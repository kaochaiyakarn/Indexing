controlling ects andrzej filinski may cmu cs school computer science carnegie mellon university pittsburgh pa submitted partial ful llment requirements degree doctor philosophy 
thesis committee robert harper chair john reynolds chair stephen brookes gordon plotkin university copyright andrzej filinski research sponsored part defense advanced research projects agency title fox project advanced development systems software contract 
research partially sponsored national science foundation 
ccr 
views contained document author interpreted representing cial policies expressed implied defense advanced research projects agency national science foundation government 
keywords monads continuations computational ects monadic re ection logical relations scheme ml 
computational ects exceptions state nondeterminism conveniently speci ed terms monads 
investigate technique uniformly adding arbitrary ects ml languages requiring structural changes programs 
monadic re ection new language construct explicitly converting back forth representations ects behavior data 
monadic re ection characterize concisely ects expressible monad give precise meaning notion simulating ect general 
isolate simple condition allowing simulation particular show monadic ect simulated continuation monad 
words relatively mild assumptions base language allowing formation suitably large answer type control universal ect 
concluding development show universal ect explicitly implemented terms standard rst class continuations call cc piece global state 
means specify effect nondeterminism abstractly terms result lists directly obtain description nondeterministic choice operator performing imperatively implemented backtracking 
include full realization general construction standard ml new jersey give programming examples 
acknowledgments wish advisors robert harper john reynolds guidance informal ideas mathematically quanti able form su ering early drafts 
insistence rigor concreteness nished sooner probably ugly hole formal development 
aws may remain nal version course 
due committee members stephen brookes gordon plotkin contributed useful insights 
thinking intuition deeply uenced number graduate courses attended cmu especially taught stephen brookes robert harper peter lee frank pfenning john reynolds gave put aspect thesis 
people provided helpful comments previous version including notably olivier danvy matthias felleisen julia lawall greg morrisett amr sabry phil wadler 
numerous mention provided bits pieces advice insights helped get detail just right 
prompt ective help various administrative want sharon burks catherine monika linda melville karen saved countless hours ghting practical problems ord time 
am grateful number friends ered encouragement support endeavor including lars birkedal prasad chalasani rowan davies kevin lynch greg morrisett mark wheeler chi wong especially olivier danvy chen lee 
course greatest go parents faith ii andrzej filinski edinburgh scotland may contents ects functional languages 
ects data 
ects behavior 
uni ed view 
monads monadic re ection 
overview thesis 
programming monadic ects base language 
terminology 
base syntax 
denotational semantics 
generalized 
equational properties 
encodings implicitly sequenced languages 
monads computational setting 
framework ects 
rigidity 
de nable monads 
extending language ects 
monadic translation 
induced equational theory 
related 
relating ects simulating monadic ects 
monad morphisms 
variant translation 
proof setting 
implementation language 
admissible relations 
computation extension relations 
simulation proof 
overview 
iii iv contents relating standard terms 
relating computational structure 
relating monads continuation passing 
factorizing variant translation 
induced relational correspondence 
related 
implementing continuation ects continuation re ection composable continuations 
level erasure 
composable continuations escapes state 
re tying recursive knot 
continuation state language 
putting 
ml implementation examples 
composable continuations 
monadic re ection 
example exceptions 
example state 
example nondeterminism 
example probability 
example continuations 
related 
summary 

closing remarks 
properties predomain model recursive type de nitions 
admissible relations 
isomorphisms recursive types 
invariant relations recursive types 
bibliography chapter chapter cover general background motivation described document 
brief discussion popular conceptual models programming computational ects introduce new approach ways combines best aspects 
give informal overview approach sketch concrete results obtained chapters 
ects functional languages important topic eld programming language semantics study computational ects 
informally ect deviation intuitive characterization program fragment representing simple function inputs outputs 
examples numerous including familiar concepts partiality exceptions state computational complexity nondeterminism concurrency 
treatment ects particularly interesting context modern functional programming languages standard ml haskell 
languages relatively simple tractable mathematical descriptions amenable formal analysis 
fact basic model computation precisely de nition evaluation functions opposed sequential execution program instructions 
aspects functional programming usefully captured simple declarative model natural formulation non trivial programming tasks tends involve occasional uses imperative concepts convenience expressing algorithm interaction outside world 
challenge admit possibility ects retaining possible appealing properties functional programming 
problem course new somewhat surprisingly distinct schools thought evolved best proceed exempli ed treatment ects purely functional languages miranda haskell versus algorithmic functional ones scheme ml 
remainder section brie presents contrasts approaches introduces basic thesis underlying dissertation integrate key ideas framework obtain model specifying ects combines best worlds 
chapter 
ects data basic ideas denotational semantics originally proposed signi cant challenge demonstrate mathematical model computation pure functions adequately model apparently non functional time important constructs existing programming languages 
striking example continuation functions modeling unstructured control constructs gotos sw rey simpler techniques su ced concepts state exceptions 
close metalanguage denotational semantics concise notation specifying continuous functions domains actual functional programming languages 
fortunate consequence appropriately expressed denotational de nition directly executed get interpreter de ned language rey 
fact techniques pioneered denotational semantics quickly adopted functional programs reasonable sense language processors 
speci cally denotational representation computational ect leads characteristic pattern style functional programs ect 
example global store modeled functionally passing additional store argument function returning function possibly updated store resulting speci cation commonly said expressed state passing style 
similarly exceptions modeled tagging function return value normal exceptional caller function explicitly check propagate exceptions exception passing style 
best known continuationpassing style cps passes function explicit representation remainder computation invoked result function rey fis plo 
techniques modeling computational ects share similar feel di er substantially details 
remarkable observation moggi seen particular instance generic schema parameterized monad simple concept category theory mog 
meant theory computational ects derived abstractly speci notion ect 
take long idea migrate mathematical semantics mainstream functional programming 
wadler wad wad pw established monadic style practical technique structuring purely functional programs way reasonably conveniently express program internal ects exceptions state external ones foreign function interfaces monadic 
bene ts denotational speci cation ect substantial get concise precise characterization program fragment behave 
example language exceptions non termination ects meaning integer returning computation meta language value type wherex xed domain exception names 
immediately tells evaluation expression possible 
effects functional languages outcomes returns number raises exception diverges 
example simple case analysis su ces formally show evaluating expression twice equivalent duplicating result interpose arbitrary computation evaluations 
analogous considerations apply purely functional program exception passing style standard reasoning principles sum types deduce properties programs exception ects validating program transformations elimination 
hand purely functional approach problems particularly evident larger scales 
disadvantage programming ects turns choice add innocuous ect debugging output gensym facility generating unique names may rewrite substantial parts program ect passing style 
monads alleviate inconvenience somewhat allowing program structured uniformly independently ects eventually 
need explicitly re express underlying functional program monadic style fact duplicating ort preemptively possibly having add ects 
course conversion monadic style easily express programs concise notation automatically expanded monadic style explicitly source transformation implicitly interpreter 
approach problems interposing translation phase expanding monadic ects denotations ectively de ning entirely new programming language 
writing non trivial programs new language want conveniences commonly provided language environment pattern matching function de nitions static type system giving meaningful error messages module system standard library practical ort involved may larger looking core translation equations 
related logically distinct problem monadic style de nitions impose substantial overhead execution implemented compiled 
ects rare tenets functional programming infrastructure required support occasional imperative construct imposes uniform burden entire evaluation process 
example exception passing style speci cation demands subcomputation may raise exception check possibility proceed normally propagate exception rest computation 
simple realization exception passing spend large fraction time checking conditions occur rarely 
sophisticated implementation especially translation may able eliminate checks general calls unknown functions passed parameters separately compiled explicitly guarded exceptional returns 
improvements require pushing ect language chapter 
implementation providing purely functional interface relevant operations implementing ciently expressed explicitly language 
particular proposals direct implementations state languages haskell pw 
unfortunately black box approach negates main advantages denotational approach ability represent ect meanings explicitly ordinary functional constructs reasoned directly language 
signi cantly cient implementations available select ects programmer de ned application speci monads take advantage non functional implementation techniques 
ects behavior noted previous section compelling advantages denotational approach ects signi cant practical problems 
outweigh controversial issue especially alternative way treating ects programs 
approach referred loaded term impure functional programming generally neutral names behavioral operational 
basis approach program expressed terms function de nitions applications natural algorithmic reading 
speci cally fundamental principle applicative order reduction reducing argument part redex performing substitution seen specifying particular sequencing evaluations 
sequencing serve robust skeleton organizing general computational ects 
idea traced back early lisp prototypical functional language cr 
key semantic di erences distinguishing scheme purely functional language call byvalue evaluation strategy presence explicitly mutable state feature known rst class continuations 
characteristics scheme versatile language potentially signi cantly complicate reasoning programs 
problem call value state continuations inherently particularly hard reason 
simple denotational counterparts scheme program relatively easily expanded purely functional continuation passing transform 
fact need explicitly translate direct style equational theories computational calculus slightly complicated conversion mog 
situation complicated somewhat dynamic creation mutable cells dealt fh 
ease reasoning impure functional programs constant factor pure programs 
subtle reason general scheme programs harder analyze formally ect free ones set computational ects ectively xed low level powerful operations natural programming style consists encoding higher level ect abstractions imperatively terms 
effects functional languages available ects explicit ect passing 
simple example consider parameterization 
suppose places program spread separately compiled modules need access parameter supplied part initial expression evaluated 
basic approaches achieving pass parameter eventually needed store value global cell access 
program su ciently large accesses parameter su ciently infrequent second approach natural choice probably correct choice software engineering perspective 
encoding parameterization terms state ectively failed represent important fact parameter immutable 
suppose program purely functional 
style easily argue safely replaced unknown function 
admit general state optimization longer automatically valid need able making sure change global value ofp eliminate common subexpressions 
words transformation simple equational property purely functional setting best provable language ects functions calls known 
reason program explicitly embody speci cation global state modi ed initialization 
course purely functional language state solution available 
accurately ects pure language written full parameterization naturally expressed functional state passing 
wehave explicit ects anyway may aswell precise 
control ects problem course compounded 
imperative realization ects exceptions nondeterminism concurrency may practically preferable declarative counterpart explicit ect passing style price pay loss simple reasoning principles 
fact problem analyzing programs ects challenging show formally implementation ect correct 
example scheme encode control aspects ml exception facility lines code call cc current handler cell 
proof implementation agrees explicit exception passing formal de nition sml mth means trivial task 
similar considerations apply analyzing control implementations backtracking hay hdm concurrency wan code may short elegant intuitively plausible formally relating denotational speci cation success lists wad resumptions sch mog serious undertaking 
say sense purely functional programs er chapter 
pragmatic reasoning advantage impure ones penalizing ects equally discourage precise custom tailored ect representations 
impure languages hand leave unpleasant choice trading precision verbosity desired ect explicitly available decide encode terms general standard ect rewrite program explicit ect passing style 
uni ed view seen approaches advantages disadvantages 
question naturally arises way combine best features 
particular possible set things think formally informally terms precise functional denotations writing executing programs concise operational behaviors 
main goal thesis answer question 
see possible take purely functional denotational speci cation monadic ect obtain directly executable operational implementation call cc state 
fact able de ne functions converting back forth denotational behavioral views ect loss information 
fundamental idea distinguish carefully transparent opaque representations computational ect 
transparent representation explicit denotational computation may raise exception represented computation sum typed result computation state ects represented pure function old state result new state nondeterministic computation represented deterministic computation list results forth 
hand opaque representation ectively data type operations construct trivial computation value sequence computations may depend outcome 
operations realized depends particular notion ects course 
writing bulk typical program opaque representation need 
example program written monadic style bind operations structuring regardless expanded 
wish perform ect raising exception accessing store making nondeterministic choice need additional operations 
explicit ect manipulations weintroduce additional operations converting transparent opaque representations ect 
explicit representation ect value representing raised exception function modifying state list possibilities obtain corresponding opaque representation combined opaque computations usual way 
conversely equally importantly opaque representation recover transparent counterpart 
example handle exception explicitly examine sum representation computation perform appropriate action case 
determine nondeterministic subcomputation successful outcome check transparent list representation non empty 

effects functional languages distinction may rst appear particularly profound useful sketch crucial observations summarize main contributions thesis roughly corresponding 
opaque computations priori simply datatype operations value inclusion sequencing exactly forms ect backbone imperative functional language scheme ml 
language subcomputation mayhave ect 
value constant lambda abstraction special case implicitly coerced general computation 
corresponds rst operation adt opaque computations 
similarly ects compound computations implicitly sequenced call byvalue evaluation order 
example evaluated avalue nally application performed 
corresponds explicit sequencing opaque computations subsequent computations may depend values produced earlier ones 
view conversions transparent opaque representations computations provide ect introspective capability language exposing underlying notion ects matters 
operators convert computations data behavior single setting integrating views ects happening 
key requirement conversion operations sided inverses information lost switching view 
relaxing relationship transparent opaque representations identical merely isomorphic gained important model programming convenient concise ml language intuitive imperative reading permitting equational reasoning programs written purely functionally explicit ect passing 
go 
ultimate goal reasoning programs characterize observable behavior freedom choosing opaque representation ects long guarantee properly tracks transparent representation complete programs 
words need ensure representations observationally isomorphic denotationally 
explicitly addition canonical opaque representation simply encapsulates speci cation monad transparent representation may variant opaque representation di erent implementation monad 
long choose implementation monad successfully mimics speci cation counterpart program contexts reason programs opaque ects directly represented speci cation monad 
chapter 
course known property data types general 
case adt operations value inclusion sequencing implicitly invoked single subcomputation performs ects addition explicit conversions transparent opaque representations 
ciency implementation signi cant concern 
consider examples ect simulations give general characterization relationships monads satisfy order act opaque representation 
remarkable useful instance suitable assumptions monad simulated continuation monad 
particular means matter apparently complex transparent speci cation may implemented uniformly continuation passing 
adds attractiveness programming monadic ects reason programs operational behavior realized explicit ect passing potentially computationally costly declarative speci cation 
actual implementation needs incur relatively low xed cost continuation passing 
better 
nominally way simulate arbitrary monadic ects continuation monads way full implementation hypothetical ml language behavior data duality user de nable ects 
shown continuations sense universal ect need exploit property practice 
key third step note variant opaque representation ect canonical opaque representation ect induced implementation monad 
de ne ml language notion native ects directly corresponds continuation monads implementing monadic ects 
language style directly embedded language control ects 
show equally surprising result universal control ect language embedded language rst class continuations mutable global variables 
said validate informal claim scheme rationale call cc useful control abstractions implemented explicitly changing extending language cr 
correspondence ectively bridged gap denotational operational view ects reason safely terms practical familiar programming language terms 
general construction takes non trivial amount ofwork develop prove correct need perform new ect want implement 
presentation document oriented call value languages take full advantage point 
principle reason 
monads monadic reflection exploited purely functional language cient implementations ects important haskell languages scheme ones 
develop details application 
monads monadic re ection section give somewhat simpli ed monadic ects 
particular assume monad investigation represents computational ect language 
formal development chapter considers general notion computation monad serves introduce new ect top potentially existing ones 
basic idea details substantially involved 
moment ignore possibility ects introduced 
monads originate category theory concepts equivalent de nitions 
purposes variant usually known kleisli triple formulation convenient de nition preliminary monad functional language consists type type function unit function 
functionf functionf extension 
components satisfy monad laws idt fg fg category theory monad conventionally de ned terms natural transformations id satisfying certain equalities ml vi 
context functional programming corresponding operations usually referred map unit join wad :10.1.1.33.5381
easy see formulations equivalent kleisli triple determines monad tf id conversely monad determines kleisli triple assignments inverses 
terms kleisli triple monad synonymously 
simple syntactic variation kleisli triples popularized wadler wad uses binary operator denote application extended function bind ort 
continuation notation usually preferable writing chapter 
actual functional programs monadic style formulation de nition convenient purposes 
mentioned monads properly called strong monads category theory mog essentially extended need closed 
monad laws hold open terms formal de nition chapter re ect 
functional programming categorical terminology document 
monads provide uniform framework reasoning computational ects state exceptions applicative programming languages mog mog 
informally represents pure ect free computation represents computation consisting oft ects followed application result computed byt 
concrete instance may help clarify example xed type carrying exceptions inla inla fa inre inre computation type type left summand denoting successful computation ofa type right summand representing speci failure 
unit extension operations capture expected operational behavior exceptions particular evaluation function exception simply propagated 
easy check de nitions fact satisfy equations de nition 
monads structuring purely functional programs opposed language semantics quite commonplace wad pw 
course structuring techniques usually scheme languages rarely monadic style programs rely lazy evaluation fundamental way bene ts clear pure program isolated ects gensym occasional output cient easier understand glance equivalent completely pure program expressed monadic style 
interesting way explicitly monads structuring tool programs impure functional languages takes full advantage eager evaluation strategy trying ignore 
study alternative main focus thesis 
speci cally development simple functional language moggi principle computations type correspond values typet noted moggi correspondence principle embodied concrete language construct call monadic re ection analogy general notion computational re ection smi wf 
speci cally take de nition preliminary re ection monad language operators 
monads monadic reflection satisfying possibly computational ects value presence operators arises naturally monadic framework little generally said computational interpretation usefulness actual functional programming 
turns monadic re ection provides exactly need program monadic ects having rewrite code monadic style 
operational terms re computation type construct explicit representation ect perform execute passing 
conversely general rei es corresponding ect free value typet inspected analyzed inert piece data 
possible write programs re ection rei cation operators directly actual programming language typically de ne collection convenient operations terms example consider exception monad example 
express usual exception raising construct directly def lete inre expression typically just value type explicitly construct right tagged value explicit representation computations pass ect 
conversely rei es possibly exception raising value type de ne exception handling construct def case inla inre ife returns normally ignored ife raises exception handler invoked exception data general pattern matching handle construct sml easily expressed terms 
example type state monad de ned ha si ts represented pure function accepting current returning ect free computation passes state modifying reading extension rst current states resulting evaluation oft 
chapter 
re ection de ne operators updating reading state state def letv hhi vi state def hs si state ect represented function replacing state value ofe result operation state denotes ect reading current state modifying 
de nitions explicitly uses rei cation operator 
implicitly top level ife program state ects rune def ina result starting initial states discarding nal state 
simple re nement course permit state persist sequence top level evaluations interactive read eval print ml scheme 
generally ifwe take store nite map locations values de ne mutable def letv hhi sf def hs si location corresponding 
note state accessing operations export subset functionality state monad 
express general re ection rei cation store case need access rst class store mechanism 
implemented reasonably ciently version trees requiring store copied jd mor impose overhead 
example illustrates may feasible desirable export full re ection rei cation pair monad real programming language 
important analysis purposes consider fully general formulation ect terms restrictions accessible functionality viewed purely pragmatic considerations 
concerns emphasize orthogonal issue 
re ection rei cation expose exactly range ects expressible corresponding state passing formulation traditional denotational semantics language store formally enforce store singlethreaded way 
exception state monads means exhaust interesting possibilities 
examples simple monadic ects listed table encounter detail 
collection may limited considered combinations encode multiple ects 
example 
represents computations exceptions state 
combine speci cations individual ects composites non trivial problem 
develop details full generality 
overview thesis common name functor unit extension ft partiality upa fa 
exception inla fa inre inre state ha sit ts environment te complexity na ha ni list fa fan set na ang fa fan continuation oa kat table simple monads incremental approach chapter layer new ect top existing illustrates basic principle re ne de nition monad explicitly account original ects new speci cation 
overview thesis 
presents background material computational ects informally introduces notion monadic re ection bridge denotational operational view monadic ects 

programming monadic ects rst specify simple functional base language notion ambient ects partiality 
de ne monads setting show monad induces extension base language new focus ect 
specify semantics language simple somewhat impractical de nitional monadic translation back original language semantics 
task remaining chapters devise prove correct alternative implementation extended language 

relating ects contains main technical contribution thesis 
consider speci cation monad implementation monad investigate said simulate rst show data connecting de ne variant translation extended language base language ects perform ects correctness guarantees 
technical preliminaries setting proof context introduce concept monad relation show relation de nitional variant translation agree complete programs 
cases obtain required monad relation directly existence monad morphism general continuation simulation chapter 
monad involves additional twist capture parametricity properties nal answer type 
conclude chapter showing correspondence monads continuations allows de ne monadic re ection operators directly terms continuation monad su ces provide implementation language continuations notion focus ect 

completing construction implementing continuation ects shows ects corresponding continuation monad embedded scheme language 
proof broken distinct steps 
monadic ects continuations expressed terms control abstraction called composable continuations decomposed simpler control operators 
second show distinction ambient focus ects introduced de nitional monadic translation ect evaluation leaving implement language single level ects 
third show language implemented embedding language continuations state 
conclude showing concrete implementation construction programming examples 

summarizes results outlines promising directions 
chapter programming monadic ects chapter introduce simple functional programming language serve concrete framework results proofs thesis 
formally de ne notion monad setting show monad allows systematically de ne extended language ects 
base language terminology language consists 
syntax de nes sets wellformed types typed terms type means language signature set type constructors typed term constructors language phrases built inductively 
semantics assigns notion meaning terms 
practical minimum expect semantics provide notion program evaluation partial function suitable subset ofl terms closed terms base type set observable results say natural numbers 
evaluation semantics induces notion observational equivalence terms terms considered equivalent substituted program context changing observable outcome program 
easy see relation terms fact congruence wrt 
term constructors language 
denotational semantics provides model 
type set meanings terms type term constructor meaning constructed term expressed function meanings subterms 
particular provides notion equality denotational equivalence terms equal denote element model compositionality requirement denotational equivalence likewise congruence 
terms may observationally equivalent denotationally usually simpler reason denotational equivalence 
obtain evaluation semantics denotational semantics de ning function meanings closed terms observable results 
example denotation program element domain 
lifted natural numbers chapter 
programming monadic effects induced evaluation semantics simply evident partial function mapping lifted natural number unde ned element domain 
di erent semantics syntax say direct continuation may determine evaluation semantics notion observational equivalence induce di erent notions denotational equivalence 
say language member language class class lambda calculi signature contains speci ed set type constructors product function space term constructors abstraction application meanings types terms equational constraints congruences conversion 
result entire class languages holds generically model equations 
base syntax concrete language doing formal development 
syntax semantics similar pcf plo pcf lifted types mit ect structure explicit 
ect pcf 
syntax informal operational interpretation section precise denotational semantics 
ect pcf somewhat verbose typical practical programming language computation sequencing explicit syntax 
example application function argument explicitly evaluated values 
worked ml cbv language directly general treatment monadic ects awkward sequencing left implicit 
formulation allows cleanly separate handling ects purely functional structure exponentials products 
simple ect independent elaboration standard ml syntax ect pcf view implicit sequencing computations callby value languages merely convenient shorthand corresponding ect pcf terms 
return elaboration section 
base signature displayed 
type structure notable characteristic syntax division types classes value types subset called generalized computation types 
operational signi cance division possibility ects explicit types separating trivial manifestly ect free serious computations 
value types properly include computation types possibility value unevaluated computation represented value type example closed expression type equivalent numeral general expression expected yield natural number may diverge ect type 
base language types terms ajj xj ifz ij case jx jmj letx inm xm typing type xn distinct 
sm mz ms ifz hi hm fstm case 
hm 
fstm letx inm base signature 
xm chapter 
programming monadic effects computation type conveniently thought computation parameterized value function values computations 
particular arrow type actual evaluation occurs parameters 
similarly computation type viewed single computation parameterized choice component evaluate unrelated computations 
case type re ected isomorphism 
product type constructors value types computation types 
typing equational properties identical standard semantics interpreted cpo constructor variants logically distinct 
generally omit superscripts clear meant factors avalue type context requires computation type 
analogous consideration apply unit type course simply assume types identical unduly constraining semantics 
set value types includes countable set type variables 
type variables computation types 
fa ang nite set type variables write type ctype type variables occurring free case say type clearly type ctype 
say type closed empty 
atype determines type family consisting types obtained substituting closed types type variables note constructs language explicitly binding type variables 
extension ofl recursively de ned types section canonical model language category cpos predomains continuous functions computation types interpreted pointed cpos operator types corresponding lifting 
see section details 
terms term structure associated typing rules conventional 
similarly parameterization types type variables write type variables occurring free listed mis said term called type closed empty set type closed instances term forms term family 
complementing operator types term constructs ect free computation letx inm constructs computation consisting andm sequence second evaluation bound result rst 
computation treated rst class 
base language object performed value explicitly requested directly top level program evaluation evaluation enclosing 
generally omit type tags terms clear context 
occasionally pattern matching syntax lambda bindings usual expansions inm def letx inm fv note projections considered trivial typing rules result substitution typed 
constructs associated type allow program natural numbers zero constant successor function combined zero test predecessor operation 
general recursion construct standard arithmetic operations primitives 
example de ne addition plus 
hn 
ifz letr fn sr note result addition computation addition function happens total 
course extend language additional primitives arithmetic primitive recursion construct pure value types 
having xed points computation types allows express mutual recursion easily asin fst oi hn ifz inl hi ifz inr hi en def boolean values 
hand write term corresponding xed point pure successor function type expressible language 
write letn sn surprisingly denotes diverging computation intended interpretation 
occasionally standard abbreviations id 




id def def 
def id andn def denotational semantics program base language closed term type semantics term equivalent ton program denotes successful computation result diverging computation 
denotational semantics gives meaning complete program induction syntactic structure 
chapter 
programming monadic effects preliminaries give simple model base language setting cpos called pre domains complete partial orders necessarily having element 
completeness review associated terminology constructions 
de nition set equipped complete partial countable va elements upper bound written iai 
monotone order preserving function called continuous chain ai 
iai ai 
called pointed element function pointed andb called strict iff 
name domain synonymously pointed cpo 
number standard cpos cpo constructions base types 
set natural numbers organized cpo equipping discrete ordering unit type 
element set fg trivially cpo 
pointed 
products cartesian product cpos ordered componentwise va ia va anda va 
ifb andb pointed isb 
sums disjoint union cpos note separated sum standard domain theoretic notation ja ja ordered inject wise va ii cpo general pointed summands 
function space cpo continuous functions toa va 
minimize confusion abstraction application language andf abstraction application cpo model pointed lifting 
de ne lifted cpo 
ag ordered fa 
write 
naturally pointed 
strict extension functionf functionf andf 
generally forany andf maps tof re exive types 
cpo model allows construct solutions isomorphism recursive type equations 
need immediately important section 

base language nite seti write iai indexed product cpos set functions iai ai 
function usually called environment 
environments naturally ordered pointwise 
vai write empty environment fi may may member ofi function toa ai function restricted 
base ects give semantics language predomain model rst need choose notion base ambient ects denoted constructor 
canonical example ect partiality structure proofs largely independent exact choice need show satis es simple relational properties 
treat case partiality formally setup generalizes ambient ects appropriate 
develop semantics ambient ects detail possible convenient treat ambient ects uniformly monadic translations introduced little 
reason considering complicated base ects model language features eliminated source source transform 
example true non determinism opposed nitary variant de ned backtracking transformation modelled powerdomain similar construct 
similarly notion operations extra linguistic ects accounted semantics source level 
treat formally 
de nition ambient ect monad cpo semantics data cpo ta pointed cpo 
family continuous functions ta 
assignment continuous functionf ta continuous function ta ta assignment continuous satisfy equality ifi components satisfy monad laws idt afg fg de nition partiality semantics 
pointed required andf strict de nition 
easy check monad laws hold triple 
incidentally requirement thatf strict ensures ta monad morphism partiality monad tot phrase general terms de nitions example chapter 
programming monadic effects semantics types formed type assign cpo ctype pointed cpo 
semantics terms typed assign xi sm ifz mz ms mz ms hi hm fstm case letx inm xm anyi th iterate andf 
denotational base language 
base language examples easily adapted source level monads section example obtain notion ambient state cf 
example 
de nable ambient ects conveniently dealt syntactic level explicit monadic translation 
explicitly accessible ect base language divergence useful consider general ect structures semantics 
example continuation semantics may interest language contain explicit control operators 
give denotational semantics base language parameterized choice ect structure 
nite set type variables variables cpos 
semantics assigns type pointed computational term continuous xi tol 
usually omit clear context 
particular language constructs binding type variables stays constant semantic equations omitted gure reduce clutter 
denotational semantics assigns meanings types terms arbitrary interpreting type variables arbitrary cpos purposes generality syntactic substitutions closed types type variables su ce 
uses parameterized semantics showing syntactic monad may express semantic proposition introducing ned types section 
generalized de nition computation type ofl de ne derived generalized typing rule induction structure letx inm letx inm letx inm inm hi inm fstm inm letx inm predomain semantics particular consequences de nition letx inm 
case partiality semantics fact possibilities 
obtain natural generalization existing strict extension chapter 
programming monadic effects type interpreted pointed cpo necessarily directly lifted 
note need type general computation type strictness sense arbitrary pointed cpos strict extension operation extend toa arbitrary 
important note di erence say computation returning pair integers wherem evaluated exactly yielding pair numbers construction pair computations letx wherem evaluated component result requested 
similarly distinguish diverging computation function 

successful computation yielding function diverges inputs equational properties 

xed clear context preferable reason programs level terms explicitly denotations semantics 
generally isolate set reasoning principles hold large variety interpretations check speci es principles 
mentioned purposes su ce consider equational properties type closed terms free type variables extend naturally type term families nonempty set type variables 
de nition set type term constructors 
type type ofl set val term nite function xi xi val element int val 
equational set typed equalities type closed model equational theory interpretation satis es equations theory environment int int provable elements val 
clear predomain semantics notion ambient determines interpretation ofl val set int asl forgetting continuity ofl function environments values 
equational simultaneously argue predomain interpretation model theory 
particular classes additional equations 
base language may axiomatizable example ambient ects commutative idempotent consider extensions 
cases axioms listed immediately veri ed referring semantics omit details easily lled 
equality judgments type closed terms omit implicit typing assumptions rules 
lemma andm weakening substitution principles hold proof 
routine induction onm 
nx ifx fv xg lemma veri cation equations straightforward 
congruences substitutions denotational assumption notion equivalence inherently congruence wrt 
term constructors language 
general principles closure weakening substitution follow directly lemma nx nx xg fm xg xg 

fm xg natural numbers mz ms ifz mz ms mz unit type mz ms ifz sm mz ms xg ifz fz xg xg fm xg hi terminal object 
note equation means value type may di erent computations value terms type 
partiality case closed terms termination hi divergence 

chapter 
programming monadic effects products symm symm products categorical sense 
predomain semantics notions products interpreted object require general 
sums case fm symm case xg xg fm xg sums coproducts categorical sense 
veri cation rst law immediate lemma 
second rely fact thatl value form equation sound interpreted separated sum andm denoted diverging computation 
useful consequence equations necessarily denoting strict function case case fm xg case case case case hm hm function space fm xg 
mx 
categorically exponentiation require existence exponentiations arbitrary codomain types category types terms quite ccc 
computations letx inm fm xg letx inx letx letx inm inm letx letx inm corresponds directly monad equations governing ambient ect monad 
example rst verify letx inm 
base language fixed points 
xm xm su ces evaluation general formal reasoning need additional properties details covered chapter 
results thesis depend xed point equation ine principle safely omit ecting correctness 
established proposition ambient ect monad predomain model ofe equational theory generated inference rules listed 
encodings implicitly sequenced languages actual programming languages explicit syntactic typing distinction values general terms 
grammar types terms form 
xj ij inre case jx eje xe trivial serious computations priori occupying type 
explicitly sequenced syntax simpli es formal manipulation programs somewhat inconvenient actual programming 
common practice relatively uncommon see applications forme ande ects particular evaluation ofe rarely ects 
typical programs ml languages sequencing left implicit burdensome force explicitly sequenced 
fortunately treat compact general syntax merely shorthand explicitly sequenced terms programs rst desugared elaborated sequenced form operational denotational semantics 
elaborations leading call value cbv call name cbn interpretation implicitly sequenced language 
cbv translation types 
type cbv language ofl 


chapter 
programming monadic effects translation terms 
source language inl se letx sx ifz ez es letn ifz ez es hi hi letx letx letx letx letx inre letx case letx case letf leta xe letf vf ff inf cbv functional type computation type 
allow product computation types context mutually recursive de nitions interpret computation product explicit necessary type 

syntactically 
example get validity beta value reduction letf leta letf leta fm xg xg similarly general ex letf infx 
equality 
cbn gives language essentially identical pcf product sum types 
type translation 


monads computational setting interpretation type computational form exponentials pair types exponentials source language forms ccc 
elaboration composed predomain semantics type interpreted proper domain fact partiality semantics gives exactly standard domain theoretic model pcf 
translation terms 
source language inl 
se letx sx ifz nn ifz fx xg hi hi fst snd inl inre inr case nx case xe xed points source types including note numbers represented domain opposed lazy natural numbers include partially de ned values 
monads computational setting section formal de nition monads suitable language notion ambient ects 
de nition phrased terms basic concepts need introduce rst 
framework ects ultimate goal line research framework computational ects possible describe ects modular way 
speci cally wewant ability add ects incrementally resulting language speci ed sequence de nitional translations translates away level ects 
example language exceptions state speci ed composition exception passing state passing transform 
consider level case notion ambient ects possibly combination primitive ones speci ed semantic chapter 
programming monadic effects monadt denotational semantics focus ect speci ed syntactic monad order de ne notion monad interacts suitable way ambient ects need amount structure language 
provides need de nition say language computational lambda language cll class computation types forming necessarily proper subset types properties computations type set computation types closed nite products function spaces arbitrary domain type ctype ctype ctype ctype ctype type ctype ctype write type ctype types set type variables assign meaning types nonempty 
terms term constructors letx inm variables computation inclusions generalized term constructors products function spaces 
write term necessarily meaning 
equations hold type closed terms letx inm fm xg letx inx letx inm inm letx letx inm congruence substitution rules axioms unit products functions listed section 
nally generalized satisfy necessarily directly de nition equations de nition 
example cll type exists computation type 
note slightly stronger requirement moggi st exponentials mog guaranteed existence function spaces form 

weaker notion take computation types exactly set types form requiring computation types closed products especially function spaces allow give uniform treatment de nable computational ects 

monads computational setting proposition base language equations section organized cll de ning inductively de nition 
proof 
need verify equational properties generalized hold de nition 
proof simple induction show sample cases similar 
inm fstm ih fstm fm xg fm fstm ifm xg fm xg inm inm letx inm inm ih letx letx inm letx letx inm letx inm inm ways constructing computation types may possible depending actual set types available 
example language explicit polymorphism natural take extended accordingly 
lack better name say computational language ect free type case cll requirements degenerate ccc 
ect freeness confused existence type 
associated abstraction application operations 
concrete ect free languages concept mainly show various de nitions results reduce familiar counterparts existing monads computational ects 
essence generalized computation type expressed simply existence function satisfying equations 
def letx inx letx inx letx category theoretic terms says structure map algebra monad underlying ml vi 
speci cally function de ne generalized operator letx inm letx inm generalized formulation convenient equational properties natural generalization existing formalized de nition 
remember generalized equivalently characterized uniquely de nition 
chapter 
programming monadic effects applications generalized operation de ne simple ect theoretic generalization strictness turn plays key role de nition monads 
rigidity de nition say aterm 
cll rigid function computation types write letx inx rigidity purely equational property distinguish provable rigidity equation derivable equational theory semantic rigidity equation holds model implies 
immediate consequence de nition get lemma application rigid function moved arbitrary binding letx inm derivable ine true model 
proof 
simple veri cation letx inm letx letx inm letx inm mg letx inm mg letx inm application rigidity ofm 
particular 
mm letx inx letx inm operationally says argument rigid function evaluated call result coerced trivial computation nominal cbn evaluation parameters type 
usually property associated strictness 
proposition predomain model base language rigid function necessarily strict 
particular case partiality semantics converse holds strict function rigid 

monads computational setting proof 
easy check equational reasoning principle letx 
inm 
strict andl 

leth 
rigid function 

letx 


inh 
conversely strict letm possibilities form 
letx inx letx 
inx 

letx inx letx inx hb general function rigid uses argument exactly serious computation 
particular case partiality function 

model quali es rigid explicitly argument 
easy check identity composition rigid functions rigid fst snd fa andx leta 
likewise iff andf rigid hf xi rigid fax 
known properties strictness hold general rigidity 
ect free case function trivially rigid 
alternative equivalent characterization rigidity 
natural functorial action mapping functionf 

letx fx recall de ne 
letx inx functionf 
rigid iff morphism corresponding algebras letx fx letx fx fx infx letx inx chapter 
programming monadic effects de nable monads notion monad language consists semantic aspect 
syntactically exhibit type term families semantically establish certain equational properties hold terms inl necessarily particular equational theory 
separation important eventually consider interpretations semantics necessarily satisfy monad laws 
type type inl substitution closed types variables fg closed type ofl 
particular type may occur identi ed type schema fag type 
analogously term determines type closed term fg fg 
give formal de nition monad kleisli triple formulation de nition signature cll 
monad triple items computation type constructor ctype 
fort af ag 
term family unit functions instances term fag write af ag 
term family extension operators fa gf strictly speaking type indexed omit type indices 
triple actual monad cll equations hold closed type instances 

idt fg fg 
note equational condition expansion de nition 
conditions cover equations non variable terms asm closure substitution terms variables 
de nition akin monad constructor simple monad necessary information composition implicit representation monad computational language 
refer monad monad laws required hold opposed provable equational theory 
course showing monad laws equational theory su cient establish model theory 
note condition sense andt required computation types 
ect free rigidity requirement vacuous de nition reduces ordinary monad 
important concrete language rigidity implies strictness rigidity requirement forf merely domain theoretic reasons 
monads computational setting crucial composing ects general purely settheoretic formulation composable monads setting general recursion 
practice natural monad extensions rigid anyway 
example identity simplest possible monad de nable cll leta veri cation monad laws straightforward 
identity monad degenerate case example obtain specializing exception monad type values possibility raising exception state monad atype value information free state 
example exceptions xed type exception names exn sml 
obtain monad inla letv case fa inre completeness show complete veri cation slightly involved exception monad ect free language lett inx letv inx case fa inre letx letv case fa inre infx letv inla case fa inre case inla fa inre fa letv case inla inre letv inv id gf ft letv case fa inre letv ing case fa inre letv case fa inre letv case fa inre case gb inre letv case fa case inre gb inre letv case fa inre fa gf note type term constructors image cbn translation exceptions form monad language haskell language level sum type separated sum domain terminology 
example state type 
state monad de ned 
ha si ts veri cation fairly simple lett inx ha inx ha letx ha xs letx infx chapter 
programming monadic effects ha ha si ha ha si fst ha si snd ha si fas fa ha ts ha si ha ts ha ts inp ts id gf ft ha ts hb ha ts ha ts hb fas ha ts ing fa ha ts fa fa gf practically useful monads monads model equational important reasons require monad laws hold respect speci interpretations 
monad components may de ned arbitrarily hard show monad triple monad su cient 
validate equational properties frequently proofs results rely monad laws particular monads provable ine 
second fundamental reason certain useful notions computation form monads presence arbitrary ambient ects 
best known example kw list monadt list model nondeterminism 
turns monad ambient ects commutative equation letx letx inm letx letx inm occurs free holds inl 
partiality satis es equation possible notions ambient ects state continuations 
examples fragile monads require ambient ects idempotent property shared ects partiality 
distinguishing satisfaction monad laws equational theory speci model partiality semantics results applicable list monads robust ones exceptions state satisfy monad laws notion ambient ect 
nally note semantics assigns meaning type open types terms stronger de nition monad possible de nition monad predomain interpretation said uniform equations hold type open terms 
monad laws de nition allow types terms contain type variables assigns cpo xi xi thenl elements ofl state simple consequence 
extending language effects proposition uniform monad predomain semantics notion ambient ect 
determines new ambient ect monad sense de nition 
ta 


proof 
rst note computation types interpreted pointed cpos ta pointed required 
similarly arrow types interpreted continuous function spaces andf continuous function environments values proposition get strictness rigidity ofx veri cation monad laws straightforward uniformity oft 
usually need modify semantic characterization ambient ects explicitly de ne language new notion ambient ects iterated monadic translation case su cient monad laws hold type closed instances 
extending language ects monadic translation show monad language allows de ne new language richer set computational ects 
de nition monad triple cll 
consists new computation type constructor new term constructors type ctype letx inm letx inm note overload syntactic construct represent distinct term constructors existing wherem new de ned wherem 
clear context meant 
chapter 
programming monadic effects basic notions computation original partiality ects raising exceptions 
set computation types closed products function spaces 
extended signature merely unstructured set types type constructor type constructor ofl particular type awell type 
generalized binding results computations de nable computation types new clause mixed level 
re ection rei cation establish correspondence opaque transparent representation computations opaque computations may constructed sequenced manipulated full range operations available typet injections case analysis see example 
extension de ne canonical de nitional translation extended signature back original 
dealing source source translations introduce shorthand de nition translation convention specifying translation share lot operations generally omit clauses form xn xn construct translated named construct inl 
occasionally include selected clauses form emphasis clarity formal distinction attached clause included 
de nition monadic translation maps types terms ofl counterparts type inl type inl 
ctype inl ctype inl 
inl inl 
translation types merely replaces de nitional expansion type constructors left intact type variables 
similarly term translation expands away new term constructors letx inm letx inm variables term constructors type annotations expanded type translation 

extending language effects monadic translation simply de nitional extension full syntactic transformation adopt translation formulation get explicit syntactic handle expansion 
particular consider alternative ways translating away new constructs ofl convenient concise notation referring di erent expansions 
note type term variables translated translations compositional sense particular ag tf ag xg tf xg af ag tf ag af ag likewise term translations monad components implicit type tags appropriately translated 
translation mixed may need little explanation 
consider case state monad base ect partiality 
extended language evaluation ofm may diverge state ects take state argument return new state 
hand may diverge access store 
translation ofm passed current state new state returns state returned expression 
appropriate state passing translation letx inm letx ts precisely generalized expands 
generally easy check derived rule anl computation type may contain letx inm de nitional translation opaque computations represented type consequently term translations re ection rei cation trivial 
consider di erent representation ects operators interesting de nitions 
syntactic translation determines semantics de nition base obtain semantics extended andl fact semantics extends standard monadic semantics new ambiente ect monad induced chapter 
programming monadic effects proposition semantics ofl underlying ambiente ect monad uniform monad semantics de nition syntactic transformation replacing types terms thenl jj lt types terms monadic semantics ambient ect monadt interpreting components shown proposition 
proof 
induction structure types terms 
cases immediate computations get ag 

ih 
lt lt lt jmj jmj jmj jmj jmj af ag jmj 
jmj 
jmj ih 
lt lt lt lt lt case letx inm similar 
similarly evaluation semantics computable partial function terms type natural numbers get evaluation semantics 
directly regardless oft translation term type term type worth remarking identity monad ft leta translation ectively replaces occurrences source term letx inm leta letx letx inm exhibit relation translation monadic translation continuation monad get relation direct continuation passing style presence arbitrary su ciently behaved ambient ects simply identity monad 
de speci operators re ection rei cation primitives allow de ne meanings terms abbreviations extended language additional clauses translation equations 
example exception monad de ne usual ml exception primitives 
extending language effects follows def lete inre def lett case raise exception explicitly construct sum representation value right inject activate re ecting process computation 
conversely handle potential exception rst inspect appropriate action possibilities normal exceptional value 
fact expanding de nitions monadic translation gives expected results lete inre inre lett case inre inre lett case inre inre lett case lett case lett case inla induced equational theory translation induces natural equational theory terms extended language de nition equational including cll axioms monad triple inl equational consists ofe extended rules write ix im inm fm xg inm inm inm letx inm letx inm rst rules part ofe 
chapter 
programming monadic effects proposition equational theory sound monadic translation sense ifm provable ine provable ine extended monad laws may may provable ine 
implies thatl monad 
proof 
simple equational reasoning proposition derivable equational properties generalized 
example letx inm xg fm xg letx inm xg fm xg letx letx inm inm letx letx letx inm letx letx inm inm letx letx inm rst rules de nition say elimination attening valid mixed levels long types match 
single notion computation sequencing shared ects level tags merely keep track kinds ects happen 
express re ection rei cation exact inverses 
example exception case correspondence dynamic computations type may raise exceptions static exception free values type 
remaining equations show acts shallow version monadic translation 
rst terms ambient ects una ected rei cation focus ect may move barrier freely 
example ambient ect state focus ect exceptions computation raise exception moved try handle 
equation necessarily satis ed base language ect free case simply substitution ofm 
nal rules explicit computations realized terms monad operations enabling reason locally propagation ects entirely extended language level 
rules case lhs type correct rhs 
equations left right worrying type preservation 
simple consequence proposition get 
related corollary translation replacing occurrence jt types terms model ofe 
ofl jt lt jj model ofe particular computational lambda language 
proof 
equations numbers products sums functions xed points follow immediately translation 
computations rst rules ofe proposition 
note implicitly asserts form easy see equalities leta fa derivable monad laws andf follow leta fa leta fa leta fa fa fa rigidity lett inx leta inx leta fa leta letx fa fa leta letx fa letx leta fa lett leta fa infx example extended language equations verify rule exceptions lett case lete inre lett case lett case inla lett lett lett lett int identity crucial pattern matching exception handlers exception implicitly re raised match clauses handler want ensure handler ect result program 
related combining monadic ects mog kw cm ste esp varying degrees generality formality 
approaches particularly concerned nonstandard implementations chapter 
programming monadic effects newly speci ed ects ectively interpret programs modular speci cation directly signi cant cost execution time 
framework outlined level case generalizes multiple explicitly speci ed ects full re ection rei cation operator 
primary notion layered ect ensure simulated strong sense continuation passing escapes state detailed chapters 
consequently broader modularity aspects approach properly developed 
chapter relating ects part continuation folklore continuations provide general notion ects partiality exceptions state expressed continuation semantics suitable answer type 
presence higher order functions proving correctness continuation simulation decidedly non trivial rey sto mw purely functional language partiality asthe notion computational ect 
chapter consider relationship direct continuation semantics arbitrary monadic ects 
fact continuation semantics conveniently cast monadic mold making result particular instance simulating monadic ect 
continuation passing case especially complicated signi cant part proof consists establishing general framework necessary lemmas case 
broadly general idea follows assume monads base language suitable sense general give di erent translations tol original monadic translation variant translation representations oft ects 
exhibit type indexed family relations property translations term type related relation base types identity 
translations induce evaluation semantics 
simulating monadic ects section general principle relating ects introduce variant translation argue informally correctness 
actual simulation proof postponed section 
monad morphisms natural way relating monads consists exhibiting function mapping chapter 
relating effects de nition monads cll 
de nable monad morphism type indexed family ofl terms fag ua respecting monad structure holds closed types 
think representations ects tou representations 
condition technical constraint ensuring essentially conversion focus ects respects underlying ambient ects example computation represented computation 
explicitly says computation mapped computation 
condition may look somewhat arbitrary rst note written form conditional equality emphasizing parallel wheref andg 
expresses requirement converting output equivalent applying conversion input 
example monad function family monad morphism identity monad example letx inx letx inx ft leta leta leta leta leta fa leta inh fa leta hf hf leta hf ht fact morphism 
immediate base language ect free condition id holds general suppose monad morphism letx inx ht 
simulating monadic effects captures intuitive notion ect simulate absence ects probably consider minimal requirement notion ect simulation 
interesting example provided example simplicity assume base language includes term constructor 
satisfying equations andm model forms monoid 
course de ned addition operator existing language recursion necessarily give type 
cluttering terms explicit sequencing additions 
easy check correctly de ned 
determines monad usually called complexity monad ha fa computation type represented base computation yielding value type notion cost involved computing number oating point operations performed encoding numbers terms amount assuming ambient ects include notion communication outside world 
trivial computation resulting viewing value computation zero cost cost sum computing cost ata 
complexity monad works summing complexities subcomputation 
subcomputations invoke operation counted potentially wasteful adding zeros time 
important complexity fairly ad hoc monad perform actual translation get monadic ects 
alternative way track complexity maintain running total updated cost incurring operations passively transmitted 
achieve state monad example 
ha si represent computation function current total addition 
fact monad morphism ni ni chapter 
relating effects formally de ne avery important class monads de nition computation type 
continuation monad answer ko ko ko ka easy check determines monad 
rigidity wehave inx inx inx inf xk inf satisfaction equations completely straightforward 
importance continuation monads stems property lemma monad computational language arbitrary type necessarily computational 
take kt continuation monad answer typet family functions forms monad morphism proof 
straightforward veri cation kt tt int tt int ka ft ft fa fa fa fa ak fa equations marked signify application monad laws de nition 
identity monad necessarily degenerates instance example 
interestingly example exceptions monad morphism kt specializes 
letv case ka inre recall representation successful computation type included left inject corresponding continuation passing computation immediately apply continuation toa 
fact inla letv inla case ka inre case inla ka inre ka 
simulating monadic effects similarly computation terminates raised represented value right inject continuation passing analog simply discards current continuation returns exceptional value result inre letv inre case ka inre case inre ka inre inre nally nonterminating computation represented non terminating computation continuation 
letv 
case ka inre 
monad morphism arbitrary monad continuation monad kt form core simulation result 
fact representation sense parametric choice captured equationally setting 
possible language polymorphism gir rey 
formal proof section need stronger relational characterization accurately express property 
variant translation section show exploit existence monad morphism properties simulate kind ects 
speci cally show interpret enriched ect language terms ofu ects 
exposition slightly simpli ed consider single semantics base language actual proof section distinguishes speci cation implementation semantics get result su cient strength support chapter 
formal de nitions give general cases 
motivated previous section monad morphisms give simple way relating notions ects 
monad morphism guarantee ects ects useful sense 
example unique monad morphism degenerate monad hi id 
proper simulation need way recover representation ect representation de nition monad morphism monad retraction type left inverse term idt say retraction schematic members term family af ag 
usually expect exist gives way extracting meanings complete programs 
cases easy nd suitable inverse types example complexity state simulation example particular monad morphism ni ni chapter 
relating effects 
determines monad retraction types 
extract complexity computation state passing representation simply initialize state zero perform computation read complexity asthe nal state 
easy see schematic left inverse monad morphism meaningful sense simulate arbitrary computations complexity ects 
terms typed monad morphisms retractions give adi erent translation ect enriched back au representation oft ects representation de nitional translation 
de ne translation course need assume equational properties terms involved de nition inl monad triples family terms type set nite nite ofl types term bel rei cation restricted types 
de ne variant implementation translation follows 
types take type translation terms letx inm letx inm write emphasize re ection rei cation operators fort 
de nitional translation de nition easily seen preserve types inl inl 
course idt trivially monad morphism schematic retraction get exactly original translation special case 
general transparent opaque representations computation ects di erent 
representation ect au representation ts rest passing translation 
conversely rei cation externalize representation de representation ect 
de nitional variant translation type general di erent agree base types particular results transforming complete 
simulating monadic effects programs closed terms type directly comparable 
fact show translations term type equal partiality semantics appropriately related notions ambient ects 
monad continuation case monad morphism lemma obvious de ne general 
see section achieve 
purposes section simply restrict rei cation type opposed types standard translation allows 
take fg 
continuation monad answer typet directly take gives kt kt monad retraction example lett exception monad continuation kt 
example 
case translation equations specialize letx inm letx inm lett case ka inre inla third equation de nition expand generalized de nition 
continuation passing analogs raise handle expansions example lete inre inre tk lett inre case ka inre lett inre case ka inre case inre ka inre inre lett case lett case lett inla case ka lett inla case ka handle expressions type 
match operational intuition raise exception determined simply return name directly answer tagged right inject enclosing handle tell di erence 
conversely handle potential exception inm invoke left injection continuation 
ifm returns normally returning inla pass continuation handle 
hand ifm raises returns inre toe control context handle 
chapter 
relating effects comparison suppose restrictions rei cation issue example content allow uses handle single base type entirely unreasonable restriction raise types 
fairly simple correspondence direct continuation passing de nitions exceptions reasonably ask formalize translation simply take continuation cial de nition exceptions 
view exceptions simply syntactic sugar corresponding continuation ects 
problem cps translation satisfy desirable equational reasoning principles pure exception passing 
example consider reasoning principle saw example translation veri es law provable continuation semantics get lett case lett case lett case ka lett case ka lett inla case ka easy check fact hold ka corresponding ect free computation ofa 
similarly equation satis ed inre corresponding computation raising 
representing non terminating computation terms equal denotations 
simple guarantee fact forms especially may call unknown function 
example consider case element 
inl call computation represents normal value raised exception divergence 
fact inl desired reasoning principle fails get inl presence computations means derive identity directly model need elaborate argument involving induction syntactic terms language complicated presence higher order functions 
analogous situation holds complexity state simulation example 
easy see ambient ects commutative ects de ned complexity monad 
general state passing hand commutative lose useful equational property specifying complexity ects directly terms state passing 
mean inherently presents problem formal reasoning 
recall show independently translation translation agree programs 
equations induced translation de nition valid observational equivalence inl 
proof setting evaluation semantics induced translations reason ects terms relatively speci cation implementation 
particular case exceptions construct adhoc continuation semantics translation takes normal continuation type type invoking whichever appropriate 
translation verify handle re raise equation problem choice answer type 
requires translation equations modi ed pass extra continuation standard cps transform bulk language 
importantly continuations trick generalize relies isomorphism counterpart monadic ects 
proof setting section establishes general framework simulation proof section 
material relatively standard consequently relegated appendix 
implementation language base need tightly constrained rely induction types terms proof 
target language variant translation hand need restricted simple types 
fact obtain simulation result continuations full generality need structure predomain model implementation language 
accordingly de ne required extensions expressing weak notion nitary sums recursively de ned types 
embedding types rei cation continuations need embed di erent types single type answers 
suitable construct expressing de nition new type constructor type type countable family ofl types possibly repetitions usually abbreviate 
associated term constructors chapter 
relating effects injecting projecting embedding type 
correspondingly extends equations de ne derived term constructor def case 

easily get derived inference rule ine outi chapter ini outi equation su ce particular outi 
chapter explicit tied particular notion ambient ects convenient 
important nite index sets embedding types introduce circularity summand de ned type form 
index set nite fi simply take terminating merely ensures uniform encoding summands corresponding operations ini inr inik case inla case easily seen satisfy required equations 
general case obtain model straightforward extension predomain semantics toi indexed coproducts ji immediate check interpretation validates equations 

proof setting recursive type speci cations independently embedding types express continuation variant translation rei cation types containing need recursively de ned answer type 
accordingly take de nition new type constructor formedness rule fag type type new term constructors roll unroll typings ag roll likewise isomorphism equations ag unroll roll ag unroll ag roll unroll allow parameterized probably harm include 
case domains predomain equation expressed terms standard cpo constructors solution 
example consider empty set organized cpo empty non empty lead contradiction 
equations arising interpretations ofl types notably require codomains arrow types computational ruling counterexample solutions essentially extend interpretation parameterized type functor suitable category 
need result theorem fag parameterized type ofl exists proof 
see corollary appendix ignoring additional property ofi 
interpretation theorem roll asi unroll asi predomain semantics model ofe admissible relations equational theory allows reason equivalence terms axiomatically equality denotations speci interpretation reason general relations terms syntactic level 
rst establish set generic relational reasoning principles validated wide range chapter 
relating effects interpretations 
con ne reasoning programs principles results necessarily hold particular relational interpretation 
denotational semantics associates open term continuous function meanings assigned free variables meaning resulting term 
xed term constructors denote semantic function 
example vall necessarily term write inla element 
xn assigns value ai val 

improve readability usually asm notations equivalent 
equational case talk relations terms di erent languages 
say relation types ofl relation sets vall vall 
languages xed write simply rel set relations 
interested set admissible relations see de nition 
useful classify relation wrt 
types established admissible 
motivation considering di erent languages implementing monadic ect may need di erent resources specifying 
particular may contain constructs inl withl providing interpretation 
andl may arise di erent choices base ect monadt means specify monad say constructs ofl partiality ambient ect show translation say extended recursive types continuation semantics ambient ects satisfy monad laws inl rel write ara shorthand vall vall ara 
similarly ara abbreviates vall vall ara 
isolate subset relations working 
de ne relational analog pointed cpos de nition binary sets underlying called chain complete pair va va holds iai ia 
relation pointed andb called pointed br 
de ne suitable notion relations predomain semantics de nition languages extensions ofl andl andl extensions predomain semantics section possibly di erent ambient ect monads 
say relation types ofl admissible interpreted chain complete relation vall vall write arel set relations 
similarly computation admissible relation types 
proof setting interpretation chain complete pointed carel corresponding set 
refer pair languages type indexed sets computation admissible relations relational correspondence 
conciseness correspondence fully determined languages de nitions arel carel 
enumerate properties computation admissible relations especially certain stylized methods constructing available 
proofs fairly simple appendix 
properties reason related terms entirely base language referring semantic equations chains continuity explicitly 
consider notions computation admissibility pointed chain completeness remainder section establishes need require admissible relations establishing results section 
lemma admissible relations closed inverse image term contexts arbitrary intersection 

arel xn terms respectively alli xi vall vall rel admissible 
rm computation types ris computation admissible andx rigid 

rj arbitrary necessarily nite countable family admissible relations relation jrj admissible rj computation admissible jrj 
proof 
see lemma 
simple way combining existing relations individual types relations constructed ones lemma standard relational actions type constructors de ned true inla inla 
ar far chapter 
relating effects admissible 
speci cally ther admissible rr andr 
rr 
thes computation admissible andr 
rs 
omit clear form context action relations 
note relational action general explicitly de nable language characterize de nition 
proof 
show admissibility rr andr 
rr lemma 
rst case simply empty intersection computation admissible relations 
constructed relation products intersection admissible relations obtained inverse images projections admissible 
projections rigid computation admissible andr 
expressed intersection family admissible relations image construction fr far application rigid computation admissibility implies computation admissibility ofr 
cases natural numbers sums hand depend speci cs model see lemma 
reason restricting attention computation admissible relations validate binary version xed point induction lemma lets carel letf vall 
andf vall bsb xfs proof 
see lemma 
ectively saying computation admissible relations interpretations related 
computation extension relations akey concept extension value relation relation computations 
intuitively computations considered related generally related ects results pass computations related original relation 
example case partiality computations related diverge converge related values 
exceptions computations related produce related successful answers raise exception 
state xed relation states map related initial states related values related nal states 
control computations related invoked related continuations mapping related values related nal answers produce related nal answers 
monads common equational properties ects simple set axioms unit extension functions characterize minimal requirements relation extension follows 
simulation proof de nition computation extension relations assigns pair types arel admissible carel andr holds ara 
ar fa letx infx letx inf terms related values inclusions computations related 
parameterized computations related pair related parameters remain related pre xed related computations computing values parameters 
simple instance proposition standard partiality semantics lifting ofr 
determines computation extension 
proof 
lemma shows computation admissible 
condition immediate 
ar fa cases disjunct de nition ofr andm get result directly assumption onf andf letx infx fv letx inf 
second disjunct de nition ofr letx infx letx inf proposition obtain equalities see proposition systematically construct ects de ned explicit monadic translation 
simulation proof avoid repetition rst de ne de nition persistent assumption section assume relational correspondence ofl spe ci cation language andl implementation language xed computation extension relations 
particular ed occurrences arel carel andr refer correspondence 
chapter 
relating effects concreteness may help think ofl asl extended recursive types embedding types monad continuation case section partiality semantics andl continuation semantics base computations confused continuation monad de ned continuation interpretation ambient chapter 
overview monad morphism gives simple way converting computation representing 
simple relationship extend directly functions computations 
example function obtain 
left inverse try fj really satisfactory example andf identify function get meaning identity general correct representation identity ont better approach characterize example requiring satisfy equation general function higher order values computations corresponding ones computations get binary relation 
general outline proof follows 
type family inl de ne family logical show relational interpretation type parameters interpretations term ofl related hhii 
particular means term components monad triple inl related interpretations 
gives way talking ects languages monad inl de ne general notion monad relation monad speci cation language monad implementation language 
general notion existence monad morphism assigning function tou assign binary relation 
precisely arel assign arel 
monad speci cation language monad morphism induces canonical way monad relation ur standard syntactically derived action ofu relations 
way constructing monad relations covers sample monad simulations general monad continuation case 
monad relation exhibit family relations indexed types arel de ned usual inductive way standard type constructors arel 
show translations term type related particular says translations coincide complete programs 

simulation proof returning monad continuation case show construct appropriate monad relation ko explicitly 
intuitively need generalization equational relational characterization relationship monads reason forced adapt relational approach higher order values embed non simple types answer continuation monad ko representation oft ects general unique 
simulation rely fact implementation language may contain additional types terms inl particular depending general notion oft rei cation want need recursive types embedding types construct ko 
established monad relation simple consequence properties de translation variant continuation passing translation agree complete programs 
lift simulation result relationship translations relationship source terms 
speci cally basic motivation adding re ection rei cation source language precisely permit programs written direct style ect passing style 
fact possible express simulation result source level de ning re ection rei cation operators terms ko 
need monad speci variant translation implementing ects continuations xed continuation passing translation ects 
relating standard terms rst show large collection terms related relations determined systematically types de nition nite set type variables substitution types variables types 
assign type variable relation arel 
type inl assign arel fg carel fg follows hhaii hhii hh ii hh ii hh ii hh ii hh ii hh ii hh ii hh ii hhii hhii hhii hhii extend de nition pointwise relate value substitutions xi xi hh iii xi ii computation admissibility ofthese relation follows directly lemma 
easy see usual weakening substitution principles hhii hhii 
ftv hhii 
hh ii chapter 
relating effects lemma logical relations lemma substitutions closed types variables relation assignment de nition 
type assignment type inl letm term substitutions values andl variables ii proof 
induction structure ofm xi 
show iii xi iii xi follows directly assumption case show simply taken 
case sm 
show ih onm get result 
case ifz mz ms 
show ifz hhii ifz mz ih onm inl nand inl natural 
cases 
ih get ifz mz xs ms mz ifz mz xs 
ifz sm sfm xg analogously rhs result follows ih type assignment extended substitutions 

show ii hi trivially true de nition ii 
show hm ii hm 
simulation proof fst hm hh ii fst hm snd hm hh ii snd hm fst hm analogously rhs snd get result andm 
case fstm analogous 
show fst hh ii fst get ih onm rst conjunct de nition ii case analogous 
show ii rst disjunct de nition ii su ces show get ih onm 
case case 
show ii case hhii case ih onm ii loss generality assume rst case de nition ii inla andm inla hh ii 
case case inla fa analogously rhs get result ih onm extended substitutions 
show hh ii ii accordingly show mfa xg get result ih extended substitutions 
chapter 
relating effects 
show hhii follows directly ih onm andm de nition ii 
show hhii ih onm result follows de nition properties computation extension de nition 
case letx inm 
show letx inm hh ii letx inm ih onm hh ii hh ii similarly ih onm appropriately extended substitutions get hh ii hh ii facts de nition get required result 
case xm 
show ih onm ii gm result follows directly xed point induction lemma hhii computation admissible 
simple corollary lemma obtain interpretations monad triple related lemma monad triple inl 
standard relational action oft tr respects monad operations sense andr conditions satis ed 
ar fa tr lett infx tr lett inf 
simulation proof ara tr 
ar fa tr tr ft tr proof 
cases simple 
assumption onf andf assumption lemma term ii ii xf xm fa xm recall abbreviates term core syntax expanding generalized shape oft substitutions xf xm xf xm 

analogous fag 
analogous xt fa gx xt 
relating computational structure ready characterize means monads related de nition monad relation monads assigns admissible arel carel admissible andr 
ar fa ga lett infx ara 
ar fa ga ft say anl term re ection function respect monad relation type arel tr analogously rei cation function anl term arel tr chapter 
relating effects note need satisfy monad laws inl general monad morphism 
explicitly require idt hold 
important special case monad triple monad andl lemma shows standard relational action oft induces monad relation copies simply take 
non trivial content de nition case idt andl di erent models ambient ects related relation extension 
generally convenient way obtaining monad relations directly monad morphisms proposition monad triples inl monad inl monad andl monad morphism assignment arel ther carel ur establishes monad relation ofl re ection function 
schematic retraction inl rei cation function 
proof 
computation admissible de ned inverse image computation rigid functions idu 

letm andf 
show ur rigidity ofi de nition lhs amounts showing fa ur get assumption properties ofu relational action lemma 
establish ar fa ur ga precisely assumption onf andg 

show ur de nition lhs equivalent ur get lemma 
lett hypothesis 
show ft ur 
simulation proof property monad morphism lhs amounts showing assumption assumption onf andg ur ur ar ur ga get desired result 

lett tr show ur term ofl follows lemma argument analogous lemma 

lett show tr 
assumption ur lemma tr 
cancelling lhs gives result 
monad relation re ection rei cation functions exactly need relate de nitional variant translation monad relation relates computational structure re ection rei cation functions exist convert ect representations de nition monad monad monad relation type ofl relation arel usual way induction structure de nition type variables monad relation 
note particular standard relational action oft lemma de nition type state proposition monad relation re ection function type type ofl family lt types rei cation function term ofl rei cations types 
pair substitutions related values variables variant translation de nition 
proof 
de nitions simple induction structure ofm 
cases variables numbers products sums functions base computations exactly lemma 
remaining constructs chapter 
relating effects 
show follows ih onm de nition 
case letx inm type 
show ih onm andm 
case letx inm 
show follows ih onm andm 
case 
show follows ih onm de nition 
case 
show get result ih onm de nition 
case need check computation admissible may contain type case computation admissibility ensured requirement monad relation de nition 
monad relation induced monad morphism proposition proposition immediately gives correctness number ect simulations 
example complexity state monad morphism example validates statebased maintenance complexities 
monad continuation simulation full generality little harder 
obtain rei cation arbitrary types purely equational properties monad morphism standard relational action ofu need construct appropriate monad relation explicitly 
relating monads continuation passing recall example main limitation monad morphism formulation continuation variant translation incomplete treatment oft rei cation 
speci cally directly allow de ne rei cation operation type types containing see problems elaborate monad relation 
time take care independent technical complication simulating monad continuation monad ko 
lemma 
simulation proof expect take answer bet constraints imposed eventual application section allow 
speci cally need answer type expressible 
butt necessarily form 
fortunately relational approach allows considerable latitude picking actual answer long larger originally needed 
answer type occurs positively negatively continuation monad express condition purely equationally 
conciseness formulate requirement general terms de nition answer embedding ofl computation consists pair functions inl rigid ido 
idt certainly satis es requirements gives result strong solve problems mentioned 
rst reading may simply ignore occurrences section 
purpose section important rely weaker properties guaranteed de nition 
ready state central result relating monads continuations 
essential trick commit xed answer type continuation monad free consider possible relational interpretations type lemma continuation simulation monads monad 
type type ofl answer embedding mapping ofr arel tor carel ko arel valli ara ka kt uk monad relation ko 
form re ection function rei cation function 
intuitively outer quanti cation allows overcome limitation needed rei cation type simply inner quanti cation care replacing xed relation answer types particular may recursive stronger parametricity condition 
nally mentioned need 
instructive compare cases proof corresponding ones proposition 
common structure clearly abstracted probably easier follow continuations passed concrete formulation 
chapter 
relating effects proof 
check computation admissible admissible de ned intersection inverse images computation admissible relations rigid uk speci requirements 
assume ar fa ga andm show infx infx andk show ar ka infx rigidity ofk de nition lhs rigidity de nition rhs showing ink fx gx lemma assumption su ces show ar fa ga follows assumption ga 
andk show law de nition ka precisely assumption 
assume ar fa ga andt show ft uk monad law lhs expanding rhs amounts showing fx follows de nition oft show ar fx ar fa ga follows assumption ga 
simulation proof 
andk ara ka andt tr show kt cancelling de nition kt lemma su ces show ara ka precisely assumption andk 
letr arel show tr nally need instantiate de nition ofr 
take clearly admissible assumed 
respects relational action oft lemma ka assumption monad law obtain required 
kt uk construction gives rei cation directly choosing appropriately de ne rei cation functions types lemma monad relation rei cation function type type ofl term constructors 
term rei cation function def lett proof 
inl andr arel show tr accordingly de ner arel ars chapter 
relating effects clearly admissible inverse image 
assumption properties computation de nition immediately get ara ara assumption properties monad relation de nition gives get assumption tr nally parts lemma de nition ofr ina tr ina required 
lemma speci cally ko ina consider anl program 
type system monomorphic operator program uniquely labeled speci type 
nite set ofl types needs embedded lemma 
note static property program set rei cation types bounded linearly program size 
contrast say nite xed points priori determine deeply unroll 
simulate rei cation nite sum willing construct relevant type program 
fact nite covering rei cations anl program get result larger de ning formally de ne evaluation semantics programs resulting variant translation unique meaning determined su ciently large nite collection 
single nite embedding type works programs 
particular simply countable set names types giving enumeration unproblematic set ofl types contain embedding types 
tags inherently unstructured particular monadic translation 
actual ml implementation extensible data type tags dynamically generated assigned instance rei cation 

simulation proof embedding types su ce express continuation simulation rei cation independent problem reifying atl types containing type constructor suppose simplicity needed rei cation single type choose answer type continuation monad freely 
natural simply take ando continuation passing translation de ned terms answer require solve recursive type exactly strong requirement general 
take fact need full isomorphism su ces 
alternatively broken recursion approach gives slightly simpler correspondence monads continuation passing allow express construction section full generality 
factorizing variant translation translates tol translation ects monadic translation tol sharing type translation term translation clauses 
nonstandard clauses re ection rei cation oft ects 
fact express translation entirely terms translation re ection rei cation de nable terms 
practice means cient convenient way implementing evaluators de nitional translation technique long gives correct results complete programs obtain evaluator simply re ection rei cation de nitional extensions ofl de nable inl invariant translations immediate simply take im continuation monad recursively de ned answer type formulation ofu ects integrates recursion isomorphisms continuation passing translation 
monad triples sets types ofl andl thetype constructors type type extended signature independent actual monad ects types 
de ne suitable notion native ects anl continuation monad de nition cll signature 
type signature new computation type constructor associated value inclusion lets types de nition term constructors 

chapter 
relating effects note strictly generalizes previous de nition monad extended signature case type ofl contain exactly get monad de nition 
case standard monad extension signature able back corresponding monad involves recursive type de nition 
target syntax includes types give translation de nition translation de ned follows rst take 

ando 
type translation expands 
preserves type constructors ofl 
abbreviate associated isomorphisms def 
ko 
def 

ko write 
summarize typing rule term constructor building terms terms 
type term translation standard monadic translation monad ko clauses re ection rei cation reading letr ka letr ka note isomorphisms identities trivially ensure anl type reduces original de nition monadic translation de nition law letx inx usual direct style reasoning principles re ection rei cation de nition hold general notion monadic translation 
speci cally lemma addition equations inclusion de nition equations sound translation de nition mk km letx inm letx inm letx occur free 
proof 
simple calculation mainly verify isomorphisms cancel 
example third equation 
simulation proof letr ka letr ka letr letr letr letr inr km similar 
note similarity direct style equations characterizing explicit continuation passing translation 
operational intuition passes tom functional representation current evaluation context continuation waiting result 
conversely continuation returns answer 
example letx letr sx letr sx letr sx letr sx letr sx sx letr sx sx gets bound sx twice 
circularity inherent allowing 
anl type genuine language possible write non terminating programs inl 
simplest example take 
re ection rei cation shown sided inverses give isomorphism 
de ne diverging term usual double self application type correct isomorphisms 
hi 

letx khi indx 
dd turns picking xed shape answer type requiring form 
necessitates slight twist simulating monads type constructors contain outermost allowed answer embedding de nition retraction full isomorphism 
slightly transform monad simulated de nition monad triple 
de ne new follows lett fa inr chapter 
relating effects example state example gives 
ha si lett ts letr fa outermost hand general monad 
particular law get lett fa inr fa inr fa inr 
fa monad extensionality evaluated applied value behave identically letr letr fa inr fa inr letr fa fact construction ensure functions fully applied de ne re ection rei cation terms corresponding operators continuations follows theorem monad letm anl program top level focus ects 
family types containing types contains rei cation operator 
take formed type de ne term constructors tt leta int withl model section 
replacing allt re ection rei cation operators inm de nitions rei cation arbitrarily subject constraint yields programm proof 

associated isomorphisms de nition take 
easy see functions de ned 
form answer embedding sense de nition 
lemma directly get omitting tedious cation steps 
simulation proof ka inr letr ka inr ka letr ka ka ka similarly extended lemma ini outi satisfying retraction condition de nition get tt leta int ina ina ina ina ini outi apply proposition empty result 
monad type exceptions slightly simpler construction possible 
take 
lets letr 
sided inverses 
get analog theorem de ning re ection rei cation follows km leta ina actual ml code section takes advantage optimization including explicit suspension de nition monads having implicitly inserted cbv elaboration section 
words type constructor ml signature monad corresponds 

simply theorem directly cases 
reduced problem implementing language monadic ects arbitrary de nable monad implementing language re ection rei cation operators continuation monad answer type 

chapter show achieved embedding continuation ect language scheme 
induced relational correspondence nally show relational correspondence andl generalized case base language monadic translation 
consider language take distinguished computation type constructor related operations simply additional type term constructors 
corollary showed new language model ofe shows equational characterization extends relational chapter 
relating effects proposition monad relation inl inl de nition 
relation assignment determined monad relation computation extension sense de nition computations languages lt lts de nition 
proof 
rst condition letr arel relation show thata original correspondence follows immediately de nition 
similarly assume ar fa andm show new correspondence letx infx letx inf letx infx fx fm letx inf original precisely statement 
related study relationships direct continuation semantics long history 
early investigations rey st sto set domain theoretic framework main di culties concerned re exive domains result methods results closely tied speci semantic models 
hand meyer wand approach mw applied models simply typed calculi encompass computational ects nontermination 
formulated simply typed setting axiomatic reasoning closer conceptually domain theoretic results 
particular explicitly handles general recursion computations xed point induction extend recursively de ned types obstacles 
initial version fil meyer wand approach clear scale ambient ects especially recursion 
possible correspondence monads continuation passing style cps conjectured danvy filinski df concretely wadler wad 
general idea monad morphism simulate monadic effect due wadler wad 
largely informal 
notably problems rei cation needed express handle continuation exceptions setting addressed 
peyton jones wadler pw probe relationship monads cps wadler wad analyzes composable continuations monadic perspective cases restriction hindley milner typable translations obscures general correspondence properly expressing answer type parametricity 
related simulation general monads continuation passing requires exible type system 
glimmer connection monads continuations seen sabry felleisen result equivalence cps terms coincides direct style equivalence moggi computational calculus sf mog captures exactly equivalences holding presence arbitrary monadic ects 
imply monadic ect simulated continuation monad indicate continuations form maximally necessarily general notion ect 
chapter implementing continuation ects chapter continue simulation ects showing language re ection rei cation operators continuation monad embedded language traditional set ects scheme style rst class continuations typed state 
previous chapter showed continuations precise sense universal ect de nable monad simulated continuation monad suitable answer type 
show universal ect expressed terms speci low level ects 
program directly monadic ects language scheme ml continuations 
development consists major steps 
re express re ection rei cation continuations terms alternative operationally motivated pair control operators 
implement control abstraction known composable continuations 
decompose composable continuations operators standard escape operator operator delimiter 
show level tags value inclusions lets introduced monadic translation unnecessary evaluation purposes program evaluates result original 
proof involves set logical relations indexed types original level language relating original level erased terms type 
level erased language de ne control operators terms scheme primitives 
key step re express sequencing continuation passing terms meta continuation passing style observe metacontinuation single threaded way translation maintained xed cell store 
simple logical relations argument shows equivalence original de nitions control operators escape state simulation 
conclude chapter actual implementation construction standard ml new jersey includes language support rst class continuations 
addition complete code implementing monadic re ection rei cation terms escapes state show simple programming examples 
particular illustrate de nable monadic ects nondeterministic probabilistic computations naturally traditional call value setting 

continuation reflection composable continuations continuation re ection composable continuations convenience assume signatures contain empty type value constructors 
implementation recursive types embedding types certainly example de ning embedding type empty index set 
need require counterpart speci cation adding unproblematic 
computation type unique function expressible 
whichwe write asv fact andv simply zero ary analogs sums case require av arbitrary particular monadic translation vm chapter simulation results parameterized fairly complex notion de nable monad included type constructor type indexed families term constructors constructions chapter parameterized xed closed value type 
accordingly de nitions recursive types need consider type closed types terms 
continuation passing translation allows de ne wide range control operators source language 
seen re ection rei cation possible 
particular de nition cll signature type 
type ofl 
inl 
de nition de ne operations 

cm expansions 
am 

cm 

ka am 
sm 
mk 
sm operational intuition follows cm escape representation current evaluation context 
applied value abandon current context evaluation result cm letz regardless happens 
returning invoked context expecting typed result writing letz qa inv acts scheme call cc explicitly order return value 
variant de ne 
am abort immediately terminates current computation answer 
aq supplied combination break computation typed context 
chapter 
implementing continuation effects reset prompt empty evaluation context returns nal answer evaluation delimiting control 
example get letz sm shift captures erases current evaluation context including innermost enclosing passing context tom composable function 
example letx letr letr kr inr sx note de 
probably known call cc control operators likes seen fair amount study fel sf df wad fil grr brie compare various approaches section 
need de nition note lemma translations derived control operators de nition cm ka vz am sm ka proof 
straightforward 
example am letr ka letr ka letr similar 
reason concentrate composable continuations operators seemingly general property lemma shift reset form complete set control operators sense express re ection rei cation follows 
letr mk inr 
leta letr ka inr get equivalent translations proof 
actual translations terms contain explicit isomorphisms clutter equational proofs 
convenient standard reasoning principles re ection rei cation soundness respect translation established lemma 
continuation reflection composable continuations letr mk inr letr mk inr letr mk inr letr mk letr mk kr letr mk inr mk leta letr ka inr leta letr ka inr letr ka inr letr ka letr ka letr ka inr ka re ection essentially captures current continuation passes tom rei cation delimited control context containing 
simple reading somewhat obscured explicit lets value inclusions coerce kinds computation 
eliminate operational distinction section mixed level lets replaced 
somewhat surprisingly re ect likes decomposed standard escape operator simpler constructs lemma de nable terms ofc sm letr letz ca inv proof 
lemma direct style reasoning actual veri cation letr letz ca vz ar letr letz ca vz ar ka vz letr letz ka vz ar vz letz ka vz ar vz letz ka vz vz ka vz vz ka vz ka mk sm wrap escaping control delimiter making composable function passed tom 
needs erase continuation capturing explicitly abort returned 
aand de ned terms principle matter set 
pragmatically advantage types contain negative occurrences slightly simpli es arguments section 
switch attention new set chapter 
implementing continuation effects de nition cll signature type type ofl 
kcc computation type constructor associated value inclusion lets term typed de nition 
isan evident translation tol kcc statements lemmas 
de nitional translation kcc tol identical de nition clauses replaced clauses lemma 
note consider complete programs terms type type system ensures control ects anl kcc program occur dynamic scope 
level erasure chapter section reduced monadic ects shift reset escapes abort reset dependencies original monadic translation gone translation equations monad simulation performed entirely re ection rei cation simple control operators components monad triple 
ect enriched signi cant practical limitation need explicitly indicate levels value inclusions lets 
speci cation perspective reasonable general re ection rei cation available distinguish properly computations order de ne monadic translation 
programs written terms computations uses restricted de nitions monad speci ects re ection rei cation raise handle example 
particular computational ects may need explicitly expose computations language 
hand provide re ection rei cation arbitrary programmer de ned monads need general computations directly expressible language 
languages ect pcf explicit adding level annotations inclusions lets may problematic 
ml language implicitly elaborated ect pcf section room signi cant ect annotations source terms 
fortunately far program evaluation concerned levels safely elided 
idea view subtype entirely separate type 
membership semantic property values type system guaranteeing absence ects certain terms playing active role actual evaluation process 
accordingly de ne new language uni ed notion control ects de nition bel extended empty type 
de ne set ofl types ofl type constructor replaced new constructor 
level erasure 
anl type 
composable continuations language consists ofl instances replaced particular computations letx inm computations additional term constructors 

cm 
am 

de ne translation level control ect language uni ed simply dropping distinctions levels de nition level erasure de ned follows 
type jj thel 
type obtained replacing occurrences jj jj jj type constructors una ected 
terms level erasure likewise con ates uses jmj jmj jmj maps counterparts de nition 
easy see inl kcc jmj jj inl ccj give ade nitional translation level language de nition 
anl type 
de ne continuation passing translation cc 
tol follows 
auxiliary types syntactic expansion 
take write 

roll 

unroll 
associated isomorphisms 
translation types 
type constructors ected 
correspondingly non identity clauses term translation letx inm cm ka vz am ink usual translation easily seen type preserving inl cc 
inl 
chapter 
implementing continuation effects state goal concretely want show original de nition equivalent evaluation purposes level erasure followed translation 
establish equivalence de ne collection relations types arising translations 
key ingredient suitable relational action type constructor translations de nition relational correspondence interpretations ofl computation extension de nition 
arel de ne carel 
type arel letx type arel 
ara ka leta uk note essentially monad relation lemma taken identity monad id continuation monad simulate trivial notion focus ects 
de ne system relations de nition anl type take 
de nition de nition arel 
admissible relation nal answers moment leave de nition unspeci ed 
type ofl relation arel jj usual way base types sums products functions 
type constructors take false dom mu uu 
aa ka uk easy see admissible view de ned inverse image constant functions see lemma computation admissible 
representation value jj translation form letx particular parametric answer type 
de ne committing particular relational interpretation answers occur de nition 
level erasure hand identity answer type explicitly exposed source language arbitrary value type answer allows answers inspected control ect free computations type 
want relate terms choose arbitrarily match 
fortunately circular dependency resolved important result theorem letf andf type constructors formal relation constructor built standard relational actions ofl type constructors constant admissible relations computation admissible computation types relation constructor maps arel tor arel 
invariant arel fa unroll aa unroll aa proof 
see corollary section 
form immediately obtain lemma exists admissible relation arel 
oo de ned terms de nition 
proof 
existence hinges de ned operations enumerated theorem 
directly take invariant relation action mapping 
note 
genuinely recursive contains constructors circularity de nition occurs contains just de nition induction particular depend simply take lemma de nition prove case 
state correctness result level erasure lemma term ofl kcc proof 
proof induction onm 
interesting cases 
show kk jmj leta jmj simpli cation lhs reduces showing jmj jmj get immediately ih onm assumption chapter 
implementing continuation effects case letx inm 
show letx jm show jm leta letx jm simple rewriting lhs equivalent letx leta jm jm ih onm de nition su ces show leta jm leta fa xg jm jm fa follows immediately ih onm extended substitutions 
case letx inm 
show letx jm fork 
letx jm jm simple rewriting lhs equivalent letx jm jm jm ih onm de nition 
ando su ces show jm follows immediately ih onm extended substitutions 

show jmj 
vacuously true jmj 
level erasure property su ces show lemma equivalent jmj 
jmj get ih onm cancelling isomorphisms 
case show jmj ink letx jmj ink simpli es ink jmj ink de nition assumption su ces show ih onm oo jmj follows jmj need show rr immediate consequence de nition case 

simple translation sides 

show kv jmj ih onm jmj case occur closed values type 
chapter 
implementing continuation effects case 
show ih onm de nition 
case 
show ini ini jmj jmj get result directly jmj jmj ih onm de nition ini jmj ini dom anda possibilities de nition inla inla de nition relational actions ini ini composable continuations escapes state implement aone level language escapes prompts abort speci ed simple continuation passing transform 
perform continuation passing translation anyway cps code generation app right track 
closer inspection translation quite produce proper continuation passing terms little bit explicit sequencing left output 
recall equations de nition 
problem witha especially introduce explicit notion sequencing continuationpassing terms 
stroke luck express sequencing terms standard ect state 
key idea eliminate remaining traces explicit sequencing performing continuation passing transformation new metacontinuation keep track nested computations 
take implementation interpretation ambient ects monad 
constrain answer type monad retain full range possible ambient computational ects 
may rst move farther away direct implementation see properly continuation passing terms ectively una ected second translation translations change useful way 

composable continuations escapes state de nition inl computation type ultimate answers abbreviate 
de ne translation expanding computations continuation passing answer type 
letx inm type term constructors una ected usual 
de ne new continuation passing translation ofl cc 
answer type explicitly type continuation passing computations opposed unspeci ed notion ambient ects de nition 
anl type take 
isomorphisms 

roll de ne cc 
follows 

unroll 


letx inm cm am uk ka vz note underlined occurrences reduced away translations value inclusions lets escapes form completely standard continuationpassing transformation 
easy see translation nested continuationpassing translations lemma type ofl cc 
predomain interpretation ofl 
proof 
complication type recursion de nition translations 
recall key cases 


chapter 
implementing continuation effects rst strengthen relationship type translation ko proof simple induction interesting case ko ko ko ih rst takeo get 





equalities types equality terms completely straightforward 
cases value inclusion escape immediate translations contain sequencing obtain result simple conversion 
roll roll 
roll analogously example am ih am re tying recursive knot metacontinuation translation derived directly original match state passing translation rst need relate equivalent formulation isomorphic answer type de nition 
isomorphisms 
roll 

unroll 
de ne continuation passing translation answer type translation equations escape abort reset reading cm am intuitively plausible de nition equivalent de nition state precisely corollary may proceed loss continuity 
section include 
composable continuations escapes state de nition functorial action ofl type constructors isomorphisms follows 
ag ag ag ag hi case inl inl case ai ini ai letx hi 
take advantage fact chosen solutions recursive type equations unique isomorphism particular matter break recursion de ning pair mutually recursive types lemma letf type constructors ofl necessarily covariant ga solutions corresponding recursive type equations 
predomain model exists isomorphism satis es equivalent coherence equations roll ga unroll ga ga roll ga unroll proof 
see lemma appendix 
case obtain instance lemma exists isomorphism 
induces type cc 
isomorphism 
proof 
de ne type 

ga 
get isomorphism directly lemma 
write 
rst note chapter 
implementing continuation effects hx 
hx id second form coherence equation get 

translations de nitions continuation passing translations isomorphic answer types closely related usual logical relation get simple equational correspondence lemma xn write substitution nxn xn 
cc 
term proof 
cases standard terms products sums functions straightforward 
example abstractions applications ih kn kn xg kn ua ih kn kn kn computations rst name induced isomorphisms meta computations value isomorphism computations 
cases inclusion simple ih interesting cases depend answer type 
need expand get check 
composable continuations escapes state am am ih step marked coherence equation lemma 
reset calculation little involved simply discard continuation ur ink uo 




ih applications coherence equation 
state observable consequence result expressed constructs ofl helper isomorphisms corollary letm cc 
term type andp 
pn pn proof 
simple equational veri cation lemma empty id coherence equation pn pn pn pn 
pn 
pn corollary may rst appear specialized covers exactly need 
particular ifm term escaping ects equivalent included numeral translation get pn pn pn pn pn hand ifm invokes metacontinuation protected enclosing translations return error answer 
chapter 
implementing continuation effects continuation state language assume available language scheme escapes state ects 
simplicity consider state consist single typed cell additional state accommodated choosing appropriately de nition anl type 
cs continuation state language consists ofl occurrences replaced de nition extended term constructors 

cm st st note type complex type 
stored cell procedures read modify state 
introduces re exivity types known de ne xed point operator higher order state done letrec scheme cr 
usual give de nitional translation new language de nition computation type ofl type 
translation cs tol types directions 
usual taken identities contain give term translations new constructs letx inm sks cm kas st st khi underlined instances state passing away 
words core computational structure standard continuation translation answer type 
pick 





represent metacontinuation state encoding gets passed continuation state 
informally 


composable continuations escapes state having chosen suitable state type need express relevant operations metacontinuation terms constructs continuation state language 
conciseness introduce abbreviation expansion def inm value inclusion computation sequencing escapes directly available inl cs remaining constructs ofl cc 
take de nition anl type 

de ne typed de nition follows am def st def 
st st st cv letx note particular procedure stored st previous value st return point call return type empty 
set system logical relations suitable showing statebased de nitions control operators capture behavior translation lemma relational correspondence interpretations andl ofl computation extension carel arbitrary computation admissible relation ultimate answers 
exists collection relations properties wrapped ultimate answers carel 
vall vall qs state arel gs gr sr meta computations carel 
xx gs xg values type arel de ned usual way standard type constructors particular uu 
chapter 
implementing continuation effects proof 
assume relation independently de ne terms satisfying equivalences lemma characterizing 
de ne carel 




computation admissible relation intersection inverse images rigid functions id lhs andm rhs 
depend concern admissibility action de ning 
relational actions de ning standard theorem take invariant relation action gs giving remaining equivalence lemma 
having established existence appropriate relations easily show correctness state representation metacontinuation lemma term ofl cc 
rhs expansions de nition 
proof 
induction onm 
cases immediate term constructors having expansions translations 
exceptions 
rst compute am st st gm show am am 
show ns accordingly su ces show follows de nition ih case rst expand rhs st st st cv letx ax vz kv vz show 
putting vz vs usual 
show vz vs ih onm su ces show continuations passed translations related 
continuations show ifr vz follows de nition ofg show similarly de nition requires showing forr vs cancelling isomorphisms follows immediately de nition assumption putting summarizing results chapter state theorem relational language computation extension equivalence relation 
translation ambient ects continuation monad answer type de nition vall 
printing function anda vall error answer 

continuation passing transform answer type de nition continuation state transform de nition state type ultimate answer type complete program inl cp pn term ofl cs obtained syntactically erasing level annotations value inclusions lets de ning terms escapes state detailed lemmas de nition 
chapter 
implementing continuation effects correctly ect strati ed programm initial error metacontinuation right hand side invoked 
implementation hosted ml language system statically verify typable stricter system level erasure ofm ml typable 
pragmatically give useful behavior ect typing errors notably ifm escaping control ects ectively type take initial metacontinuation produce distinct invoked want show simulation correct error catching extension 
proof 
predomain semantics ambient ect monad induced easily checked uniform monad predomain semantics proposition 
proposition straightforwardly extended additional term constructors ofl gives lc types terms 
standard relational action ofk inl cr 
ara easily seen computation extension notion ambient ects determined continuation monad ka ka similarly letm thel kcc program obtained de ning terms ofc level types 
de nition associated lemmas get cp cp level erasure lemma get relational correspondence copies jm simply equality expands type lc 
kn letx jm original correspondence type 
vall 

vall 

kn kx jm ck somewhat surprisingly actual choice matter ofc computation important 
fact simply take 
putting vacuously relate element element 
consider continuations 
pn andk 
pn natural number show ooo kn andk ignore metacontinuation arguments reduces pn get re exivity 
cp kx jm jm pn take vacuously map allo related values related results 
expanding de nition get cp jm pn take step escapes state 
letm jm 
lemma gives pn pn corollary pn pn lemma get thel correspondence wherem obtained de terms ofc st st de nition 
want get px px expanding de nition need verify continuations related pns pn reduces just pn pn check initial metacontinuation state related forr andq qs true sides simplify toa 
lines marked sequence transitivity gives desired result 
chapter 
implementing continuation effects nally theorem chapter nontermination notion ambient ects simply diverging ect typing errors get corollary 
partiality interpretation ofl monad 
pick state type inl program 
wherem term ofl cs obtained syntactically erasing levels value inclusions lets de ning terms escapes state embeddings term constructors proof 
partiality semantics relation lifting computation extension closed terms type related denotations equal model particular equivalence relation 
identity monad example continuation monad answer type de nition 
lemma monad morphism de ned follows leta ina proposition gives monad relation mapping arel tor carel 
hm letx inx ara letx inx proposition get relational correspondence interpretations andl computation taken ther de ned 
theorem taken enumeration types gives correspondence andl wherem inl obtained de ning terms components operations embedding types 
get original correspondence letx get desired result directly theorem xand 

ml implementation examples ml implementation examples section illustrate construction far transcribed runnable code 
emphasize typing issues involved new jersey dialect standard ml am concrete language operational content translate straightforwardly scheme instantiation di erent monads may convenient parameterized module facility 
give examples reader may want compare wadler presentation wad 
composable continuations sml nj rst class continuations type distinct type general procedures 
rst set scheme style representation continuations non returning procedures essential direct correspondence development section signature escape sig type void val coerce void val escape void void structure escape escape struct datatype void void void fun coerce void coerce fun escape callcc fn fn coerce fn fn throw example write open escape escape fn fn coerce val int void coerce unconstrained type variable escape permits continuations stored ref cells staying ml type system hdm 
de ne composable continuations facility parameterized type nal answers de nition lemma signature control sig type ans val reset unit ans ans val shift ans ans functor control type type ans control struct chapter 
implementing continuation effects open escape exception val mk ans void ref ref fn fn raise fun abort mk type ans ans fun reset escape fn fn val mk mk fn fn mk abort fun shift escape fn fn abort fn fn reset fn fn coerce example structure control type type ans int open reset fn fn shift fn fn val int monadic re ection building composable continuations package implement construction section 
signature monad simple signature monad sig type val unit val ext val show string string monad laws ed manually 
component show included signature convenience 
require satisfy show unit id terms factor unit provides informal string representation ect possible 
rst general parameterize types show string string recover fn ms fn show ext unit ms 
goal de ne re ection rei cation operations arbitrary monad get signature sig structure monad val reflect val reify unit val run unit string string 
ml implementation examples run illustration purposes takes suspended string returning computation returns result executing annotated external representation computational ects 
control de ne representation continuation monad arbitrary answer type lemma simpli ed level erasure functor type type answer monad struct type answer answer fun unit fn fun ext fn fn fn fun show raise fail show defined functor type type answer struct structure control type type ans answer structure type type answer answer val reflect shift fun reify fn reset fn fn fun run raise fail run defined show run de ned answer type unknown 
implement general construction need represent embedding type section 
rst fundamentally incompatible sml type system especially want parametric solution independent collection available base types type constructors 
construction requires exhibit embedding types perform rei cation 
need called generative type dynamic structure matching signature dynamic sig type dyn val unit dyn dyn monotype returns pair functions equal identity 
signature implemented type safely sml exploiting fact standard datatype exn nominally exception names useful purposes dynamically extended new summands structure dynamic dynamic struct exception dynamic abstype dyn dyn exn fun exception fn fn dyn fn dyn raise dynamic chapter 
implementing continuation effects note raise handle exception dynamically allocated tag 
encoding dynamic types terms exception names probably cient approach sml nj short bypassing type system entirely system unsafe cast depend existence extensible datatype construction 
fact get ect representing value type dyn procedure unit unit setting speci cell desired value structure dynamic dynamic struct exception dynamic abstype dyn dyn unit unit fun val ref fn fn dyn fn fn fn dyn case raise dynamic needlessly builds closure dynamic value bit obscure exn de nition 
complete construction theorem functor represent structure structure monad struct structure cr type type answer dynamic dyn structure fun reflect cr reflect fn fn ext fun reify val dynamic ext unit cr reify unit fun run show reify example exceptions example concrete setting ml implementation structure struct datatype suc err string val unit suc 
ml implementation examples fun ext suc ext err err fun show suc show err error functor structure structure sharing sig val string val unit string struct open fun reflect err fun case reify suc err note operations de ned generically terms valid implementation re ection rei cation exception monad 
example sml exceptions simply take structure struct exception exc string structure open fun reflect suc reflect err raise exc fun reify suc handle exc err fun run show reify plug canonical de nitions obtained represent structure represent structure structure structure fx structure structure open fx fun div div val int int int run fn fn val string run fn fn val error div run fn fn fn fn fn fn oops val oops div type inferred overly conservative wrt 
weakness exception raising operation returns normally rst place safe give fully polymorphic type 
achieve simply changing de nition escape coerce reflect err 
unfortunately chapter 
implementing continuation effects weakly polymorphic traced back fact reify functor represent weakly polymorphic type consequence de nition terms dynamic 
instructive inspect expansion underlying state continuation manipulations cell allocated metacontinuation control ectively contains current handler continuation invoked raise temporarily rebound scope 
way exceptions implemented sml nj details quite exception speci implementation take advantage particular operational properties monad notably handler continuations invoked optimize generic construction bit 
example state state monad straightforward functor statemonad type type state monad struct type state state fun unit fn fun ext fn val fun show raise fail defined structure monad struct structure statemonad type type state int open fun show val functor structure structure sharing sig val store int unit val fetch unit int val tick unit unit struct fun store reflect fn fn fun fetch reflect fn fn fun tick reflect fn fn structure represent structure structure structure fx structure structure open fx run fn fn store tick val fetch tick val 
ml implementation examples general construction clearly wasteful easily represented state monad callcc 
true state monads complexity 
real value general construction decomposition escapes state immediately apparent examples 
example nondeterminism nondeterministic computation represented list answers 
formally goes monads considered chapter extending proof language inductive datatypes lists straightforward 
structure monad struct type list fun unit fun ext ext ext fun show fail show show show functor structure structure sharing sig val pick list val fail unit val results unit list struct fun pick reflect fun fail reflect fun results reify structure represent structure structure structure fx structure structure open fx run fn fn val pick pick fail val string generally get haskell style list comprehensions free schema ejx xn en may en ine expressed directly letx en ine course probably cient way implementing list comprehensions ml 
observed wadler list comprehensions generalized arbitrary monads wad similarly get general monad comprehensions ml simply supplying appropriate operations :10.1.1.33.5381
chapter 
implementing continuation effects example probability slight re nement nondeterminism monad permits keep track possible outcomes nondeterministic evaluation relative probabilities distribution individual choice operations 
probabilistic computation type represented nite set pairs ai pi value type pi distinct sum 
example illustrates technical problem monads structuring tool functional programs opposed describing programming language semantics de nition monad requires operations de ned uniformly types general properly implement higher order values elements type tested equality 
example algorithmically identify probabilistic computations andf represent definite identity function 
note variant easily arise allow explicit non deterministic choice higher types consider source term amb inx non uniqueness problem observe functions directly need ensure ground type result may obtain series applications potentially higher order probabilistic functions uniquely represented 
easy way achieving represent active probabilistic computations non uniquely list nondeterminism expose rei cation types eliminate duplicates abstraction sig include monad val real list val real list struct type real list sum fun unit fun ext ext map fn fn ext fun show show show show fun sanity checking fun tally tally tally fun fold fn fn tally fun show show functor structure structure sharing sig val choose real list 
ml implementation examples val flip real bool val distribution unit real list struct fun choose reflect fun flip false true choose true false fun distribution reify structure represent structure structure structure fx structure structure open fx run fn fn flip flip diff val diff string sml nj abstraction extension hide implementation type analogous ect achieved slightly standard abstype construct 
strictly speaking gives uniqueness permutation get truly unique representation need type linearly orderable supporting equality predicate 
probabilistic ects solve textbook problems nding distribution total number heads biased coin fun toss toss flip toss toss val toss fn real int int distribution fn fn toss val int real list course particular case exists simple analytic solution probabilistic execution approach handles regular experiment protocols dissimilar branches may taken depending outcomes probabilistic choices 
note simulation keeps track possible computation paths potentially exponential cost computation time 
cases net outcome achieved di erent ways example useful add explicit wrapper choose distribution fn 
ect result computed de nition instance principle improves ciency consolidating computation paths manner analogous dynamic programming 
chapter 
implementing continuation effects example continuations consider continuation monad arbitrary xed answer type 
lets de ne escapes composable rst class continuations 
functor 
create speci instantiation structure monad struct structure type type answer string open fun show fn fn functor structure structure sharing sig val val string string val unit string string struct fun reflect fn fn fun reflect fn fn reify fn fn fun reflect fn fn reify fn fn fn fn fun reify fn fn structure represent structure structure structure fx structure structure open fx run fn fn fn fn val string run fn fn fn fn fn fn val abbc string related di erent notions functional composable continuations studied anumber researchers 
early jd df presumed explicit support compiler runtime system actual implementation ability mark splice delimited stack segments 
encoding standard scheme variant devised sitaram felleisen sf 
embedding quite complex relying dynamically allocated mutable data structures eq tests dynamic typing scheme 
explicitly scheme implementable notion partial continuations proposed queinnec qs code required intricate 
implementation related construct standard ml new jersey gunter remy grr 

related initially operators appear general monadic re ection continuations clear additional expressive power su ciently useful practice justify fairly complex implementations 
simpler construction chapter uses single statically typed cell holding continuation minimal increment call cc 
signi cantly implementation directly derived related original speci cation orts gave informal argument usually operationally speci ed control construct correctly implemented code 
relatively complex correctness proof simple control operators chapter alternatives easier verify 
term metacontinuation fairly broad meaning rst giving formal semantics notion computational re ection wand friedman wf 
restrictive usage term metacontinuation arises standard continuation passing transform cps term due danvy filinski df 
observation metacontinuation represented storage cell rst exploited preliminary version fil 
application technique continuation partial evaluation reported lawall danvy call cc implementation composable continuations uniformly outperformed equivalent explicit continuation passing translation especially respect heap usage ld 
main di erence variant composable continuations considered chapter previous formulations start speci cation original operators distinguishing type system computations control ects 
correspondingly de nitional translation non trivial ect computations kind 
distinction gives simple correspondence composable continuations monadic re ection continuation monad motivating composable continuations canonical control ect 
change partially necessitated ambient ects fil target language de nitional translation assumed ect free terminology 
chapter summary analyzed new approach incorporating computational ects functional language 
ways combines best features existing purely functional imperative models ects providing basis introducing ects incrementally 
recapitulate main properties construction convenience 
important advantage monadic re ection ease ts familiar programming paradigm ml languages 
essentially front cost programs re written particular style ects settled advance directly existing type checker module system fact need explicitly mention monads writing bulk program 
typically programmer simply de nes desired operations raise handle exceptions pick results nondeterminism spawn yield resumptions monadic re ection suitable monad expresses program terms new primitives 
visible di erence manual implementation ects terms continuations state markedly part compiler amount ofe ort ingenuity required 
usually speci cation consists lines simple ect free code 
likewise exported operations generally simple combination re ection rei cation operators 
think capturing storing retrieving invoking continuations implement say backtracking search required low level code synthesized mechanically speci cation nondeterministic choice 
ease reasoning 
despite apparent imperative nature monadic re ection equally viewed technique writing purely functional programs concise notation monad comprehensions wad :10.1.1.33.5381
fact imperative program fragment extensionally equivalent monadic style counterpart sense exist language de nable isomorphisms representations 

summary crucial point correspondence monadic style means reasoning programs 
simply expressible monad having translation purely functional code vacuous properties true program continuations state monadic ects help new 
wemust exploit knowledge program expressible particular monad restrictive notion ects continuation state monad happens embedded implementation purposes 
example ml language de ned exception passing top partiality easy argue correctness source level transformation fx fx fx succeed value raise exception diverge cases expressions equivalent 
hand examine hand coded implementation exceptions terms escapes state ects purpose program argue nearly directly common subexpression elimination valid optimization principle 
ciency 
execution ciency important concern practical uses ects monadic re ection usually fares signi cantly better actual translation monadic style 
ects rare programs run full speed overhead explicitly performing administrative manipulations speci ed monad tagging checking return values exceptions 
ensure performance re ection rei cation operators need assume reasonably cient implementation call cc host language 
cps compilers providing cheap rst class continuation facility generally straightforward app 
stack implementations techniques exist keeping amortized cost call cc acceptably low hdb 
particular ect heavily may preferable rewrite program corresponding monadic style 
example parameter provided environment monad changes frequently explicit argument functions 
faster going store access probably result clearer program 
conversely course rarely arguments implicit improving execution speed clarity focusing attention cases value changes ones merely propagated 
case need done re ection rei cation interface program fragments approaches 
best solution may ect explicit parts program heavily implicit directly ected 
chapter 
opportunities extensions investigation arise naturally recursive types speci cation language 
language dening monadic ects simply typed appear fundamental problems allowing general recursive types 
fact logical relations proofs chapter handle recursion answer type continuation monads invariant relations similar techniques likelihood chapter 
proper treatment recursive types probably include merely adding types section speci cation language 
example appropriate allow recursively de ned types form explicit notion computation type variables associated extensions generalized important want treatment monad speci cations continuation passing translation de nition 
required structure anl monad usual sense parameterized anl type 
allow express example ml style ref cells storing procedures exceptions carrying non ground data introducing explicit isomorphisms 
layering ects 
potential fully realized thesis organization terms ambient focus ects generalize directly multiple layered ects 
words able integrate di erent notions ects single language series nested monadic translations step previous focus ect new notion ambient ect 
layered strategy modularly specifying ects promises generalize modular implementation ects terms continuations state 
speci cally wewould rst relate heterogeneous tower monads tower continuation monads applying level construction chapter atten cps tower single level implementation chapter collection cells holding meta continuation hierarchy 
apparently working implementation strategy exists preliminary investigations theoretical justi cation practical usefulness encouraging 
time constraints infeasible include treatment generalized construction thesis 
fully formalizing analyzing multiple ect case left 
practical ect typing monadic ects 
goals construction permit direct embedding ect enriched language ml mean take advantage re ned type system 
discipline required writing programs ects useful detect violations ect strati cation statically program execution 

closing remarks accordingly way optionally ects piece code manifest type especially module boundaries 
course achieve exporting procedures fully rei ed form 
approach tends impractically verbose additional conversions semantically transparent may impose non negligible overhead 
want concise unobtrusive way representing information direct style 
existing area tends consider mainly low level notions ects jumps state manipulation jg application speci higher level concepts 
complex relationship monadic speci cation imperative implementation highly automated analysis able detect higher level pattern exception handling system 
current ect type systems generally phrased terms curry style type inference semantics program priori independently type 
re ection approach ects hand suited church style type reconstruction type information considered inherent part program elided conciseness advocated ml hm 
closing remarks concise way stating main functional program distinguish speci cation implementation computational ects data type 
grossly summarize alternatives triad thesis implementation speci cation 
meaning ect fully determined implementation 
example scheme program written intuitive informal abstractions error handlers backtracking threads ultimately de ned expansions call cc set 
antithesis speci cation implementation 
behavior ect fully determined purely functional executable speci cation 
example haskell program written monadic style expanding explicit exception passing success lists resumptions 
synthesis implementation related speci cation 
ect declarative meaning imperative behavior obtained systematic necessarily direct way 
example means exclusively program written analyzed terms monadic re ection eventually executed ects built escapes state 
words tension haskell style monads scheme style primitive ects need resolved unilateral favor precisely interplay best qualities exposed 
appendix properties predomain model chapter summarize auxiliary results predomain semantics needed chapters somewhat tangential main development 
fairly simple adaptations standard domain theoretic results predomain setting 
recursive type de nitions proof recursive type equations solutions predomain semantics hinges exhibiting type constructor suitable functorial action category domains strict continuous functions 
addition evident action objects need action morphisms 
construct functors directly model standard notation continuous functions convenient consistent existing term syntax ects xed partiality de nitions consider denotations constructed terms 
purposes appendix extend term syntax introducing additional computation type constructor term constructors inm types inm analogous existing ambient ects referring partiality monad 
generalized result computation type 
omit explicit type subscript uniform semantic characterization meaning pointed types inm wheref generalized strict extension section lifting 

recursive type definitions embedding types de ne general case construct dispatching possibilities semantics case xi case xi xi ai ai case writing actual programs merely gives convenient way referring semantic entities predomain model 
de nition value type computation type inl extended empty type de ne atype constructor constructor wheref means substituted positive occurrences analogously negative occurrences 
de ne term constructors types follows 



hi 

hx case 

case xi yi xi 

letx hi 
gy appendix properties predomain model simple properties de nitions lemma occur free generally type directed actions compositional ag ag de nitions functorial sense inf inf inf inf endofunctor kleisli category lifting monad functor kleisli category underlying 
proof 
simple induction cases 
note veri cation value product case relies partiality commutative ect 
de ne ordinary functorial operation functions lifted types de nition andg strict functions rigid respect ects de ne term constructor 


lemma functorial sense id id id proof 
simple veri cation lemma id id id 
recursive type definitions 



ing 

ing 








gm ing recall elementary properties xed points lemma xb denote xed point operator pointed 

andg strict hg xb xb 

andg xb gf xb fg 
proof 

follows directly de nition xb gi xb gi 
simply result necessarily strict 
letx xb fg andy xb gf 
xed point gf fg 
analogously xed point monotonicity ofg vg partial order purposes chapter need solution type equation necessarily chapter need relevant isomorphism satis es additional equational property de nition cpo category pointed cpos domains strict continuous functions 
letf cpo op cpo 
cpo functor call anf mixed functor cpo locally continuous action morphisms continuous 
minimal invariant forf xx idx appendix properties predomain model show standard inverse limit construction solving recursive domain equation yields minimal invariants theorem locally continuous mixed functor cpo minimal invariant 
proof 
see pit 
get predomain language corollary recursive type equation inl solution predomain model parameterized type fag type exists iso 
interpreting asa roll asi unroll asi equation satis ed model 
unroll 
roll proof 
pointed cpo isomorphic lifted cpo 
theorem functor 



obtain pointed 


isomorphism preserves re ects expressible 
ix 
get minimal invariant property minimal invariant property wrt 
lemma rearrange body 







id admissible relations section review properties computation relations cpo semantics particular show admissibility relation forming constructs 
relational correspondence predomain ofl de nition 
notably admissibility preserved formation inverse images intersections pit 
admissible relations lemma recall computation relations closed types pointed chain complete relation andl 

arel xn terms respectively alli xi vall vall rel admissible 
rm computation types ris computation admissible andx rigid 

rj arbitrary necessarily nite countable family admissible relations relation jrj admissible rj computation admissible jrj 
proof 
parts fairly simple 
de ne continuous andf xn xn 
xn 
thena rf 


chains inl andl respectively alli ir rf 
monotonicity sequences 

form chains inl andl assumed chain complete continuity andf equivalent rf says ia ir meaning chain complete 
pointed rf follows fact proposition rigid function strict 
appendix properties predomain model 
family chain complete relations andl ai 

chains componentwise related 
exchanging universal quanti ers get assumed chain complete implies iai jrj ia required show chain completeness ofr 
similarly relates intersection jrj pointed 
show admissibility standard relational actions type constructors follow directly previous lemma lemma ther admissible relations de ned lemma ri ri relation extension taken relation lifting proposition computation admissible 
proof 
relations determined de nitions case written jn ng iri ai ji ai rig rg check case 
case cpo natural numbers discretely ordered chain constant upper bounds componentwise related chains obviously related 


ina lie entirely injects 
assume wlog 
form ai 
chain ai 
ina 
analogously related chain form assumption ia result follows observing ai ai 
isomorphisms recursive types 
case ri analogous set tags taken asi 


mi 

chains possibilities 
alli mi andm case mi 
second disjunct de nition done 
exists ani mi ai andm de nition ordering ina form chain ai ai 
analogously assumed chain complete air 
initial segment chain ect upper bound get mi ai ai directly second component de nition pointed 
nally verify xed point induction principle lemma lets computation admissible relation letf vall 
andf vall bsb xfs proof 
xx analogously forf particulars admissible chain complete model su ces show alli sf follows simple induction oni 
fori get result computation admissibility ofs 
inductive step iff sf 
assumption onf andf 
sf 
isomorphisms recursive types de nition allows act partial functions total functions lifted cpo need generality solving recursive type equations approximants total 
type directed functor acts known isomorphisms cpos necessarily pointed simpler de nition possible de nition term constructor denoting isomorphism roll unroll de ne term constructors types 
ag ag 
ag ag appendix properties predomain model follows hi case inl inl case ai ini ai letx hi 
lemma functorial actions isomorphisms related general counterparts follows 



proof 
straightforward induction note ag 
lemma letf type constructors ofl necessarily covariant ga solutions corresponding recursive type equations 
predomain model exists isomorphism satis es equivalent coherence equations roll ga unroll ga ga roll ga unroll proof 

term constructor de ne function 

terms write forf 
analogously forg 
de ne usual abbreviations roll ga roll inverses 

isomorphisms recursive types 
andj 
minimal invariants corresponding functors 
rst show exists isomorphism 
take 

jg want show thatl sided inverse ofl 
accordingly consider strict kh 
lemma gives jg jg jg jg id fg id fg jg id gf gg jg jg kh kh kh kh jg kh jg kh jg lemma simpli cation obtain ga lemma fact minimal invariant get id id direction hk similarly get jg jg hk hk hk hk parts lemma minimal invariant property ofi ll id id id take unique isomorphism knowing inverses get second part result unrolling xed point de nition jg take advantage simple relationship functorial 





appendix properties predomain model get jg ga ga particular ga ga ga ga 
ga ga ga 
lifting injective get rst coherence equation 
second analogous 
invariant relations recursive types want show certain principles constructing relations recursive types valid speci cally class behaved relational actions allows solve recursive relation equations 
presents speci results need proofs chapter general treatment see pit 
section assume xed relational correspondence predomain ofl computation extension relations 
keeping general convention appendix write 
rst characterize particularly behaved way constructing admissible relations de nition letf andf type constructors 
mixed relational andf assigns pair arel andr arel arel 
say action admissible satis es xr xr yf likewise computation type relational action called computation admissible arel andr arel carel ga xr xr yg ga yg easy see de nition computation admissible action admissible 
number standard ways constructing computation admissible relational actions lemma relational actions admissible noted forf 
invariant relations recursive types depend andr arel arbitrary admissible relation fis ifr forf andf forf af andf af wheref admissible forf andf andf admissible forf andf computation admissible andf 
forf andf wheref admissible forf andf andf admissible forf andf ifi forf andf fi admissible andf 
andg wheref admissible forf andf andg computation admissible forg gis computation admissible 
andg wheref admissible forf andf gis computation admissible 
jfj andf fj admissible forf andf fis computation admissible proof 
simple veri cation cases 
example somewhat nonstandard go details 
note computation extension relations ar fa infx inf note simply condition monad relation de nition case ambient ect partiality andr taken ther de nition 
holds de nition computation admissible pointed 
means liftings ofr related elements get required relationship case 
verify admissibility action type andg admissible action forf andf de nition show expanding de nition establish letx inr letx property relation extension assumption andy su ces show appendix properties predomain model xf inr inr 
assumption onf observation proof su ces show rf follows immediately property relation extension 
principle constructing new computation admissible actions old ones lemma computation admissible relational action forg andg pair computation type constructors 
rigid natural transformation satisfying ga hx analogously relational de ned computation admissible 
xg proof 
rst note computation admissible relation assumption ong rigidity ofh andh de nition show yg ga yg ga assumption equivalent hy follows form assumption admissible de nition admissibility andh 
get admissibility ofthe action relating ambient computations continuation passing counterparts 
invariant relations recursive types lemma type ofl arel carel 
arel letx letf andf admissible relational 
relational computation admissible andg 
proof 
note ando arel 

computation admissible forg fa 

andg lemma 
leth letx 
mapping natural transformation functors derived letr letx letr letr hm hm 


hm 

hm id lemma appear free 
identity lemma get action byg letx computation admissible nally get result lemma 
state main result motivating de nition admissible actions theorem letf admissible relational action type andf exists invariant relation forf relation arel fa unroll unroll aa proof 
proof technique due pitts essentially pit 
working binary relations unary ones details slightly involved predomains domains worth spelling construction 
usual abbreviate roll unroll rst note functorial action relations preserves inclusions 
letr andr andf clearly appendix properties predomain model 
andf 
get lemma easily see de nition relation lifting speci ally true computation extension relations general 
words monotone second argument antimonotone rst 
letr andr arbitrary relations arel fa de ne arel fa ara af af de ne operator mapping antimonotone rst position monotone second 
set admissible relations types closed arbitrary intersection arel fa op arel fa forms complete lattice 
knaster tarski xed point theorem xed point arel fa satisfying af anda af clearly xed point greater giving components inclusion remains show containment direction 
consider relation carel fa 
fa 
determined ha computation admissible intersection inverse images application rigid computation admissible de ne fa 
fa 
fa 
fa 

analogously want show 

follows usual properties relation extension equations de ning functorial action andr 
computation admissible get xed point induction lemma xh xh property corollary 
invariant relations recursive types argument proof simpli es completing proof take invariant relation forf 
immediately get recursive type equations large class recursive relation equations solutions corollary letf andf type constructors formal relation constructor built standard relational actions ofl type constructors constant admissible relations computation admissible computation types relation constructor maps arel arel 
exists arel fa unroll aa unroll aa proof 
induction lemmas directly obtain admissible mixed relational theorem invariant relation equation simply taker bibliography am andrew appel david macqueen 
standard ml new jersey 
third international symposium programming language implementation logic programming number lecture notes computer science pages passau germany august 
app andrew appel 
compiling continuations 
cambridge university press 
cm pietro eugenio moggi 
syntactic approach modularity semantics 
proceedings conference category theory computer science amsterdam september 
cwi tech 
report 
cr william clinger jonathan rees 
revised report algorithmic language scheme 
lisp pointers july 
df olivier danvy andrzej filinski 
abstracting control 
proceedings acm conference lisp functional programming pages nice france june 
df olivier danvy andrzej filinski 
representing control study cps transformation 
mathematical structures computer science december 
esp david espinosa 
semantic lego 
phd thesis graduate school arts sciences columbia university may 
fel matthias felleisen 
theory practice rst class prompts 
proceedings fifteenth annual acm symposium principles programming languages pages san diego california january 
fh matthias felleisen robert hieb 
revised report syntactic theories sequential control state 
theoretical computer science september 
fil andrzej filinski 
representing monads 
proceedings st acm sigplan sigact symposium principles programming languages pages portland oregon january 
fis michael fischer 
lambda calculus schemata 
proceedings acm conference proving assertions programs pages 
sigplan notices vol 
sigact news january 
revised version lisp symbolic computation 
bibliography matthias felleisen mitchell wand daniel friedman bruce duba 
continuations mathematical semantics handling full functional jumps 
proceedings acm conference lisp functional programming pages snowbird utah july 
gir jean yves girard 
interpretation fonctionelle elimination des coupures de ordre 
etat universite paris vii 
grr carl gunter didier remy jon riecke 
generalization exceptions control ml languages 
functional programming computer architecture 
hay christopher haynes 
logic continuations 
journal logic programming june 
hdb robert hieb kent dybvig carl bruggeman 
representing control presence rst class continuations 
proceedings acm sigplan conference programming languages design implementation pages white plains new york june 
hdm robert harper bruce duba david macqueen 
typing rst class continuations ml 
journal functional programming october 
preliminary version appeared proceedings symposium principles programming languages 
hm robert harper john mitchell 
type structure standard ml 
acm transactions programming languages systems april 
jd gregory johnson dominic duggan 
stores partial continuations rst class objects language environment 
proceedings fifteenth annual acm symposium principles programming languages pages san diego california january 
jg pierre jouvelot david gi ord 
reasoning continuations control ects 
proceedings acm sigplan conference languages design implementation pages portland oregon june 
david gi ord pierre jouvelot john lucassen mark sheldon 
fx manual edition 
technical report mit lcs tr laboratory computer science massachusetts institute technology september 
kw david king philip wadler 
combining monads 
launchbury sansom editors functional programming glasgow pages ayr scotland 
springer verlag 
ld julia lawall olivier danvy 
continuation partial evaluation 
proceedings acm conference programming pages orlando florida june 
sheng liang paul hudak mark jones 
monad transformers modular interpreters 
proceedings nd acm sigplan sigact symposium principles programming languages pages san francisco california january 
bibliography john launchbury simon peyton jones 
state haskell 
lisp symbolic computation december 
john mccarthy lisp programmer manual 
mit press cambridge massachusetts 
mit john mitchell 
foundations programming languages 
mit press 
appear 
ml saunders mac lane 
categories working mathematician volume graduate texts mathematics 
springer verlag 
mog eugenio moggi 
computational lambda calculus monads 
proceedings fourth annual symposium logic computer science pages paci grove california june 
ieee 
mog eugenio moggi 
view programming languages 
technical report ecs lfcs laboratory foundations computer science university edinburgh edinburgh scotland april 
mog eugenio moggi 
notions computation monads 
information computation july 
mor gregory morrisett 
generalizing rst class stores 
acm sigplan workshop state programming languages pages copenhagen denmark june 
technical report yaleu dcs rr department computer science yale university 
mth robin milner mads tofte robert harper 
de nition standard ml 
mit press 
mw albert meyer mitchell wand 
continuation semantics typed summary 
rohit parikh editor logics programs proceedings number lecture notes computer science pages brooklyn june 
pit andrew pitts 
relational properties domains 
information computation 
revised version cambridge computer laboratory technical report number 
appear 
plo gordon plotkin 
call name call value calculus 
theoretical computer science december 
plo gordon plotkin 
lcf considered programming language 
theoretical computer science december 
pw simon peyton jones philip wadler 
imperative functional programming 
proceedings twentieth annual acm symposium principles programming languages pages charleston south carolina january 
qs christian queinnec bernard 
dynamic extent control operator partial continuations 
proceedings eighteenth annual acm symposium principles programming languages pages orlando florida january 
bibliography rey john reynolds 
de nitional interpreters higher order programming languages 
proceedings th acm national conference pages boston august 
rey john reynolds 
relation direct continuation semantics 
jacques editor nd colloquium automata languages programming number lecture notes computer science pages saarbrucken west germany july 
rey john reynolds 
theory type structure 
robinet editor programming symposium number lecture notes computer science pages paris france april 
rey john reynolds 
discoveries continuations 
lisp symbolic computation november 
sch david schmidt 
denotational semantics methodology language development 
allyn bacon 
sf dorai sitaram matthias felleisen 
control delimiters hierarchies 
lisp symbolic computation january 
sf amr sabry matthias felleisen 
reasoning programs continuationpassing style 
lisp symbolic computation november 
earlier version appeared proceedings acm conference lisp functional programming 
smi brian smith 
re ection semantics procedural language 
phd thesis massachusetts institute technology cambridge massachusetts january 
mit lcs tr 
st ravi sethi adrian tang 
constructing call value continuation semantics 
journal acm july 
ste guy steele jr building interpreters composing monads 
proceedings st acm sigplan sigact symposium principles programming languages pages portland oregon january 
sto joseph stoy 
congruence programming language de nitions 
theoretical computer science february 
sw christopher strachey christopher wadsworth 
continuations mathematical semantics handling full jumps 
technical monograph prg oxford university computing laboratory programming research group oxford england 
wad philip wadler 
replace failure list successes 
functional programming languages computer architecture number lecture notes computer science nancy france september 
wad philip wadler 
comprehending monads 
proceedings acm conference functional programming pages nice france june 
bibliography wad philip wadler :10.1.1.33.5381
comprehending monads 
mathematical structures computer science december 
earlier version appeared proceedings acm conference lisp functional programming 
wad philip wadler 
essence functional programming invited talk 
proceedings nineteenth annual acm symposium principles programming languages pages albuquerque new mexico january 
wad philip wadler 
monads composable continuations 
lisp symbolic computation january 
wan mitchell wand 
continuation multiprocessing 
conference record lisp conference pages stanford california august 
wf mitchell wand daniel friedman 
mystery tower revealed non re ective description re ective tower 
lisp symbolic computation may 
