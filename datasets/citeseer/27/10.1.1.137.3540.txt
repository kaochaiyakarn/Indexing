learning select branching rules dpll procedure satisfiability lagoudakis cs duke edu department computer science duke university durham nc usa michael littman research att com shannon laboratory labs research florham park nj usa dpll procedure popular complete satisfiability sat solver 
worst case complexity exponential actual running time greatly affected ordering branch variables search 
branching rules proposed best cases 
investigates automated methods choosing appropriate branching rule node search tree 
consider approach value function predicts performance branching rule case learned trial runs typical problem set target class sat problems 
results indicate provided sufficient training class resulting strategy performs cases better best branching rule class 

repetitive tasks adding numbers counting votes solving instances specific problem common people computers 
true nowadays tasks performed machines humans get tired doing thing 
machines people tend improve performance repetitive task accumulate experience task 
computer general doomed steps solving problem matter time 
human quality learning embedded machine significant impact way program think computers 
proposes combine human knowledge machine power human programmers provide set different algorithms problem machine undertakes task learning time combine algorithms improve performance 
earlier algorithm selection lagoudakis littman attacked recursive algorithms sorting order statistic selection 
extends approach backtracking algorithms satisfiability sat discusses initial experimental efforts 
solving computationally demanding problems sat area learning algorithm selection significant impact 
numerous algorithms exist special cases problems modest speedup solving problems highly desirable 
section provides overview sat problem counting variation outlines basic algorithm solving 
set branching rules considered described section learning algorithm covered section 
experimental results included section section discusses difficulties faced way plans 

sat sat dpll boolean formula conjunctive normal form cnf consists boolean variables xn clauses cm 
variable take true false value 
value complement xi variable xi opposite xi 
clause disjunction distinct literals literal single variable xi complement xi 
clause satisfied iff literals takes true value 
empty clause definition unsatisfiable 
boolean formula conjunction nonempty clauses satisfiable assignment variables satisfies clauses 
empty formula definition satisfiable 
sat refers problem finding satisfying assignment formula 
assignment exists formula unsatisfiable 
example sat formula consists variables clauses 
satisfiable satisfying assignment 
number assignments satisfy boolean formula unsatisfiable tautology satisfied assignments number variables formula 
sat refers problem finding number satisfying assignments formula 
sat sat hard problems 
sat np hard problem known np complete 
general sat represents harder problem compared sat sense algorithm solves sat exact number satisfying assignments solve sat satisfying assignment 
complete 
problem counting satisfying assignments interest artificial intelligence equivalent problems network reliability valiant belief network inference roth 
algorithm sat solve probabilistic planning problems state art speeds littman 
davis putnam logemann loveland dpll procedure davis search method solving sat problems 
dpll explores space partial assignments systematic way eliminates ones lead contradiction extends incrementally promising ones 
partial assignment extended selecting unassigned variable trying turn possible assignments true false variable branching creating new partial assignments 
reduced formula created case true assignment xi eliminates clauses contain literal xi clauses satisfied appearances xi remaining clauses 
false assignment symmetric effect 
procedure applied recursively reduced formula 
key operations dpll procedure unit propagation purification steps 
unit propagation extends partial assignment presence unit clauses clauses single literal 
clauses satisfied specific assignment corresponding variable 
complementary assignment lead contradiction safely ignored 
elimination variable create new unit clauses unit propagation eliminates variables repeated passes unit clause formula 
purification applies variable xi appears formula purely positive xi negative xi form 
variables safely eliminated assigning true positive case false negative 
purification applied repeatedly pure variables created purification pass 
dpll procedure algorithmic format 
notice purification branching implemented triggering appropriate unit propagations 
dpll contains empty clause return unsatisfiable empty output current assignment return satisfiable unit propagation contains unit clause create eliminating clauses contain appearances return dpll purification contains pure literal return dpll branching select free literal dpll satisfiable return satisfiable return dpll dpll procedure modified solve sat problem littman birnbaum 
partial assignment satisfying exist possible extensions full assignment number free variables 
exploring space partial assignments possible enumerate possible satisfying assignments 
note purification case assignments pure variables take value 
modified dpll sat 
dpll contains empty clause return empty return number free variables unit propagation contains unit clause create eliminating clauses contain appearances return dpll branching select free literal return dpll dpll 
branching rules dpll worst case complexity dpll procedure exponential actual running time greatly affected choices free literals branching step 
possible reduce size search tree dpll dpll explore orders magnitude variables chosen appropriate order 
despite fact finding optimal ordering computationally difficult significant amount research devoted invention branching rules pick literals branching step dpll 
fairly practice compared random strategy provide guarantees optimality 
branching rules general compute score free literal score free variable cases scores complementary literals combined way balance branches search path search say fruitful explored score score score 
variable maximizes score selected 
branch decided favor literal maximum individual score 
decision affects dpll procedure dpll explore branches anyway order matter 
branching rules listed 
hooker vinay li anbulagan provide extensive reviews branching rules 
rule selects literal maximum number occurrences formula number occurrences formula 
idea splitting choice wide spread effect formula 
rule similar counts occurrences literals minimum size clauses occurrences minimum size clauses 
rationale minimum size clauses play important role search reveal contradiction enable unit propagations quickly 
novel combination previous rules 
particularly true sat branches explored anyway 
idea desirable satisfy clauses possible create clauses minimum size possible 
jw wang rule combines ideas exponential weighting jw nj cj nj number literals clause cj 
smaller clauses weight larger ones 
rule probes search making trial assignment free literal counting number triggered unit propagations due assignment unit props triggered setting true 
unit propagations better unit propagation eliminates variable 
gup greedy version previous rule 
trial assignments discovered assignment literal leads contradiction satisfaction series triggered unit propagations 
literal immediately selected branch 
gup scores literals way 
sup selective version 
due huge computational cost rule sup runs inexpensive rules jw suggest distinct literals selects scoring function 
cost trial assignments unit propagations paid fixed number free literals promising ones 

learning select branching rules algorithm selection problem selecting efficient algorithm equivalent ones problem instance rice 
original form algorithm selection involves shot decision best algorithm selected applied instance decision making 
lagoudakis littman extended algorithm selection cases involve recursive computations 
recursive algorithms included set time recursive call algorithm selection process invoked select available algorithms 
key advantage approach combined hybrid algorithm results multiple decisions potential perform better individual algorithms 
hand decision making task harder involves sequence decisions 
natural approach recursive algorithm selection problem markov decision processes mdp framework ideas reinforcement learning rl 
framework agent seeks optimal policy function selects actions possible state process objective minimizing total expected cost 
process evolves state space dynamics system actions taken agent 
agent reinforced signal indicates immediate cost transition 
algorithm selection problem state consists description current instance subinstance consideration terms features size 
actions available algorithms problem 
choosing non recursive algorithm results transition final state problem solved cost choice execution time taken transition 
contrary choosing recursive algorithm results transition states recursive call new decisions 
cost paid execution time taken excluding time taken recursive calls 
goal minimize total expected cost definition total execution time particular instance 
mainstream approach solving problems construction computation learning value function predicts expected total cost action state acting optimally 
cases state space fairly big explicit tabular representation value function expensive terms storage computation learning 
reason parametric approximators represent value function problem finding set parameters maximizes accuracy approximator 
common class approximators called linear architectures value function approximated linear weighted combination basis functions features weights parameters 
linear architectures popular studied methods squares projection determining appropriate parameters bradtke barto boyan 
learning setup dpll branching rules branching rules dpll procedure thought alternatives available time algorithm branch 
equivalent sense success failure search depend tremendous impact size search tree running time dpll 
branching rules best classes sat problems performance dependent features current instance problem distribution drawn 
branching node dpll corresponds sat subinstance plausible able select best branching rule node features particular subinstance 
conform mdp terminology state process consists features current sat sub instance example number variables number clauses number literals main requirement features carry information performance branching rules varying value feature result varying performance branching rules 
features easily computable minimize overhead 
branching rules available possible actions branching node 
matter branching rule chosen search continues directions branches 
direction series unit propagations performed arriving node kind branching node unit clauses unit propagation continue 
new state new decision 
contradiction node current partial assignment causes contradiction formula 
search branch terminated 
absorbing state mdp 
satisfaction node current partial assignment satisfies entire formula 
search branch terminated number satisfying assignments computed 
absorbing state mdp 
action state results possibly absorbing new states 
state transition violates standard mdp definition thought cloning mdp creating copy transition 
copies continue independently 
point focus sat problem associated dpll procedure represent general case fit goal minimizing entire search tree 
immediate cost paid choosing branching rule computed different ways 
total number search nodes results unit propagations original new states node cost paid decision original node 
immediate cost choosing branching rules jw 
branching rules perform trial partial searches determine branching variable 
total number nodes created trial searches added node cost branching rules gup sup 
definition cost function implies total accumulated cost complete run dpll procedure size entire search tree terms nodes plus total count nodes created trial searches 
minimizing total cost way minimize total running time proportional total number nodes explored 
state representation state process description sat sub instance consideration terms easily computable features 
candidate features include limited number variables number clauses number literals minimum size clauses number minimum size clauses ratio variables clauses unfortunately size state space grows exponentially number features compromise features informative part state 
best hope characterization instance 
series experiments visualizations gathered data performed determine relevance candidate feature problem 
different combinations features tried tests performed sat instances different classes 
tests suggested really useful feature number variables formula 
surprising considering size problem instance crucial factor expected amount computational resources needed solve instance 
particular case performance branching rule pure function useful information gained rate increase cost different sizes 
surprising adding features state representation improve worsened performance 
rest state representation sat instance consist number variables instance 
simple representation take way goal 
possibilities discussed 
value function approximation accomplish goal minimizing search tree dpll procedure seek learn state action value function predicts expected total node cost action state acting optimally 
general fixed action exponential fact extensive experimentation learning tabular representations variety problem distributions approximated parametric form 
polynomial degree coefficients constant term ni approximation certainly nonlinear logarithm approximated linear architecture log basis functions approximation goal find learn best set parameters approximation accurate 
learning algorithm learning algorithm combination temporal difference learning squares 
action matrix vector maintained number basis functions 
parameters computed solution system updated incrementally way solution squares solution approximation 
entries initially set 
consider sample transition state action branching rule chosen causing transitions states total node cost note transitions branching nodes greater contradiction satisfaction nodes set absorbing state 
new sample computed bellman optimality equation min min note base exponential convenient choice 
base net change multiplicative constant coefficients values computed straight current approximation 
new sample inserted follows 
weight factor determine importance sample set 
reason reweighting typical run dpll procedure exponentially samples region leaves tree compared samples region root tree 
inherent weighting bias squares solution 
reweighting scheme attempts cancel effect defining total number variables original sat instance samples taken 
current approximation determining new samples problematic especially learning process approximator inaccurate 
way problem go learning phases 
phase value functions fixed policy consisting single branching rule action learned 
case new samples computed 
approximation problematic run dpll fixed values smaller learned values bigger fairly accurate invoked 
words learning interactions branching rules ignored evaluated separately 
second phase value functions approximation 
minimum operator determining new samples interactions branching rules taken account 
policy construction policy selecting branching rules constructed dynamically value function 
depending value function learned different policies may result 
particular consider cases ind state select branching rule minimizes 
policy results individual value functions branching rule 
state select branching rule minimizes 
case learned approximation phases 
scr state select branching rule minimizes 
case learned scratch 
rnd state select branching rules uniformly random 
purely randomized policy measure comparison 

experimental results sat instances experimentation fall classes graph coloring sat encodings graph coloring problems available online satisfiability library satlib flat set encodes problems nodes edges colors 
sat encodings contain variables clauses 
random cnf random satisfiable cnf instances generated generator allen van gelder network reliability sat encodings feed forward networks 
sat solution instance indicates number possible routes source sink provides measure reliability network 
random deep unit propagation instances variables clauses consist disjoint 
subinstance variables allows deep unit propagations chained clauses fixed 
second variables random cnf generated generator 
designed distribution exhibit different behavior 
results graph coloring classes 
results classes similar graph coloring class 
url www satlib org available dimacs rutgers edu pub challenge satisfiability contributed ucsc instances 
average number nodes jw gup sup ind scr rnd 
performance nodes graph coloring class 
methodology class problems set instances training 
phase learning individual value functions learned going training set branching rule solely branching rule 
second phase passes set executed randomized policy rest total passes 
learning scratch total passes performed 
sets learned parameters stored corresponding policies ind scr described previously 
polynomial degree approximation 
performance learned policies tested separate test set instances class 
instances test set solved average number nodes average running time recorded 
results compared performance individual branching rules test set purely random policy rnd 
code written experiments performed alpha lx machine 
running times correlated closely node counts approximately nodes sec reported 
performance results shows performance branching rules learned policies instances taken graph coloring class error bars indicate reliability intervals 
learned policies ind scr achieve performance level equal best branching rules better 
better chance values log number variables gup sup jw 
learned value function graph coloring class 
rnd bar indicates 
behavior easily explained looking learned value function 
number variables state process branching rules jw indistinguishable clearly dominate gup sup 
case selection scheme take advantage switching different branching rules resulting performance matches dominating branching rule 
performance results class shown 
case learned policies ind statistically better individual branching rules 
learning scratch scr best individual branching rule twophase learning yields better approximations case 
interesting moving ind improve performance corresponding value functions quite different 
looking value function easy see dominating branching rule switching branching rules run time advantage 
see region presumably solve variable subinstance region gup branching rules variable subinstance appropriate 
case size single state feature sufficient find cut regimes large performance difference 

limitations main weakness clearly insufficient state representation 
number variables provides average number nodes jw gup sup ind scr rnd 
performance nodes class 
coarse partition space possible sat instances throws away structure problem 
state description partition space instances way different branching rules best different regions partition 
state features sat discovered 
features induced graph width candidates come significant computational cost outweigh usefulness 
demonstrates degree reasoning learning decision making top traditional search algorithms improve performance possible fixed set hand built branching rules 
acknowledgments research supported part nsf iri 
author partially supported lilian foundation greece 
authors gratefully acknowledge influence don loveland ron parr henry kautz helping shape 
birnbaum 

old davis putnam procedure helps counting models 
journal artificial intelligence research 
boyan 

squares temporal difference learning 
machine learning proceedings sixteenth international conference pp 

morgan kaufmann san francisco ca 
bradtke barto 

linear squares algorithms temporal difference learning 
machine learning 
values log gup number variables jw sup 
learned value function class 
davis logemann loveland 

machine program theorem proving 
communications acm 
hooker vinay 

branching rules satisfiability 
journal automated reasoning 
lagoudakis littman 

algorithm selection reinforcement learning 
proceedings seventeenth international conference machine learning pp 

morgan kaufmann san francisco ca 
li anbulagan 
heuristics unit propagation satisfiability problems 
proceedings fifteenth international joint conference artificial intelligence pp 

nagoya japan 
littman 

new approach probabilistic planning 
proceedings fourth international conference artificial intelligence planning pp 

aaai press 
rice 

algorithm selection problem 
advances computers 
roth 

hardness approximate reasoning 
artificial intelligence 
valiant 

complexity enumeration reliability problems 
siam journal computing 
