priority tree practically efficient worst case optimal tree lars arge mark de berg herman ke yi priority tree pr tree tree variant answers window query os number ddimensional hyper rectangles stored tree disk block size output size 
provably asymptotically optimal significantly better rtree variants query may visit leaves tree 
extensive experimental study practical performance pr tree real life synthetic data 
study shows pr tree performs similar best known tree variants real life relatively nicely distributed data outperforms significantly extreme data 
categories subject descriptors data structures trees analysis algorithms problem complexity algorithms problems geometrical problems computations information storage retrieval content analysis indexing indexing methods general terms algorithms experimentation additional key words phrases trees spatial data naturally arise numerous applications including geographical information systems computer aided design computer vision robotics 
spatial database systems designed store manage manipulate spatial data received considerable attention years 
databases involve massive datasets disk index structures spatial data researched extensively see survey gaede nther gg :10.1.1.137.9369
especially tree gut numerous variants see survey manolopoulos emerged practically efficient indexing methods 
priority tree pr tree tree variant practically efficient provably asymptotically optimal 
preliminary version appears acm sigmod international conference management data 
department computer science university aarhus aarhus denmark 
email large daimi au dk herman net 
department computer science tu eindhoven box mb eindhoven netherlands 
email berg tue nl 
department computer science duke university box durham nc usa 
email cs duke edu tree constructed rectangles 
block size 
background previous results objects stored spatial database complex approximated simpler objects spatial indexes built approximations 
commonly approximation minimal bounding box smallest axis parallel hyper rectangle contains object 
tree originally proposed guttman gut index rectangles 
height balanced multi way tree similar tree bm com node root degree 
leaf contains data rectangles possibly pointer original data leaves level tree internal node contains pointers children child minimal bounding box covering rectangles leaves subtree rooted child 
shows example 
number rectangles fits disk block tree rectangles occupies disk blocks height log 
types queries answered efficiently tree including common query called window query query rectangle retrieve rectangles intersect answer query simply start root tree recursively visit nodes minimal bounding boxes intersecting encountering leaf report data rectangles intersecting guttman gave algorithms updating tree log os tree algorithms gut 
unique tree dataset window query performance intuitively depends amount overlap minimal bounding boxes nodes tree natural try minimize bounding box overlap updates 
led development heuristic update algorithms see example bkss kf srf refer surveys gg 
specialized algorithms bulk loading tree developed bbk dkl kf lle rl 
algorithms logm os number os needed sort elements number rectangles fits main memory log os needed build index repeated insertion 
furthermore typically produce trees better space utilization query performance trees built repeated insertion 
example experimental results shown average space utilization dynamically maintained trees bkss bulk loading algorithms capable obtaining space utilization 
bulk loading tree course updated standard tree updating algorithms 
case query efficiency space utilization may degenerate time 
common class tree bulk loading algorithms sorting rectangles global dimensional criterion placing leaves order building rest index bottom level level dkl kf lle 
dimensions socalled packed hilbert tree kamel faloutsos kf sorts rectangles hilbert values centers shown especially query efficient practice 
hilbert value point length fractal hilbert space filling curve origin hilbert curve clustering spatially close rectangles leading index 
variant packed hilbert tree takes extent rectangles account just center dimensional hilbert tree kf structure rectangle xmin ymin xmax ymax mapped dimensional point xmin ymin xmax ymax rectangles sorted positions points dimensional hilbert curve 
experimentally dimensional hilbert tree shown behave slightly worse packed hilbert tree nicely distributed realistic data kf 
intuitively vulnerable extreme datasets takes extent input rectangles account 
algorithms bulk load trees top manner developed 
algorithms recursively trying find partition data bbk 
called top greedy split tgs algorithm garc pez leutenegger shown result especially query efficient trees tgs trees 
build root subtree tree set rectangles algorithm repeatedly partitions rectangles sets divided subsets approximately equal size 
subset bounding box stored root subtrees constructed recursively subsets 
binary partitions takes set rectangles splits subsets dimensional orderings dimensions orderings considered xmin ymin xmax ymax 
ordering algorithm calculates possible partitioning possibilities sum areas bounding boxes subsets result partition 
applies binary partition minimizes sum 
tgs tree shown slightly better query performance tree variants construction algorithm uses os needs scan rectangles order binary partition 
fact worst case algorithm may take logb os 
practice fact partition decision binary effectively means algorithm uses log os 
done evaluating practical query performance tree variants mentioned little known theoretical worst case performance 
theoretical trees concerned estimating expected cost queries assumptions uniform distribution input queries assuming input points rectangles 
see survey manolopoulos 
bulk loading algorithm non trivial guarantee resulting worst case query performance agarwal 
dimensions algorithm constructs tree answers window query logb os number reported rectangles 
leaves gap lower bound number os needed answer window query ks 
input consists points rectangles worst case optimal query performance achieved kdb tree rob tree ks 
unfortunately hard modify garc describe variants top greedy method 
described efficient practice 
order achieve close space utilization size subsets created rounded nearest power remainder set 
result node level including root may children 
structures rectangles 
agarwal developed number trees worst case query performance certain conditions input 
results section new tree variant call priority tree pr tree short 
call structure priority tree bulk loading algorithm utilizes called priority rectangles way similar structure agarwal 
window queries answered os pr tree index tree variant answers queries asymptotically optimal number os worst case 
contrast previous tree bulk loading algorithms construct set rectangles query zero output leaves packed hilbert tree dimensional hilbert tree tgs tree need visited answer query 
show bulk load pr tree efficiently logm os 
bulk loading pr tree updated logb os standard tree updating algorithms maintaining query efficiency 
alternatively external logarithmic method av develop structure supports insertions deletions logb logm log logb os amortized respectively maintaining optimal query performance 
section extensive experimental study practical performance pr tree real life synthetic data 
compare performance index twodimensional rectangles packed hilbert tree dimensional hilbert tree tgs tree 
experiments show trees answer queries number os relatively square uniformly distributed rectangles 
extreme data large rectangles rectangles high aspect ratios non uniformly distributed rectangles pr tree dimensional hilbert tree outperforms significantly 
special worst case dataset pr tree outperforms order magnitude 
priority tree section describe pr tree 
simplicity describe dimensional pseudo pr tree section 
pseudo pr tree answers window queries efficiently real tree leaves level 
section show obtain real dimensional pr tree pseudo pr tree section discuss extend pr tree dimensions 
section explain pseudo pr tree serve basis structure supports efficient insertions deletions maintaining optimal query efficiency 
section show query packed hilbert tree dimensional hilbert tree tgs tree forced visit leaves 
dimensional pseudo pr trees section describe dimensional pseudo pr tree 
tree pseudo pr tree input rectangles leaves internal node contains minimal bounding box children tree leaves level tree internal nodes degree 
basic idea pseudo pr tree similar dimensional hilbert tree view input rectangle xmin ymin xmax ymax dimensional point xmin ymin xmax ymax 
pseudo pr tree basically just kd tree points corresponding input rectangles extra leaves added internal node 
intuitively socalled priority leaves contain extreme points rectangles dimensions 
note dimensional kd tree easily mapped back tree structure simply replacing split value kd tree node minimal bounding box input rectangles stored subtree rooted 
idea priority leaves introduced structure agarwal priority leaves size section give precise definition pseudo pr tree section show answer window query os 
section describe construct structure efficiently 
structure 
rn set rectangles plane assume simplicity coordinates defining rectangles equal 
define xmin ri ymin ri xmax ri ymax ri mapping ri xmin ri ymin ri xmax ri ymax ri point dimensions define points corresponding pseudo pr tree ts defined recursively contains rectangles ts consists single leaf ts consists node children priority leaves recursive pseudo pr trees 
child store minimal bounding box input rectangles stored subtree rooted node priority leaves constructed follows priority leaf xmin contains rectangles minimal xmin coordinates second ymin rectangles remaining rectangles minimal ymin coordinates third xmax rectangles remaining rectangles maximal xmax coordinates fourth ymax rectangles remaining rectangles maximal ymax coordinates 
priority leaves contain extreme rectangles ones leftmost left edges bottommost bottom edges rightmost right edges topmost top edges 
constructing priority leaves divide set sr remaining rectangles subsets approximately size recursively construct pseudo pr trees ts ts 
division performed xmin ymin xmax ymax coordinate round robin fashion building dimensional kd tree constructing root ts divide xmin values level recursion ymin values xmax values ymax values xmin values 
refer example 
note dividing say xmin corresponds dividing vertical line half rectangles sr left edge left half left edge right 
store node leaf ts disk blocks leaves contain rectangles obtain section discuss guarantee leaf full 
lemma pseudo pr tree set rectangles plane occupies disk blocks 
may contain rectangles put rectangles priority leaves 
case may assume put just construct single leaf 
xmin ymax xmin ymin query complexity split xmin xmax ymax ts xmax ts ymin construction internal node pseudo pr tree 
answer window query pseudo pr tree exactly tree recursively visiting nodes minimal bounding boxes intersecting known tree variants pseudo pr tree prove non trivial fact optimal bound number os performed procedure 
lemma window query pseudo pr tree rectangles plane uses os worst case 
xmin xmax xmax ymin xmax xmin ymin ymax xmax proof lemma plane upper dimensional space lower xmin ymax dimensions shown 
note dimensional hyperplane dimensional space 
contains dimensional facet transformation query range dimensions 
proof ts pseudo pr tree set rectangles plane 
prove query bound bound number nodes ts kd nodes priority leaves visited order answer query rectangular range total number leaves visited factor larger 
note bound number nodes visited rectangles priority leaves parent reported 
just need bound number visited kd nodes case 
parent node priority leaves reported completely priority leaf contains rectangle intersecting rectangle separated line containing sides refer 
assume loss generality vertical line xmin left edge right edge lies left left edge xmax xmin 
means point dimensional space corresponding lies left axis parallel hyperplane intersects xmax axis xmin 
recall ts basically kd tree priority leaves added dimensional region associated 
query visits rectangle subtree rooted xmax xmin lies right follows contains points sides intersect observe rectangles priority leaf xmax separated line xmin left edge rectangles xmax extreme positive direction lies completely left rectangles children including lie left case visited 
definition rectangles xmax intersect line sides say horizontal line ymax separates rectangle xmax hyperplane cuts ymin axis ymax intersects 
arguments dimensional hyperplanes defined xmin xmax ymin ymax intersect region associated viewing ts dimensional kd tree 
intersection hyperplanes xmax dimensional plane dimensional space intersects priority leaves removed ts dimensional kd tree leaves straightforward generalization standard analysis kd trees know axis parallel dimensional plane intersects regions associated nodes tree 
remains observe defines planes pair sides 
bound number nodes priority leaves visited query procedure rectangles priority leaves parent reported 
efficient construction algorithm log os simply constructing node time definition section 
describe reasonable assumption amount available main memory bulk load ts logm os 
algorithm modified version kd tree construction algorithm described note easy bulk load pseudo pr tree ts set rectangles easiest described constructing dimensional kd tree ts points construction algorithm construct preprocessing step sorted lists containing points sorted xmin ymin xmax ymax coordinate respectively 
construct log levels tree recursively construct rest tree 
construct log levels ts efficiently proceed follows 
choose parameter explained sorted lists find kn th coordinate points dimension 
coordinates define grid size scan count number points grid cell 
choose keep counts main memory 
build log levels ts worrying priority leaves construct root ts find slice grid cells common xmin coordinate hyperplane orthogonal xmin axis passes cells half points side half points side 
scanning bz blocks contain points grid cells determine exact xmin value hyperplane defined xmin divides points subsets half points 
constructing subdivide grid cells intersected divide cells compute counts bz blocks contain points grid cells 
construct kd tree side hyperplane defined recursively cycling possible cutting directions 
create new cells time create node ensure grid fits main memory constructing nodes log log levels ts 
constructing log kd tree levels construct priority leaves nodes 
reserve main memory space points priority leaves main memory hold priority leaves assumption 
fill priority leaves scanning filtering point kd tree follows start root ts check priority leaves xmin ymin xmax ymax order 
encounter non full leaf simply place encounter full leaf extreme relevant direction extreme point replace continue filtering process checking ymax continue check priority leaves child ts region contains point processing child arrived leaf level kd tree simply continue point easy see process correctly constructs top log levels pseudo pr tree ts kd tree divisions slightly different ones defined section points priority leaves removed divisions computed 
bound lemma holds term depend choice divisions kd tree analysis brought term depends fact child gets half points parent 
constructing log levels priority leaves scan sorted lists divide sorted lists leaves constructed kd tree omitting points stored priority leaves 
lists contain points writing constructed kd tree priority leaves disk construct rest ts recursively 
note number points recursive call gets smaller simply construct rest tree internal memory node time 
way slightly unbalanced divisions multiple points side dividing hyperplane 
guarantee get non full leaf subtree size obtain space utilization 
avoid having leaf may violate assumptions update algorithms may priority leaves parent slightly smaller leaves contain rectangles 
implies bound lemma holds 
lemma pseudo pr tree bulk loaded rectangles plane os 
log proof initial construction sorted lists takes logm os 
construct log levels ts os construct initial grid bz construct nodes total os 
constructing priority leaves filtering takes os distribution remaining points recursive calls 
recursive step takes os total 
lemma follows log levels recursion 
log logm dimensional pr tree section describe obtain pr tree degree leaves level pseudo pr tree degree leaves levels maintaining window query bound 
pr tree built stages bottom stage construct leaves tree set input rectangles stage construct nodes vi level tree set si rectangles consisting minimal bounding boxes nodes vi level 
stage consists constructing pseudo pr tree tsi si vi simply consists priority normal leaves tsi internal nodes discarded bottom construction ends set si small rectangles si pointers corresponding subtrees fit block root pr tree 
subtle difference pseudo pr tree algorithm stage algorithm stages 
stage construct leaves input rectangles 
stages construct nodes pointers children bounding boxes subtrees 
number children fits node differ constant factor number rectangles fits leaf number children analysis difference matter ignored simplicity 
theorem pr tree set rectangles plane bulk loaded os window query answered os 
log proof lemma stage pr tree bulk loading algorithm uses si logm si os 
complete pr tree constructed log log bi logm logm os 
analyze number os answer window query analyze number nodes visited level tree 
ti number nodes visited level nodes level leaves correspond leaves pseudo pr tree input rectangles follows lemma 
particular constants 
ti rectangles nodes level pr tree intersect nodes contain bounding boxes nodes level 
nodes level correspond leaves pseudo pr tree rectangles si follows lemma ti ti 
write recurrence log cti bi bi bi ti follows ti ti summing levels log find total number nodes visited levels log higher levels nodes just add additive constant conclude nodes visited total 
multi dimensional pr tree section briefly sketch pr tree generalizes dimensions greater 
focus generalize pseudo pr trees dimensional pr tree obtained dimensional pseudo pr trees exactly way dimensional case dimensional pr tree asymptotic performance dimensional pseudo pr tree proved exactly dimensional case 
recall dimensional pseudo pr tree basically dimensional kd tree priority leaves containing extreme rectangles directions added internal node 
similarly dimensional pseudo pr tree basically dimensional kd tree node priority leaves extreme rectangles standard directions 
constant structure constructed logm os grid method dimensional case section difference order fit dimensional grid main memory decrease number nodes produced recursive stage 
analyze number os answer window query dimensional pseudo analyze number visited internal nodes dimensional case section total number visited nodes factor higher priority leaves visited internal node visited 
dimensional case bound number nodes visited rectangles priority leaves parent reported 
number nodes visited priority leaf parent contains rectangle intersecting query bounded argument similar dimensions equal number regions associated nodes dimensional kd tree leaves intersect dimensional intersection orthogonal hyperplanes 
follows straightforward generalization standard kd tree analysis 
theorem pr tree set dimensional hyper rectangles bulk loaded log os window query answered os 
lpr tree doing insertions deletions section describe analyze logarithmic pseudo pr tree lpr tree short 
tree enables maintain tree structure efficiently losing worst case optimal query time 
structure lpr tree differs normal tree ways 
leaves different levels 
second internal nodes store additional information explained 
exactly query algorithms real tree lpr tree 
describe lpr tree dimensions generalization higher dimensions done way pr trees 
structure lpr tree consists root number subtrees 
subtree normal pseudo pr tree internal nodes kd nodes store additional information kd nodes grouped share blocks disk 
adaptations serve efficient deletions possible 
refer subtrees apr trees annotated pseudo pr trees 
internal node apr tree information stored pointers children bounding box child split value cut dimensional kd tree priority leaf extreme value relevant coordinate rectangle stored leaf memory 
tm tm 
log br log disk lpr tree 
bright part kept main memory dark part stored disk 
largest xmin coordinate xmin largest ymin coordinate ymin smallest xmax coordinate xmax smallest ymax coordinate ymax recall internal nodes pseudo pr trees degree 
apr tree group nodes blocks follows 
internal node depth tree mod log store block descendant internal nodes level log 
sections keep writing nodes share block separate nodes analysis fact follow path length tree log os 
lpr tree structure results applying logarithmic method av apr trees 
lpr tree log subtrees log 
subtree stores rectangles ti apr tree stores rectangles 
contain leaf subtrees may nodes 
smaller subtrees tree tm log total size log keep subtrees completely main memory 
larger subtrees tree log tree tl log keep top levels main memory total size log lb log log ib 
lower levels larger subtrees stored disk 
subtrees tm tl stored disk completely 
algorithms bulk load lpr tree set rectangles build apr tree rectangles store log 
subtrees left empty 
insert rectangle lpr tree proceed follows 
check 
full find subtree tj smallest tj empty 
take rectangles tj build new apr tree tj 
old apr trees ti discarded 
having sure space add 
delete rectangle lpr tree proceed follows 
search subtree ti 
start root subtree internal node compare information stored priority leaves split value decide child continue search 
find leaf contains delete 
leaf priority leaf parent kd nodes possibly children check contains rectangles 
case done 
check leaves follow sequence xmin ymin xmax ymax priority leaves leaf priority leaves find rectangles leaves extreme relevant coordinate 
move rectangles result leaves drawn may containing rectangles replenish similar manner 
leaves kd nodes priority leaves kd nodes kd children 
just leave delete completely empty 
clean rebuild entire lpr tree scratch bulk loading algorithm 
precisely maintain counter number rectangles clean counter number insertions counter number deletions 
soon clean 
query complexity verify query lpr tree efficiently 
lemma window query lpr tree rectangles plane needs os worst case 
proof apr tree structure similar pseudo pr tree result deletions apr tree somewhat unbalanced 
deletions kd nodes apr tree ti form subset kd nodes apr tree rectangles 
furthermore deletion algorithm ensures priority leaves apr tree contain rectangles possibly priority leaves kd nodes 
easy see analysis pseudo pr trees proof lemma goes just write number leaves 
find number nodes visited apr tree ti ti ti number answers ti 
sum number os needed trees ti find log bulk loading complexity lemma lpr tree bulk loaded ti logm os 
proof bulk loading apr tree log algorithm pseudo pr trees storing additional information grouping internal nodes blocks additional cost 
algorithm uses os lemma 
logm lpr tree initialized bulk loading set number rectangles bulk loading consider bulk loading clean 
insertion complexity lemma inserting rectangle lpr tree takes logm log os amortized 
proof bound os spent insertions done clean operations including os needed second clean caused insertion 
just clean rectangles stored tk log 
recall insertion full finds empty tree tj constructs tj 
tj 
tree tk involved new rectangle inserted kb insertions filled trees ti happen second clean clean done soon kb rectangles inserted earlier triggered deletions 
clean caused insertion charge cost logm os lemma insertions caused logm os amortized insertion 
clean ups caused deletions charged deletions see section remains account construction trees tj clean ups trees tj constructed main memory 
note rectangles inserted clean involved 
lemma cost constructing tj logm os amortized rectangle tree 
tj constructed rectangles put come tree ti follows rectangle included log times new tree partly built external memory 
leads amortized cost moving rectangles clean ups logm log os 
adding bounds see moving rectangles clean ups dominates gives bound claimed 
deletion complexity lemma deleting rectangle lpr tree takes logb log os amortized 
proof need find rectangle 
worst case check apr trees log partially stored disk 
higher levels trees stored main memory remaining internal nodes blocked groups height log walking path apr tree takes logb os 
total logb log os may needed locate rectangle 
priority leaves accounted follows 
external height priority leaf largest number kd nodes path apr tree stored disk priority leaves stored disk 
higher levels larger apr trees stored main memory log 
rank priority leaf times external height minus rank siblings xmin ymin xmax ymax remove rectangle priority leaf put charge place rank priority leaf 
replenish priority leaf gets half empty implies contains total charge moving rectangles lower ranked priority leaves create gaps priority leaves lower rank need put total charge place 
priority leaf frees charge pays os needed replenish priority leaves takes max log os amortized deletion 
lpr tree rebuilt cost os lemma 
deletion amortized 
logm logm adding amortized cost locating deleting rectangle priority leaves os amortized 
rebuilding lpr tree find deletion takes log log speeding deletions insertion rectangle leads building subtree ti put rectangles inserted stored previously built subtree tj possible find rectangle lpr tree searching log subtrees ti stored disk just need keep track time insertion rectangle 
want find particular rectangle lpr tree need search subtree ti constructed earliest rectangle insertion lpr tree 
need keep additional structures lpr tree single number time initially set zero increase update put unique time stamps update operations time index implemented tree top log levels kept main memory lower levels stored disk 
time index stores rectangle forest time stamp insertion 
type key uniquely identifies rectangles 
main memory non empty subtree ti time built 
algorithms modified follows 
lpr tree cleaned set time zero rebuild time index store zero time stamp rectangles 
subtree ti built modified insertion increment time record time construction ti 
rectangle inserted increment time insert rectangle key time stamp time index 
rectangle deleted query time index get rectangle time insertion find subtree ti constructed earliest rectangle inserted search ti find lemma lpr tree time stamps bulk loaded logm os 
proof lpr tree built logm os lemma 
time index built time bound sort keys rectangles logm os build tree 
lemma inserting rectangle lpr tree time stamps takes log os amortized 
log log proof inserting rectangle lpr tree logm log lemma 
inserting rectangle time index takes logb get bound claimed 
os amortized os 
add bounds lemma deleting rectangle lpr tree time stamps takes log os amortized 
os 
result os 
os amortized see proof lemma os lemma proof find rectangle time index takes logb determine subtree ti search walking subtree takes logb priority leaves takes log rebuilding lpr tree soon takes logm logm logb os amortized deletion 
worst case example lemmas lead theorem 
theorem lpr tree time stamps set rectangles plane bulk loaded logm os window query answered os worst case rectangle inserted logb logm log os amortized os amortized 
rectangle deleted log lower bound heuristic trees pr tree tree variant answers window query worst case optimally 
fact tree variants forced visit nodes answer query rectangles reported 
section show case packed hilbert tree dimensional hilbert tree tgs tree 
theorem exist set rectangles window query intersect rectangles nodes visited answered packed hilbert tree dimensional hilbert tree tgs tree proof construct set points leaves packed hilbert tree hilbert tree tgs tree visited answering line query touch point 
theorem follows points lines special rectangles 
convenience assume positive integers leaf tree contains rectangles internal node fanout construct grid columns rows column shifted little depending horizontal position row fact hammersley point set see cha 
precisely point pij xij yij xij yij number obtained reversing reading backwards bit binary representation example shown 
examine structure tree variants dataset 
packed hilbert tree packed hilbert tree sorts points hilbert values 
compare hilbert values points check lie quadrant sufficiently large square sides powers case square size suffices 
lie quadrant zoom quadrant see lie quadrant 
keep zooming arrive level points lie different quadrants 
decide quadrant comes hilbert curve 
consider points pij pi 
note yij yi smaller bits decimal point coordinates points zero 
addition xij xi starting square size zoom levels deep distinguish positions pij pi hilbert curve 
hand xij xi coordinates pij pi differ bits decimal point 
zoom levels compare basis ignoring result hilbert column tgs partitioning worst case example 
vertical division creates bounding boxes total area 
horizontal division creates bounding boxes total area 
curve visits columns grid points visits column visits points column proceeding column 
packed hilbert tree leaf column horizontal line chosen intersect columns touching point 
dimensional hilbert tree analysis similar packed hilbert trees 
tgs tree tgs algorithm partition subsets equal size partition subset recursively 
partitioning implemented choosing partitioning line separates set subsets sizes multiples applying binary partitions subsets recursively partitioned set subsets size observe levels recursion partitioning line leave fraction input side line 
prove tgs partition vertical lines follows tgs eventually put column leaf 
line query intersect leaves report 
suppose tgs partition subset consists columns inclusive pij 
greedy split algorithm gets divide set look vertical partitioning line horizontal partitioning line 
intuitively tgs favors partitioning lines create big gap bounding boxes points side line 
show constructed area gap created horizontal partitioning line roughly area gap created vertical line bigger 
partitioning vertical line leave gap roughly square fits columns see 
precisely partition set sets 
bounding boxes sets height total width total area av 
width gap horizontal partitioning line depends number columns 
columns involved bigger density points columns projected axis lower gap created see illustration 
result partitioning horizontal line lead gaps wide low relatively high wide case area gap roughly 
precisely estimate total area bounding boxes resulting partitioning horizontal line follows 
partitioning line leave fraction points side full row side line 
width bounding boxes resulting partition step 
observe set contains different multiples largest value log smallest multiple 
note go values bits bit representation remain constant bits assume possible values 
consequently bits remain constant bits assume possible values 
project points axis distance pair consecutive points tb distance topmost bottommost point 
partition set horizontal line total height resulting bounding boxes total area ah tb 
log find ah recall av 
conclude ah av partitioning vertical line result smaller total area bounding boxes horizontal line 
result tgs cut vertically columns 
experiments section describe results experimental study performance pr tree 
compared pr tree bulk loading methods known generate query efficient trees packed hilbert tree denoted rest section dimensional hilbert tree denoted tgs tree denoted tgs 
tgs reported best query performance takes os bulk load 
contrast simple bulk load worse query performance take extent input rectangles account 
reported inferior kf takes extent account tgs intuitively vulnerable extreme datasets 
experimental setup implemented bulk loading algorithms tpie 
tpie library provides support implementing efficient algorithms data structures 
implementation bytes represent input rectangle bytes coordinate bytes able hold pointer original object 
bounding box internal nodes bytes bytes coordinate bytes pointer disk block storing root corresponding subtree 
disk block size chosen kb resulting maximum fanout 
similar earlier experimental studies typically block sizes ranging kb kb fix fan number close 
experimental platform dedicated dell workstation pentium iii mhz processor running freebsd 
local gb scsi disk ibm store necessary files input data trees temporary files 
restricted main memory mb restricted amount memory available tpie mb rest reserved operating system daemons 
datasets real life synthetic data experiments 
real life data real life data tiger line data tig geographical features united states 
data standard benchmark data spatial databases 
distributed cd roms chose experiment road line segments cd roms disk containing data sixteen eastern states disk containing data western states eastern western refer datasets respectively 
obtain datasets varying sizes divided eastern dataset regions roughly equal size put increasing number regions obtain datasets increasing sizes 
largest set just eastern dataset 
dataset bounding boxes line segments input rectangles 
result eastern dataset rectangles total size mb western data set rectangles total size mb 
refer table sizes smaller eastern datasets 
note biggest dataset larger previous works rectangles kf 
note tiger data relatively nicely distributed consist relatively small rectangles long roads divided short segments somewhat badly clustered urban areas 
synthetic data dataset rectangles size mb table sizes eastern datasets investigate different trees perform extreme datasets tiger data generated number synthetic datasets 
synthetic datasets consisted rectangles mb unit square 
size max side designed class synthetic datasets investigate trees handle rectangles different sizes 
size max side dataset rectangle centers uniformly distributed lengths sides uniformly independently distributed max side 
generating datasets discarded rectangles completely inside unit square sure dataset rectangles 
portion dataset size shown 
aspect second class synthetic datasets designed investigate handle rectangles different aspect ratios 
areas rectangles datasets fixed reasonably small size 
aspect dataset rectangle centers uniformly distributed aspect ratios fixed longest sides chosen vertical horizontal equal probability 
sure rectangles fell completely inside unit square 
portion dataset aspect shown 
note input rectangles bounding boxes line segments horizontal vertical get rectangles high aspect ratio infinite case horizontal vertical segments 
skewed real life multidimensional datasets different dimensions different distributions 
distributions may highly skewed compared 
designed third class datasets investigate affects tree performance 
skewed consists uniformly distributed points squeezed dimension point replaced 
example skewed shown 
cluster final dataset designed illustrate worst case behavior tgs trees 
similar worst case example discussed section 
consists clusters centers equally spaced horizontal line 
cluster consists points uniformly distributed square surrounding center 
shows part cluster dataset 
experimental results discuss results bulk loading query experiments tree variants 
synthetic dataset size synthetic dataset aspect synthetic dataset skewed synthetic dataset cluster hilbert pr tree pr greedy tgs hilbert pr tree pr greedy tgs western data eastern data mln mln mln mln mln mln bulk loading performance tiger data upper time lower 
bulk loading performance bulk loaded trees real life tiger datasets synthetic datasets various parameter values 
experiments trees achieved space utilization 
measured time spent counted number kb blocks read written bulk loading trees 
note algorithms tested read write blocks exclusively sequential large parts data result faster blocks read written random order 
shows results experiments eastern western datasets 
experiments yield result algorithms number os roughly times fewer os pr 
surprising algorithms logm bounds pr algorithm complicated algorithms 
tgs algorithm uses roughly times os pr surprising algorithm binary partitions number levels recursion effectively log 
terms time algorithms times faster pr algorithm tgs algorithm roughly times slower pr 
shows pr cpu intensive tgs 
shows results experiments eastern datasets 
experiments show pr algorithms scale relatively linearly dataset size result logm factor bulk loading bound datasets 
means core step algorithm sorting rectangles position hilbert curve runs number passes experiments 
pr algorithm means build grid divide cells set rectangles big fit memory 
recursive steps done main memory 
cost tgs algorithm grow slightly superlinear way size data set 
result log factor bulk loading bound data sets 
means data sets subtrees just root level roughly size logb rectangles big fit main memory need significant number os build 
preprocessing accounts big portion number os scales linearly size data set 
slightly superlinear trend comes cost building root varies roughly total number os set roughly set shaded 
experiments synthetic data performance pr bulk loading algorithms practically datasets unaffected trees bulk loaded subsequently updated dynamically near space utilization desirable dkl 
mainly interested query performance tree constructed different bulk loading methods methods modified way produce non full leaves considered near utilization case 
blocks read written tgs pr mln mln mln mln mln time seconds tgs mln mln mln mln mln rectangles bulk loading performances eastern datasets left time right size max side aspect skewed cluster bulk loading time seconds top greedy split synthetic data sets rectangles size aspect points skewed cluster 
data distribution 
surprising performance depend dataset size synthetic datasets size 
pr algorithm performance varied slightly explained small effect data distribution grid method bulk loading algorithm subtrees may slightly different sizes due removal priority boxes 
average algorithms spent seconds os synthetic datasets pr algorithm spent seconds os 
hand expected performance tgs algorithm varied significantly synthetic datasets tried binary partitions algorithm depend heavily input data distribution 
tgs algorithm times slower pr algorithm terms times slower terms time 
performance tgs algorithm size max side aspect skewed cluster datasets shown 
pr pr tgs hilbert hilbert pr tree pr greedy tgs total area rectangles output query performance queries squares varying size western tiger data left eastern tiger data right 
performance number blocks read divided output size query performance bulk loading tree variants experimented query performance experiments performed randomly generated queries computing average performance exact description queries 
previous experimental studies utilized cache buffer store internal tree nodes queries 
fact experiments cached internal nodes occupied mb 
means reporting number os needed answer query effect reporting number leaves visited order answer query 
reasons previous experimental studies bkss kf kf collect timing data 
main reasons robust measure performance query time easily affected operating system caching disk block layout interested heavy load scenarios cache memory available caches ineffective dominates query time 
tiger data performed query experiments eastern western datasets 
results summarized 
show results experiments square window queries areas range area bounding box input rectangles 
smaller queries previous experimental studies example maximum query kf occupies area datasets larger datasets previous experiments reducing query size output unrealistically large reporting cost dominate query performance 
show results experiments eastern datasets various sizes fixed query size 
results show tree variants perform remarkably tiger data performance answer queries close minimum number necessary os 
relative performance generally agrees earlier results kf tgs performs better turn better experiments cache disabled showed experiments cache relatively little effect window query performance 
pr tgs hilbert hilbert pr tree pr greedy tgs mln rectangles input rectangles output query performance queries squares area eastern tiger data sets varying size 
performance number blocks read divided output size 
pr consistently performs slightly better slightly worse tgs 
synthetic data 
performed experiments synthetic datasets designed investigate different trees perform extreme datasets tiger data 
datasets size aspect skewed performed experiments varied parameter obtain data ranging fairly normal extreme 
summarize results 
left side shows results experiments dataset size max side varying max side relatively small relatively large rectangles 
queries squares area 
results show relatively small input rectangles tiger data tree variants perform close minimum number necessary os 
input rectangles get larger pr clearly outperform tgs 
performs worst surprising take extent input rectangles account 
tgs performs significantly better worse pr 
intuitively pr handle large rectangles better rigorously divide rectangles groups rectangles similar coordinates 
may enable algorithms group answers large rectangles retrieved os 
enables algorithms group small rectangles nicely tgs strives minimize total area bounding boxes may indifferent distribution small rectangles presence large rectangles 
middle shows results experiments dataset aspect vary go rectangles constant area small large aspect ratio 
query squares area 
results similar results size dataset experiments aspect ratio increases pr significantly better tgs especially size dataset pr performs perform close minimum number necessary os answer query 
set experiments re emphasizes pr tree tree able adopt varying extent 
right side shows result experiments dataset skewed vary go uniformly distributed point set tgs pr tgs rectangles pr output size max side aspect skewed pr tgs tgs query performance queries squares area synthetic data sets 
performance number blocks read divided output size skewed point set 
query squares area skewed way dataset corner transformed output size remains roughly 
expected pr performance unaffected transformations bulk loading algorithm relative order coordinates coordinates compared coordinates coordinates compared coordinates interaction 
hand query performance trees degenerates quickly point set gets skewed 
final experiment queried cluster dataset long skinny horizontal queries area clusters coordinate leftmost bottom corner chosen randomly query passed clusters 
results shown table 
anticipated query performance tgs bad cluster dataset constructed illustrate worst case behavior structures 
query returns input points average query algorithm visits leaves tgs respectively 
comparison leaves visited pr 
pr tree outperforms indexes order magnitude 
tree pr tgs os tree visited table query performances synthetic dataset cluster 
experiments main experimental study pr tree theoretically efficient practically efficient 
bulk loading algorithm slower packed hilbert hilbert bulk loading algorithms faster tgs tree bulk loading algorithm 
furthermore tgs tree performance bulk loading algorithm depend data distribution 
query performance trees excellent nicely distributed data including real life tiger data 
extreme data pr tree robust trees dimensional hilbert tree relatively robust 
concluding remarks pr tree tree variant answer window query optimal os 
performed extensive experimental study showed pr tree optimal theory performs excellent practice normal data quite competitive best known heuristics bulk loading trees packed hilbert tree kf tgs tree data extreme shapes distributions outperforms significantly 
pr tree updated known update heuristic trees performance guaranteed theoretically anymore practical performance suffer 
alternatively lpr tree theoretical worst case query performance pr tree updated efficiently logarithmic method 
wish experiment dynamic behavior pr tree lpr tree see happens performance apply heuristic update algorithms theoretically superior logarithmic method 
agarwal arge procopiuc vitter 
framework index bulk loading 
proc 
international colloquium automata languages programming pages 
pankaj agarwal mark de berg joachim mikael herman 
box trees trees near optimal query time 
discrete computational geometry 
arge procopiuc vitter 
implementing efficient data structures tpie 
proc 
european symposium algorithms pages 
av arge 
efficient dynamic planar point location 
computational geometry theory applications 
bbk berchtold hm 
kriegel 
improving query performance highdimensional index structures bulk load operations 
proc 
conference extending database technology lncs pages 
bkss beckmann 
kriegel schneider seeger 
tree efficient robust access method points rectangles 
proc 
sigmod international conference management data pages 
bm bayer mccreight 
organization maintenance large ordered indexes 
acta informatica 
cha chazelle 
discrepancy method randomness complexity 
cambridge university press new york 
com comer 
ubiquitous tree 
acm computing surveys 
dkl dewitt kabra luo patel 
yu 
client server paradise 
proc 
international conference large databases pages 
gg gaede nther :10.1.1.137.9369
multidimensional access methods 
acm computing surveys 
yv garc mario pez scott leutenegger 
greedy algorithm bulk loading trees 
proc 
th acm symposium advances gis pages 
gut guttman 
trees dynamic index structure spatial searching 
proc 
sigmod international conference management data pages 
herman mark de berg joachim 
box trees collision checking industrial installations 
proc 
acm symposium computational geometry pages 
kf kamel faloutsos 
packing trees 
proc 
international conference information knowledge management pages 
kf kamel faloutsos 
hilbert tree improved tree fractals 
proc 
international conference large databases pages 
ks singh 
optimal dynamic range searching non replicating index structures 
proc 
international conference database theory lncs pages 
lle leutenegger pez 
str simple efficient algorithm tree packing 
proc 
ieee international conference data engineering pages 
manolopoulos nanopoulos papadopoulos theodoridis 
trees grown 
submitted acm computing surveys 
procopiuc agarwal arge vitter 
tree dynamic scalable kd tree 
proc 
international symposium spatial temporal databases 
rl roussopoulos 
direct spatial search pictorial databases packed trees 
proc 
sigmod international conference management data pages 
rob robinson 
tree search structure large multidimensional dynamic indexes 
proc 
sigmod international conference management data pages 
srf sellis roussopoulos faloutsos 
tree dynamic index multidimensional objects 
proc 
international conference large databases pages 
tig tiger line tm files technical documentation 
washington dc september 
www census gov geo tiger tiger pdf 

