uniprocessor garbage collection techniques submitted acm computing surveys paul wilson survey basic garbage collection algorithms variations incremental generational collection discuss low level implementation considerations relationships storage management systems languages compilers 
attempt uni ed view traversal strategies addressing issues conservatism opportunism immediacy reclamation point implementation details signi cant impact performance 
contents automatic storage reclamation motivation phase abstraction object representations overview basic garbage collection techniques counting problem cycles ciency problem deferred counting 
variations counting mark sweep collection mark compact collection copying garbage collection simple copying collector copy semispaces 
ciency copying collection 
non copying implicit collection choosing basic tracing techniques problems simple tracing collectors conservatism garbage collection incremental tracing collectors coherence conservatism marking incremental approaches write barrier algorithms snapshot algorithms incremental update write barrier algorithms baker read barrier algorithms incremental copying baker incremental non copying algorithm treadmill conservatism baker read barrier variations read barrier replication copying collection coherence conservatism revisited coherence conservatism non copying collection coherence conservatism copying collection radical collection opportunistic tracing comparing incremental techniques real time tracing collection root set scanning guaranteeing su cient progress trading worst case performance expected performance discussion choosing incremental algorithm generational garbage collection multiple varying collection frequencies advancement policies heap organization subareas copying schemes generations non copying schemes discussion tracking intergenerational indirection tables ungar remembered sets page marking word marking card marking store lists discussion generational principle revisited pitfalls generational collection pig snake problem small heap allocated objects large root sets real time generational collection locality considerations varieties locality ects locality allocation short lived objects locality traversals clustering longer lived objects static grouping dynamic reorganization coordination paging low level implementation issues pointer tags object headers conservative pointer finding linguistic support smart pointers compiler cooperation optimizations gc anytime vs safe points collection partitioned register sets vs variable representation recording optimization garbage collection free storage management compact representations heap data gc related language features weak pointers finalization multiple differently managed heaps cost garbage collection areas research automatic storage reclamation garbage collection automatic reclamation computer storage knu coh app 
systems programmers explicitly reclaim heap memory point program free dispose statement garbage collected systems free programmer burden 
garbage collector function nd data objects longer space available reuse running program 
object considered garbage subject reclamation reachable running program path pointer traversals 
live potentially reachable objects preserved collector ensuring program traverse dangling pointer deallocated object 
surveys basic advanced techniques uniprocessor garbage collectors especially developed decade 
thorough treatment older techniques see knu coh 
cover parallel distributed collection presents uni ed taxonomy incremental techniques lays groundwork understanding parallel distributed collection 
focus garbage collection procedural objectoriented languages information serve understanding garbage collection kinds systems functional logic programming languages 
reading various advanced topics garbage collection papers collected bc starting point 
motivation garbage collection necessary fully modular programming avoid introducing unnecessary intermodule dependencies 
routine operating data structure term heap simple sense storage allows dynamically allocated object freed time confused heap data structures maintain ordering constraints 
term object loosely include structured data record records structs full edged objects encapsulation inheritance sense object oriented programming 
repository papers postscript format available anonymous internet ftp ftp host cs utexas edu pub garbage 
things repository contains collected papers garbage collection workshops held conjunction acm oopsla conferences 
routines may operating structure reason coordinate activities 
objects deallocated explicitly module responsible knowing modules interested particular object 
property introduces nonlocal bookkeeping routines locally understandable composable 
bookkeeping inhibits abstraction reduces extensibility new functionality implemented bookkeeping code updated 
runtime cost bookkeeping may signi cant cases may introduce need additional synchronization concurrent applications 
unnecessary complications subtle interactions created explicit storage allocation especially troublesome programming mistakes break basic abstractions programming language making errors hard diagnose 
failing reclaim memory proper point memory leaks memory gradually accumulating process terminates swap space exhausted 
reclaiming memory soon lead strange behavior object space may reused store completely di erent object old pointer exists 
memory may interpreted di erent objects simultaneously updates causing unpredictable mutations 
programming errors particularly dangerous fail show making debugging di cult show program stressed unusual way 
allocator happens reuse particular object space dangling pointer may cause problem 
delivery application may crash di erent set memory demands linked di erent allocation routine 
slow leak may noticeable program normal ways program terminates extra space 
code incorporated long running server program server eventually exhaust available memory crash 
available help pro long running server programs especially vulnerable leaks due exception handling 
exception handling code may fail deallocate objects allocated aborted operation occasional failures may cause leak extremely hard diagnose 
nd source leaked objects languages explicit deallocation hj extremely valuable 
unfortunately tools nd actual leaks particular program runs possible leaks due uncommon execution patterns 
finding source leaked object solve problem programmer able determine point object deallocated exists 
doesn exist program restructured 
kind garbage debugging better fallible repeated programs change desirable eliminate leaks general certain detectable leaks particular 
explicit allocation reclamation lead program errors subtle ways 
common programmers allocate moderate number objects statically unnecessary allocate heap decide reclaim 
leads xed limitations programs making fail limitations exceeded possibly years computer memories data sets larger 
brittleness code reusable undocumented limits cause fail away consistent abstractions 
example compilers fail faced programs violate assumptions normal programming practices 
problems lead applications programmers implement form application speci garbage collection large software system avoid headaches explicit storage management 
large programs data types implement counting example 
coded shot application collectors incomplete buggy 
garbage collectors unreliable hard integrated programming language 
fact exist despite problems testimony value garbage collection suggests garbage collection part programming language implementations 
widely believed garbage collection quite expensive relative explicit heap management studies shown garbage collection cheaper app explicit deallocation usually competitive zor 
explain implemented garbage collector slow running programs roughly percent relative explicit heap deallocation high performance system 
signi cant number programmers regard cost unacceptable believe small price bene ts convenience development time reliability 
reliable cost comparisons di cult partly explicit deallocation ects structure programs ways may expensive directly impact software development process 
example explicit heap management motivates extra copying objects deallocation decisions locally copy piece information deallocate nished 
incurs extra heap allocation undermines objectoriented design strategy identities objects may important store 
ciency cost extra measure fairly compare program garbage collection program written di erently garbage collection assumed 
long run poor program structure may incur extra development maintenance costs may cause programmer time spent maintaining inelegant code optimizing time critical parts applications garbage collection costs explicit deallocation savings human resources may increased attention aspects system 
reasons garbage collected languages long programming sophisticated algorithms complex data structures 
garbage collected languages lisp prolog originally popular arti cial intelligence programming useful generalpurpose programming 
functional logic programming languages generally incorporate garbage collection unpredictable execution patterns especially di gram storage deallocation 
cult explicitly pro uential object estimate part principle think garbage collection performance somewhat better practice worse 
reasons limitations estimate discussed sect 

practical problem state art garbage collectors available high performance programming systems 
example reports estimated developer ort mesa system spent dealing di cult storage management issues rov 
oriented programming language smalltalk incorporates garbage collection garbage collection incorporated general purpose languages ei el self dylan including designed part low level systems programming modula oberon 
add packages exist retro garbage collection 
rest focus garbage collectors built language implementation grafted language importing routines library 
usual arrangement heap allocation routines perform special actions reclaim space necessary memory request easily satis ed 
explicit calls unnecessary calls collector implicit calls allocator allocator invokes garbage collector necessary free space needs 
collectors require cooperation compiler interpreter object formats recognizable garbage collector certain invariants preserved running code 
depending details garbage collector may require slight changes compiler code generator emit certain extra information compile time execute di erent instruction sequences run time boe wh bc 
contrary widespread misconceptions con ict compiled language garbage collection state art implementations garbage collected languages sophisticated optimizing compilers 
phase abstraction garbage collection automatically reclaims space occupied data objects running program access 
data objects referred garbage 
basic functioning garbage collector consists abstractly speaking parts 
distinguishing live objects garbage way garbage detection 
reclaiming garbage objects storage running program garbage reclamation 
practice phases may functionally temporally interleaved reclamation technique strongly dependent garbage detection technique 
general garbage collectors liveness criterion somewhat conservative systems 
optimizing compiler avalue may considered dead point running program determined control ow data ow analysis 
garbage collector typically uses simpler dynamic criterion de ned terms root set reachability roots 
moment garbage collector invoked active variables considered live 
typically includes statically allocated global module variables local variables activation records activation stack variables currently registers 
variables form root set traversal 
heap objects directly reachable ofthese variables accessed running program preserved 
addition program traverse pointers objects reach objects object reachable live object live 
set live objects simply set objects directed path pointers roots 
object reachable root set garbage useless legal sequence program actions allow program reach object 
garbage objects ect course computation space may safely reclaimed 
object representations simplifying assumption heap objects self identifying easy determine time 
implementations statically typed garbage collected languages typically hidden header elds heap objects extra eld containing type information decode format object 
especially useful nding pointers objects 
information easily generated compiler information generate correct code objects elds 
dynamically typed languages lisp smalltalk usually tagged pointers slightly shortened representation hardware address small type identifying eld place missing address bits 
allows short immutable objects particular small integers represented unique bit patterns stored directly address part eld referred address 
tagged representation supports polymorphic elds immediate objects pointer object heap 
usually short tags augmented additional information heap allocated objects headers 
purely statically typed language runtime type information necessary types root set variables 
discussed sect despite headers statically typed languages simpli es implementations little cost 
conventional explicit heap management systems object headers similar reasons 
garbage collectors conservative pointer nding bw usable little cooperation compiler types named variables defer discussion collectors sect overview remainder discuss basic advanced topics garbage collection 
basic algorithms include counting mark sweep mark compact copying implicit collection discussed sect 

incremental techniques sect 
allow garbage collection proceed piecemeal applications running 
techniques reduce garbage collection may provide realtime guarantees 
generalized concurrent collections proceed processor parallel actual program execution 
generational schemes sect 
improve ciency locality garbage collecting smaller area exploiting typical lifetime characteristics avoid undue overhead long lived objects 
collections small area typical pause times short applications acceptable alternative incremental collection 
section discusses locality properties systems di erent systems 
section explores lowlevel implementation considerations object formats compiler cooperation section describes language level constraints features systems 
section presents basic sketches research garbage collection parallel distributed persistent systems 
heap space basic garbage collection techniques basic part operation garbage collector variations possible 
rst part distinguishing live objects garbage may ways counting 
general term tracing include marking copying techniques taken ld 
counting garbage collectors maintain counts number pointers object count local approximation determining true liveness 
tracing collectors determine liveness directly traversing pointers program traverse nd objects program reach 
varieties tracing collection mark sweep mark compact copying non copying implicit reclamation 
garbage detection scheme major uence reclamation reuse techniques introduce reclamation methods go 
counting counting system col object associated count pointers 
time object created pointer copied place assignment pointed object count incremented 
existing object eliminated count decremented 
see fig 
memory occupied object may reclaimed object count equals zero indicates pointers object exist running program reach 
straightforward counting system object typically header eld information describing object includes sub eld count 
header information count generally visible language level 
object reclaimed pointer elds examined objects holds pointers authors term garbage collection narrower sense excludes counting systems prefer inclusive sense popular usage awkward automatic storage reclamation 
root set counting 
counts decremented garbage object don count determining liveness 
reclaiming object may lead transitive decrementing counts reclaiming objects 
example pointer large data structure garbage counts objects structure typically zero objects reclaimed 
terms phase garbage collection adjustment checking counts implements rst phase reclamation phase occurs counts hit zero 
operations interleaved execution program may occur pointer created destroyed 
advantage counting incremental nature operation garbage collection updating counts interleaved closely running program execution 
easily completely incremental real time performing small bounded amount ofwork unit program execution 
clearly normal count adjustments intrinsically incremental involving operations operation program executes 
transitive reclamation data structures deferred done little time keeping list freed objects counts zero haven processed 
incremental collection easily satisfy real time requirements guaranteeing memory management operations halt executing program brief period 
support applications guaranteed response time critical incremental collection ensures program allowed perform signi cant appreciably reduced amount ofwork signi cant amount time 
subtleties real time requirements discussed context tracing collection sect 
minor problem counting systems counts take space 
systems machine word object count eld allowing represent exist system 
systems shorter eld provision ow count reaches maximum represented eld size count xed maximum value object reclaimed 
objects objects reachable reclaimed mechanism typically tracing collector run occasionally explain fall back reclamation strategy usually required anyway 
major problems counting garbage collectors ective di cult cient 
problem cycles ectiveness problem counting fails reclaim circular structures 
pointers group objects create directed cycle objects counts reduced zero objects root set mcb 
illustrates problem 
consider isolated pair objects right 
holds pointer count 
path root leads program reach 
conceptually speaking problem counting really determines conservative approximation true liveness 
object pointed object clearly garbage converse true 
may circular structures unusual 
data structures acyclic uncommon normal programs create cycles programs create 
example nodes trees mayhave backpointers parents facilitate certain operations 
complex cycles root set heap space counting cycle 
times formed hybrid data structures combine advantages simpler data structures application domain semantics data naturally expressed cycles 
systems counting garbage collectors usually include kind garbage collector cyclic garbage accumulates method reclaim 
programmers counting systems early versions smalltalk modi ed programming style avoid creation cyclic garbage break cycles nuisance 
negative impact program structure programs storage leaks accumulate cyclic garbage reclaimed means 
leaks turn compromise real time nature algorithm system may non real time collector critical moment 
ciency problem ciency problem counting cost generally proportional amount done running program fairly large constant proportionality 
cost pointer created destroyed referent count adjusted 
variable value changed pointer objects counts bob describes modi cations counting allow handle special cases cyclic structures restricts programmer certain stereotyped patterns 
adjusted object count incremented decremented checked see reached zero 
short lived stack variables incur great deal overhead simple counting scheme 
argument passed example new pointer appears stack usually disappears immediately procedure activations near leaves call graph return shortly called 
cases counts incremented decremented back original value soon 
desirable optimize away increments decrements cancel 
deferred counting 
cost optimized away special treatment local variables db bak 
adjusting counts reclaiming objects counts zero local variables included bookkeeping time 
usually counts adjusted re ect pointers heap object 
means counts accurate pointers stack destroyed accounted turn means objects count drops zero may 
garbage collection done stack taken account aswell 
counts brought stack heap objects 
objects counts zero may safely reclaimed 
interval phases generally chosen short garbage reclaimed quickly long cost periodically updating counts stack high 
deferred counting db avoids adjusting counts short lived pointers stack greatly reduces overhead counting 
pointers heap object created destroyed counts adjusted 
cost roughly proportional amount ofwork done running program systems lower constant proportionality 
variations counting optimization counting avery small count eld single bit avoid need large eld object wf 
deferred counting avoids need continually represent pointers stack single bit su cient objects minority objects counts zero reclaimed counting system fall back tracing collector 
bit count represented pointer object unused address bit requiring header eld scn 
cost counting collection harder escape 
objects counts go zero reclaimed bookkeeping done available running program 
typically involves linking freed objects free lists reusable objects program allocation requests satis ed 
strategies discussed context mark sweep collection sect 
objects pointer elds examined referents freed 
di cult reclamation operations take tens instructions object cost proportional number objects allocated running program 
costs counting collection combined failure reclaim circular structures unattractive implementors years 
explain techniques usually cient reliable 
counting advantages 
immediacy reclamation advantages memory usage locality det counting system may perform little degradation heap space occupied live objects collectors rely trading space higher ciency 
useful nalization performing clean actions closing les objects die rov discussed sect 

inability reclaim cyclic structures problem languages cyclic data structures purely functional languages 
similarly relatively high cost side ecting pointers heap objects problem languages side ects 
ref wlm shows generational techniques recapture locality 
erence counts systems 
example may support optimizations functional language implementations allowing destructive modi cation uniquely referenced objects 
distributed garbage collection bene local nature garbage collection compared global tracing 
con gurations cost counting incurred pointers objects nodes tracing collection node compute changes counts nodes 
systems may nd uses counting hybrid collectors involving techniques augmented specialized hardware ps wis gc cpu costs 
counting highperformance implementations general purpose programming languages quite common applications acyclic data structures common 
le systems counting manage les disk blocks 
simplicity simple counting various software packages including simple interpretive languages graphical toolkits 
despite weakness area reclaiming cycles counting common systems cycles may occur 
mark sweep collection mark sweep garbage collectors mcc named phases implement garbage collection algorithm described earlier 
distinguish live objects garbage 
done tracing starting root set traversing graph pointer relationships usually depth rst breadth rst traversal 
objects reached marked way altering bits objects recording bitmap kind table 

reclaim garbage 
live objects distinguishable garbage objects memory swept exhaustively examined nd unmarked garbage objects reclaim space 
traditionally counting reclaimed objects linked free lists accessible allocation routines 
detailed descriptions traversal marking algorithms knu coh 
major problems traditional mark sweep garbage collectors 
di cult handle objects varying sizes fragmentation available memory 
garbage objects space reclaimed interspersed live objects allocation large objects may di cult small garbage objects may add large contiguous space 
mitigated somewhat keeping separate free lists objects varying sizes merging adjacent free spaces remain 
system choose allocate memory needed create small data objects divide large contiguous free memory risk permanently fragmenting 
fragmentation problem unique marksweep occurs counting explicit heap management schemes 
second problem mark sweep collection cost collection proportional size heap including live garbage objects 
live objects marked garbage objects collected imposing fundamental limitation possible improvement ciency 
third problem involves locality 
objects moved live objects remain place collection interspersed free space 
new objects allocated spaces result objects di erent ages interleaved memory 
negative implications locality simple mark sweep collectors considered unsuitable virtual memory applications 
possible working set active objects scattered virtual memory pages pages frequently swapped main memory 
problem may bad thought objects created clusters typically active time 
fragmentation locality problems unavoidable general case potential problem programs 
noted problems may insurmountable su ciently clever implementation techniques 
example bitmap mark bits bits checked bit integer alu operation conditional branch 
live objects tend survive clusters memory apparently greatly diminish constant proportionality phase cost theoretical linear dependence heap size troublesome rst glance 
clus tered survival objects may mitigate locality problems re allocating space live objects objects tend survive die groups memory hay objects di erent program phases may major consideration 
mark compact collection mark compact collectors remedy fragmentation allocation problems mark sweep collectors 
mark sweep marking phase traverses marks reachable objects 
objects compacted moving live objects live objects contiguous 
leaves rest memory single contiguous free space 
done linear scan memory nding live objects sliding adjacent previous object 
eventually live objects slid adjacent 
leaves contiguous occupied area heap memory implicitly moving holes contiguous area 
sliding compaction interesting properties 
contiguous free area eliminates fragmentation problems allocating objects various sizes simple 
allocation implemented incrementing pointer contiguous area memory way di erent sized objects allocated stack 
addition garbage spaces simply squeezed disturbing original ordering objects memory 
ameliorate locality problems allocation ordering usually similar subsequent access orderings arbitrary ordering imposed copying garbage collector cg cla 
locality results sliding compaction advantageous collection process shares mark sweep unfortunate property passes data required 
initial marking phase sliding passes live objects cn 
pass computes new locations objects moved subsequent update pointers refer objects new locations move objects 
algorithms may significantly slower mark sweep large percentage data survives compacted 
alternative approach daniel edwards pointer algorithm scans inward ends heap space nd opportunities described exercise page knu 
compaction 
pointer scans downward top heap looking live objects scans upward bottom looking holes put 
variations algorithm possible deal multiple areas holding di objects avoid objects widely dispersed areas 
compacting algorithms see cn 
copying garbage collection mark compact mark sweep copying garbage collection really collect garbage 
moves live objects area rest heap known available contains garbage 
garbage collection systems implicit researchers avoid applying term process 
copying collectors marking compacting collectors move objects reached traversal contiguous area 
mark compact collectors separate marking phase traverses live data copying collectors integrate traversal data copying process objects need traversed 
objects moved contiguous destination area reached traversal 
needed proportional amount live data copied 
term scavenging applied copying traversal consists picking worthwhile objects garbage away 
simple copying collector copy semispaces 
avery common kind copying garbage collector semispace collector fy cheney algorithm copying traversal che 
collector model 
scheme space devoted heap subdivided contiguous semispaces 
normal program execution semispaces shown fig 

memory allocated linearly upward current semispace historical note rst copying collector minsky collector lisp min 
copying data area memory single heap space 
live data copied le disk read back contiguous area heap space 
modern machines slow le operations writing reading live object times slower memory operations 
fromspace root set tospace simple semispace garbage collector garbage collection 
fromspace root set tospace semispace collector garbage collection 
demanded executing program 
mark compact collector ability allocate large contiguous free space allocation simple fast stack fragmentation problem allocating objects various sizes 
running program demands allocation unused area current semispace program stopped copying garbage collector called reclaim space term copy 
live data copied current semispace fromspace semispace tospace 
copying completed tospace semispace current semispace program execution resumed 
roles spaces reversed time garbage collector invoked 
see fig 
simplest form copying traversal cheney algorithm che 
objects form initial queue objects breadth rst traversal 
scan pointer advanced rst object location location 
time pointer fromspace encountered referred object transported queue pointer object updated refer new copy 
free pointer advanced scan continues 
ects node expansion breadth rst traversal reaching copying descendants node 
see fig 

reachable data structures fromspace shown top gure followed rst states tospace collection proceeds tospace shown linear address order emphasize linear scanning copying 
stopping rst object scanning process simply continues subsequent objects nding spring copying 
continuous scan queue ect removing consecutive nodes nding spring 
spring copied queue 
eventually scan reaches queue signifying objects copied scanned descendants 
means reachable objects copied scavenging process nished 
slightly complex process needed objects reached multiple paths copied tospace multiple times 
object transported tospace forwarding pointer installed old version object 
forwarding pointer signi es old object obsolete indicates nd new copy object 
scanning process nds pointer fromspace object refers checked forwarding pointer 
moved tospace pointer itwas reached simply updated point new location 
ensures transported exactly pointers object updated refer new copy 
ciency copying collection 
copying garbage collector arbitrarily efcient su cient memory available lar app 
done collection proportional amount live data time garbage collection 
assuming approximately amount scan free aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa scan free root set ii iii iv aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa scan free aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa scan free aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa scan free aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa cheney algorithm breadth rst copying 
data live time program execution decreasing frequency garbage collections decrease total amount garbage collection ort 
simple way decrease frequency garbage collections increase amount memory heap 
semispace bigger program run longer lling 
way looking decreasing frequency garbage collections increasing average age objects garbage collection time 
objects garbage garbage collection needn copied chance object increased 
suppose example program run megabytes memory allocated megabyte live time 
megabyte semispaces garbage collected times 
current semispace third full collection leaves megabytes allocated collection 
means system copy half data allocates shown top part fig 

arrows represent copying live objects semispaces garbage collections 
hand size semispaces doubled megabytes free space available collection 
force garbage collections third times run 
straightforwardly reduces cost garbage collection half shown bottom part fig 

moment ignore virtual memory paging costs assuming larger heap area cached ram paged disk 
explain sect 
paging costs may larger heap area impractical correspondingly large amount 
non copying implicit collection wang wan baker bak dependently proposed new kind non copying collector ciency advantages copying scheme 
insight copying collector spaces collector really just particular implementation sets 
tracing process removes objects set subject garbage collection tracing complete remaining set known garbage set reclaimed entirety 
implementation sets just provided similar performance characteristics 
particular pointer object easy determine set addition easy switch roles sets just fromspace tospace roles exchanged copy collector 
copying collector set area memory collector kind set chunks memory held live objects 
non copying system adds pointer elds color eld object 
elds invisible application programmer serve storage doubly linked list serves set 
color eld indicates set object belongs 
operation collector simple isomorphic copy collector operation 
wang refers fake copying collector 
chunks free space initially linked form doubly linked list chunks holding allocated objects linked list 
free list exhausted collector traverses live objects moves allocated set call set 
implemented unlinking object doubly linked list toggling color eld linking doubly linked list 
just copy collector space reclamation implicit 
reachable objects traversed moved known contain garbage 
list free space immediately put free list 
explain section baker scheme somewhat complex collector incremental 
cost collection proportional number live objects garbage objects reclaimed small constant time 
scheme optimized ways analogous copying collector allocation fast allocated free lists contiguous separated allocation pointer 
unlinking objects list linking allocator simply advance pointer list divides allocated segment free segment 
similarly cheney style breadth rst traversal implemented pair pointers scanned free lists contiguous advancing scan pointer requires advancing pointer separates 
scheme advantages disadvantages aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa memory usage semispace gc mb top mb bottom semispaces compared copy collector 
minus side object constants probably little bit higher fragmentation problems possible 
plus side tracing cost large objects high 
mark sweep collector object needn copied contain pointers needn scanned 
importantly applications scheme require actual language level pointers objects changed imposes fewer constraints compilers 
ll explain particularly important parallel real time incremental collectors 
space costs technique usually roughly comparable copying collector 
pointer elds required object live objects traced require space fromspace tospace versions 
cases appears space cost smaller copying collector cases fragmentation costs due inability compact data may outweigh savings 
choosing basic tracing techniques treatments garbage collection algorithms textbooks stress asymptotic complexity basic algorithms roughly similar costs especially view garbage collection part free storage management scheme 
allocation garbage collection sides basic memory reuse coin algorithm incurs costs allocation time initialize elds new objects 
common criterion high performance garbage collection cost garbage collecting objects comparable average cost allocating objects 
cient tracing collection scheme basic cost components initial required collection root set scanning done allocation proportional amount allocation number objects allocated done garbage detection tracing 
initial usually relatively xed particular program size root set 
done allocation generally proportional number objects allocated plus initialization cost proportional sizes 
garbage detection cost proportional amount live data traced 
costs usually similar amount live data traced usually signi cant percentage amount allocated memory 
algorithms cost proportional amount allocation mark sweep may competitive cost proportional amount live data traced copying 
example suppose percent allocated data survive collection percent need traced 
deciding algorithm cient asymptotic complexity important associated constants 
cost sweeping object times cost copying mark sweep collector costs copy collector 
mark sweep collector sweeping cost allocator small relative cost initializing objects obvious sweep phase just terribly expensive 
current copying collectors appear cient current mark sweep collectors di erence large state art implementations 
systems memory larger expected amount live data collectors copying collectors don need space live object versions 
space tight counting collectors particularly attractive performance essentially independent ratio live data total storage 
real high performance systems hybrid techniques adjust tradeo di erent categories objects 
high performance copy collectors separate large object area cwb uj avoid copying large objects space space 
large objects kept side usually managed place marking traversal free list technique 
hybrids may techniques time occasionally compact data copying techniques avoid permanent fragmentation ld 
place collectors ability respect data values may pointers 
allows languages shelf optimizing compilers bw bar bds di cult impossible unambiguously identify pointers run time 
non moving collector conservative looks object left possible pointer doesn need changed 
contrast copying collector know avalue pointer move object update pointer 
conservative techniques discussed detail sect 
similarly choice non moving collector greatly simplify interfaces modules written di erent languages compiled di erent compilers 
possible pass pointers objects arguments foreign routines written compiled garbage collection mind 
practical copying collector pointers escape foreign routines updated referents moved 
problems simple tracing collectors widely known asymptotic complexity copying garbage collection excellent copying cost approaches zero memory large 
treadmill collection shares property collectors similarly cient constants associated memory reclamation reallocation small 
case garbage detection major cost 
unfortunately di cult practice achieve high ciency simple garbage collector large amounts memory expensive 
virtual memory poor locality allocation reclamation cycle generally cause excessive paging 
location heap location space reclaimed reused 
simply paging allocated data expensive high speed processor ung paging caused copying collection may tremendous live touched process 
doesn generally pay area larger available main memory 
mathematical treatment tradeo see lar 
main memory steadily cheaper locality cache memory increasingly important problem partly shifted di erent level memory hierarchy wlm 
general achieve potential ciency simple garbage collection increasing size memory postpone avoid collections taken far increased paging time negates advantage 
important realize problem unique copying collectors 
cient garbage collection strategies involve similar space time tradeo garbage collections postponed garbage detection done means space reclaimed quickly 
increases amount due garbage 
deferred counting tracing collection trades space time giving continual incremental reclamation avoid spending cpu cycles adjusting counts gives space objects garbage immediately reclaimed 
time scale memory reused resulting locality characteristics share basic performance tradeo characteristics generational collectors copying mark sweep varieties discussed 
copying collectors originally designed improve locality simple versions improvement large locality fact worse non compacting collectors 
systems may improve locality longlived data objects compacted contiguous area 
ect typically swamped ects due allocation 
large amounts memory touched collections unsuitable virtual memory environment 
major locality problem locality compacted data locality garbage collection process 
problem indirect result garbage collection time space reclaimed reused paged simply pages allocated 
compaction helpful little late 
simple semispace copy collector locality worse mark sweep collector copy collector uses total memory half memory collections 
fragmentation live data detrimental regular reuse spaces 
locality ensure memory large hold regularly reused slightly complicated copying schemes appear avoid problem ung wm wlm cyclic memory reuse patterns fare poorly hierarchical memories recency lru replacement policies 
suggests freed memory reused lifo fashion opposite order previous allocation entire reuse pattern kept memory 
area 
approach rely optimizations prefetching feasible level virtual memory disks simply keep rate allocation enormous speed di erential ram disk 
generational collectors address problem reusing smaller amount memory discussed sect 

historical reasons widely believed copying collectors generational case 
generational non copying collectors slightly harder construct exist quite practical wj 
temporal distribution simple tracing collector troublesome interactive programming environment disruptive user suddenly system unresponsive spend seconds garbage collecting common systems 
large heaps pauses may order seconds minutes large amount data dispersed virtual memory 
generational collectors alleviate problem garbage collections operate subset memory 
eventually garbage collect larger areas pauses may considerably longer 
real time applications may acceptable 
conservatism garbage collection ideal garbage collector able reclaim object space just object 
object implementable practice course general determined occurs 
real garbage collectors provide reasonable approximation behavior conservative approximations omniscience 
art cient garbage collector design largely introducing small degrees conservatism signi cantly reduce detecting garbage 
notion conservatism general confused speci pointer identi cation techniques socalled conservative garbage collectors 
garbage collectors conservative ways 
rst conservative assumption collectors variable stack globals registers live variable may referenced 
compiler optimizations garbage collector view reachability graph 
compiler data control ow analysis may detect dead values optimize away entirely 
compiler optimizations may extend ective lifetime variables causing extra garbage retained typically problem practice 
tracing collectors introduce major temporal form conservatism simply allowing garbage go collection cycles 
counting collectors conservative topologically failing distinguish di erent paths share edge graph pointer relationships 
remainder survey show possible kinds degrees conservatism di erent performance tradeo incremental tracing collectors truly real time applications ne grained incremental garbage collection appears necessary 
garbage collection carried atomic action program halted small units garbage collection interleaved small units program execution 
said earlier relatively easy counting collectors incremental 
counting problems ectiveness discourage desirable tracing copying marking collectors incremental 
discussion di erence copying mark sweep collectors particularly important 
incremental tracing garbage detection interesting reclamation detected garbage 
di culty incremental tracing collector tracing graph reachable data structures graph may change running program may mutate graph collector isn looking 
reason discussions incremental collectors typically refer running program mutator dlm 
garbage collector point view actual application merely coroutine concurrent process unfortunate tendency modify data structures collector attempting traverse 
incremental scheme track changes graph reachable objects re computing parts traversal face changes 
important characteristic incremental tech niques degree conservatism respect changes mutator garbage collection 
mutator changes graph reachable objects freed objects may reclaimed garbage collector 
oating garbage may go collector categorized object live mutator frees 
garbage guaranteed collected cycle garbage collection 
coherence conservatism incremental marking traversals take account changes reachability graph mutator collector traversal 
incremental copying collectors pose severe coordination problems mutator protected changes garbage collector 
may enlightening view issues variety problems having multiple processes attempt share changing data maintaining kind consistent view 
readers unfamiliar coherence problems parallel systems worry terminology issues apparent 
incremental mark sweep traversal poses multiple readers single writer coherence problem collector traversal respond changes mutator change graph objects 
similarly traversal change mark bits process update values eld writable process 
mutator writes pointer elds collector writes mark elds 
copying collectors pose di cult problem multiple readers multiple writers problem 
mutator collector may modify pointer elds protected inconsistencies introduced 
garbage collectors ciently solve problems advantage semantics garbage collection forms relaxed consistency processes needn consistent view data structures long di erences views don matter correctness algorithm 
particular garbage collector view reachability graph typically identical actual reachability graph visible mutator 
safe conservative approximation true reachability graph garbage collector may view unreachable objects reachable long doesn view reachable objects unreachable erroneously reclaim space 
typically objects go usually objects garbage reached collector traversal 
oating garbage usually reclaimed garbage collection cycle garbage collection tracing process conservatively view live 
inability reclaim oating garbage immediately unfortunate may essential avoiding expensive coordination mutator collector 
kind relaxed consistency corresponding coherence features collection scheme closely intertwined notion conservatism 
general relax consistency mutator collector views reachability graph conservative collection oating garbage accept 
positive side relaxed notion consistency exibility wehave details traversal algorithm 
parallel distributed garbage collection relaxed consistency model allows parallelism synchronization scope survey 
marking abstraction marking helpful understanding incremental garbage collection dlm 
garbage collection algorithms described process traversing graph reachable objects coloring 
objects subject garbage collection conceptually colored white collection retained colored black 
reachable nodes left traversal live data structures 
simple mark sweep collector coloring directly implemented setting mark bits objects bit set black 
copy collector process moving objects fromspace tospace objects fromspace considered white objects moved tospace considered black 
abstraction coloring orthogonal distinction marking copying collectors important understanding basic di erences incremental collectors 
incremental collectors intermediate states coloring traversal important ongoing mutator activity mutator allowed change things collector back away collector fail nd reachable objects 
understand prevent interactions mutator collector useful introduce third color gray signify object reached traversal descendants may 
traversal proceeds outward roots objects initially colored gray 
scanned pointers spring traversed spring colored gray 
copying collector gray objects objects area tospace cheney breadth rst traversal objects scan free pointers 
mark sweep collector gray objects correspond stack queue objects control marking traversal black objects ones removed queue 
cases objects reached white 
intuitively traversal proceeds wavefront gray objects separates white objects black objects passed wave pointers directly black objects white ones 
abstracts away particulars traversal algorithm may depth rst breadth rst just kind exhaustive traversal 
important thata de ned gray fringe identi able mutator preserve invariant black object hold pointer directly white object 
importance invariant collector able assume nished black objects continue traverse gray objects move forward 
mutator creates pointer black object white notify collector assumption violated 
ensures collector bookkeeping brought 
demonstrates need coordination 
suppose object completely scanned descendants reached grayed 
suppose mutator swaps pointer pointer pointer eld collector scanned 
traversal continues coordination reached reached erroneously deemed garbage reclaimed 
aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa violation coloring invariant 
incremental approaches aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa basic approaches coordinating collector mutator 
read barrier mutator attempts access pointer white object immediately colors object gray mutator read pointers white objects install black objects 
approach direct involves write barrier program attempts write pointer object write trapped recorded 
write barrier approaches turn fall different categories depending aspect problem address 
foil garbage collector marking traversal necessary mutator write pointer white object black object destroy original pointer collector sees 
rst condition writing pointer black object hold special action needed pointers white object gray objects retained garbage needn retained anyway 
second condition original path object hold object reached original pointer retained 
write barrier approaches focus aspects problem 
snapshot collectors ensure second condition happen allowing pointers simply overwritten rst saved data structure side collector nd 
path white object broken providing path object garbage collector 
incremental update collectors direct dealing troublesome pointers 
saving copies pointers overwritten copied black objects record pointers stored black objects catch troublesome copies stored noticing original destroyed 
pointer white object copied black object new copy pointer 
conceptually black object part reverted undoes collector traversal ste 
alternatively object may grayed immediately dlm 
ensures traversal updated face mutator changes 
read barriers write barriers conceptually synchronization operations mutator perform certain operations activate garbage collector perform action 
practice invocation garbage collector requires relatively simple action compiler simply emit necessary additional instructions part mutator machine code 
pointer read write depending incremental strategy accompanied extra instructions perform collector operations 
depending complexity read write barrier entire barrier action may compiled inline alternatively barrier may simply hidden line procedure call accompanying pointer read write 
strategies possible relying additional instructions compiled code assistance specialized hardware virtual memory features 
write barrier algorithms non copying collector read barrier unnecessary expense need protect mutator seeing invalid version pointer 
write barrier techniques cheaper heap writes times common heap reads 
snapshot algorithms snapshot algorithms write barrier ensure objects inaccessible garbage collector collection progress 
conceptually garbage collection copy write virtual copy graph reachable data structures 
graph reachable objects xed moment garbage collection starts actual traversal proceeds incrementally 
rst snapshot algorithm apparently abrahamson patel virtual memory copy write techniques ap general ect achieved straightforwardly fairly ciently simple software write barrier 
simplest best known snapshot collection algorithm 
location written overwritten value rst saved pushed marking stack examination 
guarantees objects unreachable garbage collector traversal objects live garbage collection reached pointers overwritten 
example shown fig 
pointer stack 
snapshot schemes conservative allow invariant broken temporarily incremental tracing 
preventing creation pointers black objects white ones global conservative strategy prevents loss white objects original path object lost overwritten pointer values saved traversed 
implies objects freed collection pointer white object stored reachable object 
includes objects created collection progress 
newly allocated objects considered black traversed 
short circuits traversal new objects fail free 
collector view reachability graph set union graph garbage collection plus allocated tracing 
important feature notice snapshot algorithms don preserve dijkstra invariant grey objects subtle role 
guaranteeing path black object white object go grey object guaranteed reachable white object path object grey object 
grey object just represent local part collector traversal wavefront may represent ters reachability graph cross wavefront unnoticed 
incremental update write barrier algorithms write barrier algorithms incremental update algorithms quite di erent 
unfortunately incremental update algorithms generally cast terms parallel systems incremental schemes serial processing due largely overlooked implementors targeting uniprocessors 
best known algorithms due dijkstra dlm 
similar scheme developed steele ste simpler deal compaction 
retaining snapshot graph garbage collection heuristically somewhat conservatively attempts retain objects live garbage collection 
objects die garbage collection reached marking traversal traversed marked 
precisely object reached collector paths broken point garbage collector reached 
pointer reached collector late 
head list reached grayed garbage rest list traversed 
avoid problem pointers hidden reachable objects scanned copied pointers caught stored scanned objects 
noticing pointer escapes location hasn traversed notices pointer hides object traversed 
copied nonlocal constraint poses signi cant problems optimization garbage collection process particularly trying generational distributed version snapshot algorithm multiple garbage collections di erent scopes proceed concurrently wj 
probable reason early papers concurrent garbage collection addressed di erent concerns facing language implementors 
dlm stressed elegance correctness proofs expense ciency readers may fact trivial changes algorithm practical 
ste complex algorithm optional incremental compaction phase readers doubtless failed recognize incremental update strategy simple orthogonal features 
better object garbage aswell get marked 
pointer installed object determined live pointer taken account incorporated graph reachable data structures 
scanned garbage collection complete nd live objects escape 
process may iterate black objects may reverted collector process traversing 
traversal guaranteed complete collector eventually catches mutator 
variations incremental update algorithm possible di erent implementations write barrier di erent treatments objects allocated collection 
incremental update scheme dijkstra dlm objects optimistically assumed unreachable re allocated 
terms marking objects allocated white black 
point stack traversed objects reachable time marked preserved 
contrast snapshot schemes assume newly created objects live pointers get installed objects reached collector traversal detected 
dijkstra chooses allocate new objects white assumption new objects short lived quickly reclaimed 
believe potentially signi cant advantage schemes allocate black 
objects short lived collector doesn reach objects early traversal re reached reclaimed promptly 
compared snapshot scheme baker described extra computational cost newly created objects live collection traversed garbage late reclaimed traversal started path 
explain worthwhile may depend factors relative importance average case ciency hard real time response 
steele proposes heuristic allocates objects white objects black attempting reclaim short live objects quickly avoiding traversal objects ste 
algorithm dlm uses somewhat conservative technique explain shortly 
ectiveness heuristic unproven appears di cult implement ciently standard hardware 
dijkstra incremental update algorithm dlm apparently predates steele slightly preserves invariant pointed white object reverting stored black object gray 
intuitively pushes gray wavefront outward preserve invariant pushing back 
conservative steele strategy pointer overwritten freeing object 
hand appears simpler faster practice slightly easier prove correctness algorithm obvious guarantee forward progress 
baker read barrier algorithms best known real time garbage collector baker incremental copying scheme bak 
adaptation simple copy collection scheme described sect 
uses read barrier coordination mutator 
baker proposed non copying version algorithm shares properties copying version bak 
incremental copying baker original copying algorithm adaptation cheney algorithm 
part copying data proceeds cheney breadth rst fashion advancing scan pointer area tospace moving referred objects fromspace 
background scavenging interleaved mutator operation mutator activity trigger copying needed ensure mutator view data structures consistent 
baker system garbage collection cycle begins atomic ip conceptually invalidates objects fromspace copies tospace objects directly reachable root set 
mutator allowed resume 
fromspace object accessed tospace copying demand enforced read barrier 
read barrier typically implemented instructions emitted compiler forming wrapper pointer dereferencing read instructions 
background scavenging process interleaved normal program execution ensure reachable data copied tospace collection cycle completes memory exhausted 
important feature baker scheme treatment objects allocated mutator incremental collection 
objects allocated tospace treated scanned assumed live 
terms marking new objects black allocated reclaimed reclaimed garbage collection cycle 
order ensure collector nds live data copies tospace free area exhausted rate copy collection tied rate allocation 
time object allocated increment scanning copying done 
terms marking scanned area tospace contains black objects copied objects scan free pointer gray 
objects fromspace white 
scanning objects copying spring moves wavefront forward 
addition background tracing objects may copied tospace needed ensure basic invariant violated pointers fromspace stored objects scanned undoing collector 
baker approach couple collector copying traversal mutator traversal data structures 
mutator allowed see pointers fromspace pointers white objects 
mutator reads potential pointer heap immediately checks see pointer fromspace referent color changed white gray 
ect advances wavefront just ahead actual keeping mutator inside wavefront 
preservation invariant indirect checking see pointers white objects stored black ones read barrier ensures baker suggests copying old live objects tospace allocating new objects 
occupied areas tospace grow older objects aren interspersed new ones 
nilsen variant algorithm updates pointers copying objects copying lazy space tospace simply reserved object pointer updated nil 
easier provide smaller bounds time taken list operations gear collector amount allocation including guaranteeing shorter pauses smaller objects allocated 
mutator see pointers place 
noted baker collector changes graph reachable objects process copying 
read barrier just inform collector changes ensure objects aren lost shields mutator viewing temporary inconsistencies created collector 
done mutator encounter di erent pointers versions object obsolete 
rst allocation new free read barrier may implemented software preceding read potential pointer heap check conditional call copying updating routine 
compiled code contains extra instructions implement read barrier 
alternatively implemented specialized hardware checks routines 
read barrier expensive stock hardware general case check see pointer points fromspace white object extra code executed move object tospace update pointer 
cost checks high conventional hardware occur frequently 
lisp machines special purpose hardware detect pointers fromspace trap handler gre moo joh conventional machines checking overhead tens percent highperformance system zor 
brooks proposed variation baker scheme objects referred indirection eld embedded object bro 
object valid indirection eld points 
obsolete version fromspace indirection pointer points new version 
unconditionally cheaper checking indirections incur overheads tens percent high performance system ung 
variant approach north reppy ina concurrent garbage collector nr variant exploits immutable values ml allow reading data fromspace hl 
zorn takes different approach reducing read barrier overhead knowledge important special cases special compiler techniques 
time overheads order percent zor 
scanning treadmill collector collection 
baker incremental non copying algorithm treadmill baker proposed non copying version scheme uses doubly linked lists object color elds implement sets objects color separate memory areas 
avoiding actual moving objects updating pointers scheme puts fewer restrictions aspects language implementation bak wj 
non copying scheme preserves essential advantage copy collection reclaiming space implicitly 
described sect 
objects white set reclaimed constant time appending remainder list free list 
real time version scheme links various lists cyclic structure shown fig 

cyclic structure divided sections 
new list allocation new objects occurs garbage collection contiguous free list allocation occurs advancing pointer separates 
garbage collection new segment empty 
list holds objects allocated garbage collection began subject garbage collection 
collector mutator traverse data structures objects moved list list 
list initially empty particular possible deal compilers unambiguously identify pointer variables stack making impossible simple copy collection 
grows objects unlinked list list collection 
new list contains new objects allocated black 
list contains black objects completely scanned gray ones reached scanned 
note isomorphism copying algorithm analogue cheney algorithm 
necessary scan pointer list advance gray objects 
eventually reachable objects fromlist moved list scanned spring 
spring reachable objects list black remaining objects list known garbage 
point garbage collection complete 
list available simply merged free list 
list new list hold objects preserved merged form new list collection 
state similar previous cycle segments moved part way cycle name treadmill 
baker describes algorithm isomorphic original incremental copying algorithm presumably including close coupling mutator collector read barrier 
conservatism baker read barrier baker garbage collectors somewhat conservative approximation true liveness ways 
obvious objects allocated collection assumed live die collection nished 
second pre existing objects may garbage having reached collector traversal reclaimed object grayed considered live garbage collection cycle 
hand objects garbage collection paths objects destroyed traversed reclaimed 
mutator may overwrite list structure exible contiguous area memory possible implement depth rst traversal auxiliary stack way cheney algorithm implements breadth rst wj 
discussion bit ed baker uses colors lists colors changed instantaneously changing sense bit patterns patterns 
pointer gray object destroying path white objects ensuring collector nd 
baker incremental scheme incrementally updates reachability graph pre existing objects gray objects pointers overwritten 
overwriting pointers black objects ect conservatism referents gray 
degree conservatism oating garbage depends details collector traversal program actions 
variations read barrier garbage collectors slight variations baker read barrier mutator allowed see black completely scanned objects 
recall baker read barrier copies object tospace soon mutator encounters pointer object 
may ine cient checking costs incurred general case costs trap scanning copying routine typically branch subroutine call 
may preferable scan entire object rst touched update object pointer elds 
may cheaper calling scanning copying routine time eld rst referenced compiler may able optimize away redundant checks multiple elds object 
jul distributed garbage collector jj uses scanning technique combines garbage collector checking costs incurred ne grained object migration 
read barrier coarser conservative baker original read barrier 
enforces stronger constraint mutator allowed see white objects allowed see black objects 
entire object scanned rst touched referents grayed object black mutator allowed see 
advances wavefront collector traversal extra step ahead mutator pattern 
black read barrier prevents data garbage garbage collector point view garbage collection pointer overwritten object containing scanned pointer referent grayed 
ect implements snapshot collection read barrier write barrier 
appel ellis li concurrent incremental collector ael uses virtual memory primitives implement black read barrier 
detecting rst grey object tospace entire pages data tospace access protected virtual memory system implicitly perform read barrier checks part normal functioning virtual memory hardware 
mutator accesses protected page special trap handler immediately scans page xing pointers objects page referents fromspace relocated tospace grayed access protected 
avoids need continual software checks implement read barrier usual case cient 
operating system trap handling slow may worth 
despite reliance operating system support technique relatively portable modern operating systems provide necessary support 
unfortunately scheme fails provide meaningful real time guarantees general case wm ns wj 
support concurrent collection greatly reduces cost read barrier 
worst case pointer traversal may cause scanning page tospace garbage collection complete 
replication copying collection nettles ong devised new kind incremental copying collection replication copying quite di erent baker incremental copying scheme 
recall baker collector garbage collection starts ip copies immediately reachable data tospace invalidates fromspace moment mutator allowed see new versions objects versions fromspace 
replication copying reverse 
copying going mutator continues see fromspace versions objects replicas tospace 
copying process complete ip performed mutator sees replicas 
johnson improved scheme incorporating copying objects tospace joh essentially application nilsen lazy copying technique nil tothe appel ellis li collector 
decreases maximum latency worst case page may scanned pointer traversal garbage collection done hard way 
consistency issues replication copying di erent baker style copying 
mutator continues access versions objects copying traversal needn check forwarding pointers 
eliminates need read barrier conceptually objects forwarded new versions ip occurs 
hand strategy requires write barrier write barrier deal just pointer updates 
baker collector mutator sees new versions objects writes objects automatically update current tospace version 
replication copying mutator sees old version fromspace object copied tospace fromspace version modi ed new replica wrong old values gets synch version seen mutator 
avoid write barrier catch updates collector ensure updates propagated ip occurs 
modi cations old versions objects corresponding new versions program sees correct values ip 
write barrier appears expensive general purpose programming languages functional languages nearly functional languages ml side ects allowed infrequently 
coherence conservatism revisited mentioned sect 
incremental collectors may take di erent approaches coordinating mutator collector tracing traversal 
quasi parallel processes coordinate closely views data structures precise coordination costs may unacceptable 
coordinate closely er dated information retain objects garbage collection 
coherence conservatism collection non copying write barrier algorithms described lie di erent points spectrum effectiveness conservatism 
snapshot algorithms treat conservatively reducing ectiveness 
dijkstra incremental update algorithm conservative snapshot algorithms conservative steele algorithm 
steele algorithm pointer white object stored black object white object immediately grayed stored black object reverted gray undoing done collector 
means stored eld overwritten white object may unreachable may reclaimed current collection 
contrast dijkstra algorithm grayed object reclaim 
may trivial di erence easy imagine scenario matters 
consider program stores data stacks implemented linked lists hanging stack objects 
stack object reached collector traversal objects pushed popped stack dijkstra algorithm reclaim popped items stack object list pointer progresses list repeatedly overwritten pointer item item grayed previous popped 
steele algorithm hand may reclaim popped items pointer eld collector traversal examines 
note spectrum conservatism snapshot algorithms dijkstra steele linear ordering algorithms traversal algorithm scheduled way relative program actual behavior practice 
details ordering collector mutator actions determine oating garbage retained 
collectors retain data reachable paths traversed collector broken 
suggests reachability graph pro traversed opportunistically total costs reduced carefully ordering scanning gray objects 
example desirable avoid scanning rapidly changing parts graph long possible avoid reaching objects shortly garbage 
things equal lieu opportunism random luck snapshot conservative ective incremental update dijkstra incremental update conservative steele 
coherence conservatism copying collection baker read barrier algorithm fall neatly spectrum 
conservative snapshot traversed conservative incremental update algorithms reached grayed objects garbage collector viewpoint simply touched mutator collection 
nettles replication copying algorithm incremental update algorithm able reclaim objects unreachable pointer overwritten reached collector 
collector conservative baker part weaker notion consistency 
mutator doesn operate tospace copying phase complete copies data tospace needn entirely consistent incremental copying 
changes fromspace data structures mutator propagated tospace eventually entire state needs consistent collection atomic ip performed 
write barrier algorithms replication copying bene signi cantly opportunistic traversal ordering 
radical collection opportunistic tracing tracing algorithms described fall roughly spectrum decreasing conservatism snapshot write barrier black read barrier baker read barrier dijkstra write barrier steele write barrier considering quasi spectrum interesting ask conservative steele algorithm 
better informed collector steele responds reachability graph 
answer 
garbage collector willing re traversal done un marking objects previously reached avoid conservatism 
refer radical garbage collection strategy 
rst glance collectors may impractical circumstances approximations may 
limiting case decreasing conservatism respond fully change reachability graph un marking objects reached garbage detected 
fully radical collector 
way doing perform full trace actual reachability graph pointer write part application 
naturally impractical extreme cost 
normal nonincremental collector viewed approximation graph traversed instantaneously stopping mutator traversal done occasionally 
way fully radical collection record dependencies reachability graph update dependency database pointer update 
paths keeping object alive broken object known garbage 
full strategy impractical general purpose garbage collection dependency database large pointer updates expensive 
note approximations dependency information relatively cheap fact exactly counts 
count approximation number paths object paths eliminated counts usually go zero allow object reclaimed immediately 
distributed garbage collection algorithms perform somewhat radical collection frequently recomputing local parts collector traversal 
comparing incremental techniques comparing collector designs instructive mind abstraction marking distinct concrete tracing mechanisms copy collection 
choice read write barrier strategy ensuring correctness independent tracing reclamation mechanism 
example brooks copying collector bro sect incremental update write barrier algorithm brooks describes optimization baker scheme 
similarly dawson copying scheme proposed daw cast incremental update scheme objects allocated fromspace white dijkstra collector 
choice read write barrier scheme basis available hardware 
specialized hardware support write barrier appears easier implement ciently heap pointer writes common pointer traversals 
appropriate virtual memory support available hard real time response required read barrier may desirable 
write barrier schemes snapshot algorithms signi cantly conservative incremental update algorithms 
advantage incremental update increased carefully choosing ordering root traversal traversing stable structures rst avoid having collector undone mutator changes 
incremental update schemes increase ectiveness may increase costs 
worst case garbage collection unreachable late traversed retained anyway 
new objects allocated white subject reclamation incremental update algorithms may considerably expensive snapshot algorithms worst case possible objects oat require traversal increase amount memory reclaimed 
discuss detail sect 

careful attention paid write barrier implementation 
boehm demers shenker bds boe incremental update algorithm uses virtual memory dirty bits coarse write barrier 
black objects page re scanned page collection 
appel ellis li copy collector coarseness sacri ces real time guarantees supporting parallelism 
allows shelf compilers don emit write barrier instructions heap writes 
uniform indirections viewed avoiding need baker style read barrier indirections isolate collector changes mutator allowing decoupled 
actual coordination terms marking write barrier 
brooks algorithm uses simple write barrier protect mutator collector simple read barrier protect collector mutator 
system compiler support garbage collection list stored locations kept dirty bits maintained software small areas memory reduce scanning costs bound time spent updating marking traversal 
done reasons generational garbage collectors discuss sect 

real time tracing collection incremental collectors designed realtime impose strictly limited delays program execution programmers guarantee garbage collected programs meet real time deadlines 
real time applications varied including industrial process controllers testing monitoring equipment audiovisual processing wire aircraft controls telephone switching equipment 
real time applications usually classi ed hard real time computations complete strictly limited time bounds soft real time acceptable tasks schedules time long doesn happen 
criterion real time garbage collection stated imposing small bounded delays particular program operation 
example traversing pointer take microsecond heap allocating small object take microseconds 
problems kind criterion 
problem appropriate notion small delay inevitably dependent nature application 
applications acceptable responses delayed signi cant fraction second seconds 
applications delay millisecond problem delays microseconds fatal 
hand consider music synthesizer controller humans imprecision swamp delay millisecond unnoticeable consider high precision guidance system anti missile missiles 
problem kind criterion unrealistically emphasizes smallest program operations 
press key musical keyboard controller may required execute thousands example digital telephone system making connection soft real time task connection established delivering continuous audio may hard realtime task 
section deal primarily hard real time issues 
program statements decide played corresponding pitch current loud play sound components mix proportions achieve right timbre pitch 
applications realistic requirement real time performance application able cpu fraction time timescale relevant application 
naturally relevant fraction depend application speed processor 
factory process control computer su cient controlling application execute second controller respond changes vat temperatures seconds second compute appropriate response 
hand controller musical synthesizer require cpu run control program half millisecond milliseconds keep delays onset individual notes threshold 
note applications function correctly garbage collector stops application quarter millisecond 
provided pauses aren frequent re short relevant applications real time deadlines 
suppose pauses clustered time happen frequently destroy application ability meet deadlines simply large fraction cpu time 
application executes sixteenth millisecond quarter millisecond pauses get fth cpu time 
case programs fail meet real time requirements process control system needs respond seconds 
described copy collectors virtual memory protections trigger scanning coarseness may fail respect real time guarantees 
worst case traversing list elements may cause pages scanned performing considerable garbage collection incurring trap overheads 
way list traversal normally take instructions may unexpectedly take millions increasing time traverse list orders magnitude 
locality may situations improbable probability bad cases negligible 
unfortunately ne grained incremental collector may problem nil wit 
consider baker copying technique 
time traverse list depends list elements require relocation tospace 
traversing single pointer may require object copied may increase cost memory order magnitude objects small hardware support available 
consider copying lisp cons cell consisting header car eld cdr eld 
memory reads memory writes required actual copy plus extra instructions install forwarding pointer adjust pointer probably branch garbage collector routine 
cases possible garbage collector overheads consume cpu time reducing available computing power power guaranteed available meeting real time deadlines order magnitude 
baker original incremental copying scheme worst case cost worse pointer traversal may force copying large object 
arrays treated specially copied lazily touched 
nilsen reduces worst case extending lazy copying types objects 
pointer tospace object encountered space simply reserved tospace object copying 
actual copying occurs incrementally background scavenger scans part tospace nil 
deciding real time tracing strategy important decide kind guarantees necessary timescales 
baker best known incremental algorithm may suitable real time applications performance unpredictable small timescales 
algorithms weaker coupling mutator collector write barrier algorithms may suitable wj 
may easier programmers reason real time guarantees know pointer traversals take constant time independent pointer traversed reached garbage collector 
write barrier algorithms require pointer store program operation variable need performed immediately maintain correctness 
unfortunately non copying algorithms convenient property time overheads predictable space costs reason 
copying algorithm generally frees large contiguous area memory requests objects size satis ed stack allocation operation 
non copying algorithms subject fragmentation memory freed may contiguous may allocate object size memory free 
sections discuss techniques obtaining real time performance incremental tracing collector 
assume system purely hard real time program consists computations complete deadlines assume timescale real time deadlines 
system main goal worst case performance possible increases expected case performance 
brie discuss tradeo systems soft real time schedules di erences expected case performance may important 
assume copying algorithm objects uniform size 
allows assume memory request satis ed memory ignore possible fragmentation free storage 
root set scanning important determinant real time performance time required scan root set 
recall baker incremental collector root set updated immediately reachable objects copied tospace single atomic operation uninterrupted mutator execution 
means occasionally pause duration roughly proportional size root set 
pause larger pause normal increment tracing may main limitation real time guarantees 
similar pauses occur incremental update tracing algorithms attempting terminate collection 
collection considered nished root set scanned recorded write barrier case algorithm steele reachable data traversed atomically 
ensures systems feasible transparently fragment language level objects easily managed chunks garbage collection easier reduce eliminate fragmentation problems 
pointers hidden collector storing roots roots scanned 
accomplished time allowed real time bounds collector suspended mutator resumed entire termination process tried 
snapshot algorithms don pose problem termination detection paths hidden collector 
way bound required ip termination keep root set small 
considering local global variables part root set may treated objects heap 
reads writes variables detected read barrier write barrier collector maintain relevant information incrementally 
problem keeping root set small cost read write barrier goes correspondingly larger number variables protected read write barrier incurring overhead time read written 
possible tradeo avoid read write barrier cost variables scan register set atomically necessary 
stack allocated local variables slow execution signi cantly 
case entire stack scanned atomically 
may sound expensive real time programs deep unbounded activation stacks cost may negligible scale program intended response times 
similarly small systems fast processors relatively large timescales real time requirements may avoid read write barrier global variables scan atomically 
intermediate strategies possible treating variables way pro ing information 
guaranteeing su cient progress preceding section focused ensuring collector cpu time relevant timescale keeping processor able meet real time deadlines 
conversely collector real time deadline meet nish traversal free memory currently free memory exhausted 
doesn application collection complete free memory 
hard real time programs way ensuring collector gets cpu time complete task free memory exhausted worst possible case 
provide guarantee necessary quantify worst case put bound collector expected 
tracing collector traverse live data requires putting bound amount 
general programmer application ensure program doesn certain amount live data traverse collector determine operate order meet deadline 
determine requires cpu time allowed consume 
naturally generally allows tradeo parameter settings 
memory available collector generally needs smaller fraction cpu time guarantee memory exhausted 
nishes usual strategy ensuring free memory exhausted collection nished allocation clock unit allocation corresponding unit collection done unit large ensure traversal completed free space exhausted bak 
simplest form key collection directly allocation time object allocated proportional amount garbage collection done 
guarantees matter uses memory collector accelerated correspondingly 
actual implementations usually somewhat larger units allocations ciency reasons 
rest section minimum safe tracing rate starting snapshot collector allocates objects black subject collection 
simplifying assumption objects uniform size single pool memory allocated reclaimed 
describing simple case explain safe tracing rate di ers incremental tracing algorithms 
snapshot algorithm live data collection traversed collection 
algorithms worst case objects mayhave freed collection 
absence information programmer collector generally assume collection maximum amount live data fact live 
assume objects created collection allocated black subject reclamation need traverse objects ignored garbage collection cycle 
rst glance appear maximum amount data memory size memory available allocate imply minimum safe tracing rate data exhausted 
unfortunately deal oating garbage 
data live collection may garbage collection late reclaimed garbage collection cycle 
data allocated may garbage allocate black don know 
memory space back garbage collection cycle left try collection 
maximum data allocate half 
minimum safe tracing rate allows allocate time takes traverse maximum live data safe tracing rate 
su cient worst case garbage entire garbage collection cycle reclaimed cycle 
mentioned situation essentially incremental tracing algorithms long allocate new objects black worst case retain objects snapshot algorithm 
minimum safe tracing rate proportional amount live data inversely proportional amount free memory approaches zero memory large relative maximum amount data 
allocating white situation considerably worse 
allocating white gambling newly allocated data short lived subject garbage collection hopes reclaiming space current cycle 
traverse reachable white objects worst case traverse allocate garbage 
assume bound amount live data provided programmer take account conservatism traversal process fact pointer may traversed broken mutator 
allocating white worst case safe traversal rate approach zero memory large approaches allocation rate traversal keep allocation rate go little faster ensure eventually catches 
increase amount memory relative amount live data reach point diminishing returns trace fast allocate 
analysis applies non copying collectors uniform sized objects 
copying collectors memory required hold new versions objects copied units memory available worst case ensure tospace exhausted fromspace reclaimed 
major space cost large relative actual amount 
non copying collectors nonuniform sized objects fragmentation taken account 
fragmentation reduces ective memory available requiring faster tracing complete collection bounded memory 
computations worst case fragmentation intrinsically program speci wj due space limitations discuss 
trading worst case performance expected performance collection phase complete collector determine conservative traversal rate slowing collection process yielding cpu cycles mutator 
possible collection collector determine fact traced revise downward worst case estimate live collection 
somewhat usually dramatically 
alternatively collector determine worst case amount ofwork may avoid gc activity entirely re activate collector time ensure meet deadline 
attractive option read write barrier ciently disabled discussion foregoing analysis assumes fairly simple model real time performance single timescale hard real time deadlines 
complex schemes certainly possible systems mixed hard soft deadlines systems multiple timescales di erent kinds goals 
example col infrequent relatively expensive operations root set scanning application longer term deadlines complementary pattern 
achieve higher performance providing tight real time guarantees necessary 
assumed fairly simple model garbage collection single pool memory available memory requests 
system objects widely di ering sizes case freeing small objects necessarily possible allocate larger 
hand appears applications memory usage dominated avery sizes objects reasoning realtime collection may hard appears rst glance majority programs wj 
reasoning done application basis 
programs guaranteeing real time performance may cost considerable memory due possible fragmentation applicationlevel objects split uniform chunks 
possibility statically allocate troublesome datatypes usually done real time systems anyway rely garbage collector manage objects automatically 
fully general real time garbage collection reasonable worst case memory usage appears ne grained copying collection required nil 
mentioned copying collection quite expensive worst case lisp machine style hardware support available speed read barrier ev wit 
nilsen schmidt designed simulated hardware support guarantee usefully real time performance ns significantly complex 
choosing incremental algorithm choosing incremental strategy prioritize average performance worst case consider autonomous robot need revise high level planning second need respond re changes environment milliseconds 
low level vision reactive adjustments consume xed percentage cpu time scale milliseconds remainder available alternately high level planning functions gc alternating half second 
nilsen requires relatively complex memory controllers compatible theshelf high performance microprocessors 
performance 
algorithms conservative may attractive conservative algorithms just conservative worst case 
usual case conservative algorithms may desirable may simply slower write barriers require instructions 
paradoxically conservative algorithm conservative practice cost may keep run 
higher overhead reduced conservatism terms incremental strategies may introduce greater conservativeness frequently garbage collected 
system design goals important choice garbage collection algorithm 
explain section generational techniques overheads incremental collection unnecessary systems hard real time response necessary su cient collector typical operation 
systems may desirable combine incremental generational techniques careful attention paid combined 
generational garbage collection realistic amount memory ciency simple copying garbage collection limited fact system copy live data collection 
programs variety languages objects live short time small percentage live longer lh ung sha zor det hay 
gures vary language language program program usually percent newly allocated heap objects die instructions megabyte allocated majority objects die quickly tens kilobytes allocation 
heap allocation measure program execution wall clock time reasons 
independent machine implementation speed varies appropriately speed program executes wall clock time avoids need continually cite hardware speeds 
appropriate speak careful interpret ideal measure 
example rates heap allocation terms amounts allocated time garbage collections largely determined amount 
improvements compiler technology may reduce rates heap allocation putting heap objects stack problem experimental studies current state art compilers don kind lifetime analysis 
garbage collections fairly close separated kilobytes allocation objects die collection need copied 
ones survive copied fraction survive collections 
objects copied collection garbage collector spends time copying old objects repeatedly 
major source ine ciency simple garbage collectors 
generational collection lh avoids ofthis repeated copying segregating objects multiple areas age collecting areas containing older objects younger ones 
objects survived small number collections moved frequently collected area 
areas containing younger objects collected quite frequently objects generally die quickly freeing space copying survive doesn cost 
survivors advanced older status collections keep copying costs 
collect non incremental garbage collection generational garbage collection additional bene collections take short time collecting just youngest generation faster full garbage collection 
reduces frequency disruptive pauses programs real time deadlines su cient interactive 
majority pauses brief fraction second noticed users ung longer pauses multi generation collections postponed system hidden noninteractive compute bound phases program operation wm 
generational techniques typically higher lisp smalltalk control information intermediate data computations passed pointers heap objects structures stack 
allocation relative measures absolute bottom line measure garbage collector ciency decreasing unit allocation nearly important programs don allocate conversely smaller percentage changes garbage collection mean programs memory demands higher 
younger generation root set older generation generational copying garbage collector garbage collection 
acceptable substitute expensive incremental techniques improve ciency 
historical reasons simplicity explanation focus generational copying collectors 
choice copying marking collection essentially orthogonal issue generational collection 
multiple varying collection frequencies consider generational garbage collector semispace organization memory divided areas hold objects di erent approximate ages generations generation memory divided semispaces 
fig 
show simple generational scheme just age groups new generation old generation 
objects allocated new generation current semispace full 
new generation collected copying live data semispace shown fig 

object survives long considered old copied new generation old back younger generation root set older generation generational collector garbage collection 
pace 
removes consideration collections longer copied collection 
relatively objects live long old memory ll slowly new 
eventually old memory ll garbage collected 
shows general pattern memory simple generational scheme 
note gure scale younger generation typically times smaller older 
number generations may greater successive generation holding older objects collected considerably 
tektronix smalltalk generational system semispaces generations cwb 
order scheme possible collect younger generation collecting older 
liveness data global property old memory data taken account 
example pointer old memory new memory pointer collection time roots traversal 
object live preserved garbage collector pointer may simply updated appropriately object moved 
event destroys integrity consistency data structures heap 
ensuring collector nd pointers young generations requires write barrier incremental collector running program freely store pointers heap objects 
potential pointer store accompanied extra bookkeeping case intergenerational pointer created 
incremental collector usually accomplished having compiler emit extra instructions store possible pointer value object heap 
write barrier may store may simple maintaining dirty scanning dirty areas collection time sha sob wm wil hms 
important point old new memory located collection time roots copying traversal 
intergenerational pointers roots ensures reachable objects younger generation reached collector case copying collector ensures pointers moved objects appropriately updated 
incremental collector write barrier results conservative approximation true liveness pointers old new memory roots roots necessarily live 
object old memory may died fact unknown time old memory collected 
garbage objects may preserved referred objects oating undetected garbage 
appears problem practice ung uj 
possible track pointers newer objects older objects allowing older objects collected independently newer ones 
costly typically pointers new old old new 
exibility consequence way typically created creating new object refers objects exist 
pointer new object installed old object considerably common 
asymmetrical treatment allows object creating code lisp frequently cons operation skip recording intergenerational pointers 
non initializing stores objects checked intergenerational writes initialize objects aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aa aa aa aa aa aa aa aa aa aa aa aa aa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aa aa aa aa aa aa aa aa aa aa aa aa aa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa second generation memory new generation memory aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aa aa aa aa aa aa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aa aa aa aa aa aa aa aa aa aa aa aa memory generational copy collector semispaces generation 
youngest generation create pointers younger ones 
young old pointers recorded may feasible collect generation collecting younger ones 
case data younger generations may considered possible roots may simply scanned pointers lh 
scanning consumes time proportional amount data younger generations generation usually considerably smaller cost may small relative cost collecting older generation 
scanning data younger generation may preferable collecting generations scanning generally faster tracing copying may better locality 
cost recording intergenerational pointers typically proportional rate program execution particularly tied rate object creation 
programs may major cost garbage collection instructions executed potential pointer store heap 
may slow program execution percent 
framework generational strategy outlined important questions remain advancement policy 
long object survive generation advanced 
heap organization 
storage space divided generations generation 
resulting reuse pattern ect locality virtual memory level level high speed cache memories 
collection scheduling 
non incremental collector mitigate ect disruptive pauses especially interactive applications 
careful opportunistic scheduling 
adapted incremental schemes reduce oating garbage 
intergenerational 
possible collect younger generations collecting older ones able nd live pointers older generations ones re collecting 
best way todo 
advancement policies simplest advancement policy simply advance live data generation traversed 
advantage ease implementation necessary able distinguish objects di erent ages generation 
copying collector allows single contiguous area generation division semispaces require header elds hold age information 
additional advantage advancing generation rst traversal avoids buildup long lived objects generation long lived object copied repeatedly timescale quickly advanced older generation collected 
problem objects may fast short lived objects allocated shortly collection advanced generation quite young die immediately ung wm 
cause older generation ll quickly collected 
problem short lived objects may alleviated delaying advancement objects just garbage collection cycle ensures objects roughly age factor advanced older generation 
incremental generational collector allocating black similar ect incremental collection phases su cient duration wj 
unclear keeping objects generation collection cycles worth extra copying cost 
conditions appears successive copies greatly reduce amount data advanced wm zor highly dependent nature application may desirable vary advancement policy dynamically wm uj 
desirability data generation multiple collection cycles ected thenumber size older generations 
general generations ungar generation scavenging system desirable retain data longer avoid lling older generations 
intermediate generations available usually preferable advance things quickly die generation advanced oldest generation wm zor 
heap organization generational collector treat objects di erent ages di erently 
tracing able tell generation object belongs order decide trace spring advance generation 
write barrier able determine objects generations detect pointer younger object stored older object 
copying collector usually done keeping objects di erent ages di erent areas memory 
systems contiguous areas object generation determined simple address comparisons 
systems areas may noncontiguous sets pages object generation determined page number part address index table says generation page belongs 
systems non copying collectors object belongs generation objects di erent generations may memory 
typically header eld indicating generation belongs 
subareas copying schemes generational copying collectors divide generations space areas 
example generation may consist pair semispaces objects copied back forth space retain generation multiple collections 
space objects advanced generation immediately copy generation 
locality semispace memory usage poor half memory generation time spaces touched entirety collection cycles 
lisp machine garbage collectors moo cou avoid problem single space generation 
copying objects semispace advanced garbage collection generation advances objects generation 
avoids need pair semispaces oldest generation place copy things 
unfortunately relatively young objects may relatively old ones objects allocated shortly collection time die advanced 
relatively young objects die shortly advanced needlessly space generation forcing collected sooner 
ungar solution problem young generation generation scavenging collector spaces just objects initially allocated third space 
newly created objects third space copied semispace objects semispace 
third space emptied garbage collection cycle reused immediately time 
locality characteristics similar single generation system 
third space increase memory usage semispaces required generation objects kept generation multiple collections 
creation area entirety collection cycle semispace hold survivors collection cycle 
typically small minority new objects typically survives rst collection small part semispaces time memory usage lower 
wilson opportunistic garbage collector wm uses variation scheme subareas generation additional purpose deciding advance object generation objects advanced semispaces generation cycle copied back forth semispace successive collections 
ect simple bucket brigade advancement mechanism sha segregation objects subareas encode ages advancement policy 
avoids need age elds object headers may advantageous systems objects headers 
provide guarantee objects advanced generation surviving collection cycles su cient toavoid premature advancement short lived data 
generational copying collection systems oldest generation treated specially 
lisp machine collectors necessitated fact generations emptied collection cycle contents copied generation oldest generation isn older generation example high performance lisp systems special pointer tag signi es pointer cons cell cons cell header 
copy things 
oldest generation dynamic space structured pair semispaces alternately 
enhancement provide special area called static space garbage collected normal operation 
area holds system data compiled code expected change rarely 
copying collectors ungar generation scavenging system treat oldest generation specially structuring single space mark compact algorithm 
systems generations typically reside ram normal execution single space reduces ram required keep oldest generation memory resident 
mark compact algorithm expensive typical copy collection ability perform full collection paging worthwhile oldest generation 
non copying techniques purpose subject fragmentation problems 
generations non copying schemes discussion generational collection far focused primarily copying garbage collection schemes generations viewed areas memory holding objects di erent ages 
unnecessary long possible distinguish objects di erent ages treat differently 
just incremental collection algorithms best understood terms abstraction marking generational algorithms best understood terms sets objects garbage collected di erent frequencies 
age sets turn divided shaded unshaded sets purposes tracing traversal 
xerox parc pcr portable common runtime garbage collector generational mark sweep collector header eld object indicating object age 
objects di erent generations may allocated page system uses heuristic minimize locality reasons garbage collecting young data pcr collector scans root set traverses objects age elds signify subject collection 
tracing continues transitively usual way tracing reachable young objects 
generational write barrier uses dirty virtual memory access protection techniques ex pages containing old objects hold young objects half empty tends avoid mixing older younger data 
sect 
pages older generations previous collection scanned entirety pointers young generations noted part root set 
discussion variations generational collection possible hybrids common allow various tradeo adjusted 
common copying collectors manage large objects di erently storing special large object area avoiding copying cwb 
essentially combines copying small objects cheap mark sweep large objects avoid larger space time overheads copying 
commonly large objects represented small copy collected proxy object holds indirection pointer actual storage object data elds 
objects known contain pointers may segregated objects optimize tracing process scanning involved schemes tracking intergenerational pointers lee may improve locality tracing copy collected proxies actual storage non pointer objects needn touched 
parcplace smalltalk garbage collector combines copy collection young generation worst case pause large incremental mark sweep collection older data 
tracking intergenerational generational collectors detect pointers older younger generations requiring write barrier similar incremental tracing algorithms 
program simply store pointers heap objects compiler hardware ensure potential store accompanied checking recording operations ensure pointers younger generations created collector 
typically compiler emits additional instructions potential pointer store instruction perform required write barrier operations 
systems may largest cost generational garbage collection 
example david ungar personal communication 
modern lisp system optimizing compiler pointer stores typically account percent total instruction count sh zor 
pointer store requires instructions write barrier performance degraded percent 
optimizing write barrier important garbage collector performance signi cantly faster write barriers developed 
key role performance generational collector discuss write barriers detail 
write barrier techniques di erent performance tradeo di erent hardware di erent languages language implementation strategies 
systems collection strategy generational write barrier get bene generational collection 
keeping track pointers old data young data created old data simply scanned pointers collection time 
requires scanning worse locality true generational collection may considerably faster tracing reachable data 
scanning typically times faster tracing strong spatial locality 
strati ed garbage collector austin kyoto common lisp enhancement common lisp uses avoid overhead write barrier 
bartlett similar technique collector designed shelf compilers emit write barrier instructions bar 
indirection tables original generational collectors lisp machines lh specialized hardware microcode speed checks pointers younger generations pointers indirected routine entry table 
pointers directly younger generation allowed pointers table entry holding actual pointer 
generation entry table holding actual pointers objects 
mutator executed store instruction attempted create pointer younger generation store instruction trapped microcode 
creating pointer directly younger generation invisible forwarding pointer created stored 
lisp machine hardware william personal communication 
microcode detected dereferenced forwarding pointers automatically making indirections invisible running programs 
garbage collecting particular generation necessary entry table additional set roots nding pointers generations updating 
somewhat di erent scheme ti explorer system having table incoming pointers generation separate table outgoing pointers maintained combination older younger generation 
example oldest generation separate exit table younger generation holding indirected pointers generations 
allowed scanning tables precise scanning pointers relevant generations collected simpler garbage collect table entries 
unfortunately indirection table schemes fast cient especially stock hardware support transparently dereferencing forwarded pointers 
baker style incremental copying cost common pointer operations greatly increased pointers checked indirections 
generational collectors avoided indirections allowed pointers directly generation 
requiring pointers localized simply keep track pointers collection time 
refer schemes pointer recording schemes simply record location pointers 
ungar remembered sets ungar generation scavenging collector pointer recording scheme recording objects pointers younger generations stored 
potential pointer store write barrier check see intergenerational pointer created checking see stored value fact pointer pointed young generation stored object old generation 
stored object added remembered set objects holding pointers 
object bit header saying remembered set duplicate entries avoided 
collection time scanning cost dependent size stored objects actual number store operations 
usual case scheme worked quite smalltalk virtual machine 
unfortunately worst case checking recording incurred tens instructions pointer store relative cost appreciably higher language implementation 
signi cant drawback remembered set objects scanned entirety garbage collection expensive 
checking cost repeated stored location stored times collections checked time stored objects scanned collection time 
worse large objects stored regularly scanned entirety tion 
observed cause large amounts scanning thrashing programs running tektronix smalltalk 
page marking moon ephemeral garbage collector symbolics lisp machines di erent pointer recording scheme moo 
recording objects intergenerational pointers stored recorded virtual memory pages stored 
page granularity recording avoided problem scanning large objects increased costs sparse writes small objects entire page scanned 
scanning cost large symbolics hardware special tag support generation checking fast pages fairly small 
write barrier implemented directly hardware additional instructions accompanying pointer write time cost pointer store small 
system information pointers younger generations held table 
advantage table implicitly eliminates duplicates page may stored number times bit set table page scanned garbage collection 
duplicate elimination equivalent bits object headers ensure uniqueness entries remembered set 
time required scan recorded items garbage collection proportional number stored pages page size number patrick personal communication 
actual store operations 
unfortunately scheme considerably slower implemented stock hardware larger pages dedicated hardware page scanning write checking 
requires ability scan arbitrary stored page complicated standard hardware symbolics machines machine word extra bits holding type tag 
virtual memory dirty bits coarse write barrier sha 
underlying virtual memory system typically maintains bit page indicates page changed way written disk 
done maintain bits done dedicated memory hardware point view language implementor free 
unfortunately operating systems provide facilities examining dirty bits operating system kernel modi cations required 
alternatively virtual memory protection facilities simulate dirty bits write protecting pages writes detected hardware invoke trap handler bds technique xerox portable common runtime garbage collector 
trap handler simply records page written garbage collection un protects page program execution resume 
pcr collector objects di erent generations may reside page page scanned collection time objects irrelevant generations skipped 
appel ellis li collector virtual memory protections impossible satisfy hard real time requirements may incur signi cant trap overhead scanning costs may relatively high write locality poor 
explain sect 
kind write barrier advantages dealing compilers uncooperative emit write barrier instructions 
word marking adapting moon collector standard hardware sobalvarro avoided cost scanning large pages word marking system bitmap record particular machine words memory pointers stored sob 
avoided need able scan arbitrary page pointers locations relevant pointers stored exactly 
sobalvarro optimized scheme standard hardware making write barrier simpler write barrier checking eliminated deferred collection time 
stored locations checked collection time see stored items intergenerational pointers 
precise moon ungar checking may cause words examined collection time bene implicit duplicate elimination performed rst checks need performed stored word 
drawback sobalvarro scheme reasonably large heap table bits fairly large percent total size memory 
scanning table relatively expensive represented simple linear array 
storing individual bits write barrier expensive architectures sub word write instructions slow synthesized instructions 
sobalvarro solution sparse level representation table incurred additional write barrier cost operations sparse array significantly slower operations contiguous array 
card marking alternative marking pages words conceptually divide memory intermediate sized units called cards sob 
relatively small cards advantage single store operation cause small amount scanning collection time making cost smaller page marking average 
long cards aren extremely small table recording stored cards smaller corresponding table word marking 
systems feasible represent table contiguous linear array keeping write barrier fast 
problem card marking standard hardware requires cards scanned pointers card object 
wilson opportunistic garbage collector addresses maintaining crossing map recording cards part object wm 
case card map nd previous card locate object header card skip forward object nds headers objects card scanned 
re nement crossing maps appel ellis li support scanning incremental copying collector ael 
wilson scheme bit corresponding card left set card contains pointer younger generation 
cards scanned garbage collection stored 
ungar chambers holzle re ned card marking scheme garbage collector self language 
table bits record stored cards uses table bytes bit needed byte stores fast architectures 
allows write barrier consist instructions unconditionally store byte byte array 
comes increase scanning costs byte array times larger bit array systems decrease cost worth cha 
holzle re ned relaxing precision write barrier recording bringing cost store instructions sun sparc processor slight increase scanning costs 
explain section card marking combined store lists reduce scanning cards hold pointers younger generations aren stored 
store lists simplest approach pointer recording simply record stored address list sort 
linked list pre allocated array successive locations stored pushing items linear array stack 
appel simple lines code generational collector standard ml new jersey app uses list simply scanned collection performance typical ml programs 
simple store lists disadvantage language implementations implement bags multisets stored locations sets 
location may appear list times frequently stored garbage collector examine entries collection time 
collection time cost proportional number pointer stores number stored locations 
lack duplicate elimination lead excessive space usage pointer stores frequent 
ml generally problem side ects relatively infrequently 
moss devised variation store list technique allows bounded special kind list called static store bu er calls special routine bu er full 
special routine processes list fast hash table remove duplicates 
technique hms reduces space costs avoids doing store list processing garbage collection time duplicate elimination advantage schemes duplicates eliminated put store list 
pointer store creates entry store list fetched examined 
hosking hudson hh combined best features card marking store lists 
pointer stores recorded card marking write barrier usual way card scanned individual locations containing pointers younger generations recorded 
allows subsequent collections avoid re scanning cards stored 
discussion choosing write barrier strategy generational collector important account interactions aspects system implementation 
example xerox parc parallel collector uses virtual memory techniques implement dirty bits partly designed variety compilers cooperate implementation write barrier shelf compilers emit write barrier instructions pointer store 
systems especially systems static type systems type inference capabilities compiler signi cantly reduce cost write barrier omitting write barrier checks done statically compiler 
issue real time response required 
table schemes page marking card marking may di cult scan recorded pointers incrementally real time 
store lists easier process real time fact done write barrier may similar done incremental update tracing technique allowing costs optimized away wj combining write barriers 
ungar technique ag bits signify object set conceivably probably worthwhile bit memory word opposed bit object header hardware support fast 
actual cost write barriers somewhat controversial 
studies measured write barrier overheads interpreted systems ung hms making hard relate highperformance systems optimizing compilers moo 
may reasonable combine measurements high performance systems analytic understanding garbage collector costs infer approximate cost implemented collector implemented systems 
mentioned earlier compiled lisp systems appear execute roughly pointer store heap object instructions card marking write barrier slow system percent executing instructions time pointer store plus smaller card scanning cost collection 
programs little live data lifetime distributions favorable generational collection tracing reclamation cost similarly low cost garbage collection percent 
gure vary considerably upward workload type information programming language data representations optimizations compiler 
implementation choices considered sections 
compiler generates faster code write barrier cost may larger fraction smaller running time 
hand compiler may able reduce write barrier costs inferring pointer recording redundant dynamically typed values pointers sect 

unfortunately cost write barriers conventional imperative statically typed systems poorly understood 
static type systems generally distinguish pointer types compiler type declarations may improve areas system performance making relative performance garbage collector worse 
hand conventional strongly typed languages lower rates heap object allocation mutation reducing write barrier tracing costs fraction program running time 
programming style signi cant impact write barrier costs 
languages designed garbage collection allocation routines primitives arguments initialize elds objects 
languages programmer may expected initialize new objects elds explicitly 
case language implementation omit write barrier initializing writes pointer elds generally 
clear problem programs languages may typically lower rates heap allocation fewer pointer elds objects 
generational principle revisited generational garbage collectors exploit fact heap allocated objects typically short lived 
longer lived objects collected assumption minority objects signi cant period live longer 
simple idea widespread obvious true strong sense hay bak unclear true generational collection worthwhile practice 
consider system property doesnot hold probability object die particular moment isnot correlated age 
lifetimes distributions system may heavily skewed short lived objects 
simple example system random exponential decay property xed fraction objects die xed period time half life property radioactive 
system lifetime distribution may appear ideally suited generational collection young objects die young 
closer examination turns picking subset objects yield equal proportion live dead objects period time 
case advantage generational collection due restricting scope collection higher mortality rate objects subject collection 
analogy appears undermine notion generational collection idea fact may 
exponential decay model generational collection may improve locality despite fact won directly improve algorithmic ciency reclaiming reusing allocated space improves locality compared reusing memory idle signi cant period 
traversing live objects cheaper objects allocated touched reclaiming reusing space garbage objects cheaper space 
pitfalls generational collection generational collection attempts improve performance heuristically advantage characteristics typical programs naturally successful programs 
programs generational collection fail improve performance may decrease 
pig snake problem problematic kind data generational collection cluster relatively long lived objects created time persist signi cant period 
occurs data structures built phase execution traversed subsequent phases execution garbage root large tree garbage 
kind data structure copied repeatedly advancement policy succeeds advancing generation large hold cluster related data objects 
increases traversal costs rst youngest generation generation bulge snake advancing snake body large meal 
bulge advanced generation hold collector age heuristic fail cause additional tracing 
pig snake problem favors relatively rapid advancement generation balanced disadvantage advancing data forcing generation collected necessary 
ungar jackson vary advancement policy dynamically attempt advance large clusters data youngest generation incur copying cost appears programs may cause older generation ll rapidly cases 
wilson advocates generations alleviate problem careful opportunistic scheduling garbage collections attempt collect little data live wm 
hayes key object opportunism re nes changes root set incidentally term inspired similar description baby boom generation resources life cycle rst requiring elementary schools ultimately causing increase demand retirement homes directors 
jon white personal communication 
uence garbage collection policy hay 
techniques appear bene cial experimentation needed larger systems 
small heap allocated objects assumptions generational heuristic pointers old objects young ones programs may violate assumption 
example programs large arrays pointers small heap allocated oating point numbers 
dynamically typed systems oating point numbers machine word general case represented tagged pointers heap allocated objects 
updating values array oating point numbers may cause new oating point objects allocated pointers installed array 
array large short lived reside older generation update oating point value create young object intergenerational pointer 
large number elements array updated sequential pass array oating point live signi cant period time long traced youngest generation collections advanced older generation 
large numbers intermediate lifetime number objects cause considerable overhead write barrier tracing 
case systems ungar original remembered set scheme remembered set scanning costs may large large objects hold intergenerational pointers 
toavoid costs approaches common short oating point formats represented tagged immediate values arrays typed elds raw oating pointers heap allocated objects 
problem short oating point values may desired numerical characteristics 
rst place numbers short word may su cient precision applications 
addition bits sacri ced tag eld reducing precision range number 
simplest scheme sacri ce bits precision removing bits mantissa problem resulting number map typical oating point hardware carefully designed precision rounding characteristics 
expected rounding properties algorithms may compute incorrect answers fail terminate 
simulating characteristics software extremely expensive 
alternative sacri ce bits exponent part hardware supported format restrict range numbers represented 
introduces instructions extra overhead converting hardware supported format tagged format wil cha 
arrays typed elds introduce irregularities dynamically typed systems arrays hold kind data strategy easy implement ciently frequently lisp systems 
unfortunately solutions xes problem general case oating point numbers possible data type cause problem 
consider complex numbers point objects objects going word 
similarly problem doesn occur arrays aggregate data structure binary tree exhibit problem 
cases programmer may choose di erent representation parallel arrays real imaginary components array complex numbers avoid unnecessary garbage collection overhead 
large root sets potential problem generational collection handling root sets 
essentially problem occurs incremental collection 
generational techniques reduce scope tracing collections reduce scanned collection 
youngest generation small frequently collected global variables stack scanned time may signi cant cost garbage collection large systems 
large systems may thousands global module variables 
alternative consider fewer things part usual root set treat variables heap objects write barrier 
stores objects may create pointers young generations recorded usual way pointers collection time 
problem approach may signi cantly increase cost stores local variables 
cost reduced compiler determine types compile time omit write barrier code writes 
treatment local variables complicated languages support closures procedures capture local variable binding environments forcing local variables allocated garbage collected heap stack 
variable bindings allocated heap requires pointer stores local variables write barrier may signi cantly increase write barrier costs programs side ects local variables relatively common 
systems desirable compiler optimizations avoid heap allocation local variables referenced closures allocated stack 
valuable improving speed code operating variables kra reducing heap allocation 
application programs root set scanning time negligible global module variables 
large integrated programming environments root set may large avoid large amounts scanning garbage collection may desirable write barrier variables stored variables scanned collection time 
easy imagine large integrated development system uses write barrier variables generate standalone application code root set scanned atomically avoid write barrier cost programs distributed 
real time generational collection generational collection combined incremental techniques marriage particularly happy wj 
typically real time garbage collection oriented providing absolute worstcase guarantees generational techniques improve expected performance expense worstcase performance 
generational heuristic fails data long lived garbage collecting young generation waste ort space reclaimed 
case full scale garbage collection collector simple non generational incremental scheme 
real time generational collection may desirable applications provided programmer supply guarantees object lifetimes ensure generational scheme ective 
alternatively programmer may supply weaker assurances risk failure meet real time deadline assurance wrong 
reasoning necessary mission critical time systems necessarily near real time approach applications interactive audio video control programs possibility reduction responsiveness fatal 
desirable combine generational incremental techniques details generational scheme may important enabling proper incremental performance 
example symbolics lmi ti lisp machines collectors real time generational systems interactions generational incremental features turn major ect worstcase performance 
garbage collecting older generations slowly course collections younger generations garbage collection ongoing time collection collects youngest generation youngest youngest older generation collected younger generations effectively regarded single generation garbage collected 
impossible younger generations generational ect garbage collecting older generations case full garbage collection ectively degenerates simple non generational incremental copying scheme 
large scale collections collector operate fast nish tracing available free space exhausted younger generations reclaim space reduce safe tracing rate 
alternatively collection speed kept space requirements larger large scale collections 
programs signi cant lived data scheme expected systematic periodic performance losses program object lifetime distribution favorable generational collection programmer provide appropriate guarantees assurances collector 
collector operate higher speed full collections memory usage go dramatically 
typically causes major performance degradation collector uses cpu cycles requires large amounts memory negating advan tage generational collection incurs performance degradation due virtual memory paging 
locality considerations garbage collection strategies major ect way memory reused naturally signi cant ect locality 
varieties locality ects locality ects garbage collection roughly divided classes ects programming style change way data structures created manipulated direct ects garbage collection process indirect ects garbage collection especially patterns reallocation free memory clustering live data 
rst ects programming style poorly understood 
systems cient garbage collector programmers adopt programming style appropriate task hand object oriented functional approach 
new data objects dynamically allocated hold newly computed data objects discarded data longer interesting 
ideally programmer expresses computation natural form application level data mapping fairly directly language level data objects 
contrast explicit allocation deallocation encourage distorted programming style programmer reuses language level objects represent conceptually distinct data time simply expensive deallocate object reallocate 
similarly systems ine cient garbage collection lisp implementations programmers resort similar language level object reuse example destructively side ecting list structures avoid allocating new list elements allocating single large array hold sets data time 
explicit deallocation leads distortions opposite variety mapping single conceptual data object multiple language level objects 
programmers extra objects simplify explicit deallocation 
data structure may copy data structure local decision memory reclaimed 
distortions extremely di cult compare locality garbage collected non garbage collected systems directly 
typical studies attempt compare programs written garbage collection mind original form explicit deallocation replaced garbage collection 
implicitly hides ects distorted programming style garbage collected version program inherits distortions 
second category locality ects locality garbage collection process usually comes immediately mind 
quite signi cant may important 
full garbage collection live data traced interact poorly conventional memory hierarchies 
live objects touched tracing little temporal locality repeated touches data short period time 
hand may considerable spatial locality touches di erent memory virtual memory page short periods time 
third category ects probably important signi cance widely appreciated 
strategy memory reallocation imposes locality characteristics way memory touched repeatedly objects die quickly touched 
thisis course main reasons generational garbage collection reuse small area memory youngest generation repeatedly allocating short lived objects 
reason activation stacks typically excellent locality near top stack memory reused frequently allocating short lived activation records 
generational garbage collector seen imposing roughly stack memory reuse pattern heap exploiting fact lifetime distributions roughly similar 
pointed earlier simple garbage collector poor locality allocation rates high simply memory touched reasonable period time 
ungar pointed ung simply paging resulting garbage room memory new data typically unacceptable cost high performance system 
generational gar collector restricts scope locality disaster manageable area youngest generation 
allows real locality characteristics repeated access longer lived data show older generation 
ect locality characteristics garbage collected systems appear roughly comparable non garbage collected systems youngest generation lters heap allocated data stack allocated languages 
direct comparisons di cult large involved garbage collectors explicit heap management 
copying garbage collection obviously indirect locality ect moving data objects memory collector ects locality program accesses ects mapping program logical language level data resulting particular memory locations 
kind ect restricted copying collection 
collectors considerable latitude deciding map language level objects available free memory 
program requests piece memory size allocator free return suitably sized piece free memory 
unclear rules govern decision 
importance di erent naturally dependent relative size data system main memory hardware runs 
systems full system heap ts main memory including editor browser compiler application code data normal mode systems ram programs typically page 
systems oldest generation large typical main memories system includes large complex software application data code large 
copying collector binary distinction generations ectively memory resident large truly rely virtual memory caching 
system collection essentially irrelevant virtual memory performance space cost xed cost occurs explicit heap management systems course systematically studied 
studies explicit techniques studied fragmentation cpu costs ignored ects caching hierarchical memories 
keeping ram 
contrast locality level virtual memory may crucial 
collector situation somewhat di erent space cost youngest generation depends degree fragmentation data various generations intermingled memory 
extent problems understood may serious widely believed hay bz boe 
locality allocation objects noted pattern allocation important ect locality simple collector 
generational copy collector ect reduced point view virtual memory pages generation reused frequently simply stay ram ectively incur xed space cost 
hand frequent reuse youngest generation may deleterious ect smaller level memory hierarchy highspeed cpu caches 
cycle memory reuse smaller cycle cache cache su er extra misses way main memory simple collector 
ects misses dramatic virtual memory ratio cache main memory speeds nearly large ratio main memory disk speeds 
copying collection pattern reallocation strongly sequential misses reduced considerably simple prefetching strategies just large block sizes 
current processors cost appears percent run time allocation rates relatively high 
faster processors may su er ects cache memory bandwidths scale processor speeds bus bandwidth premium shared bus multiprocessors 
zorn shown relatively large caches quite ective garbage collected systems zor 
wilson shown relative sizes cache youngest generation especially important particulars cache replacement policy may important aswell due peculiarities access patterns due reallocation wlm 
ect associativity isvery dependent ratio cache size youngest generation size lower researchers suggested optimizations avoid fetching garbage data areas re allocated cut cache memory bandwidth requirements nearly half 
koopman rst illustrated functional programming language implementation combinator reduction kls showed conventional cache designs achieve ect 
tarditi diwan show ect achieved conventional language implementation generational garbage collection demonstrate value cache memory interface supporting high write rates dtm 
di erence locality moving collectors appear large scale high speed cache memories type collector important rate allocation size youngest generation memory reclaimed reused usual case 
zor shows non copying collector better locality collector semispaces simply needs single space generation wlm shows ungar technique special creation area yield similar bene ts level large caches just level virtual memory 
wlm shows allocation variable binding environments activation records heap greatly exacerbate cache level locality problems due youngest generation won cache 
borne simulation studies standard ml new jersey dtm high performance processors 
suggests activation information binding environments allocated stack compile time analysis kkr stack cache cho wm kel 
software stack caches languages ml scheme binding environments may captured rst class procedures activation chains may captured rst class continuations 
cache takes advantage may perform better nearly equal 
essential feature write allocate policy block placement 
write allocate means block written rst writing allocated memory having write bypass cache simply update block main memory 
ensures objects allocated written cache referenced shortly 
sub block placement means cache block divided independent lines valid invalid cache 
allows writes word avoid triggering fetch rest block 
objects allocated initialized stalling processor fetching old contents storage occupy 
fact environments continuations captured vast majority needn put heap 
locality traversals locality gc tracing traversals di cult study isolation appears characteristics 
objects generation collected touched exactly objects pointed exactly object rov det typical data structures contain large number cycles cycles small little impact traversal locality 
main characteristic traversal exhaustively touch live data part brie little temporal locality repeated touching data 
objects referenced exactly pointer time reached tracing traversal 
major locality characteristic exploited spatial locality data structures layouts memory closely linked objects close memory touching object may bring fast memory shortly traversed 
experience xerox pcr system indicates non copying collector compaction useful locality objects initial layouts memory related objects created die time simple allocation strategies result useful clustering memory 
pcr collector enhances sorting root set traversing data root pointers area traversed time 
observed signi cantly reduce paging full garbage collections 
copying collector traversals usually spatial locality typically organized traversal ordering rst copied traversed order subsequent traversals 
rst traversal course match objects initial allocation layout traversal order may signi cant 
high spatial locality locality limit memory tracing traversal avoid needlessly displacing contents memory large amounts carl hauser personal communication 
data brie touched tracing wil bak 
incremental tracing may yield bene allowing mutator touch data tracing phase keeping active data fast memory 
clustering longer lived objects studies addressed copying collection indirect ect locality ect reorganizing data subsequently accessed running program 
static grouping stamos sta sta blau bla studied effects di erent copying traversal algorithms reorganize long lived system data code smalltalk systems 
algorithms reorganize data program execution garbage collection time referred static grouping algorithms reorganize data objects linked time garbage collection occurs clustering dynamic pattern program actual accesses data objects 
studies concluded depth rst reorganization preferable breadth rst reorganization large margin useful locality information topology data structures reasonable traversal decent job organizing data 
breadth depth rst traversals dramatically outperform random reorganization 
wilson performed similar study lisp system wlm showed traversal algorithms appreciable di erence 
important di erence experiments traversal algorithms se large hash tables treated 
system data stored hash tables implement binding environments global namespace package 
hash tables store items pseudorandom order may cause copying collector reach copy data structures pseudorandom fashion 
greatly reduces locality easy avoid treating hash tables specially 
bene may large relative additional space cost incremental collection deferred reuse memory reclaimed incremental tracing phase 
technique modify hash tables structure record order entries impose hash tables treated properly locality gains algorithm clusters data structures hierarchically 
similar results reported symbolics lisp machine system master thesis andre 
experiments particularly controlled results strikingly positive particularly signi cant results obtained large commercial system 
dynamic reorganization white proposed system garbage collection deferred long periods time baker read barrier incremental copier enabled copy data locality ects whi goal reclaim empty space simply cluster active data kept fast memory 
interesting property scheme reorganizes data order touched subsequent access patterns similar greatly improve locality 
scheme impractical original form sheer volume garbage swamp write bandwidth typical disks memory reclaimed ung basic idea incorporated garbage collector texas instruments explorer lisp machines cou joh 
collector avoids performing exhaustive background scavenging garbage collection cycle enhance odds objects reached rst mutator copied locality enhancing order 
similar approach simulations mushroom project university 
relying garbage collector system triggered cache misses respond directly locality characteristics program interaction program garbage collector 
unfortunately schemes rely specialized hardware worthwhile 
explorer system exploits lisp machines hardware support read barrier mushroom system nonrandom ordering modify collector information order examination entries 
technique hash tables indirect indexes ordered advantage implemented modifying collector user de ned table structures 
novel object oriented architecture 
wilson wil casts techniques form adaptive prefetching argues memories continue grow ne grained reorganization reorganization virtual memory pages larger units disk transfer may yield results stock hardware 
supported data loom object oriented virtual memory smalltalk sta ner grained caching strategies helpful primarily memories small 
memories get larger optimal unit caching gets larger schemes tend roughly schemes 
wilson argues improvements due ne grained reorganization may due de ciencies static graph algorithms comparison particular treatment large hash tables 
reported lla dynamic reorganization signi cantly improve locality roots treated appropriately background scavenging traversal 
coordination paging systems coordinated garbage collector virtual memory system improve paging performance 
symbolics lisp machines comprehensive coordination garbage collection virtual memory 
symbolics allocator notify virtual memory system page longer contained useful data allocate pages virtual memory paging old garbage contents memory page rst touched 
virtual memory cooperation intergenerational pointer recording mechanism 
paging page holding pointers younger generations page scanned intergenerational pointers moo 
allowed garbage collector avoid paging data just scan pointers younger generations 
virtual memory mapping techniques optimize copying large objects copying data large object pages holding data simply mapped old range virtual addresses new range wit 
added dynamic grouping moon ephemeral garbage collector uses static grouping techniques described 
microkernel operating systems ered ability modify virtual memory policies modifying kernel 
kernel calls user speci ed routines control paging process hard coding entire paging policy kernel 
mach system example external pager processes control paging activity feature reduce paging standard ml new jersey ways similar symbolics system sub 
low level implementation issues far discussed basic issues garbage collector design basic performance tradeo addition primary considerations garbage collector designer faced design choices signi cant impact ultimate performance system easily garbage collector integrated components system 
section discuss low level implementation questions detail 
pointer tags object headers pointers tagged small tags pointed objects header elds encode speci type information speci type information determine objects layouts including locations embedded pointer elds 
common scheme dynamically typed languages lisp smalltalk 
common languages objects divided major categories objects stored machine word tagged immediate values objects allocated heap referred pointers 
heap allocated objects divided categories contain tagged values immediates pointers examined collector nd pointers contain elds ignored garbage collector 
possibility contains object small immediate value pointer detailed type information 
generally requires elds words word long hold raw pointer raw immediate hold bit pattern long encode types system 
generally word eld alignment constraints load store operations 
despite waste space scheme may attractive architectures especially wide buses 
language static type system possibility objects headers pointer elds contain tags 
requires static type system ensures immediate values stored elds pointers require tag tell di erence 
simply knowing elds objects may contain pointers su cient pointed objects headers decode structure 
dynamically typed systems representation avoid having immediate values word short integers represented objects headers 
strictly static typing headers omitted pointer eld type pointer known type object points obvious app gol 
allow tracing traversals necessary types root pointers local variables activation stack known 
accomplished ways explain 
determine types referents referents pointer elds transitively 
systems static typing put headers objects anyway cost large simpli es aspects implementation 
choice tag pointer schemes usually regard garbage collection main consideration making normal program operations cient 
tagging schemes usually chosen primarily type dispatching arithmetic operations pointer dereferencing fast possible scheme best depends largely language semantics strategy ensuring frequent operations fast kkr gg sh ros 
systems individual objects headers type information encoded segregating objects particular types separate sets pages 
big bag pages technique associates types pages constrains allo architectures normal loads stores aligned word boundaries time penalty unaligned accesses 
typically requires clever implementation strategies optimize away heap allocation integers 
example page marking card marking generational collection headers simpler scan pages 
allocate objects appropriate pages 
type test requires masking shifting pointer derive page number table lookup nd type descriptor objects page 
encoding save space letting tag page encode types objects 
variation conventional tagging schemes avoid putting object headers directly objects store parallel array may advantages locality separating data relevant normal program operation interest collector allocator 
conservative pointer finding extreme case catering aspects language implementation pointer nding strategy coping compilers don er support runtime type identi cation garbage collection bw 
system collector treats pointer pointer properly aligned bit pattern address object heap 
collector may mistake values integer bit pattern pointers retain objects unnecessarily techniques probability small 
surprisingly techniques ective programs garbage collected fairly ciently little modi cation boe 
simpli es garbage collection programs written garbage collection mind programs written multiple languages uncooperative wdh 
making collector generational requires special techniques due lack compiler cooperation implementing write barrier detect intergenerational pointers 
virtual memory dirty bits traps detect pages written scanned collection time detect pointers younger generations 
conservative pointer nding imposes additional constraints garbage collector 
particular collector free move objects update pointers non pointer mistaken pointer mistakenly updated 
result techniques usually associated boehm associates developed high degree similar techniques appear earlier kyoto common lisp system 
mysterious unpredictable changes data character strings 
conservative collectors straightforward copying traversal algorithm 
conservative pointer nding combined techniques cope language implementations partly cooperative 
example detlefs copying collectors headers decode elds objects heap rely conservative techniques nd pointers activation stack bar det 
supports copying techniques relocate compact objects 
objects conservatively pointed stack pinned place moved 
choice conservative stack scanning precise heap tracing reasonable usually easier retro object headers language modify compiler stack frame formats decodable 
headers added objects heap allocation routine library routine changed substituted easily 
compilers record information decode record layouts debugging purposes information captured runtime type identi cation heap allocated objects wj 
conservative pointer nding defeated language level facilities ability cast pointers integers destroy original pointer perform arbitrary arithmetic integer value 
original value restored cast back toa pointer referred object may longer exist garbage collector may object couldn tell integer value pointed object viewed pointer value 
fortunately programs perform sequence operations may cast pointer integer original pointer object retained 
compiler optimizations perform similar operations pointers unfortunately harder programmer avoid compiler may algebraic transformations pointer expressions pointers may perform operations objects pinned place memory advanced older generation changing set page belongs objects belong pages pages belong generations entire page moved di erent generation simply changing tables record pages belong generations 
essence objects ages encoded tagging scheme 
subword parts pointer temporary inconsistencies state pointer 
compilers don perform optimizations occur compilers regularly 
compilers su cient turn highest levels optimization avoid pointer optimizations reliable compilers typically costs percent ciency due missed optimizations 
compilers provide ability selectively turn optimizations troublesome garbage collectors usually necessary turn optimizations high level optimizations 
toavoid problem garbage collector designers proposed set constraints compilers preserve ensure garbage collection possible constraints require major changes existing compilers boe bc 
similarly programming guidelines proposed ensure programmers avoid constructions correct garbage collection impossible ed programming slightly restricted subset possible ensure cooperative compiler support correct garbage collection 
slightly restricted safe subset possible ensure buggy programs break basic memory abstractions produce hard diagnose errors 
people object conservative pointer nding techniques known correct possible example integer mistaken pointer causing garbage retained 
worst case may cause considerable garbage go program may simply run memory crash 
advocates conservative pointer nding counter probability occurrence small errors fatal errors due programmers mistakes explicit heap management 
practice incorrect technique may better having programmers write programs correct 
long run hoped conservative pointer nding garbage collection widely usable widely compiler vendors provide degree support precise techniques 
linguistic support smart pointers approach retro tting garbage collection existing systems extension facilities provided language implement garbage collection language 
common form implement special set garbage collected data types restricted set access functions preserve garbage collector constraints 
example counted data type implemented accessor functions macros perform assignments accessor functions maintain counts performing actual assignments 
somewhat elegant approach extension mechanisms allow normal program operators garbage collected types compiler automatically selecting appropriate user de ned operation operands 
common de ne smart pointer classes classes str appropriately de ned meanings pointer manipulating operations suchas address operation objects 
unfortunately user de ned pointer types exactly ways built pointer types reasons ede 
reason way automatic coercions compiler performs automatically built types 
problem operators overloaded way 
provides extensibility necessary integrate garbage collection language gracefully 
apparently easier ada bak overloading system powerful builtin pointer types fewer subtleties emulated 
limitation impossible re de ne operations built classes making di cult enhance existing parts language user de ned types garbage collected gracefully 
limitation garbage collection di cult implement ciently language impossible tell compiler compile certain important special cases det ede example ada way specialize operation objects known compile time allocated heap 
terminology operators specialized re ective systems explored languages powerful regular extension mechanisms expose underlying implementation allow cient reimplementation existing language features mn ys 
existing re ective languages supply garbage collection part base language possible imagine implementing garbage collection small powerful re ective language 
re ective system important expose important low level issues avoid limiting choices base language implementor area active research 
compiler cooperation optimizations garbage collected system set conventions garbage collector rest system interpreter compiled code ensure garbage collector recognize objects pointers 
conservative pointer nding system contract compiler collector weak compiler avoids strange optimizations defeat collector 
systems compiler cooperative ensuring collector pointers stack registers 
gc anytime vs safe points collection typically contract collector running code takes forms call gc anytime safe points strategies 
gc anytime system compiler ensures running code interrupted point safe perform garbage collection information available nd currently active pointer variables decode formats reachable objects 
safe points system compiler ensures garbage collection possible certain selected points program execution points occur reasonably frequently regularly 
systems procedure calls backward branches guaranteed safe points ensuring program loop recurse inde nitely reaching safe point longest possible time safe points time take longest forward path types arguments arguments storage class 
nd cedure 
finer grained responsiveness guaranteed introducing intermediate safe points necessary 
advantage safe points scheme compiler free arbitrarily complex optimizations unsafe regions safe points obligated record information necessary possible locate de optimize pointer values 
disadvantage safe points scheme restricts implementation strategies lightweight processes threads 
threads control executing simultaneously garbage collected heap thread forces garbage collection collection wait threads reached safe point stopped 
implementation scheme mask hardware interrupts safe points common provide small routine handle actual low level interrupt time simply recording basic information setting ag resuming normal execution 
compiled code checks ag safe point dispatches high level interrupt handler set 
introduces higher level notion interrupts somewhat insulated actual machine interrupts somewhat longer latency 
safe points gc anytime strategy possible conventions ensuring pointers identi ed garbage collection safe points system compiler free violate convention safe points 
partitioned register sets vs variable representation recording systems compiler respects simple convention registers holding kinds values 
system orbit compiler kkr kra example registers tagged values raw values 
pointers assumed normal format direct pointers known set object plus tag headers extracted pointed objects simple indexed load instruction 
register set partitionings conventions possible 
example possible registers holding raw pointers pointers particularly important high level language language undesirable impossible prevent compiler optimizations mask pointers 
object collector ensures headers objects derived alignment constraints 
non copying collector untraced registers allowed hold optimized pointers point object due algebraic transformation long unoptimized pointer object traced register known format 
main problem partitioned register sets reduces compiler freedom allocate program variables temporaries whichever registers available 
code sequences require pointer registers registers code sequences require opposite 
mean variables spilled allocated stack heap registers code run slowly 
alternative partitioned register sets give compiler freedom registers require communicate information garbage collector tell pointers properly 
strategy variable representation recording compiler record decisions registers stack variables hold pointers recover object address pointer transformed optimization 
range instructions pointer variable representations differ compiler emit annotation 
information similar required debugging optimized code optimizations supported little overhead 
space requirements additional information essentially annotates executable code may negligible may desirable cases change compiler code generation strategy slightly 
optimization garbage collection garbage collectors constrained relationship compiler optimizations possible compiler assist making garbage collector cient 
example optimizing compiler may able optimize away unnecessary redundant read write barrier operations detect heap object safely stack allocated 
generational incremental algorithms write barrier necessary pointer stored may obvious compile time value pointer 
dynamically typed languages variables may able take pointer values statically typed languages pointer variables may assigned null value 
compilers may perform data ow analysis omission write barrier non pointer assignment operations 
advanced type ow analysis self compiler cu cu may provide greater opportunities read write barrier optimizations 
compiler may able assist eliminating redundant checks marking write barrier tests pointer marks object multiple times 
best knowledge existing compilers currently 
possible optimizer able assume certain things changed collector ways aren obvious compile time 
example gc anytime collector multiple threads control thread pre empted time garbage collection occur thread resumed 
system fewer opportunities optimization collector invoked consecutive instructions 
safe points system optimizer may able perform optimizations sequences instructions execute atomically respect garbage collection 
researchers investigated compiler optimizations related heap allocated structures detect potential aliasing allow heap objects stack allocated possible infer garbage particular point program sch sch hud jm rm lh hpr cwz bak 
cha discusses interactions conventional optimizations garbage collection garbage collection oriented optimizations safe 
topics scope survey best knowledge actual systems techniques garbage collection optimizations techniques may lead important improvements garbage collector performance shifting garbage detection compile time 
certain restricted forms lifetime analysis local variable binding environments simple ective need heap allocate variable bindings languages closures kra 
free storage management collectors deal fact freed space may distributed memory interspersed live objects 
traditional way dealing free lists possible adapt free storage management techniques developed explicitly managed heaps knu sta 
simplest scheme early lisp interpreters support size heap allocated object single free list hold freed items 
garbage detected sweep phase counts go zero objects simply strung list normal data elds hold list pointer 
generalizing scheme support multiple object sizes basic choices possible maintain separate lists object size approximate object size keep single list holding various sizes freed spaces 
techniques separate lists di erent sized objects include segregated storage buddy systems pn 
systems uni ed free list include sequential methods bitmapped techniques 
intermediate strategy single data structure tree similar structure sorted sizes addresses free spaces ste reduce search times 
systems hybrids oa ww gz described literature memory management describe 
exception bitmapped memory management garbage collectors usually discussed literature 
bitmapped memory management simply maintains bitmap corresponding units memory typically words pairs words objects aligned word boundaries bit value indicating unit 
bitmap updated objects allocated reclaimed 
bitmap scanned construct free list bds searched allocation time manner analogous search free list sequential algorithm 
compact representations heap data representations heap data optimized speed space 
dynamically typed languages example elds objects typically uniform size large hold tagged pointer 
pointers turn typically represented full size virtual addresses address space 
space wasted sense values represented fewer bits pointers typically contain little information due limited heap sizes locality 
mechanisms exploit regularities data structures stored somewhat compressed form time expanded demand operated 
ne grained mechanism called cdr coding whichis speci list cells lisp cons cells han bc lh 
compressed paging general purpose mechanism operates virtual memory pages wil dou wb 
mechanisms invisible language level 
cdr coding early lisp systems random access memory expensive 
unfortunately tended expensive time changeable representations list complicate basic list operations 
common operations cdr require extra instructions check see kind list cell traversing normal cell compressed 
compressed representation list system really array items corresponding items original list 
cdr coding system works concert garbage collector linearizes lists packs consecutive items arrays holding car values list items cdr values pointers link lists omitted 
necessary store bit special extra bit tag eld holding car value saying cdr value implicitly pointer item memory 
destructive updates cdr values require generation actual cons cells demand forwarding predecessor part array 
scheme really worthwhile special hardware routines lisp machines 
current general purpose processors seldom worth time savings gained 
roughly half data lisp system consists cons cells compressing words save best 
compressed paging proposed means reducing memory requirements stock hardware 
basic idea devote fraction main memory storing pages compressed form main memory page hold data virtual memory pages 
normal virtual memory access protection hardware detect compressed pages trap routine uncompress 
touched page cached normal uncompressed form program operate 
page touched time re compressed access protected 
compression routine limited compressing cdr elds designed compress pointers non pointer data integers character strings executable code 
ect compressed paging adds new level memory hierarchy intermediate cost normal ram disk 
may decrease ram requirements improve speed reducing number disk seeks 
simple fast ective compression algorithms heap data typically compressed factor considerably time take disk seek relatively slow processor wb 
processor speed improvements continue disk speed improvements compressed paging increasingly attractive 
gc related language features main garbage collection support simple abstraction nite amounts uniform memory available allocation objects simply created conceptually live forever 
desirable alter view 
desirable pointers prevent referred objects reclaimed trigger special routines object reclaimed 
desirable heap objects allocated di erent heaps treated di erently 
weak pointers simple extension garbage collection abstraction allow programs hold pointers objects pointers preventing objects collected 
pointers keep objects collected known weak pointers useful variety situations 
common application maintenance tables possible enumerate objects kind 
example desirable table le objects system bu ers ushed periodically fault tolerance 
common application maintenance collections auxiliary information objects information useless keep described objects alive 
examples include property tables documentation strings objects usefulness description depends described object interesting vice versa 
weak pointers typically implemented special data structure known garbage collector recording locations weak pointer elds 
garbage collector traverses pointers system rst determine objects reachable normal paths 
weak pointers traversed referents reached normal paths weak pointers treated normally 
copying collector updated re ect new location object 
referents reached weak pointers treated specially typically replaced value null signal referents longer exist 
finalization closely related notion weak pointers concept nalization actions performed automatically object reclaimed 
especially common object manages resource heap memory connection 
example may important close le corresponding heap object reclaimed example annotations documentation desirable delete description object object reclaimed 
finalization generalize garbage collector resources managed way memory similar program structure 
possible write general reusable code having treat certain kinds objects di erently normal objects 
consider routine iterates list applying arbitrary function item list 
le descriptors garbage collected iteration routine list le descriptors list heap objects 
list unreachable garbage collector reclaim le descriptors list structure 
finalization typically implemented marking objects way registering data structure weak pointers 
may fact data structure 
simply pointers objects aren reached primary traversal pointers recorded special treatment collection nished 
collection complete heap consistent referred objects nalization operations invoked 
finalization useful variety circumstances care 
nalization occurs asynchronously collector notices objects unreachable possible create race conditions subtle bugs 
thorough discussion weak pointers nalization see hay 
multiple differently managed heaps systems garbage collected heap provided convenience separate explicitly managed heap provided allow precise control memory 
languages modula cdg extended version ed garbage collected heap explicitly managed heap 
supports garbage collection allowing programmers explicitly control deallocation objects maximum performance predictability 
issues design multiple heap systems discussed del ed 
systems large persistent distributed shared memories may desirable multiple heaps di erent policies distribution shared vs unshared access privileges resource management mos del 
language implementations features internally hidden normal programmers little published information little standardization programmer interfaces 
terminology standardized heaps variously called heaps zones areas arenas segments pools regions 
cost garbage collection costs garbage collection studied systems especially lisp smalltalk systems 
studies serious limitations 
common limitation slow language implementation interpreter interpreted virtual machine poor compiler 
programs execute unrealistically slowly cpu costs garbage collection appear low 
common limitation cost studies toy programs synthetic benchmarks 
programs behave di erently large real world applications 
little long lived data making tracing collection appear unrealistically cient 
may ect measurements write barrier costs generational collectors programs little long lived data create intergenerational pointers 
di culty studies somewhat dated improvements garbage collection implementations 
valuable studies ones detailed statistics various events infer di erent strategies fare 
best study date zorn investigation gc cost large commercial common lisp system large programs zor 
zorn time cost generational garbage collection 
suspect numbers improved signi cantly fast write barrier 
shaw thesis provides similar performance numbers sha steenkiste thesis contains similar relevant statistics ste 
zorn studied simple non generational collector conservative pointer nding zor allowed study garbage collection highperformance implementation language compare costs garbage collection various implementations explicit deallocation 
unfortunately garbage collector stateof art partly due lack compiler cooperation 
zorn compared malloc free programs simple conservative gc cpu time memory 
zorn test programs unusually heap allocation intensive costs presumably lower typical workload 
believe gures improved considerably state art generational collector compiler cooperation 
tarditi diwan td studied garbage collection costs standard ml nj total time cost garbage collection 
interesting believe numbers unnecessarily high due extreme load garbage collector caused allocating tremendous amounts activation information binding environments heap stack sect 

believe write barrier improved 
estimate typical cost garbage collection implemented non incremental generational system high performance language implementation cost roughly percent running time cost implemented explicit heap management system space cost roughly factor data memory size 
naturally increased cpu costs traded reduced space costs 
taken educated guess compensating perceive de ciencies existing systems limitations studies date 
clearly studies garbage collection highperformance systems called especially implementations strongly typed languages 
areas research garbage collection essential fully modular programming allow exible reusable code eliminate large class extremely dangerous coding errors 
advances garbage collection technology automatic storage reclamation high performance systems 
relatively simple garbage collectors performance competitive explicit storage management app zor 
generational techniques reduce basic costs collection exploiting empirically observed tendency objects die young 
incremental techniques may garbage collection relatively attractive hard real time systems 
basic operation kinds garbage collectors provide framework ml statically typed general purpose functional language 
understanding current research eld 
key point standard textbook analyses garbage collection algorithms usually important characteristics collectors constant factors associated various costs write barrier overhead locality ects 
similarly realtime garbage collection subtle topic widely recognized 
factors require garbage collection designers take detailed implementation issues account careful choices features 
pragmatic decisions need interoperate existing code languages may outweigh small di erences performance 
despite complex issues systems fairly simple requirements garbage collector collector consists lines code 
systems large complex optimizing compilers attention paid garbage collection state art techniques 
promising development garbage collectors written portable high level languages typically adaptable various implementations various languages 
garbage collector designers keep advances aspects system design 
techniques described survey appear su cient performance relatively conventional uniprocessor systems continual advances areas introduce new problems garbage collector design 
persistent object stores abc am allow large interrelated data structures saved inde nitely writing les re reading needed automatically preserving pointer linked data structures relieve programmer tedious error prone coding input output routines 
large persistent object stores replace le systems purposes introduces problems managing large amounts longlived data 
desirable persistent stores garbage collection storage leaks result large permanent accumulation storage 
garbage collecting large persistent store di erent task garbage collecting memory single process bounded duration 
ect collector conventional system avoid problem long lived data data written les disappear col examples include umass garbage collection toolkit wilson johnstone real time garbage collector adapted ei el scheme dylan wj 
point view 
persistent store keeps data scope garbage collection ering attractive prospect automatic management long lived data challenge doing ciently 
parallel computers raise new issues garbage collectors 
desirable collector concurrent able run separate processor application take advantage processors application 
desirable collector parallel sped keep application 
concurrent collectors raise issues coordination collector mutator somewhat di cult raised simple incremental collection 
parallel collectors raise issues coordination di erent parts garbage collection process nding su cient parallelism despite potential bottlenecks due topologies data structures traversed 
distributed systems pose problems amr limitations parallelism particularly severe collection process proceed multiple networked computers communication costs high 
large systems long running applications networks typically unreliable distributed garbage collection strategies systems applications running robust tolerate computer network failures 
large persistent distributed systems data integrity particularly important garbage collection strategies coordinated checkpointing recovery ciency ensure collector fail kol det ong 
high performance graphics sound capabilities widely available economical computers graphical interactive ways 
multimedia virtual reality applications require garbage collection techniques impose large delays making incremental techniques increasingly desirable 
increasing embedded microprocessors desirable facilitate programming hard real time applications making ne grained incremental techniques especially attractive 
computer systems ubiquitous networked heterogeneous increasingly desirable integrate modules run di erent computers may developed extremely di erent programming languages interoperability diverse systems important goal garbage collection strategies developed systems 
garbage collection applicable current general purpose specialized programming systems considerable remains adapting new advanced paradigms 
acknowledgments abc ael am amr atkinson bailey chisholm cockshott morrison 
approach persistent programming 
computer journal december 
andrew appel john ellis kai li 
real time concurrent garbage collection stock multiprocessors 
proceedings sigplan conference language design implementation pld pages 
antonio albano ron morrison editors 
fifth international workshop persistent object systems san italy september 
springer verlag 
eliot miranda 
distributed garbage collection 
cohen bc pages 
david andre 
paging lisp programs 
master thesis university maryland college park maryland 
ap abraham patel 
parallel garbage collection virtual memory system 
amato editors international conference processing applications pages aquila italy september 
elsevier north holland 
app andrew appel 
garbage collection faster stack allocation 
information processing letters june 
app app andrew appel 
runtime tags aren necessary 
lisp symbolic computation 
andrew appel 
simple generational garbage collection fast allocation 
software practice experience february 
app bak bak andrew appel 
garbage collection 
peter lee editor topics advanced language implementation pages 
mit press cambridge massachusetts 
henry baker jr list processing real time serial computer 
communications acm april 
henry baker jr unify conquer garbage updating aliasing functional languages 
conference record acm symposium lisp functional programming lfp pages 
bak henry baker jr cache conscious copying collection 
oopsla workshop garbage collection object oriented systems oop 
position 
bak henry baker jr treadmill realtime garbage collection motion sickness 
oopsla workshop garbage collection object oriented systems oop 
position 
appears sigplan notices march 
bak henry baker 
infant mortality generational garbage collection 
sigplan notices april 
bak henry baker jr safe resource management ada limited types 
unpublished 
bar bar joel bartlett 
compacting garbage collection ambiguous roots 
technical report digital equipment western research laboratory palo alto california february 
joel bartlett 
copying garbage collection picks generations 
technical note tn digital equipment western research laboratory october 
daly analysis free storage algorithms revisited 
ibm systems journal 
bc daniel bobrow douglas clark 
compact encodings list structure 
acm transactions programming languages systems october 
bc hans juergen boehm david chase 
proposal garbage collector safe compilation 
journal language translation december 
bc yves jacques cohen editors 
international workshop memory manage bds bla bob ment number lecture notes computer science st malo france september 
springer verlag 
hans 
boehm alan demers scott shenker 
parallel garbage collection 
proceedings sigplan conference language design implementation pld pages 
blau 
paging object oriented personal computer smalltalk 
proceedings acm sigmetrics conference measurement modeling computer systems minneapolis minnesota august 
available technical report ucb csd university california berkeley computer science division eecs august 
daniel bobrow 
managing reentrant structures counts 
acm transactions programming languages systems july 
boe hans juergen boehm 
hardware operating system support conservative garbage collection 
international workshop memory management pages palo alto california october 
ieee press 
boe hans juergen boehm 
space cient conservative garbage collection 
proceedings sigplan conference language design implementation pld pages 
bro bw bz cdg rodney brooks 
trading data space reduced time code space real time collection stock hardware 
acm symposium lisp functional programming lfp pages 
hans juergen boehm mark weiser 
garbage collection uncooperative environment 
software practice experience september 
david barrett zorn 
lifetime predictors improve memory allocation performance 
proceedings sigplan conference language design implementation pld pages 
luca cardelli james donahue glassman mick jordan bill greg nelson 
modula report revised 
research report digital equipment systems research center november 
cg cha douglas clark green 
empirical study list structure lisp 
communications acm february 
david chase 
garbage collection optimizations 
phd thesis rice university houston texas august 
cha craig chambers 
design implementation self compiler optimizing compiler object oriented programming language 
phd thesis stanford university march 
che cheney 
nonrecursive list compacting algorithm 
communications acm november 
cho clinger anne erik ost 
implementation strategies continuations 
conference record acm symposium lisp functional programming pages snowbird utah july 
acm press 
cla douglas clark 
measurements dynamic list structure lisp 
ieee transactions software engineering january 
cn jacques cohen alexandru nicolau 
comparison compacting algorithms garbage collection 
acm transactions programming languages systems october 
coh jacques cohen 
garbage collection linked data structures 
computing surveys september 
col george collins 
method overlapping erasure lists 
communications acm december 
cou robert courts 
improving locality garbage collecting memory management system 
communications acm september 
cu craig chambers david ungar 
customization optimizing compiler technology self dynamically typed object oriented language 
proceedings sigplan pages 
cu cwb craig chambers david ungar 
making pure object oriented languages practical 
paepcke pae pages 
patrick allen wirfs brock 
third generation smalltalk implementation 
conference oriented programming systems languages applications oopsla proceedings pages 
acm press october 
cwz david chase mark wegman kenneth zadeck 
analysis pointers structures 
proceedings sig plan language design implementation pages white plains new york june 
acm press 
daw je rey dawson 
improved ectiveness real time lisp garbage collector 
conference record acm symposium lisp functional programming pages pittsburgh pennsylvania august 
acm press 
db peter deutsch daniel bobrow 
cient incremental automatic garbage collector 
communications acm september 
del 
allocation regions implementation contracts 
cohen bc pages 
det john detreville 
experience concurrent garbage collectors modula 
technical report digital equipment systems research center palo alto california august 
det david detlefs 
concurrent atomic garbage collection 
phd thesis dept computer science carnegie mellon university pittsburgh pennsylvania november 
technical report cmu cs 
det david detlefs 
garbage collection runtime typing library 
usenix conference 
dlm edsger dijkstra leslie lamport martin scholten ste ens 
garbage collection exercise cooperation 
communications acm november 
dou amer diwan eliot moss richard hudson 
compiler support garbage collection statically typed language 
proceedings sigplan conference language design implementation pages san francisco california june 
acm press 
fred douglis 
compression cache line compression extend physical memory 
proceedings winter usenix conference pages san diego california january 
alan dearle gail shaw stanley zdonik editors 
implementing persistent object bases principles practice international workshop dtm ed ede ev fy persistent object systems martha vineyard massachusetts september 
morgan kaufman 
amer diwan david tarditi eliot moss 
memory subsystem performance programs intensive heap allocation 
submitted publication august 
alan demers mark weiser barry hayes daniel bobrow scott shenker 
combining generational conservative garbage collection framework implementations 
conference record seventeenth annual acm symposium principles programming languages pages san francisco california january 
acm press 
john ellis david detlefs 
safe efcient garbage collection 
technical report digital equipment systems research center 
daniel ross 
smart pointers re smart re pointers 
usenix conference pages 
technical report ucsc crl university california santa cruz center computer engineering information sciences june 
steven jim 
automatic storage management systems real time constraints 
oopsla workshop garbage collection object oriented systems oop 
position 
robert fenichel jerome 
lisp garbage collector virtual memory computer systems 
communications acm november 
gc edward ellis chang 
hardware assisted memory management 
oopsla workshop memory management garbage collection oop 
position 
gg ralph griswold griswold 
implementation icon programming language 
princeton university press princeton new jersey 
gol benjamin goldberg 
tag free garbage collection strongly typed programming languages 
proceedings sigplan conference programming language design implementation pld pages 
gre richard greenblatt 
lisp machine 
shrobe sandewall editors interactive programming environments 
mcgraw hill 
gz david 
representing type information dynamically typed languages 
technical report tr university arizona department computer science tucson arizona 
dirk grunwald benjamin zorn 
cient synthesized memory allocators 
software practice experience august 
urs holzle 
fast write barrier generational garbage collectors 
oopsla workshop memory management garbage collection oop 
position 
han hay hansen 
compact list representation de nition garbage collection system implementation 
communications acm september 
barry hayes 
key object opportunism collect old objects 
paepcke pae pages 
hay barry hayes 
finalization garbage collector interface 
cohen bc pages 
hh antony hosking richard hudson 
remembered sets play cards 
oop 
available anonymous ftp cs utexas edu pub garbage gc 
hj hl reed hastings bob joyce 
purify fast detection memory leaks access errors 
usenix winter technical conference pages 
usenix association january 
lorenz james larus 
concurrent copying garbage collector languages distinguish im mutable data 
proceedings fourth acm sigplan symposium principles practice parallel programming ppopp pages san diego california may 
acm press 
published sigplan notices july 
richard hudson eliot moss amer diwan christopher weight 
language independent garbage collector toolkit 
coins technical report university massachusetts amherst ma september 
hms hpr antony hosking eliot moss darko 
comparative performance evaluation write barrier implementations 
andreas paepcke editor conference object oriented programming systems languages applications oop sla pages vancouver british columbia october 
acm press 
published sigplan notices october 
susan horwitz er reps dependence analysis pointer variables 
proceedings sigplan sigplan symposium compiler construction june 
published sigplan notices 
hud paul hudak 
semantic model counting abstraction 
conference record acm symposium lisp functional programming pages cambridge massachusetts august 
acm press 
jj jm joh niels christian eric jul comprehensive robust garbage collection distributed system 
cohen bc pages 
neil jones steven muchnick 
flow analysis optimization lisp structures 
steven muchnik neil jones editors program flow analysis pages 
prentice hall 
douglas johnson 
case read barrier 
fourth international conference support programming languages operating systems asplos iv pages santa clara california april 
joh ralph johnson 
reducing latency real time garbage collector 
acm letters programming languages systems march 
gregor kiczales jim des rivieres daniel bobrow 
art metaobject protocol 
mit press cambridge massachusetts 
kel richard kelsey 
tail recursive stack disciplines interpreter 
available anonymous ftp nexus yorku ca pub scheme txt stack gc ps 
slightly enhanced version technical report nu ccs college computer science northeastern university 
kkr david kranz richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
sigplan symposium compiler construction pages palo alto california june 
published acm sigplan notices july 
kls phillip koopman jr peter lee daniel siewiorek 
cache performance combinator graph reduction 
acm transactions programming languages systems april 
knu donald knuth 
art computer programming volume fundamental algorithms 
addison wesley reading massachusetts 
kol elliot kolodner 
atomic incremental garbage collection recovery large stable heap 
dearle pages 
kra david kranz 
orbit optimizing compiler scheme 
phd thesis yale university new haven connecticut february 
lar larson 
minimizing garbage collection function region size 
siam journal computing december 
ld bernard lang francis dupont 
incremental incrementally compacting garbage collection 
sigplan symposium interpreters interpretive techniques pages saint paul minnesota june 
acm press 
published sigplan notices july 
lee lfp lfp hoe sing lee 
object storage inheritance self prototype objectoriented programming language 
engineer thesis stanford university palo alto california december 
conference record acm programming austin texas august 
acm press 
conference record acm programming nice france june 
acm press 
lh henry lieberman carl hewitt 
realtime garbage collector lifetimes objects 
communications acm june 
lh kai li paul hudak 
new list compaction method 
software practice experience february 
lh james larus paul hil nger 
detecting con icts record accesses 
proceedings sigplan conference language design implementation pld pages 
lla rene 
performance analysis garbage collection dynamic reordering lisp system 
phd thesis department electrical computer engineering university illinois champaign urbana illinois 
mcb mcc harold 
counter method 
communications acm september 
john mccarthy 
recursive functions symbolic expressions computation machine 
communications acm april 
mey norman meyrowitz editor 
conference object oriented programming systems languages applications oopsla proceedings san diego california september 
acm press 
published sigplan notices november 
min mn marvin minsky 
lisp garbage collector algorithm serial secondary storage 
memo massachusetts institute technology project mac cambridge massachusetts 
pattie maes daniele nardi editors 
meta level architectures re ection 
north holland amsterdam 
moo david moon 
garbage collection large lisp system 
conference record acm symposium lisp functional programming lfp pages 
mos nil nr eliot moss 
addressing large distributed collections persistent objects mneme project approach 
second international workshop database programming languages pages beach oregon june 
available technical report university dept computer information science amherst massachusetts 
kelvin nilsen 
garbage collection strings linked data structures real time 
software practice experience july 
scott nettles james toole david pierce nicholas haines 
replication incremental copying collection 
cohen bc pages 
north reppy 
concurrent garbage collection stock hardware 
gilles kahn editor acm programming languages computer architecture number lecture notes computer science pages 
springer verlag september 
ns kelvin nilsen william schmidt 
high level overview hardware assisted realtime garbage collection 
technical report tr dept computer science iowa state university ames iowa 
ns kelvin nilsen william schmidt 
cost ective object space management hardware assisted real time garbage collection 
acm letters programming languages systems december 
oa allan 
adaptive exact storage management 
communications acm may 
ong oop oop james toole scott nettles david gifford 
concurrent compacting garbage collection persistent heap 
proceedings fourteenth symposium operating systems principles asheville north carolina december 
acm press 
published operating systems review 
oopsla workshop garbage collection object oriented systems october 
available anonymous ftp cs utexas edu pub garbage gc 
oopsla workshop memory management garbage collection october 
available anonymous ftp cs utexas edu pub garbage gc 
pae andreas paepcke editor 
conference object oriented programming systems languages applications oopsla phoenix arizona october 
acm press 
published sigplan notices november 
pld proceedings sigplan conference language design implementation atlanta georgia june 
acm press 
pld proceedings sigplan conference programming language design implementation toronto ontario june 
acm press 
published sigplan notices june 
pld proceedings sigplan conference language design implementation albuquerque new mexico june 
acm press 
pn peterson norman 
buddy systems 
communications acm june 
ps 
peng sohi 
cache memory design considerations support languages dynamic heap allocation 
technical report computer sciences dept university wisconsin madison wisconsin july 
rm ros christina thomas murtagh 
lifetime analysis dynamically allocated objects 
conference record fifteenth annual acm symposium principles programming languages pages san diego california january 
acm press 
john rose 
fast dispatch mechanisms stock hardware 
meyrowitz mey pages 
rov paul 
adding garbage collection runtime types strongly typed statically checked concurrent language 
technical report csl xerox palo alto research center palo alto california july 
sch sch jacob schwartz 
optimization high level languages value transmission corollaries 
journal computer languages 
jacob schwartz 
optimization high level languages ii 
deducing relationships inclusion membership 
journal computer languages 
scn stoye clarke norman 
practical methods rapid combinator reduction 
conference record acm symposium lisp functional programming lfp pages 
sh peter steenkiste john hennessy 
tags type checking lisp 
second international conference support programming languages operating systems asplos ii pages palo alto california october 
sha sob robert shaw 
empirical analysis lisp system 
phd thesis stanford university palo alto california february 
technical report csl tr stanford university computer systems laboratory 
patrick sobalvarro 
lifetime garbage collector lisp systems generalpurpose computers 
thesis massachusetts institute technology eecs department cambridge massachusetts 
sta thomas standish 
data structure techniques 
addison wesley reading massachusetts 
sta james william stamos 
large objectoriented virtual memory grouping strategies measurements performance 
technical report scg xerox palo alto research center palo alto california may 
sta james william stamos 
static grouping small objects enhance performance paged virtual memory 
acm transactions programming languages systems may 
ste guy steele jr multiprocessing garbage collection 
communications acm september 
ste stephenson 
fast ts new methods dynamic storage allocation 
proceedings ninth symposium operating systems principles pages woods new hampshire october 
acm press 
published operating systems review october 
ste peter steenkiste 
lisp reduced instruction set processor characterization optimization 
phd thesis stanford university palo alto california march 
technical report csl tr stanford university computer system laboratory 
str bjarne stroustrup 
evolution 
usenix workshop pages 
usenix association 
sub subramanian 
managing discardable pages external pager 
usenix mach symposium pages monterey california november 
td david tarditi amer diwan 
full cost generational copying garbage collection implementation 
unpublished september 
uj david ungar frank jackson 
policies generation storage reclamation 
meyrowitz mey pages 
ung david ungar 
generation scavenging non disruptive high performance storage reclamation algorithm 
acm sig soft sigplan software engineering symposium practical software development environments pages 
acm press april 
published acm sigplan notices may 
usenix association 
usenix conference portland oregon august 
wan thomas wang 
mm garbage collector 
master thesis california polytechnic state university san luis california october 
wb paul wilson 
compressed paging 
preparation 
wdh wf mark weiser alan demers carl hauser 
portable common runtime approach interoperability 
inproceedings twelfth symposium operating systems principles december 
david wise daniel friedman 
bit count 
bit september 
wh paul wilson barry hayes 
oopsla workshop garbage collection object oriented systems organizers report 
jerry archibald editor oopsla addendum proceedings pages phoenix arizona october 
acm press 
published oops messenger october 
whi jon white 
address memory management gigantic lisp environment gc considered harmful 
lisp conference pages redwood california august 
wil paul wilson 
issues strategies heap management memory hierarchies 
oopsla ecoop workshop garbage collection object oriented systems october 
appears sigplan notices january 
wil paul wilson 
operating system support small objects 
international workshop object orientation operating systems pages palo alto california october 
ieee press 
revised version appear computing systems 
wis david wise 
design multiprocessing heap board counting 
functional programming languages computer architecture pages 
springer verlag september 
lecture notes computer science series 
wit wj 
real real time garbage collection 
oopsla workshop garbage collection object oriented systems oop 
position 
paul wilson mark johnstone 
truly real time non copying garbage collection 
oopsla workshop memory management garbage collection oop 
expanded version workshop position submitted publication 
wlm paul wilson michael lam thomas moher 
ective static graph reorganization improve locality systems 
proceedings sigplan conference language design implementation pld pages 
published sigplan notices june 
wlm paul wilson michael lam thomas moher 
caching considerations generational garbage collection 
conference record acm symposium lisp functional programming pages san francisco california june 
acm press 
wm ww paul wilson thomas moher 
design opportunistic garbage collector 
conference oriented programming systems languages applications oopsla proceedings pages new orleans louisiana 
acm press 
charles weinstock william wulf 
quick cient algorithm heap storage allocation 
acm sigplan notices october 
williams mario wolczko trevor hopkins 
dynamic grouping object oriented virtual memory hierarchy 
european conference object oriented programming pages paris france june 
springer verlag 
ys akinori yonezawa brian smith editors 
re ection meta level architecture proceedings international workshop new models tokyo japan november 
research institute software engineering rise information technology promotion agency japan ipa cooperation acm sig plan ipsj 

design implementation kyoto common lisp 
journal information processing 

real time garbage collection general purpose machines 
journal systems software 
zor benjamin zorn 
comparative performance evaluation garbage collection algorithms 
phd thesis university california berkeley eecs department december 
technical report ucb csd 
zor benjamin zorn 
comparing mark sweep copy garbage collection 
conference record acm symposium lisp functional programming lfp pages 
zor benjamin zorn 
measured cost conservative garbage collection 
software practice experience 

