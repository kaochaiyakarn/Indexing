usenix association proceedings th symposium operating systems design implementation boston massachusetts usa december advanced computing systems association usenix association rights reserved information usenix association phone fax email office usenix org www www usenix org rights individual papers remain author author employer 
permission granted noncommercial reproduction educational research purposes 
copyright notice included reproduced 
usenix acknowledges trademarks 
current system loggers problems depend integrity operating system logged save sufficient information replay analyze attacks include non deterministic events 
revirt removes dependency target operating system moving virtual machine logging virtual machine 
allows revirt replay system execution intruder compromises system intruder replaces target operating system 
revirt logs information replay long term execution virtual machine instruction instruction 
enables provide arbitrarily detailed observations system presence non deterministic attacks executions 
revirt adds reasonable time space overhead 
overheads due virtualization imperceptible interactive cpu bound workloads kernel intensive workloads 
logging adds overhead logging traffic workloads stored single disk months 

revirt enabling intrusion analysis virtual machine logging replay george dunlap samuel king peter chen department electrical engineering computer science university michigan umich edu www eecs umich edu improving security today computer systems urgent difficult problem 
complexity rapid rate change current software systems prevents developers verifying auditing code thoroughly eliminate vulnerabilities 
result diligent system administrators cope routinely computer break ins 
situation continue foreseeable statistics cert coordination center show steady increase past years number incidents handled number vulnerabilities reported number advisories posted cer 
infeasibility preventing computer compromises vital analyze attacks occur 
post attack analysis understand attack fix vulnerability allowed compromise repair damage caused intruder 
computer systems try enable type analysis logging various events anderson 
typical unix installation may record login attempts mail processing events tcp connection requests file system mount requests commands issued superuser 
windows record login events file accesses process start exit events security policy changes restart shutdown events 
unfortunately audit logs provided current systems fall short ways needed integrity completeness 
current system loggers lack integrity assume operating system kernel trustworthy ineffective attackers compromise operating system 
way current loggers trust operating system keeping logs local file system allows attackers compromise kernel hide activities deleting past log records cer 
existing log files kept safely computer write media attackers forge misleading log records prevent useful log records saved compromise operating system 
absence useful log records point compromise difficult assess fix damage incurred attack 
ironic current loggers best kernel compromised audit logs intended system compromised 
attack kernels ways 
easiest way leverage capabilities kernel provides superuser account 
attacker gained superuser privileges change kernel writing physical memory special device dev mem unix inserting dynamically loaded kernel module overwriting boot sector kernel image disk 
administrator turned capabilities attacker exploit bug kernel 
kernels large complex tend contain bugs 
fact study automated tool find security vulnerabilities linux openbsd 
current system loggers lack completeness log sufficient information recreate understand attacks 
typical loggers save types system events events insufficient determine certainty break occurred damage inflicted 
administrator left guess happened painful uncertain task 
attack analysis published project uncertainty containing numerous phrases may indicate method reasonable assume appears edited presumably clear service hon 
secure installations may log inputs system network activity keyboard input 
extensive logging enable administrator re create attacks involve nondeterministic effects 
attacks exploit unintended consequences non determinism time time race conditions bishop advisories described non deterministic exploits linux kernel microsoft java vm freebsd netbsd kerberos ssh tripwire kde windows media services 
furthermore effects non deterministic events tend propagate impossible re create analyze large class events replaying earlier events deterministically 
encryption example encryption algorithms non deterministic events generate entropy choosing cryptographic keys communication depends value keys 
logging non deterministic events encrypted communication decrypted attacker forgets delete key 
goal revirt solve problems current audit logging 
improve integrity logger revirt encapsulates target system operating system applications inside virtual machine places logging software beneath virtual machine 
running logger different domain target system protects logger compromised application operating system 
revirt continues log actions intruders replace target boot block target kernel 
improve completeness logger revirt adapts techniques fault tolerance primary guest application backup recovery elnozahy checkpointing logging roll forward recovery 
revirt able replay complete instruction instruction execution virtual machine execution depends non deterministic events interrupts user input 
administrator type replay answer arbitrarily detailed questions attack 

virtual machines guest application guest operating system virtual machine monitor vmm host platform virtual machine structure 
guest application virtual machine monitor vmm layer software emulates faithfully hardware complete computer system goldberg 
abstraction created virtual machine monitor called virtual machine 
hardware emulated vmm similar identical hardware vmm running operating systems applications run physical machine run virtual machine 
host platform vmm runs operating system host operating system bare hardware 
operating system running virtual machine called guest operating system distinguish host operating system running bare hardware 
applications running top guest operating system called guest applications distinguish applications running host operating system vmm 
vmm runs separate domain guest operating system applications example vmm may run kernel mode guest software may run user mode 
research group interested enhancing security running target operating system target services inside virtual machine making guest operating system applications adding security services vmm host platform chen 
course vmm may subject security breaches 
fortunately vmm better trusted computing base guest operating system due narrow interface small size 
interface provided vmm identical similar physical hardware cpu memory disks network card monitor keyboard mouse interface provided typical operating system richer processes virtual memory files sockets guis 
narrow vmm interface restricts actions attacker 
addition simpler abstractions provided vmm lead code size orders magnitude smaller typical operating system smaller code size easier verify vmm 
see narrow interface vmm easier log replay 
virtual machines classified similar host hardware 
extreme traditional virtual machines ibm vm goldberg vmware export interface backward compatible host hardware interface identical slightly extended 
operating systems applications intended run host platform run vmms change 
extreme virtual machines java vm export interface completely different host hardware 
vmms run operating systems applications written specifically 
virtual machines vax vmm security kernel karger fall middle export interface similar identical host hardware 
types vmms typically deviate host hardware interface interacting peripherals 
virtualizing register interface peripherals controllers difficult time consuming virtual machines provide higher level methods invoke guest operating system ported run vmms 
specifically device drivers guest kernel higher level methods vmm disk device driver host system access virtual hard disk 
required port guest operating system types vmms similar done device manufacturers write drivers devices 

umlinux revirt uses virtual machine called umlinux 
umlinux falls category virtual machines vmm umlinux exports interface similar identical host hardware 
version umlinux described 
note umlinux different similarly named user mode linux dike 
guest application guest application guest operating system vmm kernel module host operating system host hardware guest application umlinux os os structure 
version umlinux implemented loadable kernel module host operating system 
device interrupt drivers guest operating system host services system calls signals 
modified code developed researchers university erlangen 
version umlinux vmm uses custom optimizations underlying operating system achieve order magnitude speedup original umlinux king 

umlinux structure operation virtual machine umlinux runs user process host 
guest operating system guest applications run inside single host process virtual machine process 
guest operating system umlinux runs top host operating system uses host services system calls signals interface peripheral devices 
call virtualization strategy os os call normal structure target applications run directly host operating system direct host 
guest operating system linux host operating system linux 
vmm version umlinux implemented loadable module host linux kernel plus hooks kernel invoke vmm module 
vmm module called signal system call virtual machine process 
instructions executed virtual machine execute directly host cpu 
memory accesses translated host mmu 
guest host operating systems different 
operating system guest host enable direct comparison running applications umlinux guest running applications directly host 
xc host operating system guest operating system guest application umlinux address space 
linux processes host kernel address space occupies xc host user address space occupies xc 
guest kernel occupies upper portion host user space xc current guest application occupies remainder host user space 
translations set host operating system system calls 
shows address space process 
host memory protections prevent guest applications accessing guest kernel address space 
umlinux provides software analog peripheral device normal computer system 
table shows mapping host component event software analog virtual machine 
umlinux uses host file raw device emulate hard disk cd rom floppy 
version umlinux uses tun tap virtual ethernet device linux emulate network card 
umlinux uses small application host display console output read keyboard input application communicates guest kernel console driver tcp 
umlinux uses video card displays graphical output remote server typically host server 
umlinux provides software analog computer current privilege level 
vmm module maintains virtual privilege level set kernel host component event emulation mechanism umlinux hard disk host raw partition cd rom host dev cdrom floppy disk host dev floppy network card console video card tun tap virtual ethernet device tcp host application display remote server current privilege level vmm variable system calls signal timer interrupts timer signal device interrupts signal memory exception signal enable disable interrupts mask signals table mapping host components umlinux equivalents 
transferring control guest kernel set user transferring control guest application 
vmm module uses current virtual privilege level distinguish system calls issued guest application system calls issued guest kernel 
system calls issued guest application redirected guest kernel system call trap handler 
guest application executes system call instruction int host cpu traps host kernel system call handler transfers control vmm kernel module 
current virtual privilege level set kernel vmm knows guest kernel system call typically access host device change memory translations 
case vmm checks system call umlinux guest kernel expected passes host kernel 
virtual privilege level set user vmm knows guest application system call 
case vmm module notifies guest kernel sending signal 
vmm module passes registers time trap guest kernel signal handler 
signal handler guest kernel equivalent system call trap handler normal operating system 
sigsegv signals emulate hardware timer device interrupts memory exceptions 
host kernel delivers signals registered signal handler guest kernel 
signal handlers equivalent timer interrupt interrupt memory exception handlers normal operating system 
umlinux emulates enabling disabling interrupts masking signals system call 

trusted computing base umlinux virtualization strategies described section depend trustworthiness layers guest operating system vmm host platform 
umlinux trusted computing base tcb comprised vmm kernel module host operating system 
umlinux tcb larger tcb virtual machines run directly hardware ibm vm vmware esx server 
umlinux tcb similar virtual machines cooperate host operating system vmware workstation 
common question security service added host operating system os os structure protected attack security service added host operating system direct host structure 
example logging os os structure depend integrity guest operating system doesn depend integrity host operating system 
contend logging os os structure difficult attack logging direct host structure tcb os structure smaller complete host operating system 
os direct host depend host operating system avenues villain attack host differ greatly structures 
assume comparison villain gained control target applications send arbitrary network packets host 
villain launch attacks host operating system directions 
villain attack causing application processes invoke host operating system dangerous ways 
direct host struc ture attacker complete freedom invoke functionality host operating system available user processes 
attacker control multiple application processes access multiple files issue arbitrary system calls 
os os structure attacker gained control application processes avenues attack guest operating system 
attacker gains control guest operating system severely restricted actions take host operating system 
guest kernel needs small subset functionality available generalpurpose host processes vmm easily disallow functionality outside subset goldberg 
example attacker gained control target applications guest operating system controls single host process virtual machine process access host files devices virtual hard disk virtual cd rom virtual floppy system calls 
second villain attack low level network protocol stack sending dangerous network packets host ping death 
attacks host operating system exposed dangerous packets os os structure direct host structure 
virtual machines packets traverse entire network stack delivered applications craft packets attack layer network stack 
virtual machines packets need traverse small part network stack 
portion host operating system included umlinux tcb host os code guest kernel incoming packets invoke plus vmm disallows invocations outside portion 
measure size code rigorously early indications suggest portion significantly smaller entire host operating system 
example vmm restricts guest kernel fewer system calls available general host processes network traffic virtual machine processed guest operating system tcp udp stacks small ip layer packet filter host operating system 
tcb current umlinux prototype smaller complete host operating system small 
host operating system prototype runs processes attacked server network messages host processes traverse entire host network stack 
includes measuring reducing size host operating system support umlinux 
example restrict system calls issued guest kernel certain parameter values move server virtual machine 

logging replaying umlinux 
overview logging widely recovering state 
basic concept straightforward start checkpoint prior state roll forward log reach desired state 
type system recovered determines type information needs logged database logs contain transaction records file system logs contain file system data 
replaying process requires logging non deterministic events affect process computation 
log records guide process re executes rolls forward checkpoint 
events deterministic arithmetic memory branch instructions need logged process re execute events way replay logging 
non deterministic events fall categories time external input 
time refers exact point execution stream event takes place 
example replay interrupt log instruction interrupt occurred 
external input refers data received non logged entity human user computer 
external input enters processor peripheral device keyboard mouse network card 
note output peripherals affect replaying process need saved fact output peripherals reconstructed replay 
non determinism micro architectural state cache misses speculative execution need saved affects architectural state 
replaying shared memory multiprocessor requires saving fine grained interleaving order memory operations outside scope leblanc 

revirt section describes apply general concepts logging enable replay umlinux running processors 
revirt implemented set modifications host kernel 
starting umlinux checkpoint state making copy virtual disk 
currently require replay start powered virtual machine virtual disk comprises state virtual machine 
envision checkpointing rare event days copying speed critical 
log records added saved disk manner similar daemon 
vmm kernel module kernel hooks add log records circular buffer host kernel memory user level daemon consumes buffer writes data log file host 
revirt log non deterministic events affect execution virtual machine process 
note non deterministic host events need logged affect execution virtual machine 
example host hardware interrupts affect virtual machine process cause host kernel deliver signal virtual machine process 
likewise scheduling order host processes affect process interprocess communication virtual machine process host processes shared files memory messages 
revirt log asynchronous virtual interrupts synchronous exceptions sigsegv deterministic need logged 
delivering host signal representing virtual timer interrupts process revirt logs sufficient information re deliver signal point replay 
uniquely identify interrupted instruction revirt logs program counter number branches executed interrupt bressoud 
architecture allows block memory instruction repeat string interrupted middle execution log register ecx stores number iterations remaining time interrupt 
processors provide hardware performance counter configured compute number branches executed interrupt int 
branch retired configuration performance counter amd athlon processor counts branches hardware interrupts timer network interrupts faults page faults memory protection faults fpu faults traps system calls 
hardware performance counter count number hardware interrupts subtract branch retired counter 
similarly instrument host kernel count number faults traps subtract branch retired counter 
configure branch retired counter count user level branches 
easier count number branches precisely keeps count independent code executed kernel interrupt handlers 
addition logging asynchronous virtual interrupts revirt log input external entities 
include virtual devices keyboard mouse network interface card real time clock cd rom floppy 
note input virtual hard disk deterministic data virtual hard disk reconstructed re read replay 
imagine requiring user re insert floppy disk cd rom replay case reads cd rom floppy deterministic need logged 
expect data sources significant portion log data sources limited speed user ability switch media 
umlinux guest kernel reads types input data issuing host system calls recv read gettimeofday 
vmm kernel module logs input data intercepting system calls 
general revirt log host system call yield non deterministic results 
architecture includes instructions return non deterministic results normally trap running user mode 
specifically read timestamp counter read performance monitoring counter instructions difficult log 
virtual machine process completely deterministic replay set processor control register cr trap instructions executed 
remove guest kernel instructions replacing host system call scaling result possible leave calls guest kernel trap emulate log instruction 
disallow guest kernel guest applications 
replay revirt prevents new asynchronous virtual interrupts perturbing replaying process 
revirt plays back original asynchronous virtual interrupts combination hardware counters host kernel hooks 
cd rom switched automated jukebox jukebox participate replay cd rom reads considered deterministic 
logging 
revirt goes phases find right instruction deliver original asynchronous virtual interrupt 
phase revirt configures branch retired performance counter generate interrupt branches scheduling interval 
second phase revirt uses breakpoints time executes target instruction 
breakpoint revirt compares current number branches desired amount 
phase executes speed original run faster second phase triggers breakpoint time target instruction executed 
second phase needed exactly right instruction interrupt generated retired counter execution instantaneously may execute past target number branches 
replay conducted host processor type original host 
replaying different host allows administrator minimize downtime original host 

cooperative logging sources non determinism generate small amount log data 
keyboard mouse input limited speed human data entry 
interrupts relatively frequent interrupt generates bytes log data 
sources non determinism received network messages potential generate enormous quantities log data 
reduce amount logged network data simple observation computer received message computer sent message 
sending computer logged revirt receiver need log message data sender re create sent data replay 
technique commonly message logging recovery protocols elnozahy viewed expanding domain replay system include computers 
receiver need log data sent computers cooperate replay receiver need log unique identifier message identity sending computer sequence number 
cooperative logging reduce amount logged network data dramatically certain cases 
example computers lan participate traffic outside lan needs logged reducing maximum log growth rate lan bandwidths wan bandwidths 
cooperating logging reduce log volume complicates replay requires cooperating computers trust regenerate message data replay 
implemented cooperative logging revirt 

alternative architectures logging replay considered strategies building logging replay system settling approach described 
particular started implementing direct host system host kernel logged replayed host processes 
discussed section direct host approach secure virtual machine approach 
difficult log replay host processes log replay process 
interestingly narrow interface umlinux host kernel os os approach secure direct host structure os os system easier replay 
general approach replaying direct system similar revirt system log replay non determinism 
types non determinism exist multiple host processes virtual machine approach interrupt timing external input 
challenging log replay direct host structure virtual machine process direct host structure involves multiple host processes os os approach involves single host process 
scheduling order guest processes umlinux nondeterministic abstraction virtual machine replayed deterministically result deterministic signal delivery virtual machine process 
replaying multiple host processes done ways problematic 
replay communication channels processes replaying shared memory communication channel requires complex instrumentation executing code adds significant overhead netzer 
second replay scheduling order host processes russinovich 
strategy difficult host process interrupted executing kernel mode executing system call 
hard identify point kernel interrupt occurred identifying point critical replaying exact scheduling order 
hardware performance counters identify exact interrupt point revirt interrupt point kernel configure count user mode instructions 
configuring count user kernel instructions leads difficulties kernel execute deterministically instruction counts differ replay 
solutions possible appealing 
change host kernel allow interrupts defined points log points interrupted 
require widespread changes host kernel 
second try replay entire host kernel 
require changing interrupt handlers log replay hardware interrupts adjusting hardware performance counters different code paths executed interrupt handlers logging replay 
addition coping scheduling order multiple host processes direct host approach cope large number non deterministic interfaces 
large number system calls including ioctl wide variety possible parameters 
replaying host system requires identify log replay non determinism system calls 
contrast revirt needs handle systems calls umlinux 

revirt analyze attacks revirt enables administrator replay complete execution computer attack 
types tools built foundation assist administrator understand attack 
type tool runs inside guest virtual machine 
revirt supports ability continue live non replaying execution point replay 
administrator ability run new guest commands probe virtual machine state 
example administrator replay suspicious point normal guest commands edit current files list current processes debug processes 
virtual machine switch back replaying perturbed manner instruction counts apply revised state 
continue replay perturbed point analyst checkpoint process perturbing start replay continue point 
second tools debuggers disk analyzers run outside guest virtual machine analyze state virtual machine address space registers disk data 
advantage line tools depend guest kernel guest applications 
example line tool inspect contents directory attacker replaced command normally lists directory 
particularly useful tool runs outside guest re displays original graphical output 
recall umlinux uses remote server running host graphical display 
replaying virtual machine process faithfully stream network packets sent server 
server control replay system send back different packets virtual machine due different mouse movements 
packets sent virtual machine affect replay replaying machine gets input packets log 
tcp protocol server may expect different replies packets sends virtual machine may confused virtual machine resent packets 
address simple proxy host opens new tcp connection server 
proxy goal act new client happens send display messages server virtual machine logging 
proxy accomplishes receiving packets re sent replaying virtual machine stripping ethernet ip tcp headers packets window data stream sending data stream server 
fortunately protocol largely deterministic require client reply messages sent server sole exception authentication protocol proxy written navigate protocol 

experiments section validates correctness quantifies virtualization logging overhead modified umlinux revirt logging replay system 
experiments run computer amd athlon processor mb memory samsung sv ide disk 
guest kernel linux ported umlinux host kernel umlinux modified version linux 
virtual machine configured mb physical memory 
virtual hard disk stored raw disk partition host avoid double buffering virtual disk data guest host file caches prevent virtual machine unfairly host file cache 
evaluate system workloads 
workloads start warm guest file cache 
pov ray cpu intensive ray tracing program 
render benchmark image pov ray distribution quality 
kernel build compiles complete linux kernel clean dep 
nfs kernel build kernel build kernel stored nfs server 
specweb benchmark measures web server performance apache web server 
configured specweb simultaneous connections spread clients connected mb ethernet switch 
workloads exercise virtual machine intensively making system calls 
similar kernel intensive workloads evaluate cellular disco 
revirt umlinux author desktop machine hours get idea virtualization logging overhead day day 
result represents average runs daily test represents single hour period 
variance runs 

virtualization overhead concern time overhead arises running applications umlinux virtual machine 
compare running applications umlinux running directly host linux kernel 
host guest file systems versions software exercised tests redhat 
table shows results 
umlinux host optimizations adds little overhead applications pov ray 
perceive overhead umlinux interactive jobs mail editing word processing web browsing 
overheads specweb kernel build nfs kernel build higher issue guest kernel calls trapped vmm kernel module reflected back guest kernel sending signal 
addition kernel build nfs kernel build cause large number guest processes created maps executable pages demand 
demand mapped page causes signal delivered guest kernel ask host kernel map new page 
workload believe overheads umlinux low unnoticeable normal desktop 
overheads higher workloads guest kernel intensively believe overhead prohibitive sites value security 
vmware workstation normalized runtime approximately kernel build umlinux modifications host kernel normalized running time version user mode linux configured protect guest kernel memory guest applications normalized runtime 
low overhead vmware acceptance production settings indicate virtualization fast enable services revirt 

validating revirt correctness goal verify revirt system faithfully replays exact execution original run 
runs add extensive error checking alert replaying run deviated original 
system call virtual interrupt log register values retired counter verify values replay 
addition revirt mechanism replaying interrupts verifies branch count interrupted instruction matches branch count seen instruction logging 
run micro benchmarks virtual machine verify virtual interrupts replayed point occurred logging 
micro benchmark runs guest processes share mmap ed memory region 
guest process increments shared variable times prints resulting value repeats 
guest processes share variable output umlinux runtime normalized direct host pov ray kernel build nfs kernel build specweb daily table virtualization overhead 
table shows overhead caused running applications umlinux 
runtime normalized runtime running directly host 
process depends iterations process executed time process prints value 
second microbenchmark runs single process increments variable infinite loop 
process prints current value receives signal 
test verifies guest kernel re delivers signal point logging 
ran micro benchmarks times time output replay matched original output error checks passed 
run macro benchmark verify revirt faithfully plays back input external systems exercise system longer periods 
macro benchmark boot computer start gnome window manager displaying remote server open interactive terminal windows concurrently build applications remote nfs server 
logging run benchmark generates system calls virtual interrupts 
revirt replayed run deviation original run 
tests disable extra error checking mentioned 
revirt checks branch count interrupted instruction matches branch count seen instruction logging detect errors effectively developing revirt 

logging replaying overhead seek quantify space time overhead logging 
include time space overhead checkpoint system expect checkpoint amortized long period time days 
table shows time space overhead logging pov ray kernel build nfs workload runtime logging normalized umlinux logging kernel build specweb workloads 
logs stored compressed format 
table shows time overhead logging small 
space overhead logging small save logs long period time low cost 
workloads little non determinism pov ray kernel build generate little log traffic 
note log data needed replay local compilations takes space disk data generated compilation 
log growth rate nfs kernel build specweb higher need log incoming network packets 
prohibitive 
example gb disk store volume log traffic generated nfs kernel build months 
file server revirt cooperative logging client reduce log volume generated nfs kernel build kernel build 
revirt umlinux author desktop machine hours get idea virtualization logging overhead day day experienced perceptible time overhead relative running directly host log occupied gb day 
table shows workloads typically replay speed ran logging 
possible replay workload faster faster ran logging replay skips periods idle time encountered non working hours daily workload 

test run linux guest operating system 
log growth rate table time space overhead logging replay 
logging slowdown shows overhead caused logging relative running umlinux logging 
log growth rate shows average rate growth log workload 
replay runtime normalized runtime umlinux logging 
replay runtime values indicate replay ran faster logging due replay ability skip periods idle time 

analyzing attack demonstrate ability revirt help analyze non deterministic attack involves kernel level vulnerability 
re introduced guest kernel ptrace race condition linux kernels cer 
villain exploits bug running setuid process attaching ptrace 
vulnerability non deterministic depends time check race condition 
attack successful file currently file cache file cache state depends scheduling order behavior prior processes 
exercised vulnerability compromising system added trojan horse bin ls backdoor inetd conf 
revirt successfully replays attack allows find attacker compromised system assess damage done point compromise 
able replay point attack run guest programs examined system state diagnose method effects intrusion 

related replay runtime normalized umlinux logging pov ray gb day kernel build gb day nfs kernel build gb day specweb gb day daily gb day bressoud schneider fault tolerance bressoud shares techniques revirt 
bressoud schneider virtual machine pa risc architecture interpose software layer hardware unchanged operating system log non determinism reconstruct state changes primary computer backup 
revirt shares mechanisms hypervisor revirt uses achieve different new goal 
hypervisor intended help tolerate faults mirroring state primary computer backup 
revirt takes techniques developed fault tolerance applies provide novel security tool 
specifically revirt intended replay complete long term execution computer 
illustrate difference goals compare usefulness checkpoints goal 
recovering backup prior point time accomplished checkpointing primary state periodically logging primary operations 
hand checkpoints sufficient intrusion analysis show system transitioned checkpoints checkpoints initialize replay procedure 
difference goals hypervisor revirt differ design choices 
hypervisor seeks restore backup saved state primary discards log records synchronization point 
contrast revirt enables replay long periods months computer execution save log records checkpoint 
difference hypervisor defers delivery interrupts fixed number instructions called epoch revirt delivers interrupts soon occur guest kernel re enables interrupts 
hypervisor logs information revirt hypervisor logs disk reads 
virtual machines similar umlinux 
user mode linux dike shares goals umlinux 
chose umlinux virtual machine contained single host process user mode linux uses separate host process guest application process speeds context switching guest processes 
simos direct execution mode similar systems targeted architecture easier virtualize rosenblum 
revirt shares similar philosophy security logging strunk 
revirt add logging target operating system protect logging functionality data compromised applications operating systems 
revirt adds logging virtual machine adds disk drives 
logging revirt captures different information logging 
revirt enables replay entire computer execution logs replays disk activity 
revirt save different data log revirt saves non deterministic events saves disk data comparison log volume generated depend workload 

near term checkpointing faster convenient 
plan accelerate disk copy done checkpointing copy 
plan enable vmm checkpoint running virtual machine saving reconstructing host kernel state virtual machine process plank 
plan build higher level analysis tools leverage revirt ability replay detailed longterm executions 
current techniques computer forensics analyze evidence left careless intruders revirt allows analyst watch intrusion arbitrary detail 
plan revirt building block new security services 
revirt ability recover arbitrary state may enable recover system automatically analyze prevent key events attack 

revirt applies virtual machine fault tolerance techniques enable system administrator replay long term instruction instruction execution computer system 
target operating system target applications run virtual machine revirt replay execution intruder compromises system 
capability especially useful determining fixing damage intruder inflicted compromising system 
revirt logs non deterministic events replay non deterministic attacks executions trigger race conditions 
revirt replay instruction instruction sequences provide arbitrarily detailed observations system 
revirt adds reasonable time space overhead 
overhead virtualization ranges imperceptible interactive cpu bound applications kernel intensive applications 
time overhead logging ranges logging traffic workloads stored single disk months 

acknowledgments grateful researchers university erlangen writing umlinux sharing 
particular kerstin helped understand umlinux 
brian noble cox anonymous reviewers shepherd jay lepreau helpful feedback 
research supported part national science foundation ccr ccr intel 
samuel king supported national defense science engineering graduate fellowship 

anderson james anderson 
computer security threat monitoring surveillance 
technical report james anderson april 
contract 
ken dawson engler 
programmer written compiler extensions catch security holes 
proceedings ieee symposium security privacy may 
hans 
virtual machine virtual operating system 
proceedings acm workshop virtual computer systems pages 
bishop matt bishop michael 
checking race conditions file accesses 
usenix computing systems 
bressoud thomas bressoud fred schneider 
hypervisor fault tolerance 
acm transactions computer systems february 
kerstin 
framework testing fault tolerance systems including os network aspects 
proceedings ieee symposium high assurance system engineering pages october 
cer cert cc security improvement modules analyze available information characterize intrusion 
technical report cert coordination center may 
cer linux kernel contains race condition ptrace execve 
technical report vulnerability note vu cert coordination center march 
cer cert cc overview incident vulnerability trends 
technical report cert coordination center april 
chen peter chen brian noble 
virtual better real 
proceedings workshop hot topics operating systems hotos pages may 
dike jeff dike 
user mode port linux kernel 
proceedings linux showcase conference october 
elnozahy elnozahy lorenzo alvisi yi min wang david johnson 
survey rollback recovery protocols messagepassing systems 
acm computing surveys september 
goldberg robert goldberg 
survey virtual machine research 
ieee computer pages june 
goldberg ian goldberg david wagner randi thomas eric brewer 
secure environment untrusted helper applications 
proceedings usenix technical conference july 
dan huang mendel rosenblum 
cellular disco resource management virtual clusters shared memory multiprocessors 
acm transactions computer systems august 
hon report linux honeypot compromise 
technical report project november 
project org challenge results dittrich evidence txt 
int ia intel architecture software developer manual volume system programming guide 
technical report intel 
karger paul karger mary ellen douglis andrew mason clifford kahn 
retrospective vax vmm security kernel 
ieee transactions software engineering november 
king samuel king 
operating system extensions support host virtual machines 
technical report cse tr university michigan september 
leblanc leblanc mellor crummey 
debugging parallel programs instant replay 
ieee transactions computers pages april 
robert donald simard 
commercial technology high assurance applications 
tech trend notes preview tomorrow information technologies september 
netzer robert netzer mark weaver 
optimal tracing incremental debugging long running programs 
proceedings conference programming language design implementation pldi june 
plank james plank beck gerry 
transparent checkpointing unix 
proceedings winter usenix conference pages january 
rosenblum mendel rosenblum stephen herrod witchel anoop gupta 
complete computer system simulation simos approach 
ieee parallel distributed technology systems applications january 
russinovich mark russinovich bryce 
replay concurrent non deterministic shared memory applications 
proceedings conference programming language design implementation pldi pages may 
strunk john strunk garth goodson michael craig soules gregory ganger 
self securing storage protecting data compromised systems 
proceedings symposium operating systems design implementation osdi october 
jeremy ganesh beng hong lim 
virtualizing devices vmware workstation hosted virtual machine monitor 
proceedings usenix technical conference june 
