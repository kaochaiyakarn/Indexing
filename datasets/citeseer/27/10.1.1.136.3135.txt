random oracle methodology revisited preliminary version ran canetti lambda oded shai march take formal look relationship security cryptographic schemes random oracle model security schemes result implementing random oracle called cryptographic hash functions 
main result negative exist signature encryption schemes secure random oracle model implementation random oracle results insecure schemes 
process devising schemes consider possible definitions notion implementation random oracle pointing limitations challenges 
keywords cryptography encryption signature schemes complexity theory cs proofs 
lambda ibm watson box yorktown height ny usa 
mail canetti watson ibm com computer science weizmann institute science rehovot israel 
mail oded wisdom weizmann ac il 
done visiting lcs mit 
partially supported darpa dabt 
watson box yorktown height ny usa 
mail watson ibm com popular methodology designing cryptographic protocols consists steps 
designs ideal system parties including adversary oracle access truly random function proves security ideal system 
replaces random oracle cryptographic hashing function md sha providing parties including adversary succinct description function 
obtains implementation ideal system real world random oracles exist 
methodology explicitly formulated bellare rogaway referred random oracle methodology works see example :10.1.1.41.4144:10.1.1.41.4144
random oracle methodology useful practice unclear put methodology firm grounds 
clear statements regarding operation ideal system clear happens replaces random oracle function succinct description available parties 
liked definition class functions replace random oracle maintains security ideal scheme 
purpose point fundamental difficulties proceeding goal 
specifically argue traditional approach providing single robust definition supports wide range applications bound fail 
expect see definitions pseudorandom generators functions general results type saying application parties restricted merely computing resources 
suggest proceed identifying useful special purpose properties random oracle provided fully specified function function ensemble yield implementations certain useful ideal systems 
alas results imply properties cover doable random oracle model 
specifically consider property call correlation intractability underline heuristics fiat shamir transformation round identification scheme signature scheme show minimalistic formulation property obtained fully specified function function ensemble 
demonstrate implications security cryptographic systems show systems security relies correlation intractability oracle may secure random oracle model insecure implemented fully specified function function ensemble 
specifically describe schemes digital signatures publickey encryption secure random oracle model implementation yields insecure schemes 
refutes belief security proof random oracle model means structural flaws scheme 
setting random oracle model scheme operates random oracle model parties including adversary modeled probabilistic polynomial time interactive machines oracle access 
parties interact usual interactive machines addition oracle queries 
postulated oracle queries regardless identity party making answered single function denoted uniformly selected possible functions 
set possible functions determined length function delta security parameter system 
specifically security parameter consider functions mapping 
set interactive oracle machines corresponds ideal system specific application 
application comes security requirement specifying adversary abilities considered successful 
abilities adversary include computational power typically arbitrary polynomial time machine ways interact parties 
success adversary defined means predetermined polynomial time predicate application view ideal system considered secure adversary abilities negligible probability success 
implementing ideal system loosely speaking implementing particular ideal system mean easy evaluate function random oracle 
ideal system queries oracle value implementation evaluates function 
formally defining notion takes care 
briefly examine discard notion implementation single function notion implementation function ensemble notion 
implementation single function 
ideal system specific application pi transformed real system application follows 
transform interactive oracle machine standard interactive machine natural manner 
oracle call replaced evaluation fixed function corresponding query system called implementation pi function adversary attacking implementation may mimic behavior adversary ideal system evaluating arguments choice needs 
particular may obtain global insight structure function insight vicious goals 
implementation called secure adversary attacking may succeed negligible probability success event defined exactly ideal system defined polynomial time computable predicate application view 
notion implementation say function implementation random oracle ideal system pi pi secure implementation pi easy see single polynomial time computable function provide implementation random oracle 
consider example candidate function contrived application provide implementation consists oracle machine representing honest party receiving message query oracle reveals private input oracle answers 
suppose adversary deemed successful honest party reveals private input 
clearly ideal system secure random oracle model implementation certainly secure 
implementation function ensemble 
implementations single function discussed straightforward interpretation random oracle methodology 
application view consists initial inputs parties including adversary internal coin tosses messages exchanged 
formally function takes input security parameter function delta def delta maps 
cated interpretation called 
considers substitution random oracle function randomly selected collection functions 
setting system set phase function selected description available parties set phase function place random oracle just 
little precisely consider function ensemble ng fk ffs 
exists polynomial time algorithm input returns fs 
implementation ideal system pi function ensemble obtained follows 
security parameter uniformly select gk available parties including adversary 
initialization phase replace oracle call interactive oracle machine evaluation function fs corresponding query 
resulting system called implementation pi function ensemble adversary may need necessarily mimic behavior adversary random oracle model evaluating fs arguments choice 
real system called secure adversary attacking negligible probability success probability taken random choice coins parties 
say ensemble provides implementation random oracle ideal system pi pi secure implementation pi notice case contrived example anymore success event independent random choice results obtain imply function ensemble provide implementation random oracle 
elaborate subsection 
results correlation intractability 
property certainly expect implementation random oracle infeasible find inputs function stand rare relationship corresponding outputs 
applications random oracle methodology fiat shamir heuristic assume infeasible find input output pair stands particular relations induced application 
trying formulate property may require description function hard find sequence preimages images function satisfy relation 
clearly hold relations finding sequences hard random oracle model 
hard find sequence preimages images random oracle satisfy relation description function fs hard find sequence preimages images fs satisfy fact sequel consider task finding single preimage image satisfies property 
loosely speaking relation called evasive access random oracle infeasible find string pair relation 
function ensemble called correlation intractable evasive relation description uniformly selected function fs fk infeasible find fs relation 
show informal theorem exist correlation intractable function ensembles 
sequel consider examples public key signature encryption schemes 
schemes initialization step combined key generation step original scheme 
restricted correlation intractability 
proof negative result relies fact description function shorter input 
investigate case restricts function fs inputs length length show negative result extended case function description shorter sum lengths input output function 
furthermore generalizes notion correlation intractability relations sequences inputs outputs negative result holds long total length inputs outputs length function description 
leaves open possibility exist function ensembles correlation intractable respect input output sequences priori bounded total length 
see discussion section 
failure random oracle methodology formulating random oracle methodology bellare rogaway warn proof security random oracle model taken guarantee security implementations random oracle replaced functions md :10.1.1.41.4144
widely believed security proof random oracle model means structural flaws scheme 
attack implementation scheme take advantage specific flaws function implement oracle 
demonstrate beliefs false 
specifically show informal theorem exists encryption signature schemes secure random oracle model secure implementation real model random oracle exist 
implementing secure ideal schemes function ensemble results insecure schemes 
encryption signature schemes prove theorem unnatural 
claim suggest statement holds respect schemes literature 
lesson mere fact scheme secure random oracle model necessarily imply particular implementation real world secure scheme structural flaws 
furthermore justified ideal scheme may secure implementations 
related definition correlation intractability related definition okamoto 
terms terminology okamoto considers function ensembles infeasible form input output relations respect specific evasive relation def 
relations 
uses assumption function ensembles exists specific evasive relation thm 

steps direction identifying studying useful special purpose properties random oracle model taken canetti 
specifically canetti considered property called perfect wayness provided definition property constructions possess property reasonable assumptions applications functions suffice 
additional constructions suggested canetti micciancio reingold 
proof theorem uses cs proofs random oracle model defined constructed micali essential way 
underlying ideas micali construction kilian construction 
organization section syntax necessary rest 
section discuss reasoning led define correlation intractability property prove minimalistic definition met function ensemble 
section main negative results demonstrating existence secure ideal signature encryption schemes secure implementations 
restricted correlation intractability defined studied section 
function ensembles discussion precise explicitly associate length function 
random oracle candidate implementations 
assume length functions polynomially bounded log poly 
refer oracle length function oracle 
security parameter oracle answers query string length 
candidate implementation random oracle ensemble define 
definition function ensembles 
length function 
ensemble sequence families functions fk ffs lambda 
gs gk holds length requirement 
gk lambda jfs 
efficiency 
exists poly time algorithm eval lambda eval fs 
sequel call description seed function fs 

length seed definition serves security parameter meant control quality implementation 
important note fs delta syntactically defined input cryptographic applications inputs length poly jsj 
stress results refer usage 

may envision applications stringent condition fs holds 
specifically may require function fs applied inputs length jsj 
specific polynomially bounded length function 
discuss effects making stringent requirement section 
correlation intractability section discuss difficulty defining requirements function ensemble behaves random oracle description 
particular show minimalistic definitions realized 
obvious failure 
comment obvious definition amount adopting pseudorandom requirement fails poorly 
demand efficient algorithm description function distinguish input output behavior random function 
function description determines input output behavior 
minimalistic definition 
require value fully specified function random may able require properties 
example may require description family function chosen random family hard find preimages function maps image 
sound definition coincides known collision intractability property 
trying generalize may replace equality images relation relation preimages images function 
say ensemble correlation intractable relation description randomly chosen function infeasible find sequence preimages images satisfy relation 
requirement unreasonably strong relations easy satisfy random oracle model 
restrict infeasibility requirement saying holds respect relations hard satisfy random oracle model 
hard find sequence preimages images random function satisfy relation description randomly chosen function fs hard find sequence preimages images fs satisfy minimalistic notion correlation intractable collection functions show collection satisfy 
fact definition consider task finding single preimage image satisfies property 
considering possible relations consider binary ones 
showing impossibility result syntactic restriction strengthens result 
definitions start formal definition relation hard satisfy random oracle model 
definition evasive relations binary relation said evasive respect length function probabilistic polynomial time oracle machine pro lambda 
uniformly chosen function delta negligible function special case evasive relations consists exists negligible function delta max lambda ae oe relations sequel falls category 
reason evasive oracle machine making poly queries random satisfies pro poly delta max lambda pro poly delta ready state minimalistic definition correlation intractable ensemble function negligible positive polynomial sufficiently large 
definition correlation intractability length function ensemble 
say correlation intractable polynomial time machine evasive relation holds pr gk fs delta negligible function probability taken choice gk coins 
definition quantify evasive relations 
weaker notion called weak correlation intractability obtained quantifying polynomial time recognizable evasive relations consider relations exists polynomial time algorithm decides 
sequel consider notions 
correlation intractable ensembles exist theorem exist correlation intractable ensembles weak sense 
proof length function ensemble 
define binary relation rf def phi fs gk psi clearly relation polynomial time recognizable fs computed polynomial time 
relation evasive lambda satisfying rf rf gamma gamma log hand consider machine computes identity function violates correlation intractability requirement pr gk fs fact rf polynomial time recognizable weak correlation intractability requirement violated 
failure random oracle methodology section show security cryptographic scheme random oracle model may imply security specific choice hash function implements random oracle 
prove statement construct signature encryption schemes secure random oracle model implementation random oracle yield insecure schemes 
put words ideal scheme secure implementation necessarily insecure 
exists jxj 
underlying idea start secure scheme may may random oracle modify get scheme secure random oracle model security easily violated trying replace random oracle ensemble 
done evasive relations constructed theorem 
modified schemes start trying find preimage image yields pair evasive relation 
case attempt succeeds scheme clearly insecure apply identity transformation message output secret key 
scheme behaves original secure scheme 
case finding pair relation occur rarely random oracle model scheme maintain security 
case occur implementation random oracle model implementation may secure 
clarity presentation start case signature scheme construction steps 
ffl step carry idea naive way 
allows prove weaker statement saying function ensemble exists signature scheme secure random oracle model secure implemented means construct function ensemble provides secure implementation cryptographic scheme secure random oracle model 
rule possibility ruled cryptographic scheme secure random oracle model exists secure implementation different function ensemble 
ffl second step diagonalization techniques reverse order quantifiers 
show exists signature scheme secure random oracle model implementation function ensemble results insecure scheme 
scheme constructed step utilizes signing verification procedures slightly super polynomial time 
ffl third step cs proofs get rid super polynomial running time obtaining standard signature scheme secure random oracle model secure implementation 
specifically step cs proofs tool diagonalize polynomial time ensembles polynomial time 
noted silvio micali technique may useful settings diagonalization techniques applied 
reader referred basic terminology regarding signature schemes corresponding notions security 
starting point constructions signature scheme denoted key generation algorithm signing algorithm verification algorithm 
assume scheme existentially unforgeable adaptive chosen message attack random oracle model 
somewhat surprisingly need rely cryptographic assumptions ideal schemes easily shown exist techniques way functions exist random oracle model alternatively ordinary signature scheme theorem conditioned existence way functions 
conventions 
steps assume loss generality security parameter implicit keys generated 
fix length function 
implicit discussions assume random oracles oracles relations evasive 
step definition 
signature scheme may may random oracle binary relation evasive length function 
sr sr vr denote modification utilizes random oracle modified signature sor sk msg message msg signing key sk 
msg msg output sk msg 

msg msg output sk msg 
modified verification vk msg oe alleged signature oe msg verification key vk 
msg msg accept 
output vk msg oe 
note key generation algorithm original scheme 
item signing verification algorithms harmful modification original signature scheme 
evasive little effect ideal system behavior modified scheme indistinguishable original 
particular proposition suppose evasive existentially unforgeable chosen message attack random oracle model 
sr existentially unforgeable chosen message attack random oracle model 
proof sketch evasive infeasible forger find message forgery modified scheme due item yields breaking original scheme 
modification enables break modified scheme implemented real ensemble case relation rf proposition 
corollary propositions immediately obtain corollary efficiently computable ensemble exists efficient signature scheme secure random oracle model implemented resulting scheme totally breakable adaptive chosen message attack existentially key attack 
proof sketch recall ensemble implement random oracle scheme sr obtain real scheme denote def uniformly pick gk set sk vk gfs output si si 
si msg def output sf sk msg 
si msg oe def output vk msg oe 
consider happens ensemble implement scheme srf recall definition rf eq 

rf evasive proposition infer srf secure random oracle model 
ensemble implement scheme seed part public verification key known adversary 
adversary simply output pair ffl accepted rf valid message signature pair fs rf 
adversary achieves existential forgery rf key attack 
alternatively adversary ask legitimate signer signature obtaining secret signing key total forgery 
second step enumeration 
loosely speaking subsection need enumeration efficiently computable function ensembles 
enumeration achieved enumeration polynomial time algorithms candidates evaluation ensembles 
standard technicalities arise 
enumerating polynomial time algorithms problematic single polynomial bounds running time algorithms 
fix arbitrary super polynomial proper complexity function 
nlog enumerate algorithms running time bounded done enumerating possible algorithms modifying algorithm adding time mechanism terminates execution case steps taken 
modification effect polynomial time algorithms 
interested enumerating ensembles modify algorithm viewing input pair hs xi standard parsing rule padding truncating output length jsj 
modification effect ensembles 
denote ith function ensemble enumeration denote function indexed ensemble standard rule parsing string ff pair hi si viewing description function universal ensemble 
denote universal function ensemble induced enumeration hi si 
exists machine computes universal function works time universal relation 
denote ru universal relation defined respect universal ensemble similarly way rf defined respect ensemble ru hi si modified signature scheme 
signature scheme 
denote su su vu modified signature scheme derived ru place previous construction 
specifically sou sk msg def recall proper complexity function time constructible exists machine computes works time 
technical requirement needed ensure enumeration computable time 
example parse string ff hs xi ff efficiently computable prefix free encoding 

msg msg ru msg hi si msg msg output sk msg 

output sk msg ou vk msg oe def 
msg msg ru accept 

output vk msg oe 
note signature verification algorithms need compute run time slightly super polynomial 
proposition suppose existentially unforgeable chosen message attack random oracle model 
su existentially unforgeable chosen message attack random oracle model implementing function ensemble yields scheme totally breakable chosen message attack existentially key attack 
recall su proper signature scheme operates slightly super polynomial time 
proof sketch ru evasive follows su secure random oracle model 
hand suppose tries replace random oracle scheme ensemble index enumeration 
adversary seed function set msg hi si output pair msg ffl accepted valid message signature pair vu 
alternatively ask signer signature msg obtain secret signing key 
third step eliminate super polynomial time signature scheme cs proofs defined constructed micali 
recall cs proof system prover trying convince verifier ver validity assertion type machine accepts input steps 
central feature cs proofs running time prover input polynomially related actual running time global upper bound verifier running time poly logarithmic relative context cs proofs random oracle model prover verifier access random oracle 
construction cs proofs micali requires computational assumptions 
precise formulation cs proofs appendix 
cs proofs construct new signature scheme works random oracle model 
construction similar subsection checking msg msg ru signer verifier gets cs proof claim needs verify validity proof 
verifying validity cs proof done efficiently checking claim scratch signing verifications algorithms new scheme may polynomial time 
yields theorem exists signature scheme existentially unforgeable chosen message attack random oracle model implemented function ensemble resulting scheme existentially key attack totally breakable chosen message attack 
note signature scheme subsection signature scheme works polynomial time 
proof sketch describe signature scheme 
construction ingredients 
ffl signature scheme operating random oracle model existentially unforgeable chosen message attack 
ffl fixed easily computable parsing rule interpret messages triples strings msg hi ssi 
ffl algorithms ver cs proof system described 
ffl access independent random oracles 
easy achieve access oracle specifically setting def def def 
oracle basic scheme oracle cs proofs oracle evasive relation 
note oracle 
ffl universal function subsection proper complexity bound nlog denote mu universal machine decides relation ru input hi si machine mu invokes ith evaluation algorithm accepts hi si note mu works time worst case 
importantly function ensemble computed time pi delta pi polynomial strings machine mu works input hi si poly jij delta pi jsj steps describe ideal signature scheme 
usual key generation algorithm remains unchanged 
signature verification algorithms proceed follows 
uo sk msg def 
parse msg hi ssi set hi si 

apply verify ss valid cs proof oracle security parameter claim machine mu accepts input time 

ss valid proof output sk msg 

output sk msg 
uo vk msg oe def 

ss valid proof accept 
output vk msg oe 
computation required item signature verification algorithms executed polynomial time 
reason definition verifying cs proof done polynomial time provided statement decided exponential time case nlog 
easy see pair sk vk output point merely fixed expression poly jij delta jsj bounded polynomial jsj 
msg string uo sk msg constitutes valid signature msg relative vk oracle show scheme secure random oracle model observe security parameter infeasible find string ru ru evasive 
soundness cs proofs infeasible find ss ru ss valid cs proof contrary relative security parameter jxj 
infeasible polynomial time adversary find message pass test item signature verification algorithms infer modified signature secure random oracle model 
show candidate implementation exists polynomial time adversary effecting total break chosen message attack analogously existential forgery key attack 
function fs denote def fs def fs def fs 
denote ensemble functions 
suppose ith function ensemble enumeration mentioned randomly chosen bit seed adversary generate message msg hi ssi ss cs proof adequate security parameter true statement mu accepts input jxj jyj steps hi si 
recall statement true adversary generate proof time polynomial time takes compute 
note perfect completeness cs proof system ability prove correct statements holds choice random oracle particular equal see appendix 
note adversary specifically designed break scheme random oracle implemented index depends choice incorporated program adversary 
efficiency condition cs proofs possible find ss oracle access time polynomial time takes mu accept input 
polynomialtime computable mu works input hi si polynomial time described adversary operates polynomial time 
construction modified verification algorithm ffl valid signature msg hi ssi existential forgery feasible priori 
furthermore requesting signer sign msg yields signing key total forgery 

note argument immaterial cs proofs implemented real world access random oracles 
specifically doesn matter cheat oracle substituted candidate function ensemble case real world implementation sufficient adversary invoke proof system valid statements 
rely perfect completeness cs proofs implies valid statements proven possible choice oracle proof system 
encryption construction signature schemes adapted public key encryption schemes straightforward way yielding theorem theorem assume exists public key encryption scheme semantically secure random oracle model 
exists public key encryption scheme semantically secure random oracle model semantically secure implemented function ensemble 
assume exists public key encryption scheme secure adaptive chosen ciphertext attack random oracle model 
exists scheme secure adaptive chosen ciphertext attack random oracle model implementing function ensemble yields scheme semantically secure chosen ciphertext attack reveals secret decryption key 
proof proof notations proof theorem 
encryption scheme semantically secure random oracle model modify get scheme 
key generation algorithm remains unchanged encryption decryption algorithms utilize random oracle viewed oracles 
modified encryption msg plaintext msg public encryption key ek 
parse msg hi ssi set hi si 
ss valid cs proof oracle security parameter assertion mu accepts pair steps output msg 

ss proof output eo ek msg 
modified decryption ciphertext private decryption key dk 
output halt 

output dk halt 

parse hi ssi set hi si ss valid cs proof oracle security parameter assertion mu accepts pair steps output dk 

output ffl 
efficiency scheme follows 
easy see pair ek dk output plaintext msg msg msg holds show scheme secure random oracle model observe infeasible find plaintext satisfies condition item encryption algorithm resp ciphertext satisfies condition item decryption algorithm 
modified ideal encryption scheme random oracle model inherits security features original scheme 
similarly show replacing random oracle function ensemble yields insecure scheme observe ensemble exists adversary similarly adapt argument shared key aka private key encryption schemes 
case computational assumptions needed shared key encryption implied way functions exist random oracle model 
seed generate plaintext msg resp ciphertext satisfies condition item encryption algorithm resp condition item decryption algorithm 
adversary identify msg encrypted violates semantic security ask decryption obtaining secret decryption key 

opposed theorem need computational assumptions exist schemes secure random oracle model 
result imply highly schemes proven exists making assumptions 
clearly scheme secure random oracles secure random oracle model 
recall exist provided trapdoor permutations exist 
restricted correlation intractability faced negative result theorem may explore restricted possibly useful versions correlation intractability property 
possibility put stringent constraints ensemble cryptographic scheme show long ensemble restricted manner guaranteed maintain aspects correlation intractability 
particular notice proof theorem relies heavily fact input fs long seed adversary feed input function fs 
option require fs inputs shorter specifically require function fs applied inputs length jsj 
pre specified function 
corresponding restricted notion correlation intractability derived definition definition restricted correlation intractability 
length functions 
machine called jm jsj lambda binary relation evasive respect polynomial time machine pro 
uniformly chosen function delta negligible function 
say ensemble restricted correlation intractable just correlation intractable short polynomial time machine evasive relation 
holds pr gk fs weak correlation intractability defined analogously considering polynomial time recognizable 
negative results proof ideas theorem easily applied rule existence certain restricted correlation intractable ensembles 
proposition gamma log infinitely exists ensemble correlation intractable weak sense 
log exists ensemble correlation intractable 
proof proof straightforward generalization proof theorem 
need consider cases case case gamma log case proceed proof theorem define rf def fs lambda jsj gamma 
second case ensemble define relation rf def lambda jxj show rf evasive showing exist polynomially rf case rf implies exists jxj 
case hypothesis jxj gamma log implies jzj log jzj log jxj 
case hypothesis jxj conclude jzj log 
polynomially upper bound number paired follows 
rf assertion rf polynomial time computable follow assuming polynomial time computable 
hand consider machine input outputs jsj bit prefix lambda fs rf proof assume finitely 
start defining inverse function gamma def minfk ng case exists define gamma 
definition follows gamma belongs set fk gamma exists 
define rf def phi lambda jxj jzj gamma jxj psi relation defined conditions lengths gamma jxj jxj function defined input case gamma log relation may polynomial time recognizable 
evasive 
security parameter rf fififi phi jzj gamma gamma psi fififi gamma gamma gamma gamma gamma log conclude set paired forms negligible fraction rf evasive 
machine input outputs jsj bit prefix satisfies fs rf 
open problems proposition leaves open question existence restricted correlation intractable ensembles case log believe interesting resolve situation way provide negative results special case provide plausible construction 
open sub case log considers weak restricted correlation intractability 
recall case proposition proven relations known polynomial time recognizable 
comment restricted correlation intractable ensembles exist non robust constructs 
example ensemble ffs jsj kgk correlation intractable respect length functions ensemble obtained applying independent copies concatenating results may 

define def ff delta delta delta ks js delta delta delta kgk delta delta delta gm delta delta delta delta ks delta delta delta def delta delta delta xm sufficiently large direct product ensemble correlation intractable natural restricted sense 
proposition 
length functions 
function 
arbitrary function ensemble defined eq 

correlation intractable natural min restricted sense delta def delta xx xx fin outg 
proof assume simplicity 
stated adapt proof theorem 
time define relation rf def fs kt jsj prefix jtj gamma delta notice definition jsj delta delta min delta jfs jtj delta delta relation min restricted 
easy see rf polynomial time recognizable evasive string gk coupled gamma fraction possible delta bit long strings log log delta 
hand consider real life adversary seed delta delta delta ksm gm delta function delta delta delta ks sets input function equal 
prefix equiv fs prefix delta delta delta ksm delta delta delta ks real life adversary violates restricted correlation intractability generalized notion correlation intractability recall proposition rule existence restricted ensembles having seeds longer sum lengths inputs outputs 
fact ensembles exist case delta seed may directly specify function values dismiss trivial useless case 
special case thing ruled narrow definition refers forming rare relationships single input output pair 
furthermore generalizes definition correlation intractability consider evasive relations unbounded sequences inputs outputs negative result extended arbitrary 
definition generalized restricted correlation intractability 
length functions 
consider probabilistic polynomial time oracle machines input oracle access function 

relation pairs binary sequences evasive respect evasive polynomial time machine holds pro xm jx xm xm usual 
uniformly chosen function 
say ensemble restricted general correlation intractable just correlation intractable short evasive relation polynomial time oracle machine holds prs xm jx xm fs fs xm proposition 
arbitrary length functions log 
exist restricted general correlation intractable function ensembles 
proof assume simplicity integer denote 
ensemble 
adapting proof theorem define relation rf def xm fs fs xm jx delta delta delta xm note relation polynomial time recognizable 
clearly evasive sequence xi coupled sequence 
identity function demonstrates corresponding general restricted correlation intractability condition hold gk parsing xm xi length xm fs fs xm rf discussion propositions demonstrate narrow margin strict correlation intractability may 
ensembles strict correlation intractable respect relations priori bounded total length input output sequences may useful applications 
typically may hold applications number invocations cryptosystem priori bounded security system depends priori bounded partial history invocations current 
note fiat shamir heuristic transforming interactive identification protocols signature schemes fall category function seed needs fixed public key signing polynomially messages polynomial priori known 
acknowledgments wish silvio micali enlightening discussions 
bellare rogaway :10.1.1.41.4144
random oracles practical paradigm designing efficient protocols 
st conf 
computer communications security acm pages 
bellare rogaway 
exact security digital signatures sign rsa rabin 
eurocrypt springer lncs vol 
pages 
blum micali 
generate cryptographically strong sequences pseudorandom bits 
vol 
pages 
preliminary version rd focs 
canetti 
realizing random oracles hash functions hide partial information 
crypto springer lncs vol 
pages 
canetti micciancio reingold 
perfectly way probabilistic hashing 
th acm symposium theory computing 
damg ard 
collision free hash functions public key signature schemes 
eurocrypt lncs vol 
springer verlag 
pages 
fiat shamir 
prove 
practical solutions identification signature problems 
crypto springer verlag lncs vol 
pages 
goldreich goldwasser micali 
construct random functions 
jacm vol 
pages 
goldwasser micali 
probabilistic encryption 
jcss vol 
pages 
preliminary version th stoc 
goldwasser micali rivest 
digital signature scheme secure adaptive chosen message attacks 
april pages 
quisquater 
practical zero knowledge protocol fitted security microprocessors minimizing transmission memory 
eurocrypt springerverlag lncs vol 
pages 
astad impagliazzo levin luby 
construction pseudorandom generator way function 
appear 
preliminary versions impagliazzo st stoc astad nd stoc 
impagliazzo rudich 
limits provable consequences way permutations 
th acm symposium theory computing 
kilian 
note efficient zero knowledge proofs arguments 
th acm symposium theory computing pages 
micali 
cs proofs 
th ieee symposium foundations computer science pages 
naor yung 
universal way hash functions cryptographic applications 
th acm symposium theory computing pages 
okamoto provably secure practical identification scheme corresponding signature scheme 
crypto pages 
pointcheval stern 
security proofs signature schemes 
eurocrypt springer verlag lncs vol 
pages 

way functions necessary sufficient secure signatures 
nd acm symposium theory computing pages 
schnorr 
efficient signature generation smart cards 
journal cryptology vol 
pages 
yao 
theory application trapdoor functions 
rd ieee symposium foundations computer science pages 
appendix cs proofs formulation cs proofs defined 
computationally sound cs proof system non interactive system proving statements type machine accepts input steps 
consists polynomial time oracle machines prover verifier ver 
security parameter prover input hm access oracle computes proof ss hm 
verifier input hm ss encoded binary access decides accept reject proof 
proof system satisfies conditions efficiency conditions important aspect micali definition construction prover satisfies stronger condition just polynomial time worst case 
specifically input hm accepts time input works time polynomial upper bound 
perfect completeness machine accepts string steps pro ss hm hm ss accept context important probability guaranteed proof true statement convincing random oracle replaced fixed function 
computational soundness polynomial time oracle machine bad input hm accepts steps holds pro ss bad hm hm ss accept poly jwj 
soundness condition proof theorem machine complexity bound delta hard find pair ss accept steps ver accept ss valid cs proof contrary 
reason seemingly stronger soundness condition security parameter string length run ver security parameter bad prover pick bit depending oracle probability able fool verifier poly 

