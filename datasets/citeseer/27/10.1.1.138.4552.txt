mark jones yale university new haven ct jones mark cs yale edu composing monads luc duponcheel bell telephone antwerp belgium ra research report yaleu dcs rr december monads increasingly important tool functional programming 
different monads model wide range programming language features 
real programs typically require combination different features important techniques combining features single monad 
practice usually possible construct monad supports specific combination features 
techniques typically ad hoc difficult find general techniques combining arbitrary monads 
report gives general constructions composition monads depends existence auxiliary function linking monad structures components 
case establish set laws auxiliary function satisfy ensure composition monad 
notation constructor classes describe specific applications constructions 
results development simple expression evaluator combines exceptions output environment variable bindings composition corresponding monads 
years concept monad idea originally motivated high level algebra important practical tool functional programmers 
reason monads provide uniform framework describing wide range programming language features including example state continuations exceptions parsing non determinism leaving framework purely functional language 
techniques familiar functional programmers new insights reinterpreted specific instances general concept 
gofer script containing executable versions programs described report currently available anonymous ftp nebula cs yale edu file pub yale fp reports rr gs 
initial interest monads motivated wadler turn drew inspiration moggi spivey :10.1.1.33.5381
monads widely small large programs example glasgow haskell compiler largest haskell program known time writing substantial monads 
new approaches old problems proposed relying heavily monads 
example monad proposed widely may soon included part definition haskell :10.1.1.100.9674
monads influencing design programming languages 
example monads provide important motivating example system constructor classes 
exception questions monads combined far received surprisingly little attention :10.1.1.33.5381
important topic real programs require combination features example state exceptions 
practice usually possible construct suitable monad supports desired combination features methods typically ad hoc monolithic 
goal report investigate techniques combining monads process composition illustrate constructions practice 
conditions required build composite monad quite complex hope provide step modular approach monads 
features monads little practice carefully chosen syntax quite easy write programs monadic style knowledge theoretical underpinnings 
spirit report directed functional programmers interest monads part practical programming project underlying category theory 
number places intentionally chosen give definitions results corresponding categorical concepts 
readers interest technical category theoretic presentation ideas described report referred 
assume familiarity motivation monads structuring functional programs wadler provides excellent topics :10.1.1.33.5381
programming examples written syntax gofer small experimental purely functional language closely definition haskell 
enables constructor classes show results expressed concrete programming language 
completeness included detailed proofs results 
keeping aim avoid unnecessary technical details proofs constructed principles simple equational reasoning 
working manner lead surprising insights 
example results section corresponds closely result stated careful study laws proof allowed weaken hypotheses state result slightly general form :10.1.1.33.5381
recognizing readers may prefer omit details proofs boxed figures easily identified skipped 
remainder report organized follows 
section gives definition algebraic properties monad describe construction compositions monads section converses section 
moving practical applications section describes results composition monads expressed notation constructor classes examples section 
simple application building framework included section 
section illustrates ways combining certain monads setting direction 
monads functional programming wadler defines monad unary type constructor functions map unit join types map unit join addition functions required satisfy collection algebraic laws map id id map map map unit map unit join map map map join join unit id join map unit id join map join join join standard infix period notation function composition symbol id represent identity function id known composition functions associative id left right identity symbols :10.1.1.33.5381
id id appropriate types 
purposes report convenient break stages unary type constructor say functor function map satisfying laws 
premonad functor function unit satisfying law 
monad premonad function join satisfying laws 
mentioned equivalent ways define concept monad comes collection monad operators equational laws 
example wadler describes monad characterized just unit function operator bind map join operators described defined bind unit 
bind operator particularly useful practical monads means translating notation monad comprehensions 
furthermore laws needed specify properties monad case 
chosen map unit join formulation monads outlined 
reason decision opinion proofs easier express framework 
addition see ability distinguish monads quite useful 
conditions composition suppose functors 
avoid confusion write mapm mapn corresponding map functions case 
possible compose functors sensible way 
certainly think composition type constructor takes type type need able give definition map satisfying functor laws 
fortunately quite easy 
apply mapn obtain mapn apply mapm obtain mapm mapn 
gives definition map mapm mapn proofs show satisfy necessary laws 
proofs standard techniques equational reasoning writing justification step right hand column 
cases just law convention example version law constructor step follows directly definition function folding unfolding definition simply write name function involved justification 
composition similar 
definition composed type constructor dealt composition functors 
suitable unit function composition unit unit unitm unitn map id mapm mapn id map mapm id id map map mapm mapn mapm mapn map map mapm mapn mapn mapm mapn map map composition functors laws unitm unitn unit functions respectively proof demonstrates satisfy law 
unit unitm unitn unit unitm mapn unitn mapm mapn unitm unitn map unit map unit composition law unfortunately real goal composition monads difficult 
recall define composition monads need find function join satisfies monad laws 
guess pattern previous examples consider function joinm joinn joinm joinn join functions component monads 
general type correct 
result joinn type joinm expects argument type form 
fact prove certain sense way construct join function type operations monads see appendix outline proof 
follows way hope form composition additional constructions linking components 
report concentrate methods constructing composite monad described sections 
trivial case definition composite monad polymorphic function join satisfying laws 
course follows directly definitions 
prod construction composition monad premonad monad polymorphic function join function defined satisfying laws prod join joinm mapm prod prod mapn map map prod prod unitn id prod mapn unit unitm prod mapn join join prod proofs 
interesting point started assumed necessary require monads 
fact proofs see need monad laws 
result construct composition monads somewhat weaker conditions originally expected 
dorp construction composition premonad monad monad polymorphic function join function defined laws hold dorp join mapm joinn dorp dorp map mapm map dorp dorp unit mapm unitn dorp map unitm id dorp join join map dorp full proofs 
case fact monad arbitrary premonad 
join map map joinm mapm prod mapm mapn map join map joinm mapm prod mapn map joinm mapm map prod joinm mapm map mapm prod joinm mapm mapm mapn mapm prod map mapm mapn joinm mapm prod map join map join join unit joinm mapm prod unitm unitn join unit joinm unitm prod unitn prod unitn id join map unit joinm mapm prod mapm mapn unit join map joinm mapm prod mapm unit joinm mapm unitm id join map join joinm mapm prod mapm mapn join join map joinm mapm prod mapn join joinm mapm join prod joinm mapm joinm mapm prod prod join joinm mapm joinm mapm mapm prod mapm prod joinm joinm mapm mapm prod mapm prod joinm mapm prod joinm mapm prod join join join join composition monads laws join joinm mapm prod join map map mapm joinn dorp map mapm mapn join map mapm joinn map mapn dorp mapm joinn mapm mapn mapn dorp map mapm joinn mapn mapn dorp mapm mapn joinn dorp mapm mapn mapm joinn dorp map join map join join unit mapm joinn dorp unit join mapm joinn mapm unitn mapm joinn unitn mapm id id join map unit mapm joinn dorp map unitm unitn join unit mapm joinn dorp map unitm map unitn mapm joinn map unitn mapm joinn mapm mapn unitn map mapm joinn mapn unitn mapm id id join map join mapm joinn dorp map mapm joinn dorp join join mapm joinn dorp map mapm joinn map dorp mapm joinn map joinn dorp map dorp mapm joinn mapm mapn joinn dorp map dorp map mapm joinn mapn joinn dorp map dorp mapm joinn joinn dorp map dorp mapm joinn mapm joinn dorp map dorp mapm joinn join map dorp join mapm joinn dorp join join join join composition monads laws join mapm joinn dorp swap construction define composition monads terms polymorphic function swap join function defined join mapm joinn joinm mapm swap satisfying collection laws 
note equivalent join joinm mapm mapm joinn swap mapm joinn joinm mapm swap joinm mapm mapm joinn mapm swap joinm mapm mapm joinn swap 
order state laws swap define named functions abbreviations expressions involving swap prod mapm joinn swap dorp joinm mapm swap justify names state laws swap function satisfy swap mapn mapm mapm mapn swap swap unitn mapm unitn swap mapn unitm unitm prod mapn dorp dorp prod possible prove existence composite monad definitions 
easier instructive indirectly exploring relationship swap prod dorp 
note definition join coincides join obtained prod construction definition prod joinm mapm prod joinm mapm mapm joinn swap prod join join furthermore definition join coincides join function obtain dorp construction definition dorp mapm joinn dorp mapm joinn 
joinm mapm swap dorp join join assuming laws satisfied proofs figures show prod dorp satisfy laws respectively 
note case monads composite monad 
example proof requires monad laws prod construction requires monad 
prod mapn map mapm joinn swap mapn mapm mapn prod map mapm joinn mapm mapn mapn swap mapm joinn mapn mapn swap mapm mapn joinn swap mapm mapn mapm joinn swap map prod map prod prod unitn mapm joinn swap unitn prod mapm joinn mapm unitn mapm joinn unitn mapm id id prod mapn unit mapm joinn swap mapn unitm unitn prod unit mapm joinn swap mapn unitm mapn unitn mapm joinn unitm mapn unitn unitm joinn mapn unitn unitm prod mapn join prod mapn mapm joinn dorp join mapm joinn swap mapn mapm joinn mapn dorp prod mapm joinn mapm mapn joinn swap mapn dorp mapm joinn mapn joinn swap mapn dorp mapm joinn joinn swap mapn dorp mapm joinn mapm joinn swap mapn dorp mapm joinn prod mapn dorp prod mapm joinn dorp prod join prod join proof prod mapm joinn swap dorp map mapm joinm mapm swap mapm mapn mapm dorp map joinm mapm swap mapn mapm joinm mapm mapm mapn swap joinm mapm mapm mapn mapm swap mapm mapn joinm mapm swap map dorp map dorp dorp unit joinm mapm swap unitm unitn dorp unit joinm unitm swap unitn swap unitn mapm unitn dorp map unitm joinm mapm swap mapm mapn unitm dorp map joinm mapm swap mapn unitm joinm mapm unitm id dorp join joinm mapm swap joinm mapm prod dorp join joinm joinm mapm mapm swap mapm prod joinm mapm joinm mapm mapm swap mapm prod joinm mapm joinm mapm swap prod joinm mapm dorp prod dorp joinm mapm prod mapn dorp joinm mapm prod map dorp map join map dorp join proof dorp joinm mapm swap summary glance constructions previous sections may mysterious case gave type polymorphic function stated laws satisfy 
presto way composing monads 
fact constructions discovered largely experimentation guessing definition join particular form example join joinm mapm prod attempting prove monad laws example determine properties prod satisfy 
types played essential part process helping suggest ways define join ensuring laws typed 
diagram summarizes results relationship different constructions compositions monads prod satisfying swap join satisfying satisfying dorp satisfying case arrows different constructions represent implications labels indicating constructors required monad 
converse results number different ways composing monads attempt see general approach 
particular natural ask kinds monads obtained constructions described 
thinking diagram previous section know definition compositions join function specified rightmost box 
goal section establish conditions necessary move back opposite direction arrows constructions 
formally suppose monads composition operators map unit join satisfying laws map mapm mapn unit unitm unitn problem determine composite monads defined way obtained prod dorp swap constructions 
prod construction fairly easy give definition prod function required type terms various monad operators available prod join unitm showing definition prod satisfies laws straightforward detailed proofs 
fact difficulty arises try map prod map join unitm prod join map map unitm join mapm mapn map unitm map join unitm mapn map prod mapn map prod prod unitn join unitm unitn prod join unit unit id prod mapn unit join unitm mapn unit prod join mapm mapn unit unitm join map unit unitm map unitm prod mapn join join unitm mapn join prod join mapm mapn join unitm join map join unitm map join join unitm join prod prod proof existence composition show join function obtain prod construction join function started 
way follows joinm mapm prod joinm mapm join unitm prod joinm mapm join mapm unitm join joinm mapm unitm join note depends assumption way join joinm commute joinm mapm join join joinm condition may little arbitrary turns composite monad obtained prod construction property joinm mapm join joinm mapm joinm mapm prod join joinm mapm joinm mapm mapm prod joinm joinm mapm mapm prod joinm mapm prod joinm join joinm join follows set composite monads obtained prod construction precisely satisfying 
dorp construction previous case easy find suitably typed definition dorp function operations composite monad components dorp join map mapm unitn proofs show definition satisfies laws hope 
difficult task show join function obtained dorp function earlier construction equal join operator composite monad 
way prove follows mapm joinn dorp mapm joinn join map mapm unitn dorp join map mapm joinn map mapm unitn join map mapm joinn unitn join map mapm id join depends assumed law time linking behaviour join joinn join map mapm joinn mapm joinn join fact law holds composite monads obtained dorp construction demonstrated join map mapm joinn mapm joinn dorp map mapm joinn join mapm joinn map joinn dorp mapm joinn mapn joinn dorp map mapm joinn joinn dorp mapm joinn mapm joinn dorp mapm joinn join join dorp map mapm join map mapm unitn map mapm dorp join map mapm unitn join map mapm mapn unitn join map map map mapm unitn map map join map mapm unitn map dorp dorp dorp unit join map mapm unitn unit dorp join unit mapm unitn mapm unitn dorp map unitm join map mapm unitn map unitm dorp join map mapm unitn unitm join map unitm unitn join map unit unit id dorp join join map mapm unitn join dorp join join map map mapm unitn join map join map map mapm unitn join map join map mapm unitn join map dorp dorp proof existence composition swap construction goal section determine class composite monads constructed swap construction section 
results composite obtained swap obtained prod dorp construction follows results sections monad obtained swap satisfy 
fact show properties necessary sufficient 
pattern previous cases start definition swap function terms join composite monad equivalently swap join unitm mapn mapm unitn swap join map mapm unitn unitm join unitm mapn mapm unitn join mapm mapn mapm unitn unitm join map mapm unitn unitm map note definitions swap expressed terms prod dorp functions previous sections swap join unitm mapn mapm unitn swap prod mapn mapm unitn prod swap join map mapm unitn unitm swap dorp unitm dorp assuming show definition prod terms swap section coincides prod function specified terms join section mapm joinn swap mapm joinn join unitm mapn mapm unitn swap join map mapm joinn unitm mapn mapm unitn join unitm mapn mapm joinn mapn mapm unitn map join unitm mapn mapm joinn unitn join unitm similar way assuming show definition dorp swap section gives function definition dorp section joinm mapm swap joinm mapm join map mapm unitn unitm swap joinm mapm join mapm map mapm unitn unitm join joinm mapm map mapm unitn unitm join map mapm unitn joinm mapm unitm map join map mapm unitn results straightforward show composite monad satisfying swap function defined satisfies laws required swap construction see proofs 
convenience swap mapn mapm dorp unitm mapn mapm swap dorp map mapm unitm map map dorp unitm mapm mapn swap map swap swap unitn dorp unitm unitn swap dorp unit unit mapm unitn swap mapn unitm dorp unitm mapn unitm swap dorp map unitm unitm map unitm dorp prod dorp join unitm prod join map dorp unitm join unitm mapn dorp map prod mapn dorp prod proof existence composition properties dorp described laws establish properties swap 
similar derivations possible laws prod directly definition swap terms join proofs little longer particularly second case 
comments completes proof set monads constructed swap function precisely satisfying 
summary corresponding diagram section summarize results converses prod dorp swap constructions follows prod satisfying swap join satisfying satisfying dorp satisfying time labeled arrows different constructions additional properties required establish converse 
properties results fairly similar law form join map join join map functions read corresponding operators monad join function composite monad 
join map operators taken composite monad mapm joinn incidentally functions satisfying law form shown quite widely studied functional programming 
example special case list monad join just concatenation list lists concat function haskell functions satisfying law referred list homomorphisms 
programming monad composition goal remaining sections show different constructions monad composition practical programming language 
convenience notation constructor classes implemented part gofer system ideas applied wider range languages 
section general framework working different forms monad composition 
describe number concrete examples monad composition simple application 
representing functors haskell programming language system type classes provide flexible treatment ad hoc polymorphism 
type class set types referred instances class family operations defined instance 
constructor classes natural extension allowing classes type constructors 
types just nullary constructors arguments includes haskell style type classes special case 
example declaration introduces class functor specifies instance map function maps functions type functions type class functor map corresponds fairly closely definition functor section include functor laws 
equality functions computable way compiler ensure laws satisfied 
useful able include part program check type correct 
way define operator representing desired equality law error uncomputable equality type signature particularly important specifying values compared type 
exact definition law type isn important argument type record type values asserted equal 
note attempt operator compare values produce runtime error 
technique represent functor laws function definitions law functor law law map id id law functor law law map map map notice function arguments model free variables definition law types variables type expressions compared read directly type signature 
note written explicitly part program type obtained automatically gofer type inference mechanism 
law unit value emphasize fact law free variables definition data law unspecified 
addition dummy argument helps avoids monomorphism restriction haskell gofer type law calculated type inference mechanism 
dummy argument explicit type signature mandatory optional 
representing framework established representation straightforward 
class described class class functor premonad unit note line declaration captures requirement premonad functor way saying premonad subclass functor 
premonad law referred part report represented law premonad law law map unit unit representing monads representation monads follows directly earlier definitions captured class monad subclass premonad class premonad monad join monad laws represented law monad law law join map map map join law monad law law join unit id law monad law law join map unit id law monad law law join map join join join general framework composition constructions easy describe composition functors definitions mapc functor functor mapc map map premonad premonad unit unit functions type right form able define instance functor premonad classes 
furthermore consider different constructions monad composition type expression form indicate construction intended 
avoid problem define different constructor composition constructions intention isomorphic composition identifying construction 
simplify task converting values type type introduce constructor class describe required isomorphisms class composer open close functions package mapc operator defined give instance functor class instance composer functor functor functor map close mapc open note definition suitable need repeat definition map function different construction 
definition composition dealt similar manner 
instance composer premonad premonad premonad unit close instance declarations compositions open close modify type value define instance particular class 
function number times subsequent sections wrap definition join function instance monad class wrap composer functor functor wrap close mapc open open type function may little daunting 
really convert function type suitable join function composition equivalent form instance composer class 
technical aside implementations give sections strictly isomorphisms representations isomorphic lifted representation 
fixed strict constructors irrefutable pattern matching purposes assume open close genuine isomorphisms consider details 
need way embed computations component composite monad 
accomplished functions right composer premonad right close unit left composer functor premonad left close map unit see section concrete example 
programming prod construction construction application composer class introduced prod construction described section 
composer identify particular construction 
data pc instance composer open pc close pc construction requires prod function described class declaration class monad premonad prod note uses parameters superclass constraints capture requirement monad premonad structure needed definition composite join function follows directly earlier results joinp joinp join map prod measure include laws required prod construction 
brevity omit corresponding type signatures case inferred automatically prod map mapc mapc prod prod unit id prod map unit prod map joinp joinp prod package joinp function defined define new instance monad class corresponding superclass instances functor premonad covered definitions previous section instance monad join wrap joinp programming dorp construction previous section fresh minds treatment dorp construction section cause big surprises 
definition new composer identify compositions obtained construction data dc instance composer open dc close dc construction requires function dorp specified class premonad monad dorp yields monad structure join function map join dorp definition dorp expected satisfy laws represented follows dorp mapc map mapc dorp dorp map unit dorp mapc unit id dorp mapc dorp package dorp construction instance monad class declaration instance monad join wrap programming swap construction pattern previous sections implementation swap construction definition corresponding new composer data sc instance composer open sc close sc compose monads technique require swap function class monad monad swap satisfying laws represented swap mapc mapc swap swap unit map unit swap map unit unit prod map dorp dorp prod prod map join swap dorp join map swap allows define monad structure composition join function joins joins map join join map swap leads instance monad class instance monad join wrap joins capture aspects relationship different constructions instance declarations 
instance prod map join swap instance dorp join map swap definitions reflect fact proved section values prod dorp derived suitable definition swap 
specific monad constructions established basic framework approach monad composition show results compose specific monads 
seen define composition works arbitrary monads 
best option fix components composition particular monad allow component range family different monads 
illustrate different constructions sections show define certain compositions reader list monads prod dorp swap constructions respectively 
examples techniques obtain compositions standard monads 
datatype datatype model form exception handling defined data just natural functor monad structure corresponding datatype declarations proofs functions satisfy appropriate laws left exercise reader instance functor map just just map instance premonad unit just instance monad join just join goal show construct new monad composing constructor arbitrary datatype 
prod construction composition form require function prod 
monad operators appear reasonable way define suitable function type 
probably proved formally kind techniques proof appendix 
hand composition form require function prod 
case know structure objects constructed relatively easy find suitable definition prod instance prod just prod unit proofs definition satisfies necessary laws 
case law split proof case values form second values just prod map mapc prod map unit prod unit map map map map unit law mapc unit mapc mapc prod prod prod map mapc just prod just mapc map mapc prod mapc prod just prod prod unit prod just unit prod prod map prod map unit prod prod map just prod just map prod unit unit unit just unit prod map joinp prod map join unit prod law join map prod unit law joinp unit joinp joinp prod prod prod map joinp just prod just joinp map joinp prod joinp prod just prod proof monad monad comprehension syntax monad constructions introduced sections convenient notation monad comprehensions 
functional programming languages including haskell gofer provide special syntax list comprehensions allow list computations expressed clearly concisely 
lists form monad see section details noticing wadler showed comprehension notation generalized arbitrary monad :10.1.1.33.5381
comprehension written notation exp gs exp expression gs list generators expressions form meaning comprehension defined translating form standard monad operators exp map exp exp unit exp exp gs hs join exp hs gs equation considered way defining map comprehension notation map exp gs exp gs 
second equation gives meaning comprehension empty sequence qualifiers 
equation variables gs hs range possibly empty sequences generators 
monad laws show way rules find translation monad comprehension effect meaning result 
see details :10.1.1.33.5381
convenience laws monad comprehensions derived definitions monad laws 
xs xs map unit exp join exp example just way writing functor law second follows directly justify equalities map map exp map exp similar way justification laws unit unit 
mention give definition join operator comprehension notation join join 
reader monads reader monad described constructor form mapping type function type refer computations monad readers read value passed parameter type change value 
functor premonad monad structures readers instance functor map instance premonad unit instance monad join declaration compose arbitrary monad reader monad dorp construction instance dorp proofs definition satisfies laws included 
list monad lists widely monads functional programming 
structure list monad captured type constructor list instance declarations instance functor list map map xs map xs instance premonad list unit instance monad list join foldr foldr function list append operator taken standard prelude 
time swap construction obtain composition monad list monad see shortly construction yields composite fact concrete syntax gofer currently requires write constructor notation list clarity 
type list type standard haskell notation 
dorp mapc map map map map dorp mapc map map map map map map map dorp dorp map map dorp map mapc dorp mapc dorp unit unit dorp unit unit unit map unit map dorp mapc unit map map unit dorp mapc map unit map unit unit dorp map join dorp dorp join dorp map dorp dorp join join dorp dorp join map dorp join map map dorp map join mapc dorp mapc join dorp mapc dorp dorp map join dorp mapc dorp map mapc dorp proof reader monads monad certain commutativity property instance list swap unit swap xs ys ys swap xs proofs hold monad structural induction required proofs shown case values follow directly pattern matching definition monad operators 
proof law involved 
need introduce auxiliary functions prod map join swap dorp join map swap quick calculation prefer proof induction definition swap allows definition prod function prod unit prod xs prod xs proof structural induction 
steps proof require explanation 
lemma describing way swap distributes swap xs ys swap xs swap ys law holds monad monad comprehension interpreted proved simple structural induction xs 
notice variant important step commutativity property enables swap generators comprehension 
require law satisfied swap prod xs swap prod xs swap swap way ensure law holds insist commutative monad satisfies law 
swap mapc swap map map mapc swap mapc map unit swap unit map map map map unit law mapc swap mapc swap swap mapc xs swap map map xs mapc swap map map map xs map ys map ys swap map map xs swap ys map ys map map swap xs induction map ys ys swap xs map ys ys swap xs map map ys ys swap xs map mapc swap xs mapc swap swap unit swap unit ys ys swap swap ys ys unit swap unit map unit swap map unit swap map unit swap swap map unit xs swap unit map unit xs map ys unit ys swap map unit xs swap ys unit ys unit xs induction xs unit xs proof list monad prod map dorp prod map unit prod swap swap join unit swap law join map swap unit law dorp unit dorp dorp prod prod prod map dorp xs prod dorp map dorp xs map dorp prod map dorp xs prod dorp dorp prod xs induction dorp join map swap prod xs dorp dorp map swap prod xs dorp prod xs swap join map swap prod xs swap dorp map swap prod xs swap swap prod xs swap prod xs swap swap commute join swap swap prod xs join swap prod xs lemma join map swap prod xs dorp prod xs dorp dorp prod xs prod proof list monad swap ys swap ys vs vs swap ys vs vs swap ys vs unit vs swap ys vs swap vs swap ys swap swap xs ys swap xs ys zs zs swap xs ys swap zs zs vs swap xs vs swap ys induction vs swap xs vs swap ys vs swap xs vs swap ys swap proof swap xs ys swap xs swap ys 
identity monad set monad reader monads property 
hand list monad monad state monad non commutative 
summary commutative monad list monad 
require single special case commutativity property possible may able relax restriction commutative monads degree 
possible remove restrictions altogether 
particular constructions compose list monad 
importance commutative monads recognized situations 
example monads satisfying commutativity axiom capture explicit parallel execution programs written monadic style 
composing monad section commented just looking types involved clear definition join joinm joinn form composition monads argument function joinn produces result type form function joinm expects value type form 
general case types match 
reader may realized argument fails special case fact required type function joinm joinm satisfy monad laws 
example list monad demonstrate direct counter example law join join map id general composition monad treated special case need constructions described 
comparison combining monads results restrict composition list commutative monads 
contrast king wadler give slightly different construction general avoiding restrictions choice monads composed list :10.1.1.33.5381
unfortunately promise general construction turns developed different manner approach turns equivalent prod construction fact require form commutativity 
construction definitions monad prod monad prod foldr unit prod function define join join map prod proof defines monad structure composed list monad resting number properties prod including prod map join map prod join map prod prod :10.1.1.33.5381
somewhat contrived counter example find law hold 
prod map join map prod :10.1.1.34.1287
join map prod prod course said proves impossible construct monads composition arbitrary monads list monad know possible constructions described report :10.1.1.34.1287
additional monad compositions sections deal examples providing compositions standard monads 
case swap construction obtain composition detailed proofs included similar previous sections detailed proofs results section included program comments gofer script containing executable version definitions report 
see comments page details availability 
writer monads writer monad describing programs produce output return value 
pays take general approach allowing type values output provided parameter monad constructor committing particular output type early stage 
declarations define constructor writer assuming output type corresponding functor monad structure writer constructor data writer result instance functor writer map result result instance monoid premonad writer unit result zero instance monoid monad writer join result result result add write writer write msg result msg write function defined perform output argument msg returned output value returned just unit value 
values zero add definitions represent null output sequencing output 
establish monad laws writer constructors need insist add associative zero left right identity 
words require values form monoid 
captured class declaration class monoid zero add obvious choices output types forms monad lists functions described instance declarations 
instance monoid zero add instance monoid zero id add 
example section lists strings values type string corresponding line output output values 
practice output type form string string sensible allowing tree structures printed linear time time quadratic size tree 
possibilities permitted definitions 
incidentally mention monad writer int assuming monoid structure instance monoid int zero add gives example commutative monad see section 
example simple profiler counting number times particular tasks carried command write increment counter suitable points program 
writer monads composed arbitrary monads definition swap instance monoid writer swap result result error monad simple variation monad described section useful able return form error message exception occurs 
described error monad data error ok error string instance functor error map ok ok map error msg error msg instance premonad error unit ok instance monad error join ok join error msg error msg prod construction obtain composition error left monad suitable definitions proofs obtained replacing just ok value form error msg section 
alternatively swap construction definition instance error swap ok map ok swap error msg unit error msg tree monad final example consider tree monad defined constructor tree mapping type type tree binary trees leaf values type monad structure declarations data tree leaf tree tree instance functor tree map leaf leaf map lx rx map lx map rx instance premonad tree unit leaf instance monad tree join leaf join lm rm join lm join rm composition tree monad monad described swap construction instance tree swap leaf leaf swap lm rm lx rx lx swap lm rx swap rm case list monads proof depends commutativity property proofs proofs monad laws tree require special properties simple example evaluator section show monad constructions introduced small practical example expression evaluator 
example interesting environment mapping variables values careful treatment unbound variables provide simple trace facility 
base expression evaluator types representing values variable names environments mappings variable names values expressions type value int type name string type env name value data expr const value var name expr expr trace string expr keep example short restricted simple expression language allowing constants variables addition simple trace mechanism 
evaluator need access variables bound environment may produce output trace facility requires form error handling deal unbound variables 
captured defining monad structure type constructor type env writer string error working suitable versions monad operators particular type 
re going really verify monad laws definitions choose operators 
definition quite complex require long error prone largely calculation 
alternative tools introduced report recognize definition expressed composition monads 
assuming components monads results mean approach requiring proofs type env writer string error honesty admit looks ugly 
language designed scratch support kind reasonably expect able define clumsy manner equation form env writer string error functions defined terms general left right functions introduced section embed computations component monads full monad error right right env left writer string right left possible package functions general way overloading mechanism types form constructor consider 
give definition evaluator need simple utility function determine value bound particular variable environment 
type enable deal cases depending variable bound environment 
lookup name env error value lookup env ok lookup env lookup error unbound variable complete evaluator defined follows single case possible form expression eval expr value eval const unit eval var lookup eval eval eval eval trace eval write show provide function execute computation monad environment value returning string result result text env string result env output result val result open open env val case ok show error msg msg example programs described gofer interpreter expression trace sum const const var gives results result eval output sum result unbound variable result eval output sum result ways combine monads having spent time concentrating composition monads important point methods combine monads 
cases composition monads suitable implies certain level independence components may desired 
example common application monads model state computations state transformers functions initial state returning pair containing final state return value type 
described example type constructor data state st type gives type values state represents type return values 
standard functor monad structure declarations instance functor state map st st st st instance premonad state unit st instance monad state join st st st notice type constructor state isomorphic composition reader monad writer monad writer 
monad structure associated constructors different 
example unit function state monad returns initial state value unchanged unit operator composition returns zero additional constraint monoid 
general construction combining monads applied writer obtain state monad 
interesting example combine simple state monad arbitrary definitions adapted data stm instance monad functor map stm xs stm xs instance monad premonad unit stm unit instance monad monad join stm xss stm stm xs xss xs example monad form construction combinator parser 
kind application stream tokens parsed state 
possible choices monad include list monad deal ambiguous grammars 
monad support backtracking parsers 
error monad provide error handling 
composition error allow error handling backtracking 
looking types involved express composition reader monad writer writer definitions report monad structure composition right different monad structure constructor left declarations 
combination state monad arbitrary monad described instance general construction monad combination 
way view examples report generalization concept monad include hole filled monad obtain suitable combinations features 
example constructors examples hole represented parameter similar idea motivates steele holes built called pseudomonad operators individual constructors 
pseudomonad operators difficult express properly haskell type system appear require form existential recursive typing 
fortunately quite easy express operators constructor classes class premonad pseudomonad monad monad id map function included familiar provides pseudomonad version monadic bind operator mentioned section 
function steele included close relationship join formulation monads report 
strictly speaking functions required define instance pseudomonad class default definitions provided lines class declaration show defined terms 
types similar types corresponding monad operators additional parameter representing arbitrary monad replacing parameter identity monad gives familiar monad operators 
hand extra parameter enables describe composition simple elegant manner 
starting definition new composer data comp cc instance composer comp open cc close cc composition arbitrary pseudomonad arbitrary monad yielding composite monad comp described instance declaration instance pseudomonad monad monad comp join wrap join map way build chain pseudomonads 
pn final hole plugged monad comp 
comp comp 
pn infix dot comp just pn 
certainly promising approach hope investigate relationship constructions fully 
different constructions compose monads shown encoded practical programming problems provide combination features offered component monads 
proofs required establish monad laws composition require simple equational reasoning structural induction little long 
hand developed small library describing compositions certain standard monads extended include monads necessary 
results construct new monads proof obligations 
surprising aspect need restrict attention commutative monads compositions list monad 
additional property necessary establish monad law referred associative law monads 
practice examples basic framework suggested types monad operators useful practical programming examples corresponding monad laws satisfied 
examples include strictness monad state transformers composable contexts :10.1.1.33.5381
similar way expect composition arbitrary monads list may useful practical programming applications associativity law hold 
functional programmers prepared sacrifice algebraic properties full monad gaining wider application techniques monadic style programming reward 
acknowledgments described report grew conversation authors comp lang functional newsgroup december grateful access forum 
mark jones supported part arpa contract number 
luc duponcheel carried recreation hobby jos support bell opportunity spend little time kind research oriented 
duponcheel 
short note monad monad morphism composition 
bell telephone antwerp belgium 
manuscript september 
hall hammond partain peyton jones wadler 
glasgow haskell compiler retrospective 
proceedings glasgow workshop functional programming ayr scotland july 
springer verlag workshops computing series 
hudak peyton jones wadler eds 
report programming language haskell version 
acm sigplan notices may 
hutton :10.1.1.34.1287
higher order functions parsing 
journal functional programming volume part july 
jones 
system constructor classes overloading implicit higher order polymorphism 
proceedings th acm conference functional programming languages computer architecture copenhagen denmark acm press june 
jones hudak 
implicit explicit parallel programming haskell 
yale university department computer science research report yaleu dcs rr august 
kieburtz hook 
monads continuations 
proceedings acm sigplan workshop continuations department computer science stanford university report 
stan cs june 
king wadler :10.1.1.33.5381
combining monads 
proceedings fifth annual glasgow workshop functional programming ayr scotland springer verlag workshops computer science 
moggi 
computational lambda calculus monads 
ieee symposium logic computer science asilomar california 
odersky rabin hudak 
call name assignment lambda calculus 
th annual symposium principles programming languages charleston south carolina 
peyton jones wadler :10.1.1.100.9674
imperative functional programming 
th annual symposium principles programming languages charleston south carolina 
spivey 
functional theory exceptions 
science computer programming 
steele jr building interpreters composing monads 
appear proceedings st annual acm sigplan sigact symposium principles programming languages portland oregon january wadler :10.1.1.33.5381
comprehending monads 
mathematical structures computer science december 
earlier version appears conference lisp functional programming nice france june 
wadler 
essence functional programming 
th annual symposium principles programming languages santa fe new mexico january 
appendix non existence natural join section commented certain sense impossible construct join function composition monads operators component monads 
sketch proof claim 
full justification approach goes little scope 
particular need recognize fact categorical perspective type map function involves different kinds function arrows objects arrows arrows 
distinctions lost functional languages haskell gofer 
believe result techniques proof interest readers decided outline details appendix 
suppose working category monads endofunctors general case typed terms constructed setting functors natural transformations unit join monads precisely terms obtained set typing rules id map map unitm unitn joinm joinn course assumes basic properties category 
richer categories may operations forming products sums exponentials addition guarantee full abstraction may arrows underlying category obtained rules 
main aim exactly kind arrow prod dorp swap function construct composition 
characterization show way construct term type natural join function composition regard types rules purely formal expressions convenience write types strings notation rd string obtained removing adjacent duplicates example rd result want follows lemma proved simple structural induction 
lemma rd suffix rd suffix follows way define join function required type 
similar arguments show way define natural prod dorp swap functions framework 

