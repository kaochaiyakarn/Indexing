partial dead code elimination jens knoop universit passau lambda knoop fmi uni passau de oliver kiel informatik uni kiel de bernhard steffen universit passau lambda steffen fmi uni passau de new aggressive algorithm elimination partially dead code code dead program paths 
powerful usual approaches dead code elimination algorithm optimal sense partially dead code remaining resulting program eliminated changing branching structure semantics program impairing program executions 
approach techniques partial redundancy elimination 
new technical problems significant difference partial dead code elimination introduces second order effects overcome means exhaustive motion elimination steps 
optimality uniqueness program obtained proved means new technique universally applicable particularly useful case mutually interdependent program optimizations 
topics data flow analysis program optimization dead code elimination partial redundancy elimination code motion assignment motion bit vector data flow analyses 
proceedings th acm sigplan conference programming language design implementation pldi orlando florida sigplan notices 
motivation dead code elimination technique improving efficiency program avoiding execution unnecessary statements run time 
usually lambda fakult ur mathematik und informatik universit passau passau germany 
ur informatik und praktische mathematik christian universit kiel germany 
assignment considered unnecessary totally dead content left hand side variable remainder program 
partially dead assignments node dead left alive right branch considered 
simple motivating example moving assignment node entry node node assignment dead node removed shown 
aggressive algorithm partial dead code elimination optimally captures effect partially dead code remaining resulting program eliminated changing branching structure semantics program impairing program executions 
point algorithm move partially dead statements far possible direction control flow maintaining program semantics 
process places statements specific context possible maximizes potential dead code subsequently eliminated 
partially dead assignment removed approach essentially dual partial redundancy elimination computations moved control flow far possible order effects universal possible 
similar techniques applied 
moving assignments turns intricate moving eliminating assignments mutually influence illustrated dx illustrating second order effects significant inefficiency example program obviously loop invariant code fragment node removed loop standard techniques loop invariant code motion instruction defines operand second assignment note interleaving code motion copy propagation suggested succeeds removing right hand side computations loop assignment remain 
ex ba result algorithm performs optimization displayed steps removing second assignment loop suspends assignment removed loop 
systematic treatment second order effects important part algorithm 
illustrating treatment loops addition covering second order effects algorithm captures arbitrary control flow structures elegantly solves usual problem distinguishing profitable code motion loop structures fatal code motion loops 
fact execution resulting program fast similar execution original program set statements executed reduced 
illustrated example contains loop constructs irreducible 
result shows algorithm moves assignment node irreducible loop construct removes dead code branch leading node inserts new node edge connecting node node 
worth noting assignment node partially dead 
elimination partially dead assignment require move second loop dramatically impair program executions 
related idea assignment sinking dead code elimination global optimizer sketched 
algorithm restricted special control flow patterns address general problem 
dhamdhere proposed extension partial redundancy elimination assignment movement contrast approach assignments hoisted sunk allow elimination partially dead code 
pointed importance partial dead code elimination 
algorithm characterized considering complex statements movement candidates elementary statements blocked 
contrast usual code motion algorithms may modify branching structure program consideration 
algorithm sketched discussed capable moving statements loops loops 
considers transformations place occurrence possibly complex partially dead statement single point live 
restriction forbids attractive optimizations 
instance assignment gamma removed node consequence second order movements missed 
example possibly dealt extension algorithm vaguely mentioned 
extension fail capture movements require simultaneous treatment occurrences specific pattern 
instance partially dead assignments node node eliminated simultaneous treatment occurrences 
illustrating briggs cooper algorithm published proceedings employs instruction sinking expressions 
product partially dead assignments removed 
contrast algorithm strategy instruction sinking significantly impair certain program executions instructions moved loops way repaired subsequent partial redundancy elimination 
example algorithm sink instruction node loop node 
note subsequent partial redundancy elimination fails hoist back safety reasons 
dhamdhere presents application code hoisting sinking techniques register assignment provide contribution general problem partial dead code elimination 
instruction scheduling techniques usually restricted basic blocks loops focus specific goals code generation instance yield short evaluation sequences respect machine model prepare code efficient execution parallel pipelined machine 
structure develops lines 
preliminary section section presents central notions approach establishes essential features partial dead code elimination 
subsequently section gives detailed discussion second order effects section develops algorithm 
complexity estimation section drawn section 
preliminaries consider variables terms directed flow graphs node set edge set nodes represent basic blocks statements edges nondeterministic branching structure unique start node node assumed represent empty statement skip possess predecessors successors respectively 
statements classified groups assignment statements form empty statement skip relevant statements forcing operands alive 
ease presentation relevant statements explicit output operations form notion lhs refer left hand side variable assignment statement 
succ df pred df denote set successors predecessors node respectively 
path sequence nodes nk practice conditions statements assignments global variables variables declaration outside scope flow graph consideration considered relevant 
straightforward extend approach accordingly 
ni succ ni denotes set finite paths node assumed lie path assignment pattern ff string form set assignment patterns occurring program denoted ap 
critical edges partial redundancy elimination partial dead code elimination blocked critical edges flow graph edges leading node successor node predecessor cf 

critical edges assignment node partially dead respect assignment node 
partially dead assignment safely eliminated moving successors may introduce new assignment path entering node left branch 
hand safely eliminated inserting synthetic node critical edge illustrated 
restrict attention programs critical edge split inserting synthetic node 
partial dead code elimination conceptually partial dead code elimination stands sequence ffl assignment ffl dead code eliminations formally defined 
definition assignment sinking ff assignment pattern 
assignment sinking ff program transformation ffl eliminates occurrences ff ffl inserts instances ff entry exit basic blocks reachable basic block eliminated occurrence ff 
order admissible sinking assignments semantics preserving 
obviously sinking assignment pattern ff blocked instruction ffl modifies operand ffl uses variable ffl modifies variable define definition admissible assign 
sinking assignment sinking ff admissible iff satisfies conditions 
removed assignments substituted program path leading occurrence ff eliminated instance ff inserted node path ff blocked instruction 
inserted assignments justified program path leading instance ff inserted occurrence ff eliminated node path ff blocked instruction definition assignment elimination assignment elimination ff program transformation eliminates original occurrences ff argument program 
sinking assignments elimination admissible leads notion dead assignments 
occurrence assignment pattern ff basic block dead left hand side variable dead path right hand side occurrence considered instance ff preceded modification simple definition strong order characterize assignments relevant computation 
recursive definition yields characterization 
occurrence assignment pattern ff basic block faint cp 
left hand side variable faint path right hand side occurrence instance ff preceded modification assignment left hand side variable faint 
example taken shows faint assignment scope dead code elimination 
faint dead assignment faint code elimination powerful dead code elimination 
hand contrast faint code elimination dead code elimination efficient bit vector data flow analysis 
consider techniques sequel 
definition dead faint code elim 
dead faint code elimination assignment pattern ff assignment elimination ff dead faint occurrences ff eliminated 
worth noting admissible assignment sinking preserves program semantics 
true assignment eliminations 
fact dead faint code eliminations may change semantics program reducing potential run time errors possible changes semantics induced dead faint code elimination 
particular evaluation program instruction remains program guaranteed behave exactly 
definition part 
dead faint code elim 
partial dead faint code elimination pde pfe arbitrary sequence admissible assignment dead faint code eliminations 
write pde pfe flow graph results applying admissible assignment sinking dead faint code elimination flow graph denote universe programs resulting partial dead faint code elimination think overflow division zero caused evaluation right hand side term eliminated assignment 
go df lambda rest section 
key notion definition optimality pde pfe 
go better signs ff ap ff pg ff pg ff pg ff pg denote number occurrences assignment pattern ff respectively 
lambda go optimal lambda better program go relation better pre order go reflexive transitive antisymmetric 
may programs optimal sense definition 
hand obvious go optimal element 
constructive criterion guaranteeing existence optimal element 
criterion slight generalization tarski fixpoint theorem tailored deal mutually interdependent program transformations 
setting consider partial order vo go defined vo df lambda finite family functions fo ff go go satisfying 
dominance go fo vo 
monotonicity go fo vo vo family functions fo apply generalized version tarski fixed point theorem order obtain theorem existence optimal programs go optimal element wrt computed sequence function applications contains elements fo sufficiently 
optimal program unique 
show exists canonical representative unique reorderings basic blocks 
note relation reflexive 
fact precise notion 
remember branching structure preserved 
starting path easily identify corresponding paths 
second order effects partial dead code elimination section discuss interdependencies various sinking elimination steps assignments 
comparison consider situation partial redundancy elimination 
partial redundancy elimination conceptually composed kinds elementary program transformations 
hoisting computations second eliminating total redundancies 
partial redundancy elimination done independently program term single application step sufficient yield optimal result 
unfortunately hold partial dead code elimination 
fact various kinds second order effects need considered 
going systematically discuss effects fully captured algorithm section 
sinking elimination effects effect primary interest assignment sunk eliminated dead faint code elimination 
reconsider motivating examples section illustration 
sinking sinking effects sinking assignment may open way assignments sink redefinition site assignments modifies operand right hand side term 
case illustrated 
previously sinking assignment node assignment node sink entry node 
blocked sinking corrupt value right hand side expression 
anticipating sinking assignment node node assignment node sunk node node dead code elimination removes occurrence node displayed 
elimination sinking effects similar reasons elimination dead assignments may enable sinking assignments see illustration 
assignments node node sunk violating admissibility 
assignment node removed dead code elimination value anymore 
removal enables assignment ca sinking sinking effect sunk node order eliminate partially dead assignments leading program displayed 
elimination sinking effect elimination elimination effects effect illustrated 
assignment node dead eliminated path leading node lefthand side variable redefined 
subsequently assignment node dead due usage node dead removed shown 
worth noting example shows second order effect partial dead code elimination order effect partial faint code elimination assignments node node faint eliminated simultaneously faint code elimination 
elimination elimination effect algorithm section algorithm optimal elimination partially dead faint assignments 
give overview algorithm subsequently describe relevant steps detail 
overview algorithm pde pfe consists main procedures repeated program stabilizes 
procedure dce fce elimination dead faint assignments controlled dead faint variable analysis 

procedure ask assignment sinking controlled analysis working bit vectors sinking candidates 
going describe procedures detail 
complexity estimation section 
eliminating dead faint assignments elimination dead faint assignments determination dead faint variables 
dead variables computed means backwards directed bit vector data flow analysis 
standard formulation table dead dead mean variable dead entry exit statement 
additionally table shows equation system faint variable analysis analogously dead variable analysis faint faint mean variable faint entry exit statement 
faint problem bit vector form easily solved means iterative worklist algorithm operating bit vectors cp 

subtlety slot assignment statement may influenced slot successor node slot lhs 
taken care additionally updating worklist slots right hand side variable slot lhs processed successfully 
worth noting cause problems correctness complexity method cf 
section 
having computed greatest solution equation systems specified table corresponding program transformation simple elimination step process basic block successively eliminating assignments left hand side variables dead faint immediately 
standard methods dead code elimination usually definition graphs connect definition sites variable corresponding sites 
dead assignments identified indirectly means simple marking algorithm working definition graph 
algorithm uses optimistic assumptions faint assignment detected time proportional size graph 
unfortunately definition graphs usually quite large order worst case denotes number instructions number variables occurring flow graph 
algorithm improves result working sparse definition graph ssa form 
results worst case time complexity coincides complexity simple iterative algorithm cf 
section 
sinking assignments program transformation stage analysis designed determine far hoisted computation sunk earliest initialization point order minimize lifetimes temporaries introduced partial redundancy elimination maintaining computational optimality 
table presents analysis adapted situation bit vector format bit corresponds assignment pattern occurring program 
intuitively mean sinking candidates ff moved entry exit basic block respectively sinking candidates occurrences assignment inside basic block blocked followed modification operand modification usage see illustration 
note various occurrences assignment pattern basic block candidate global sinking occurrence blocked subsequent occurrence 
bca bca sinking candidate sinking candidates greatest solution equation system displayed table characterizes program points instances assignment pattern ff inserted means insertion predicates insert insert 
subsequent program transformation simple easily shown assignment patterns inserted particular program point independent placed arbitrary order insertion step process basic block successively inserting instances assignment pattern ff entry exit ff ff satisfied termination global algorithm algorithm terminates soon steps dead faint code elimination assignment sinking leave program invariant 
case dead faint code elimination simply means assignments eliminated case assignment sinking holds basic block satisfies false 
results denoting final programs result applying algorithm partial dead faint code elimination respectively due edge splitting insertions exit branching nodes 
local predicates ffl right hand side variable instruction ffl right hand side variable relevant instruction 
ffl ass right hand side variable assignment statement 
ffl mod left hand side variable instruction 
dead variable analysis bit vector dead df lambda dead mod dead df succ dead faint variable analysis simultaneously variables faint df lambda faint mod lambda faint lhs ass faint df succ faint table dead faint variable analysis ain particular variables occurring relevant statements considered right hand side variables 
analyses employed instruction level 
important faint variable analysis 
fact dead variable analysis straightforwardly modified basic blocks 
theorem correctness 

easy prove df df satisfy dominance monotonicity property section 
apply theorem establishes optimality results theorem optimality theorem 
optimal 
optimal complexity parameterized complexities components ffl complexities data flow analyses corresponding component transformations ffl maximal factor number instructions may increase application algorithm ffl maximal number applications component transformations results complexity transformations pde delta pfe delta denotes number instructions occurring original program 
factor delta caused actual intermediate transformations updates local predicates 
subsections provide detailed estimation parameters mentioned terms number basic blocks number instructions number variables number assignment patterns original program 
subsequently complexity sketched roughly terms uniform parameter reflecting program size argument program 
local predicates ffl ff sinking candidate ff ffl ff sinking ff blocked instruction analysis df 
false sq pred delayed df lambda insertion points df lambda df lambda succ table analysis insertion points complexity component transformations analysis analysis realizing essential part assignment sinking procedure forward directed bit vector data flow analysis 
structured flow graphs efficient bit vector techniques applicable yielding linear complexity terms fast bit vector operations 
arbitrary control flow structures approach best yielding delta worst case time complexity assignment sinking procedure 
dead faint variable analysis dead code analysis bit vector problem 
replacing parameter estimations apply worst case time complexity 
unfortunately faint variable analysis bit vector problem solution computed variable independently 
special algorithms structured programs approach applied 
note structure faint code analysis requires computation instruction level 
prove usual assumptions ffl size program terms bound constant ffl number edges order faint code elimination proportional number instructions number program variables 
investigating equation system faint variable analysis table reveals iterative computation greatest solution equation system slot variable change value true false 
changes reason updating worklist ffl slot part entry bit vector instruction predecessors slots exit bit vectors added current worklist ffl slot part exit bit vector instruction slots bitvector added current worklist right hand side variable easily establish edge control flow graph considered times analysis order reach corresponding successor 
applying assumptions yields number worklist entries written faint code analysis algorithm proportional program size number program variables 
similar argument suffices prove global cost faint code analysis including effort slot processing order completes proof 
size program may increase factor execution algorithm see section intermediate program size execution algorithm estimated delta yielding worst case complexity delta delta required faint analysis steps 
estimating code size induction length shortest acyclic path reaching node easily shown number instructions inserted bound number instructions number instructions basic block exceed showing order worst case 
practice expect bound constant 
estimating number iterations applying shortest path argument section number assignments inserted node application algorithm bound number dce fce ask applications estimated delta yielding quadratic program size 
conjecture depends linearly summary combining results previous subsections ffl estimated ffl estimated 
guarantees partial dead code elimination order partial faint code elimination order worst case 
estimations pessimistic 
conjecture reduce complexities respectively 
reasonable assumption factor indicates degree static code replication order saves factor partial faint code elimination saves factor partial dead code elimination fast bit techniques applicable 
expect quadratic behaviour partial dead code elimination cubic behaviour partial faint code elimination 
summarizing time bound algorithms slightly worse significantly weaker technique dead code elimination definition graphs comparable complexity aggressive code motion techniques 
algorithm global value numbering requires reducible flow graphs guarantees optimality acyclic program structures third order 
new aggressive algorithm optimal elimination partially dead faint code captures second order effects due mutual dependences assignment sinking dead faint code elimination 
algorithm comparably expensive aggressive optimization methods 
complexity ranges dead version realistic structured programs faint version completely unrestricted worst case 
aggressive methods algorithm typically employed optimization time critical sections code moderate size 
general modifications algorithm applied limit number assignment sinking dead faint code elimination steps 
currently investigating heuristics guiding limitation range simply cutting global iteration process amount time fixed number iterations localizing optimization process hot areas 
grateful anonymous referees gerald valuable comments 
aho johnson ullman 
code generation expressions common subexpressions 
journal acm 
aho sethi ullman 
compilers principles techniques tools 
addisonwesley 
bernstein rodeh 
global instruction scheduling superscalar machines 
proc 
acm sigplan conference programming language design implementation volume acm sigplan notices pages toronto ontario june 
briggs cooper 
effective partial redundancy elimination 
proc 
acm sigplan conference programming language design implementation volume acm sigplan notices pages orlando fl june 
cytron ferrante rosen wegman zadeck 
efficiently computing static single assignment form control dependency graph 
acm transactions programming languages systems 
dhamdhere 
fast algorithm code movement optimization 
acm sigplan notices 
dhamdhere 
register assignment code placement techniques 
journal computer languages 
dhamdhere 
usually linear algorithm register assignment edge placement load store instructions 
journal computer languages 
dhamdhere 
practical adaptation global optimization algorithm morel renvoise 
acm transactions programming languages systems 
technical correspondence 
dhamdhere rosen zadeck 
analyze large programs efficiently 
proc 
acm sigplan conference programming language design implementation volume acm sigplan notices pages san francisco ca june 

drechsler 
solution problem morel renvoise global optimization suppression partial redundancies 
acm transactions programming languages systems 
technical correspondence 

drechsler 
variation knoop steffen lazy code motion 
acm sigplan notices 
xue 
revival transformation 
conf 
record nd acm symposium principles programming languages pages portland oregon january 
knoop steffen 
chaotic fixed point iterations 
mip bericht fakult ur mathematik und informatik universit passau germany 
gibbons muchnik 
efficient instruction scheduling architecture 
proc 
acm sigplan symposium compiler construction volume acm sigplan notices pages june 
giegerich wilhelm 
invariance approximative semantics respect program transformations 
proc 
third conference european operation informatics informatik pages 
springer 
hecht 
flow analysis computer programs 
elsevier north holland 
horwitz demers teitelbaum 
efficient general iterative algorithm data flow analysis 
acta informatica 
kam ullman 
global data flow analysis iterative algorithms 
journal acm 
kennedy 
node listings applied data flow analysis 
conf 
record nd acm symposium principles programming languages pages palo alto ca 
kennedy 
survey data flow analysis techniques 
muchnick jones editors program flow analysis theory applications chapter pages 
prentice hall englewood cliffs nj 
knoop steffen 
lazy code motion 
proc 
acm sigplan conference programming language design implementation volume acm sigplan notices pages san francisco ca june 
knoop steffen 
optimal code motion theory practice 
acm transactions programming languages systems 
kou 
live dead analysis global data flow problems 
journal acm july 
mintz fisher sharir 
design global optimizer 
proc 
acm sigplan symposium compiler construction volume acm sigplan notices pages denver col 
morel renvoise 
global optimization suppression partial redundancies 
communications acm 
rosen wegman zadeck 
global value numbers redundant computations 
conf 
record th acm symposium principles programming languages pages san diego ca 
sethi ullman 
generation optimal code arithmetic expressions 
journal acm 
tarjan 
applications path compression balanced trees 
journal acm 
wegman zadeck 
constant propagation conditional branches 
acm transactions programming languages systems april 
