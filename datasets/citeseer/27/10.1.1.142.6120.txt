query deforestation torsten marc scholl faculty mathematics computer science university konstanz torsten marc scholl uni konstanz de construction declarative query engine dbms includes challenge compiling algebraic queries efficient execution plans run top persistent storage 
pursues goal employing foldr build deforestation derivation efficient streaming programs programs allocate intermediate data structures perform task algebraic combinator query plans 
query engine insertion representation collections base types making deforestation idea amenable wide range type constructors operators 
addition removal intermediate data structures deforestation implements certain algebraic optimizations free 
query deforestation generally applicable technique puts derivation streaming programs compact formal framework immediately applicable 
motivation construction declarative query interface dbms lets challenges show compilation queries equivalent access plans eoecient execution top persistent storage play major role 
compiled plans exhibit tree structure nodes represent operators implement diverse tasks selections aggregations joins grouping 
non trivial eoeciently schedule aeow data leaves processing tree root represents query result 
assigning operators single processes connected ipc facilities control aeow execution disk les communicate temporary results operating system scheduling ed costly option 
necessary process context switches ipc cost temporary results dominate query cost 
dioeerent lines research led development single process query engines query plan compiled single iterative recursive procedure 
possible approaches strive stream pipelined execution avoid temporary data 
query processor ts streaming objects addressed brought persistent storage 
execution memory intermediate writes persistent store subsequent fault ins occur 
query compiler arranges query plan sequence separate operators obvious eoecient streaming procedure automatically derived operators commonly individually designed combinators consume input transform subsequently produce intermediate result 
combinators arranged functional composition form query plans 
combinator style query engines highly modular easily extensible suitable targets query compilation bears abovementioned performance penalty 
core concern automatically derive streaming programs extensive query engine supported operators data types arbitrary combinator queries 
go common pipelining approaches geared fuse combinator patterns adjacent select project join operators 
graefe proposed solution operators re coded streaming style operators consume input demand lazily element wise 
operators interact simple stream 
call interface 
employed instance burlington unfold transform fold program transformation strategy inner control structure combinators expressed limited subset lisp revealed unfolded goal fusing neighbouring combinators 
rule sets described fusing possible 
strategy tried fold fused program back combinator form step involved complex pattern matching cases done semiautomatically 
developed set fusion rules imperative programming language plans coded 
arrange query plan sequence combinators coincides closely called style functional programming complex list manipulations expressed compositions simple general functions map generating intermediate result list combinators adhere simple syntactic criterion programs optimized wadler deforestation 
program allocates intermediate data structures unfortunately deforestation involves fold step increases technique complexity considerably 
regular collection producer consumer scenario query engine demand deforestation technique applicable full functional programming language cheap deforestation possible programs generic combinator foldr consumer :10.1.1.39.5086
query compilation context restrictive may 
shown combinators needed compilation full declarative object query language oql entirely expressed foldr 
proposals expressive query languages relied variants foldr 
cheap foldr build deforestation step transformation involve fold step 
relies observation list built constructors cons nil subsequently reduced foldr may reduced construction 
furthermore due deforestation separate program parts adjacent 
may eoeect see opportunity optimizations stream operator model provide 
contribution 
deforestation provides formal framework derivation stream plans problem primarily tackled implementation level 
extend list deforestation left associative algebras general idea amenable query engines object query languages oql advanced bulk type systems operator sets 
formal setting complements algebraic optimization described corresponding optimizing translation execution plan level 
query deforestation handles classes nested programs expressed previous unsafe programs 
due simplicity deforestation step transformation large set equivalence laws technique easily integrated actual query optimizer 
synopsis 
sequel pursue goal foldr build deforestation query execution plans source language oql 
proceed follows 
section reviews insertion representation collections base data types making queries sets bags cation aggregation accessible originally list cheap deforestation 
query engine combinators mapped core language built foldr 
translation oql framework possible principal method may 
section examines deforestation queries show cover extend despite generality special lazy functional language may built lists elements allocated garbage collected anyway 
deforestation removes intermediate data structures wadler collectively refers trees 
name deforestation 
transformations developed 
discuss connections related particular details context 
section sheds light correctness implementation issues 
idea evolve touched section 
haskell style representation language sake readability 
query representation nite value type ff list may built nitely applications list constructors 
consequence initiality algebra ff list es deo nition functions pattern matching patterns resp 
xs take lists apart 
principle extends algebras 
finite values type ff set may built nitely insertions empty set similarly bag type constructor 
adopt insertion representation collections sake notational uniformity denote constructors type constructor bag set left commutative left idempotent set set xs set set xs set set xs set xs associates right 
consequences deo nedness foldr return section 
aggregation cation may understood model 
aggregates sum min represented algebras sum int resp 
min int int min 
ers exists implemented bool true exists bool false universal cation collection booleans starts constructor true inductively adds collection member boolean conjunction compute result 
prefer write usual constructors non collection algebras true denote 
see mapping oql complete family aggregates ers lines 
query engine algebraic combinators naturally expressed familiar list operations 
point shows selection filter existential cation exists really new learned 
amenable deforestation give foldr deo nitions engine combinators shortly 
note filter exists exclusively constructors resp 
exists algebra produce result 
combinators carry collection type operate annotation 
time annotations may understood type abstractions sense second order calculus 
ff bool ff ff xs filter xs filter xs ff bool ff bool false xs xs recursive deo nitions combinators filter exists 
filter exists exhibit pattern simple recursion reduction algebraic combinators 
generic functional foldr variants referred pump sri literature implements pattern implies complete query engine built solely eoecient implementation foldr section come back point foldro ff fi fi fi ff fi foldro foldro xs foldro xs abbreviate delta delta delta xn follows 
haskell write phi application ino operator phi binary function ino operator 
evaluation foldro delta delta delta xn results xn delta delta delta collection argument constructor replaced binary function likewise 
xs 
xs false obtain exists transformation recursive combinator deo nitions equivalent non recursive foldr form straightforward may done machine :10.1.1.39.5086
lists query operators encounter sequel 
may similarly deo ned 
say deo nedness operators section 
foldro xs 
xs xs foldro xs 
xs foldro xs 
xs false allo foldro xs 
xs true foldro xs 
xs foldro xs 
xs oe foldro xs 
ys 
ys ys xs oe foldro xs 
xs xs oe foldro xs 
ys 
oe ys ys oe xs foldr deo nitions algebraic combinators 
aside combinators pretty standard explain join implements binary join respect predicate result building function obtain collection pairs 

operator combines join grouping object group objects predicate built duplicate removal 
proven especially useful query processors complex object models 
despite complex control structure deforestation enable fuse adjacent combinators automatically 
shown set combinators built lines implement query language oql eoeciently 
approached problem opposite direction mapping oql monad comprehensions developed turn easily mapped algebraic combinators including foldr 
comprehensions pointed 
sketch suitable generalization observation section may rapidly prototype complete query language compiler 
summarizes core representation language query engine section 
semantics non strict functional language extended additional collection type constructors 
records represented tuples level 
cheap deforestation widely accepted approach deo ning query algebra set combinators may orthogonally combined rearranged facilitates algebraic optimization idea deducing streaming programs 
combinator algebras implicitly accept need temporary storage communicate results operators stream execution plans avoid allocation intermediate collections possible 
combinator compositions quite easy see get rid intermediate results 
consider simple oql query select es variables constants en tuples application vs 
abstraction foldro reduction constructors conditional op en primitives op decls local deo nitions decl variable binding query engine core representation language 
algebraic equivalent map filter es 
allocating temporary result filter pass es streaming plan scan es immediately apply objects satisfy just drop 
corresponding query engine program allocate intermediate results read foldro xs 
xs xs es having detected particular chance streaming supply plan generator rewrite rule realize transformation 
supposed deduce streaming program larger composition arbitrary algebraic operators 
set rewrite rules account possible pairs combinators combinatorial explosion subject major change cation query algebra 
regular collection consumption pattern expressed foldr comes play 
recall foldro traverses argument type ff replaces collection constructor resp 
goes 
replacement done plan generation time query execution statically get rid foldr 
cheap deforestation exactly list principle nicely adapts insertion representation collection base types see 
implement idea rst need means gain handle constructor occurences core language expression say 
achieve compile time fi abstraction constructors 

result applying foldro may readily computed plan generation time foldro 

fi note rightmost expression streaming program composition foldro constructing temporary collection uses reduce input consumption 
correctness deforestation step 
clearly depends prerequisite exclusively uses produce result need replace constructors order implement streaming correctly 
fortunately condition met algebraic combinators 
gives proof uses non hindley milner type constraint elegantly enforce correctness 
deo nition function abstracted constructors derived fi abstraction described denotes free occurences replaced 
foldro xs 
xs 
foldro ys 
ys ys allo 
foldro xs 
xs 
foldro xs 
xs oe 
foldro xs 

ys 
ys ys xs combinators abstracted constructors 
may written 
allows render 
concisely foldro foldr build cancellation transformation query deforestation relies 
fold step required 
application streaming plan problem immediate foldr combinators abstracted algebraic constructors build result build 
summarizes build forms operators derived alike combinators omitted sake brevity 
note produces result oe oe build twice fully constructors away 
implementation query deforestation inherent method single syntactic transformation applied exhaustively 
contrast extensive sets rewriting rules derived generic fold fusion rule 
rule sets imply need sophisticated rule application strategy 
additionally accompanies rules complex provisos strictness distributivity functions easily asserted checked syntactically 
number examples help reveal potentials query deforestation 
deforestation examples come back introductory query deforestation computes streaming plan es follows 
deo nitions map filter unfolded give 
foldro xs 
xs 
foldro ys 
ys ys es foldr build rule applied foldr build pair marked grey 
foldro ys 
ys ys es unfolding outer build gives desired streaming program shown foldro ys 
ys ys es consider semijoin filter 
unfolding combinators gives 
foldro xs 

zs 
zs xs xs 
foldro ys 
ys ys foldr build cancellation unfolding remaining builds results foldro ys 
zs 
zs false ys ys temporary result allocated 
plan scans evaluates semijoin condition objects satisfy objects nding join partner contribute result dropped 
eoecient plan hope provided supported index 
streaming plans queries lines 
cases deforestation happens implement known algebraic optimization heuristics rst query transformed 
adjacent selections collapsed conjunctive selection second ffi complete combinator algebra subject deforestation due uniform representation collection construction cation aggregation 
ers 
deforestation successfully fuses ers operators 
query gives foldro ys 
ys ys false equivalent deo nitions foldro ys 
ys false 
replace exists original query get allo 

rewritings developed added separate rules optimizer rule sets 
deforestation implements combinator composition allows 
aggregates 
principle naturally extends aggregates 
example aggregation fuses combinators 
unfolding query gives 
foldro 
foldro xs 
xs allocates intermediate result map equivalent foldro xs 
xs 
collection reduced int value consumption 
similar results readily obtained count min max sum count hold set see section 
conclude list examples oql query involving aggregation selection join grouping select sum sal emp dept dno group devotes develop specialized laborious transformation simpler query join involved 
query deforestation immediately comes streaming program computes sum aggregates grouping phase actual groups need allocated 
implements join grouping equivalent combinator plan query 
dno 
sal 
dept emp groups computed subsequently aggregated map sum employing higherorder nature algebra 
deforestation proceeds follows omit steps save space ss 
bag ss bag 
ds 

es 
dno sal es es emp ds 
bs 
bs bs dept deforestation map results sum adjacent ds 

es 
dno sal es es emp bag ds bag 
bs 
bs bs dept opens possibility nally merge aggregate grouping phase give resulting streaming plan aggregation join grouping completely fused ds 
es 
dno sal es es emp bag ds ds bag dept deforestation cantly extend furthermore solely list 
cheap deforestation avoids complications called fold union steps leads results faster applicable programs expressible fold fusion 
includes unsafe programs queries nested subquery traverses partial results computed outer query 
instances class programs elements aggregate queries compute running sums list reversal accessible fold promotion theorems developed fused adjacent expressions 
optimization implementation issues sake simplicity post questions correctness implementation issues 
section 
sketch alternative shortcut sense declarative query language implementation comprehensions methods may lead eoecient implementation 
observe query engine rely xed order iteration plan uses iterator access set bag due bag set left commutative persistent storage opposed lists freedom retrieve elements order 
element may encountered case course due left idempotence set 
impact deo nedness foldro left idempotent exhibit properties 
able assign meaning foldro independent iteration order multiplicity elements 
prerequisites necessary behaved 
asking needed properties undecidable query deforestation seriously theoretical point view query compiler produces behaved algebraic expressions case oql compiler discussed example foldro say may replace cing deo nedness left commutative left idempotent words deforestation rule foldro safe 
implementations query engines list 
mainly due apparent cost duplicate elimination inherent set enables engine reason sorting orders object streams 
problems ill behaved expressions occur systems deo ned 
query engines typically separate combinator enforce set semantics needed 
query engines type naturally represented setup may expressed engine core language 
query engine option delay duplicate elimination equivalence read direction arrow allows ipush duplicate elimination plan enables eoecient list processing 
rule particular cance context implementation typically involves sorting memoization disrupts fully stream execution query plans 
asymmetry join 
foldr representation join binary operators symmetric plan generator keep eye argument assign inner foldr loop iterates 
clearly assigned cheaper terms appropriate cost model inputs 
happen inputs exchanged plan generator may means rule flip join join flip ffi flip ffi comprehensions rapid prototyping 
compilation oql eoecient algebraic combinator plans complicated language easily translated monad comprehensions syntactic mapping 
mapping generalization list comprehensions known functional programming languages monadic types comprehension qn ers qi generators predicates generator qi sequentially binds variable elements range bound qi qn binding propagated predicate evaluates false 
head evaluated bindings pass function results accumulated 
notice relational calculus may understood instance monad comprehension calculus 
provide intuition oql comprehension translation refer interested reader 
give just examples queries section respectively translate es bag sal emp dept dno sum dept bag types insertion representation queries easily monad instances 
second syntactic translation scheme mc generalization similar scheme completes prototypical oql compiler 
mc uses structural recursion list ers translate comprehensions nested admittedly naive general compete algebraically optimized plan 
mc emits expressions desired foldr build form subsequent deforestation turn expressions streaming plans partly previous phases 
mc qs 
qs mc mc qs mc qs qs foldr xs 
qs xs mapping comprehensions query engine core language 
implementing foldr 
conclude section note deo nition foldr deo nitions combinators necessarily involves pattern matching collections 
foldr may terms graefe operator model foldr xs stream 
xs xs xs foldr xs linear recursion implemented foldr may easily replaced iteration nal mapping query engine typically imperative implementation language 
outlook algebraic optimization phase query language compilers reasonably understood backed formal methods hold plan generators general 
proposed query deforestation overcome deo ciency generalized types insertion representation foldr build deforestation provides formal setting derivation eoecient streaming programs algebraic combinator queries achieved program transformation techniques algebraic optimizers 
complex object algebra expressions comprehensions acceptable input deforestation process time appears simpler previous proposals 
program optimizations developed functional programming community applicable query engine core uses extended calculus representation language 
got promising results experiments employed techniques lifting static argument transformation partial evaluation 
deforestation applies tree data types may open possibilities interleave actual query execution index lookups trees eoecient manner 
provide formal access problem area tackled implementation level far 
provide proof concept implemented query compiler oql comprehensions foldr 
nal stage emits query code 
compiler currently prototypical croque object base system query code compiled dynamically linked loaded runtime provide ad hoc query facility 
compiler stages prior code generation test driven web interface url www informatik uni konstanz de cgi bin oql foldr 
beeri 
algebraic optimization object oriented languages 
proc 
rd int conference database theory icdt pages paris france december 
breazu tannen subrahmanyam 
logical computational aspects programming sets bags lists 
proc 
th th int colloquium automata languages programming pages madrid spain july 
buneman naqvi tannen wong 
principles programming complex objects collection types 
theoretical computer science 
burstall darlington 
transformation system developing recursive programs 
journal acm january 
fegaras 
efficient optimization iterative queries 
proc 
th int workshop database programming languages dbpl pages august 
fegaras maier 
effective calculus object query languages 
proc 
acm sigmod int conference management data may 
freytag goodman 
translating aggregate queries iterative programs 
proc 
th int conference large data bases vldb pages kyoto japan august 
freytag goodman 
translation relational queries iterative programs 
acm transactions database systems march 
gill 
cheap deforestation non strict functional languages 
ph dissertation department computing science university glasgow january 
scholl 
incremental updates materialized oql views 
proc 
th int conference deductive object oriented databases dood pages switzerland december 
graefe 
encapsulation parallelism volcano query processing system 
proc 
acm sigmod int conference management data pages atlantic city new jersey usa 
graefe 
query evaluation techniques large databases 
acm computing surveys 
kro ger heuer scholl 
query evaluation croque calculus algebra coincide 
proc 
th british national conference databases pages london college july 
hudak peyton jones wadler report programming language haskell 
acm sigplan notices 
launchbury sheard :10.1.1.39.5086
warm fusion deriving build recursive definitions 
proc 
acm conference functional programming computer architecture fpca la jolla california june 
dewitt 
transformation approach optimizing loops database programming languages 
proc 
acm sigmod int conference management data pages san diego california june 
poulovassilis small 
formal foundations optimising aggregation functions database programming languages 
proc 
th int workshop database programming languages dbpl estes park colorado usa 
rich rosenthal scholl 
reducing duplicate relational join unified approach 
proc 
int conference information systems management data pages delhi india october 

optimization object query languages 
ph dissertation department computer science university twente 
suciu wong 
forms recursion 
proc 
th int conference database theory icdt pages prague czech republic january 
vance 
object oriented query algebra 
technical report oregon graduate institute science technology january 
wadler 
deforestation transforming programs eliminate trees 
theoretical computer science 

