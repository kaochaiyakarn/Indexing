appear ai magazine summer fall 
commitment planning daniel weld department computer science engineering university seattle wa weld cs washington edu developments clari ed process generating partially ordered partially speci ed sequences actions execution agent goal 
summarizes progression commitment planners starting handles simple strips representation manages actions disjunctive precondition conditional ects universal quanti cation dynamic universes 
way explain chapman formulation modal truth criterion misleading np completeness result reasoning plans conditional ects apply planner 
franz tony barrett darren denise draper ernie davis oren etzioni fowler rao kambhampati craig knoblock nick kushmerick neal lesh karen lochbaum drew mcdermott ramesh patil kari pulli ying sun austin tate mike williamson helpful comments retain sole responsibility errors 
research funded part ce naval research national science foundation iri contents planning problem search world space progression regression analysis search space plans total order planning partial order planning analysis action schemata variables planning partially instantiated actions implementation details conditional ects disjunction planning conditional ects disjunctive preconditions universal quanti cation assumptions universal base ucpop algorithm confrontation example quanti cation example quanti cation dynamic universes implementation advanced topics ii achieve goals agents need act world 
surprise quest building intelligent agents forced arti cial intelligence researchers investigate algorithms generating appropriate actions timely fashion 
course problem solved considerable progress 
particular ai researchers developed complementary approaches problem generating actions planning situated action 
techniques di erent strengths weaknesses illustrate 
planning appropriate number actions executed coherent pattern achieve goal actions interact complex ways 
situated action appropriate best action easily computed current state world lookahead necessary actions interfere 
example goal attend ijcai conference chambery france advanced planning suggested 
goal attending ij cai engenders subgoals booking plane tickets getting airport changing dollars making hotel reservations nding hotel achieving goals requires executing complex set actions correct order prudent agent spend time reasoning actions proper order advance 
slightest attempting hotel reservations executing trans atlantic action lead failure night streets paris city hungry 
hand goal stay alive playing fast paced advanced planning may important 
may su ce watch dangers approach shoot threatening attackers rst 
wasting time best target decrease success time better spent shooting myriad enemy 
domain speci situated action systems implemented production systems hardwired logic combinational networks 
techniques automatically compiling reactive systems declarative domain speci cations learning algorithms automatically improving performance hot topics research 
neglect situated techniques concentrate converse approach synthesizing actions planning 
planners characterized distinguish construction strategy component size respectively 
way constructing plans process gradually adding actions constraints retraction eliminates previously added components plan transformational planners interleave re nement retraction activities 
di erent dimension concerns basic blocks planner uses synthesizing plan generative planners construct plans scratch case planners library previously synthesized plans plan fragments 
case systems motivated observation agent actions routine example making daily commute school probably executes roughly actions roughly order 
actions may interact probably doesn need think interactions executed similar actions times 
main challenge faced proponents casebased system developing similarity metrics allow cient retrieval appropriate previously executed plans memory 
faced task getting thinking dinner night ll arrive late 
reasoning action generative refinement planning generative transform 
situated action case refinement case transform 
major approaches reasoning action 
focuses generative re nement planning 
sections ll de ne planning problem precisely start describing algorithms solving problem 
restrict attention generative re nement planning algorithms adapted transformational case approaches hanks weld 
shall see planning naturally formulated search problem choice search space critical performance 
planning problem formally planning algorithm inputs 
description world formal language 
description agent goal behavior desired formal language example chef hammond spa hanks weld examples transformational case planners prodigy analogy veloso carbonell kambhampati hendler case re nement planners 
algorithms remainder generative algorithms 
simmons provides example generative transformational planner case mode 

description possible actions performed formal language 
description called domain theory 
planner output sequence actions executed world satisfying initial state description achieve goal 
note formulation planning problem 
fact really speci es class planning problems parameterized languages represent world goals actions 
example propositional logic describe ects actions preclude describing actions universally quanti ed ects 
action executing unix rm command naturally described quanti cation les current directory deleted 
describe ects actions rst order predicate calculus assumes ects deterministic 
di cult represent precise ects action ipping coin prescribing particular medication sick patient get better form probabilistic representation 
general spectrum expressive languages representing world agent goals possible actions 
task writing planning algorithm harder expressive representation languages speed resulting algorithm decreases 
ll explain build planners languages simplifying assumptions 
atomic time execution action indivisible need consider state world execution proceeding 
may model execution atomic transformation world state 
simultaneously executed actions impossible 
deterministic ects ect executing action deterministic function action state world action executed 
omniscience agent complete knowledge initial state world nature actions 
sole cause change way world changes agent actions 
agents world static default 
note assumption means rst input planner world description need specify initial state world 
admittedly assumptions unrealistic 
simplify problem point describe simple algorithms 
alternatively skip ahead section advanced topics describe extensions algorithms relax assumptions 
ll start discussion planning simple language propositional strips representation 
propositional strips representation describes initial state world complete set ground literals 
example simple world consisting table blocks shown left side described true literals initial goal states sussman anomaly problem blocks world 
table table clear clear require initial state description complete atomic formulae explicitly listed description assumed false called closed world assumption reiter 
means clear implicitly initial state description bunch negative literals 
strips representation restricted goals attainment 
general planner accept arbitrary description behavior desired agent time 
example specify robot cook breakfast leave house 
planning research considered goal descriptions specify features hold world distinguished time point plan executed renders remain house goal inexpressible 
furthermore strips representation restricts type goal states may speci ed matching conjunction positive literals 
example goal situation shown right hand side described conjunction literals 
yields simple block stacking challenge called sussman anomaly 
acronym strips stands stanford research institute problem solver famous uential planner built control unstable mobile robot known shakey fikes nilsson 
name bit puzzling problem discovered mit allen brown noticed hacker problem solver problems dealing domain theory denoted greek letter forms third part planning problem formal description actions available agent 
strips representation actions represented preconditions ects 
precondition action follows restriction problem goal conjunction positive literals 
action ect hand conjunction may include positive negative literals 
example de ne action move table follows precondition clear ect table clear actions may executed precondition true case ed robot may table top atop 
action executed changes world description way 
positive literals ect conjunction called action add list added state description negative literals called action delete list removed 
example executing move table initial state described leads state table table table clear clear clear true atomic formulae false 
concludes description planner inputs description initial state description goal domain theory set action descriptions 
called inputs planner return sequence actions achieve goal executed initial state 
example problem de ned sussman 
hacker core gerald sussman ph thesis got stuck name 
subsequent years numerous researchers searched elegant ways handle 
tate system tate sophisticated reasoning goal interactions nd optimal solution sacerdoti noah planner sacerdoti exible representation sidestep problem 
planners described adopt techniques problem anomalous situation 
worth explaining problem early researchers 
note problem subgoals achieve achieve 
natural try divide conquer try achieve rst subgoal starting second obvious solution put table put accidentally wind table 
course get trying solve rst subgoal rst appears mistake 
try achieve rst problem buried bottom stack 
matter order tried subgoals interfere 
humans divide conquer computers 
fact show section plan space search 
illegal action ect include atomic negation lead unde ned result 
anomaly initial goal states set actions described planner return sequence move table move table move table shall see variety algorithms exactly cient 
ll start looking planners conceptually quite simple look sophisticated ways planning 
search world space simplest way build planner cast planning problem search space world states shown 
node graph denotes state world arcs connect worlds reached executing single action 
general arcs directed encoding blocks world actions reversible directed edges single arc increase readability 
note initial goal world states sussman anomaly highlighted grey 
phrased manner solution planning problem plan path state space 
note step solution listed previous section shortest path states paths possible 
advantage casting planning simple search problem immediate applicability familiar brute force heuristic search algorithms korf 
example depth rst breadth rst iterative deepening search starting initial state goal located 
alternatively sophisticated memory bounded algorithms russell korf 
tradeo di erent searching algorithms discussed extensively focus structure search space 
handy way specify planner nondeterministic algorithm 
idea may strange rst ll extensively subsequent sections important learn 
fact quite simple specifying planning algorithm uses nondeterministic choose primitive 
choose takes set possible options magically selects right 
beauty nondeterministic primitive lies ease implementation choose simulated conservative search method approximated aggressive search strategy 
decoupling search strategy basic nondeterministic algorithm things accomplished algorithm simpler easier understand imple world space 
mentor easily switch di erent search strategies ort improve performance 
progression concrete contains simple nondeterministic planner operates searching forward initial world state nds state goal speci cation satis ed 
right think nondeterministic algorithm personally calling shots time choose gets called 
example try sussman anomaly rst call procedure world state set initial state leftmost grey state goal list set implicit conjunction path set null sequence 
initial state doesn satisfy goal execution falls line choose called 
moment thought convince best choice move table rst action assume choice computer 
giving program magical oracle easily nd sequence correct choices lead solution 
assume oracle best choice program quit con dent solution possible runs dead 
course wants implement computers exist today doesn want get lot email program asking advice 
needs search 
simple algorithm world state goal list path 
world state satis es conjunct goal list 
return path 
act choose action precondition satis ed world state choice possible return failure result simulating execution act world state return goal list concatenate path act 
progressive world state planner 
set path null sequence 
initial call technique implement choose breadth rst search 
way wouldn oracle planner try paths parallel storing queue time slicing state satis ed goal speci cation 
time nondeterministic algorithm nd solution breadth rst search version worst case take searching version exponentially longer 
regression describes just way planning search space world states 
approach called regression planning waldinger outlined 
searching forward initial state algorithm adapted nilsson searches backwards goal 
intuitively reasons follows want eat need cook dinner need food need buy food need go store step chooses action possibly help satisfy outstanding goal conjuncts 
illustrate concrete example sussman anomaly cur goals initially set list conjuncts 
rst call choose demands action ect contains conjunct appears cur goals 
action move table ect achieving assume planner magically nondeterministically choice 
step called goal regression forms core algorithm assigned result regressing logical sentence conjunction corresponding list cur goals action act 
result algorithm init state cur goals path 
init state conjunct cur goals 
return path 
act choose action ect matches conjunct cur goals 
result regressing cur goals act 
choice act possible unde ned return failure cur goals return init state concatenate act path 
regressive world state planner 
initial call set path null sequence 
regression logical sentence encodes weakest preconditions true act executed order assure cur goals true act executed 
simply union act preconditions current goals provided ects act preconditions act cur goals goals added act example act table precondition table ect result regressing table 
act achieved regression removed literal sentence replacing precondition act table 
act doesn ect goal remains part weakest precondition 
note sentence produced regression conjunction true long action preconditions restricted conjunctions ok encode cur goals lists 
line interesting says choose nd action regression satis es certain criteria dead reached 
parts dead check discuss turn 
action ect containing conjunct matches conjuncts cur goals action pro table 
see case note act matching conjunct result performing goal regression strictly larger conjunctive sentence 
satis ed initial state cur goals 
point considering successful plan result improved eliminating path 

result regressing cur goals act unde ned plan adds act point path fail 
unde ned 
recall regression returns weakest preconditions true act executed order cur goals true execution 
act ects directly con icts cur goals 
weakest precondition unde ned matter true act execution ruin things 
example results tries regress move table 
action negates weakest preconditions unde ned 

cur goals really point adding act path reasons explained bullet 
fact show cur goals action ect doesn cur goals converse false 
strictly speaking cur goals renders test bullet unnecessary eliminating result reduced ciency regressions required 
analysis presentation planning algorithms suggests natural questions 
rst questions concern soundness ifa plan returned really 
completeness plan exists sequence nondeterministic choices exist nd 
algorithms 
won prove algorithms sound complete 
important question algorithm faster 
nondeterministic forms course complexity perfect luck ll number say nondeterministic choices nding solution 
real implementation search implement nondeterminism important question choices considered nondeterministic branch point 
call number small di erence lead tremendous di erence planning ciency brute force searching time 
plausible assumption goal planning problem involve small fraction literals describe state planning smaller branching factor call choose result run faster 
see note probably actions executed initial state relevant goal ects match goal legal regressions 
consider actions preconditions satis ed initial state bene guidance provided planning objective 
cases course situation may reversed 
note variety search techniques means ends analysis bidirectional search haven discussed 
reason selective portrayal stems nature world space search 
section shows better search space partially speci ed plans 
search space plans earl sacerdoti built planner called noah novel features 
innovation ll focus reformulation planning search problem 
searching space world states arcs denote action execution sacerdoti phrased planning search plan space 
space nodes represent partially speci ed plans edges denote plan re nement operations addition action plan 
illustrates space 
initial goal state highlighted grey 
initial state represents null plan actions goal state represents complete working plan sussman anomaly 
note world state planners return path initial goal states plan space goal state solution 
total order planning point forced confess 
claimed useful think planning search plan space explained plan space nodes denote plans haven said plans really 
fact subtle issue shall discuss depth consider simple answer suppose plan represented totally ordered sequence actions 
case view familiar algorithm isomorphic plan space planner 
recursive call passes argument path totally ordered means ends analysis problem solving strategy gps newell simon especially important historical perspective ubiquity machine learning research speedup learning minton minton 
unfortunately gps planners incomplete example solve sussman anomaly complicates analysis comparison algorithms 
needed investigate bene ts approach 
fact noah didn search space exhaustive manner nonlin tate backtracking credited reformulating space question 
move move move move table move move move table move plan space sequence actions plan 
fact watch successive values path recursive call get picture shown 
summary nature space searched algorithm somewhat eye 
view searching space world states regression planner 
view searching space totally ordered plans plan re nement operators modify current plan prepending new actions sequence 
point thinking planning search process plan space 
framework facilitates thinking alternative plan operators leads powerful planning algorithms 
example adding new actions plan arbitrary locations devise planner works better restricted prepending actions 
won describe algorithm possible better changing plan representation described section 
partial order planning think moment solve planning problem 
concreteness return introductory example planning trans atlantic trip ijcai 
trip needs purchase plane tickets buy go guide france enable choosing hotels itinerary 
need decide purchase executed rst 
idea commitment planning represent plans exible way enables deferring decisions 
committing prematurely complete totally ordered sequence actions plans represented partially ordered sequence planning algorithm practices commitment essential ordering decisions recorded 
plans causal links threats represent plan tuple ha li set actions set ordering constraints set causal links described 
example fa bethe set fa 
constraints specify plan necessarily actions commit choice actions comes rst 
note ordering constraints consistent exists total order satis es 
commitment planners re ne plans constraint satisfaction ensure consistency maintaining consistency partially ordered set actions just simple example constraint satisfaction planning ll see subsequent sections 
akey aspect commitment track past decisions reasons decisions 
example purchase plane tickets satisfy goal boarding plane sure take airport 
goal having hands free open taxi door say causes drop tickets sure pick 
way ensuring di erent actions introduced di erent goals won interfere record dependencies actions explicitly 
record dependencies data structure called causal link invented austin tate nonlin planner tate 
causal link structure elds contain pointers plan actions link producer ap consumer ac third eld proposition ect ap precondition ac causal link ap ac store plan links set causal links detect newly introduced action interferes past 
call action threat 
precisely suppose ha li plan ap ac causal link di erent action threatens ap ac criteria satis ed fa consistent ect 
example asserts precondition plan contains ap ac considered threat moved ordering constraints didn prevent executed ap ac 
plan contains threat danger plan won anticipated 
prevent happening planning algorithm alternative approach repeatedly compute interactions cient 
check threats take evasive countermeasures 
example algorithm add additional ordering constraint ensure executed ap 
particular threat protection method called demotion adding symmetric constraint ac atis called promotion 
ll see subsequent sections ways protect threats 
representing planning problems null plans uniformity key simplicity 
turns simplest way describe plan space planning algorithm uniform representation planning problems incomplete plans 
secret achieving uniformity encoding trick initial state description goal conjunct bundled special tuple called null plan 
encoding simple 
null plan planning problem actions fa ordering constraint fa causal links fg 
planning activity stems actions 
start action preconditions ect speci es propositions true planning problem initial state false 
action ects precondition set conjunction goal planning problem 
example null plan corresponding sussman anomaly shown 
start clear clear table table null plan sussman anomaly contains actions start action precedes action 
rationale names stems fact demotion moves threat lower temporal ordering promotion moves higher 
adopt convention proposition explicitly speci ed true initial state assumed false 
called closed world assumption cwa 
pop algorithm simple regressive algorithm searches space plans 
pop starts null plan planning problem nondeterministic choices conjuncts action precondition supported causal links threatened links protected possible interference 
ordering constraints nal plan may specify partial order case total order consistent guaranteed action sequence solves planning problem 
see rst argument plan structure second agenda goals need supported links 
item agenda represented pair hq aii conjunct precondition ai 
note times identity clear context pretend agenda contains propositions hq aii pairs 
important understand algorithm works detail behavior sussman anomaly 
making initial call pop arguments null plan shown agenda fh ig 
agenda isn empty control passes line 
choices immediate goal pop 
comes crucial subtle point 
pop choose subgoals written choose 
answer choice matter far completeness concerned eventually choices 
result reason searching version program backtrack choice 
mean choice doesn matter 
absolutely 
choice lead planner nd answer quickly choice lead search 
practice choice important ciency useful interleave reasoning di erent subgoals 
order subgoals considered planner ect completeness important nondeterministic algorithm number nondeterministic choices way 
anyway suppose pop selects agenda goal rst set 
line needs choose real pop planner similar mcallester snlp algorithm mcallester rosenblitt improved formalization chapman tweak planner chapman 
di erence snlp pop concerns de nition threat 
snlp treats threat link ap ac ect ect 
may counterintuitive matter asserted twice de nition leads property called systematicity reduces size search space 
widely believed systematicity technical point view necessarily lead increased planning speed 
see kambhampati discussion 
algorithm pop ha li agenda 
termination agenda empty return ha li 

goal selection hq pair agenda de nition aand conjunct precondition 

action selection choose action adds newly instantiated action action consistently ordered prior 
action exists return failure 

newly instantiated fa 

update goal set agenda agenda 
newly instantiated conjunct precondition add hq addi agenda 
causal link protection action threaten causal link ap ac choose consistent ordering constraint demotion add pto promotion add constraint consistent return failure 

recursive invocation pop ha agenda 
pop regressive partial order planner 
initial call set ha li null plan problem set agenda list goal conjuncts 
choice time 
action ect 
suppose magic oracle suggests making new instance move table action 
new causal link added agenda updated 
threats sole link line recursive call arguments depicted 
second invocation pop agenda empty goal chosen 
suppose clear conjunct added move table action precondition selected line 
line choose called nondeterministic choice producing action 
suppose instantiating new action illustrated time planner decides reuse existing start action 
net ect pass pop add single link illustrated shrink agenda slightly 
suppose third invocation pop planner selects top start clear clear table table clear clear table move table clear table table clear adding causal link support plan shown agenda contains clear clear table open propositions 
start clear clear table table clear clear table move table clear table table clear adding causal link support clear plan causal links agenda set clear table level goal agenda 
possibilities exist nondeterministic choice line 
suppose pop decides instantiate new move table action add 
new causal link gets added new action constrained precede agenda updated 
things get bit interesting control ow reaches line 
note new actions move table move table constrained precede contains constraints relative ordering 
furthermore note move table negates clear 
means threatens link labeled clear 
illustrated 
protect threat pop nondeterministically choose ordering constraint 
general possibilities constrain move action move action constrain move precede start action 
line assures action follows choice inconsistent 
pop orders threat link consumer shown 
start clear clear table table clear clear table move table clear table table clear clear clear table move table clear table table clear move action possibly precede move action threatens link labeled clear indicated dashed line 
agenda contains entries left done 
subsequent decisions follow lines reasoning 
eventually pop returns plan shown 
careful inspection gure con rms link threatened 
actions dummies exactly ones returned world state planners previous section 
planners prove pop sound complete 
implementation details implement pop choose data structures represent partial order actions 
operations data structure needs support addition new constraints testing consistent determining ai consistently ordered prior aj returning set actions ordered aj 
fact set interface operations reduced ability add delete ai test consistency won necessarily lead greatest ciency queries typically performed threat detection discussed paragraph true updates 
caching results queries incrementally computing transitive closure signi cantly increase performance 
denotes number actions plan takes time compute transitive closure space store queries answered quickly see floyd warshall algorithm discussion cormen 
considerable research focussed time space tradeo variants assume di erent interface temporal manager see williamson hanks start clear clear table table clear clear table move table clear table table clear clear clear table move table clear table table clear promoting threatening action plan actions totally ordered 
nice discussion pointers 
implementation detail concerns testing threatened causal links 
links threats 
cient handle threats incrementally new causal link added actions tested see threaten 
takes time 
new action instance added links tested see threatened 
takes time 
analysis general expected performance search algorithm cb 
parameters determine performance explained 
times nondeterministic choose called solution obtained 
determines exponent 
possibilities need considered searching algorithm call choose 
determines average branching factor 
long take process node search space processing goes recursive call 
written constant usually function size node considered 
start clear clear table table clear move table table clear clear clear table move table clear table table clear clear clear table move table clear table table clear eventually plan returned solution cost node search space quite di erent pop doesn matter practice 
world state planner node operations implemented time proportional number current goals cur number complexity actions 
pop hand operations testing threatened links example complexity grows length plan consideration 
say factors don matter exponential dominates costs 
number nondeterministic calls vary somewhat 
particular call action introduced pop precondition conjunct links threatened 
ignoring issue threatened links pop higher action supports precondition conjunct case 
example start action supports conjuncts 
hand ratio pop greater maximum number precondition conjuncts action typically small constant blocks world 
case value certainly doesn suggest pop run faster 
pop usually run faster reason 
pop achieves completeness smaller branching factor world space algorithms 
call choose line pop consider actions ects relevant particular goal chosen line 
recall choice require backtracking 
situation quite di erent 
line nondeterministic choice consider actions ects relevant member cur goals 
words backtrack choice goal failure consider possibilities sacri ce completeness 
reason stems fact links decision goal decision execute resulting actions 
commitment approach set ordering constraints pop achieves branching factor smaller factor equal average size cur goals agenda grow quite big 
increased branching factor usually dominant ect 
factors involved detailed analysis complex 
see barrett weld barrett weld minton minton di erent types analytic comparisons experimental treatments 
important note pop algorithm represents just point spectrum possible commitment planning algorithms 
brevity precludes discussion interesting see kambhampati kambhampati survey approaches fascinating taxonomy design tradeo action schemata variables idea commitment proven useful natural wonder take 
possible useful 
describe step wish highlight relationship commitment constraint satisfaction 
note key step allowing pop delay decisions individual actions scheduled inclusion set ordering constraints attendant constraint satisfaction algorithms determining consistency 
turns perform trick choosing action support open condition delay decision adding constraints gradually re ning 
take look back pop just created rst causal link new move table action support goal choice get 
line pop selected existing new actions ect 
possibilities 
move action worked 
blocks mentioned problem pop consider moving 
absurd 
point planning process pop worry going 
better delay commitment choices may easily ruled 
accomplish pop add action move denotes variable value chosen 
fact go way de ne general move schema de nes class actions move arbitrary block arbitrary prior location ll call action schema operator 
choosing instantiate operator specify subsequent decisions add constraints value eventually unique value 
key question types constraints allowed 
simplest answer allow codesignation constraints write respectively 
ideas concrete see de nition de nes move operator general 
define operator move parameters precondition clear clear table effect clear clear variables codesignation constraints allow speci cation general action schemata 
planning partially instantiated actions fairly clear operator economical description fully speci ed move actions replaces number blocks world 
addition description enormous software engineering bene ts needless duplication lead inconsistent domain de nitions error copy replaced copies mistakenly left unchanged 
representation thing planning 
pop planning algorithm modi ed order handle partially instantiated actions resulting general operators 
explain changes 
elaborate approach incorporate ideas programming language type systems 
de nition move restricted block moved table 
necessary action ects di erent destination table 
speci cally normal de nition block world assumes table clear blocks block top 
moving block negate clear happen table 
possible write fully general move operator requires expressive action language allows conditional ects described presently 
data structure representing plans include slot set variable binding codesignation constraints 
plan ha bi problem null plan fg 
need way perform uni cation 
mgu function returns general literals respect codesignation constraints returned uni er exists 
form general uni er taken set pairs indicating ensure unify 
allows treat codesignation constraints conjunction general uni ers general may contain constraints mgu generate 
mgu mgu shorthand write mgu explicitly specifying empty set bindings 
furthermore assume redundantly negated literals treated obvious way 
uni es logical sentence notation nb denotes sentence resulting substituting ground values variables possible codesignation constraints returned uni cation 
line pop action selection choice consider existing actions new actions instantiated operator ect conjuncts goal plan codesignation constraints mgu 
example null plan sussman anomaly supposing planner nondeterministically choose set new instance move operator ect conjunct uni es 
line new causal link added plan binding constraints added force producer ect supply condition required consuming action 
continuing sussman anomaly example constraints cg added line new action instance created operator planner ensure variables refered action named binding 
previously plan 
example sussman anomaly example second move action instantiated support goal action reuse variable names example new action instance refer 
line update goal set pop removes agenda adds preconditions newly instantiated 
operators include precondition conjuncts specify constraints need treated specially added agenda 
adding preconditions agenda logical preconditions clear added 
line causal link protection pop considers action threaten causal link ap ac land promotes 
actions variables meaning threaten subject interpretation 
supposing clear ect threaten link labeled clear 
contains constraint form planner eventually add codesignation threat undeniable 
best wait uni cation forced unify substitution returned 
point need planner decide adding ac nal change necessary 
line pop returns plan agenda empty extra test required 
return plan variables constrained unique constant value 
necessary ensure threatened links recognized see previous bullet 
fortunately get test free requiring initial state contain variables variables mentioned ects operator included preconditions operator 
restrictions legal operator syntax binding constraints added line guaranteed result unique values 
implementation details implement generalized pop algorithm described choose data structures representing binding constraints nec point rst suggested steel subtle possibilities explored 
explained peot smith kambhampati approach advantage simplicity ciency 
essary operations include addition constraints testing consistency uni cation substitution ground values 
note familiar algorithms uni cation inadequate tasks accept constraints require constraints 
remainder section describes way implement functions 
casual readers wish skip discussion jump directly section conditional ects disjunction 
implementation represents list varset structures 
varset elds const cd set ncd set 
const eld empty represents unique constant 
cd set eld list variables constrained ncd set list variables constants constrained variables cd set constant 
add constraint form rst searches nd rst distinct const elds set constraint inconsistent 
new empty varset created const eld copied whichever set 
cd sets unioned assigned new structure likewise ncd sets 
member resulting ncd set resulting cd set operation inconsistent 
new varset pushed list 
adding constraint constant done way 
add constraint form rst searches nd set varset fail copy augmenting ncd sets push new copies routines may ine cient note remove old numerous copies perform practice enable planner explore plans parallel arbitrary search technique reasonable space ciency structures shared plans 
restricts planner depth rst search cient codesignation algorithm removes constraints backtracking possible 
ciency issue concerns creation new variable names instantiating new actions operators 
simple caching scheme eliminate unnecessary copying provide substantial speedup 
conditional ects disjunction annoying aspect move operator restriction destination location table 
means describe idea observation sibling plans explore di erent re nements parent reuse action instances 
possible movement actions necessary augment move additional operator move table describes actions move blocks arbitrary place table 
irritating software engineering ciency reasons concentrate 
note existence separate movement operators means planner commit line destination table block adding action achieve goal destination 
example move added support open condition clear planner prematurely commit destination block top violation principle commitment causes reduced planning ciency 
previously alluded fact relax annoying restriction action language allowed conditional ects 
conditional ects useful represent important step journey increasingly expressive action representation languages described 
basic idea simple allow special clause syntax action ects 
takes arguments consequent 
consequent parts lled single literal conjunction literals interpretation di erent 
part refers world action executed consequent refers world execution 
interpretation execution action consequent ect just case true immediately execution action precondition determines execution legal 
illustrates conditional ects allow general de nition move 
define operator move parameters precondition clear clear effect clear table clear conditional ects allow move operator source destination locations table 
compare 
planning conditional ects historically planning actions conditional ects thought inherently expensive problematic air see 
may come conditional ects demand small modi cations planning algorithm earlier 
recall line action selection algorithm selects new existing action ect uni es goal consequent conditional ect uni es may support causal link 
case line update goal set add conditional ect agenda 
conditional ects line causal link protection nondeterministic choice adding demotion adding ac promotion 
threatening ect conditional alternative threat resolution technique called confrontation possible add negation conditional ect agenda 
example confrontation see section 
note confrontation introduces negated goals previously discussed 
part negated goals just positive goals supported action action ect matches 
di erence concerns initial state 
convenient toavoid specifying facts initially false special machinery necessary implement closed world assumption 
disjunctive preconditions handy allow actions conditional ects contain disjunctive preconditions 
disjunctive preconditions quickly cause search space explode useful moderation 
planning simple 
line goal selection selecting agenda extra test added 
removed agenda nondeterministic call choose selects 
whichever disjunct selected added back agenda 
note allowing preconditions disjunctive ects 
previous section described conditional ects confused ects allow logical implication 

particular 
conditional ect refers state world action executed consequent speci es change world 
easy extend planner handle disjunctive preconditions disjunctive ects harder 
disjunctive ects sense describing action nondeterministic random ects 
example action ipping coin described landmark planning conjunctive goals chapman clari ed topic commitment planning readers contained number results misleading 
chapman central contribution modal truth criterion mtc formal speci cation simple version nonlin question answering algorithm tate 
mtc lists necessary su cient conditions ensuring condition true speci point time partially ordered set partially speci ed actions 
chapman observed mtc plan veri cation plan generation demonstrate implemented sound complete planner called tweak 
chapman proved evaluating mtc np hard actions contain conditional ects 
tweak evaluated mtc repeatedly innermost loop chapman researchers speculated commitment planning scale expressive action languages allowing conditional ects 
fortunately chapman pessimism ungrounded 
aw arguments stem di erence determining condition true ensuring true planner need 
example modi ed pop algorithm adds actions ects su cient goal conditions true ect necessary concern long planner nondeterministically considers alternative 
planner ask condition true plan adds actions posts su cient constraints true 
constraints posted planner ensure constraints satis ed terminate successfully 
combination causal links threat detection algorithm renders check inexpensive plan basis increase number plans visited nondeterministic choice promote demote confront 
words modi ed pop algorithm pushes complexity mtc size search space 
depth discussion aspects chapman results see kambhampati nau information commitment planning conditional ects see pednault collins pryor penberthy weld 
modal truth criterion conditional ects disjunctive ect heads tails 
planning actions ects partially known tricky don time describe simple 
see warren schoppers kaelbling gini peot smith etzioni kushmerick 
universal quanti cation ready take major step expressive actions 
allowing universal quanti cation preconditions allows easily describe real world actions unix rmdir command deletes directory les inside deleted 
universally quanti ed ects allow describe actions chmod set protection les directory 
naturally universal quanti cation equally useful describing physical domains 
universally quanti ed preconditions avoid need special clear predicate attendant need user specify action ects clearness objects 
provide move precondition says picked blocks aren universally quanti ed conditional ects allow speci cation objects moving briefcase causes objects inside move aswell 
example see 
define operator move parameters precondition briefcase effect forall object moving briefcase causes objects inside briefcase move 
describing requires universally quanti ed conditional ects 
forall quanti es type object 
assumptions implement planner ucpop handles universally quanti ed preconditions ects ll simplifying assumptions 
speci cally assume world modeled nite static universe objects 
furthermore assume object type 
object universe initial state description include unary atomic sentence declaring type 
example initial description include sentences form block briefcase block briefcase types 
assumption universe static means action ects may assert type information 
action allowed assert briefcase amount destruction object 
similarly execution ect said block create new block 
don allow types ects 
assumptions relaxed scope 
ne object multiple types stated explicitly 
example initial state specify briefcase object allow general facility stating objects 
universal base assure systematic establishment goals subgoals universally quanti ed clauses ucpop maps formulae corresponding ground version 
universal base rst order function free sentence de ned recursively follows contains quanti ers correspond possible interpretation universe discourse fc cng possible objects type genesereth nilsson 
replaced constant example suppose universe book crime 
forall book universal base conjunction moby crime dict static universe assumption goal satis ed universally quanti ed goal satis ed 
call universal base universally quanti ed variables replaced constants 
handle interleaved universal existential quanti ers need extend de nition follows 
correspond possible interpretation universe discourse type fc cng 
replaced constant ci 
addition replaced skolem constants yi 
existential quanti ers eliminated remaining free variables act skolem constants implicitly existentially quanti ed 
careful generate skolem constant possible assignment values universally quanti ed variables enclosing scope need generate reason skolem functions 
words enumerate set ff cn member universe generate appropriate set clauses substitution renaming 
type universe assumed nite universal base guaranteed nite 
examples illustrate handling existential quanti cation 
note de nition relies fact type nite universe result skolem constants generated 
leading universally quanti ed variables type skolem constants yi necessary 
exists briefcase forall book universal base briefcase moby crime dict nal example suppose universe briefcase fb forall briefcase exists book universal base contains skolem constants book book skolem constants exhaust range skolem function domain universe 
nite static universe assumption expansion creating universal base 
ucpop algorithm ucpop planning algorithm pop modi ed allow action schemata variables conditional ects disjunctive preconditions universal quanti cation 
previous sections discussed modi cations required language enhancements universal base de ned easy explain 
helps de ne utility functions goal precondition universally quanti ed sentence ucpop computes universal base plans achieve 
ect involves universal quanti cation ucpop immediately compute universal base 
universal base generated incrementally ect support causal links 
need change de nition threaten account universally quanti ed ects 
ap ac causal link 
exists step satisfying conditions threat ap ac 
free implicitly existentially quanti ed 
course briefcase equivalent books 
case specify implicit disjunction 
result legal goal ucpop allow action ect reasons described section 

ap acis consistent 
ect conjunct conditional ect consequent conjunct 
mgu equal 
pairs mgu member ect universally quanti ed variables 
words action considered threat uni cation returns bindings ect universally quanti ed variables 
previously mentioned wanted consider action threat necessarily forced codesignation 
ordinary commitment variables happens mgu returns empty set 
universally quanti ed ects situation di erent 
example consider unix chmod action ect les write protected 
action necessarily threatens link labeled writable foo tex mgu returns binding foo tex ect universally quanti ed variable put way chmod action threat writable foo tex member universal base ect 
universally quanti ed ects replaced universal base operator instantiation time mgu return bindings universally quanti ed variables wouldn 
substitution eliminate need bullet special treatment universal variables de nition threats ine cient 
universally quanti ed ects expanded universal base incrementally de nition threat altered 
summarizes algorithm 
shall prove see penberthy weld ucpop sound complete action representation assumptions xed static universe 
confrontation example see concrete example ucpop action recall move operator de ned transports briefcase location contents 
remember previous de nition move lets agent directly move briefcase objects moved indirectly 
suppose de ne operator removes item briefcase shown 
note take doesn change location remain location briefcase moved 
algorithm ucpop ha bi agenda 
termination agenda empty return ha bi 

goal reduction remove goal ac agenda 
ac quanti ed sentence post universal base agenda 
goto 
conjunction qi post qi ac agenda 
go 
disjunction qi nondeterministically choose disjunct qk post qk ac agenda 
goto 
literal link ap ac exists fail impossible plan 

operator selection nondeterministically choose existing new instantiated action ect conjunct cis consistent note consequent conjunct ect conditional uni es choice exists fail 
fap acg mgu universally quanti ed variables ect fap acg 
enable new actions ects agenda agenda 
add add preconds agenda add fa gto add non cd constraints ect conditional establish link add substituting mgu 

causal link protection causal link ai aj action threatens nondeterministically choose choice exists fail promotion consistent fa tg 
demotion consistent fat aig 
confrontation threatening ect conditional consequent add agenda 
recursive invocation inconsistent fail call ucpop ha agenda 
ucpop partial order planning algorithm define operator take parameters precondition effect action removes item briefcase 
suppose just briefcase home inside codi ed initial conditions briefcase home home 
furthermore suppose home want briefcase words goal office home 
call ucpop null plan agenda containing pair office home move take operators 
agenda nonempty goal removed agenda recognized conjunction reduced literals put back agenda line 
line executed goal home removed agenda literal control proceeds line operator selection 
ways support goal creating new instance move action linking initial conditions existing step 
suppose ucpop correct nondeterministic choice links initial state 
link isn threatened ucpop calls recursively plan shown gure 
start briefcase home home office home subgoal easy support ucpop removes goal office agenda line shifts control line algorithm 
ways achieve goal existing steps ects matching goal options involve instantiating new move step 
obvious way achieve goal move directly ce method move di erent briefcase subgoal getting inside recall refer agenda contains just logical halves contains entry office pairs 
example agenda home tagged step 
case idea step logical sentence precondition 
briefcase 
isn briefcase second approach result backtracking suppose ucpop correct nondeterministic choice updates set actions links bindings appropriately 
move action newly added precondition briefcase added goal agenda 
point threatened links ucpop calls recursively plan shown gure 
note ects move shown gray black signi es conditional 
furthermore note variable surrounded circle denote universally quanti ed 
start briefcase home home briefcase move office office office office home new move step supports second goal threatening rst link 
conjunctive goal briefcase gets reduced component literals get chosen turn 
cases possible link initial state way illustrated 
ucpop uses initial condition home support move precondition forced add home plan set codesignation constraints 
change causes move threaten link labeled home signi ed dashed line gure 
previously link wasn move mgu home uni ed complex uni er home second binding pair contains universally quanti ed variable rst pair de nition threat 
extended constrain value home general uni er consists solely 
threat real gure shows 
protect threat line algorithm ucpop choose nondeterministically techniques promotion demotion confrontation 
current situation promotion demotion impossible move come start action action 
fortunately threatening ect con start briefcase home home briefcase home move home office office home office home office home codesignation constraints bind home move step threatens existing link 
ditional confrontation viable technique 
intuitively sense 
move step ects location ucpop posts negation new subgoal move agenda 
note uni cation universally quanti ed variables ignored threat detection constraints crucially important posting new subgoal ucpop need ensure briefcase just remove 
result subgoal generated confrontation speci illustrated gure 
start briefcase home home briefcase home move home office office home office home office home confronting threat satisfying new requires instantiating adding take step adds subgoal agenda 
goal easily satis ed initial conditions ucpop quickly returns plan shown gure solution planning problem 
start briefcase home home take briefcase home move home office office home office home office home final plan 
quanti cation example example previous section illustrated ucpop basic operation confrontation protect threatened links demonstrate planner capability handle universally quanti ed goals 
link universally quanti ed ect demonstrate incremental expansion universal base 
demonstrate features consider primitive operator problem 
new action schema allows add items briefcase 
define operator put parameters precondition briefcase effect briefcase put things 
note put requires briefcase location disallows putting briefcase inside 
suppose initial conditions specify facts true false object object briefcase home office goal request object home forall object home null plan corresponding problem shown 
start object object briefcase home office forall object home dummy plan representing problem 
note explicitly listed false relevant example 
fact closed world assumption states propositions explicitly listed true presumed false 
ucpop rst called line immediately recognizes sole agenda entry forall object home quanti ed sentence expands universal base 
control shifts back line agenda containing home home 
iteration line splits conjunction component parts jumps back line 
point agenda contains entries home home tagged 
iteration suppose home time line cases satis ed control proceeds line 
suppose ucpop instantiate new instance move support goal 
links bindings orderings updated line new action added preconditions stu ed agenda 
recursive call occurs line updated plan shown 
start object object briefcase home office briefcase move home home home home home supporting rst conjunct iteration suppose home 
literal control goes line 
suppose ucpop wisely nondeterministically chooses support goal existing move action 
particular decides universally quanti ed conditional ect object briefcase get moved briefcase 
time incrementally expand ect universal base 
key step line ucpop adds new goal instantiated conditional ect agenda 
resulting plan shown 
note home instantiated ects move don get explicitly added data structures 
point long quanti ed version 
catch phrase incrementally generating universal base ects misleading 
prefer think generated ne 
start object object briefcase home office briefcase move home home home home 
home home incrementally expanding part universal base universally quanti ed ect covered interesting stu ll fast forward 
quanti cation dynamic universes far discussion universal quanti cation assumed universe discourse type nite static known agent 
section explain handle dynamic universes domains action ects create new objects delete existing ones 
independent questions address turn object creation destruction represented syntactically action language nite universes discourse situations agent incomplete information handled considerably di cult 
see golden information 
start object object briefcase home office briefcase home move home office office home office home briefcase office office put object briefcase office move office home home office home office home 
home home final plan planner handle universally quanti ed goals face possible ects 
model action destroys object ect negates object type predicate 
example dict type book destroying dictionary represented ect asserting book dict 
similarly action creates new book need ect asserts book newly generated symbol 
extending ucpop handle object destruction straightforward 
example suppose universe book forall book 
recall universe books static ucpop generates moby dict universal base 
account potential destruction ucpop simply generate slightly elaborate universal base moby book moby dict book dict long new books created goal satis ed exactly quanti ed expression satis ed 
note expression reduces im simpler destructive actions way toachieve book subgoals 
somewhat trickier handle actions create new objects 
object creation ucpop determine universe discourse type matching book ects initial state 
example ucpop determines moby dict possible books 
arbitrary actions create objects type book expanding universal base precondition action ac ucpop consider books possibly created actions possibly ordered prior ac 

subsequent problem solving add new actions plan actions ordered prior ac ucpop maintain list previously expanded forall goals 
new action added checked list forall goals new action creates object type previously expanded forall goal reconsidered universal base incrementally updated 
gets tricky goal expression involves nested universal existential quanti ers incremental expansion create appropriate number new skolem constants 
implementation common lisp source code ucpop planner available ftp 
code simple classroom quite cient takes ms explore re ne partial plan sparc ipx 
addition features described section ucpop version provides enhancements declarative speci cation control rules guide nondeterministic search 
graphic plan space browser written clim portability 
domain axioms predicates call lisp code action preconditions useful domain theory involves arithmetic strategy handles standard logical interpretation quanti ed expression technique raises question wants planner plotting book burning strategies 
claim issue plan quality harmful side ects best treated separately crops situations universally quanti ed goals 
see weld etzioni lansky pollack wilkins discussion topic 
technique rst planner simmons simmons 
set domain theories including experimentation 
users manual barrett planner available anonymous ftp june cs washington edu compressed le ftp pub ai ucpop tar binary mode transfer 
advanced topics discussion sections restricted goals attainment 
explained handle goal descriptions involving disjunction universal quanti cation just conjunction strips assumed goal logical expression describing single world state attained complete plan executed 
useful specify general constraints agent behavior time part goal 
example wish specify household robot set house re software robot softbot etzioni segal etzioni etzioni shouldn delete valuable les 
class behavioral constraints called maintenance goals implemented easily top ucpop extension causal link threat detection see etzioni weld etzioni 
drummond drummond describes rich language expressing goals including maintenance 
planner handles wide range behavioral goals lansky 
zeno synthesizes plans achieve universally quanti ed temporal metric goals penberthy weld 
simple propositional strips planning pspace complete actions conjuncts preconditions bylander 
cases planning undecidable erol 
result expect planners described perform quickly problems time 
fact achieve reasonable performance time usually necessary add control knowledge necessary sacri ce completeness 
nondeterministic choose function implemented search amounts aggressive heuristic search algorithm breadth rst iterative deepening depth rst 
simple way provide ranking function function takes plan returns real number indicating metrically 
unfortunately estimators known cient useful 
better idea knowledge search build miniature production system uses knowledge base forward chaining rules guide nondeterministic choice 
acquiring domain dependent knowledge rule form easier individual rules refer local decisions need weight pieces required computing single metric rank 
ideas rst explored soar system laird re ned prodigy planner minton minton incorporated ucpop implementation described barrett 
machine learning techniques automatically derive production rules 
learning algorithms explored including explanation learning minton static domain compilation etzioni etzioni smith peot abstraction knoblock derivational analogy veloso 
see case planner built pop snlp framework hanks weld similar system kambhampati hendler built reduction schemata planner 
production rule control implement re nement hierarchical reduction schemata traditional planning method tate currie tate charniak mcdermott yang 
form search control exploits notion resources sipe wilkins wilkins impressive planner uses sophisticated heuristics handle domains industrial complexity 
pop ucpop planners support open conditions single causal link actions plan provide redundant support 
seen violation commitment demands planner respond threats cases redundant supports 
idea multiple causal support dates back planner tate see kambhampati kambhampati june clean formalization 
see kambhampati excellent analysis di erent design choices planning algorithms 
possible build planners handle expressive action languages ones described 
pednault pednault describes adl language slightly expressive handled ucpop discusses theory regression planning language pednault implemented planner full language 
extensions implemented including incomplete information execution sensing operations etzioni peot smith golden probabilistic planning kushmerick draper decision theoretic speci cation goals williamson hanks metric time continuous change penberthy weld 
extensions remain investigated example richer utility models haddawy hanks mcdermott planner mcdermott total order planner handles roughly subset adl ucpop 
wellman domain axioms events generation safe plans weld etzioni multiple cooperating agents shoham 
interest describe 
see allen tip iceberg 
allen allen hendler tate editors 
readings planning 
morgan kaufmann san mateo ca august 
steel steel 
integrating planning execution monitoring 
proc 
th nat 
conf 
pages 
barrett weld barrett weld 
characterizing subgoal interactions planning 
proc 
th int 
joint conf 
pages september 
barrett weld barrett weld 
partial order planning evaluating possible ciency gains 
arti cial intelligence 
appear 
available ftp pub ai cs washington edu 
barrett barrett golden penberthy weld 
ucpop user manual version 
technical report university department computer science engineering september 
available ftp pub ai cs washington edu 
bylander bylander 
complexity results planning 
proceedings ijcai pages 
chapman chapman 
planning conjunctive goals 
arti cial intelligence 
charniak mcdermott charniak mcdermott 
arti cial intelligence 
addison wesley publishing reading ma 
collins pryor collins pryor 
achieving functionality lter conditions partial order planner 
proc 
th nat 
conf 
august 
cormen cormen leiserson rivest 
algorithms 
mit press 
currie tate currie tate 
plan open planning architecture 
arti cial intelligence november 
draper draper hanks weld 
probabilistic planning information gathering contingent execution 
proc 
nd int 
conf 
planning systems june 
drummond drummond 
situated control rules 
proceedings international conference knowledge representation reasoning may 
erol erol nau subrahmanian 
planning decidable 
proc 
st int 
conf 
planning systems pages june 
etzioni segal oren etzioni richard segal 
softbots testbeds machine learning 
working notes aaai spring symposium knowledge assimilation menlo park ca 
aaai press 
etzioni etzioni hanks weld draper lesh williamson 
approach planning incomplete information 
proc 
rd int 
conf 
principles knowledge representation reasoning october 
available ftp pub ai cs washington edu 
etzioni oren etzioni neal lesh richard segal 
building softbots unix preliminary report 
technical report university 
available anonymous ftp pub etzioni softbots cs washington edu 
etzioni oren etzioni 
acquiring search control knowledge static analysis 
arti cial intelligence august 
etzioni oren etzioni 
intelligence robots reply brooks 
ai magazine december 
available anonymous ftp pub etzioni softbots cs washington edu 
etzioni oren etzioni 
structural theory explanation learning 
arti cial intelligence march 
fikes nilsson fikes nilsson 
strips new approach application theorem proving problem solving 
arti cial intelligence 
genesereth nilsson genesereth nilsson 
logical foundations arti cial intelligence 
morgan kaufmann publishers los altos ca 
golden golden etzioni weld 
omniscience sensor management planning 
proc 
th nat 
conf 
july 
golden golden etzioni weld 
sense sense 
planner question 
technical report university department computer science engineering january 
available ftp pub ai cs washington edu 
haddawy hanks haddawy hanks 
representations decision theoretic planning goals 
proc 
rd int 
conf 
principles knowledge representation reasoning 
hammond hammond 
explaining repairing plans fail 
arti cial intelligence 
hanks mcdermott steve hanks drew mcdermott 
modeling dynamic uncertain world symbolic probabilistic reasoning change 
arti cial intelligence 
hanks weld steven hanks daniel weld 
systematic adaptation case planning 
proc 
st int 
conf 
planning systems june 
hanks hanks 
practical temporal projection 
proc 
th nat 
conf 
pages august 
kaelbling leslie pack kaelbling 
goals parallel program speci cations 
proc 
th nat 
conf 
morgan kaufmann 
kambhampati hendler kambhampati hendler 
validation structure theory plan modi cation reuse 
arti cial intelligence 
kambhampati nau kambhampati nau 
nature role modal truth criteria planning 
technical report isr tr university maryland inst 
systems research march 
submitted arti cial intelligence 
kambhampati kambhampati 
characterizing multi contributor causal structures planning 
proc 
st int 
conf 
planning systems pages june 
kambhampati kambhampati 
utility systematicity understanding tradeo redundancy commitment partial order planning 
proceedings ijcai pages 
kambhampati kambhampati 
planning re nement search uni ed framework analysis search space size performance 
department computer science engineering tr arizona state university 
kambhampati june kambhampati 
multi contributor causal structures planning formalization evaluation 
technical report cs tr dept computer science engg arizona state university june 
appear arti cial intelligence fall 
knoblock knoblock 
learning abstraction hierarchies problem solving 
proc 
th nat 
conf 
pages august 
korf korf 
search survey results 
shrobe editor exploring arti cial intelligence pages 
morgan kaufmann san mateo ca 
korf korf 
linear space best rst search summary results 
proc 
th nat 
conf 
pages july 
gini 
empirical study sensing defaulting planning 
proc 
st int 
conf 
planning systems pages june 
kushmerick kushmerick hanks weld 
algorithm probabilistic planning 
technical report univ washington dept computer science engineering 
appear arti cial intelligence 
available ftp pub ai cs washington edu 
laird laird newell rosenbloom 
soar architecture general intelligence 
arti cial intelligence 
lansky lansky 
localized event reasoning multiagent domains 
computational intelligence 
lansky amy lansky editor 
working notes aaai spring symposium foundations automatic planning classical approach menlo park ca 
aaai press 
mcallester rosenblitt mcallester rosenblitt 
systematic nonlinear planning 
proc 
th nat 
conf 
pages july 
mcdermott mcdermott 
regression planning 
international journal intelligent systems 
minton minton knoblock gil joseph carbonell 
prodigy manual tutorial 
cmu cs carnegie mellon university may 
minton steven minton jaime carbonell craig knoblock daniel kuokka oren etzioni yolanda gil 
learning problem solving perspective 
arti cial intelligence 
available technical report cmu cs 
minton minton bresina drummond 
commitment strategies planning comparative analysis 
proceedings ijcai pages august 
minton minton drummond bresina phillips 
total order vs partial order planning factors uencing performance 
proc 
rd int 
conf 
principles knowledge representation reasoning october 
minton minton 
quantitative results concerning utility explanation learning 
proc 
th nat 
conf 
pages august 
newell simon newell simon 
gps program simulates human thought 
feigenbaum feldman editors computers thought 
mcgraw hill new york 
nilsson nilsson 
principles arti cial intelligence 
tioga publishing palo alto ca 
gini gini 
deferred planning sensor 
proceedings darpa workshop innovative approaches planning scheduling control 
morgan kaufmann 
pednault pednault 
synthesizing plans contain actions context dependent ects 
computational intelligence 
pednault pednault 
adl exploring middle ground strips situation calculus 
proceedings knowledge representation conf 
pednault 
pednault 
generalizing nonlinear planning handle complex goals actions context dependent ects 
proc 
th int 
joint conf 
july 
penberthy weld penberthy weld 
ucpop sound complete partial order planner adl 
proc 
rd int 
conf 
principles knowledge representation reasoning pages october 
available ftp pub ai cs washington edu 
penberthy weld penberthy weld 
temporal planning continuous change 
proc 
th nat 
conf 
july 
peot smith peot smith 
conditional nonlinear planning 
proc 
st int 
conf 
planning systems pages june 
peot smith peot smith 
threat removal strategies partial order planning 
proc 
th nat 
conf 
pages june 
pollack martha pollack 
uses plans 

arti cial intelligence reiter reiter 
logic default reasoning 
arti cial intelligence 
russell russell 
cient memory bounded search algorithms 
proceedings tenth european conference onarti cial intelligence vienna 
wiley 
sacerdoti sacerdoti 
nonlinear nature plans 
proceedings ijcai pages 
schoppers schoppers 
universal plans reactive robots unpredictable environments 
proceedings ijcai pages august 
shoham shoham 
agent oriented programming 
arti cial intelligence march 
simmons simmons 
combining associational causal reasoning solve interpretation planning problems 
ai tr mit ai lab september 
simmons simmons 
theory debugging plans interpretations 
proc 
th nat 
conf 
pages august 
simmons simmons 
roles associational causal reasoning problem solving 
arti cial intelligence pages february 
smith peot smith peot 
postponing threats planning 
proc 
th nat 
conf 
pages june 
tate tate 
interacting goals 
proceedings ijcai pages 
tate tate 
generating project networks 
proc 
th int 
joint conf 
pages 
veloso carbonell veloso carbonell 
derivational analogy prodigy automating case acquisition storage utilization 
machine learning 
veloso manuela veloso 
learning analogical reasoning general problem solving 
phd thesis carnegie mellon university 
available technical report cmu cs 
waldinger waldinger 
achieving goals simultaneously 
machine intelligence 
ellis horwood limited chichester 
reprinted allen 
warren warren 
generating conditional plans programs 
proceedings aisb summer conference pages university edinburgh 
weld etzioni weld etzioni 
rst law 
proc 
th nat 
conf 
july 
available ftp pub ai cs washington edu 
wellman wellman 
challenges decision theoretic planning 
proceedings aaai symposium foundations automatic planning classical approach march 
wilkins wilkins 
causal reasoning planning 
computational intelligence 
wilkins wilkins 
practical planning 
morgan kaufmann san mateo ca 
wilkins wilkins 
ai planners solve practical problems 
computational intelligence november 
williamson hanks mike williamson steve hanks 
exploiting domain structure achieve cient temporal reasoning 
proc 
th int 
joint conf 
pages september 
williamson hanks williamson hanks 
optimal planning goal directed utility model 
proc 
nd int 
conf 
planning systems june 
yang yang 
formalizing planning knowledge hierarchical planning 
computational intelligence february 

