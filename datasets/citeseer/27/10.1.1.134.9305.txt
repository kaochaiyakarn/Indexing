bugs deviant behavior general approach inferring errors systems code dawson engler david yu chen seth hallem andy chou benjamin chelf computer systems laboratory stanford university stanford ca major obstacle finding program errors real system knowing correctness rules system obey 
rules undocumented specified ad hoc manner 
demonstrates techniques automatically extract checking information source code programmer avoiding need priori knowledge system rules 
cornerstone approach inferring programmer beliefs cross check contradictions 
beliefs facts implied code dereference pointer implies belief non null call unlock implies locked beliefs know programmer hold pointer dereference immediately flag contradictions errors 
beliefs programmer may hold assume beliefs hold statistical analysis rank resulting errors 
example call spin lock followed call spin unlock implies programmer may paired calls coincidence 
pairing happens times probably valid belief sole deviation probable error 
key feature approach requires priori knowledge truth beliefs contradict know error knowing correct belief conceptually checkers extract beliefs tailoring rule templates system example finding functions fit rule template paired 
developed checkers follow conceptual framework 
find hundreds bugs real systems linux openbsd 
experience give dramatic reduction manual effort needed check large system 
compared previous template checkers find times rule instances derive properties impractical specify manually :10.1.1.114.3285
want find serious bugs possible 
experience biggest obstacle finding bugs need sophisticated techniques lack bugs correctness constraints 
simple techniques find bugs systems filled rules errors 
biggest obstacle finding bugs simply knowing rules check 
manually discovering significant number rules system obey adventure especially repeated new release system 
large open source project linux rules evolve uncoordinated effort hundreds thousands developers 
result ad hoc collection conventions encoded millions lines code documentation 
manually finding rules difficult focus techniques automatically extract rules source code priori knowledge system 
want find incorrect knowing correct 
problem known solutions contradictions common behavior 
detect lie 
cross check statements witnesses 
contradict know wrong knowing truth 
similarly divine correct behavior 
look examples 
person acts way may correct behavior may coincidence 
thousands people action know majority probably right contradictory action probably wrong knowing correct behavior 
approach collects sets programmer beliefs checked contradictions 
beliefs facts system implied code 
examine types beliefs beliefs may beliefs 
beliefs directly implied code doubt programmer belief 
pointer dereference implies programmer believe pointer non null assuming want safe code 
may beliefs cases observe code features suggest belief may coincidence 
call followed call implies programmer may believe paired coincidence 
set beliefs things 
set beliefs look contradictions 
contradiction implies existence error code 
set including may beliefs separate valid beliefs coincidences 
start assuming may beliefs beliefs look violations errors beliefs 
statistical analysis rank error probability beliefs 
particular belief observed cases probably valid belief 
belief happens probably coincidence 
apply approach combining prior :10.1.1.114.3285
system specific static analyses find errors fixed set manually specified rules spin lock paired spin unlock 
leveraged fact rules commonly map fairly simple source code sequences 
example check rule inspecting path call spin lock ensure path contains call spin unlock 
effective previous limited need find rules manually 
describes derive rule instances automatically system infers pairing rule directly source code 
experience indicates approach far better alternative manual text search find relevant rule instances 
analyses automatically derive rule instances previously hand specified additional factor :10.1.1.114.3285
check properties gave see section 
demonstrate approach works complex real code find hundreds errors linux openbsd operating systems 
bugs resulted kernel patches 
section discusses related 
sections give overview approach sections apply find errors 
section concludes 
related methods finding errors 
widely testing manual inspection suffer exponential number code paths real systems erratic nature human judgment 
compare approach methods finding errors software type systems specification checking high level compilation 
close comparing systems dynamically infer invariants 
type systems 
language type systems probably find bugs daily basis approach 
program restrictions especially temporal context dependent restrictions rich underlying type system simply expressed 
richer frameworks typestate vault aspectoriented programming systems relations require programmer participation :10.1.1.115.8660
tool perspective language approaches require invasive rewrites get results 
contrast approach transparently infers richer invariants requiring specific language ideology code construction 
traditional type systems require programmers fixed type system code 
take opposite approach inferring ad hoc type system implicit programs putting compiler 
side effect show code features believed require specification pulled source directly see section 
specifications 
approach specify code check specification errors 
extreme example approach formal verification 
gains richness allowing programmer express invariants general specification checked model checker theorem provers checkers 
formal verification find deep errors difficult costly rarely software 
specifications necessarily mirror code suffer missing features simplifications practice 
begun attacking problems verifying software extremely rare :10.1.1.29.3872
slam project promising variation approach 
extracts model checks boolean variable program skeleton code 
requires considerably effort approach appears check limited set properties 
developed heavyweight checkers notably extended static type checking esc project checks interface level specifications lclint statically checks programmer source annotations 
approaches require effort 
specifications required approaches scale code size 
contrast analyses cost fixed amount construct cost automatically extracting checking information large input codes 
sense complementary approaches information extracted analyses check specifications correctly describe code 
houdini assistant esc effort decrease manual labor annotation approaches 
houdini uses annotation templates automatically derive esc annotations uses annotations statically find runtime errors java programs 
difference approach theirs allow noisier samples deriving rule templates statistical analysis rank derived rules 
high level compilation 
projects embedded hard wired application level information compilers find errors :10.1.1.161.222
projects find fixed set errors derive new checks source allowing detection broader range errors 
checking information extract serve inputs suitably modified versions checkers 
dynamic invariant inference 
significant projects area daikon eraser 
daikon similar project terms deriving program rules 
daikon dynamically monitors program execution reconstruct simple algebraic invariants 
starts set linear building block hypotheses variable constant greater variable validates hypothesis execution trace 
trace violates hypothesis hypothesis discarded 
compared static analysis dynamic monitoring advantage noise undecidability concern definition executed path possible runtime values determined 
accuracy dynamic monitoring cost 
daikon primarily intended help understand programs 
errors significant difficulties doing see executed paths requires test cases adequately exercise code monitors observe code works tested environment 
static analysis problems 
terms desire find bugs eraser system similar :10.1.1.161.222
eraser dynamically detects data races monitoring locks protect variables 
inconsistent locking flagged error 
eraser effective finding real bugs :10.1.1.161.222
dynamic similar limitations daikon sees limited number paths requires ability monitor code flag error path executed 
course dynamic information quite useful 
intend explore static analysis augmented dynamic monitoring 
possibility profile data rank bugs 
methodology section introduces approach terminology finding bugs 
goal approach extract beliefs code check violated beliefs 
restrict attention beliefs fit generic rule templates 
example template paired 
example bracketed letters represent positions template extraction process fill concrete elements code 
call positions slots code elements fill slots slot instances 
possible slot instances slots function calls lock unlock respectively 
remainder section explains apply template new unknown system hundreds automatically detected bugs 
detailed example null pointer checker 
example introduces general approach call internal consistency 
detailed description locking discipline checker introduces approach call statistical analysis 
conclude describing system implement checkers systems check 
example null pointer consistency subsection illustrates internal consistency find errors applying simplest possible problems detecting null pointer uses statically 
consider code fragment compares pointer card null dereferences drivers isdn card null kern err 
card id line check card null implies belief card null true path conditional 
line dereference card implies belief card null contradiction 
consistency checker find errors associating pointer belief set flagging cases beliefs contradict 
example belief set contain known null definitely null null definitely null null null 
code element action implying belief contradicts current belief set error 
note relevant error comparison action line implies belief set contain null null line 
check pointless 
implied belief set useful different piece code drivers char int write struct tty struct tty 
struct struct info tty driver data unsigned long flags tty info xmit buf return 
line tty driver data dereferences tty line check tty implies tty null 
check impossible deleted code potential error fixed 
beliefs inferred line line entry write 
assuming inter procedural information checker sets tty belief set unknown set value caller 
line checker sets tty belief set null 
lines impact belief set 
say belief set propagated moves action 
case belief set line propagated forward lines line 
line implies belief set tty containing null null 
path condition belief set null contradicts implied belief set 
formalize framework internal consistency checkers 
general internal consistency consistency checkers defined things 
rule template 
valid slot instances 
code actions imply beliefs 

rules beliefs combine including rules contradictions 

rules belief propagation 
rule template determines property checker tests 
checker job find check valid slot instances template example checker template dereference null pointer pointers potentially valid slot instances 
slot instance associated belief set 
action consider action effects belief sets slot instance 
checker action dereference pointer action signal error belief set contains belief null add belief null belief set 
action implies belief consider belief propagates actions 
comparison null propagates belief null subsequent actions true branch belief null subsequent actions false branch belief null null paths join 
general beliefs propagate forward backward caller callee functions implement interface program programs piece related code 
give complete discussion related code section 
formally slot instance denote belief set bv 
null checker associates pointer belief set bp take values bp definitely null bp definitely null bp null null 
convention empty belief set bp means known actions impact current belief sets propagating forward unaltered statement 
null checker actions imply beliefs dereferences comparisons 
actions affect belief set valid slot instance pointer dereferenced compared null 
dereference pointer implies belief notnull bp gives error belief set contains null null bp 
comparison implies things 
belief set prior comparison contains null notnull bp 
error beliefs known precisely error bp bp 
second conditional null true path bp null false bp 
complication propagating beliefs happens different paths join 
null checker takes union beliefs joining paths 
example card belief set bp true path comparison card null bp false path bp paths join line 
example statistical lock inference subsection illustrates statistical analysis find errors sets may beliefs 
statistical analysis rank may belief errors probable 
consider problem detecting shared variable accessed associated lock held 
know locks protect variables readily check rule static analysis 
unfortunately systems specify lock protects variable 
derive specification code seeing variables usually protected locks 
protected may worth flagging cases 
consider contrived code example shared variables may may protected lock times times held held 
contrast protected protected twice protected situation 
intuitively lock lock int variables potentially protected void foo lock enter critical section may protected unlock exit critical section protected void bar lock may protected unlock void baz may protected unlock protected protected contrived useful illustration example locks variables protected belief strengthened fact variable accessed critical section line acquisition spurious locks protect fixed programmer believes protects checking problem reduces inferring code believes protects variable protected lock implied belief protects check rule internal consistency 
protected access simply coincidence accessing unprotected variables critical sections harmless 
infer code may believe protects call type belief may belief 
check may beliefs 
cases consider may belief reduces candidate slot instances checked rule example variable lock checked template variable protected lock 
effective way determine may belief plausible simply act check belief internal consistency record belief satisfied rule versus gave error 
counts rank errors credible essentially ranking belief true versus negation 
checks belief passes credible violations higher errors ranked 
highest ranked errors examples fewest counter examples middle beliefs violated bottom errors violated beliefs 
inspecting results start top list way noise coincidental beliefs high point 
code treat may beliefs protects protects beliefs 
checking lock protects variable determine lock held 
beliefs locks propagate forward backward lock unlock actions lock implies belief locked locked unlock implies belief locked unlocked 
sideeffect checker catch double lock errors 
lock belief sets record variable checked rule access times times variable failed check 
number times accessed bl 
usually protected unprotected access line probably valid error 
errors correct uses usually discard 
programmers usually right 
bigger concerns concurrency bugs 
generally hypothesis test statistic rank errors ratio successful checks errors 
statistic favors samples evidence higher ratio examples counter examples 
discuss statistic section 
general statistical analysis may beliefs concern particular set slot instances checked rule template conceptually statistical checker internal consistency checker modifications 
applies check potential slot instance combinations 
assumes combinations beliefs 

indicates specific slot instance combination checked failed check errors 

augmented function rank uses count information rank errors slot combinations plausible 
lock checker mean checker consider variable lock pairs valid instances 
pair emits error message location lock held check message time accessed 
code possible slot combinations 
instance check messages lines error line 
instance check messages lines errors lines 
practical differences internal consistency statistical checkers 
results statistical analysis needs large set cases 
contrast internal consistency checker give definitive errors contradictory cases 
second universe slot instances manageable statistical checker may optional pre processing pass filters universe possible slot instances moderately plausible 
technique applies types system rules 
internal consistency flags cases conflicting beliefs errors statistical analysis set checks errors noisy 
sm internal null checker state decl pointer initial start state match pointer compared null code put null state true path ignore false path 
start null 
true null false null 
true false null give error pointer null state dereferenced code 
null 
err dereferencing null ptr simple metal extension flags pointers compared null dereferenced 
implement checkers write analyses metal see highlevel state machine sm language writing compiler extensions :10.1.1.114.3285
extensions dynamically linked extended version gnu gcc compiler 
translates input function internal representation extensions applied execution path function 
system extension results making analyses usually roughly linear code length 
metal viewed syntactically similar yacc specification 
typically sms patterns search interesting source code features cause transitions states matched 
patterns written extended version base language gnu match arbitrary language constructs declarations expressions statements 
expressing patterns base language flexible easy closely mirror source constructs describe 
system described detail :10.1.1.114.3285
purposes main features extensions small simple range lines code easily written system implementers compiler writers 
errors find leverage fact analyses aggressively system specific 
key feature inspect errors rank roughly ease diagnosis likelihood false positives 
ranking criteria places local errors global ones errors span source lines conditionals ones serious errors minor ones inspect errors starting top list way 
false positive rate high 
checkers report errors rarely inspect 
static analysis scalable precise immediate 
fixed cost writing analysis pass paid analysis automatic scalability say exactly file line led error precision require executing code immediacy 
static analysis finds bugs code run 
feature important os code bulk resides device drivers 
typical site hundreds required devices 
systems check applied extensions openbsd linux 
bulk focuses linux snapshots version released roughly draft written roughly final draft completed 
version check determined current checker described written 
represent hard test live errors unknown 
occasionally select example errors intermediate snapshots mainly report results released versions reproducibility 
apply checkers openbsd check generality 
main caveat results linux openbsd implementers get fooled spurious couplings non obvious ways apparent errors correct 
countered releasing bugs main kernel implementers 
resulted immediate kernel patches 
sections continue discussion methodology describing may beliefs detail 
rest evaluates methodology case studies 
internal consistency internal consistency finds errors propagating beliefs inferred code location related locations 
belief conflict error 
introduced internal consistency describing null pointer checker section 
section describe applications general technique provide detailed description technique 
section section case studies find errors 
table gives set example questions answered beliefs 
example discussed section code beliefs determine pointer kernel pointer dangerous user pointer 
dereferenced kernel believe safe kernel pointer 
passes special paranoid routine believe unsafe user pointer 
error beliefs 
consistency single function simplest form checkers function treats pointer unsafe pointer treat unsafe 
consistency checkers go 
code grouped equivalence classes related code share belief set 
propagate beliefs held member members equivalence class 
gives powerful lever single location holds valid belief lets find errors code propagate belief 
primary objectives finding beliefs relating code 
beliefs applicable checker 
code relate propagate beliefs find location holds valid belief 
discuss objectives briefly 
inferring beliefs infer beliefs ways direct observation implied pre post conditions 
direct observation uses standard compiler analyses compute code believe tracking actions reveal code state 
null pointer checker described section example direct observations setting pointer null checking null 
explicit state change second observation state 
changing state programmer believe changes took effect 
similarly observing state programmer believe observation true 
note beliefs inferred direct observation validated compute truth 
second method inferring beliefs fact actions code pre postconditions 
example division implies belief non zero deallocation pointer implies belief dynamically allocated precondition deallocation post condition 
assume code intends useful infer code believes actions redundant 
section observed check null implies belief check spurious 
similarly mutation setting implies belief different section section demonstrate flagging redundancies points programmers confused errors 
relating code code related implementation level execution path action action abstraction level related common interface abstraction semantic boundary 
consider 
code related implementation 
execution path allows cross check beliefs typically standard compiler analysis 
addition obvious beliefs shared data cross check assumed execution context fault models 
example calls usually inherits fault model checks foo failure careful 
conversely inherits faults fail 
code related abstractly 
implementations routine interface data type cross check beliefs relationship implies 
implement interface assume execution context fault model 
addition argument restrictions produce error behavior example contradictions categories include exits interrupts disabled enabled checks argument null dereferences directly returns positive integers signal errors returns negative integers 
perform checks programs checking different unix implementations posix system calls argument checks return error codes 
equivalent implies symmetrically cross check different pieces code template action belief null pointer 
null 
section null 
null true null false 
dangerous user pointer passed copyin dangerous user pointer 
section safe system pointer 
err check checked err err 
routine returned result 
section checked err err 
table questions inferred internal consistency 
ranking results necessary single contradicted belief error 
nice feature contradictions check code knowing context state 
tell relate code level 
way course divine intervention know cross check 
lacking knowledge find relationships automatically 
simple technique relate routine time different versions 
implementation stable check modifications violate invariants implied old code 
way relate code exploit common idioms imply implementations provide interface 
common idiom routines addresses assigned function pointer passed arguments function tend implement interface 
important trick cross check implementations interface single os different file systems export virtual file interface host os different device drivers implement interrupt handler see section 
statistical analysis statistical checkers find errors may beliefs 
statistical analysis filter coincidences may beliefs observing typical behavior examples 
sort errors statistical analysis ranking statistic proportions gamma lambda gamma population size number checks number counter examples errors number examples successful checks gamma probability examples gamma probability counter examples 
statistic measures number standard errors away observed ratio expected ratio 
typically assume random distribution probability 
ranking increases grows number counter examples decreases 
intuitively probability observed result increases number samples 
purposes bug finding perfect fits relatively uninteresting 
error cases reside number counter examples 
samples derivation infer wide range rule instances 
table gives set example questions answered statistical checkers 
couple things note ranking approach 
augmented additional features 
useful addition code trustworthiness code errors reliable examples correct practice code 
second interesting inversion property 
ranks instances satisfy template commonly useful rank gamma computes template useful negation useful 
call inverse principle 
third statistical analysis internal consistency exploit non spurious principle 
properties true element lock protect variable routine security check protect sensitive action 
cases empty template slot signals derivation error 
example lock checker section finds lock variable ratio checks errors gives acceptable rank checks checks gamma errors know problem analysis understand lock bindings program serious set errors 
general idea trivially applied statistical analysis property member 
cases immediately promote may belief belief statistical analysis 
example critical section accesses single shared variable implies code believe variable protected critical section lock 
handling noise concern deciding may beliefs true noise coincidences imperfect analysis 
key features counter noise large samples ranking error messages human level operations 
easily gather large representative sets behavioral samples basing approach static analysis allows examine paths 
paths inherently noisy derive patterns promising candidates 
second counter noise error messages statistic value rank errors credible 
inspect errors search false positive rate deemed high 
step sense crucial 
naive statistic rank beliefs errors 
initial approach just selected threshold calculated belief treated beliefs threshold beliefs 
checked rules beliefs threw resultant errors pool 
problem approach sensitivity value 
low false positives 
high find interesting 
ranking error messages beliefs completely avoids problems start inspecting top extreme cases false positive rate lowest 
noise increase steadily go list 
high 
switching approach notable difference building effective checkers 
analyses aided fact code understood humans 
important operations usually special function call set data types specific naming conventions 
fact commonly latent specifications cull easily understood results deriving paired functions give priority pairs substrings lock unlock acquire release discuss 
latent specifications latent specifications features designed communicate intent programmers idioms implicitly denote restrictions context 
encoded directly program text extensions easily access determine check conditions hold various points code 
leveraging encodings approach robust required programmers write specifications annotate code practice event worth remarking 
statistical analysis checks cases internal consistency checks leverage latent specifications filter results suppress false positives 
primitive latent specifications naming conventions 
familiar substrings include lock unlock alloc free release assert fatal panic spl manipulate interrupt levels sys signal system calls intr flag interrupt handlers release buffer cache blocks ioctl annotation buggy code 
statistical analysis passes auxiliary information flagging potentially interesting functions 
slightly higher level code cross cutting idioms encode meaning 
example error paths commonly signaled return null pointer negative positive integer 
annotations allow checkers detect failure paths callers error paths callees 
code interlaced executable specifications 
example debugging assertions precisely state conditions hold routine runs 
example routines bug linux panic bsd 
calls serve precise annotations marking paths executed machine rebooted call 
checkers suppress error messages paths 
specifications completely transparent shared code domain 
examples include popular rules null pointers dereferenced circular locking bad 
compiler extension directly encode information 
internal null consistency sections case studies evaluating approach section focus internal consistency section section focus statistical analysis 
section implements generalized version internal consistency checker section 
finds pointer errors flagging types contradictory redundant beliefs 
check pointer believed null subsequently dereferenced 

check pointer dereferenced subsequently checked null 
note error path leading check opposite belief null 

redundant checks pointer known null known null subsequently checked null null 
paths leading check known value check check violate rule dereference null pointer 
tend hard errors cause system crashes 
redundant checks violate rule test pointer value known 
violations cause crashes directly flag places programmers confused 
conceptually described earlier checker associates belief set pointer beliefs list null null unknown empty list 
checker rules straightforward 
dereference pointer adds belief null belief set 
error belief set contained null 

pointer checked null non null implies beliefs 
propagates backwards belief pointer value unknown null null 
checker flags error known precise belief 
second check propagates forward belief null true path non null false path 
simplicity implemented error type different extension 
implementation straightforward 
example full check checker written lines gives stripped version 
puts pointer compared null null state flags subsequent dereferences errors 
follow similar pattern sure error occur paths reporting 
checkers interesting challenge limiting scope broadening preventing beliefs violating abstraction boundaries suppressing impossible paths deciding boundary programming spurious checks 
template examples population lock protect 
uses protected uses paired paths paired paths routine fail 
result checked result security check protect checked reverse 
error paths paired error paths called interrupts disabled called interrupts disabled called table templates derivable statistical analysis statistical methods necessary counter coincidental couplings 
ranked 
commonly useful trick gamma derive checkers ensure beliefs flow black box abstraction barriers 
example macros perform context insensitive checks add null belief pointer belief set 
belief assume macro user 
want propagate outside macro falsely report dereferences pointer error 
false positives observed due macros 
reduce modified pre processor annotate macro produced code truncate belief propagation 
counter intuitive result checkers check redundant check generally best purely local prevent violations potential abstraction boundaries 
second problem check checker flag cases caused common idiom checking impossible condition calling panic equivalent crash machine condition true idle panic idle process cpu cpu idle processor cpu panic causes machine reboot dereference null idle impossible 
calls essentially latent specifications impossible paths 
eliminate problems checkers including section pre process code line extension eliminates crash paths removing hundreds false positives 
decide threshold redundancy contradiction errors 
checks separated lines errors separated considered robust programming practice 
arbitrarily set threshold roughly executable lines code 
results table shows errors linux 
amusing bugs highlighted section 
check example bug desire print helpful error message causes kernel segmentation fault 
second example section demonstrates common check error idiom dereference pointer initializer followed subsequent null check 
example code cut paste locations 
redundant checks checker far fewer errors provide evidence hypothesis redundancy contradiction correlated general checker bug false check check redundant checks table results running internal null checker linux 
confusion 
redundant cases follow example allocation wrong pointer value checked success 
drivers video fb info virt fb info virt return fb info virt meta meant fb info virt 
fb info virt fb info virt contradiction flagged suspicious locations contradictory pointer check tmp buf pointed error drivers char tmp buf page get free page gfp kernel meta missing read barrier tmp buf free page page missing cache read barrier potentially allow access stale pointer value held tmp buf similar locations spurious synchronization code 
discussion main results section ideas redundant contradictory observations find errors demonstrating contradiction checking simple beliefs find errors real code 
checkers section generalized find redundancies contradictions 
opportunities checks essentially action source code implies set beliefs 
example checks include warning critical section access shared state structure field read precision utilized write mutation read functions fail checked general expressions conditionals impossible redundant paths violate assertion conditions 
contribution realization traditional compiler optimization passes dead code elimination constant propagation error checkers minor re tooling 
security checker section describes checker finds security errors 
uses internal consistency check slot instances rule template dereference user pointer latent specifications automatically suppress false positives kernel backdoors 
techniques check fraction kernel code determine pointers dangerous 
readily security holes linux openbsd 
problem operating systems safely dereference user pointers 
access pointed data special paranoid routines copyin bsd derived systems 
single unsafe dereference crash system worse give malicious party control 
list pointers passed userlevel static analysis readily find errors 
unfortunately experience manual classification pointers 
worst offenders device drivers bulk operating systems interact extensively user code follow discernible convention denoting user pointers 
routines follow vague naming convention tend mixture safe pointers passed kernel unsafe pointers passed raw user fabricated input integers 
classify dangerous pointers security holes largest source errors 
solve problem internal consistency derive pointers believed user pointers checking treated kernel pointers dereferenced 
rules checker follows 
pointer dereferenced believed safe kernel pointer 

pointer sent paranoid routine believed tainted user pointer 

pointer believed user pointer kernel pointer error 
checker refines process considering arguments functions abstractly related function pointers 
functions assigned function pointer fp treats ith parameter user pointer treat ith parameter user pointer 
consistency checkers correct technique check related uses 
implementation discuss checker implementation false positive suppression manual effort needed retarget checker new system 
security hole linux shown running example clarify description implementation 
checker finds hole follows 
call paranoid routine copy user line implies belief buff tainted 
second buff net atm proc proc mpc write struct file file const char buff page char get free page gfp kernel page null return copy user data buff page retval copy user page buff retval 
pass page buff 
retval parse qos buff incoming int parse qos const char buff int len unchecked buff cmd buff security error driver carefully copies user memory safe location page immediately passes unsafe user pointer buff parse qos reads 
striking feature error amidst fair amount safety conscious boilerplate programmer const qualifier buff ensure buff accidentally mutated 
passed parse qos line passes line turn dereference implying buff safe kernel pointer 
beliefs conflict checker emits error 
checker works passes global derivation pass computes summaries checks assignment local checking pass checks function calls pointer dereferences summaries computed pass 
global pass computes summaries transitive closure functions taint parameters transitive closure functions dereference parameters function pointer assignment including assignments static structure initialization 
results pass passed step text files 
transitive closure operations essentially technique 
tainted list know functions parameters eventually execution path passed paranoid routine 
happen directly line example indirectly line function foo void foo struct file char buff sz proc mpc write buff dereferencing list computed exactly manner 
function parse qos dereferences parameter buff directly call line 
functions call parse qos passing parameters argument parse qos marked 
result passes emitted lists tainting list dereference list form fn indicates function fn dereferences ith parameter 
summaries completed summaries check conflicts function pointer assignment error function pointer assigned function dereferences ith parameter ith parameter 
flag error function pointer fp assigned tainted list dereference list 
run local checking pass uses lists similarly warn tainted pointer dereferenced passed routine dereference 
goes function twice 
pass examines call sites marking pointer passed parameter tainting routine tainted 
example pointer buff marked tainted passed tainting routine copy user line 
second pass checks uses tainted pointers flags raw dereferences call routine dereference 
example call parse qos line flagged tainted pointer buff passed dereferencing routine parse qos 
note example inference approach gracefully programmer annotations 
text files summaries annotations pointers user pointers easily added file manually extracted source annotations inserted 
false positives 
largest source false positives kernel backdoors check called user code kernel code 
case safely dereference pointers uses flagged naive checker 
fortunately dangerous activity kernel programmers stylized naming conventions boolean flags determine context operating 
openbsd linux variables named user user 
extension treats variables implicit specifications tells dataflow framework evaluate true backdoor path pruned away 
obvious main technique suppressing false positives list dereferencing functions 
natural checker simply warn tainted value passed function parameter checking call dereferenced value 
unfortunately prevalence type coercion cause false positives 
device code commonly uses value pointer value path integer 
naive checker path cause value tainted second path cause error message called function tainted value function value integer 
manual labor 
checker system independent 
system specific parts 
text file listing paranoid routines 
routines bsd linux 

text file listing tainting dereferencing routines ignored 
suppress false positives caused limitations system static analysis independent deriving approach 
functions bsd linux 

list variables names substrings indicate kernel backdoors 
form annotation needed system expect leveraging source reduces os errors false applied openbsd linux linux table user pointer checker bugs total 
false positives applied roughly times linux openbsd 
numbers linux available earlier version system 
numbers parentheses kernel errors false positives cross checking functions assigned function pointer 
effort roughly small reasonably 
applying checker new system typically follows stages 
tainting routines specified checker run system 
second results ranked inspected 
function causes false positives added list ignored routines related errors skipped 
similarly false positives kernel backdoors cause add flag extension list skip related errors 
rerun checker system re mark errors inspected 
results table lists bugs number false positives check applied 
bugs led subsequent kernel patches 
false positive ratio fairly low 
seriousness bugs higher rate acceptable 
linux device drivers account error 
bulk errors concentrated ioctl calls 
bugs tend cluster assumptions led mistake avalanche 
worst example code ioctl routine errors pattern calling copy user safely copy user pointer rt simultaneously calling function promptly dereference 
representative example drivers net ioctl case copy user rt find route rt sizeof struct route return analysis taint rt passed copy user call warn call find route rt dereferences 
openbsd bulk errors system compatibility layer 
due simply reversing arguments paranoid functions copyin 
error faithfully replicated different places 
interestingly places code immediately errors handles parameter passing correctly 
similar argument reversal bugs caught linux 
cross checking functions assigned function pointer errors false positive 
analysis systems 
errors came improper implementations routines assigned write method field file operations structure routines assigned pointer treated second parameter tainted buggy routines fop write mdc device write dereferenced pointer directly 
example fop write sbc buf tainted 
size fop write struct file file const char buf 
scan ofs ofs count ofs buf ofs wdt expect close section author uses const qualifier type safety compromising system security 
expected find bugs function pointer equivalence small bug counts reassuring imply call chains treat pointer correctly place allowing check entire call chain 
inferring failure section finds errors routines checked incorrectly checked failure 
uses statistical analysis derive check slot instances rule template function checked failure 
demonstrate basing analysis client beliefs allows find restrictions indirectly represented source code 
result find completely unanticipated errors traditional analysis problem kernel code check failure resource exhaustion access control point 
enormous number cases missing checks common 
example previous static analysis cases linux kernel code check result memory allocation procedures similar analysis allocator openbsd cases :10.1.1.114.3285
lead segmentation faults allocation failed high load 
non memory allocation functions fail 
failures frequently silent making worse ways kernel crashes 
example colleague wasted days tracking bug hidden single missing check graphics device driver signaled driver allocate range device memory 
effect failure display graphics assume happens new card misconfigured case bug opaque driver 
traditional approach finding routines fail compute transitive closure routines return null pointers error codes 
practice limitations 
easy values returned directly difficult variables returned 
example code return foo bar field bar structure foo may may null value explicitly set cleared 
program text tell 
second type analysis give high number false positives routines fail pre conditions met version bug false openbsd total table errors false positives running derived null checker linux openbsd 
bugs format errors derived functions previously known return null errors functions know 
openbsd results older version checking system newer version gives times lower false positive rates checker 
note checked earlier versions oses submitted bug reports :10.1.1.114.3285
result developers fixed easy cases 
searching list failure may outside program fault model 
robust approach deriving routines programmers believe plausibly fail 
missing checks checked routines candidates errors 
similarly checks checked routines frequently signal misunderstood interfaces 
checkers wrote checkers model 
ensures routines returning null pointers checked 
second ensures routines return integer error codes checked 
follows 
assume functions fail 

result function ignored checks checker emits error message 

result function checked checker emits checked message 
high ratio check error messages implies client believes checks necessary 
going entire system checker counts function total number errors messages err total number checked uses chk 
uses counts rank error messages err chk chk errors functions high value put lower values 
highest ranked errors checked functions probability real errors 
table lists number null errors checker 
note statistical ranking beliefs infer may beliefs 
tell unchecked call means programmer believes need checked believe need checked particular callsite 
case examining callsites allows generalize beliefs 
worst error hand examined excess errors various types 
error linux version test worst seen 
missed traditional null pointer analysis interestingly checker automatically type error thought 
error started confusing false positive checker emitted message stating unchecked pointer shp ipc shm map zero setup err shp seg alloc return ptr err shp false positive caused error return convention 
routine seg alloc returns valid pointer success failure return null pointer casts integer error codes pointer returns essentially doing return void 
callers check returned pointer errors special call err caller reverses cast compares value negative integer 
key point failure seg alloc returns non null bogus pointer 
true null checker looking 
seg alloc callers understandably forgotten idiom checked function return null 
searching log turned routine test ipc shm note checking seg alloc shp seg alloc return id shm shp happens seg alloc fails 
case null pointer check shp fail call routine shm pointer shp argument 
pointer passed routine ipc parameter new catastrophic things happen int ipc struct kern ipc perm new new new uid current new gid new current ids entries id new routine writes bogus memory location pointed new 
error bits form valid physical address writes new corrupt physical memory 
second entry placed array structures guaranteeing corruption re occur sporadic continuous basis 
traditional null pointer error checking completely oblivious cases detected fairly easily just examining inconsistencies callers handle function returns 
err consistency checking 
type error leads 
error obvious secondary check verify routines similar error pointer trick correctly handled callers 
pass consistency checker enforced restriction function return value checked err callers check result way 
functions kernel 
find bugs seg alloc case find opposite problem code err check function returned null 
check fail causing client think error dereference null pointer 
checked call sites errors false positives caused unusual coding styles 
caught errors fixed 
discussion nice feature analysis style finds additional unforeseen types errors 
err checking idiom example imagined bizarre error type know look shown initially understand going 
picked traditional generic null pointer analysis 
find way derive failing routines 
misunderstood interface uses unanticipated error type approach 
checkers section manifests routines fail spuriously checked callers 
examples systems looked 
commercial system routine showed mixed function analysis 
examined turned return fail 
despite places checked failure 
checks implicitly showed callers realize routine return assumed code calls run 
happened initial version routine fail code written way interface changed code updated subsequent code initial failure checks correct way treat 
similar case shows openbsd function fail treated way clients 
checks nice way flagging code written programmers poor grasp internal interfaces code audited 
basic approach finding deviant interfaces extended richer examples 
summary type analysis serves supplement traditional compiler analysis approach 
sense checks level interface viewing clients treat routine examining implementation 
possible direction approach catch implementation violates specification checking implementation actions contradict client assumptions return null clients check 
deriving temporal rules type error approach find violations temporal rules sequences actions need considered 
examples temporal rules 
freed memory follow 
unlock follow lock contextual rules context 
error paths reverse side effects 
small number templates different specific operations fit 
section look temporal rule templates 
checks rule flagging cases memory passed potential deallocation function 
second analysis checks rule follow pre processing code build traces related function calls local program paths examined find sequences operations fit rule 
fits kept bad fits discarded 
deallocation rule checks freed memory 
finding rule violations difficult systems large set deallocation functions ranging general purpose routines wrappers routines variety ad hoc routines manage internal free lists 
section describes checker infer routine types 
checker exploits single simple implication function argument call infer programmer may believe deallocation function 
may belief step statistical process find violations 
blindly assume function frees arguments 

function argument pair count number times check pair err number times pair failed check 

segregate errors pair statistic rank pair pair checked versus failed err gamma err 
pushes errors pairs top list 
unsurprisingly checking argument pairs computationally expensive practice 
reduce overhead latent specification automatically filter population candidate functions contain names suggestive deallocation containing substring free 
applied process linux kernel inspected top ranked functions 
free errors missed previous 
false positives total 
shows interesting example double free caught old system 
second call copy user fails code carefully frees buff possibly missing return frees variables 
bug particularly bad opens security hole users trigger path deterministically calling code invalid pointers cause copy user fail 
second disastrous bug frees memory allows escape occurs routine proc file system code fs proc generic proc symlink ent data ent data ent goto return ent allocation fails routine free data pointed ent returning null return ent 
callers checking failure get non null pointer assume routine succeeded pointer 
remaining errors single free error implementer carefully cut paste different locations 
drivers block ioctl copy user cmd free null buff null buff return direction xfer read copy user cmd free null buff cmd free null buff null buff double free security hole copy user correctly deallocates storage returns error 
second appears omitted return statement allowing code fall hit duplicate free buff 
follow subsection find errors temporal template follow 
function followed implies may belief followed belief belief pairings coincidental 
intuitively determine pairing real spurious comparing number code paths call number paths pair calls non spurious couplings near equal counts errors slightly different 
conceptually checker rule identical deallocation checker previous subsection 
blindly assume possible function pairs obey rule 
pair count number times check pair err number times pair failed check 
rank pairs statistic gamma err 
practice need modifications 
control overwhelming number pairwise combinations pre process possible paths get plausible pairs 
second reduce inspected number false positives statistic rank error messages pair plausibility individual error message 
discuss modification 
selecting plausible pairs 
reduce number possible pairwise combinations automatically extracting traces source code culling plausible pairs feeding checker 
consider idiomatic types function traces type type type foo foo foo bar bar bar baz baz baz type traces result function assigned variable passed argument subsequent call 
happen handle returned number calls possibly released 
trace example foo bar baz 
type traces variable passed initial assignment 
call spin lock followed spin unlock lead type trace 
third series argument function calls 
paired calls lock kernel unlock kernel generate type trace 
idioms filter pairs analysis manageable effective cover wide set uses 
generate pairs steps 
run trace extractor kernel 
result file containing unique trace order magnitude kernel generates roughly traces 
second post process traces statistic select plausible pairs latent specifications increase weight functions names suggestive paired functions substrings lock unlock acquire release spl 
feed selected functions implementation checker sketched 
hierarchical ranking 
classic error rule paths correctly followed paths 
classic false positive single false positives typically happen local analysis check pairs encounters wrapper routines pair example locking wrapper function acquire lock release 
want rank error messages fit idiom errors fit second 
computing additional statistic rank errors single checked function number paths function contain pair versus number paths contain additional ranking pair pushes errors top 
importantly functions top list contain errors contain best examples programmer attempted pair examples help determine pair valid 
errors binned pair bins sorted pair plausibility 
bin errors sorted individual error plausibility 
inspect errors starting top list 
pair test validity error 
valid continue inspecting errors bin false positive rate high 
skip pair 
continue process number bogus pairs deemed high point 
results 
applied checker linux kernel errors involved functions checked prior false positives 
simplest error insidious errors seen trident sound driver global kernel lock acquired call lock kernel released error path contained subsequent macro validate state drivers sound trident trident release lock kernel card state card state validate state state errors similar cases functions reversed error paths 
unusually errors core file system code drivers 
drivers sound solo midi release static int solo midi release 
lock kernel file mode write add wait queue midi wait set current state task interruptible spin lock lock flags count midi spin unlock lock flags file flags remove wait queue set current state task running release lock 
return unlock kernel return code acquires global kernel lock release error path properly roll back number operations 
identical error cut paste total device drivers 
example happened ufs file system code acquired lock file system super block sb function lock super release error path 
error survived sent bug report days originally submitted 
gives complex errors acquires master kernel lock lock kernel rolls back number operations error path forgets release lock 
error faithfully copied device drivers 
currently machine learning techniques automatically generate temporal rules rule templates directly source code 
performing statistical analysis traces form general model actions control flow probabilistic automata hidden markov models stochastic context free grammars probabilities initialized static branch prediction 
initial results lead believe profitable approach 
shows automatically find bugs system having priori knowledge correctness rules system obey 
simple static analyses automatically extract programmer beliefs source code flag belief contradictions errors 
key benefit approach eliminates need understand system deep way know contradicted belief error having know actual belief 
approach significant improvement prior manually specified rules check 
specify general template rule allow automatic analysis specialize template checked system 
technique drastically decreases manual labor required re target analyses new system enables check rules impractical 
general techniques implementing deriving analyses discuss framework terminology describing 
technique internal consistency finds errors programmers violated beliefs know hold 
second technique statistical analysis extracts beliefs noisier sample extracted beliefs valid coincidental 
shown approach works real systems code 
template checkers hundreds errors snapshots linux openbsd operating systems 
errors resulted kernel patches 
acknowledgments david dill early discussions invariant derivation 
wilson hsieh justin ken provided minute editing assistance 
evan parker doing bulk implementation section built check redundant check checkers inspected results modified pre processor mark macros expanded 
generous readers linux kernel feedback support especially alan cox confirming fixing bugs 
eddie kohler diane tang suggested guided multiple minute attempts rescue clarity 
eddie simplified gave new insights framework 
diane donated exhaustive close reads 
especially mark horowitz creating lab environment allows focus research bureaucracy 
research supported darpa contract mda stanford networking research center 
aiken su 
detecting races relay ladder logic programs 
proceedings st international conference tools algorithms construction analysis systems april 
ball rajamani 
bebop symbolic model checker boolean programs 
spin workshop model checking software lncs springer august september 
bishop 
checking race conditions file accesses 
computing systems pages spring 
bush pincus 
static analyzer finding dynamic programming errors 
software practice experience 
corbett dwyer hatcliff laubach pasareanu robby zheng 
bandera extracting finite state models java source code 
icse 
deline fahndrich 
enforcing high level protocols low level software 
proceedings acm sigplan conference programming language design implementation june 
detlefs leino nelson saxe 
extended static checking 
tr src compaq src december 
henglein mossin niss rensen tofte 
type theory year conversion tool 
conference record popl th acm sigplan sigact symposium principles programming languages san antonio texas pages new york ny 
engler chelf chou hallem :10.1.1.114.3285
checking system rules system specific programmer written compiler extensions 
proceedings operating systems design implementation osdi september 
ernst cockrell griswold notkin 
dynamically discovering program invariants support program evolution 
ieee transactions software engineering february 
evans guttag horning tan 
lclint tool specifications check code 
proceedings acm sigsoft symposium foundations software engineering december 
flanagan rustan leino 
houdini annotation assistant esc java 
symposium formal methods europe pages march 
floyd 
assigning meanings programs pages 
schwartz ed 
american mathematical society 
freedman 
statistics 
norton third edition edition 
holzmann smith 
software model checking extracting verification models source code 
invited 
proc 
forte publ 
kluwer 

personal communication 
wasted days configuring graphics card missing error check driver september 
kiczales lamping mendhekar maeda lopes loingtier irwin :10.1.1.115.8660
aspect oriented programming 
european conference object oriented programming ecoop june 
lie chou engler dill 
simple method extracting models protocol code 
proceedings th annual international symposium computer architecture july 
mcmillan 
formal verification cache consistency protocol 
proceedings international symposium shared memory multiprocessing pages 
tokyo japan inf 
process 
soc 
nelson 
techniques program verification 
available xerox parc research report csl june stanford university 
savage burrows nelson sobalvarro anderson :10.1.1.161.222
eraser dynamic data race detector multithreaded programming 
acm transactions computer systems 
stern dill 
automatic verification sci cache coherence protocol 
correct hardware design verification methods ifip wg advanced research working conference proceedings 
strom yemini 
typestate programming language concept enhancing software reliability 
ieee transactions software engineering january 
wagner foster brewer aiken 
step automated detection buffer overrun vulnerabilities 
network distributed systems security conference 
san diego ca february 
