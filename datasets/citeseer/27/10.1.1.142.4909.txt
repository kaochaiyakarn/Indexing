cient software fault isolation robert wahbe steven lucco thomas anderson susan graham computer science division university california berkeley ca way provide fault isolation cooperating software modules place address space 
tightly coupled modules solution incurs prohibitive context switch overhead 
software approach implementing fault isolation single address space 
approach parts 
load code data distrusted module fault domain logically separate portion application address space 
second modify object code distrusted module prevent writing jumping address outside fault domain 
software operations portable programming language independent 
approach poses tradeo relative hardware fault isolation substantially faster communication fault domains cost slightly increased execution time distrusted modules 
demonstrate frequently communicating modules implementing fault isolation software hardware substantially improve application performance 
supported part national science foundation cda defense advanced research projects agency darpa contracts dabt digital equipment systems research center external research program foundation 
anderson supported national science foundation young investigator award 
content necessarily re ect position policy government cial endorsement inferred 
appear proceedings symposium operating system principles 
application programs achieve extensibility incorporating independently developed software modules 
faults extension code render software system unreliable dangerous faults corrupt permanent data 
increase reliability applications operating system provide services prevent faults distrusted modules corrupting application data 
fault isolation services facilitate software helping identify sources system failure 
example postgres database manager includes extensible type system sto 
facility postgres queries refer general purpose code de nes constructors destructors predicates user de ned data types geometric objects 
fault isolation query uses extension code interfere unrelated query corrupt database 
similarly operating system research focused making easier third party vendors enhance parts operating system 
example micro kernel design parts operating system implemented user level servers easily modi ed replaced 
generally systems added extension code operating system example bsd network packet lter mra mj application speci virtual memory management hc active messages 
industry systems microsoft object linking embedding system cla link independently developed software modules 
xpress desktop publishing system structured support incorporation email lucco tea cs berkeley edu general purpose third party code 
postgres faults extension modules render systems unreliable 
way fault isolation cooperating software modules place address space 
remote procedure call rpc bn modules separate address spaces call normal procedure call interface 
hardware page tables prevent code address space corrupting contents 
unfortunately high performance cost providing fault isolation separate address spaces 
transferring control protection boundaries expensive necessarily scale improvements processor integer performance 
cross address space rpc requires trap operating system kernel copying argument caller callee saving restoring registers switching hardware address spaces machines translation lookaside bu er trap back user level 
operations repeated rpc return 
execution time overhead rpc highly optimized implementation orders magnitude greater execution time overhead normal procedure call ball 
goal fault isolation cheap system developers ignore performance ect choosing modules place separate fault domains 
cases fault isolation useful cross domain procedure calls frequent involve moderate amount computation call 
situation impractical isolate logically separate module address space cost crossing hardware protection boundaries 
propose software approach implementing fault isolation single address space 
approach parts 
load code data distrusted module fault domain logically separate portion application address space 
fault domain addition comprising contiguous region memory address space unique identi er control access process resources le descriptors 
second modify object code distrusted module prevent writing jumping address outside fault domain 
program modules isolated separate software enforced fault domains modify data execute code explicit cross fault domain rpc interface 
ed programming languageindependent transformation strategies render object code unable escape code data segments 
concentrate simple transformation technique called sandboxing slightly increases execution time modi ed object code 
investigate techniques provide debugging information incur greater execution time overhead 
approach poses tradeo relative fault isolation 
eliminate need cross hardware boundaries er substantially lower cost rpc fault domains 
safe rpc prototype implementation takes roughly decstation roughly dec alpha order magnitude faster existing rpc system 
reduction rpc time comes cost slightly increased distrusted module execution time 
test suite including spec benchmarks sandboxing incurs average execution time overhead decstation alpha 
software enforced fault isolation may counter intuitive slowing common case normal execution speed uncommon case cross domain communication 
frequently communicating fault domains approach er substantially better performance 
demonstrate applied software enforced fault isolation postgres database system running sequoia benchmark 
benchmark postgres extensible data type system de ne geometric operators 
benchmark software approach reduced fault isolation overhead factor decstation 
software approach provides tradeo performance level distrust 
modules program trusted distrusted may case extension code distrusted modules incur execution time overhead 
code trusted domains run full speed 
similarly possible techniques implement full security preventing distrusted code reading data outside domain cost higher execution time overhead 
quantify effect section 
remainder organized follows 
section provides examples systems require frequent communication fault domains 
section outlines modify object code prevent generating illegal addresses 
section describes implement cross rpc 
section presents performance results prototype nally section discusses related 
background section characterize detail type application bene fault isolation 
defer description postgres extensible type system section gives performance measurements application 
operating systems community focused considerable attention supporting kernel extensibility 
example unix vnode interface designed easy add new le system unix kle 
unfortunately expensive forward le system operation user level typically new le system implementations added directly kernel 
andrew le system largely implemented user level maintains kernel cache performance hkm 
epoch tertiary storage le system web example operating system kernel code developed third party vendor 
example user programmable high performance systems 
data arriving channel high rate performance degraded substantially control transferred user level manipulate incoming data fp 
similarly active messages provide high performance message handling distributed memory multiprocessors 
typically message handlers application speci network controller accessed user level thi message handlers compiled kernel reasonable performance 
user level example xpress desktop publishing system 
purchase third party software extend system perform functions unforeseen original designers 
time extensibility caused number problems 
lack cient fault domains personal computers xpress runs extension modules corrupt internal data structures 
bugs third party code system appear unreliable users distinguish sources system failure 
examples share characteristics 
hardware fault isolation result significant portion execution time spent operating system context switch code 
second small amount code distrusted execution time spent trusted code 
situation software fault isolation cient hardware fault isolation sharply reduces time spent crossing fault domain boundaries slightly increasing time spent executing distrusted part application 
section quanti es trade domain crossing overhead application execution time overhead demonstrates domain crossing overhead represents modest proportion total application execution time software enforced fault isolation cost ective 
software enforced fault isolation section outline software encapsulation techniques transforming distrusted module escape fault domain 
rst describe technique allows users pinpoint location faults software module 
introduce technique called sandboxing isolate distrusted module slightly increasing execution time 
section provides performance analysis 
software encapsulation technique allows cooperating fault domains share memory 
remainder discussion assumes operating risc load store architecture techniques extended handle 
section describes implement safe cient cross fault domain rpc 
divide application virtual address space segments aligned virtual addresses segment share unique pattern upper bits called segment identi er 
fault domain consists segments distrusted module code static data heap stack 
speci segment addresses determined load time 
software encapsulation transforms distrusted module object code jump targets code segment write addresses data segment 
legal jump targets distrusted module upper bit pattern segment identi er similarly legal data addresses generated distrusted module share segment identi er 
separate code data segments necessary prevent module modifying code segment possible address correct segment identi er illegal instance refers unmapped page 
caught normal operating system page fault mechanism 
segment matching unsafe instruction instruction jumps stores address statically ver system supports dynamic linking special interface 
ed correct segment 
control transfer instructions program counter relative branches statically veri ed 
stores static variables immediate addressing mode statically veri ed 
jumps registers commonly implement procedure returns stores register hold target address statically veri ed 
straightforward approach preventing illegal addresses insert checking code unsafe instruction 
checking code determines unsafe instruction target address correct segment identi er 
check fails inserted code trap system error routine outside distrusted module fault domain 
call software encapsulation technique segment matching 
typical risc architectures segment matching requires instructions 
lists pseudo code fragment segment matching 
rst instruction fragment moves store target address dedicated register 
dedicated registers inserted code modi ed distrusted module 
necessary code distrusted module may arrange jump directly unsafe store instruction bypassing inserted check 
transform unsafe store jump instructions dedicated register 
software encapsulation techniques require dedicated registers segment matching requires dedicated registers hold addresses code segment hold addresses data segment hold segment shift amount hold segment identi er 
dedicated registers may impact execution time distrusted module 
modern risc architectures including mips alpha registers retarget compiler smaller register set minimal performance impact 
example section shows decstation reducing registers register set available compiler gcc signi cant ect average execution time spec benchmarks 
address sandboxing segment matching technique advantage pinpoint instruction 
capability useful software development 
reduce runtime overhead cost providing information source faults 
architectures limited register sets int possible encapsulate module reserved registers restricting control ow fault domain 
dedicated reg target address move target address dedicated register 
scratch reg dedicated reg shift reg right shift address get segment identi scratch reg dedicated register 
shift reg dedicated register 
compare scratch reg segment reg segment reg dedicated register 
trap equal trap store address outside segment 
store instruction uses dedicated reg assembly pseudo code segment matching 
dedicated reg target reg mask reg dedicated register mask reg clear segment identi er bits 
er 
dedicated reg dedicated reg segment reg dedicated register segment reg set segment identi er bits 
store instruction uses dedicated reg assembly pseudo code sandbox address target reg 
unsafe instruction simply insert code sets upper bits target address correct segment identi er 
call sandboxing address 
sandboxing catch illegal addresses merely prevents ecting fault domain generating address 
address sandboxing requires insertion arithmetic instructions unsafe store jump instruction 
rst inserted instruction clears segment identi er bits stores result dedicated register 
second instruction sets segment identi er correct value 
lists pseudo code perform operation 
segment matching modify unsafe store jump instruction dedicated register 
dedicated register distrusted module code produce illegal address jumping second instruction sandboxing sequence upper bits dedicated register contain correct segment identi er second instruction ect 
section presents simple algorithm verify object code module correctly sandboxed 
address sandboxing requires dedicated registers 
register hold segment mask registers hold code data segment guard zones segment reg offset segment guard zones 
size guard zones covers range possible immediate sets register plus set addressing modes 
identi ers hold sandboxed code data addresses 
optimizations overhead software encapsulation reduced conventional compiler optimizations 
current prototype applies loop invariant code motion instruction scheduling optimizations asu acd 
addition conventional techniques employ anumber optimizations specialized software encapsulation 
reduce overhead software encapsulation mechanisms arithmetic computes target addresses 
example risc architectures include register plus set instruction mode set immediate constant limited range 
mips architecture sets limited range 
consider store instruction store value offset reg address offset reg uses register plus set addressing mode 
sandboxing instruction requires inserted instructions sum reg offset dedicated register sandboxing instructions set segment identi er dedicated register 
prototype optimizes case sandboxing register reg actual target address reg offset saving instruction 
support optimization prototype establishes guard zones top bottom segment 
create guard zones virtual memory pages adjacent segment unmapped see 
reduce runtime overhead treating mips stack pointer dedicated register 
avoid sandboxing uses stack pointer sandboxing reg register set 
uses stack pointer form addresses plentiful changes optimization signi cantly improves performance 
avoid sandboxing stack pointer modi ed small constant set long modi ed stack pointer part load store address control transfer instruction 
modi ed stack pointer moved guard zone load store instruction cause hardware address fault 
dec alpha processor apply optimizations frame pointer stack pointer 
number optimizations reduce sandboxing overhead 
example transformation tool remove sandboxing sequences loops cases store target address changes small constant set loop iteration 
prototype implement optimizations 
process resources multiple fault domains share virtual address space fault domain implementation prevent distrusted modules corrupting resources allocated address space basis 
example fault domain allowed system calls close delete les needed code executing address space potentially causing application crash 
solution modify operating system know fault domains 
system call page fault kernel program counter determine currently executing fault domain restrict resources accordingly 
keep prototype portable implemented alternative approach 
addition placing distrusted module separate fault domain require distrusted modules access system resources cross fault domain rpc 
reserve fault domain hold trusted arbitration code determines particular system call performed fault domain safe 
distrusted module object code performs direct system call transform call appropriate rpc call 
case extensible application trusted portion application system calls directly shares fault domain arbitration code 
data sharing hardware fault isolation mechanisms support data sharing virtual address spaces manipulating page table entries 
fault domains share ad dress space set page table entries standard shared memory implementation 
read sharing straightforward software encapsulation techniques alter load instructions fault domains read memory mapped application address space object code particular distrusted module sandboxed share read write memory fault domains technique call lazy pointer swizzling 
lazy pointer swizzling provides mechanism fault domains share arbitrarily read write memory regions additional runtime overhead 
support technique modify hardware page tables map shared memory region address space segment needs access region mapped set segment 
words alias shared region multiple locations virtual address space aliased location exactly low order address bits 
hardware shared memory schemes shared region di erent segment set 
avoid incorrect shared pointer comparisons sandboxed code shared memory creation interface ensure shared object unique address 
distrusted object code accesses shared memory sandboxing code automatically translates shared addresses corresponding addresses fault domain data segment 
translation works exactly hardware translation low bits address remain high bits set data segment identi er 
operating systems allow virtual address aliasing implement shared regions introducing new software encapsulation technique shared segment matching 
implement sharing dedicated register hold bitmap 
bitmap indicates segments fault domain access 
unsafe instruction checked shared segment matching requires instruction segment matching 
implementation veri cation identi ed strategies implementing software encapsulation 
approach uses compiler emit encapsulated object code distrusted module integrity code veri ed module loaded fault domain 
alternatively system encapsulate distrusted module directly modifying object code load time 
wehave techniques perform general protection encapsulating load instructions store jump instructions 
discuss performance variants section 
current prototype uses rst approach 
modi ed version gcc compiler perform software encapsulation 
note current implementation language dependent techniques language independent 
built veri er mips instruction set works sandboxing segment matching 
main challenge veri cation presence indirect jumps execution may instruction code segment 
address situation veri er uses property software encapsulation techniques unsafe stores jumps dedicated register form target address 
veri er divides program sequences instructions called unsafe regions 
unsafe store region begins modi cation dedicated store register 
unsafe jump region begins modi cation dedicated jump register 
rst instruction unsafe store jump region executed subsequent instructions guaranteed executed 
unsafe store region ends hold instruction store uses dedicated register form target address instruction control transfer instruction instruction guaranteed executed instructions code segment 
similar de nition unsafe jump regions 
veri er analyzes unsafe store jump region insure dedicated register modi ed region valid exit region 
example load dedicated register begins unsafe region 
region appropriately dedicated register unsafe region deemed safe 
unsafe region veri ed code rejected 
incorporating software encapsulation existing compiler able take advantage compiler infrastructure code optimization 
approach disadvantages 
modi ed compilers support programming language gcc supports pascal 
second compiler veri er synchronized respect particular encapsulation technique employed 
alternative called binary patching alleviates problems 
fault domain loaded system encapsulate module directly modifying object code 
unfortunately practical robust binary patching resulting cient code currently possible lb 
tools translate binary format built tools rely compiler speci idioms distinguish code data processor emulation handle unknown indirect jumps 
software encapsulation main challenge transform code uses subset registers major components cross fault domain rpc 
ing registers available dedicated 
solve problem working binary patching prototype uses simple extensions current object le formats 
extensions store control ow register usage information su cient support software encapsulation 
low latency cross fault domain communication purpose reduce cost fault isolation cooperating software modules 
section half solution cient software encapsulation 
section describe half fast communication fault domains 
illustrates major components domain rpc trusted distrusted fault domain 
section concentrates aspects fault domain crossing 
describe simple mechanism allows fault domain safely call trusted stub routine outside domain stub routine safely calls destination domain 
second discuss arguments ciently passed fault domains 
third detail registers machine state managed cross fault domain rpcs insure fault isolation 
protocol exporting naming procedures fault domains independent techniques 
way control escape fault domain jump table 
jump table entry control transfer instruction target address legal entry point outside domain 
instructions target address immediate encoded instruction jump table rely dedicated register 
table kept read code segment modi ed trusted module 
pair fault domains customized call return stub created exported procedure 
currently stubs generated hand stub generator 
stubs run unprotected outside caller callee domain 
stubs responsible copying cross domain arguments domains managing machine state 
stubs trusted able copy call arguments directly target domain 
traditional rpc implementations address spaces typically perform copies transfer data 
arguments message kernel copies message target address space nally callee de marshall arguments 
having caller callee communicate shared bu er lrpc uses single copy pass data domains ball 
stubs responsible managing machine state 
cross domain call registers caller potentially modi ed callee protected 
registers designated architectural convention preserved procedure calls saved 
optimization callee domain contains instructions modify preserved register avoid saving 
karger uses trusted linker perform kind optimization address spaces kar 
addition saving restoring registers stubs switch execution stack establish correct register context software encapsulation technique validate dedicated registers 
system robust presence fatal errors example addressing violation executing fault domain 
current implementation uses unix signal facility catch errors terminates outstanding call noti es caller fault domain 
application uses operating system thread fault domains way terminate call long example nite loop 
trusted modules may timer facility execution periodically determine call needs terminated 
performance results evaluate performance software enforced fault domains implemented measured prototype system mhz decstation mhz alpha dec alpha 
consider questions 
head software encapsulation incur 
second fast cross fault domain rpc 
third performance impact software enforced fault isolation user application 
discuss questions turn 
encapsulation overhead measured execution time overhead sandboxing wide range programs including spec benchmarks splash benchmarks ass swg 
treated benchmark distrusted module sandboxing code 
column table reports overhead dec mips column reports overhead 
columns report overhead technique provide general protection sandboxing load instructions store jump instructions detailed section sandboxing requires dedicated registers 
column reports overhead removing registers possible compiler 
overheads computed additional execution time divided original program execution time 
dec mips program measurement tools pixie qpt calculate number additional instructions executed due sandboxing dig bl 
column table reports data percentage original program instruction counts 
data table appears contain number anomalies 
benchmark programs example ear dec mips compress dec alpha sandboxing reduced execution time 
number cases overhead surprisingly low 
identify source variations developed analytical model execution overhead 
model predicts overhead number additional instructions executed due sandboxing instructions oating point interlock cycles interlocks 
sandboxing increases available instruction level parallelism allowing number oating point interlocks substantially reduced 
integer pipeline provide interlocking delay slots explicitly lled nop instructions compiler assembler 
scheduling ects integer instructions accurately re ected count added instructions 
expected overhead computed instructions interlocks cycles second original execution time seconds loads libraries standard library sandboxed 
model provides ective separate known sources overhead second order ects 
column predicted overheads 
seen table model average ective predicting sandboxing overhead 
di erences measured expected overheads normally distributed mean standard deviation 
di erence means measured expected overheads statistically signi cant 
experiment demonstrates combining instruction count overhead oating point interlock measurements accurately predict average execution time overhead 
assume model accurate predicting overhead individual benchmarks conclude second order ect creating observed anomalies measured overhead 
discount ective instruction cache size virtual memory paging sources observed execution time variance 
sandboxing adds instructions ective size instruction cache reduced 
account measured overheads higher predicted account opposite ect 
benchmarks compute bound variations due virtual memory paging 
dec mips physically indexed physically tagged direct mapped data cache 
experiments sandboxing ect size contents starting virtual address data segment 
original sandboxed versions benchmark programs successive runs showed insigni 
di cult quantify believe data cache alignment important source variation experiments 
conjecture observed variations caused instruction cache mapping con icts 
software encapsulation changes mapping instructions cache lines changing number instruction cache con icts 
number researchers investigated minimizing instruction cache con icts reduce execution time mcf ph sam 
researcher reported performance gain simply changing order object les linked ph 
samples hil nger report significantly improved instruction cache rates rearranging application basic blocks sam 
ect statistically signi cant di erences programs 
average programs contained signi cant percentage oating point operations incurred overhead 
mean overhead oating point intensive benchmarks compared mean remaining benchmarks 
benchmarks dec mips dec alpha fault protection reserved instruction fault fault protection benchmark isolation overhead register count isolation isolation overhead overhead overhead overhead overhead overhead predicted alvinn fp bps fp cholesky fp compress int ear fp eqntott int espresso int gcc int na na li int locus int mp fp int qcd fp sc int na na tracker int water fp average table sandboxing overheads dec mips dec alpha platforms 
benchmarks gcc sc dependent pointer size bits compile dec alpha 
predicted fault isolation overhead cholesky negative due conservative interlocking mips oating point unit 
compute intensive 
programs perform signi cant amounts incur overhead 
fault domain crossing cost cross fault domain rpc 
rpc mechanism spends time saving restoring registers 
detailed section registers designated architecture preserved procedure calls need saved 
addition instructions callee fault domain modify preserved register need saved 
table reports times versions null cross fault domain rpc 
column lists crossing times data registers caller saved 
column lists crossing times preserved integer registers saved 
times listed column include saving preserved oating point registers 
cases crossing times reduced statically partitioning registers domains 
comparison measured calling mechanisms 
measured time perform procedure call takes arguments returns value 
second sent single byte address spaces pipe abstraction provided native operating system measured roundtrip time 
times reported columns table 
platforms cost cross address space calls roughly orders magnitude expensive local procedure calls 
operating systems highly optimized rpc implementations reduced cost cross rpc roughly orders magnitude local procedure calls 
mach space rpc mhz decstation times expensive local procedure call ber 
spring operating system running mhz sparcstation delivers cross address space rpc times expensive local leaf procedure call hk 
software enforced fault isolation able reduce relative cost cross rpc order magnitude systems 
fault domains postgres capture ect system application performance added software enforced fault domains postgres database management system measured postgres running sequoia benchmark 
sequoia benchmark cross fault domain rpc platform caller save save pipes save integer integer float procedure registers registers registers call dec mips dec alpha table cross fault domain crossing times 
sequoia untrusted software enforced number dec mips pipe query function manager fault isolation cross domain overhead overhead overhead calls predicted query query query query table fault isolation overhead postgres running sequoia benchmark 
contains queries typical earth scientists studying climate 
support kinds non traditional queries postgres provides type system 
currently user de ned types written conventional programming languages dynamically loaded database manager 
long recognized serious safety problem sto 
eleven queries sequoia benchmark user de ned polygon data types 
measured queries unprotected dynamic linking software enforced fault isolation 
postgres code trusted sandboxed dynamically loaded user code 
experiment cross fault domain rpc mechanism saved preserved integer registers variant corresponding column table 
addition instrumented code count number domain rpcs estimate performance fault isolation separate address spaces 
table presents results 
untrusted user de ned functions postgres separate calling mechanism built functions 
column lists overhead untrusted function manager software enforced fault domains 
reported overheads table relative original postgres untrusted function manager 
column reports measured overhead software enforced fault domains 
number cross domain calls listed column dec mips pipe time reported table column lists estimated overhead conventional hardware address spaces 
analysis postgres experiment software encapsulation provided substantial savings native operating system services hardware address spaces 
general savings provided techniques hardware mechanisms function percentage time spent distrusted code td percentage time spent crossing fault domains tc overhead encapsulation ratio fault domain crossing time crossing time competing hardware rpc mechanism 
savings tc htd graphically depicts trade axis gives percentage time application spends crossing fault domains 
axis reports relative cost software enforced fault domain crossing hardware address spaces 
assuming execution time overhead encapsulated code shaded region illustrates software enforced fault isolation better performance alternative 
software enforced fault isolation increasingly attractive applications achieve higher degrees fault isolation see 
example application spends time crossing fault domains rpc mechanism need perform better competitor 
applications currently spend little time crossing require improvement fault domain crossing time 
reported section crossing time dec alpha aaaa crossing time relative existing rpc aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa percentage execution time spent crossing shaded region represents software enforced fault isolation provides better performance alternative 
axis represents percentage time spent crossing fault domains tc 
axis represents relative rpc crossing speed 
curve represents break point tc htd 
graph encapsulation overhead dec mips dec alpha 
example hardware address space crossing time dec mips dec alpha provide better performance software fault domains 
far know production experimental system currently provides level performance 
assumes entire application encapsulated 
applications postgres assumption conservative 
transforms previous gure assuming total execution spent distrusted extension code 
figures illustrate software enforced fault isolation best choice crossing overhead signi cant proportion application execution time 
demonstrates overhead due software enforced fault isolation remains small regardless application behavior 
plots overhead function crossing behavior crossing cost 
crossing times typical highly optimized hardware rpc mechanisms shown 
graph illustrates relative performance stability software solution 
stability allows system developers ignore performance ect fault isolation choosing modules place separate fault domains 
related systems considered ways optimizing rpc performance ta bla sb hk ball ball 
traditional rpc systems crossing time relative existing rpc aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaa percentage execution time spent crossing shaded region represents software enforced fault isolation provides better performance alternative 
axis represents percentage time spent crossing fault domains tc 
axis represents relative rpc crossing speed 
curve represents break point tc htd 
graph encapsulation overhead dec mips dec alpha 
percentage execution time spent crossing ultrix context switch decstation hardware minimum crossings software percentage time spent crossing code versus number fault domain crossings millisecond dec mips 
hardware minimum crossing number taken cross architectural study context switch times 
ultrix context switch time reported column table 
hardware fault isolation ultimately limited minimal hardware cost kernel traps hardware context switches 
lrpc rst rpc systems approach limit prototype uses number techniques lrpc systems thread runs caller callee domain stubs kept simple possible crossing code jumps directly called procedure avoiding dispatch callee domain 
systems fault isolation avoids hardware context switches substantially reducing crossing costs 
address space identi er tags reduce hardware context switch times 
tags allow address space share tlb tlb ushed context switch 
estimated cost lrpc fire tags due tlb misses ball 
address space tags reduce cost register management system calls operations scaling integer performance 
important advantage fault isolation rely specialized architectural features address space tags 
restrictive programming languages provide fault isolation 
pilot requires kernel user library code written mesa strongly typed language code shares single address space rdh 
main disadvantage relying strong typing severely restricts choice programming languages ruling conventional languages assembly 
strongly typed languages ada modula programmers nd need loopholes type system undercutting fault isolation 
contrast techniques language independent 
deutsch built system allowed user de ned measurement modules dynamically loaded operating system executed directly processor dg 
module format stylized native object code designed easier statically verify code violate protection boundaries 
interpreter provide failure isolation 
example bsd unix network packet lter utility de nes language operating system network driver 
interpreter insulates operating system possible faults customization code 
approach allows code written programming language safely encapsulated rejected safe executed near full speed operating system 
anonymous rpc exploits bit address spaces provide low latency rpc probabilistic fault isolation 
logically independent domains placed random locations hardware address space 
calls domains anonymous reveal location caller callee side 
provides probabilistic protection domain able discover location domain malicious accidental memory probes 
preserve anonymity cross domain call trap protected code kernel hardware context switch needed 
summary software mechanism portable programming language independent fault isolation cooperating software modules 
providing fault isolation single address space approach delivers cross fault domain communication order magnitude faster rpc mechanism date 
prevent distrusted modules escaping fault domain software encapsulation technique called sandboxing incurs execution time overhead 
despite overhead executing distrusted code software fault isolation yield best application performance 
extensive kernel optimizations reduce overhead hardware rpc factor software alternative 
situation software fault isolation better performance choice overhead hardware rpc greater 
brian bershad mike burrows john hennessy peter kessler butler lampson ed lazowska dave patterson john ousterhout oliver sharp richard sites alan smith mike stonebraker helpful comments 
jim larus provided pro ling tool qpt 
mike olson paul aoki helping postgres 
acd adam chandy dickson 
comparison list schedules parallel processing systems 
communications acm december 
thomas anderson henry levy brian bershad edward lazowska 
interaction architecture operating system design 
proceedings th international conference support programming languages operating systems pages april 
ass administrator national computer graphics association 
spec newsletter december 
asu ball ball ber bl bla bn alfred aho ravi sethi je rey ullman 
compilers principles techniques tools 
addison wesley publishing 
brian bershad thomas anderson edward lazowska henry levy 
lightweight remote procedure call 
acm transactions computer systems february 
brian bershad thomas anderson edward lazowska henry levy 
user level interprocess communication shared memory multiprocessors 
acm transactions computer systems may 
brian bershad august 
private communication 
thomas ball james larus 
optimally pro ling tracing 
proceedings conference principles programming languages pages 
david black 
scheduling support concurrency parallelism mach operating system 
ieee computer may 
andrew birrell bruce nelson 
implementing remote procedure calls 
acm transactions computer systems february 
cla clark 
window programmer guide ole dde 
prentice hall 
dg deutsch 
exible measurement tool software systems 
ifip congress 
dig digital equipment 
ultrix pixie manual page 
fp peter dyson 
xpress modular software custom systems 
report desktop publishing june 
kevin fall joseph pasquale 
exploiting data paths improve throughput cpu 
proceedings winter usenix conference pages january 
hc david cheriton 
application controlled physical memory external page cache management 
proceedings th international conference support programming languages operating systems october 
hk graham hamilton panos 
spring nucleus microkernel objects 
proceedings summer usenix conference pages june 
hkm howard kazar menees nichols satyanarayanan sidebotham west 
scale performance distributed file system 
acm transactions computer systems february 
int intel santa clara california 
intel programmer manual 
michael jones richard rashid mary thompson 
matchmaker interface speci cation language distributed processing 
proceedings th acm sigact sigplan symposium principles programming languages pages january 
kar kle paul karger 
registers optimize cross domain call performance 
proceedings rd international conference architectural support programming languages operating systems pages april 
steven kleiman 
vnodes architecture multiple file system types sun unix 
proceedings summer usenix conference pages 
lb james larus thomas ball 
rewriting executable les measure program behavior 
technical report university wisconsin madison march 
mcf scott mcfarling 
program optimization instruction caches 
proceedings international conference architectural support programming languages operating systems pages april 
mj steven mccanne van jacobsen 
bsd packet filter new architecture user level packet capture 
proceedings winter usenix conference january 
mra mogul rashid accetta 
packet lter cient mechanism user level network code 
proceedings symposium operating system principles pages november 
ph karl pettis robert hansen 
pro le guided code positioning 
proceedings conference language design implementation pages white plains new york june 
appeared sigplan notices 
rdh david redell dalal thomas hugh lauer william lynch sam sb paul mcjones hal murray stephen purcell 
pilot operating system personal computer 
communications acm february 
samples 
code reorganization instruction caches 
technical report ucb csd university california berkeley october 
michael schroeder michael burrows 
performance fire rpc 
acm transactions computer systems february 
richard sites anton cherno matthew kirk maurice marks scott robinson 
binary translation 
communications acm february 
stonebraker 
sequoia benchmark 
proceedings acm sigmod international conference management data may 
sto michael stonebraker 
extensibility post 
ieee database engineering september 
sto michael stonebraker 
inclusion new types relational data base systems 
michael stonebraker editor readings database systems pages 
morgan kaufmann publishers 
swg singh weber gupta 
splash stanford parallel applications shared memory 
technical report csl tr stanford 
ta shin yuan david anderson 
performance evaluation dash message passing system 
technical report ucb csd computer science division university california berkeley october 
thi thinking machines 
cm network interface programmer guide 
von eicken culler goldstein schauser 
active messages mechanism integrated communication computation 
proceedings th annual symposium computer architecture 
robbert van renesse hans van staveren andrew tanenbaum 
performance world fastest distributed operating system 
operating systems review october 
web neil webber 
operating system support portable filesystem extensions 
proceedings winter usenix conference january 
curtis richard thomas anderson 
anonymous rpc low latency protection bit address space 
proceedings summer usenix conference june 
