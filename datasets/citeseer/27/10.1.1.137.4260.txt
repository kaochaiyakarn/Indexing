ieee transactions software engineering vol 
february dynamically discovering program invariants support program evolution michael ernst jake cockrell william griswold member ieee david notkin senior member ieee computer society explicitly stated program invariants help programmers identifying program properties preserved modifying code 
practice invariants usually implicit 
alternative expecting programmers fully annotate code invariants automatically infer invariants program 
research focuses dynamic techniques discovering invariants execution traces 
article reports results 
describes techniques dynamically discovering invariants implementation named daikon embodies techniques 
second reports application daikon sets target programs 
programs gries program derivation system rediscovered predefined invariants 
program lacking explicit invariants system discovered invariants assisted software evolution task 
experiments demonstrate small programs invariant inference accurate useful 
third analyzes scalability issues invariant detection runtime accuracy functions test suites program points instrumented 
index terms program invariants formal specification software evolution dynamic analysis execution traces logical inference pattern recognition 
invariants play central role program development 
representative uses include refining specification correct program statically verifying properties type declarations runtime checking invariants encoded assert statements 
invariants play equally critical role software evolution 
particular invariants protect programmer making changes inadvertently violate assumptions program correct behavior depends 
near absence explicit invariants existing programs easy programmers introduce errors making changes 
alternative expecting programmers annotate code invariants automatically infer invariants 
research focuses dynamic discovery invariants technique execute program collection inputs infer invariants captured variable traces 
fig 
shows architecture daikon invariant detector 
dynamic approaches testing profiling accuracy inferred invariants ernst department electrical engineering computer science laboratory computer science massachusetts institute technology massachusetts ave cambridge ma 
mail lcs mit edu 
cockrell macromedia redwood parkway redwood city ca 
mail macromedia com 
griswold department computer science engineering university california san diego la jolla ca 
mail cs ucsd edu 
notkin department computer science engineering university washington box seattle wa 
mail notkin cs washington edu 
manuscript received nov revised apr accepted may 
recommended acceptance garlan 
information obtaining reprints article please send mail tse computer org ieeecs log number 
ieee depends part quality completeness test cases additional test cases provide new data accurate invariants inferred 
inference invariants program traces application software evolution raises number technical questions 
invariants detected 
inference process fast 
kind test suite required infer meaningful invariants 
techniques minimize irrelevant invariants aid programmer task hand 
required information extracted program runs 
programmers productively inferred invariants software evolution 
article provides partial answers questions form results stemming initial experiences approach 
result set techniques discovering invariants execution traces prototype invariant detector daikon implements techniques 
invariants detected program executions instrumenting source program trace variables interest running instrumented program set test cases inferring invariants instrumented variables derived variables manifest original program 
essential idea test set possible invariants values captured instrumented variables invariants tested sufficient degree falsification reported programmer 
section discusses invariant detection engine discussion instrumentation deferred section 
second result application daikon sets target programs 
set programs appear science programming 
programs derived formal preconditions postconditions loop invariants 
runs program randomly generated ieee transactions software engineering vol 
february fig 

architecture daikon tool dynamic invariant inference 
inputs daikon discovers program properties plus additional ones introduce result motivation section 
experiment demonstrates dynamic invariant detection produces invariants accurate 
second set programs programs originally siemens modified rothermel harrold annotated invariants indication invariants explicitly construction 
section shows numeric invariants dynamically inferred programs assisted understanding changing 
scenario shows dynamic invariant discovery complementary static techniques examine program text run program 
second experiment demonstrates dynamic invariant detection produces invariants useful 
third result section quantitative analysis scalability issues 
analysis demonstrates inference running time linearly correlated number program points traced square number variables scope program point size test suite 
choices program points variables detect invariants control invariant detection time 
potential invariants quickly falsified contributing little runtime 
experiments test suite selection suggest set invariants inferred tends stabilize growing test suite size reducing need large test suites limiting inference time 
section correlates number invariants program correctness 
section discusses initial concerning adequacy automatically generated test suites invariant inference 
section surveys related section discusses ongoing section concludes 
rediscovery invariants introduce dynamic invariant detection illustrate daikon output invariants detected simple program taken science programming book deriving programs specifications 
typical programs may difficult determine desired output invariant detection book programs include preconditions postconditions loop invariants embody properties computation author considered important 
specifications form gold standard invariant detector judged 
programs ideal initial tests system 
daikon successfully reports formally specified preconditions postconditions loop invariants chapters book 
success feel need continue exercise chapters 
chapter containing programs previous chapters underlying mathematics methodology 
programs perform simple tasks searching sorting changing multiple variables consistently computing gcd 
investigate programs invariants described pictures informal text mathematical predicates 
programs quite small built simple test suites 
experiments intended conclusive initial test 
programs small show full article complete daikon output 
additionally illustrate number important issues invariant detection 
simple example invariant detection consider program sums elements array fig 

program dialect lisp enhanced gries style control constructs nondeterministic conditionals 
daikon lisp instrumenter section added code writes variable values data trace file code automatically inserted program entry enter loop head loop program exit exit 
ran instrumented program randomly generated arrays length element random number range fig 

gries array sum program program formal specification 
program sums values array length result variable statement parallel simultaneous assignment values right hand side variables left hand side 
od form repeatedly evaluates condition left hand side true evaluates body right hand side execution form terminates condition evaluates false 
ernst dynamically discovering program invariants support program evolution fig 

invariants inferred gries array sum program fig 
randomly generated input arrays 
invariants shown entry precondition exit postcondition program loop head loop invariant 
daikon successfully rediscovered invariants program formal specification fig 
goal invariants boxed emphasis 
shorthand size element array orig var represents var value start procedure execution 
invariants elements array listed indented array example array multiple elementwise invariants 
number samples right hand column number times program point executed loop iterates multiple times test case generating multiple samples 
counts values right hand column indicate distinct variable values encountered 
instance program exited times boxed postcondition sum indicates variable sum distinct final values executions 
inclusive 
fig 
shows output daikon invariant detector data trace file 
best realistic test suite happens tried testing daikon 
results illustrate potential shortcomings approach motivate improvements handle 
fig 
shows daikon output array sum program run different test suite 
sections discuss selection test suites 
preconditions invariants enter program point fig 
record length array falls inclusive array elements 
invariant size fig 

invariants inferred gries array sum program fig 
input set array lengths element values chosen exponential distributions expected array lengths element values uniform distributions fig 

invariants fig 
specific test suite appear output 
crucial correctness program omitted formal invariants stated gries 
gries stated precondition implied boxed output shorthand 
postconditions exit program point include gries postcondition sum section describes inference functions sum 
addition daikon discovered remain unchanged words program side effects variables 
loop invariants loop program point include gries 
additional invariants bounds maximum value array elements complement minimum value noted precondition postcondition invariants 
section discusses reported loop invariant preconditions postconditions shows eliminate 
fig 
invariants appear part formal specification program book boxed emphasis 
invariants split categories 
invariants erroneously omitted formal specification detected daikon size 
second properties test suite 
invariants provide valuable information data set help validate test suite indicate usage context function computation 
third extraneous probably uninteresting invariants discussed section eliminated 
example daikon detected size property holds test cases written satisfy intent author clear book 
ieee transactions software engineering vol 
february express intent postcondition size 
code different way sum part array precondition size existing postcondition 
different test suite indicate uses program 
fact daikon fundamental invariants gries programs including crucial ones specified gries demonstrates potential dynamic invariant detection 
toy program small exhaustively discuss article static analysis produce result 
static analysis report true undecidable properties properties program context 
furthermore static analysis language features pointers remains state art difficulty representing heap forces precision losing approximations 
dynamic analysis suffer drawbacks complements static analysis 
section shows daikon application realistic program constructed formal invariants 
section describes daikon operates 
inferring invariants principal challenges inferring invariants previous section choosing invariants infer performing inference 
third challenge capturing program behavior inference discussed section 
daikon infers invariants specific program points procedure entries exits optionally loop heads 
instrumented program provides daikon execution program point values variables scope 
daikon checks invariants involving single variable constraint holds values multiple variables relationship values variables 
invariants follows variables computed constants invariants variable constant value indicates variable constant 
uninitialized uninit indicates variable set 
small value set fa cg indicates variable takes small number different values 
invariants single numeric variable range limits printed indicate minimum maximum value 
nonzero indicates variable set see section details invariant reported 
modulus mod indicates mod holds 
mod reported mod takes value invariants numeric variables linear relationship ax ordering comparison functions fn fn fn python built unary functions absolute value negation bitwise complement additional functions trivial add 
invariants invariant list invariants single numeric variable mod 
invariants subsumes ordering comparisons permit inference properties daikon prints invariants numeric variables linear relationship ax ax bz ay bz functions fn fn python built binary functions min max multiplication greatest common divisor comparison exponentiation floating point rounding division modulus left right shifts additional functions trivial add 
permutations hx zi tested permutations symmetric functions listed parenthesis semicolon permutations nonsymmetric functions 
invariants single sequence variable range minimum maximum sequence values ordered lexicographically instance indicate range string array values 
element ordering elements sequence nondecreasing nonincreasing equal case sequence contains multiple instances single value value may differ sequence sequence 
invariants sequence elements treated single large collection example fig 
elements array 
sum invariants fig 
appear sum derived variable described section 
invariants sequence variables linear relationship ax elementwise 
comparison performed lexicographically 
subsequence relationship subsequence vice versa 
reversal reverse invariants sequence numeric variable membership variable tuple variables potential invariant instantiated tested 
instance variables potential unary invariant checked potential binary invariant checked hx yi hx zi hy zi ernst dynamically discovering program invariants support program evolution potential ternary invariant checked hx zi 
potential invariant checked examining sample turn sample tuple values instrumented variables program point stemming execution program point 
soon sample satisfying invariant encountered invariant known hold checked subsequent samples invariants may continue checked 
cost computing invariants tends proportional number invariants discovered see section 
simple example consider code int int int return procedure exit value tuples include line shown orig orig orig return value trace admits invariants including orig orig orig return invariants listed inexpensive test require full fledged theorem proving 
example linear relationship ay bz unknown coefficients variables degrees freedom 
consequently linearly independent tuples values sufficient determine coefficients checking requires arithmetic operations equality check 
example inexpensive checking common modulus variable mod greatest common divisor differences list elements 
reduce source language dependence simplify implementation improve error checking daikon supports forms data scalar number including characters booleans sequence scalars trace values converted forms 
example array tree nodes left right child converted arrays left containing object ids left children right right children 
design choice avoids overhead interpretation data structure information 
declared types recorded separate file mapping program types limited set conflate different types 
invariants original objects recovered daikon output computes invariants arrays finding relationships ith element 
example left right reported left right post processing step easily convert representation referring original program type declarations 
produced list potential invariants proposing basic set invariants natural generally applicable programming specification experience 
added invariants helpful analyzing programs believed generally useful experiments biasing experiments tuning daikon specific programs 
removed original list invariants turned useful practice anticipated 
list include invariants programmers find useful 
instance daikon follow arbitrary length paths recursive data structures see section 
daikon compute invariants linear relationship variables test data structure red black tree invariant 
omitting invariants controls cost complexity section notes number invariants checked significantly affect daikon runtime 
general balanced performance general utility reported invariants 
time expect modify daikon list invariants comments users improvements underlying inference technology 
users easily add domain specific invariants derived variables section writing small amount code 
current list useful enabled successful detection gries invariants useful invariants siemens suite section 
invariants viewed forming lattice subsumption logical implication 
implementation takes advantage relationships order improve performance intelligibility output see section 
additional advantage gained formalizing lattice 
invariant confidence invariants reported 
unique value tuples program point program point executed times frequently executed variable values relationships distinct variable values may mere coincidences properties held test runs 
reporting spurious invariants discourage programmers looking list better supported invariants 
simple solution problem better test suite 
larger complete test suite include counterexamples coincidental properties hold smaller test sets 
generating ideal test suites difficult see sections improve invariant detection output deficient test suites daikon includes method computing invariant confidences 
detected invariant daikon computes probability property appear chance random input 
probability smaller user ieee transactions software engineering vol 
february specified confidence parameter property considered reported 
words daikon assumes distribution performs statistical test attempt null hypothesis states observed values generated chance distribution 
null hypothesis rejected certain level confidence observed values unusual property worth reporting 
probability limit confidence likelihood reported invariants correct possible inputs decide particular invariant worth reporting user 
purposes article part demonstrate spurious invariants fig 
set probability limit report invariants percent occurred chance 
actual recommend substantially smaller value system checks millions potential invariants reporting thousands spurious invariants unacceptable 
concrete example statistical test suppose reported values variable fall range size includes suppose ranges test cases 
values uniformly distributed probability single instance samples probability probability userdefined confidence level invariant reported 
tests non modulus tests analogous 
example ranges numeric variables reported appear 
limit reported values near range extrema appear expected distribution appears uniform stops observed minimum maximum extremum appears expected greater lesser values clipped value 
random arrays experiment fig 
happened support boundedness inference elements 
second run arrays selected distribution bounds inferred larger test suites bounds inferred 
fig 
shows result running daikon different set arrays output precisely gries invariants 
figs 
invariants reported loop head procedure entry exit array values visible program points 
reason samples insufficient support inequality inferences loop head executed times 
subsequently enhanced implementation record variable set time program point encountered counting occurrence particular variable value eliminates extra loop invariants figs 

details reported 
derived variables computing invariants manifest program variables inadequate programmer needs 
instance array integer scope may interest expression source code variable may appear program text 
daikon adds certain derived variables expressions list input 
derived variables derived sequence length number elements size 
extremal elements size size reported brevity negative indices suggest indexing sequence 
including second penultimate elements addition accommodates header nodes distinguished uses extremal elements 
derived numeric sequence sum sum minimum element min maximum element max 
derived sequence numeric variable element index example 
element specified index element immediately preceding introduced derived variables programmers maximum valid index limit invalid index 
subsequences notation indicates portion spanning indices inclusive 
case subsequences introduced numbers may indicate maximum valid index length 
derived function invocations number calls far 
daikon computes running count trace file 
daikon treats derived variables just variables permitting infer invariants hard coded list 
instance size derived sequence system report invariant size hard coding comparison check case scalar length sequence 
implementation report compound relations necessarily anticipate 
variable derivation invariant inference avoid unnecessary examining invariants 
derived variables introduced invariants computed previously existing variables derived variables introduced stages 
instance ernst dynamically discovering program invariants support program evolution sequence derived variable size introduced invariants computed variables derived size sense creating derived variable 
derived variable sensible valid index derivations performed 
likewise size identical need derived 
derived variables guaranteed certain relationships variables instance member length 
daikon compute report tautologies 
likewise variables determined equal chosen canonical removed pool variables derived analyzed reducing computation time output size 
deriving variables derived variables eventually create arbitrary number new variables 
order avoid system introducing baroque unhelpful variables daikon halts derivation fixed number iterations limiting depth potential derivation number derived variables 
invariants discussed section dynamic invariant detection accurately rediscovered known invariants gries programs 
section reports second experiment indicates inferred invariants substantial assistance understanding modifying testing program contains explicitly stated invariants 
determine derived invariants aid program modification programmers working team modified program siemens suite modified rothermel harrold traditional tools invariants produced prototype invariant detector daikon 
section lays task describes programmers activity modifying program discusses invariants qualitatively different traditional styles gathering information programs 
task siemens replace program takes regular expression replacement string command line arguments copies input stream output stream replacing substring matched regular expression replacement string 
replace program consists lines code contains procedures 
program comments documentation regrettably typical real world programs 
regular expression language replace includes kleene closure omits kleene closure decided useful realistic extension 
preparation change instrumented ran replace test cases randomly selected provided siemens suite 
resulting trace daikon produced invariants entry exit procedure 
provided output programmers making change worked completely independently 
described fig 

function constant closure siemens program replace 
dynamically detected invariants traditional tools techniques useful 
performing change programmers began studying program call structure high level definitions essentially static analysis composed pattern parser pattern compiler matching engine 
avoid modifying matching engine minimize changes parser decided compile input pattern form semantically equivalent 
initial changes straightforward informal program inspection manual analysis 
particular simple text searches helped programmers find handled parsing 
mimicked constant closure value new constant pclosure plus closure value simple changes adding pclosure sets represent special classes characters functions set pat set 
studied closure function handle pclosure analogously 
basic code fig 
determines character input closure calls star closure function fig 
conditions exceptions differ plus closure 
programmers duplicated code sequence modifying copy check pclosure call new function 
initial body copy body 
determine appropriate modifications programmers studied 
initial static study program determined compiled pattern stored element array named pat 
speculated uses array pat loop manipulate pattern target closure operator adding characters compiled pattern function 
programmers wanted verify loop entered call 
depend called depend turn unstated assumptions legal call decided examine invariants attempt global static analysis ieee transactions software engineering vol 
february fig 

function siemens program replace 
template new function fig 

program 
initialization exit conditions loop imply loop entered equal examined invariants inferred variables entry third invariant implies loop body executed jp initialized loop body entered inconsistent programmers initial belief 
find offending values queried trace database calls cases loop entered 
daikon includes tool takes input program point constraint produces output tuples execution trace database satisfy optionally falsify constraint program point 
query returned calls value exceeding size array pat 
programmers soon determined instances compiled pattern long resulting array bounds error 
error apparently noticed previously despite test suite test cases 
excluding exceptional situations loop body executes function called increasing programmers confidence loop manipulates pattern closure operator applied 
allow proceed kleene extension fixing bug recomputed invariants test cases caused improper calls 
studying manipulation array pat fig 
carefully observed loop index decremented pat read written fig 

closure character inserted array compiled pattern index 
looking invariants pat pat orig pat indicates pat updated 
determine pat queried trace database values pat entry exit 
example test case replace ab values parameter pat calls value pat value pat ca cb suggests program compiles literals prefixing character puts kleene expressions prefix form 
authors independently discovered fact careful study program text 
compiled pattern ca cb ca stands character cb stands character modifies cb 
negative indexing assignment position moves closed pattern rightward array room prefix 
call result test case cb match instances character zero 
new implementation kleene requires duplicating previous pattern shifting rightward kleene implementation bit simpler 
figuring doing address index passed increments index array bound exceeded programmers converged version fig 

check modified program violate invariants hold added test cases kleene recomputed invariants modified program 
expected invariants remained unchanged differing invariants verified program modifications 
invariant orig invariant orig 
difference expected compilation kleene replicates entire target pattern characters long ernst dynamically discovering program invariants support program evolution fig 

function siemens program replace 
compiled form 
invariants process changing replace programmers investigated invariants discovered function 
determining called learn new called invariants showed parameter start tested fig 
parameter controls outer loop null character character 
invariants indicated specialized contexts saving considerable effort understanding role pattern compilation 
programmers reported doing mental partial evaluation order understand specific function program 
programmers hypothesized lj local lj refer different times generated element compiled pattern refers place append 
invariants confirmed relation invariant lj reported 
query trace database exit returned cases lj contradicted programmers expectations prevented introducing bugs flawed understanding code 
inferred invariant calls set calls set called predicate controlling invocation see fig 
equal number calls indicates test cases caused set return false 
helping modify program invariant indicates property particular test cases 
suggests need run replace provided test cases better expose replace special case behavior produce accurate invariants see section 
invariant uses task adding kleene operator siemens replace program dynamically detected invariants played number useful roles 
explicated data structures 
invariants queries invariant database helped explicate undocumented structure compiled regular expressions program represents strings 
confirmed contradicted expectations 
function programmers expected lj expectation confirmed increasing confidence understanding program 
second expectation refuted permitting correct misunderstanding preventing introducing bug flawed understanding 
revealed bug 
function programmers expected unrelated 
counterexample property evidenced previously undetected array bounds error 
fig 

function extended replace program 
written copying fig 
modifying copy 
ieee transactions software engineering vol 
february showed limited procedures 
parameters function constant zero 
behavior special case required order perform assigned task easier understand full generality 
demonstrated test suite inadequacy 
number invocations functions constant return value programmers noticed indicated branch taken small test suite 
indicated need expand test suite 
validated program changes 
differences invariants showed respect performing intended 
fact invariants rest program remained identical showed unintended changes changes modified parts program inadvertently affected computations performed unmodified parts program 
discussion dynamically detected invariants convenient effective learned replace program detected combination careful reading code additional static analyses including lexical searches selected program instrumentation insertion printf statements execution debugger 
adding inferred invariants techniques provides qualitative benefits 
inferred invariants succinct abstraction mass data contained data trace 
programmer provided information terms manifest program variables expressions defined program points captures properties hold runs 
invariants provide substantial insight difficult programmer extract manually trace program traditional means 
second inferred invariants provide suitable basis programmer complex inferences 
reported invariants relatively simple concern observable entities program 
programmers prefer told refers place append character compiled pattern level interpretation current capabilities 
programmer examine program text perform supporting analyses better understand implications reported invariants 
example presence related invariants indicating starts zero value regularly incremented compilation pattern allowed programmers quickly determine higher level invariant 
basic nature reported invariants render useless 
third programmers reported seeing inferred invariants led think terms invariants 
believed helped better job fewer errors directly dealing daikon output 
fourth invariants provide beneficial degree serendipity 
scanning invariants reveals facts programmers noticed surely thought check 
example small case expectation program correct thousands tests dynamic invariant detection helped find latent error index exceeded array bounds cases 
ability draw human attention suspicious overlooked aspects code strength approach 
programmer seeking specific piece information aiming verify specific invariant facts code may able dynamic invariant detection advantage get programmer open possibly valuable information 
tools provided daikon proved useful 
queries trace database help programmers delve deeper unexpected invariants appear expected invariants appear 
example inferred invariants contradicted expectations regarding preconditions clarifying information provided supporting data 
revealed bug simplified implementation 
tool invariant comparator reveals sets invariants differ enabling comparison programs versions program test suites settings invariant detector 
verified aspects correctness program change 
technique possible evolve systems previously intractable change 
initial experience inferred invariants shows promise simplifying evolution tasks concisely summarizing program trace data providing means querying trace database additional insight 
scalability time space costs dynamic invariant inference grow number program points variables instrumented number invariants checked number test cases run 
cost inference hard predict 
example daikon generates derived variables analyzing traces derived variables introduced depends trace values 
daikon stops testing invariant soon falsified meaning running time sensitive order variable value tuples examined 
selection test cases ones impact invariants discovered 
section presents results experiments determine costs invariant inference section stability reported invariants test suite increases size section 
largely results experiments section suggests ways accelerate inference improve scalability manage reporting invariants 
performance gain insight performance related scalability issues measured invariant detection runtime siemens replace program 
aimed identify quantitative observable factors user control ernst dynamically discovering program invariants support program evolution manage time space requirements invariant detector 
briefly invariant detection time potentially cubic number variables scope program point total number variables program 
invariants involve variables cubic number potential invariants 
words invariant detection time linear number potential invariants program point 
invariants falsified quickly true invariants need checked entire run invariant detection time program point really linear number true invariants small constant practice 
linear number samples number times program point executed determines sets values variables provided daikon 
value linearly related test suite size cost reduced sampling 
linear number instrumented program points point processed independently 
default case number instrumented program points proportional size program users control extent instrumentation improve performance interest libraries intend focus part program daikon command line parameters permit users skip arbitrary classes functions program points 
informally invariant detection time characterized time vars program vars number variables program point small constant time falsify potential invariant small number true invariants program point size test suite program number instrumented program points 
products multiply count invariants time test invariant 
rest section intuition sketched justifies experiments 
section describes experimental methodology 
section reports number variables scope instrumented program point affects invariant detection time section reports number test cases program runs affects invariant detection time 
section considers factors affect invariant detection time 
instrumented program point processed independently program size affects invariant detection time insofar larger programs afford instrumentation points global variables 
implies analysis portion large program difficult complete analysis smaller program 
methodology instrumented ran siemens replace program subsets test cases supplied program including runs randomly chosen test inputs set subset larger 
ran test cases initial prototype implementation ran memory exceeding mb program point inputs second program point inputs 
replace program procedures instrumentation points routines performs error handling invoked omit henceforth 
implementation reduce space costs substantially different data representation storing tuple values including distinct string array value encountered program 
instance system retain certain witnesses counterexamples query tool checked properties 
witnesses counterexamples help explicate results user asks certain property satisfied trace database described section 
daikon infers invariants average variables original derived scalars sequences instrumentation point replace 
average test cases produce samples instrumentation point current implementation daikon takes seconds infer invariants average instrumentation point 
test cases samples processing takes seconds 
ran experiments mhz pentium ii 
daikon written interpreted language python 
daikon seriously optimized time space point improved performance nearly factor inlining line procedures 
addition local optimizations algorithmic improvements compiled language improve performance order magnitude 
number instrumented variables number variables invariants checked important factor affecting invariant detection runtime 
number variables scope program point total number variables program generally small grow slowly program size global variables introduced 
average functions replace parameters pointers scalar translate checked variables arrays pointers address contents separately invariant detector 
average local variables including return value scope procedure exit replace uses global variables 
number derived variables difficult predict depends values variables described section 
average variables derived original number holds wide variety relative numbers scalars arrays 
statistics number scalars sequences predictive power total number variables 
fig 
plots growth invariant detection time growth number variables 
data point fig 
compares invariant detection times sets variables procedure exit replace element ieee transactions software engineering vol 
february fig 

change invariant detection runtime versus change number variables 
squares trend line highlights relationship value indicating fit 
data point compares inference different sets variables single instrumentation point invariant inference program runs 
test cases graph similar 
run variables runtime variables runtime axis measures test suite 
set variables initial argument values set adds final argument values local variables return value 
larger set times large smaller range axis fig 

absolute number variables ranges 
choice variable sets comparison somewhat arbitrary applied consistently program points produces range ratios sizes sets results repeatable multiple test suite sizes 
test suite run compare inference times different program points different program points executed different numbers times different sample sizes generate different numbers distinct values different value distributions induce different invariants goal measure effect number variables 
fig 
indicates invariant detection time grows approximately quadratically number variables invariants checked 
implied linear relationship ratios 
ratios vr tr linearly related slope vr str tr vr test cases fig 
slope quadratic growth explained fact number possible binary invariants relationships variables quadratic number variables program point 
verify results repeated experiment test suite inputs 
results nearly identical test cases ratios closely fitted straight line slope 
fig 
contains data points 
graphs omit functions invariant detection runtimes second runtime measurement variations produce inaccurate results 
absolute runtimes range seconds 
axis measures equation indicating doubling number variables tends increase runtime factor increasing number variables increases runtime times 
test suite size effect test suite size invariant detection runtime pronounced effect number variables 
fig 
plots growth time growth number test cases program runs program point 
relationships strongly linear 
remaining twelve relationships runtime anomalies varying severity data points largely fall line usually single exception 
timings reproducible isolated cause departures linearity 
midst reimplementing daikon plan repeat experiment new implementation see remain 
runtime part linearly related test suite size divergent lines fig 
show slopes relationships vary considerably 
slopes correlated number original variables variables scope program point total original derived variables variables scalar sequence type measure tested 
know way predict slopes growth runtime test suite size 
factors compared large number factors attempt find formulas relating 
hope relate runtime directly factors user control number test cases users predict invariant detection runtime 
best single predictor invariant detection runtime number pairs values encountered invariant detector fig 
plots linear relationship 
runtime correlated total number values number values variable total number samples test suite size demonstrated ernst dynamically discovering program invariants support program evolution fig 

invariant detection runtime function number test cases program runs 
plot contains data point program point test suite size data points program point 
lines drawn data sets highlight growth runtime test suite size increases 
cases fit number pairs values prediction 
runtime correlated factors products sums factors tried 
number pairs values predictor runtime correlated number values ratio numbers scalar sequence variables predicted factors 
unsurprisingly number samples number times particular program point executed linearly related test suite size number program runs 
number distinct values correlated number samples 
number distinct variable values instrumentation point follows perfectly linear relationship measures new value samples 
expected fewer new values appear runs 
repeated array values rare test suite inputs produced samples function average avoiding high distinct sample ratio expected inputs 
invariant stability key question invariant inference kind large test suite required get reliable useful set invariants 
test cases result small number invariants confidence levels low false invariants falsifying test cases omitted 
running test cases increases inference times linearly demonstrated section 
explore test suite size desirable invariant inference compared pairwise invariants detected replace different numbers randomly selected test cases 
figs 
chart number identical missing different invariants reported test suites smaller test suite subset larger 
missing invariants invariants reported test suites 
daikon detects invariants hold test suite vocabulary invariants forms listed section program variables fields derived variables forms listed section 
invariant holds test suite holds subset test suite 
detected invariant may reported statistically justified section certain circumstances see section 
comparisons invariants reported invariants output user sees 
figs 
separate differences potentially interesting ones probably uninteresting ones 
difference invariants considered uninteresting difference bound variable range invariants indicate different small set possible values called small value set section differences classified potentially interesting 
typical uninteresting invariant range differences differences invariants exit function comparing test suite size size tests values tests values tests values tests values difference bound variable peculiarity data significant difference change programmer conception program operation 
particular case variables indices arrays length 
uninteresting category contains variables values infer general invariant set values differs set runs 
ieee transactions software engineering vol 
february fig 

number pairs values best predictor invariant detection runtime 
number pairs values number distinct hx yi pairs values different variables single sample particular execution program point 
number pairs variables predictable correlated number test inputs number variables 
differences reported figs 
potentially interesting 
example comparing test suite size size difference reported exit tests values tests mod values differences missing invariants may merit closer examination 
examination output revealed substantive differences invariants detecting result case rare far fewer procedure average 
invariants discovered procedure clearly incomparable unrelated quantities comparison integer address elements array different arrays artifacts particular test cases adding mod 
invariant differences result different values pointers uninitialized array elements 
fig 

invariant similarities differences versus test cases siemens replace program 
chart compares invariants computed element test suite invariants computed smaller test suites subsets element test suite 
example minimum value array set runs array contain nonnegative characters 
nonsensical values sum elements string appeared frequently differing invariants 
important directions research include reporting directing user relevant invariants determining invariant differences significant safely ignored 
figs 
number identical unary invariants grows modestly smaller test suite size increases 
identical binary invariants show greater increase particularly jump test cases 
especially comparisons case test suite indications number identical invariants stabilizing indicate asymptotically approaching true set invariants program 
daikon invariants gries listed section experiments similar results 
fig 

invariant similarities differences versus test cases siemens replace program 
chart compares invariants computed element test suite invariants computed smaller test suites subsets element test suite 
ernst dynamically discovering program invariants support program evolution fig 

relevant invariants student pizza distribution programs 
variables program inputs test suite people trying order 
program satisfied invariants 
problem specified cost 
test suite left paying maximal possible number necessarily ordered person receives slices 
invariant embodies requirement fewer leftover pizza slices people eating 
inversely number differing invariants reduced smaller test suite size increases 
unary binary differing invariants drop sharply test cases differences case test set smooth significantly stabilizing differences case test set drop rapidly 
missing invariants follow similar pattern 
dropoff unary invariants largely due fewer uninteresting invariants dropoff binary invariants due fewer interesting invariants 
replace randomly selected test suites knee test cases benefit randomly selected test case greatest range 
result empirically validated reduce cost selecting test cases producing execution traces computing invariants 
figs 
paint somewhat different pictures invariant differences 
differences smaller comparisons element test suite values tend level comparisons element test suite 
percent binary invariants detected case test suites identically number invariants differ noise important differences 
comparisons test case suite numbers drop rapidly test suites approach size 
larger test suite size invariants different missing numbers stabilize quickly 
case test suite appears anomalous comparisons sizes show similarity numbers patterns reported case test suite 
comparisons smaller test suites larger ones larger comparisons omitted functions invariant database ran memory large numbers samples 
preliminary investigations revealed precise cause larger differences case test suite accurately predict sizes invariant differences investigation required order understand phenomena 
fig 

relationship grade number goal invariants fig 
student programs 
instance programs grade exhibited goal invariants programs grade exhibited invariants 
grade perfect score programs exhibited fewer relevant invariants 
invariants program correctness section compares invariants detected large collection programs written specification 
correct versions programs give rise invariants incorrect programs 
examined student programs single assignment introductory programming course university washington cse introductory programming 
grades assigned programs approximate satisfy specification 
perfect measure adherence specification points may deducted poor documentation incorrectly formatted output programs solve problem fair distribution pizza slices computer science students 
number students amount money student possesses number desired program calculates students afford 
program calculates slices student may eat slices remain fair distribution pizza 
manually modified programs test suite remove user interaction standardize variable names 
invariant detection performed executions program resulting invariants program 
invariants detected programs received perfect grades selected relevant invariants listed fig 

list include trivial invariants slices indicating students receive negative number slices uninteresting invariants slices pizza price artifact test cases 
invariants valuable understanding test suites aspects program behavior focus experiment 
fig 
displays number relevant invariants appeared program 
relationship program correctness measured grade number relevant invariants detected low grade programs tend exhibit fewer relevant invariants programs tend exhibit 
correlation program correctness number relevant invariants detected perfect 
ieee transactions software engineering vol 
february main reason discrepancy programs calculate key values printf statement store variable 
programs specified graded terms output returning storing values 
programs algorithmic data structure bent performing trivial computations probably return store results exposing invariant inference 
test suites invariant discovery far daikon produced adequate invariants randomly generated tests gries programs section preexisting test suites siemens programs section 
characterized properties test suite size appropriate dynamic invariant detection 
furthermore desirable test suite construction affordable 
section reports quality invariants resulting test suites generated semiautomatic relatively inexpensive methods simple random test case generation section grammar driven test case generation section 
siemens programs replace string pattern replacement schedule process scheduling tcas aircraft collision avoidance compare invariants resulting automatically generated test suites random selection hand crafted test cases siemens modified rothermel harrold 
randomly generated test suites simplest method generating test cases randomly generate inputs proper types 
random testing cheap poor coverage effective finding highly peculiar bugs 
randomly generated test suites failed execute portions program 
daikon produce invariants resulting handcrafted input cases 
example random generation produces valid input pattern strings replace program functions read construct pattern rarely reached 
functions entered random test cases produced invariants identical ones derived siemens test cases additional ones 
example schedule function init prio queue adds processes active process queue 
daikon correctly produced invariant num proc loop 
discovered invariants related program behaviors largely independent procedure actual parameters 
random test cases reveal program behaves invalid inputs 
example tcas performs bounds checks statically declared fixed sized array 
index specified input bounds resulting invariants showed garbage values determining aircraft collision avoidance response 
grammar generated test suites randomly generating test cases grammar describes valid inputs holds promise fully fig 
number identical differing invariants invariants produced grammar driven test cases siemens test cases siemens programs 
test suite contained test cases 
random testing 
grammar ensure large number correct inputs biasing grammar choices produce representative test cases 
compared random test generation grammar driven approach produced invariants closer achieved siemens test cases required effort produce 
programs specifications derived grammars describing valid program inputs looking source comments available 
general straightforward cases input combinations occur added explicit constraints generator 
case replace enhanced generator occasionally insert instances produced pattern target string perform replacements ensuring substitution functions exercised 
arranged grammars produce invalid inputs 
cases introducing errors simplified grammars 
example permitted character fill pattern format replace test generation grammar pattern language prohibits regular expression 
table fig 
compares invariants produced grammar driven test cases invariants produced siemens suite programs test cases 
grammar driven test cases produced invariants siemens test cases 
differing invariants appear relevant inherently subjective assessment 
replace differing invariants resulted larger range characters produced generator compared siemens test cases 
differing invariants artifacts erroneous invalid input combinations produced generated siemens test cases 
differences significant resulting input combinations grammar generation method produce 
investigation required evidence reasonable effort generating test cases derive useful invariants 
particular test case generators may able produce invariants roughly equivalent produced test suite designed testing 
programmer need build perfect grammar driven test case generator executes program trace points sufficiently 
detected invariants indicate shortcomings test suite 
random selection values constraints grammar acceptable beneficial invariant inference 
furthermore imperfect grammar help ernst dynamically discovering program invariants support program evolution exercise error conditions needed fully understand program behavior 
program instrumentation daikon input sequence variable value tuples program point interest programmer 
instrumentation inserted program points captures information writing variable values time program point executed 
daikon includes fully automatic java lisp 
data file format program point interest instrumented program writes data trace file values variables scope including global variables procedure arguments local variables procedure exits return value 
instrumenter creates instrumentation time declaration file describing format data trace file 
declaration file lists instrumented program point variables instrumented types original program representations trace file sets variables may sensibly compared see section 
instrumented program point trace file contains list tuples values value instrumented variable 
instance suppose procedure formal parameters scope global variables called twelve times 
computing precondition computing invariant entry point invariant engine list twelve elements element tuple variable values visible variable 
daikon output modification bit value indicates variable set time program point encountered 
permits daikon ignore garbage values uninitialized variables prevent unchanged values encountered multiple times invariant confidence see section details 
fig 
shows excerpt data trace file 
languages explicit pointers java jvm gives access object id output address object id content object array 
permits comparisons contents 
noted section daikon operates scalar numbers including characters booleans arrays numbers 
values converted forms 
instance record converted collection variables natural names array structures converted set parallel arrays structure slot appropriately named origin clear 
daikon accepts arbitrary number trace files declaration files input permitting aggregation multiple program runs production single set invariants generally superior single run 
fig 

records data trace file gries array sum program fig 
invariants fig 
derived 
array integers variables integers 
records give variable values program entry start loop iterations 
complete data trace file contains records 
instrumentation approach daikon front ends add instrumentation program source source translation 
instrumenter operates parsing program source syntax tree ast determining variables scope program point inserting code program point dump variable values output file unparsing ast file source code compiled run standard way 
adding instrumentation program faster compiling 
instrumenting program modifying object code permit improved precision instance determining exactly memory locations accessed hooking exact point variable modified allow instrumentation arbitrary binaries offers substantially greater obstacles implementation 
example standard debugging tools instrumented source code special effort maintain symbol tables debugging source easier portable doing assembly instrumented source code entirely platform independent 
invariant inference sense program modified requires access program source anyway 
source code instrumentation simplifies instrumenting just part system certain files 
relatively small compute bound programs examined far instrumented code slowed order magnitude programs bound 
optimized trace file size writing time approach perform invariant checking online writing variable values file 
implemented lisp java 
section discusses front experiment described section 
lisp instrumenter experiment described section similar simpler respects ieee transactions software engineering vol 
february instance need concerned determining array sizes avoiding segmentation faults 
java front discussed 
instrumenting programs instrumenting programs output variable values requires care uninitialized variables side effects called procedures uncertainty pointer array scalar partially uninitialized arrays sequences encoded arrays 
daikon front edg front manages problems part maintaining runtime status information variable program part simplifying assumptions 
instrumented program contains variable original program associated status object scope variable pointers malloc free functions instrumented create destroy status objects 
status object contains modification timestamp smallest largest indices far arrays pointers arrays linked list object structures true slots type pointer structure 
program manipulates variable status object may updated 
instance assignment copies status information source destination 
order provide accurate information procedure parameters track modifications called procedures variable status object passed returned procedure 
variable passed status object variable passed value status function argument lvalue argument literal function call expression dummy status object created passed value 
instance function declaration ele get nth element list list int 
ele get nth element list instrumented ele get nth element list list var status list status int var status status var status retval status 
ele get nth element list status dummy status ele status tracking variable updates 
modification timestamp variable status object prevents writing garbage values data trace file uninitialized annotation written prevents instrumenter dereferencing uninitialized pointer cause segmentation fault 
daikon problem severe faced tracers purify examine memory locations referenced program 
code instrumented daikon examines potentially dereferences variables visible program point 
modification timestamp initially set uninitialized updated variable assigned 
instance statement foo instrumented version record modification var status record modification var status foo var status comma operator lines comma third line separates function arguments sequentially evaluates operands allows instrumented program perform side effects arbitrary expression introducing new statements affect program syntax tree complicate source source translator 
pointers 
uses type pointer single object type pointer array elements type incorrect assumption referent variable type result loss information outputting single element referent array meaningless values program crash outputting entire block memory interpreted array referent single object 
daikon front discriminates situations simple static analysis program source 
variable base array indexing operation expression marked array scalar 
variable known point array size array available runtime system 
seriously programs allocate arrays larger need portion 
unused sections arrays problems instrumentation uninitialized variables 
determine valid portion array variable status object contains smallest largest integers index array 
information updated array index operation 
instance expression translated record array index var status function record array index returns second argument index updating argument variable status side effect 
minimal maximal indices writing arrays data trace file order avoid walking valid portion array 
approach sound instance works array implementation stack growing irrelevant data output stack shrinks worked practice 
prevents running array assigning array variable updates variable status 
character arrays instrumenter assumes valid data terminated null character 
universally true practice 
programs tested programs practice character buffers explicit lengths null terminated 
structure contains slot type pointer structure type structure link building block linked lists 
daikon ernst dynamically discovering program invariants support program evolution directly reason lists limited internal data formats 
instrumenter works limitation constructing outputting sequence consisting elements reachable pointer 
sequence structures converted collection sequences structure slot described section 
related applications techniques section discusses uses program invariants presents dynamic static approaches determining invariants considers discovered invariants checked methods 
applications invariants article focused dynamic inference invariants applications software evolution 
invariants uses computer science 
dynamically inferred invariants situations declared statically inferred invariants cases application dynamic ones may effective 
invariants provide valuable documentation program operation data structures 
discovered invariants inserted program assert statements testing ensure detected invariants violated code evolves 
double check existing documentation assert statements particularly program self checks ineffective 
additionally nearly true invariant may indicate bug special case brought programmer attention 
invariants may assist test case generation validate test suite 
observed section invariants resulting program runs indicate insufficient coverage certain program states 
dynamic invariants form program spectrum help assess impacts change software 
detected invariants bootstrap direct manual automatic correctness proof 
daikon sound help bootstrap users wish fully hand annotate programs advantage theorem provers static verifiers 
low level execution information profile directed compilation augmented higher level invariants enable better optimization common case 
dynamic inference machine learning artificial intelligence research provides number techniques extracting abstractions rules generalizations collections data 
relevant research application inductive logic programming ilp produces set horn clauses effectively order rules express learned concepts construct invariants variable values particular loop executions 
traditional ai machine learning techniques applicable problem variety reasons relating nature training sets 
learning systems including ilp trained set examples marked correct answers produce useful results 
preclude generation hypotheses training data learning systems apply additional techniques supplying counterexamples training set adding domainspecific knowledge requiring extra inference step find minimal positive generalization initial hypothesis 
access counterexamples 
domain knowledge comes limited form fixed classes hypotheses invariants test 
second experimental control required learning systems perform reinforcement learning trainer environment rewards penalizes agent action takes 
words performing observational experimental discovery 
third learning approaches bayesian pac learning assume noise input data inaccuracies classification acceptable beneficial 
inputs contain noise know exact values instrumented variables program point 
accuracies considered quite subfields acceptable domain 
approach characterizes training set perfectly approach misclassify additional data 
fourth research focuses comprehensibility resulting invariants usefulness programmers 
approaches neural networks produce artifacts predict results little power possible know circumstances accurate 
ai research addresses problems different 
clustering example groups similar examples domain specific similarity metric 
classification places examples set predefined categories categories require definitions commonly training set 
regression attempts learn function variables producing nth closer goal subsume finding relationships variables 
related area programming example programming demonstration goal automation repetitive user actions handled keyboard macro recorder 
research focuses discovery simple repeated sequences user input graphical user interfaces 
dynamic inference placed broad framework concept discovery artificial intelligence number similarities 
instance requires input set irrelevant generalizations may result input set small representative population possible inputs 
generalizes data find properties fitting specified grammar explores space perform directed search 
uses bias choice properties worth checking reporting user 
particular problem directly solved ai techniques applicable believe generalizing techniques applying subproblems task fruitful 
ieee transactions software engineering vol 
february dynamic approaches approach capturing modeling runtime system behavior uses event traces describe sequence events possibly concurrent system produce finite state machine generating trace 
cook wolf statistical techniques detect sequencing conditionals iteration concurrent programs business processes 
users may need correlate original discovered models different structure layout may need iteratively refine model parameters improve output 
verisoft systematically explores state space concurrent systems synthesized finite state machine process 
andrews compares actual behavior behavior user specified model indicating divergences :10.1.1.44.1120
dynamic analyses examine program executions software tasks testing debugging 
program spectra specific aspects program runs event traces code coverage outputs reveal differences inputs program versions 
invariants detected program serve spectrum 
applies database optimizations task dynamically testing specified properties objects system similar techniques query tool 
value profiling addresses subset problem detection constant near constant variables instruction operands 
information permit runtime specialization program branches specialized version variable value expected 
runtime disambiguation similar focuses pointer aliasing 
optimizations valid pointers known aliased 
static determination aliasing state art checked runtime order specialized version code 
pairs pointers shown profiling rarely aliased runtime reductions percent realized 
capable finding subsets invariants ordering relationships pairs variables simple linear patterns predicting memory access strides permits effective parallelization 
static inference formal methods inspired research motivated desire find dynamic analog static techniques involving specifications 
adopted hoare dijkstra school notations terminology preconditions postconditions loop invariants automatic system programmer produces properties guaranteed universally true 
number authors note advantages knowing properties suggest starting specification writing code 
static analyses operate program text particular test runs typically sound conservative 
result properties report true program run theoretically detect sound invariants run convergence 
particular interpretation implemented dataflow analysis starts set equations specifying semantics program expression symbolically executes program point values variables expressions available terms inputs 
solution approached greatest lower bound decreasing approximations upper bound increasing approximations 
fixed point equations possibly reached infinitely iterations compute improving approximations reasoning directly fixed point optimal invariants imply solution 
practice static analyses suffer limitations 
omit properties true uncomputable properties depend program including properties inputs 
seriously static analyses limited uncertainty properties capabilities high cost modeling program states approximations permit algorithms terminate introduce inaccuracies 
instance accurate efficient alias analysis state art pointer manipulation forces static checkers give approximate resulting overly weak properties 
cases resulting property may simply infinite unrolling program conveys little understanding size complexity 
dynamic techniques detect context dependent properties easily check properties static analyses approaches complementary 
program understanding tools taken interpretation dataflow approach 
specifications constructed extending specification inputs procedure output 
approach similar interpretation symbolic execution possibly empty precondition operation semantics determines best postcondition 
givan takes approach permits procedural implementations specification functions runtime checking 
indication irrelevant properties output provided 
cheng reverse engineer construct specifications programs strongest postcondition predicate transformer 
user interaction required determine loop bounds invariants 
suggest ways weaken conditions avoid overfitting specifications implementations deleting conjuncts adding disjuncts converting conjunctions disjunctions implications 
adds propagates data structure shape descriptions program cast traditional gen kill analysis 
descriptions include dimensionality pointers pair live pointer variables visible program point reachability common object reachable 
information permits determination data structure tree dag cyclic graph modulo approximations analysis 
shape analyses similar flavor 
jeffords heitmeyer generate state invariants state machine model requirements specifications finding fixed point equations ernst dynamically discovering program invariants support program evolution specifying events cause mode transitions 
compared analyzing code approach permits operation higher level abstraction detection errors earlier software life cycle 
formal proof systems generate intermediate assertions help proving goal formula propagating known invariants forward backward program 
case array bounds checking desired property obvious 
illustrating compiler heuristically infers compile time pattern matching type inferencing datatype implemented collection concrete operations graphically displays data way natural datatype 
reform semiautomatically transforms provably correct steps program specification 
maintainer assistant uses program transformation techniques prove equivalence programs transformed specification 
related includes staging binding time analyses determine invariant semi invariant values partial evaluation 
checking invariants specification checked implementation dynamically running program statically analyzing 
dynamic approaches simpler implement rarely blocked inadequacies analysis slow program check finitely runs 
numerous implementations assert facilities exist research addressed making invariant debugging assertion languages expressive restrictive topic taken research static checking 
programmers tend different styles dynamically statically checked invariants instance tradeoffs completeness runtime cost affect checks programmer inserts 
self checking self correcting programs results computing value ways verifying value difficult compute easy check 
certain functions implementations correct inputs checking effective finding errors extended correct inputs high probability 
dynamic checks effective detecting errors 
study program self checks effective located bug including errors previously discovered way voting versions program ineffective checked condition didn catch error raised false alarms new faults introduced programs unknown efficacy got triggered known bug code tested 
considerable research addressed statically checking formal specifications verify invariants discovered dynamically making system sound 
realistic static specification checkers implemented 
lclint verifies programs respect annotations larch interface language 
focus properties modularity guaranteed modern languages include pointer properties definedness allocation state 
esc extended static checker permits programmers write type annotations including arithmetic relationships declarations mutability catches array bound errors nil dereferences synchronization errors programming mistakes 
lclint esc attempt check full specifications remains state art successful limited domains 
dependent types similar tradeoff expressiveness computability 
lclint esc sound provide programmers substantial confidence annotations check 
investigating integrating daikon systems order explore realistic annotate program sufficiently pass checkers 
partially annotated program trigger warning messages unannotated 
program checking challenging automated 
determining property check considered harder 
research area focused generation intermediate assertions goal prove systems step attempt find sufficiently strong auxiliary predicates permit proof performed automatically 
may forward propagation generation auxiliary invariants backward propagation strengthening properties discussed 
research directly applicable goal discovery properties program point 
ongoing early experience dynamic inference invariants highlighted number issues require research 
section briefly discusses increasing relevance reported invariants improving performance performance enhancing way users see manage reported invariants adding collection checked invariants 
interesting areas investigation evaluating improving test suites formally proving detected invariants 
increasing relevance naive implementation techniques described article run excessively slowly produce uninteresting invariants omit certain useful invariants 
call invariant relevant assists programmer programming task 
perfect relevance unattainable presence ideal test suites relevance depends task programmer experience knowledge underlying system developed techniques generally improve relevance dynamically detected invariants 
techniques exploiting unused polymorphism uses pass approach add desired invariants output 
daikon respects declared types accepts integer integer array inputs 
runtime types detected pass information may specific declared ieee transactions software engineering vol 
february polymorphic types provided second pass manipulate objects ways specific actual values 
techniques remove irrelevant invariants 
invariants logically implied invariants output suppressed cuts output reducing information content 
implications exploited earlier inference save 
second variables statically proven unrelated need compared 
saves runtime avoids reporting coincidentally true unhelpful uninteresting properties 
third variables assigned time instrumentation point encountered ignored 
contribute confidence invariant change occurred loop invariant value repeatedly encountered loop head 
improving performance techniques improving relevance mentioned immediately aid performance reducing number variables considered inference engine 
ways mitigate combinatorial instrumentation output size inference time number results due potentially large numbers program points instrument variables examine point invariants check variables 
approach address granularity instrumentation affects amount data gathered time required process 
inferring loop invariants relationships local variables require instrumentation loop heads function calls determining representation invariants properties global variables require instrumentation points module entry exit points sufficient 
part program interest program need instrumented replace study recomputed invariants just single procedure order invariant detection complete faster 
similarly choice variables instrumented program point affects inference performance 
interest skipped variables changed instrumentation point need reexamined 
supplying fewer test cases results faster runtimes risk precise output 
inference engine directly sped checking fewer invariants particularly useful programmer focusing part program interested certain kinds properties say ternary functions 
derived variables likewise throttled save time increased provide extensive coverage 
complicated derived variables may added complex expressions appear program text derived variables invariants may involve functions defined program 
mentioned earlier daikon implementation written interpreted object oriented language python optimized implementation significant way 
significant performance improvements appear feasible 
viewing managing invariants may difficult overwhelming programmer sort large number inferred invariants 
issue replace daikon reported dozens invariants program point useful particular task 
relevance improvements help significantly regard 
additional tools viewing managing invariants help 
example developed tool retrieves variable value tuples satisfy falsify user specified property 
example considering developing text editor provide list invariants program point variable cursor 
programmer permitted filter classes invariants 
ordering reported invariants category predicted usefulness help programmer find relevant invariant quickly 
invariant differencing tool indicate program change affected computed invariants 
selective reporting invariants improve performance invariant inference 
example user interface presents invariants demand invariants computed demand 
replace example average program point required seconds inference time 
order magnitude speed improvement due implementation compiled language combined filtering unwanted classes invariants variables demand inference time limited seconds start costs inference limited running test cases 
richer invariants pursuing techniques find report sophisticated invariants 
critical improvements discovering invariants recursive data structures linked lists trees graphs computing conditional disjunctive invariants null improvements symbiotic trivial example shows 
current design handling pointer data structures linearize variety ways instrumentation look invariants linearized sequences 
conditional invariants detected splitting data trace parts performing invariant inference part combining results 
data split number ways random exhaustive splitting traces exceptions invariants tested splitting special values common constants zero extremal values earlier static analysis identify potential predicates splitting 
preliminary results reported 
research demonstrates feasibility effectiveness discovering program invariants execution traces 
technique automatically detected stated ernst dynamically discovering program invariants support program evolution invariants set formally specified programs furthermore invariants detected program proved useful software evolution task 
techniques prototype implementation adequately fast applied modest programs 
working evolution tasks programs write gave insights strengths weaknesses dynamic invariant detection specific techniques daikon tool 
dynamically inferred invariants qualitatively affected programmers encouraging think terms invariants 
variety improvements discussed previous section significant promise approach applicable evolution larger systems 
promise holds despite fact invariant detector may discover invariants universally true potential executions 
local static analysis reveal useful invariants universally true function matter 
program analysis discover stronger properties function particular properties dependent contexts function called discussed section 
dynamic invariant detector report stronger invariants depend data sets program may run 
ability achieve admits invariants true particular test suite chosen generally discernible user kinds invariants 
regardless inferred invariants capable pointing flaws test suite directing improvement discussed section 
focusing general task software evolution task driven needs programmer led effective solutions 
instance technique need find complete specification interesting invariant find interesting correct invariants 
technique enable programmer evolve systems effectively 
point view guided technical aspects research 
instance chose highly uniform design invariant engine modeling scalar integer variables arrays scalars 
types mapped types nonvariable entities mapped variables 
choices constrain invariants system infers provides useful invariants acceptable cost 
focusing software evolution task guided choices checking fixed set invariant classes computing confidence levels data capture instrumentation 
daikon invariant detector available sdg lcs mit edu daikon 
acknowledgments revised extended version appeared icse :10.1.1.137.4260
performed analysis student programs reported section 
provided valuable assistance statistical analysis 
gregg rothermel shared modified versions siemens test programs 
colleagues provided comments ideas particularly grateful early feedback craig chambers oren etzioni lau david madigan jared 
greg craig chambers lau todd millstein jon steve wolfman anonymous icse ieee transactions software engineering referees improved article critiquing previous versions 
daniel jackson litvinov george necula james noble referees suggested related 
supported national science foundation ccr ccr ibm cooperative fellowship gift edison design group 
research conducted ernst cockrell university washington 
abramson foster relative debugging new methodology debugging scientific applications comm 
acm vol 
pp 
nov 
andrews testing log file analysis tools methods issues proc :10.1.1.44.1120
th ann 
int conf 
automated software eng 
ase pp 
oct 
bj rner browne manna automatic generation invariants intermediate assertions theoretical computer science vol 
pp 
feb 
bratko grobelnik inductive learning applied program construction verification knowledge oriented software design extended papers ifip tc workshop artificial intelligence information processing perspective ed pp 

godefroid automatic synthesis specifications dynamic observation reactive programs proc 
third int workshop tools algorithms construction analysis systems tacas pp 
apr 
bensalem lakhnech saidi powerful techniques automatic generation invariants proc 
eighth int conf 
computer aided verification cav pp 
july aug 
blum designing programs check proc 
int symp 
software testing analysis ostrand weyuker eds june 
chan boyland scherlis promises limited specifications analysis manipulation proc 
th int conf 
software eng pp 
apr 
cousot cousot automatic synthesis optimal invariant assertions mathematical foundations proc 
acm symp 
artificial intelligence programming languages pp 
aug 
calder feller eustace value profiling proc 
th ann 
int symp 
microarchitecture micro pp 
dec 
calder feller eustace value profiling optimization instruction level parallelism vol 
mar www org vol 
cheng abstraction formal specifications program code proc 
third int conf 
tools artificial intelligence tai pp 
nov 
watch programming demonstration cypher lieberman myers eds cambridge mass mit press 
cohen grammatically biased learning learning logic programs explicit antecedent description language artificial intelligence vol 
pp 
aug 
cook wolf discovering models software processes event data acm trans 
software eng 
methodology vol 
pp 
july 
cook wolf event detection concurrency proc 
acm sigsoft symp 
foundations software eng pp 
nov 
ieee transactions software engineering vol 
february clarke wing alur cleaveland dill emerson garland german guttag hall henzinger holzmann jones kurshan leveson mcmillan moore peled pnueli rushby shankar sifakis sistla steffen wolper woodcock zave formal methods state art directions acm computing surveys vol 
pp 
dec 
chase wegman zadeck analysis pointers structures proc 
sigplan conf 
programming language design implementation pp 
june 
dunlop basili heuristic deriving loop functions ieee trans 
software eng vol 
pp 
may 
dwyer clarke data flow analysis verifying properties concurrent programs proc 
second acm sigsoft symp 
foundations software eng 
sigsoft pp 
dec 
detlefs overview extended static checking system proc 
workshop formal methods software practice pp 
jan 
dijkstra discipline programming 
englewood cliffs prentice hall 
detlefs rustan leino nelson saxe extended static checking src research report compaq systems research center dec 
amarasinghe software speculative parallelism mit lcs technical memo lcs tm apr 
program derivation development programs specifications addison wesley 
ernst cockrell griswold notkin dynamically discovering program invariants support program evolution proc :10.1.1.137.4260
st int conf 
software eng pp 
may 
ernst griswold notkin quickly detecting relevant program invariants proc 
nd int conf 
software eng pp 
june 
edison design group front internal documentation version ed mar www edg com 
evans guttag horning tan lclint tool specifications check code proc 
second acm sigsoft symp 
foundations software eng 
sigsoft pp 
dec 
ernst griswold notkin dynamically discovering pointer program invariants technical report uw cse univ washington seattle wash nov 
ernst dynamically discovering program invariants phd thesis dept computer science eng univ washington seattle wash aug 
evans static detection dynamic memory errors proc 
sigplan conf 
programming language design implementation pp 
may 
cheng strongest postcondition semantics formal basis reverse engineering automated software eng vol 
nos 
pp 
june 
cheng specification matching approach reverse engineering proc 
st int conf 
software eng pp 
may 
hanson duel high level debugging language proc 
usenix conf pp 
jan 
ghiya hendren tree dag cyclic graph 
shape analysis heap directed pointers proc 
rd ann 
acm sigplan sigact symp 
principles programming languages pp 
jan 
givan inferring program specifications polynomial time proc 
third int symp 
static analysis sas pp 
sept 
givan jr automatically inferring properties computer programs phd thesis mass inst 
technology cambridge mass june 
gries science programming new york springer verlag 
gupta fresh look optimizing array bound checking proc 
sigplan conf 
programming language design implementation pp 
june 
german wegbreit synthesizer inductive assertions ieee trans 
software eng vol 
pp 
mar 
hamlet random testing encyclopedia software eng 
hutchins foster ostrand experiments effectiveness dataflow controlflow test adequacy criteria proc 
th int conf 
software eng pp 
may 
hendren hummel nicolau abstractions recursive pointer data structures improving analysis transformation imperative programs proc 
sigplan conf 
programming language design implementation pp 
june 
hastings joyce purify tool detecting memory leaks access errors programs proc 
usenix conf pp 
jan 
hoare axiomatic basis computer programming comm 
acm vol 
pp 
oct 
harrold rothermel wu yi empirical investigation program spectra acm sigplan sigsoft workshop program analysis software tools eng 
paste pp 
june 
huang shen speculative disambiguation compilation technique dynamic memory disambiguation proc 
st ann 
int symp 
computer architecture pp 
apr 
henry whaley university washington illustrating compiler proc 
sigplan conf 
programming language design implementation pp 
june 
jones gomard sestoft partial evaluation automatic program generation 
prentice hall int 
jeffords heitmeyer automatic generation state invariants requirements specifications proc 
acm sig soft symp 
foundations software eng pp 
nov 
jones strategy finding optimal data placement regular programs master thesis dept computing imperial college 
jacobs van den berg huisman van reasoning java classes object oriented programming systems languages applications oop sla pp 
oct 
holzle bruno reflective java library support design contract technical report univ calif santa barbara jan 
kleene representation events nerve nets finite automata automata studies annals math 
studies shannon mccarthy eds pp 

katz manna logical analysis programs comm 
acm vol 
pp 
apr 
wolfe elimination redundant array subscript range checks proc 
sigplan conf 
programming language design implementation pp 
june 
leveson cha knight self checks voting software error detection empirical study ieee trans 
software eng 
vol 
pp 


liao diwan bosch jr lam suif explorer interactive interprocedural proc 
seventh acm sigplan symp 
principles practice parallel programming ppopp pp 
may 
liskov guttag abstraction specification program development 
cambridge mass mit press 
ho lzle singh query debugging object oriented programs proc 
conf 
object oriented programming systems languages applications pp 
oct 
leino nelson extended static checker modula proc 
compiler construction seventh int conf 
cc pp 
apr 
landi ryder safe approximate algorithm interprocedural pointer aliasing proc 
sigplan conf 
programming language design implementation pp 
june 
mitchell machine learning 
mcgraw hill series computer science boston mass mcgraw hill 
ernst dynamically discovering program invariants support program evolution clarke osterweil dwyer verification concurrent software proc 
th int conf 
software eng pp 
may 
nicolau run time disambiguation coping statically unpredictable dependencies ieee trans 
computers vol 
pp 
may 
necula lee design implementation certifying compiler proc 
acm sigplan conf 
programming language design implementation pp 
june 
callahan jackson program understanding tool type inference proc 
th int conf 
software eng pp 
may 
pfenning dependent types logic programming types logic programming pfenning ed chapter pp 

quinlan learning logical definitions relations machine learning vol 
pp 

reps ball das larus program profiling software maintenance applications year problem proc 
sixth european software eng 
conf 
fifth acm sigsoft symp 
foundations software eng 
esec fse pp 
sept 
rothermel harrold empirical studies safe regression test selection technique ieee trans 
software eng vol 
pp 
june 
rosenblum practical approach programming assertions ieee trans 
software eng vol 
pp 
jan 
su zhao wang wu study pointer aliasing software pipelining run time disambiguation proc 
th ann 
int symp 
microarchitecture micro pp 
nov dec 
suzuki implementation array bound checker proc 
fourth ann 
acm symp 
principles programming languages pp 
jan 
sagiv reps wilhelm parametric shape analysis valued logic proc 
th ann 
acm sigplan sigact symp 
principles programming languages pp 
jan 
sohi empirical analysis instruction repetition architectural support programming languages operating systems asplos viii pp 
oct 
tan formal specification techniques promoting software modularity enhancing documentation testing specifications technical report mit lcs tr mass inst 
technology laboratory computer science june 
van rossum python manual ed dec 
holzmann automatic detection invariants spin spin papers fourth int spin workshop nov 
ward program analysis formal transformation computer vol 
pp 

wasserman blum software reliability run time result checking acm vol 
pp 
nov 
ward munro maintainer assistant proc 
int conf 
software maintenance pp 

wegbreit synthesis loop predicates comm 
acm vol 
pp 
feb 
wilson lam efficient context sensitive pointer analysis programs proc 
sigplan conf 
programming language design implementation pp 
june 
xi pfenning eliminating array bound checking dependent types proc 
acm sigplan conf 
programming language design implementation pp 
june 
xi pfenning dependent types practical programming proc 
th ann 
acm sigplan sigact symp 
principles programming languages pp 
jan 
zenger indexed types theoretical computer science vol 
pp 

michael ernst holds sb sm degrees institute technology 
received phd degree computer science engineering university washington prior lecturer rice university researcher microsoft research 
assistant professor department electrical engineering computer science laboratory computer science institute technology 
primary technical interest programmer productivity encompassing software engineering program analysis compilation programming language design 
published artificial intelligence theory areas computer science 
jake cockrell received bs degree computer science university virginia ms degree computer science engineering university washington 
currently works macromedia engineer team 
william griswold received ba degree mathematics university arizona phd degree computer science university washington 
associate professor department computer science engineering university california san diego 
program committee international conference software engineering associate editor ieee transactions software engineering officer acm sigsoft 
research interests include software evolution design software tools program analysis 
member ieee ieee computer society 
david notkin received degree brown university phd degree carnegie mellon university 
boeing professor computer science engineering university washington 
dr notkin received national science foundation presidential young investigator award served program chair acm sigsoft symposium foundations software engineering served program th international conference software engineering chaired steering committee international conference software engineering served charter associate editor acm transactions software engineering methodology journal programming languages serves associate editor ieee transactions software engineering named acm fellow serves chair acm sigsoft received university washington distinguished graduate mentor award 
research interests software engineering general software evolution particular 
senior member ieee computer society 
