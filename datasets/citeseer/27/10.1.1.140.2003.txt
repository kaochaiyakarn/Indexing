knightcap chess program learns combining td minimax search jonathan baxter department systems engineering australian national university canberra australia andrew tridgell department computer science australian national university canberra australia lex weaver department computer science australian national university canberra australia november jon baxter andrew tridgell lex weaver anu edu au variation td algorithm enables conjunction minimax search 
experiments chess program knightcap learn evaluation function playing free chess server net 
improved rating rating just games days play 
discuss reasons success relationship results tesauro results backgammon 
temporal difference learning td introduced sutton elegant algorithm approximating expected long term cost cost go stochastic dynamical system function current state :10.1.1.132.7760
mapping states cost implemented parameterized function approximator neural network 
parameters updated online state possibly batch updates state transitions 
goal algorithm improve cost estimates number observed state transitions associated costs increases 
remarkable success td tesauro td gammon neural network backgammon player trained scratch td simulated self play 
td gammon competitive best human backgammon players 
td gammon neural network played dual role predictor expected cost go position means select moves 
position move chosen greedily evaluating positions reachable current state selecting move leading position smallest expected cost 
parameters neural network updated td algorithm game 
results backgammon quite striking disappointment despite attempts repeated board games othello go chess 
authors discussed peculiarities backgammon particularly suitable temporal difference learning self play 
principle speed play td gammon learnt games self play representation smoothness evaluation backgammon position reasonably smooth function position viewed say vector piece counts making easier find neural network approximation stochasticity backgammon random game forces minimal amount exploration search space 
td gammon original form searched ply ahead feel list appended shallow search humans 
possible reasons gain lot searching deeper backgammon questionable versions td gammon search ply significantly improves performance humans simply incapable searching deeply td gammon competing pool shallow searchers 
know psychological studies investigating depth humans search backgammon plausible combination high branching factor random move generation quite difficult search ply ahead high branching factor reason humans search deeply go game similar branching factor backgammon 
contrast finding representation chess othello go allows small neural network order moves ply near human performance far difficult task 
games reliable tactical evaluation difficult achieve deep lookahead 
deep lookahead invariably involves kind minimax search turn requires exponential increase number positions evaluated search depth increases computational cost evaluation function low ruling neural networks 
consequently chess othello programs linear evaluation functions branching factor go minimax search significant depth nearly infeasible 
introduce variation td theme learn evaluation function deep minimax search 
identical td operating positions occur game operates leaf nodes principal variation minimax search position 
test effectiveness incorporated chess program knightcap 
knightcap particularly rich board representation enabling relatively fast computation sophisticated positional features 
trained knight cap linear evaluation function playing free internet chess server net internet chess club icc com 
internet play avoid premature convergence difficulties associated self play main success story report starting evaluation function coefficients set zero values pieces knightcap went rated player rated player just days games 
knightcap ongoing project new features added evaluation function continually 
internet play tune coefficients features going press discovered idea tune material values chess program operated material values 
learnt values came close traditional chess values pawn knight bishop rook queen learnt self play line play 
knightcap self play worse line learning see section knightcap performance measured line players fixed program 
remainder organised follows 
section describe td algorithm applies games 
algorithm described section 
details knightcap section 
experimental results internet play chess sections 
section contains discussion concluding remarks 
td algorithm applied games section describe td algorithm applies playing board games 
discuss algorithm point view agent playing game 
denote set possible board positions game 
play proceeds series moves discrete time steps time agent finds position available set moves actions legal moves position 
agent chooses action transition state probability position board agent move opponent response 
game agent receives scalar reward typically win draw loss 
ease notation assume games fixed length essential 
denote reward received game 
assume agent chooses actions function current state randomizing move choice way avoiding problems associated self play approach tried go advantage internet information provided opponents play 
expected reward state expectation respect transition probabilities possibly respect actions agent actions stochastically 
vary large state spaces possible store value try approximate parameterized function class example linear function splines neural networks assumed differentiable function parameters aim find parameter vector minimizes measure error approximation td algorithm describe designed exactly 
suppose sequence states game 
parameter vector define temporal difference associated transition note property measures difference reward predicted time reward predicted time true evaluation function approximation observation td motivates algorithm 
ease notation assume final temporal difference satisfies close zero 
difference true outcome game prediction penultimate move 
game td algorithm updates parameter vector formula positive parameter controls learning rate typically annealed zero course long series games 
parameter controls vector partial derivatives respect parameters 
extent temporal differences propagate backwards time 
see compare equation consider term contributing sums equations 
parameter vector adjusted way move predicted reward time closer predicted reward time contrast td adjusts parameter vector way move predicted reward time step closer final reward time step values zero interpolate behaviours 
successive parameter updates td algorithm time lead improved predictions expected reward provided actions independent parameter vector shown linear algorithm converges near optimal parameter vector 
unfortunately td guarantee non linear depends 
despite lack theoretical guarantees successful applications td algorithm 
minimax search td games action taken state lead predetermined state denote approximation choose actions state picking action successor state minimizes opponent expected reward strategy td gammon 
unfortunately games othello chess difficult accurately evaluate position looking move ply ahead 
programs games employ form minimax search 
argmin minimax search builds tree position examining possible moves computer position possible moves opponent possible moves computer predetermined depth leaf nodes tree evaluated heuristic evaluation function successor states determined stochastically choice choose action minimizing expected reward choice successor states 
full breadth ply search tree illustrating minimax rule propagating values 
leaf nodes score evaluation function scores propagated back tree assigning nent internal node minimum children values internal nodes maximum children values 
principle variation sequence best moves side starting root node illustrated dashed line 
note score root node evaluation leaf node principal variation 
ties siblings derivative score respect parameters just stage move leads best position player move 
see example game tree minimax evaluation 
note evaluation assigned root node evaluation leaf node principal variation sequence moves taken root leaf side chooses best available move 
practice engineering tricks improve performance resulting scores propagated back tree choosing minimax algorithm famous 
denote evaluation obtained state applying leaf nodes depth minimax search aim find parameter vector approximation expected reward way achieve td apply algorithm sequence positions game define temporal differences equation td algorithm updating parameter vector problem equation function values necessarily differ differentiable 
search tree non unique principal variation pv 
case derivative root node respect parameters leaf node evaluation function multi valued transpositions case identical derivative single valued anyway col extremely rare ignore choosing leaf node arbitrarily available candidates 
values ties minimax search best move available positions principal variation means principal variation unique see 
evaluation assigned root node evaluation number leaf nodes 
fortunately mild technical assumptions behaviour shown state set differentiable lebesgue measure zero 
states differentiable function note continuous function continuous function implies bad pairs undefined multivalued 
arbitrarily choose particular value happens land bad points 
observations td modified algorithm take account minimax search way working root positions td algorithm applied leaf positions minimax search root positions 
call algorithm 
full details 
experiments chess section describe outcome experiments algorithm train weights linear evaluation function chess program knightcap 
class evaluation functions parameterized positions occurred course game outcome game 
notational convenience set 
state compute performing minimax search depth score leaf nodes 
note may vary position position 

denote leaf node principle variation starting principal variation choose leaf node available candidates random 
note 
compute temporal differences 
update formula algorithm knightcap knightcap reasonably sophisticated computer chess program unix systems 
standard algorithmic features modern chess programs tend number features common 
section meant give reader overview type algorithms chosen knightcap 
space limitations prevent full explanation described features interested reader able find explanations widely available computer chess literature see example examining source code anu edu au 
board representation knightcap differs chess programs 
principal board representation knightcap array 
array bit words word square board 
bit word represents pieces starting chess position pieces pawns side 
bit square set piece attacking square array proved powerful representation allows easy description evaluation features difficult costly representations 
array updated dynamically move way vast majority moves small proportion array need directly examined updated 
simple example array knightcap determining king check 
check function quite expensive chess programs knightcap involves just logical operation array 
similar fashion evaluation function find common features connected just instructions 
array drive move generator obviates need standard move generation function 
search algorithm basis search algorithm knightcap mtd 
mtd logical extension minimal window alpha beta search formalises placement minimal search window produce effect bisection search evaluation space 
variation mtd knightcap uses includes convergence acceleration heuristics prevent slow convergence plague mtd implementations 
heuristics similar concept momentum terms commonly neural network training 
mtd search algorithm applied standard iterative deepening framework 
search begins depth obtained transposition table initial search position continues time limit reached search 
search ordering root node ensures partial ply search results obtained timer expires quite safely 
null moves knightcap uses recursive null move forward pruning technique 
null move chess programs fixed value number additional prune trying null move knightcap uses variable value asymmetric fashion 
initial value algorithm tests result null move search 
computers side search null move indicates position computer value decreased null move retried 
effect null move system speed system obtained making null move defensive errors system 
essentially pessimistic system 
search extensions knightcap uses large number search extensions ensure critical lines searched sufficient depth 
extensions indicated combination factors including check null move mate threats pawn moves ranks recapture extensions 
addition knightcap uses single ply system pawn threshold 
asymmetries quite number asymmetric search evaluation terms knightcap leaning pessimistic 
careful play 
apart asymmetric null move search extensions systems mentioned knightcap uses asymmetric system decide moves try search asymmetric evaluation terms evaluation function king safety trapped piece factors 
combined algorithm knightcap able learn appropriate values asymmetric evaluation terms 
transposition tables knightcap uses standard deep transposition table bit transposition table entry 
entry holds separate depth evaluation information lower upper bound 
enhanced transposition table cutoff technique move ordering reduce tree size 
transposition table feed book learning system initialise depth iterative deepening 
move ordering move ordering system knightcap uses combination commonly history killer refutation transposition table ordering techniques 
relatively expensive evaluation function knightcap afford spend considerable amount cpu time move ordering heuristics order reduce tree size 
parallel search knightcap written take advantage parallel distributed memory multicomputers parallelism strategy derived naturally mtd search algorithm 
details methodology parallelism results obtained available 
results obtained single cpu machine 
evaluation function heart chess program evaluation function 
knightcap uses quite slow evaluation function evaluates number quite computationally expensive features 
computationally expensive part evaluation function board control 
function evaluates control function square board try determine controls square 
control square essentially defined determining player square flight square piece player controls square pawn 
despite fact board control function evaluated incrementally control squares updated move affects square function typically takes total cpu time program 
high cost considered worthwhile flow effects calculation aspects evaluation search 
flow effects include ability knightcap evaluate reasonably accurately presence hung trapped immobile pieces normally severe weakness computer play 
noted accurate evaluation function tends reduce search tree size making decreased node count 
modification modifications knightcap affected number program subsystems 
largest modifications involved parameterisation evaluation function evaluation coefficients part single long weight vector 
evaluation knowledge described terms values vector 
major modification addition full board position data structures evaluation value obtained 
involved substitution structure usual scalar evaluation type evaluation function filling evaluated position board state information evaluation call 
similar additions transposition table entries book learning data result search available position associated leaf node principal variation 
significant modification required increase bit resolution evaluation type numerical partial derivative evaluation function respect evaluation coefficient vector obtained reasonable accuracy 
experiments knightcap main experiment took knightcap evaluation function set material parameters zero 
material parameters initialised standard computer values pawn knight bishop rook queen 
parameter settings knightcap wimp knight set playing free internet chess server net human computer opponents 
played knightcap games modifying evaluation function get reasonable idea rating 
games fast time control rating put level human performance standard deviation ratings reported section 
gives example kind game plays just material evaluation function 
turned learning algorithm learning rate value chosen heuristically typical delay moves error takes effect set high ensure rapid modification parameters 
couple minor changes algorithm raw linear leaf node evaluations tween computing converted score ensured small fluctuations relative values leaf nodes produce large temporal differences 
outcome game set win loss draw 
set ensure value equivalent material superiority pawn 
temporal differences modified way 
negative values left unchanged decrease evaluation position viewed mistake 
positive values occur simply opponent blunder 
avoid knightcap trying learn predict opponent set positive temporal differences zero knightcap predicted opponent move 
value pawn kept fixed initial value allow easy inter weight values multiples pawn value 
games knightcap rating risen increase points days 
point knightcap performance began plateau primarily opening book repeatedly play weak lines 
implemented opening book learning algorithm knight cap plays rating major internet chess server icc com 
regularly beats international masters similar performance crafty best public domain program longer time controls 
repeated experiment td applied root nodes search actual positions occurred game leaf nodes principal variation observed point rating rise games 
significant improvement slower lower peak 
appear number reasons remarkable rate knightcap improved 

non material weights initially zero small changes weights cause large changes relative ordering materially equal positions 
games knightcap playing substantially better game chess 

important knightcap started life intelligent material parameters 
put close parameter space far superior parameter settings 

players prefer play opponents similar strength knight cap opponents improved 
may effect guiding knightcap path weight space led strong set weights 

knightcap thrown deep stronger opponents positive negative feedback games 

knightcap learning self play 
investigate importance reasons conducted experiments 
initial conditions 
second experiment run knightcap coefficients initialised value pawn 
value pawn needs positive knightcap places code example deem mtd search converged pawn 
set parameters equal value value pawn 
playing initial weight settings knightcap rating 
games knightcap rating improved point gain 
slower improvement original experiment 
know coefficients eventually converged values clear experiment starting near set weights important fast convergence 
interesting avenue exploration effect learning rate 
initial evaluation function completely wrong justification setting early knightcap tries predict outcome game evaluations moves extremely unreliable 
positive negative feedback investigate importance balanced feedback initialised parameter knightcap evaluation function value pawn weak version played version stronger parameter settings 
apart draws repetition opening weak version lost single games 
weak version training stronger original pawn weight version weak player example sacrifice queen knight pawns positions 
reason improvement pawn weight version trained version learnt increased material weight tend hang material pawn weight version quite happily threw material away 
face value remarkable trained version learnt useful losing games 
game lost fixed point td algorithm algorithm value position loss outset 
fact close solution knightcap evaluation starting position pawns simulation gives value close squashing 
achieved primarily exploiting material weights asymmetric positional features zero opponent pieces attacking king zero pieces attacking opponent king 
knightcap learnt coefficients features pawns pawns meant position attack king starting position features contributed pawns knightcap evaluation function 
material weights increased opponent strong player games weak version soon material encourages positive material parameters gives negative value position 
self play learning self play extremely effective td gammon significant reason randomness backgammon ensures high probability different games substantially different sequences moves 
chess deterministic game self play deterministic algorithm tends result large number substantially similar games 
problem games seen self play representative games played practice see example game knightcap self play games non zero material weights different kind games humans level play 
demonstrate learning self play knightcap effective learning real opponents ran experiment material parameters initialised zero time knightcap learnt playing 
games twice original experiment played resulting version version learnt games weight values fixed 
self play version scored version 
positive results essentially self play random move choice reported learning material weights 
comparing performance line players primarily investigating weights converge sensible values naive values pawn knight bishop rook queen 
view positive results negative results self play investigation required determine critical line learning play 
knightcap vs knightcap 
na nc 
nb rb 
nc ra 
rb 
ra na 
nf bd 

qd nf 
nc 
qe nb 
nd bc 
qf qd 
nb nc 
kd ne 
qf ng 
qg 
ne nd 
kd qb 
nc 
bxc qa 
rb kd 
qf ke 
kd qc 
ke 
kd kd 
na 
ke kc 
rb ne 

kd 
kd nd 
rb kc 


bf rd 
rb nf 
nb 
ke kd 
kc 
kd 
bd ne 
ra kc 
kd 
rc 
kd kd 
bf nc 
na na 
kc ke 
rb 
kb ra 
bf nb 
ra rb 
nc na 
ra bd 
bf rb 
nb 

na 
nb nb 
ra bxb 
rd 
kc kd 
bd rc 
kd nc 
ra nd 
ne 
bd kd 
bc kc 
ra kd 
kc rd 
rc nd 
rd 
bc 

kd 
rb rb 
bd 
kc 
ke kd 
kf rbb 
kg kc 
moves game knightcap sides evaluation function non zero parameters material coefficients 
configuration gives knightcap rating seen game plays human similar rating 
discussion introduced variant td suitable training evaluation function minimax search 
extra requirement algorithm leaf nodes principal variations stored game 
experiments linear chess evaluation function trained line play mixture human computer opponents 
experiments show importance line sampling opposed self play need start near solution fast convergence 
compared training leaf nodes training root nodes significant improvement training leaf nodes chess 
currently investigating works backgammon view understanding differences chess backgammon affect learning 
theoretical side shown td converges linear evaluation functions 
interesting avenue investigation determine similar convergence properties 
beal smith 
learning piece values temporal differences 
journal international computer chess association 
bertsekas tsitsiklis 
neuro dynamic programming 
athena scientific 
kaelbling littman moore 
reinforcement learning survey 
journal artificial intelligence research 
levy newborn 
computers play chess 
freeman 
marsland schaeffer 
computers chess cognition 
springer verlag 
schaeffer de bruin 
best fixed depth minmax algorithms 
artificial intelligence 
pollack blair land 
coevolution backgammon player 
proceedings fifth artificial life conference nara japan 
schraudolph dayan sejnowski 
temporal difference learning position evaluation game go 
cowan tesauro alspector editors advances neural information processing systems san fransisco 
morgan kaufmann 
sutton :10.1.1.132.7760
learning predict method temporal differences 
machine learning 
tesauro 
practical issues temporal difference learning 
machine learning 
tesauro 
td gammon self teaching backgammon program achieves master level play 
neural computation 
thrun 
learning play game chess 
tesauro touretzky leen editors advances neural information processing systems san fransisco 
morgan kaufmann 
tridgell 
knightcap parallel chess program ap 
proceedings seventh fujitsu parallel computing workshop canberra 
ftp samba anu edu au knightcap pcw ps gz 
source code anu edu au 
roy 
analysis temporal difference learning function approximation 
ieee transactions automatic control 
walker downs 
self learning patterns othello board game method temporal differences 
liu foo editors proceedings th australian joint conference artificial intelligence pages melbourne 
world scientific 

