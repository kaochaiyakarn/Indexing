hongwei xi oregon graduate institute mechanism declaring datatypes functional programming languages ml haskell great practice 
mechanism suffers imprecision capturing invariants inherent data structures 
remedy situation dependent datatypes model data structures significantly accuracy 
interesting examples implementations red black trees binomial heaps illustrate dependent datatypes capturing sophisticated invariants data structures 
claim dependent datatypes enable programmer implement algorithms way robust easier understand 
mechanism allows programmer declare datatypes indispensable functional programming languages standard ml haskell 
practice encounter situations declared datatypes accurately capture really need 
instance need data structure pairs integer lists length declare datatype standard ml haskell pairs integer lists 
inaccuracy problem rich source program errors 
typical scenario function receive argument pair integer lists length mistakenly applied pair integer lists different lengths 
unfortunately mistake causes type errors pairs integer lists equal length type pairs integer lists usually hide program unnoticed run time debugging demanding compile time 
inaccuracy problem serious start implement sophisticated data structures red black trees binomial heaps ordered lists relatively complex invariants data structures maintain order implement correctly 
instance correct implementation insertion operation red black tree yield red black tree 
form datatype precisely capture properties red black tree possible detect program error type checking error leads violation captured properties 
evidently desirable feature programming practical 
need forming accurate datatypes partially motivated design dependent ml dml enrichment ml restricted form dependent types 
precisely dml language schema 
constraint domain dml language schema type index expressions drawn roughly speaking type index expression simply term index type 
type checking dml reduced constraint satisfaction restrict integer domain name dml particular dml 
variant dml de caml implemented top caml light 
implementation essentially replaces front partially supported united states air force materiel command department defense 
caml light dependent type checker keeps back caml light intact 
modifies library functions assigning accurate types 
alternative approach forming accurate datatypes nested datatypes :10.1.1.31.3551
instance nested datatype exactly representing red black trees readily formed 
exist various significant differences dml style dependent types nested datatypes illustrate 
font represent code de caml verified prototype implementation 
significant consequence dependent types loss notion principal types dml 
instance types assigned implementation de caml zips lists 
list list list nat list list list type usually meaning second implies natural number function yields list length pair lists length notice list type list length element type dependent type assigned function dml responsibility programmer annotate function dependent type 
probably significant difference programming styles ml dml 
practice observe type annotations typical dml program constitutes entire code 
dependent type annotations lead accurate reports type error messages serve informative program documentation feel dml programming style acceptable practical point view 
provide concrete examples reader judge claim including implementations red black trees binomial heaps 
implementations adopted corresponding ones :10.1.1.54.6229
implementations de caml advantages original ones 
verified invariants de caml implementations 
instance verified type system de caml function merges binomial heaps yields binomial heap 
type annotations implementations fully trusted mechanically verified offer pedagogical values 
feel easier understand de caml implementations reader reason presence informative dependent types 
possible necessary formally dml 
focus presenting concrete examples programming language de caml variant dml intuitive explanation 
refer interested reader formal development dml strongly believe largely unnecessary comprehending :10.1.1.41.548
rest organized follows 
section give brief overview types dml 
introduce de caml section presenting main features illustrating type checking de caml short example 
case studies section including implementations braun trees random access lists red black trees binomial heaps 
lastly discuss related conclude 
types dependent ml section brief explanation types dml 
reader encouraged skip section read helpful gather intuition studying concrete examples section 
intuitively speaking dependent types types depend values language expressions 
instance may form type integer mean integer expression type value singleton type 
note expression type depends 
name type index expression expression 
various compelling reasons practical type checking imposing restrictions expressions chosen type index expressions 
index expressions index propositions index sorts index contexts syntax type index expressions novelty dml require type index expressions drawn constraint domain 
purpose restrict type index expressions integers 
syntax type index expressions type index variables fixed integer 
note language type index expressions typed 
sorts types language order avoid potential confusion 
empty index variable context omit standard sorting rules language 
certain transparent abbreviations stands subset sort stands sort elements sort satisfy proposition example nat abbreviation subset sort types dml formed follows 
type variables type constructors 
types instance type constructor stands type integer list length form universal dependent type existential dependent type respectively 
instance universal dependent type captures invariant function natural number returns integer list length integer list length existential dependent type mean integer list unknown length 
demonstrate type constructor declared section 
typing rules language familiar dependently typed calculus ones underlying coq nuprl 
critical notion type conversion uses judgment congruent extension equality index expressions arbitrary types notice application rules generates constraints 
instance constraint generated order derive difficult details space limitation 
interested point detailed formal development dml :10.1.1.41.548
features de caml section examples unique significant features de caml preparing case studies section 
programmer declares datatypes programming ml 
instance datatype declaration defines type constructor type list nil cons list roughly speaking declaration states polymorphic list formed cons types list list list respectively 
type variable 
declared type list coarse 
instance type distinguish empty list non empty 
de caml type refined follows 
refine list nat nil nat cons list list nat means refine type list index sort nat index natural number 
case index stands length list 
nil means type list list length nat cons list means type nat list list natural cons yields list length element type list length note nat universal quantifier usually written type theory 
list types informative 
code defines append function lists 
infix operator 
rec append function ys ys xs ys append xs ys withtype nat nat list list list clause type annotation supplied programmer simply states function returns list length pair lists lengths respectively 
informal description type checking case 
clause ys ys type checker assumes types list index variable 
implies ys type list list 
type checker instantiates respectively verify right side type list 
type list assumption type checker generates constraint assumption natural number 
constraint easily verified 
type check second clause xs ys append xs ys 
assume xs ys type list list respectively index variables sort nat 
xs ys type list list instantiate respectively 
infer right side append xs ys type list assumed types list list respectively 
need prove right side type int list leads constraint immediately verified assumption natural numbers 
finishes typechecking de caml program 
interested reader referred formal presentation type checking dml :10.1.1.41.548
clearly natural question type reconstructed synthesized 
simple example highly possible 
experience indicates exceedingly difficult general synthesize dependent types practice formally studied issue 
refining type allowed declare dependent type de caml 
instance declare 
datatype list nat nil nat cons list declaration basically equivalent refinement earlier 
significant difference 
declare refinement able interpret corresponding unrefined types terms refined ones 
example refining type list interpret type terms refined list type 
need existential dependent types purpose 
list interpreted nat list list list unknown natural number note nat existential quantifier written type theory 
provides smooth interaction ml types dependent types 
suppose defined list type refined type list list 
refining list type assign type nat list nat list takes list unknown length returns list unknown length 
possible applied argument dependent type say int list 
essential ensuring backward compatibility important issue existing ml code concerned 
need imposing restriction datatype refinement 
give short example illustrate need 
datatype tree declared follows binary trees 
datatype tree leaf node tree tree suppose declare refinement type index standards height tree 
refine tree nat leaf nat node tree tree refinement problematic type nat tree standards type perfect binary trees represent original tree type binary trees 
syntactic restriction imposed rule problematic datatype refinements 
mentioning restriction simply needed 
important existential dependent types 
order guarantee practical type checking de caml constraints relatively simple 
currently accept linear integer constraints 
immediately implies realistic constraints inexpressible type system de caml 
instance code implements filter function list removes list elements satisfying 
filter function xs filter xs filter xs general impossible know length list filter knowing impossible type function universal dependent types 
know length filter xs equal invariant captured types 
bool nat list nat list note nat stands significant existential dependent types represent range values 
nat int array represent type vectors elements natural numbers 
datatype nat nat nat rec diff function mod diff diff withtype nat nat int int rec size function size diff withtype nat int implementation size function braun trees useful eliminating array bound checks run time :10.1.1.36.3970
general view existential types de caml handling functions filter crucial scalability type system de caml functions abundant practice 
lastly mention convention de caml 
declaring dependent type follows datatype may write stand 
example list stands nat list 
case studies section examples demonstrate dependent datatypes capturing invariants data structures 
examples de caml successfully verified prototype compiler de caml written top caml light compiler 
claim dependent datatypes enable programmer implement algorithms way robust easier understand 
braun trees braun tree balanced binary tree branch node tree left subtree size right subtree contains element 
braun trees give neat implementations flexible arrays priority queues 
algorithm computes size braun tree time size braun tree 
implement algorithm 
declare dependent datatype braun trees size note type nat nat states yields braun tree size element braun tree size braun tree size holds 
exactly captures invariant braun trees mentioned 
number natural braun tree size satisfying yields difference function size function braun trees defined straightforwardly 
interesting point example type precisely indicates size function braun trees states function returns integer value braun tree size reason diff yields difference size 
give brief explanation 
clear leaf left right branches respectively 
odd holds 
readily verified odd similar reasoning eventually prove correctness defined 
example shows datatype type declaration braun trees contains size information information available run time recursive walk tree necessary determine size tree 
random access lists random access list list representation list lookup update implemented efficient way 
case lookup update function takes time contrast usual time worst case length input list 
implementation random access list figures 
declare dependent datatype random access lists 
note rlist stands type random access lists length nil constructors empty singleton random access lists respectively 
furthermore odd form random access lists odd lengths respectively 
ifl andl represent lists respectively represents list similarly represent lists respectively odd represents data structure implement lookup update function random access list takes time 
crucial invariant data structure thatl andl length formed orl contains element formed 
clearly captured dependent datatype declaration rlist 
function cons appends element list decomposes list pair consisting head tail list 
note type requires function applied non empty list 
takes time 
safe deserves explanation 
type function indicates applied natural number value length ofl 
notice look simply need check datatype rlist nat nil nat rlist rlist nat odd rlist rlist exception subscript rec cons function nil odd cons odd cons withtype nat rlist rlist rec function nil match nil odd odd withtype nat rlist rlist rec length function nil length odd length withtype nat rlist int rec lookup safe function mod lookup safe lookup safe odd mod lookup safe lookup safe withtype nat nat int rlist implementation random access lists de caml rec update safe function mod update safe update safe odd mod odd update safe odd update safe withtype nat nat int rlist rlist implementation random access lists de caml ii datatype rlist nat nil nat rlist nat odd rlist nested dependent datatype random access lists natural number length ofl case 
usual lookup function implemented usual follows 
rec lookup raise subscript length raise subscript lookup safe withtype int rlist point implementation random access lists uses feature nested datatypes :10.1.1.54.6229
okasaki implementation supports average time consing operations superior implementation respect 
hand update function okasaki implementation requires higher order feature exist implementation 
view edge implementation 
stressed nested datatypes dml style dependent types orthogonal 
instance form nested dependent datatype random access lists imitating corresponding datatype :10.1.1.54.6229
unfortunately currently experiment dependent datatype polymorphic recursion supported caml light 
red black trees red black tree rbt balanced binary tree satisfies conditions leaves marked black nodes marked red black node number black nodes path connecting node leaf number called black height node sons red node black 
common practice rbt data structure implementing dictionary 
declare datatype precisely captures properties rbt 
type key int sort color int datatype rbtree color nat nat color cl color cr color bh nat bh rbtree cl bh key rbtree cr bh cl color cr color bh nat bh cl cr rbtree cl bh key rbtree cr bh restore function withtype cl color cr color bh nat vl nat vr nat vl vr rbtree cl bh vl key rbtree cr bh vr color rbtree bh exception item exists insert rec ins function restore ins restore ins raise item exists ins ins raise item exists withtype color bh nat rbtree bh color nat rbtree bh match ins withtype color bh nat key rbtree bh bh nat rbtree bh red black tree implementation declared type index expressions representing colors nodes 
black red 
simplicity integers keys 
course readily ordered data structures 
indexed triple bh color node black height tree number color violations 
record color violation red node followed red node rbt color violations 
clearly types constructors indicate color violations cano occur top node 
notice leaf considered black 
datatype declaration explanation clear type rbt simply color bh nat rbtree bh tree top node color black height color violations 
involved task implement rbt 
implementation basically adopted minor modifications :10.1.1.54.6229
explain insertion operation rbt implemented 
clearly invariant intend capture inserting entry rbt yields rbt 
words intend declare insertion operation type 
key color bh nat rbtree bh color bh nat rbtree bh insert entry rbt properties rbt may violated 
properties restored rotation operations 
defined purpose 
type easy understand 
states function takes entry tree color violation rbt returns rbt tree 
trees argument black height natural number returned rbt black height information great help understanding code 
information informally expressed comments difficult know comments trusted 
notice trivial verify information manually 
imagine appreciate availability type checker perform automatically 
great difference type checking pattern matching clauses dml ml 
operational semantics ml requires pattern matching performed sequentially chosen pattern matching clause matches value 
instance definition clause chosen run time know argument match clauses ahead 
taken account typechecking pattern matching dml 
approach expand patterns disjoint ones 
instance pattern expands patterns range patterns ande 
unfortunately expansion may lead combinatorial explosion 
alternative require programmer indicate expansion needed 
currently available de caml author taken inconvenience expand patterns disjoint ones necessary 
emphasize code expanded order pass type checking de caml 
fixed straightforwardly currently unclear method solve problem best 
complete implementation insertion operation follows immediately 
notice type indicates may return tree color violation applied tree red top node 
fixed replacing top node black returned tree red top node 
extra index indicate size rbt 
show insert function returns rbt size rbt size note exception raised inserted entry exists tree 
please refer details 
binomial heaps binomial tree defined recursively binomial tree rank consists single node binomial tree rank consists linked binomial trees rank root leftmost son binomial heap collection binomial trees satisfy properties binomial tree heap ordered key node greater equal key parent binomial tree root degree 
please refer details 
declare datatypes forming binomial heaps 
binomial trees rank list binomial trees decreasing ranks list empty rank binomial tree list 
represent binomial heap list binomial trees increasing ranks 
heap heap empty rank binomial tree heap 
notice attach rank tree node order efficiently compute rank tree type guarantee component node represents rank node 
notice datatype binomial trees capture invariant stating trees 
reach dependent datatypes 
note able capture invariants ordinary list constructors nil cons form tree lists 
leads 
special feature programming dependent datatypes unpleasant consequence mention section 
implementation largely adopted :10.1.1.54.6229
type function merge relatively complex explain follows 
type states binomial heaps types heap heap respectively function returns binomial heap type heap 
limitation mention limitations dependent datatypes section 
order capture invariants may declare new datatypes existing ones 
instance declared existing list constructors form list trees 
reason wanted form lists binomial trees decreasing rank 
similarly introduced capture invariant binomial heap list trees increasing order 
forces define function heap essentially reverses list trees append heap 
existing list constructors declaring existing function lists heap 
order words dependent datatypes may lose opportunities code reuse 
limitation illustrated example 
constructor declared form braun trees 
suppose occurs code programmer knows reason size contains element established type system de caml 
case code rejected de caml typechecker code cause run time error trust programmer 
situation similar case move untyped programming language typed 
solution problem introduce run time checks 
instance may define function size size raise illegal argument withtype int readily pass type checking de caml refer interested reader details :10.1.1.41.548
penalty case takes time build tree size avoided store size information node 
general programmer anticipates situation occur frequently sure run time checks done efficiently switch back non dependent datatypes 
datatype tree nat nat node int int nat nat nat tree datatype heap nat nat nat tree heap rank function node withtype nat tree int root function node withtype nat tree int link node ts function node ts node ts node ts withtype nat tree tree tree rec function ts ts rank rank ts link ts withtype nat nat tree heap nat heap insert hp node hp withtype int nat heap nat heap rec merge function hp hp hp hp hp hp hp hp rank rank merge hp hp rank rank merge hp hp hp merge hp hp link hp withtype nat nat heap heap nat min heap implementation binomial de caml exception heap empty rec function raise heap empty hp hp hp root root hp hp withtype nat heap nat nat tree heap findmin hp hp root withtype nat heap int rec heap hp function hp ts heap hp ts withtype nat nat heap heap deletemin hp node ts hp hp merge heap ts hp withtype heap heap implementation binomial heap de caml ii recommend programmer avoid complex encodings dependent datatypes capture invariants data structures 
related type systems program error detection ubiquitous 
usually types general purpose programming languages ml java relatively sake practical type checking 
languages types program verification effective limited 
viewed providing expressive type system allow programmer capture program properties types catch errors compile time 
consequence types serve informative program documentation facilitating program comprehension 
assign priority practicality type checking language design emphasize need restricting expressiveness type system 
compared traditional dependent type systems ones underlining coq nuprl far refined type system dml :10.1.1.41.548
give comparison notion indexed types earlier version described notion refinement types notion sized types programming language cayenne :10.1.1.47.155
studies nested datatypes constructing sophisticated datatypes capture invariants data structures :10.1.1.31.3551
instance variety examples 
feel advantage approach requires relatively minor language extensions may include polymorphic recursion higher order kinds rank polymorphism existing functional programming languages haskell type checking dml involved 
hand approach flexible requiring involved treatment type program level 
important notion datatype refinement dml captured nested datatypes 
instance impossible form nested datatype capture notion length list imply simply types distinguish non empty lists empty ones 
general think approaches essentially orthogonal spite similar motivations development readily combined little effort 
dependent datatypes capturing invariants data structures novel 
practice offer advantages implement algorithms advanced programming languages equipped mechanism 
significant advantage probably program error detection 
argued section imprecision datatypes standard ml haskell capturing invariants rich source run time program errors 
addition dependent type annotations supplied programmer mechanically verified fully trusted 
serve valuable program documentation facilitating program understanding 
various uses dependent datatypes compiler optimization 
type checking dml largely independent size program type checking unit roughly body toplevel function 
general matters type checking difficulty level properties checked 
serious issue report error messages case type errors 
type checking de caml implements top style algorithm usually pinpoints location type error 
unfortunately author finds may surprisingly difficult cause type error 
positive side type checker de caml capable detecting variety subtle errors 
instance author form random list type checker raised error prove thatl 
gone unnoticed invalidated invariant assumed programmer potentially causing difficult run time errors 
currently process gathering statistics regarding de caml 
usual focus data structure design mainly enhancing time space efficiency attention paid program error detection 
dependent datatypes provides opportunity remedy situation 
general interested promoting light weight formal methods practical programming enhancing robustness programs 
concrete examples dependent datatypes support promotion 
hope examples raise awareness dependent datatypes implementing algorithms 
acknowledgment chris okasaki ralf hinze anonymous referee constructive comments undoubtedly raised quality 
lennart augustsson :10.1.1.47.155
cayenne language dependent types 
proceedings rd acm sigplan international conference functional programming pages 
richard bird lambert meertens :10.1.1.31.3551
nested datatypes 
mathematics program construction pages 
springer verlag lncs 
richard bird ross paterson 
de bruijn notation nested datatypes 
journal functional programming appear 
braun rem 
logarithmic implementation arrays 
technical report memorandum ms university technology 
robert constable implementing mathematics nuprl proof development system 
prentice hall englewood cliffs new jersey 
thomas charles leiserson ronald rivest 
algorithms 
mit press cambridge massachusetts 
rowan davies 
practical refinement type checking 
thesis proposal november 
gilles dowek amy felty hugo herbelin rard huet chet murthy catherine parent christine paulin mohring benjamin werner 
coq proof assistant user guide 
rapport techniques inria rocquencourt france 
version 
tim freeman frank pfenning 
refinement types ml 
acm sigplan conference programming language design implementation pages toronto ontario 
ralf hinze 
numerical representations higher order nested types 
technical report iai tr institut informatik iii universit bonn april 
ralf hinze 
constructing red black trees 
proceedings workshop algorithmic aspects advanced programming languages september 
ralf hinze 
manufacturing datatypes 
proceedings workshop algorithmic aspects advanced programming languages september 
available technical report iai tr institut informatik iii universit bonn 
john hughes lars pareto amr sabry 
proving correctness reactive systems sized types 
conference record rd acm sigplan symposium principles programming languages pages 
inria 
caml light 
caml inria fr 
robin milner mads tofte robert harper macqueen 
definition standard ml 
mit press cambridge massachusetts 
chris okasaki 
algorithms braun trees chris okasaki 
journal functional programming november 
chris okasaki :10.1.1.54.6229
purely functional data structures 
cambridge university press 
chris okasaki 
fast exponentiation square matrices adventure types 
proceedings th acm sigplan international conference functional programming september 
simon peyton jones haskell non strict purely functional language 
available www haskell org february 
xi pfenning :10.1.1.36.3970
eliminating array bound checking dependent types 
proceedings acm sigplan conference programming language design implementation pages montreal june 
xi pfenning :10.1.1.41.548
dependent types practical programming 
proceedings acm sigplan symposium principles programming languages pages san antonio january 
hongwei xi :10.1.1.41.548
dependent types practical programming 
phd thesis carnegie mellon university 
pp 
viii 
available www cs cmu edu dml thesis ps 
hongwei xi 
programming examples de caml 
available www cse ogi edu hongwei dml examples 
christoph zenger 
indexed types 
theoretical computer science 
christoph zenger 
typen 
phd thesis fakult informatik universit karlsruhe 
forthcoming 

