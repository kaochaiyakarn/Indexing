ieee transactions information theory vol 
february design capacity approaching irregular low density parity check codes thomas richardson amin shokrollahi member ieee urbanke design low density parity check ldpc codes perform rates extremely close shannon capacity 
codes built highly irregular bipartite graphs carefully chosen degree patterns sides 
theoretical analysis codes 
assuming underlying communication channel symmetric prove probability densities message nodes graph possess certain symmetry 
symmetry property show assumption cycles message densities converge number iterations tends infinity 
furthermore prove stability condition implies upper bound fraction errors belief propagation decoder correct applied code induced bipartite graph degree distribution 
codes optimizing degree structure underlying graphs 
develop strategies perform optimization 
simulation results codes show performance codes close asymptotic theoretical bounds 
index terms belief propagation irregular low density codes low density parity check codes turbo codes 
irregular low density parity check ldpc codes exhibit performance extremely close best possible determined shannon capacity formula 
binary input additive white gaussian noise bi awgn channel best code rate half threshold db capacity simulation results show best ldpc code length achieves bit error probability db away capacity surpassing best turbo codes known far 
ldpc codes possess distinct advantages turbo codes 
belief propagation decoding ldpc codes fully parallelizable potentially accomplished significantly greater speeds 
second indicated earlier low complexity decoders closely approximate belief propagation performance may manuscript received may revised september 
material part ieee international symposium information theory sorrento italy june 
richardson bell labs lucent technologies hill nj usa 
technologies nj usa mail richardson com 
shokrollahi bell labs lucent technologies hill nj usa 
digital fountain san francisco ca usa mail amin com urbanke bell labs 
epfl dsc ch lausanne mail urbanke epfl ch 
communicated associate editor coding theory 
publisher item identifier 
ieee fig 

qy ta regular ldpc code length ih rate half 
variable nodes check nodes 
check node check node sum gf pa adjacent variable nodes equal zero 
designed codes 
third ldpc decoding verifiable sense decoding correct codeword detectable event 
practical objection ldpc codes encoding complexity high 
way get problem slightly modify construction codes bipartite graphs cascade graphs see :10.1.1.35.5754
alternative solution practical purposes require cascades 
recall basic notation 
originally suggested tanner ldpc codes represented bipartite graphs set nodes variable nodes corresponds elements codeword set nodes check nodes corresponds set parity check constraints define code 
regular ldpc codes nodes type degree 
example regular ldpc code graphical representation variable nodes degree check nodes degree bipartite graph determining code shown fig 

irregular ldpc codes introduced studied :10.1.1.35.5754
irregular ldpc code degrees set nodes chosen distribution 
irregular ldpc code ieee transactions information theory vol 
february graphical representation half variable nodes degree half degree half constraint nodes degree half degree length degree distribution define ensemble codes choosing edges connections variable check nodes randomly 
precisely enumerate edges emanating variable nodes arbitrary order proceed way edges emanating check nodes 
assume number edges code particular instance ensemble identified permutation letters 
definition elements ensemble equiprobable 
practice edges chosen entirely randomly certain potentially unfortunate events graph construction easily avoided 
asymptotic analysis ldpc codes message passing decoding 
briefly recall main results assume setup 
channel ordered family binary input memoryless channels parameterized real parameter channel parameter physically degraded version channel parameter see 
furthermore channel family output symmetric ensemble say polynomial form degree distribution nonnegative coefficients note associate coefficient see notation introduced leads elegant compact descriptions main results :10.1.1.35.5754
degree distribution pair associate sequence code ensembles length code specifies variable check node degree distribution 
precisely represents fraction edges emanating variable check nodes degree example regular code maximum variable degree check degree denoted respectively 
assume code variable nodes 
number variable nodes degree total number edges emanating variable nodes equal reassuring note linear binary codes known capable achieving capacity binary input memoryless output symmetric channels see 
manner assuming code check nodes expressed equating expressions conclude generically assuming check equations linearly independent see design rate equal shown :10.1.1.35.5754
message passing decoder select message passing decoder 
definition messages contain extrinsic information message emitted edge depend incoming message edge 
decoder fulfills symmetry conditions 
condition check node slightly involved 
edge emanating check node flipping sign incoming messages arriving node excluding message edge results change sign outgoing message edge cases sign changed reliability remains unchanged 
generally require decoder asymptotically monotonic respect channel parameter 
roughly speaking means limit infinitely long codes probability error decoder nondecreasing channel parameter fixed number iterations 
case belief propagation decoder property direct consequence decoder asymptotic optimality fact consider families channels ordered physical degradation see section iii 
decoders interest monotonicity property proved directly hold virtually decoders interest 
interested exclusively decoder shall implicitly assume monotonicity 
assumptions channel family fixed exists threshold maximum channel parameter properties 
exists length number code bit error probability smaller assuming transmission takes place channel parameter iterations message passing decoding performed 
conversely fixed upper bound number iterations transmission takes place channel parameter code bit error precisely fraction codes statement true converges exponentially fast 
richardson design capacity approaching irregular low density parity check codes probability larger constant depend number iterations performed 
main steps taken arrive 
shows fixes number iterations performance various realizations graph channel concentrate expected value concentration exponential length code 
exponent may general depend degree distribution pair chosen message passing decoder channel parameter 
order characterize performance sufficiently long codes suffices determine average performance 
unfortunately easy task determine average performance finite length ensembles 
limit long codes average performance determined follows 
observes probability decoding neighborhood variable node tree contain repetitions cycles 
decoding neighborhood tree performance decoder fairly straightforward determine involved random variables independent 
mentioned symmetry assumptions channel decoder assume codeword transmitted conditional bit error probability independent transmitted codeword 
convention choose messages way codeword assumption positive messages signify correct messages negative messages indicate errors 
case belief propagation decoders messages log likelihood ratios form distribution messages initially emitted determined channel associated probability error 
independence assumption track evolution message distributions progress tree root 
particular interested evolution error probability function iteration number 
threshold defined worst channel parameter message distribution evolves way associated probability error converges zero number iterations tends infinity 
procedure tracking evolution message distribution termed density evolution 
efficient numerical procedure developed implement density evolution important case belief propagation decoders efficiently compute associated threshold desired degree accuracy 
threshold values simulation results variety noisy channel models class ldpc codes considered largely restricted regular codes 
results indicating remarkable performance achieved properly chosen irregular codes 
idea underlying quite straightforward 
assume interested transmission particular family binary conjecture stronger statement true codes ldpc ensemble bit error probability regardless length regardless iterations performed 
proofs obtained exponent depends degree distribution pair ax ticular message passing decoder 
pair degree distributions associated threshold call natural search pairs maximize threshold 
accomplished great success case erasure channel :10.1.1.35.5754
memoryless channels interest situation complicated new methods brought bear optimization problem 
fig 
compares performance instance regular ldpc ensemble best regular ensemble performance instance best irregular ldpc ensemble search performance instance standard parallel concatenated ensemble introduced berrou glavieux 
codes rate half performance belief propagation decoding shown code word length shown shannon limit threshold value best ldpc ensemble itis evident considerable benefit derived optimizing degree distribution pairs 
bit error probability best ldpc code db away capacity 
surpasses performance turbo codes 
impressive threshold indicates performance infinite lengths mere db away shannon capacity limit 
empirical evidence fig 
results section ii beg question ldpc codes belief propagation decoding achieve capacity binary input memoryless output symmetric channel 
definitive results direction give explicit sequences degree distribution pairs thresholds binary erasure channel bec converge shannon capacity limit :10.1.1.35.5754
theorem due gallager imposes binary symmetric channel bsc necessary condition ldpc codes achieve capacity maximum check degree tend infinity 
result bounds performance ldpc codes away capacity gap extremely small gap converges zero exponentially fast great theoretical interest theorem impose significant practical limitation 
theorem ldpc code rate bsc crossover probability assume codeword equal probability 
binary entropy function may optimize degree distribution pairs various constraints 
example larger degrees larger code size needs order approach predicted asymptote 
highly desirable look best degree distribution pair priori bound size degrees 
case maximum likelihood decoding answered affirmative gallager mckay see 
conjecture similar statement proof continuous channels 
fact similar theorem holds erasure channel theorem capacity achieving sequences degree distributions channel 
ieee transactions information theory vol 
february fig 

comparison error rates achieved qy ta regular ldpc code turbo code optimized irregular ldpc code 
codes length ih rate half 
bit error rate shown function ax decibels standard deviation raw input bit error probability block bit error probability bounded away zero constant independent discussion note capacity bsc equal finite wehave quick calculation shows gap capacity approximated decreases zero exponentially fast gallager stated theorem regular codes 
examination proof reveals remains valid case irregular codes interpreted maximum check node degree 
key proof lies realization entropy received word bounded follows received word describe specifying value systematic bits equivalent specifying codeword plus value specify coset 
parity probability strictly half entropy received word strictly bits gives rise stated upper bound 
details proof 
outline follows 
start presenting tables degree distribution pairs section ii 
focus rate half give examples different channels rates 
discuss simulation results show promised performance closely achieved reasonably long codes 
section iii describe study properties density evolution 
assumption input distribution arises symmetric channel show message distributions note slightly sharper bound replace average degree fraction highest degree nodes 
improvement usually slight exact size gap significant practice leave details interested reader 
satisfy certain symmetry condition invariant density evolution 
simplifications arise symmetric channel case afford considerable insight nature density evolution 
particular derive stability condition gives rise upper bound threshold case general binary input memoryless output symmetric channels 
show threshold partially characterized non existence fixed points density evolution 
section iv describe numerical optimization techniques generate tables section ii 
motivate definitions statements general binary input memoryless output symmetric channels counterpart bec channel 
see despite simplicity bec model iterative decoding properties shared general class channels considered 
ii 
capacity approaching degree distribution paris optimization results numerical optimization techniques described detail section iv searched degree distribution pairs rate half various upper bounds maximum variable degree result search bi summarized tables ii 
table contains degree distribution pairs table ii contains degree distribution pairs table columns correspond particular degree distribution pair 
degree distribution pair coefficients threshold assume standard pulse amplitude modulation pam signaling hy richardson design capacity approaching irregular low density parity check codes table degree distribution pairs rate half maximum variable node degrees ary sy ty uy vy wy ip 
degree distribution pair threshold value corresponding decibels ia input bit error probability hard decision decoder 
listed maximum stable value ia corresponding value decibels raw bit error probability input quantized bit known function 
section iii show channel maximum stable value call precisely show degree distribution pair strictly larger probability bit error converge zero regardless iterations performed 
value listed tables 
required see listed degree distribution values fairly close 
results quite encouraging 
compared regular ldpc codes highest achievable threshold irregular ldpc codes substantially higher thresholds 
threshold increases initially rapidly largest investigated degree threshold value db away capacity 
quite tempting conjecture threshold converge ultimate shannon limit precision equal rate half codes tends infinity 
unfortunately moment empirical evidence support conjecture 
focus mainly binary codes rate half examples show techniques find degree distribution pairs memoryless channels different rates 
note particular rate degree distribution pairs optimized usually degree distribution pairs large class channels including binary input laplace channel bsc 
nev optimizing degree distribution pair particular channel generally give better results 
example example consider codes rate channel 
rate shannon bound degree distribution pair theoretical threshold allowing higher degrees certainly result degree distribution pairs larger thresholds 
example bsc ultimate threshold shannon limit bsc rate half best degree distribution pair far ieee transactions information theory vol 
february table ii degree distribution pairs rate half maximum variable node degrees phy sh 
degree pair threshold value corresponding db ia input bit error probability hard decision decoder 
listed maximum stable value ia allowed maximum variable node degree maximum check node degree example consider binary input laplace channel continuous output alphabet additive noise 
precisely channel modeled random variables probability density ultimate threshold rate shannon formula equal degree distribution pair threshold maximum variable node check node degrees respectively 
simulation results concentration results proved guarantee sufficiently large block lengths code ensemble vanishing probability bit error channels parameters calculated threshold 
lengths required proofs far practical values expect medium sized codes deviate significantly predicted performance 
maximum possible number loop free iterations grows logarithmically block length priori doubtful simulation results practical lengths closely match predicted asymptotic performance 
regular ldpc codes demonstrated actual convergence faster realistically sized block codes perform close asymptotic value 
irregular codes finite length effects include deviation input variance mean nonzero probability small loops deviation support tree average node fraction neighbors node degree deviate expected value 
effect expected influence finite length performance severely larger operating close degree distribution pair threshold require large number iterations reach target bit error probabilities say 
limit number iterations converges fortunately small margin degree distribution pair threshold typically drastically reduce required number iterations 
simulation results show irregular case actual convergence performance finite length codes asymptotic performance faster predicted bounds appearing analysis 
fig 
shows performance particular ldpc codes 
chosen lengths start go 
precisely lengths maximum variable degrees appearing respectively 
case decoder run iterations get best possible performance 
number practically useful iterations function length interest question parameter design shall address issue 
length error rates systematic bits 
specific encoder constructed 
length error rate bits codeword 
graphs chosen entirely randomly 
degree nodes loop free lengths length case correspond nonsystematic bits 
length graph randomly constructed double edges loops variable nodes avoided 
shorter lengths small loop removal performed 
note particularly small lengths better richardson design capacity approaching irregular low density parity check codes fig 

comparison bit error rates achieved turbo codes dashed curves ldpc codes solid curves lengths ih ih ih codes rate half 
observe longer ldpc codes outperform turbo codes gap significant larger chosen 
short lengths appears structure turbo codes gives edge ldpc codes despite having lower threshold 
performance achieved degree distribution pairs smaller values degree distribution pairs smaller threshold 
see actual performance quite close predicted asymptotic performance longer lengths codes beat best known turbo code length 
bits code db away capacity bit error probabilities ldpc codes slightly lower complexity fully parallelizable allow different decoding algorithms far ranging tradeoff performance complexity ldpc codes considered serious competitors turbo codes 
spent considerable amount computing time optimization clear degree distribution pair slightly improved patience 
iii 
analytic properties density evolution section study exhibit analytic properties density evolution belief propagation decoders 
loss generality assume codeword transmitted messages represented log likelihood ratios 
independence assumption give compact mathematical description evolution message densities proceed tree 
doing largely follow 
show output symmetric channels received message degree distribution pairs giving highest threshold maximum degree constraint 
small graphs best pick degree distribution pair highest threshold 
designing degree distribution pairs small graphs advantageous look highest possible threshold appropriate constraint allowed number iterations 
accomplished 
distribution symmetric symmetry preserved belief propagation decoding 
discuss stability condition density evolution stems analyzing convergence behavior density evolution assumption small error probabilities achieved evolution process 
give partial characterization threshold terms non existence fixed points density evolution recursion 
topic motivate definitions statements considering equivalent definitions statements simple case bec 
quite surprisingly simple nature bec find results extend general case 
belief propagation main result section stated theorem explicit recursion connects distributions messages passed variable nodes check nodes consecutive iterations belief propagation 
case bec task accomplished shown expected fraction erasure messages passed th iteration call evolves general binary input memoryless output symmetric channels situation involved keep track evolution general distributions usually parameterized single parameter :10.1.1.35.5754
recalling belief propagation algorithm 
standard binary pam map 
iteration messages passed edges graph variable nodes incident check nodes back 
messages typically real valued ieee transactions information theory vol 
february take values reflecting situation bits known absolute certainty 
generically messages sent th iteration denoted denote message sent variable node incident check node denote message passed check node incident variable node message represents quantity random variable describing codeword bit value associated variable node random variable describing information incorporated message 
bayes rule equally message log likelihood ratio random variable assumption 
independence see shortly represent updates performed check nodes alternative representation messages appropriate 
define map gf follows 
remarks order 
define slightly unconventional probabilistic definition sign function probability probability sign assignment effect algorithm useful certain definitions follow 
log likelihood ratio codeword bit associated variable node conditioned channel observation bit 
update equations messages belief propagation set check nodes incident variable node set variable nodes incident check node easy check belief propagation decoder defined fulfills symmetry conditions discussed section restrict output symmetric channels assume codeword transmitted loss generality reader wonder cia defined impossible belief propagation node receive message ci message ix message implies absolute certainty value associated bit opposite signs 
assumptions conditional error probability independent transmitted codeword see 
sequel interested output symmetric channels assume codeword transmitted 
note case observed fulfill follows log likelihood ratios take values range short glance update equations shows messages sent course belief propagation lie range message take value distributions channels bec bsc density received log likelihood ratios discrete 
density continuous 
case message densities discrete second case message densities continuous 
order able treat cases uniform manner shall fairly general class distributions 
reader casually interested technical aspects advised think smooth densities associated continuous distributions skim current section 
denote space right continuous nondecreasing functions defined satisfying associate random variable random variable law distribution reason allow permit probability mass random variable completely specified distribution element define left limit note left continuous 
densities formally treated radon derivatives elements derivative exists density associated random variable may additional point mass recall densities primarily way 
lebesgue stieltjes integral defined nonnegative continuous functions density corresponding distribution write proxy consider update equations belief propagation 
note consist com exists include term aa aa definition 
purposes case notation ah need concerned issue 
richardson design capacity approaching irregular low density parity check codes ponents summation messages messages log likelihood ratio representation represented sign reliability ii change representation 
interested evolution message distributions independence assumption 
discuss distributions evolve independent random variables representation summed representation variables changed 
convolution defined generalizes notion convolution densities corresponding densities respectively distribution corresponding density write arbitrary densities indicate density associated distribution easy check independent random variables distributions respectively distribution case independent random variables defined 
suppose random variable distribution wish describe distribution random variable defined 
approach problem assigning connected distributions associated conditions respectively 
function gf written denotes characteristic function set 
denote space functions gf nondecreasing right continuous 
conditions correspond conditions functions random variable distribution define distribution integral defined right continuity determines rest 
note particular element speak densities gf substituting associated densities 
definition analogous point mass magnitude point masses magnitude corresponds assigning equally 
shall interested densities gf satisfy conditions 
function defined inverse 
easy check additive operators spaces respectively 
convenience constitutes abuse notation apply densities 
implicitly understood notation representation appropriate operation applied distributions 
space defined convolution 
convolution distributions distribution denotes sided convolution standard distributions 
words new convolution convolution group gf abuse notation denote new convolution symbol shall allow convolution operator act densities associated elements implicit understanding provides rigorous definition 
independent random variables gf distributions respectively distribution example give examples densities interest 
denote density corresponding distribution words denotes dirac delta function 
special case corresponds distribution density ieee transactions information theory vol 
february expressed distributions density expressed distributions description density evolution symbols shorthand notations densities random variables respectively 
notation distributions 
denote associated see random variable describing message passed check node variable node image sum random variables gf random variables independent independence assumption 
density sum convolution densities 
graph degree distribution pair recall fraction edges connected variable node degree fraction edges connected check node degree randomly chosen edge graph connected check node degree probability probability sum terms corresponding edges connecting neighbors conclude case density equal summing possibilities degrees check node see density message equals equation explains unusual definition recursion terms derived similarly quite straightforward 
density message passed check node variable node round equal incoming messages check nodes added received value result sent back independence assumption random variables describing messages independent density message equals density random variable describing channel 
combining obtain desired recursion terms theorem binary input output symmetric memoryless channel denote initial message density log likelihood ratios assuming codeword transmitted 
fixed degree distribution pair denotes density messages passed variable nodes check nodes th iteration belief propagation independence assumption operators defined respectively 
discussion result previous theorem complete agreement result erasure channel obtained previously fact contains special case :10.1.1.35.5754
distributions case easily seen obtain recover formula proved :10.1.1.35.5754
symmetry definition symmetry call symmetric function integral exists 
densities equivalent statement density symmetric example symmetric 
aim section prove density functions messages passed variable check nodes belief propagation symmetric provided channel output symmetric 
theorem binary input memoryless channel denote initial message density log likelihood ratios assuming word transmitted 
fixed degree distribution pair define symmetric 
note immediate corollary 
distribution density define error probability operator corollary converges zero iff converges definition convergence see section iii richardson design capacity approaching irregular low density parity check codes proceeding proof theorem exemplify symmetry known noise densities 
example bec erasure channel initial message density linear combinations symmetric functions symmetric result follows symmetric 
example bsc bsc crossover probability initial message density symmetry need prove straightforward 
example initial message density symmetry condition verified example final example initial message density laplace channel easy check symmetry condition fulfilled 
proof theorem proceed steps 
establish symmetry initial message density general conditions 
done prove symmetry preserved convolutions 
theorem remains show symmetric symmetric 
characterize symmetry prove representation symmetry preserved convolutions 
proofs results densities 
rigorous proof obtained formally translating subsequent proof language distributions 
proposition consider binary input memoryless channel initial message density log likelihood ratio form word assumption 
symmetric 
proof channel symmetry condition obtain show symmetry preserved convolutions 
lemma convolution symmetric distributions symmetric 
proof symmetric densities 
consider iteration formula theorem know symmetric 
prove induction symmetric show symmetric definition say symmetric nonnegative continuous function proposition function symmetric 
symmetric symmetric distributions gf convolution proof density associated symmetry condition see symmetric 
definition convolution density need show symmetric ieee transactions information theory vol 
february sum quantities difference obtain done 
able prove main theorem 
proof theorem outlined induction density evolution formula theorem 
induction anchored proposition symmetric 
assume symmetric 
proposition part symmetric part proposition symmetric 
part proposition implies symmetric 
lemma shows symmetric 
stability consider density evolution bec 
recall degree distribution pair evolution expected fraction erasure messages emitted th iteration call initial fraction erasures equal erasure probability channel 
recall threshold defined supremum values converges zero tends infinity 
easy derive upper bound looking behavior recursion small values expanding right hand side taylor series zero get clearly sufficiently small convergence behavior determined term linear precisely convergence depend smaller larger 
precise statement 
theorem stability condition bec assume degree distribution pair real number define necessity exists constant sufficiency exists constant converges zero tends infinity 
discussion note initial erasure fraction zero fixed point recursion 
natural think condition stability condition fixed point zero 
result proved follow derivation theorem 
uses condition decoding successful inequality aa valid hy stability condition far reaching implications case bec 
name just important immediately gives rise bound shown theorem sequence capacity achieving degree distribution pairs inequality tight 
important role stability condition plays case bec natural ask equivalent condition formulated general binary input memoryless output symmetric channels 
fortunately answer affirmative main result line summarized 
theorem general stability condition assume degree distribution pair symmetric density define assume zero 
neigh necessity exists constant sufficiency exists constant converges zero tends infinity 
discussion bec stability condition gives rise upper bound threshold 
assume channel family parameterized real parameter assume exists unique number message density received values corresponding channel parameter note codes cycle codes stability condition determines threshold exactly see specific examples 
prove necessity stated stability condition 
demonstrating sufficiency quite involved proof 
proof necessity stability condition calculate stability condition explicitly various channels 
example bec bec see example richardson design capacity approaching irregular low density parity check codes stability condition reads stated previously obtained 
example bsc bsc see example follows stability condition bsc example see example stability condition reduces example see example stability condition written reader noticed examples equal constant appears bhattacharyya bound 
coincidence 
constant simply exponent chernoff bound ask probability sum independent samples common density negative 
proof theorem recall case bec observed zero fixed point recursion linearizing recursion fixed point able analyze stability 
general case proceed lines 
recall deal distributions log likelihood ratios 
corollary know zero probability error corresponds density clearly fixed point density evolution 
analyze local convergence fixed point shall consider linearization density evolution fixed point 
equivalently get nontrivial ha ia formulated upper bound gives defined ha ia gives rise defined ha ia effect consider density note density symmetric complete iteration density evolution density evolve generally consider iterations density evolution see density evolve interested error probability associated interested note neighborhood zero defined see 
assume exists integer follows positive constant depending assume iteration claim contradiction shown error probability nonincreasing function number iterations 
show suitable positive constant show argue follows 
consider random tree depth variable nodes leaves variable node root 
leaf nodes observations correspond samples density internal variable nodes observations correspond samples density density message emitted root node compare scenario setup leaf nodes take observations correspond samples density case density message emitted root node note cases estimate root node message maximum likelihood ml estimate 
appendix show lemma think samples density physically degraded samples density claim implies see assume contrary words improve estimate emitted root nodes scenario adding noise observations corresponding leaf nodes applying ml estimate new observations applying ml estimate original observations 
contradicts known fact uniform prior ml estimates minimum probability error 
ieee transactions information theory vol 
february remains prove stated 
general large deviation principle see implies symmetric close subsection posing fundamental open questions 
generally true sequence capacity achieving degree distribution pairs stability condition tight case bec 
possible formulate higher order stability conditions show tight sequence capacity achieving degree distribution pairs case bec theorem 
fixed points density evolution main result section states density evolution belief propagation converges fixed point 
consider example bec associated density evolution recursion 
case complete characterization threshold terms fixed points 
theorem fixed point characterization threshold bec degree distribution pair define define sufficiency converges solution converges zero tends infinity :10.1.1.35.5754
necessity exists fixed point characterizations threshold solution ii solution proof note nonincreasing converges point call clearly exact statement differs result easy consequence statements 
bh fulfills fixed point exists converges zero tends infinity proves assertion 
prove second assertion note fixed point fact nondecreasing function argument finite induction follows remains discuss characterization threshold terms fixed points 
note remarked earlier fixed point recursion fixed point follows characterizations defined 
equivalence characterizations follows fact strictly increasing appear behavior special bec case known belief propagation decoder density evolution dimensional description 
quite surprising sufficiency part complete analog general case 
order generalize results generalize various notions proof 
crucial ingredient argument monotonicity sequence real numbers monotonicity guarantees convergence fixed point recursion 
general case density evolution assert convergence distributions 
show exists large family monotonicity conditions prove convergence 
theorem symmetric densities degree distribution pair define nonincreasing function proof message density represents conditional probability particular bit value 
assume independent observation bit value available decoder assume independent observation obtained passing bit channel fulfills symmetry condition lemma assumption codeword transmitted conditional density bit log likelihood ratios conditioned information incorporated independent observation density new density corresponds maximum posteriori map estimate conditioned information nondecreasing stated monotonicity condition follows 
theorem symmetric density prove useful sequel consider family densities richardson design capacity approaching irregular low density parity check codes clearly symmetric density symmetric density define immediately 
corollary symmetric density degree distribution pair define nonincreasing function show symmetric density uniquely determined basis functionals lemma basic lemma symmetric density uniquely determined proof distribution associated point continuity hard check differentiable symmetry condition implies derivative particular 
recover symmetric proof complete 
generalize convergence results bec provide precise definition notion convergence general symmetric densities 
particular convergence defined 
denote set right continuous nondecreasing functions note say sequence converges sequence converges pointwise points continuity convergence sense implies weak convergence associated lebesgue stieltjes measure 
suitable function important property space sequentially compact 
infinite sequence selection principle see theorem exists subsequence converges element denote subset consisting symmetric functions 
note sequentially compact limit point definition symmetry definition see weak convergence immediately implies symmetry limit 
say sequence symmetric densities converges corresponding distributions converge converges theorem partial fixed point characterization threshold general channels degree distribution pair symmetric density define sufficiency symmetric density sequence densities converges symmetric density fixed point solution 
exist symmetric density fixed point converges zero tends infinity equivalently proof consider sequence message densities 
sequential compactness subsequence converges symmetric limit density call original sequence converge exist subsequence converges distinct symmetric limit follows basis lemma contradiction monotonic function theorem possess distinct limits 
conclude converges density fixed point update equations continuous notion convergence 
furthermore sequence monotonically nonincreasing wehave symmetric density conclude exist fixed point satisfying iv 
optimization section briefly describe optimization techniques obtain degree distribution pairs large thresholds 
general remarks apply numerical optimization technique 
formally threshold defined supremum channel parameters probability error density evolution converges zero 
corollary equivalent requiring message distribution converges practice verify best probability error reaches value prescribed theorem know choose small automatically implies convergence zero probability error 
practice issue convergence great concern allow finite small probability error 
secondly order perform computations need quantize quantities involved 
quantization leads quantization error error accumulate course iterations rendering computations useless 
problem circumvented way 
carefully performing quantization ensure quantized density evolution corresponds exact density evolution quantized message passing scheme 
belief propagation optimal quantized version suboptimal reported thresholds thought lower bounds actual thresholds 
local optimization find degree distribution pairs started simple hill climbing approach 
fix small target error probability maximum number iterations start degree distribution pair determine maximum admissible channel parameter maximum channel parameter error probability iterations apply small change degree distribution pair ieee transactions information theory vol 
february fig 

evolution bit error probability density evolution function iteration number 
fig 

decrease bit error probability function current bit error probability 
check larger admissible channel parameter smaller target error probability iterations 
declare new degree distribution pair currently best degree distribution pair keep original degree distribution pair 
basic step repeated large number times 
search degree distribution pairs substantially accelerated appropriately limiting search space 
example degree distribution pairs exist nonzero terms 
particular suffices allow nonzero check node degrees degrees chosen consecutively limit nonzero variable node degrees maximum degree possibly chosen degrees 
substantial savings running time achieved follows 
particular degree distribution pair fig 
shows evolution bit error probability function iteration number 
clearer picture emerges plot decrease bit error probability function current bit error probability shown fig 

seen figures initial swift decrease bit error probability procedure comes halt decreases bit error probability iteration 
convergence speeds hits low critical points outgoing message distribution fixed point equation system corresponding iteration 
parameter richardson design capacity approaching irregular low density parity check codes slightly increased iteration overcome points verify arise corresponding fixed points density evolution 
provided fixed points stable message distributions points continuous functions degree distribution pair 
small change degree distribution pair causes small changes associated fixed point distributions 
furthermore fixed points stable affords certain density evolution process serve local attractors 
small perturbations path matter domain convergence fixed point entered fixed point path leads irrelevant 
practice observe points density evolution gets stuck stable fixed points 
fixed point theorem section iii shows fixed points limits density evolution marginally stable 
considerations suggest scheme 
assume determine critical points near fixed points fixed points slightly worse initial distribution particular degree distribution pair determine merit particular small change degree distribution pair 
starting initial distribution checking fast initial distribution converges memorize distributions critical points original degree distribution pair determine proposed change affects speed convergence locally points 
promising change merit change verified starting initial degree distribution pair 
typically iterations necessary critical point determine change degree distribution pair improves convergence 
compared hundreds iterations thousands iterations necessary starts initial distribution 
optimization scheme just described distributions critical points find promising changes degree distribution pair 
schemes extend idea resulting algorithms reminiscent algorithms bec case 
simplicity describe optimization variable node degree distribution 
extension check node degree distribution joint optimization quite apparent 
assume degree distribution pair particular channel parameter target probability error sequence error probabilities belief propagation algorithm 
precisely initial error probability probability error th iteration assume want find new degree distribution achieves target probability error fewer iterations achieves lower target number iterations 
define matrix entry error probability results run belief propagation decoder steps assuming variable node degree distribution followed step assume variable node degree distribution singleton mass degree note actual error probability th iteration expressed terms define function linearly interpolating setting define interpret number iterations required take initial probability error expression write gradient respect particular perturbation compute returning discrete representation equivalent observe gradient ways exploit expression 
negative gradient direction hill climbing globally optimize linearized approximation case incorporate constraints alternative degree distribution 
clearly probability mass function correspond code equal rate 
negative gradient direction positive constraints may satisfied 
degree distributions satisfying constraints closest euclidean distance easily computed alternating projections 
projections required orthogonal projection subspace determined total probability constraint rate constraint second projection sets prior projection note alternative interpretation project gradient direction convex polytope admissible directions 
ieee transactions information theory vol 
february compute maximum step size constraints remain satisfied recompute projection point 
way easily walk projected gradient direction look improved degree distribution 
consider second way exploit gradient expression approximation valid long differ assuming message distributions corresponding different recall want minimize right hand side constant linear function degree distribution constraints stated linear approximately accomplished means linear program 
procedure applied repeatedly attempt converge degree distribution 
approaches local optimizations appropriate repeat optimization various initial conditions 
global optimization code design problem described belongs class nonlinear constraint satisfaction problems continuous space parameters 
general algorithms solving problems developed 
experimented algorithm called differential evolution de successfully applied design erasure codes 
de robust optimizer multivariate functions 
describe details suffice say algorithm part hill climbing algorithm part genetic algorithm 
goal maximize cost function define threshold value channel 
optimizers de particular operate best continuous parameter space large dimension frequent function evaluations required optimization convenient parameter space continuous space small dimension 
accomplish introduced fractional phantom distributions 
polynomials take general form similarly degree take positive real value 
real degree distribution obtained phantom distribution uniquely determined equations way guaranteed obtain degree distribution respects rate constraints code 
allowing fractional degrees effect force program choose close optimal degrees 
results significant reduction dimensionality parameter space running time sparsity degree distributions obtained 
appendix channel equivalence lemma say binary input memoryless output symmetric channels equivalent density loglikelihood ratios 
convenient pick representative equivalence class 
done shown lemma 
lemma channel equivalence lemma symmetric density 
binary input memoryless output symmetric channel symmetry associated density log likelihood ratios equal proof appendix erasure decomposition lemma lemma erasure decomposition lemma binary input memoryless output symmetric channel 
denote associated distribution log likelihood ratios channel represented concatenation erasure channel erasure probability ternary input memoryless output symmetric channel physical degraded version erasure channel 
proof recall lemma loss generality may assume symmetry denote erasure denote bit values 
denote channel input alphabet real output set easy check quantities defined densities 
denote concatenation erasure channel channel output erasure channel fed richardson design capacity approaching irregular low density parity check codes note equally inputs output erasure channel input probabilities respectively 
acknowledgment authors wish sae young chung reviewers detailed comments helpful suggestions 
richardson urbanke capacity low density codes message passing decoding ieee trans 
inform 
theory vol 
pp 
feb 
luby mitzenmacher shokrollahi spielman practical loss resilient codes proc :10.1.1.35.5754
th annu 
acm symp 
theory computing pp 

spielman linear time decodable error correcting codes ieee trans 
inform 
theory vol 
pp 
nov 
richardson urbanke efficient encoding low density parity check codes ieee trans 
inform 
theory vol 
pp 
feb 
tanner recursive approach low complexity codes ieee trans 
inform 
theory vol 
pp 
sept 
luby mitzenmacher shokrollahi spielman analysis low density codes improved designs irregular graphs proc 
th annu 
acm symp 
theory computing pp 

improved low density parity check codes irregular graphs belief propagation proc 
ieee int 
symp 
information theory cambridge ma aug 
mackay wilson davey comparison constructions irregular gallager codes ieee trans 
commun vol 
pp 
oct 
gallager information theory reliable communication 
new york wiley 
luby mitzenmacher shokrollahi analysis random processes tree evaluation proc 
th annu 
acm siam symp 
discrete algorithms pp 

shokrollahi storn design efficient erasure codes differential evolution proc 
int 
symp 
information theory sorrento italy june 
berrou glavieux near shannon limit error correcting coding decoding proc 
int 
communications conf 
icc switzerland may pp 

gallager low density parity check codes 
cambridge ma mit press 
mackay error correcting codes sparse matrices ieee trans 
information theory vol 
pp 
mar 
shokrollahi new sequences linear time erasure codes approaching channel capacity proc 
th conf 
applied algebra error correcting codes cryptography lecture notes computer science 
berlin germany springer verlag pp 


chung forney richardson urbanke design low density parity check codes db shannon limit ieee commun 
lett vol 
pp 
feb 
shokrollahi capacity achieving sequences codes systems graphical models ima volumes mathematics applications marcus rosenthal eds 
new york springer verlag vol 
pp 

mor error correcting capabilities cycle codes graphs comb probab computing pp 

horn iterative decoding ph dissertation dept elect 
eng calif inst 
technol ca may 
richardson urbanke proof stability condition ldpc codes preparation 
shwartz weiss large deviations performance analysis 
london chapman hall 
billingsley probability measure rd ed 
new york wiley 
price storn differential evolution simple efficient heuristic global optimization continuous spaces global vol 
pp 

luby mitzenmacher shokrollahi spielman practical loss resilient codes ieee trans 
inform 
theory vol 
pp 
feb 
