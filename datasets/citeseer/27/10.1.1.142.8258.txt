datalog binary decision program analysis john whaley michael monica lam computer science university stanford ca usa lam cs stanford edu 
problems program analysis expressed naturally declarative language datalog 
easy specify new analyses extend compose existing analyses 
previous imple declarative languages perform poorly compared traditional implementations 
describes bddbddb bdd deductive da implements declarative language datalog stratified negation totally ordered finite domains comparison operators 
bddbddb uses bi nary decision diagrams bdds efficiently represent large relations 
bdd operations take time proportional size data structure numberof tuples relation leads fast execution times 
bddbddb effective tool implementing large class program analyses 
show insensitive points analysis implemented bddbddb twice fast carefully hand tuned version 
bdds allows heretofore unsolved problems context sensitive pointer analysis large programs 
program analyses expressed naturally easily logic prolog datalog 
expressing program analysis declaratively logic programming language number advantages 
anal ysis implementation greatly simplified 
analyses expressed lines datalog take hundreds thousands lines code traditional language 
automat ically deriving implementation datalog specification introduce fewer errors 
second analysis information expressed uniform manner analysis results combine analyses 
optimizations datalog applied analyses expressed language implementations logic programming systems slower traditional implementations difficulty scaling large programs 
experiment corel general purpose logic programming system implement demand interprocedural reaching definitions analysis 
logic programming approach times slower native implementation 
dawson prolog perform groundness analysis logic strictness analysis functional programs 
xsb system better efficiency corel able analyze number programs effi ciently 
programs analyzed small lines code 
liu stoller efficient datalog appears promise performance results 
system specifying program analyses datalog successfully programs tens thousands lines source code regularly performed faster handcoded analyses 
discuss experience develop ing points analyses java compare earlier handcoded versions 
discuss results security analysis analysis specified system 
datalog bdds developed system called bddbddb stands bdd 
bddbddb solver datalog stratified negation totally ordered finite domains comparison operators 
bddbddb represents relations diagrams bdds 
bdds novel data structure traditionally hardware verification model checking spread areas original bdds cited papers computer science 
showed bdds implement context insensitive inclusion pointer analysis efficiently 
showed bdd implementation competitive performance traditional im 
zhu investigated bdds pointer analysis 
whaley lam showed bdds solve context analysis large programs exponential number calling contexts heretofore unsolved problem 
bdds solve new analysis problems known efficient algorithms 
datalog logic programming language designed relational databases 
datalog rule series bdd operations find fixpoint solution applying operations rule program converges relations 
bdds represent relations bdd operations operate entire relations iterating individual tuples goal bddbddb hide complexity bdds user 
years experience developing bdd program analyses encoded knowledge experience design tool 
non experts develop analyses having deal complexities fine tuning bdd implementation 
easily extend build top results advanced program analyses written bddbddb bddbddb easier implementing analysis hand produce efficient implementation 
bddbddb takes advantage opti mization opportunities difficult tedious hand 
implemented whaley lam context sensitive pointer analysis earlier version system performed significantly faster hand coded hand tuned implementation bdds 
hand coded implementation times longer contained bugs 
bddbddb variety analyses analy sis queries pointer analysis eliminating bounds check operations finding security vulnerabilities web applications finding race conditions lock analysis serialization errors identifying memory leaks listeners 
contributions contributions 
description bddbddb system 
describes detail datalog efficient optimized bdd operations reports performance gains due various optimizations 
expand material earlier tutorial 

demonstration effective application logic programming problems pro gram analysis 
previous shows penalty writing program analysis database operations show bdd implementation dat program analysis efficient 
interprocedural program analysis tends create data exhibits commonalities 
commonalities re sult extremely efficient bdd representation 
datalog evaluation semantics directly efficiently map bdd set operations 
experimental results variety program analyses multiple input programs show bddbddb effective generating bdd analyses datalog specifi cations 
particular compare bddbddb hand coded hand optimized bdd program analyses show bddbddb twice fast cases far easier write debug 

insights bdds program analysis 
building tool considerable experience developing bdd program analyses 
knowledge went design tool algorithms shares insights interesting uses bdds program analysis 
organization rest organized follows 
describe program described datalog program section 
section datalog program operations relational algebra shows bdds rep resent relations implement relational operations 
section describes algorithm bddbddb translate datalog program interpretable program effi cient bdd operations 
section presents experimental results comparing bddbddb hand coded implementations program analysis bdds 
section related 
section 
expressing program analysis datalog program analyses including type inference points analyses de scribed formally compiler literature inference rules naturally map datalog programs 
program analysis expressed datalog accepts input set input relations generates new output relations representing results analysis 
terminology bddbddb implementation datalog stratified negation totally ordered comparison operators 
datalog program consists set set relations set rules variables types code locations function names input program mapped integer values 
statements program broken basic program operations 
type basic operation represented relation operations program tuples corresponding input relations 
program analysis declare additional domains relations 
datalog rules define new domains rela tions computed 
domain size size set natural numbers require domains finite size 
elements domain set numbers 
size relation set ary tuples attributes 
kth attribute relation signified ak number attributes relation signified 
relations attributes arity attribute domain domain defines set attribute 
expression 
xn true iff tuple 
xn relation likewise 
xn true iff 
xn rules form 
ek 
expression rule head form 
xn rand arity 
expression list 
ek rule subgoals list expressions forms 
xn arity 
xn arity comparison expressions natural numbers 
domain variable determined usage rule 
appears kth argument expression form 
xn domain domain domain ak 
uses variable rule agree domain 
furthermore comparison expression domains variables match safe datalog program guarantees set inferred facts relation tuples finite 
bddbddb domains finite programs necessarily safe 
avariable head rule appear subgoals variable may take value corresponding attribute domain bound domain 
bddbddb allows negation programs 
rules grouped solved sequence 
strata minimal solution relations minimum number tuples necessary satisfy rules 
negated predicate evaluates negation relation fully computed previous strata 
datalog founded negation superset datalog tion express fixpoint queries 
necessary extend bddbddb support founded semantics difficult 
example algorithm context insensitive points analysis precomputed call graph pa rameter passing modeled assignment statements 
domains variable map heap map field map relations input vp variable heap input store base field source input load base field dest input assign dest source output vp variable heap output hp base field target rules vp vp 
vp assign vp 
hp store vp vp 
vp load vp hp 
algorithm datalog program simple java points analysis 
declaration domains sizes optional mapping files containing meaningful names numerical values domain 
domain local method parameters distinguished identifier name lexical scope 
domain heap objects named allocation site 
domain field identifiers distinguished name type object contained 
relations declared names domains attributes relation vp set initial points relations 
vp declared set tuples vp true iff program directly places ref erence heap object variable operation new string 
relation store represents store operations load similarly repre sents load operations 
assign true iff program contains assignment assuming program call graph available priori intraprocedural assignments method invocation arguments formal method parameters assignments statements return value destinations modeled simple assignments 
analysis infers possible points relations heap objects relations variables heap objects 
vp true variable heap object point program execution 
similarly hp true heap object field may point heap object rule incorporates initial points relations vp rule computes transitive closure inclusion edges 
variable point object includes point rule models effect store instructions 
statement point point point 
rule resolves load instructions 
statement point point point 
string fido string dog new dog name vp va vp vd assign vb va store vd name vb fig 

example program java pointer analysis 
corresponding input relations 
illustrate analysis action simple java program listed 
domain contains values va vb vd representing variables andd 
domain contains values representing objects allocated lines 
domain consists value name represents name field dog object initial relations input program 
initial points relations vp va vd 
program assignment opera tion represented vb va relation assign store operation represented vd name vb relation store rule find vp va vp vd true 
assignment line rule tells vp vb true assign vb va vp va true 
rule hp name true store vd name vb vp vd vp vb true 
datalog bdd operations section explain rationale bdd operations solve 
show datalog program translated relational algebra operations 
show represent relations boolean functions algebra operations boolean functions 
show boolean functions represented efficiently binary decision diagrams bdds 
relational algebra datalog query finite domains stratified negation solved relational algebra operations corresponding datalog rules iteratively fixpoint solution reached 
shall illustrate translation simply way ofan example relatively understood 
set relational operations join union project rename dif ference select 
denotes natural join relations new relation tuples merged tuples corresponding attributes equal values 
denotes union relations returns new relation contains union sets tuples 
ssa ak denotes project operation forms new relation re moving attributes 
ak tuples aea denotes rename operation returns new relation attribute renamed 
difference relations contains tuples 
select operation denoted oea restricts attribute match equivalent performing natural join unary relation consisting ofa single tuple attribute holding value illustrate application rule vp assign vp 
corresponds sequence relational algebra operations source vp assign variable vp vp note rename operations inserted join union difference ensure corresponding attributes name non corresponding attributes different names 
boolean functions encode relations boolean functions tuples binary values 
elements assigned consecutive numeric values starting 
value domain elements represented dlog bits 
suppose attributes ofan ary relation associated numeric domains 
dn respectively represent boolean function 
dn 
dn iff 
dn 
dn iff 
dn relation set tuples 
binary encoding function displayed attribute represented bits second attribute relational algebra operation logical operation produces effect applied corresponding binary function representation 
suppose represented function function 
relation represented function 
similarly union binary operator project operation existential quantification 
example ssa represented 
binary decision diagrams large boolean functions represented efficiently bdds nally invented hardware verification efficiently store large number states share commonalities bdd directed acyclic graph dag single root node terminal nodes represent constants zero 
graph represents set input decision variables 
non terminal node labeled input decision variable exactly outgoing edges high edge low edge 
evaluate function set input values path root node terminal nodes high edge node corresponding input variable true low edge false terminal node gives value function input 
shows bdd representation function 
non terminal node corresponding decision variable solid line indicates high edge dashed line indicates low edge 
fig 

binary encoding relation 
bdd encodings relation decision variable orders respectively 
specifically variant bdds called reduced ordered binary decision dia grams robdds 
ordered bdd sequence variables evaluated path dag guaranteed respect total decision variable order 
decision variable order significantly affect number nodes required bdd 
bdd uses variable order represents function variable order 
change order adds extra node example worst case exponential number nodes added 
addition robdds maximally common bdd subgraphs collapsed single graph nodes shared 
size robdd depends subexpressions encoded function number entries set 
bdd operations boolean function operations discussed section standard feature 

difference boolean function operations applied bdds producing bdd resulting function 
bdd ex quantification operation exist produce new bdd projected attributes removed 
operation combines low high successors removed node applying operation rename operations implemented bdd replace operation new bdd decision variables corresponding old attributes replaced decision variables corresponding new attribute names replace operations eliminated renamed attributes encoded decision variables original attributes 
replace operation relative order decision variables linear respect number nodes bdd 
order changed cost replace respect number decision variables 
care taken encoding relation attributes minimize number expensive rename operations natural join operations frequently followed project operations eliminate unnecessary attributes 
bdd relational product operation sequence single operation 
similarly select project operations combined single bdd operation known restrict bdd operations operate entire relations time tuple time 
cost bdd operations depends size shape bdd graphs number tuples relation 
large relations computed quickly long encoded bdd representations compact 
due caching identical subproblems computed 
points key efficiency bdd operations reason data represent relations 
translating optimizing datalog programs bddbddb system applies large number optimizations transform efficient bdd operations 
apply datalog source level transforms optimizations 
section 
remove unnecessary rules stratify rules determine rule iteration order 
section 
translate stratified query intermediate representation ir consisting relational algebra operations 
section 
analysis optimize ir add bdd operations replace equivalent sequences relational algebra operations 
section 
choose bdd decision variables encoding relation attributes 
section 
perform dataflow optimizations physical domains assigned section 
interpret resulting program 
section illustrate process algorithm section running example 
vp vp hp store load assign vp vp assign assign vp hp store load vp hp store load fig 

predicate dependency graph algorithm 
breaking pdg sccs cycles 
datalog source transformations compilation normalize forms input rules follows variable appears rule changed underscore unused attribute 
variable appears multiple times single subgoal give distinct name add extra equality subgoals new variables equal original variable 
example subgoal transformed subgoals comparison subgoal attribute domain substituted sub goal corresponding precomputed relation defined comparison function 
subgoals rules define temporary relations inlined rules relations 
temporary relations non input non output relations head rule appear subgoal rule 
datalog rule optimization rule removal solver removes rules relations indirectly output relations 
predicate dependency graph pdg built record dependencies rules relations 
node represents relation marked rule rule subgoal relation head relation 
ifthe subgoal negated edge marked negative edge 
pdg example shown 
necessary rules relations performing pass pdg starting output relations 
stratification pdg stratify program 
stratification relation negated subgoal fully computed applying rules containing negation 
stratum distinct subset program rules relations belonging stratum 
rules particular stratum may positive forms relations computed stratum positive negated relations calculated earlier strata input relations relational database 
cyclic dependencies strata 
program stratified user 
experience designing datalog programs program analysis find need non queries 
example contain negations rules relations single stratum 
finding cycles cycles pdg indicate rules relations requiring iterative application rules cycles reach fixed point solution 
pdg stratum split strongly connected components sccs compute result stratum evaluating strongly connected components non cyclic relations topological order pdg single strongly connected component encompass multiple loops share header node 
distinguish different loops asingle scc iterate independently 
pdg typically reducible classical algorithm finding loops tarjan interval works reducible graphs 
extensions deal irreducible graphs typically property node loop 
solve identifying loop scc eliminating back edge recursively re applying scc algorithm interior find inner loops 
steps algorithm example shown 
pdg sccs labeled shown left 
remove edge rule hp vp breaking larger cycle topologically sort find smaller self cycle vp rule shown right 
determining rule application order order rules applied significant difference execution time 
multiple cycles single scc number rule applications necessary reach differ relative order cycles iterated 
application order yield fewest number rule applications depends rules nature relations 
aspects bdd library certain iteration orders rule applications 
example bdd library uses operation cache results recursive bdd nodes avoid redundant computations performing operation 
cache provide benefits different operations bdds share nodes 
take advantage operation cache locality operations perform related operations sequence 
aspect influencing iteration der choice set oriented nature bdd operations 
performing operation tuples generated loop faster apply operation loop iterations applying loop iteration 
absence profile information prior runs user static analysis rules decide rule application order 
cycles involve fewer rules iterated cycles involve rules rules fewer subgoals iterated rules subgoals 
reasoning smaller shorter chains rules smaller rules faster operation cache locality 
static metric works examples tried small cycles usually transitive closure computations expose opportunities set computation larger cycles 
intermediate representation determined iteration order translate rules relational algebra operations follows 
subgoal underscore project away unused attributes 
subgoal constant select project operators restrict relation match constant 
join subgoal relation subgoal relations projecting away attributes unnecessary 
rename attributes result match head relation 

head relation contains constant select operator result value constant 

unify result head relation 
ir optimizations repeated applications rule loop efficient differential current value subgoal relation previous value time rule applied 
known semi na ive evaluation strategy 
computing difference subgoal relations compared previous iteration avoid extra inputs thesame iteration avoid applying rule altogether 
tradeoff old value subgoal stored 
allow user control performed rule basis 
performing sequence relational derived rule section generates ir vp vp vp vp vp assign assign assign assign assign source vp assign source vp assign variable vp vp apply number traditional compiler data flow optimizations ir constant propagation 
propagate empty set universal set constants unions joins difference operations 
definition chains 
calculate chains definitions uses optimize program eliminating dead code operations results uses coalescing natural join project pairs operations select project pairs restrict operations 
stage optimizations relational algebra operations replaced combined operations restrict operations pos sible 
rule vp diff vp vp vp copy vp replace vp variable source assign source replace dest variable vp vp optimized ir join project pair involving assign vp col single 
operations computing differ ence assign removed assign loop invariant 
bdd decision variable assignment noted section bdd operations implement relational constraints choice bdd decision variables encode relation attributes 
performing operation bdds decision variables cor responding attributes match 
likewise unmatched attributes assigned different decision variables 
bdd replace operation different decision variables substituted bdd result relational rename 
important minimize cost replace operations 
depends onthe choice decision variables encoding attribute 
cost zero linear exponential depending new decision variables relative order different relative order 
additionally prefer perform costly replace operations smaller bdds terms bdd nodes larger bdds 
bddbddb uses priority constraint system assign attributes bdd de cision variables 
system expressed terms equivalence constraints relation attributes sequences decision variables 
weuse specialized union find data structure augmented non equivalence constraints efficiently compute constraint system 
bdd terminology sequence bi nary decision variables represent attribute referred physical domain confused datalog domain defined section avoid introducing replace operations constraining renamed physical domain original attribute 
introduced constraint cause constraint system solution assign new attribute physical domain add replace operation point allow con straint satisfied 
carefully choosing order priority constraints added system ensure replace operations introduced efficient 
attribute relation create non equivalence constraint attributes add constraints program operations inorder importance 
operations inner loops higher importance operations outer loops presumption operations performed 
loop depth operations considered order execution typically expensive operations 
consider operations 
unary operation copy constraints corresponding attributes source destination relations 
binary operation interacting attributes input relations equal 
considering operations add constraints attributes input output relations 
physical domains specified user loaded stored relational database application physical domain assignment algorithm running example reveals variable vp source assign assigned domain 
replace occurs removed vp diff vp vp vp copy vp vp assign source replace dest variable vp vp additional optimizations domain assignment opportunity apply set optimizations global value numbering 
global value numbering factors evaluation com mon subexpressions rules non redundant computations 
optimizes loops hoisting invariants copy propagation 
copy propagation eliminates unnecessary temporary ir relations generated optimizations liveness analysis 
liveness analysis clean dead code 
reduce memory footprint ir interpretation freeing relation allocations lifetime relation ended 
interpretation bddbddb interprets optimized ir performs ir operations se quence calling appropriate methods bdd library 
decision variable ordering bdds proven effective compacting commonalities large sets extent commonalities exploited depends ordering decision variables 
case difference bad ordering termination non termination due memory exhaustion analysis 
relative orderings readily apparent static analysis space orders extremely large precedence interleaving conditions number orders series ordered bell numbers 
developed algorithm finding effective decision variable order ing 
algorithm active learning embedded execution datalog programs bddbddb system 
bddbddb encounters rule takes longer parameterized amount time initiates learning episode find better decision variable ordering measuring time taken orderings 
rule applications expensive bddbddb maximizes effectiveness trial actively seeking decision variable effects known 
experimental results measure effectiveness bddbddb system compare hand programs 
prior developing bddbddb system manually implemented optimized points analyses context insensitive pointer analysis described context sensitive pointer analysis cloning paths call graph field sensitive context insensitive pointer 
wrote datalog versions analyses ran bddbddb system hand coded java analyses result months effort tuned optimized 
variable ordering physical domain assignment care fully hand tuned achieve best results 
rules hand coded algorithms 
proved tedious error prone process system unwieldy 
bugs popping weeks completed 
hand happily decomposed largest complex inference rules unsafe nature pointer analysis complicated consisting rules 
hand coded pointer analysis physical domain variable orderings order inferences optimized avoid significant execution slowdowns 
specification low level bdd error prone time consuming process 
deal time spent modifying physical domain assignments solving errors due incorrect specification domains bdd operations 
datalog version analysis specified development hand coded version discontinued effort 
experiment reported compare hand coded version equivalent datalog implementation time evaluate performance bddbddb additional analyses analysis find external lock objects aid finding data races atomicity bugs analysis find sql injection vulnerabilities java web applications 
analyses build top context sensitive java pointer analysis fairly sophisticated analyses 
hand coded implementations analyses tedious implement hand 
comparing lines code metric comparison number lines code algorithm analysis hand coded insensitive java context sensitive java context insensitive external lock analysis sql injection analysis fig 

loc hand coded analyses versus lines datalog bddbddb specifying analysis datalog reduced size analysis times inthe case analysis times case context sensitive java analysis 
disparity java implementations due fact thatthe implementation combined bdd operations single line java implementation put bdd operation separate line code adding new analysis bddbddb takes lines code versus rewrite thousands lines hand coded implementation 
external lock analysis andthe sql injection analysis examples 
example easily modified inference rules context insensitive points analysis create context sensitive analysis adding additional context attribute existing relations 
extremely simple change bddbddb datalog specification modification required rewriting hundreds lines low level bdd operations hand coded analysis 
comparing analysis times analysis compared solve time hand bddbddb implementation varying levels optimization 
analyses performed amd opteron gb ram run ning redhat enterprise linux java jdk 
bddbddb analyses hand coded java points analysis open source library internally buddy bdd library 
hand coded pointsto analysis direct buddy library 
java context insensitive initial node table size operation cache size 
java context sensitive analysis points analyses initial node table sizeof operation cache size 
figures contain run times java context insensitive analysis sensitive analysis pointer analysis respectively 
columns give benchmark name description 
column gives solve time hand coded solver 
remaining columns give solve time bddbddb various optimizations enabled 
column adds new opti mization addition columns left 
opts optimizations disabled 
incr add described sec tion 
du add optimizations definition chains 
dom optimize physical domain assignments 
add remaining optimiza tions described section 
java context insensitive pointer analyses order column shows result bddbddb optimizations enabled variable order discovered learning algorithm referred section 
programs order learned 
java programs order learned 
java context sensitive case learning algorithm name description hand opts incr du dom order virtual machine compiler graph theory library auction site tool jedit sourcecode editor uml class diagrams java networked game fig 

comparison context insensitive java pointer analysis runtimes 
times seconds 
name description hand opts incr du dom virtual machine compiler graph theory library auction site tool jedit sourcecode editor uml class diagrams java networked game fig 

comparison context sensitive java pointer analysis runtimes 
times seconds 
name description hand opts incr du dom order crafty chess program text ps conversion mbox html conversion monkey webserver fig 

comparison pointer analysis runtimes 
times seconds 
name description opts incr du dom virtual machine compiler graph theory library auction site tool jedit sourcecode editor uml class diagrams java networked game fig 

external lock analysis runtimes 
times seconds 
name description opts incr du dom order ee blogging application road testing application ee blogging application roller ee blogging application fig 

sql injection query results 
times seconds 
indicates analysis 
able find better order omitted column 
entries marked signified test case complete due running memory 
time spent bddbddb translate datalog optimized bdd operations compared solve times translation times omitted 
cases bddbddb spent seconds compile datalog 
unoptimized context insensitive java analysis times slower hand coded version 
showed small improvement adding def optimizations began see useful time reduction 
optimizing bdd domain assignments reduces runtime original enabling optimizations reduces runtime original 
improved variable order brought runtime unoptimized runtime 
def optimizations bring bddbddb analysis close hand coded analysis runtimes remaining optimizations learned variable order combined beat hand runtime factor 
results context sensitive java analysis similar context 
unfortunately variable order learning algorithm unable learn better variable order analysis leaving fully optimized bddbddb analysis faster hand coded version 
case analysis unoptimized bddbddb analysis hand coded version 
due relative complexity datalog analysis case optimizations able significant im execution times 
analysis times optimizations enabled roughly comparable hand coded solver 
java analyses due optimized physical domain assignment 
applying learned variable order bddbddb analysis runtimes reduced fall hand coded implementation 
external lock sql injection analyses bddbddb build external lock sql injection detection analyses java points analysis results 
runtimes external lock analysis different levels optimization displayed 
re duces analysis time original time 
optimizing physical domain assignments reduces analysis time original 
displays runtimes sql injection analysis web applications 
analysis fails complete due memory tion 
optimization see performance gains similar external lock analysis 
related related falls general categories optimizing datalog executions systems bdds program analysis bdds 
go category turn 
optimizing datalog liu stoller described method transforming datalog rules indexed linked data structures 
proved technique optimal run time respect fact combinations lead hypotheses rule simultaneously true considered exactly 
experimental results 
formulation greatly simpli fied complexity analysis datalog programs 
technique apply bdds cost bdd operations depend combi nations facts number nodes bdd representation nature relations lots research optimizing datalog evaluation strategies example semi na ive evaluation bottom evaluation top ramakrishnan investigated role rule ordering computing fixpoints 
evaluation strategy geared peculiarities data structure example maximize cache locality iterate inner loops transforming datalog programs reduce amount necessary compute solution 
magic sets general algorithm rules cut number irrelevant facts generated 
idea extended add better support certain kinds recursion 
sagiv algorithm optimizing datalog program uniform equivalence 
zhou sato optimization techniques fast computation fixpoints redundant evaluation subgoals 
halevy describe query tree data structure useful optimiza tion datalog programs 
query tree encodes symbolic derivation trees satisfy property 
logic programming bdds described technique bdds logic programming 
different ways encoding relations logarithmic encoding encoding linear encoding encodes elements elements bdd variable 
evaluate technique transitive closure computation 
system translates logic programming queries decision diagrams 
crocopat tool relational computation structural analysis systems 
bddbddb bdds represent relations 
program analysis bdds zhu bdds implement context insensitive inclusion points analysis 
zhu extended technique support context sensitivity whaley lam developed cloning sensitive pointer analysis algorithm relies heavily data sharing inherent bdds 
extended whaley lam algorithm support pointer arithmetic 
java language extension provides relational algebra abstraction 
treatment domain assignment constraint problem similar sat solver find legal domain assignment 
attempt constraints importance 
jensen describe framework uses datalog specify variety analyses object oriented programs 
de moor larsen formulate program analyses conditions control flow paths 
free metavariables corresponding program elements variables constants 
bdds efficiently represent search large space possi ble instantiations 
bebop symbolic model checker checking program behavior 
represent sets states 
validate critical safety properties device drivers 
described bddbddb deductive database engine uses datalog spec querying program analyses 
datalog natural means specifying program analyses complicated analyses specified lines 
adding bdds combination works bdds take advantage redundancies occur program analyses especially context bdd set operations correspond closely datalog evaluation style experience system encouraging 
program analyses easier implement bddbddb longer go back old hand coding analyses 
especially true experiments showed bddbddb execute program analyses faster tuned handcoded im plementation 
done improving algorithms implementation bddbddb tool useful research system brings benefits 
prototyping new analyses remarkably easy 
combining results multiple analyses trivial 
easier verify larger traditional programs 
analysis runs faster inference engine automates tedious process optimizing analysis 
new optimizations tested implemented inference engine repeatedly analysis 
bddbddb bridges specification program analysis implementation 
greatest benefit system powerful program anal ysis widely accessible 
ease declarative language sql considered reasons success databases 
believe may play important role interactive programming tools 
bddbddb system publicly available sourceforge licensed open source license 
acknowledgments authors benjamin livshits christopher test cases helpful feedback experiences bddbddb 
supported part nsf graduate fellowship 

dalton livshits lam 
improving software security analysis 
icse proceedings th international conference software engineering 
acm press 
ball rajamani 
bebop symbolic model checker boolean programs 
proceedings th international spin workshop spin model checking pages 
springer verlag 

ball rajamani 
automatically validating temporal safety properties interfaces spin proceedings th international spin workshop model checking software pages 
springer verlag new york 
bancilhon maier sagiv ullman 
magic sets strange ways implement logic programs extended 
pods proceedings fifth sigmod symposium principles database systems pages 
acm press 
ak qian hendren 
points analysis bdds 
pldi proceedings acm sigplan conference programming lan guage design implementation pages 
acm press 

jensen 
modular class analysis datalog 
cousot editor pro ceedings th static analysis symposium sas pages 
springer lncs vol 

beyer lewerentz 
simple efficient relational querying software structures 
proceedings th ieee working conference reverse engineering nov 

bryant 
graph algorithms boolean function manipulation 
ieee computers 

whaley lam 
finding effective variable orderings bdd analysis 
submitted publication 

ceri gottlob tanca 
logic programming databases 
springer verlag newyork 

chandra harel 
horn clauses generalizations 
journal logic programming 

chen warren 
tabled evaluation delaying general logic programs 
acm 


charlier 
efficient bottom prolog means constraint solving symbolic finite domains 
plilp proceedings th international symposium programming logic programming pages 
springer verlag 

dawson ramakrishnan warren 
practical program analysis generalpurpose logic programming case study 
pldi proceedings acm sigplan conference programming language design implementation pages 
acm press 

gelder ross schlipf 
founded semantics general 
acm 

halevy mumick sagiv shmueli 
static analysis datalog extensions acm 

inoue 
bottom evaluation logic programs binary 
icde proceedings eleventh international conference data engineering pages 
ieee computer society 
lam whaley livshits martin 
context sensitive program analysis database queries 
proceedings sigact sigmod sigart symposium principles database systems 
acm june 

ak hendren 
bdd relational extension java 
pldi proceedings acm sigplan conference programming language design implementation pages 
acm press 
lind nielsen 
buddy binary decision diagram package 
buddy sourceforge net 

liu stoller 
datalog rules efficient programs time 
ppdp proceedings th acm sigplan international conference principles practice declarative programming pages 
acm press 
livshits lam 
finding security vulnerabilities java applications static analysis 
th usenix security symposium 
usenix aug 
martin livshits lam 
finding application errors pql program query language 
proceedings acm conference object oriented pro gramming systems languages applications oopsla oct 

naughton ramakrishnan 
bottom evaluation logic programs 
compu tational logic essays honor alan robinson pages 

naughton ramakrishnan sagiv ullman 
efficient evaluation right left multi linear rules 
sigmod proceedings acm sigmod international conference management data pages 
acm press 
ramakrishnan srivastava sudarshan 
rule ordering bottom fixpoint evaluation logic programs 
proceedings th international conference data bases pages 
morgan kaufmann publishers 

ramakrishnan ullman 
survey research deductive database systems 
logic programming 

ramalingam 
identifying loops linear time 
acm transactions systems mar 

reps demand interprocedural program analysis logic databases pages 
kluwer 

sagiv 
optimizing datalog programs 
pods proceedings sixth sigmod sigart symposium principles database systems pages 
acm press 
sagonas swift warren 
xsb efficient deductive database engine 
sigmod proceedings acm sigmod international conference man agement data pages 
acm press 

de moor larsen 
incremental execution 
popl proceedings st acm sigplan sigact symposium principles programming languages pages 
acm press 
tamaki sato 
old resolution tabulation 
proceedings third international conference logic programming pages 
springer verlag new york 
tarjan 
testing flow graph reducibility 
journal computer system sciences dec 
ullman 
bottom beats top datalog 
pods proceedings eighth acm sigact sigmod sigart symposium principles database systems pages 
acm press 

ullman 
principles database knowledge base systems 
computer rockville md volume ii edition 

whaley 
library 
sourceforge net 
whaley lam 
cloning context sensitive pointer alias analysis binary decision diagrams 
pldi proceedings acm sigplan conference language design implementation pages 
acm press 


zhou sato 
efficient fixpoint computation linear tabling 
ppdp proceedings th acm sigplan international conference principles practice declarative programming pages 
acm press 
zhu 
symbolic pointer analysis 
iccad proceedings ieee acm international conference computer aided design pages 
acm press 
zhu 
symbolic pointer analysis revisited 
pldi proceedings acm sigplan conference programming language design implementation pages 
acm press 
