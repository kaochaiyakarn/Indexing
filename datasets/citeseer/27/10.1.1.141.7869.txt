basis mathematical theory computation john mccarthy included computer programming formal systems edited published north holland 
earlier version published proceedings western joint computer conference 
computation sure important sciences 
science machines carry intellectual processes 
know intellectual process carried mechanically performed general purpose digital computer 
limitations able computers far clearly come far weakness programmers intrinsic limitations machines 
hope limitations greatly reduced developing mathematical science computation 
established directions mathematical research relevant science computation 
oldest numerical analysis 
unfortunately subject matter narrow help forming general theory begun affected existence automatic computation 
corrected version title western joint computer conference may 
tenth section discussing relations mathematical logic computation bean added 
second relevant direction research theory computability branch recursive function theory 
results basic theory including existence universal machines existence unsolvable problems established framework theory computation fit 
unfortunately general trend research field establish better unsolvability theorems little attention paid positive results establishing properties kinds algorithms 
reason formalisms describing algorithms cumbersome describe actual algorithms 
third direction mathematical research theory finite automata 
results finiteness number states tend useful dealing computers states impossible go substantial fraction reasonable time 
attempt create basis mathematical theory computation 
mentioning shall discuss briefly practical results hoped suitable mathematical theory 
contains direct contributions goals mentioned list additional goals order encourage gold rush 

develop universal programming language 
believe goal written prematurely number people 
opinion situation algol right track mainly lacks ability describe different kinds data cobol step blind account orientation english suited formal description procedures exercise group thinking 
formalism describing computations candidate universal programming language lacks number features mainly syntactic necessary convenient 

define theory equivalence computation processes 
theory define equivalence preserving transformations 
transformations take algorithm form easily seen give right answers equivalent form guaranteed give answers advantages speed economy storage incorporation auxiliary processes 

represent algorithms symbolic expressions way significant changes behavior represented algorithms represented simple changes symbolic expressions 
programs supposed learn experience change behavior changing contents registers represent modifiable aspects behavior 
certain point view having convenient representation behavior available modification meant consciousness 

represent computers computations formalism permits treatment relation computation computer carries computation 

give quantitative theory computation 
quantitative measure size computation analogous shannon measure information 
contains information 
divided sections 
contains descriptive formalisms examples second contains little theory enables prove equivalence computations expressed formalisms 
formalisms treated 
way describing functions computable terms base functions conditional expressions recursive function definitions 
formalism differs recursive function theory integers strings symbols fixed domain 

computable functionals functions functions arguments 

non computable functions 
adjoining quantifiers computable function formalism obtain wider class functions priori computable 
functions shown equivalent computable functions 
fact mathematics computation may major aspects rules permit transform functions non computable form computable form 

ambiguous functions 
functions values incompletely specified may useful proving facts functions certain details irrelevant statement proved 

way defining new data spaces terms base spaces defining functions new spaces terms functions base spaces 
lack formalism main weaknesses algol business data processing languages cobol start direction start hampered concessions authors presume prejudices business men 
second part contains mathematical results properties formalisms introduced part 
specifically describe 
formal properties conditional expressions 

method called recursion induction proving equivalence recursively defined functions 

relations formalisms introduced formalisms current recursive function theory programming 
hope reader angry contrast great expectations mathematical theory computation meager results 
formalisms describing computable functions related entities part describe number new formalisms expressing computable functions related entities 
important section subject matter fairly understood 
sections give formalisms hope useful constructing computable functions proving theorems 
functions computable terms base functions suppose base collection functions including predicates having certain domains ranges 
case non negative integers may successor function predicate equality case expressions discussed basic operations 
object define class functions shall call class functions computable terms developing formally wish give example order give example need concept conditional expression 
notation conditional expression form 
pn en corresponds algol language expression 
pn en 

pn propositional expressions values standing truth falsity respectively 
value 
pn en value corresponding value 
examples conditional expressions known functions ij triangular function graph represented conditional expression tri 
fig 
ready conditional expressions define functions recursively 
example 

evaluate 
definition 







reader followed simple examples ready construction straightforward generalization tying loose ends 
notation 
collection finite examples shall give functions domains ranges certain sets 
class functions involving sets shall call computable terms suppose function variables suppose write xi xn xi takes values set ui takes value set customary describe situation writing 
un set un tuples 
xn called domain set called range forms functions 
order properly definitions follow distinguish functions expressions involving free variables 
church called forms 
single letters sequences letters sin denote functions 
expressions called forms 
particular may refer function defined definitions written forms involving functions written expressions infixes examples 
composition 
shall describe ways new functions defined old 
way may called generalized composition involves forms 
shall letters 
subscripts variables suppose notation constants expressions ambiguous 
decimal notation allowed constants dealing integers 
class forms defined recursively follows variable associated space form form associate constant space form associate form 
ii en forms associated spaces un respectively en form associated space form may built forms function variables occurring form xn define function writing xn shall assume reader knows compute values function defined way 
fm functions occurring shall say function defined composition fm 
class functions definable functions composition narrower class function computable terms functions 
partial functions 
theory computation necessary deal partial functions defined tuples domains 
partial function minus defined minus defined pairs positive integers greater function defined tuples domain called total function 
admit limiting case partial function defined tuples 
tuples function described composition defined determined obvious way sets tuples functions entering composition defined 
functions occurring composition total functions new function total function processes defining functions kind totality 
word function shall mean partial function 
having introduce partial functions nuisance unavoidable 
rules defining computable functions give computation processes terminate computation process fails terminate result undefined 
known effective general way deciding process terminate 
predicates propositional forms 
space truth values elements truth falsity special role theory 
function range called predicate 
examples predicates integers prime defined prime prime defined shall course write 
space predicate equ arguments defined equ shall write equ remarks functions hold tried consider equality single predicate defined spaces 
form values prime called propositional form 
propositional forms constructed directly predicates prime may called simple 
compound propositional forms constructed simple ones means propositional connectives 
shall assume reader familiar connectives 
conditional forms conditional expressions 
conditional forms require little careful treatment connection example 
value conditional form pn en value corresponding value value value conditional form defined 
rule complete provided defined values need provision possibility undefined 
rule follows undefined occurs true false corresponding true undefined form undefined 
value form value corresponding true shall illustrate definition additional examples undefined undefined undefined truth value simplify certain conditional forms 
shall write 
propositional connectives expressed terms conditional forms follows considerations truth tables show formulae give results usual definitions 
order treat partial functions consider possibility may undefined 
suppose false undefined conditional form definition false undefined 
propositional connectives turns appropriate theory computation calculation gives result need computed evaluate calculation terminate get computing natural ask function variables defined pn en pn en 
possible extend notion function normally requires arguments function function computed 
shall shortly see important conditional form considered defined example true defined undefined 
required extension concept function property functions variables longer identified variable functions defined product spaces 
shall pursue possibility 
want extend notion forms include conditional forms 
suppose pn forms associated space truth values en forms associated space suppose variable xi occurring pn en associated space pn en form associated believe conditional forms eventually come generally mathematics functions defined considering cases 
kind innovation vector notation 
proved proved 
formal properties discussed reduce verbal arguments calculation 
definition functions recursion 
definition 

example definition recursion 
consider computation 



see important provide conditional form defined term gives value undefined 
case 
undefined 
note consider wider domain non negative integers 
defined partial function non negative integer recursion process terminate 
general define single functions recursion define functions simultaneous recursion particular case 
define simultaneously functions fk write equations xn fk xn ek expressions ek contain known functions functions fk 
suppose ranges functions vk respectively require expressions ek associated spaces respectively ek taken having corresponding ranges 
consistency condition 
fi xi xk evaluated values follows 

ei conditional form evaluated prescribed order stopping true corresponding evaluated 

ei form evaluated function applied 

expression fi occurs evaluated defining equation 

subexpressions ei evaluated evaluated rules 

variables occurring subexpressions evaluated giving assigned values 
guarantee evaluation process terminate case 
particular arguments process terminate function undefined arguments 
function fi occurs expression ei possibility termination depends presence conditional expressions ei class functions computable terms base functions defined consist functions defined repeated applications recursive definition process 
recursive functions integers develop recursive functions class symbolic expressions terms conditional expression recursive function formalism 
example recursive function definitions shall give recursive definitions number functions integers 
reasons help reader familiarize recursive definition show simpler practice methods recursive definition turing machines kleene formalism prove partial recursive function kleene non negative integers contains successor function predicate equality 
set non negative integers 
denote successor integer denote equality integers 
define functions succ eq eq succ write succ eq 
interested 
clearly functions integers truth values values 
define predecessor function pred defined pred pred pred pred 
shall denote pred define sum product mn mn difference defined inequality predicate defined 
strict inequality defined 
integer valued quotient defined 
remainder dividing defined rem rem divisibility number number 
number defined prime prime prime prime 
euclidean algorithm defines greatest common divisor write gcd gcd rem gcd rem define euler function gcd 
number numbers relatively prime shows form recursion convenient way defining arithmetical functions 
shall see properties arithmetical functions conveniently derived formalism section 
computable functionals formalism previously described enables define functions functions arguments 
example ai regarded function numbers sequence ai 
regard sequence function write recursive definition sum sum terms conventional notation 
functions functions arguments called functionals 
example functional gives integer predicate 
order functionals convenient notation naming functions 
church lambda notation 
suppose function defined equation xn expression xn 
name function xn 
example name function defined 

variables occurring definition dummy bound variables replaced changing function provided replacement done consistently 
example expressions represent function 
notation represented sum integer represented 
functions dealing defined recursively difficulty arises 
example consider factorial defined expression factorial factorial 
factorial serve name function clear occurrence factorial expression refers function defined expression 
recursive functions adopt additional convention label xn stands function defined equation xn occurrences function letter stand function defined 
letter dummy variable 
factorial function name label factorial factorial factorial dummy variables expression label represents function 
start base domain variables possible consider hierarchy functionals 
level functions arguments base domain 
level functionals functions level arguments 
level functionals functionals level arguments functionals variables mixed type 
hierarchy exhaust possibilities allow functions take arguments eliminate label naming recursive functions 
suppose function defined expression function variable function named label 
suppose define function 
satisfies equation write 

eliminates label excessive cost 
expression gets quite complicated admit functionals capable arguments 
escape orderly hierarchy functionals 
non computable functions functionals supposed mathematical theory computation need consider computable functions 
mathematical physics carried terms real valued functions computable approximable computable functions 
shall consider successive extensions class 
adjoin universal quantifier operations define new functions 
suppose form variable variables associated space truth values 
new form remaining variables associated 
value values remaining variables values value value value value remaining case values value undefined undefined 
allow universal quantifier form new propositional forms conditional forms get class functions ha may called class functions hyper arithmetic case successor equality integers ha consists kleene hyper arithmetic functions 
step allow description operator 
stands unique true 
unique undefined 
case integers defined terms universal quantifier conditional expressions case domains effectively enumerable may wish domains enumeration unnatural 
step allow quantification functions 
gets kleene analytic hierarchy presumably allows functions analysis 
facts worth noting 
refers functions domain just computable ones 
restrict quantification computable functions get different results 
secondly allow functions take arguments difficult assign meaning quantification 
fact apparently confronted paradoxes naive set theory 
ambiguous functions ambiguous functions really functions 
prescription values arguments ambiguous function collection possible values 
example ambiguous function defined positive integer values non negative integer possible value 
define basic ambiguity operator amb possible values defined whichever defined 
define amb 
property define ult ult ult number important kinds mathematical arguments convenient formalization may involve ambiguous functions 
order give example need definitions 
ambiguous functions shall say descendant possible value possible value 
secondly shall say property ambiguous functions hereditary possessed function possessed descendants property iteration integer valued function eventually gives hereditary function property 
descendants 
integer function satisfying property identically descendant 
function complicated reduces number iterated sufficiently give 
example reasons hoping ambiguous functions turn useful 
just operation amb defined adjoined generate extend class may called computably ambiguous functions 
wider class ambiguous functions formed operator am values satisfying 
recursive definitions sets previous sections recursive definition functions domains ranges basic functions prescribed defined functions domains ranges 
section shall consider definition new sets basic functions 
shall consider operations new sets defined 

cartesian product sets set ordered pairs finite sets denote numbers members respectively 
associated pair sets canonical mappings defined defined word canonical refers fact defined sets depend knowing members canonical function function variables defined 
purposes functions variables identified functions variable defined 
direct union sets union nonintersecting sets correspondence finite intersect 
elements may written elements subscripted set come aa bb 
canonical mappings associated direct union ia defined ia aa ja defined ja bb pa defined pa comes qa defined qa comes canonical partial functions ra sa ra defined elements coming satisfies ra ia similarly sa satisfies sa ja 
power set set mappings canonical mapping defined 
canonical mappings 
regard sets canonical mapping defined ga ga 
shall write express fact sets canonically isomorphic 
canonical isomorphisms 
ta defined 




shall denote null set containing elements set consisting integers terms associate left convention convention 
terms associate left convention suppose write recursive equation interpret defining set sequences elements follows 
interpret denoting null sequence 
null sequence strictly image element 
pair consisting element element element pair element consists sequences elements including null sequence 
suppose substitute right side get 
substitute expand distributive law expressed equation get denote set way writing set sequences 
shall denote set sequences elements seq 
derive relation writing solving formally getting expand geometric series get just 
useful recursive construction elements forms set expressions alphabet may denote sexp 
set subject matter paragraph refers 
sets formed kind recursive definition canonical mappings associated direct sum cartesian product operations significance 
consider example sexp 
define basic operations lisp atom eq car cdr cons equations atom pa eq ia ia assuming equality defined space car ns sa cdr sa cons ja definition set integers 
denote null set 
define set integers elements shall denote successor predecessor functions definable terms canonical operations defining equation 
succ pred 
properties computable functions part solely concerned presenting descriptive formalisms 
part shall establish properties entities previously introduced 
important section section deals recursion induction 
formal properties conditional forms theory conditional expressions corresponds analysis cases mathematics mild generalization propositional calculus 
start considering expressions called generalized boolean forms gbf formed follows 
variables divided propositional variables general variables 
shall write 
called elementary conditional form ecf called premiss alternative respectively 

variable gbf propositional variable called propositional form pf 

pf gbf 
addition pfs 
value gbf values undefined propositional variables case pf general variable 
value determined gbf table value undefined value value value undefined shall say strongly equivalent value values propositional variables including case undefined propositional variables 
weakly equivalent values values propositional variables restricted equivalence tested method truth tables identical propositional calculus 
table foregoing page 
adopted church spelling premise argument 
adopted generally gave 
table strongly equivalent 
weak equivalence case left table 
consider table proves weakly equivalent 
strongly equivalent 
shall write relations strong weak equivalence 
rules equivalence generate equivalences 

result substituting gbf variable 
called rule substitution 

subexpression result replacing occurrence occurrence 
called rule replacement 
rules applicable strong weak equivalence fact general situations 
weak equivalence corresponds closely equivalence truth functions propositional calculus strong equivalence 
consider equations strong equivalence proved truth tables 
equations axioms transform gbf weakly equivalent substitution replacement 
fact transform gbf canonical form 
canonical form 
pn variables gbf taken arbitrary order 
transformed form ai form general ai ai ai ai ik pk ai ik ai ik ai truth value general variable 
example canonical form variables taken order 
canonical form cases truth falsity pn explicitly exhibited 
expression may transformed canonical form follows axiom repeatedly subexpression consists single propositional variable 
variable moved front repeated application axiom 
cases axiom directly applicable axiom applicable axiom case handled manner similar case 
main expression form move occur front eliminate axioms 
bring front axiom necessary guarantee occurrence 
process continued canonical form achieved 
canonical form strong equivalence 
gbf strongly equivalent form contain canonical form 
variable may chosen arbitrarily inevitable propositional variable original gbf chosen inevitable variable 
inevitable variable gbf defined propositional variable inevitable variable 
inevitable variables 
gbf may put strong canonical form follows axiom get premisses propositional variables 
choose inevitable variable say put form axiom 
step eliminate occurrences 
done general rule ecf occurrences premiss replaced occurrences alternative wish substitution replacement formulas need additional axioms 
suppose occurrence want replace axioms move objectionable occurs inner forms 
case objectionable removed axiom moved moved 
missing 
inevitable variables brought front forth 
equivalent weakly strongly weak strong canonical form 
way easy prove canonical form transformed canonical form 
suppose different weak canonical forms variables taken order 
values chosen giving different values form proving non equivalence 
strong case suppose inevitable propositional variables 
inevitable variables assigned suitable values defined undefined 
undefined inevitable proves non equivalence 
strongly equivalent inevitable variables put front 
process repeated alternative general conditional form regarded having form pn en pn en special undefined variable properties derived gbf relation functions conditional forms distributive law xi pn en xi xk xi xi xk pn xi en xi xk 
rule replacement extended case conditional expressions 
suppose occurrence subexpression expression 
define certain propositional expression called premiss follows premiss premiss xi xn part xi premiss xi 
occurs premiss ei premiss pi ei pn en pi pi 
occurs pi premiss pi premiss pi ei pn en pi 
extension rule replacement occurrence may replaced premiss 
subcase needs prove equivalence premiss subcase 
recursion induction suppose function defined recursively xn xn expression general contains suppose set tuples xn defined 
functions domain defined tuples suppose satisfy equation defined assert xn xn xn simply equation uniquely determines value function satisfying arguments turn follows fact compute xn xn shall call method proving functions equivalent name recursion induction 
shall develop properties elementary functions integers order illustrate proof recursion induction 
recall definitions mn mn 
roof definition addition properties conditional expressions proof 

roof define 
easily seen converges completely defined equation computable 

easily seen functions defined equations satisfy equation example clear principle recursion induction equivalent functions domain defined set pairs integers 
fact defined converges case general fact functions defined equations form converge 
able discuss formal proofs convergence 
presenting proofs shall terse 

proof 
converges th 


forms satisfies equation 
setting theorem gives commutativity addition 
fact prove making assumptions take account dealing integers 
suppose space consisted vertices binary tree fig 
vertex just left vertex just bottom tree 
defined course satisfies theorems satisfy example diagram shall assumptions 


embody peano axioms induction axiom 

proof 
proof remarked 





axiom proof th 

th 

th 

th 

twice 
proof proof letf 
mn mn 
proof mn mn axioms 

mn mp 
proof letf mn mn mn mp mn mp mn mn mp mn mn mp mn mn mp shall give examples application recursion induction proving theorems functions symbolic expressions 
rest proofs depend acquaintance lisp formalism 
start basic identities 
car cons cdr cons atom cons car cdr atom cons null eq nil define concatenation lists formula null cons car cdr objective show concatenation associative 


proof shall show satisfy functional equation null cons car cdr establish auxiliary result cons null cons cons car cons cdr cons cons write null cons car cdr null cons car cdr null cons car cdr null cons car cdr 
results obvious satisfy functional equation 

nil nil proof nil null nil cons car nil cdr nil nil null nil cons car cdr nil 
null nil cons car cdr 
nil satisfies equation 
write list null null nil cons car cdr satisfies equation 
consider function reverse defined reverse null nil reverse cdr cons car nil 
difficult prove recursion induction reverse reverse reverse reverse reverse elementary results elementary theory numbers elementary theory symbolic expressions provable straightforward way 
number theory gets far theorem prime divides ab divides formulate unique factorization theorem requires notation dealing sets integers 
wilson theorem moderately deep result expressed formalism apparently proved recursion induction 
immediate problems extending theory develop better techniques proving recursively defined function converges 
hope find ambiguous functions 
godel theorem disallows hope complete set rules formed 
relevance theory computation excursion number theory theory illustrates simple form mathematical problems involved developing rules proving equivalence algorithms 
recursion induction discovered considering number theoretic problems turns applicable change functions symbolic expressions 
relation formalisms recursive function theory characterization set functions computable terms base functions independently verified general concept compared 
hard show partial recursive functions sense church kleene succ 
order prove shall definition partial recursive functions davis 
modify definition page davis omit oracles function partial recursive obtained finite number applications composition functions list ui xn xi xy functions succ eq 
closed composition remains show succ eq closed operation 
operation defined follows operation associates total function xn function xn value xn xn undefined exists 
show succ eq may defined xn xn xn xn xn 
converse statement functions succ eq partial recursive presumably true quite easy prove 
opinion recursive function formalism conditional expressions better formalisms heretofore recursive function theory practical theoretical purposes 
particular functions may interested easily written resulting expressions understandable 
observed cases looked fundamental reason 
original church kleene formalism formalism operation integer calculations control flow calculations 
done noteworthy controlling flow way natural conditional expressions control flow directly 
similar objection applies basing theory computation turing machines 
turing machines conceptually different automatic computers general poor control structure 
programmer write turing machines compute functions observe invent constructing turing machines programming 
course theory computability deals questions concerned particular ways computations represented 
sufficient computable functions represented symbolic expressions numbers functions computable terms functions represented expressions computable terms expressions representing original functions 
practical theory computation applicable particular algorithms 
objection applies basing theory computation markov normal algorithms applies basing properties integers flow control described 
attempt give formalism describing computations allows computations entities arbitrary spaces ershov 
formalism uses computations symbolic expressions representing program steps unnecessary complication 
discuss relation formalism computer programming languages 
formalism basis lisp programming system computing symbolic expressions turned quite practical kind calculation 
particular advantage easy write recursive functions transform programs compilers program generators easy write 
relation recursive functions description flow control flow charts described 
algol program described recursive function provided lump variables single state vector having variables components 
number components large operations performed involve necessary separate names components 
means programming language include recursive function definitions algol statements 
theory computation certainly techniques proving algorithms equivalent far easier develop proof techniques recursion induction recursive functions algol programs 
relations computation mathematical logic follows computation mathematical logic taken wide sense 
subject computation essentially artificial intelligence development computation direction making machines carry complex sophisticated processes behave intelligently possible 
mathematical logic concerned mal languages representation information various mathematical non mathematical kinds formal systems relations logical dependence process deduction 
discussions relations logic computation tendency confused statements say aspect logic identical aspect computation relation identity 
shall try precise 
single relationship logic computation dominates 
list important relationships 

morphological parallels formal command languages procedures described algol formal languages mathematical logic order predicate calculus natural languages extent may described morphologically describe grammatical sentence similar syntactical terms 
opinion importance relationship exaggerated soon goes sentences mean parallelism disappears 

equivalent classes problems certain classes problems computations equivalent certain classes problems formal systems 
example class turing machines initial tapes class formulas order predicate calculus class general recursive functions class formulas universal post canonical system class element lisp function suitable set arguments ak program stored program digital computer 
ask machine 
ask formula valid 
ask defined 
ask formula theorem 
ask ak defined 
ask program 
pair ei ej define computable map takes problems elements ei corresponding problem element ei problems answer 
turing machine initial tape find corresponding formula order predicate calculus turing machine eventually formula valid 
case want strict equivalence computer provided infinite memory kind 
practically computer states reason finiteness computation terminate repeat solar system comes forced consider problems concerning actual computers methods appropriate machines infinite number states 
results owe importance fact problem classes unsolvable sense class machine solve problems class 
result easily proved certain classes traditionally turing machine equivalence permits extension classes 
results generalized various ways 
world post myhill creative sets kleene hierarchies unsolvability 
world potential interest computation generation new unsolvable classes problems great interest computation 

proof procedures proof checking procedures relation stems fact computers carry algorithms devised generate proofs sentences various formal systems 
formal systems may subject matter interest mathematics science concerning relation intelligent computer program environment 
formal system done order predicate calculus particularly important reasons 
subjects interest axiomatized calculus 
second complete valid formula proof 
third general methods order predicate calculus able produce proofs significant results part arithmetic axiomatizable calculus important domain mathematics development general methods provide measure left subject matter dependent heuristics 
understood reader order predicate calculus undecidable possibility program decide formula valid 
done construct programs decide cases eventually prove valid formula run indefinitely case certain invalid formulas 
proof checking computer may important proof generation 
part definition formal system proofs machine checkable 
forthcoming explore possibilities applications machine checked proofs 
machine asked checking proof human proofs easier write systems 
particular proofs contain request machine explore tree possibilities conventional proof 
potential applications computer checked proofs large 
example trying computer programs test cases debugged prove desired properties 
incidentally desirable mildly general concept formal system 
formal system consists computable predicate check statement proof symbolic expressions statement proof 
say proof proof statement provided check statement proof value usefulness computer checked proofs depends development types formal systems proofs easy write formalization interesting subject domains 
remembered formal systems far developed logicians heretofore quite properly objective convenient prove metatheorems systems convenient prove theorems systems 

formal systems computer programs instructs computer perform task uses sequence imperative sentences 
hand instructs human perform task uses mainly declarative sentences describing situation act 
single imperative sentence frequently sufficient 
ability instruct person way depends possession common sense shall define fact count having available sufficiently immediate consequence tell presume knows 
proposed computer program called advice taker capabilities discussed advantages 
main problem realizing advice taker devising suitable formal languages covering subject matter want program think 
experience led mathematical linguists making serious mistake exclusive concentration syntax specially grammar natural languages 
important develop mathematical understanding formalization kinds information conveyed natural language 
mathematical theory computation earlier sections tried lay basis theory computations built elementary operations data spaces built 
formalism differs heretofore theory computability emphasis cases proving statements system metatheorems 
fruitful field logicians 
reasonable hope relationship computation mathematical logic fruitful century analysis physics 
development relationship demands concern applications mathematical elegance 
church calculi lambda conversion annals mathematics studies princeton princeton university press 
mathematical logic princeton princeton university press 
davis computability unsolvability new york mcgraw hill 
ershov operator algorithms russian doklady nauk vol pp 

kleene recursive predicates quantifiers transactions american mathematical society vol 

mccarthy letter editor communications association computing machinery vol 
august 
recursive functions symbolic expressions computation machine part communications acm vol 
april pp 

lisp programmer manual computation center 
computer programs checking mathematical proofs published proceedings american mathematical society symposium recursive function theory held new york april 
programs common sense proceedings conference mechanization thought processes office 
markov theory algorithms russian moscow ussr academy sciences mathematical institute 
naur report algorithmic language algol communications acm vol 
may 
turing computable numbers application problem proceedings london mathematical society ser 
vol 
correction ibid vol 

logical schemes algorithms problems cybernetics translated russian griffiths kiss muir new york pergamon press pp 


