discovering temporal patterns interval events kam po shan thesis submitted partial fulfillment requirements degree master philosophy computer science engineering chinese university hong kong june chinese university hong kong holds copyright thesis 
person intending part materials thesis proposed publication seek copyright release dean graduate school 
discovering temporal patterns interval events submitted kam po shan degree master philosophy chinese university hong kong sequence data collected applications 
examples range sales records stock exchange patient records scientific databases geophysics astronomy 
databases incorporate concept time describes event starts ends historical records 
temporal nature data provides better understanding trend pattern time find correlation events 
important interesting characteristic event sequences collection events occur certain pattern 
thesis interested discovering temporal relations events satisfy certain timing constraints event appears period event occurs 
existing algorithms mining temporal pattern treats data chronological orders event sequences support point events 
physical ordering events quite simple limited expressive power specifying temporal relations overlaps point interval data may exist exist application domains 
address problems introduce kinds patterns appseq linkseq accommodate temporal interval data 
patterns simple useful describe behavior events 
develop methods finding interesting patterns different data structures facilitate efficient mining process 
methods propose generalized taxonomy temporal relationships highly expressive describe basic relationships events 
quantitative performance study conducted experiments synthetic real datasets results show efficiencies proposed methods large databases 
acknowledgments thesis dedicated parents brother support pursue master degree continuous support studies 
wish express deepest gratitude supervisor prof ada fu continuing support guidance 
encouragement discussions advice invaluable resources prof ann heng prof man hong wong comments insights 
am thankful friends inspired study phil student 
chun chun tong lam lam chi man lam chi fung wong lai mak hon wai fung sun cheung 
course graduate studies benefited interactions warm people especially ming chan tsui ying law kwong wai chen ka po ma wai chiu wong wai ching wong chun hing cai tze kin lao yin ling cheung po man wan endless encouragement enthusiasm making years truly enjoyable 
want god love grace believe works years 
brothers sisters church continuous encouragement love patience showed ii contents ii data mining 
temporal data management 
temporal reasoning temporal semantics 
temporal data mining 
motivation 
approach 
focus objectives 
experimental setup 
outline contributions 
relevant data mining 
association rules 
classification 
clustering 
sequential pattern 
frequent patterns 
interesting patterns 
granularity 
temporal database 
temporal reasoning 
natural language expression 
temporal logic approach 
iii temporal data mining 
framework 
temporal association rules 
attribute oriented induction 
time series analysis 
discovering temporal patterns interval events temporal database 
allen taxonomy temporal relationships 
mining temporal pattern appseq linkseq 
temporal pattern 
second temporal pattern linkseq 
overview framework 
mining temporal pattern appseq 
mining temporal pattern ii linkseq 
summary 
mining temporal pattern appseq problem statement 
mining temporal patterns 
candidate generation 
large items generation 
mining temporal patterns 
candidate generation 
generating large items 
modified appone 
performance study 
experimental setup 
experimental results 
medical data 
summary 
mining temporal pattern ii linkseq problem statement 
method mining linkseq 
second method mining linkseq 
alternative method mining linkseq 
iv sequence tree design 
construction seq tree 
mining linkseq seq tree 
performance study 
discussions 
summary 


bibliography list figures kdd process 
sample fp tree 
sample decision tree naive bayesian network 
event structure 
versions employee objects time index 
thirteen possible relationships intervals sequence interval events 
different temporal pattern representation 
differences linkseq appseq 
composition item list 
main algorithm 
candidate generation algorithm 
support counting candidates 
candidate generation algorithm 
forming 
distribution temporal relations events 
variation minimum support 
execution time pass 
number large items generated pass 
variation window size 
scale number sequences 
scale number events sequence 
seq tree constructed sequence 
identical pattern main bh sub bh 
splitting node different sub bh 
seq tree constructed example 
vi construction sequence tree seq tree 
building main branch 
adding subsidiary branches 
mining frequent temporal pattern seq tree 
variation minimum support 
scale number sequences 
scale number events sequence 
vii list tables transform database seq list item list 
partial large item list 
candidates 
partial large item list 
partial large item list formed 
parameters 
number appseq different min sup 
mining appseq database 
large items 
transform database sequence form 
mining linkseq traversing seq tree 
number linkseq obtained different min sup 
viii chapter research thesis grows development data mining temporal databases 
extension mining temporal pattern accommodates interval data interesting useful temporal information 
chapter give brief data mining temporal database provide basic principles investigated 
related temporal reasoning temporal data mining discussed 
address motivation approach undertaken 
data mining decade data mining knowledge discovery databases kdd emerged significant field research 
emergence motivated rapid development data warehousing intelligent analysis data required 
advances technologies widespread bar codes supermarket goods monitoring devices hospitals sensors onboard orbiting satellites scientific geophysical science investigation enormous amount data high dimension collected 
explosive growth data infeasible analyze manually leads promising field study called data mining 
data mining defined nontrivial extraction implicit previously unknown potentially useful information data 
data mining developed confluence research machine learning statistics database systems 
fundamental goals data mining prediction description 
existing variables databases predict unknown values interest knowledge obtained 
finding chapter 
frequent patterns describe behavior data better understanding system analysis 
hand size complexity data generally large efficient scalable algorithms needed 
discovered knowledge applied commercial industry making better marketing strategy decision making system expert system medical diagnosis geographical information system scientific data tool analyzing data 
survey current data mining issues chapter 
studies data mining transaction database applicative databases temporal databases spatial databases object oriented databases multi media databases requires specific data mining techniques facilitate efficient effective knowledge discovery particular kinds data 
advances research temporal data structures temporal reasoning indexing query languages temporal databases provides new challenges study temporal data mining 
data mining techniques extended accommodate specific properties temporal data 
focus thesis methods temporal data mining extracts temporal information stored temporal databases 
temporal data management temporal databases incorporate concept time maintain past data 
store time varying information 
database applications temporal nature financial applications portfolio management accounting banking record keeping applications personnel medical record inventory management scientific applications weather monitoring study temporal databases active field research past decade 
generally temporal database supports distinct types time attributes valid time transaction time user defined time 
valid time stored time event takes place start time time values 
transaction time time event recorded database user defined time uninterpreted time domain 
valid time describes occurrence pattern events stored database promises greater utility source domain knowledge transaction time 
discussion temporal pattern thesis focused valid time temporal database 
record stores start time time tuple valid 
chapter 
data collected form event time sequences event lasts certain time interval 
instance hospital information systems laboratory examinations clinical records stored medical diagnosis patients behavior certain monitoring period 
records patient surgery june stored 
temporal nature data provides better understanding trend pattern time find valuable information 
example patterns patients took medicine took medicine hour got fever day 
frequent temporal patterns exhibited patients may identify correlations drugs diagnosis 
temporal data telecommunication network marketing data analyzing sequences time stamped data better understanding data changes time 
knowledge discovery temporal databases catches attention researchers 
research temporal databases important contributions characterizing semantics temporal information providing expressive efficient means model store query temporal data 
different models database management efficient storage access temporal data proposed 
optimization query processing indexing techniques active investigation 
instance extended sql standard tsql developed temporal databases 
tsql standard time widely represented intervals defined start time time points 
queries interval primitive adopted 
words point interval data supported 
believe significant investigations development temporal databases temporal data structure temporal algebraic operators query processing indexing paved way study temporal data mining 
existing mining techniques applied temporal databases handle temporal interval data directly new algorithms knowledge extraction needed capture temporal semantics 
temporal reasoning temporal semantics hand considerable research effort directed temporal aspects information systems 
temporal reasoning involves issues time modeling representation temporal relationships underlying temporal domain 
basically primitive notion temporal data time point time interval temporal reasoning systems chapter 

time points assumed linear ordering relation defined 
intervals expressed pair start time time points gamma gamma ordering relations expressed terms relations endpoints 
time points intervals complex inter relations example interval may overlaps meets interval 
different representations semantics temporal information proposed 
different measures ordering metric relationships helps express reason time application domains 
formalisms time modeling temporal logics 
follow syntax semantics modal logic represent temporally definite statements means temporal operators 
development various forms temporal logic played part data mining research particularly temporal pattern matching sequence mining 
instance order temporal logic way represent temporal patterns :10.1.1.28.536
sequence analyst recommends buy stock analyst recommends sell expressed analyst report analyst stock analyst report analyst stock og operators meaning respectively 
temporal logics computationally intractable expressive power exceeds requirement temporal databases 
number formalisms weakens temporal logic expressiveness developed 
define algebra temporal relationships classical point view 
commonly interval formalism allen interval algebra 
models relationship intervals subset set thirteen basic relations including meets overlaps starts finishes inverses plus relation equal 
binary operations intersection composition defined set relationships 
allen interval algebra order temporal logic widely knowledge discovery process 
incorporate temporal reasoning mean representation temporal knowledge framework 
strong emphasis placed complexity mining result easily read comprehended 
selection appropriate set temporal predicates fundamental provide useful temporal reasoning 
problem allen thirteen temporal relationships adopted describe basic binary temporal predicates details covered chapter 
chapter 
temporal data mining temporal data constitutes large portion data collected daily operations 
general temporal data loosely defined data contains temporal information 
examples include financial database stock price index telecommunications medical databases 
searching similar patterns temporal database useful applications discover predict risk causality trend associated specific pattern 
accommodation time mining techniques provides window temporal arrangement events ability suggest cause effect trends rule sets 
temporal data mining important extension capability infer causal temporal proximity relationships non temporal data mining able 
time component captured helps analyzing changes data time system 
may find causal relationships ordering occurrences events condition followed second identified cause effect relationship association knowledge time known 
likewise time component may assists identifying validity rules hiking boots outerwear years delta months years years 
reveals spring time customers buy hiking boots buy outerwear 
rule may valid 
observe adding temporal semantics rule set accurate clear information obtained 
addition discovering change knowledge obtained underlying data possible know quickly domain change helps better marketing strategies 
example identifying frequently unexpected occurring patterns event sequences stocks similar price movement customer purchasing patterns seasons rare events happened fraud detection gain information sequences records 
general set historical data collected form event time sequences 
current temporal data mining techniques broadly classified categories categorical numerical data analysis 
focuses discovery causal relationships temporally oriented events 
events concerned point categorical events time transaction takes placed recorded sales records telecommunication network alarms categorical data interval events valid time supported system patient database scientific databases geophysics astronomy chapter 
areas ordering data valuable source information direct operations 
numerical data analysis concerns discovery similar patterns time sequence different time sequences :10.1.1.40.4034
numerical values sequences taken consideration comparison trend discovery prediction known time series analysis 
different shapes changes data time analyzed 
previous knowledge discovery temporal data mainly sequential pattern :10.1.1.45.9405:10.1.1.40.9892:10.1.1.42.5048
potential knowledge extracted techniques treat data series chronological order 
consider ordering string events mainly support point events 
algorithms ignore time intervals data stamped 
physical ordering events quite simple limited expressive power specifying temporal relations overlaps address problems introduce kinds patterns appseq linkseq accommodate temporal interval data 
discuss details chapter 
motivation motivation research extend temporal data mining examines interval data stored temporal databases 
view emerging needs temporal data mining problem addressing temporal interval data aim find common sequences accommodates temporal semantics interval data 
introduce problem mining temporal patterns interval events observations 

emerging need development temporal databases capture temporal nature data stored applications 
studying information stored temporal databases lead better understanding evolving business 
rapid development research temporal databases different models temporal data storage query processing suggested 
favors developing temporal data mining techniques 

mining sequence data interval events important finding association temporal data ordering relation events provide insight causal relationships 
relation descriptions temporal relations specified interval data chapter 
helps understanding general trend sequence data 
existing algorithms point data 
simple ordering events considered series parallel ordering events taken place 
applied temporal database directly valid time supported 
need extend existing mining sequential pattern accommodate interval events 

contrary case time points relationship time intervals described different ways 
interval form different structures relation better understanding interact 
generalized taxonomy temporal relationships simple highly expressive needed express complex relations intervals 
complex relations involved possibly vast number temporal relationships single sequence events may complicated useful user 
restrict interest simple meaningful type temporal pattern pattern highly expressive reflect complex relations events 
motivates explore interesting temporal patterns appseq linkseq 

believe patterns useful describe temporal behavior events 
example clinical records storing time varying attributes find appseq linkseq data stock market data analyse changes data different intervals time specifying relationship considering timing interval restrictions obtain interesting knowledge temporal data 
approach framework mainly focus temporal databases store interval events discover interesting temporal relations order find correlation events 
example medical field patterns patients contract disease got disease time disease contracted 
frequent temporal patterns diseases exhibited patients may identify correlations diseases provide invaluable information diagnosis 
chapter 
focus objectives mentioned tremendous forms temporal patterns derived sequence interval events 
notice complexity results increases introduce complicated combinations may desirable feature 
computation time required increased may feasible mining purpose 
consider complex temporal patterns 
limit focus temporal patterns reveal temporal behavior events 
believe temporal relations give insight causal relationships 
events happened may cause event 
temporal patterns gives modeling idea 
introduce patterns chapter methods mining patterns chapter 
experimental setup evaluate performance proposed methods large range data conducted experiments ultrasparc workstation mb main memory 
methods written consider set synthetic data application domain medical database 
database stores person id disease person contracted corresponding duration time 
person record sequence clinical records stating different diseases contracted 
sequence potentially maximal large sequence 
example sequence person contracts disease treatment disease disease contracted 
number events sequence person chosen poisson distribution mean person may clinical records record refers event sequence 
synthetic database mining patterns 
secondly real data set contains clinical records patients 
refers spinal deformation 
database stores list measurements patients number curves curve locations degree curvature curve directions records patents personal information date birth family history class contracted treatment 
sequences records patients stored 
short sequences containing records obtained patients longer sequences 
examining changes values temporal attributes view sequence may discover temporal knowledge stored database 
aim chapter 
find interesting patterns occur frequently discover correlation non temporal attributes 
outline contributions thesis focuses temporal data mining 
framework mining temporal patterns suggested 
introduce notion temporal representation capable expressing relationships interval events 
interesting types temporal patterns considered 
believe findings lead useful systems mining temporal patterns involving events duration 
start discussion surveying current research data mining chapter 
aim survey provide better understanding nature knowledge discovery 
issues temporal data semantics context temporal database management 
gives background knowledge complexities integrating temporal semantics data mining techniques discussed 
state art temporal data mining showing different directions current identify related research challenges area 
chapter provides mining problem 
sequence interval events interested finding temporal relationship events time line 
particular focus kinds temporal patterns appseq linkseq simple easy understand 
general framework temporal patterns described 
chapter investigates greater depth temporal pattern appseq 
introduce variations appseq patterns pattern variates pattern 
introduce notion temporal patterns describe methods finding 
experiments synthetic data real data set 
chapter considers problem point view kind temporal pattern linkseq suggested 
introduce methods mining second temporal pattern means different data structures facilitate efficient support counting process 
performance study conducted experiments synthetic data sets results show efficiency proposed methods 
give talk chapter chapter relevant chapter briefly introduce current issues research data mining directions challenges involved 
study temporal database management temporal reasoning section respectively 
provide background knowledge problem discussed 
section investigate related various temporal data mining techniques new challenges faced 
problems accommodating interval data addressed thesis 
data mining years rapid growth size databases led increased interest automatic extraction knowledge data 
term data mining knowledge discovery databases kdd adopted general concept seeking knowledge data held structured databases 
strictly kdd viewed process extracting useful interesting information databases 
process includes selection preparation data manipulation analysis result obtained 
data mining considered part kdd process 
shows overview kdd process 
mainly divides phases understanding domain kdd discovery driven process need solid understanding domain order select right subsets data suitable classes patterns criteria interestingness pattern concerned 
cleaning data missing values invalid data incorrect input chapter 
relevant data selection data kdd process different ways exploiting useful data databases proposed 
selection essential fields mining process performed phase 
discovering patterns data mining scalable effective mining algorithms required extraction interesting knowledge large set data 
different strategies scaling search space mining process proposed 
postprocessing discovered patterns analysis discovered patterns expert knowledge performed 
evaluation result feedback mining process improve quality information obtained 
presenting final result user friendly interface recommended visualize mining result making discovered patterns easier understand 
interactive analysis final result 
data mining incorporates methods tools areas machine learning statistics databases 
areas aim locating interesting regularities patterns concepts empirical data data mining emphasizes automatic knowledge discovery huge data data corrupted noise errors missing values 
kinds data databases different applications contain complex data types structured data hypertext object oriented databases multimedia databases spatial databases temporal database spatio temporal databases transaction databases 
different techniques facilitate efficient effective extraction information needed 
summarize issues challenges development data mining 
chapter 
relevant ffl efficiency effectiveness huge amount data considered scalability mining process main concern decade 
time effectiveness algorithms finding useful patterns key concerns developing various mining methods 
ffl interestingness knowledge obtained discovered knowledge accurately portray contents database useful certain applications 
measures interestingness currently statistical measure frequency provides best optimal interesting rules 
may interested finding customer buying preference sales records look frequently occurring pattern 
cases may interested finding rare events fraud detection credit card payment plan failures plan execution traces exceptional rules medical field diagnosis 
different measures interestingness 
ffl various types data development various types databases involve complex data requires different mining techniques cope specific intrinsic information embedded data 
example ranges temporal data spatial data multimedia data semi structured web documents 
ffl robust outliers mentioned real data contains incomplete information unexpected values regarded noise requires careful handling avoid discrepancies mining result 
ffl interactive mining process data mining techniques usually application dependent expert knowledge incorporated interactively mining process helps producing useful results 
database amount knowledge extracted may far greater original data set 
multi stage filters reduce query search space basis source data target pattern statistics significance mining result needed 
interactive environment provides flexible way users determine number rules pattern obtained different instant preferred 
ffl visualization mining result visualization data mining result supports interactive mining process multiple abstraction levels 
chapter 
relevant helps mining result users user friendly way means nice graphical interface 
data mining techniques usually associated decision support systems knowledge base creation data warehouses expert systems newly discovered knowledge improve system performance provide better strategy 
hand knowledge obtained detection inconsistencies integrity enforcement systems semantic query optimization data warehouse 
various data mining techniques major data mining tasks association classification clustering sequence discovery 
excellent survey different aspects kdd conducted 
provide brief areas follows 
association rules mining association rules transactional relational databases caught lot attention 
association rules typically find correlations items transaction data sets customers purchase items single transaction 
relationship items expressed follows delta delta delta xm delta delta delta xn ae ae 
association rule derives database transactions consists set items bought customer single visit store 
example association rule customer buys usually buys bread transaction 
set rules obtained interpretation 
usually support count confidence value measure interestingness rules 
words focus frequently occurring pattern 
applications include supermarket inventory planning attached mailing direct marketing promotional sales planning 
apriori level wise method proposed mining association rules 
algorithm starts small data set large ones anti monotone heuristic length pattern frequent database length super pattern frequent 
mining process mainly divides phases candidate generation phase test bed phases 
mining association rules may require scanning large transaction database find different association patterns amount computational cost chapter 
relevant high 
efficient algorithms mining association rules various data structure pruning strategies performance enhancement developed :10.1.1.3.2424:10.1.1.40.6757
example finding frequent patterns association rules developed 
tree structure fp tree mining process 
suggested fp tree proposed deal frequent pattern especially large data set long patterns 
extended prefix tree structure storing crucial quantitative information frequent patterns 
fp tree constructed way ffl frequent length items nodes tree 
ensure potential frequent patterns form frequent length items considered 
ffl set frequent items transaction stored tree way item added node tree 
tree nodes arranged descending order frequency length items higher frequency nodes placed close root node 
transaction list nodes inserted root placed frequency items 
ffl multiple transactions sharing identical frequent item set merged number occurrences registered count 
easy check sets identical frequent items transactions sorted descending order frequency 
ffl transactions share common prefix sorted order frequent items merge shared part prefix structure count registers properly 
frequent items sorted descending order frequency prefix strings shared size tree reduced 
ffl transaction mapped path tree frequent information transaction stored tree 
frequent itemset transaction encoded corresponding path frequent pattern tree traversing tree ensures completeness result 
fp tree transaction database shown minimum support 
looking event header table find corresponding paths containing node examine prefix subpath node 
counter values stored node complete set frequent patterns generated 
structure fp tree helps keeping chapter 
relevant ffl cfl afl bfl fl fl fl fl fl fl head header fl fl fl fl fl sorted freq 
fl fl fl ofl bfl fl fl sample fp tree important information support counting frequent patterns 
look database needed 
words generates frequent pattern candidate generation phase scanning database support counting 
greatly reduce high cost mining frequent pattern experimental results show advantages approach 
hand variations association rules mining sequential pattern quantitative association rules market basket data suggested :10.1.1.40.9892:10.1.1.40.6428
rules quite large amount digest understand investigations interestingness rules discovered carried 
classification classification process finds common properties set objects database classifies different classes classification model 
set records corresponding attributes categorize records similar attribute values group describe characteristics classes 
history classification function developed identifying new candidates predication 
credit analysis card issuing customer records containing number descriptors 
customer known credit history customer record tagged excellent medium poor 
classification rules customers excellent credit history debt equity ratio 
class descriptions chapter 
relevant classify incoming data databases 
applications range target mailing franchise location credit approval treatment appropriateness determination scientific data analysis 
data classification studied substantially statistics machine learning neural networks expert systems important theme data mining 
examples decision trees bayesian network classifiers shown 
classification aims classifying new records appropriate class accuracy classification result main concern problem 
various methods improving accuracies results entropy values information theory penalty wrong classification multiple classifiers proposed 
hand years extension accommodate spatial objects geographical studies suggested 
group cfl fl fl group bfl group afl academia afl fl afl fl cfl sample decision tree naive bayesian network sample decision tree naive bayesian network clustering clustering segments original database different subsets clusters 
task identify clusters densely populated regions distance measurement large multi dimensional data set 
set objects clustering criterion number clusters required distance measure objects groups objects clusters objects cluster similar objects different clusters 
finds interesting structure directly data background knowledge concept hierarchies clustering useful discovering groups identifying interesting distributions underlying data 
clustering techniques studied extensively statistics 
algorithms partitioning medoids pam clustering large applications clara chapter 
relevant inefficient computational complexity point view 
efficiency concern algorithm called clustering large applications randomized search clarans developed 
experimental results showed clarans outperforms pam clara 
pam clara find representative points clusters objects analyzing possible pairs objects computationally inefficient large values clustering large sets points clustering feature tree cf summarizes information sub clusters points algorithm balanced iterative reducing clustering birch capable finding clusters single scan data 
hand traditional clustering algorithms mean medoids approaches suffer fact cluster represented just point 
methods deal irregular shapes sizes different clusters data 
address problem method called clustering representatives cure multiple representatives clusters proposed 
chooses set points represent cluster employs novel hierarchical clustering algorithm adopts middle ground centroid point extremes 
density clustering method dbscan supports arbitrary shapes clusters suggested 
clusters concave clusters clusters noise significantly different diameters located close 
addition number clusters unknown advance input parameter required 
problem high dimensionality tackled sub space approach clique cluster analysis 
large set multi dimensional data points data space usually uniformly occupied data points 
clique identifies sparse crowded places considering appropriate subspaces original dimensions maximize similarity cluster maximize difference groups 
allows records missing values clustering accurate results replacing missing values taken distribution 
sequential pattern previous classes data mining problems static data captured sequential pattern mining temporal knowledge extraction sequence data data associates occurrence time 
linear ordering known chapter 
relevant serial ordering obtained 
problem mining sequential patterns stated follows fi delta delta delta ing set items 
itemset subset items denoted delta delta delta ik ij item 
sequence ordered list itemsets 
sequence ff denoted ff 
ff 
delta delta delta 
ffq sequence element ffj itemset 
sequence ff ff 
ff 
delta delta delta 
ffn called subsequence sequence fi fi 
fi 
delta delta delta 
fim exist integers delta delta delta jn ff fij ff fij delta delta delta ffn 
sequence itemsets pj called sequence 
interested finding sequence support threshold minimum support support number data sequences contain pattern 
application domain time attribute data various web log telecommunication network marketing sales transactions collected :10.1.1.40.9892:10.1.1.42.5048
analyzing sequence data obtain better understanding trend behavior system 
example consider sales database book store records books bought customer period time 
interesting patterns people buys jane austen pride prejudice buys emma month 
stores patterns promotions shelf placement web access database particular site discovered patterns sequences frequently accessed pages site 
kind information restructure web site dynamically insert relevant links web pages user access patterns 
frequent patterns mining frequent patterns sequence database studies contributed efficient mining sequential patterns frequent patterns time related data :10.1.1.3.2424:10.1.1.40.3204:10.1.1.40.9892:10.1.1.42.5048
mechanism proposed relies apriori heuristic proposed association mining non frequent pattern frequent :10.1.1.40.9892
frequent sequences length built frequent sequences length gamma applying self join operation set computing support resulting sequence 
frequent sequences removed result 
heuristic generalized definition sequential patterns include time constraints sliding time window user defined taxonomy proposed generalized sequential pattern mining algorithm gsp developed 
hand research sequence mining oriented chapter 
relevant discovery episodes occur frequently sequences :10.1.1.42.5048
episode formally conjunction events includes serial parallel ordering events 
results sequence mining episode rules form time intervals 
may discover causal relations events 
extension finding frequent episodes uses temporal logic formalism expressing temporal patterns defined categorical data suggested :10.1.1.42.5048:10.1.1.28.536
discovers frequent patterns satisfy certain temporal logic expressions 
temporal logic programming suggested mechanism discovery frequent patterns expressible temporal logic 
order temporal logic fotl express patterns hold stock market sentiment hold temporal predicate 
temporal operators considered expressed terms episodes 
apriori employs bottom search enumerates single frequent itemset exponential complexity fundamentally inefficient discovering long patterns large data set low minimum support 
new algorithm sequential pattern discovery equivalence classes spade fast discovery sequential pattern proposed 
vertical id list database format sequence associate list objects occurs time stamps frequent sequences enumerated simple id list intersections 
approach decompose original search space smaller pieces sublattices processed independently suggested 
sequences scanning database 
data structure wap tree mining sequential pattern variation fp tree shown 
wap tree proposed mining web logs data point events considered 
storing critical information access pattern mining generation large candidate set wap tree facilitates efficient mining access patterns 
technique projection databases frequent item matrix introduced mining sequential pattern 
general idea frequent items recursively project sequence databases set smaller projected databases grow subsequence fragments projected database 
experimental results show reducing high cost candidate generation test methods outperform apriori gsp method 
chapter 
relevant interesting patterns conventional mining techniques provide users limited mechanism minimum support specifying patterns interest unfocused approach suffers major drawbacks disproportionate computational cost selective users overwhelming volume potentially useless results 
tackle problems simple natural syntax regular expressions res introduced flexible constraint specification tool enables user controlled focus incorporated pattern mining process 
re constraints help pruning search space patterns computation directing useful results return users 
family algorithms sequential pattern mining regular expression constraints spirit proposed mining frequent sequential patterns satisfy user specified re constraints 
suggested algorithms address problems narrowing target search space 
similar idea imposing selection constraints user specified pattern suggested 
language specifying episodes interest 
frequencies measure interestingness sequential pattern notion minimum description length principle mean evaluate mining result proposed :10.1.1.34.184
number bits sequence encoded appropriate coding scheme sequences large code length interpreted potentially surprising patterns patterns considered interesting 
likewise finding frequently occurring patterns suggest measure interestingness capture rare events 
extremely useful error discovery errors supposed rare events restrict search space frequent sequences exceptional sequences easily rejected impossible distinguished trivial sequences 
pruning predictive redundant patterns interest proposed deal plan failure prediction applied predict telecommunication equipment failures reduce size returned rule set significantly 
probabilistic approach adopted 
pattern deemed interesting ratio actual number occurrences exceeds expected number occurrences user defined threshold 
assumed event sequence occurs probability certain conditional distribution exist neighboring events 
expected number occurrences certain pattern sequence computed 
unexpected patterns chapter 
relevant xfl fl xfl fl xfl fl event structure series operating system calls sendmail program :10.1.1.40.9892:10.1.1.40.4034
granularity discovery temporal patterns relationships involve multiple granularities addressed 
stressed events occurring day happening weeks specific day may capture attention 
event structure set temporal constraints set variables representing events target patterns events match structure 
consider event structure depicted variables assigned ibm rise ibm earnings report hp rise ibm fall respectively 
complex event type describes scenario ibm earnings reported day ibm stock rose week ibm stock fell hp stock rose business days rise ibm stock hours fall ibm stock 
facilitate pattern matching process notion timed finite automaton granularities tag introduced 
tag essentially standard finite automaton modification set clocks associated automaton transition conditioned input symbol values associated clocks clocks automaton may running different granularities 
temporal database temporal database records time varying information 
applications temporal nature financial applications inventory management scheduling applications scientific applications development temporal databases research topic decades number bibliographies research field published 
important contributions characterizing temporal semantics chapter 
relevant information providing expressive efficient means model store query temporal data 
temporal database maintenance requires consideration different time dimensions 
orthogonal time dimensions proposed valid time period information input valid transaction time time record stored 
valid time allows keep track history application domain evolution time transaction time allows maintain history evolution database 
research temporal databases roughly categorized areas 
area formulation semantics time closely related research issues knowledge representation 
issues various theoretical point view temporal logic infinite periodic time sequences applied questions represent time values minimal space utilize calendars 
data types time points time intervals temporal elements sets intervals representation time discussed 
data explicitly stored temporal database associated certain semantic assumptions assumption viewed way deriving implicit information explicitly stored data 
second area concerns physical implementation issues focus efficient access methods data organization strategies temporal database 
conventional indexes long reduce need scan entire relation access subset tuples support selection algebraic operator temporal joins facilitate efficient temporal query processing 
temporal indexing strategies trees index time point values 
indexing techniques time index shown 
capable retrieving versions object valid specific time period 
proposed improve performance certain classes temporal queries 
valid time intervals various object versions overlap arbitrary ways 
define total ordering interval values special attention paid selection set linearly ordered indexing points time dimension 
third category study temporal database logical modeling temporal data emphasize extension relational data model capture temporal semantics support relational temporal query languages 
extended models generally augment relations snapshot data model time attributes store relevant timestamps valid chapter 
relevant efl fl efl fl efl fl efl fl fl fl fl fl fl fl fl fl fl fl fl fl fl fl tfl efl fl efl fl efl fl efl fl efl fl efl fl fl fl fl fl fl fl fl fl fl fl fl fl efl fl efl fl efl fl fl efl fl efl fl efl fl efl fl fl efl fl efl fl efl fl fl efl fl fl fl efl fl efl fl efl fl fl efl fl efl fl efl fl fl efl fl efl fl efl fl efl fl fl efl fl efl fl efl fl efl fl fl efl fl efl fl efl fl efl fl fl versions employee objects time index time transaction time 
new temporal operators defined extended data models traditional relational algebraic operators allow users query time attributes 
languages designed support predicates temporal values multiple calendars schema versioning periodic data point interval semantics adequate expressive power ability efficiently implemented 
notable temporal querying language tsql 
tsql developed consolidate approaches temporal query languages comprehensive temporal extension sql time represented intervals 
temporal reasoning closely related study formulation semantics time temporal database research temporal reasoning artificial intelligence ai information system 
temporal reasoning fundamental choice time points time intervals primitive objects reason action time 
influential theories time interval algebra ia introduced james allen 
addresses problem representing temporal knowledge performing temporal reasoning perspective natural language understanding 
notion relations pairs intervals introduced 
bases allen approach consists interval chapter 
relevant temporal logic computationally effective reasoning algorithm constraint propagation 
interval represented ordered pair gamma real numbers gamma denoting left right endpoints interval respectively 
relations intervals composed disjunctions basic interval relations known interval operators operate intervals denoted int int 
boolean value returned follows ffl int overlaps int ffl int int ffl int meets int ffl int int ffl int int thirteen basic relations get possible relations intervals full algebra 
reasoning algebra reasoning implied interval relations determining consistency set assertions shown np complete 
point algebra pa introduced notion time point place interval 
basic relations pa hold points 
relation points disjunction basic relationships gives set natural language expression temporal representation reasoning necessary components systems consider events occur real world 
appointment scheduling time management natural language expressions refer collections intervals routinely 
effective means representing intervals essential 
example classes expressions day month refer collection intervals explicitly 
hand expressions election day tuesday monday november specify intervals implicitly 
formula represent collections intervals proposed 
example assume time saturday december midnight collection described formula 
ff day ff days mod days chapter 
relevant foundation collection representation set primitive collections called calendars 
calendar collection consisting infinite sequence intervals span time line 
days months chinese calendar years instances calendars 
temporal logic approach natural language expression reasoning time mathematical model temporal logics proposed 
logics concept predicate calculus statement universally true false may true false different moments time 
temporal quantifiers augment calculus 
temporal operators 
temporal data mining temporal data mining non trivial extraction implicit potentially useful previously unknown knowledge implicit explicit temporal content large quantities data 
accommodation time mining techniques provides window temporal arrangement events ability suggest cause effect 
framework recognized time dependent information important data mining 
temporal patterns concerning temporal features rules associations investigated discovered temporal databases provide accurate information evolving business domain 
prototype system architecture mining temporal patterns introduced 
generic definition temporal pattern 
temporal pattern defined triplet patt general pattern may trend classification rule association rule causal relationship periodic time expression general interval expression 
takes absolute time measure interest discovery patterns 
temporal data mining language temporal query mining language suggested integrated framework 
snapshots derived knowledge temporal patterns existing data interesting temporal patterns may lost 
hand idea adding chapter 
relevant temporal semantics existing data mining tasks suggested 
introduces integration temporal reasoning knowledge discovery process 
conventional data mining algorithms extended handle temporal semantics attribute oriented induction association rule 
temporal association rules association rules extended different ways deal quantitative categorical data 
overlook time components usually attached transactions stored databases 
existing algorithms applied temporal databases directly temporal information ignored 
problem integrating temporal issues association rules addressed 
integration calendar set time intervals discovery association rules proposed 
concept association rules defined rules associate instances calendar 
segmenting data different time intervals may discover interesting pattern previously ignored 
example beer chips sold primarily pm pm week days viewing data week may get support pattern beer chips support confidence 
segment data intervals am pm pm pm consider data weekdays may find support beer chips rule segment pm pm jumps 
analyzing data finer time granularity may find interesting rules exist certain time intervals occur period time 
likewise determining periodic intervals rules problem mining cyclic association rules introduced detects periodical behavior rules time 
instance find association rules monthly sales data may observe seasonal variation certain rules held approximately year 
periodicity limited power describing real life variations 
complicated patterns working day month described simple periodic expression 
similar idea association rules segments data intervals suggested 
gaining support discover interesting rules discovery association rules known valid periods periodicities concerned 
introduces notion temporal association chapter 
relevant rules absolute time taken consideration 
find rules summer customers buy bread butter buy milk consider period may september year 
temporal information extracted provides detailed information reflect dynamic changing data reality static 
particular may interested finding longest interval association rule holds behaves periodically 
hand discovering relationships items satisfy certain timing constraints overlaps temporal database find interesting associations items recorded tuples 
group tuples certain timing constraint examine tuples group find association groups items 
example duration item item overlap intersect correlate 
idea adding temporal semantics existing data mining techniques raised 
extends association rule mining technique handle temporal semantics examining temporal relation associated items 
finding associated attributes look temporal relationships 
temporal nature data captured 
instance original association rules may tell investment portfolio associated insurance policy temporal associations may tell investment portfolio usually occurs start insurance policy may indicate customers start insurance policy gateway services investment portfolio attribute oriented induction extension accommodating temporal semantics existing data mining techniques attribute oriented induction 
temporal interval generalization framework facilitate generalization time interval data introduced 
integration existing algorithm induction characterization rules 
time series analysis time series analysis focuses symbolic patterns numerical curve patterns sequences useful applications stock market data financial data telecommunication network data analysing change shapes relationship mining cyclic association rules partial periodic chapter 
relevant patterns sequences suggested 
partial period interval methods finding partial periodic patterns time series proposed 
example partial periodic pattern may state jim reads vancouver sun newspaper weekday morning activities times regularity 
sequence consideration look periodic patterns partial periodic patterns preferred 
idea interval time event happens similar problem focused interval events 
periodicity temporal relations events considered 
length timing interval partial periodic pattern determined behavior repeating pattern length timing interval occurrences events 
conventional data mining techniques accommodate interval data useful applications previous temporal data mining especially mining sequential pattern extend current accommodate interval data 
chapters interesting temporal patterns introduced 
chapter discovering temporal patterns interval events chapter describe mining problem details 
aim find temporal patterns defined terms allen taxonomy temporal relationships sequences interval events stored temporal database 
formulate concept event sequence section introduce allen taxonomy temporal relationships section 
introduce temporal patterns appseq linkseq section 
argued patterns capable expressing complex relationships interval events 
overview framework mining interesting patterns section 
summarize discussion section 
temporal database adopt discrete model time integer represents point instant time time line 
granularity time scaled different segment sizes seconds years smallest possible granule size defined 
actual duration application specific 
temporal database supports types time elements introduced previous chapter 
transaction time valid time user defined time 
database captures past data temporal attributes change values time 
applications medical database scientific databases geophysics astronomy data stored associated valid time 
instance health care database patient record stores patient charge time discharge operation takes hours finish 
chapter 
discovering temporal patterns interval events kind data stored temporal database historical records 
tuple associates pair ordered time points stating period information stored valid 
focus valid time data stored indicates evolution data time 
events stored temporal database happen linear time order event lasts period time 
denote events interval events 
describe problem formally introduce terminologies 
assume temporal database database record contains pair ordered time points ts te ts te positive integers 
start time time specify valid time information stored 
record may attributes simplicity consider single temporal attribute denote event 
assume set event types 
definition event event associated time occurrence specified triple ts te event type ts te start time time respectively 
ts te indicate times 
consider example medical database 
temporal database record database contains person id name disease start time time 
suppose event represents contraction certain type disease 
general setting assume event associated person 
assume database set sequences sequence consists events particular person 
sequence person 
definition sequence sequence events defined list events event associated person person sequence sj sj ts te ts te tsn events ordered times tei tei gamma 
definition similar customer sequence proposed tuples associated person grouped form sequence :10.1.1.40.9892
events ordered time ensure event ends order interval events 
chapter 
discovering temporal patterns interval events bfl efl overlaps relation xfl equal equal xfl meets met xfl xfl overlapped xfl tfl sfl tfl efl tfl efl contains xfl xfl xfl tfl efl starts started xfl xfl xfl xfl tfl efl finishes finished xfl ofl dfl sfl ffl thirteen possible relationships intervals allen taxonomy temporal relationships relationship time intervals described different ways 
allen taxonomy temporal relationships adopted describe basic relationships events 
takes notion temporal interval primitive obtains set temporal relations intervals 
provides simple natural syntax specifying temporal relations intervals thirteen relationships useful describing inter relations interval events 
summarizes allen thirteen temporal relationships 
relations intervals expressed terms relations endpoints call endpoint constraints 
instance consider sequence overlaps ts ts te ts te te 
known thirteen relationships express relationship held intervals provide basis description temporal patterns 
relations mirror image example overlaps implies relation overlapped 
focus primitive temporal relations order items preserved 
relations shown shaded area 
call set temporal chapter 
discovering temporal patterns interval events relations rel 
rel rel events sequence endpoints satisfying constraints rel say rel true sequence 
simplicity symbols represent corresponding rel figures chapters 
endpoint constraints suggested order events important representation temporal relations 
observe primitive relations intervals te te ts ts te te 
sections restrict order events setting times strictly ascending order start times descending order equal times 
obtain set binary predicates consider temporal relations events 
combining binary predicates sequence events expressed different temporal patterns observe discovering possible patterns computationally amount results user overwhelming 
restrict attention temporal patterns provide simple meaningful results showing temporal behavior events 

appseq delta delta delta rel rel delta delta delta gamma ak 
expands event time find temporal relations preceding events 
may obtain pattern overlaps overlaps 
sequence get idea events related time line 
temporal pattern going study discuss chapter 

linkseq rel rel delta delta delta ak gamma gamma ak operation 
form sequence linking common events binary predicate 
patterns overlaps overlaps 
sequence obtain individual temporal relations events clearly 
second temporal pattern investigate chapter 
believe patterns useful describe temporal behavior events 
simple easy understand 
knowing ordering events happen obtain better understanding events interact 
patterns formed binary predicates closely related different representations sequence 
introduce chapter 
discovering temporal patterns interval events afl bfl cfl dfl fl fl fl fl fl fl fl fl tfl sequence interval events framework mining appseq 
continue study second pattern linkseq describe details chapter 
mining temporal pattern appseq linkseq pattern formed combining events associated relations group events 
appending event greater time preceding events 
consider sequence shown combine binary predicate overlaps event having associated temporal relation considering endpoint constraints binary predicates event 
result pattern overlaps overlaps 
pattern formed appending event time call appseq 
afl bfl cfl dfl bfl dfl fl fl fl fl fl fl fl fl tfl afl cfl overlaps overlaps dfl afl bfl cfl dfl bfl dfl fl fl fl fl fl fl fl fl tfl overlaps fl afl cfl different temporal pattern representation temporal pattern step expanding patterns single event may interested discovering temporal pattern patterns sizes greater combined temporal relation 
see different chapter 
discovering temporal patterns interval events patterns overlaps overlaps overlaps hold sequence considering different ways combinations 
easy see number possible descriptions exponential sequence size 
restrict interest patterns formed appending event time find temporal relations preceding group events 
consider temporal patterns form rel rel gamma ak call temporal pattern 
main reasons restriction 
believe temporal relations give insight causal relationships 
events happened may cause event 
temporal patterns form gives modeling idea 

discovering possible patterns computationally amount results user overwhelming 
verify argument computation complexity implemented mechanism discover temporal pattern obtained appending composite pattern size time results patterns overlaps 
show experiments small extension way results increased computational cost 
name temporal pattern temporal pattern 
temporal patterns derived appseq slightly different nature look 
leads differences mining methods discussed chapter 
second temporal pattern linkseq hand second temporal pattern known linkseq formed linking binary predicates common event binding point 
composition results form overlaps overlaps sequence shown 
extract temporal knowledge events pair investigate relations binary predicates sequence 
linkseq looks similar appseq sequence 
obtain patterns emphasizing different temporal structure formed events 
fact appseq chapter 
discovering temporal patterns interval events cfl dfl tfl bfl afl cfl dfl tfl bfl afl linkseq overlaps overlaps fl overlaps starts fl overlaps fl appseq overlaps overlaps fl cfl dfl tfl bfl afl linkseq overlaps finishes fl appseq overlaps fl overlaps fl cfl dfl tfl bfl afl differences linkseq appseq general linkseq 
illustrate idea giving example 
consider sequence shown 
appseq form composite pattern overlaps going append event form new sequence 
consider linkseq relation may gain support discovered mining process 
process obtaining longer sequence linkseq terminates 
linkseq appseq generalizes groups distinct relations relation gains support pattern 
result patterns appseq 
hand appseq expands event time appending event having greater time preceding events 
come temporal relation finishes equal events sequence shown may obtain overlaps overlaps appseq 
linkseq obtain longer pattern overlaps finishes consider pairs binary predicates 
linkseq includes event equal time preceding events 
considering cases notice pattern reveals temporal behavior events sequence closely related 
argued patterns interesting useful describe temporal behavior interval events 
overview framework mentioned pay special attention mining temporal pattern appseq linkseq 
different formation patterns proposed chapter 
discovering temporal patterns interval events methods different strategies tackle problem 
briefly describe approach mining patterns 
mining temporal pattern appseq regarding appseq form pattern appending event time 
idea expanding event examine second pattern formed appending events binary predicate time results number events pattern denote temporal pattern 
extension original pattern name temporal pattern 
temporal patterns similar formation introduce method appone considering simplest form appseq shown 
extend method finding kind pattern shown second method 
basic strategic similar apriori approach layout call item list mining process appone :10.1.1.40.6757
comparison performance study methods experiments synthetic data conducted 
addition patterns formed binary predicates observe methods suffer high cost generation binary predicates early stage mining process 
deal problem investigate improved mechanism form binary predicates directly data undergoing candidate generation phase 
discuss methods details chapter 
mining temporal pattern ii linkseq different formation second temporal pattern linkseq extract temporal knowledge different data structures results methods perform mining task 
intuitively may find linkseq deriving appseq 
frequent events form appseq form corresponding binary predicates form linkseq linking binary predicates order events preserved inherited appseq 
mentioned previous section appseq may event time preceding 
may find complete set linkseq suggests 
despite method useful consider linkseq chapter 
discovering temporal patterns interval events appseq result 
denote method 
formation linkseq combining binary predicates suggests modify previous appone method accommodate needs second pattern apriori approach 
call method 
apriori approach divides mining process candidate generation phase support counting phase inspired mining frequent pattern propose tree structure store sequence data 
exploring compact information stored seq tree develop efficient mining method pattern linkseq 
discuss alternatives mining linkseq chapter 
experimental results showing performance methods 
summary chapter introduce temporal patterns called appseq linkseq 
previous approaches mining sequential patterns considers point events consider interval events believe important applications 
employ allen taxonomy temporal relationships mechanism express temporal patterns interval events 
discover number temporal relationships prohibitively large patterns may complicated little value users 
consider types temporal patterns simple meaningful 
describe mining methods patterns details chapter 
chapter mining temporal pattern appseq chapter discuss temporal pattern appseq subdivides introduced previously 
start giving notion temporal pattern section 
methods mining pattern described section respectively modified approach proposed section 
experimental results section 
section summarize discussion mining appseq 
problem statement mentioned chapter assume event associated time occurrence ts te 
obtain binary temporal predicates consider events 
express complex relation events sequence form temporal pattern appending event time temporal relation definition definition temporal pattern temporal pattern defined recursively follows ffl single event type temporal pattern called atomic pattern 
ffl temporal patterns rel rel rel temporal pattern 
composite pattern 
size temporal pattern number atomic patterns pattern 
chapter 
mining temporal pattern appseq definition atomic patterns sequence shown 
sizes atomic patterns 
composite patterns include overlaps overlaps overlaps size pattern respectively 
mainly focus finding composite pattern consists group atomic patterns 
definition mapping atomic temporal pattern mapping sequence find event type sequence 
denote mapping feg 
associate time duration mapping follows ts ts te te say holds composite pattern rel atomic pattern rel rel mapping rel sequence mapping find event type mapped consider imaginary event start time ts time te rel true 
case rel feg 
say relation rel holds mapping rel associated time interval rel ts minfm ts tsg rel te te mapping composite pattern sequence union time intervals takes place 
form minimum time interval includes events composite pattern 
resultant interval determined minimum start times maximum times respectively 
example sequence shown obtain composite pattern overlaps resultant interval :10.1.1.42.5048:10.1.1.40.4034
user specify maximum length time interval interest known window size win size 
intuition events happen close interested find correlation 
definition window size window size temporal pattern holds sequence mapping te gamma ts chapter 
mining temporal pattern appseq definition item ai bag event types reli rel item form ffa frel rel gamma pg temporal pattern terms events types ak relations rel gamma 
window size subset set events sequence supports item ffa frel rel gamma pg mapping temporal pattern te gamma ts say event supports example window size sequence supports temporal pattern overlaps overlaps overlaps 
support temporal pattern set sequences defined total number different mappings sequences pattern total number sequences support sjs supports support item support temporal pattern item 
large item item having support greater threshold min sup provided users support min sup 
aim find large items mining temporal patterns propose method appone mining frequent temporal pattern shown 
example illustrate method works 
example patient database form shown table 
tuple contains person id disease contracted patient duration disease 
database find diseases cause diseases temporal relations 
assumed minimum support window size set time units 
layout event sequence different finding sequential pattern :10.1.1.40.9892
transforming original database list sequences seq list sequence corresponds person item list represent temporal data 
event associated list chapter 
mining temporal pattern appseq person id disease start original database person id seq list seq list item pid list item list table transform database seq list item list chapter 
mining temporal pattern appseq person id start time time pid ts te 
table illustrates differences approaches example patient records 
note item atomic composite pattern ts te item list indicates time interval pattern 
similar idea transforming database form called item list 
basic strategic similar apriori gen approach :10.1.1.40.6757
seq list need scan database iteration 
item list approach avoids problem enables count support direct composition lists 
size lists number candidates shrink sequence length increases facilitates fast computation 
motivates choose item list format store large items efficient support counting 
initially compute large items single database scan storing large atomic patterns item list 
refer set large items lk 
generate candidates combining gamma item lk gamma single event 
candidate form fa bg gamma item item 
database refer set candidates generated method ck 
major task generation large items determine candidate contained sequence 
candidate examine lk gamma determine temporal relations composite pattern atomic pattern sufficient supports 
generate new large items obtain lk item list merging composite atomic patterns temporal relation 
composition item lists form lk depicted 
need scan database create item list pass 
iterations simply join item lists obtain large items 
computation time mainly depends size item lists lk ck shrink iterations 
main algorithm shown 
algorithm terminates find large items current pass 
discovery process mainly divided phases sort phase group records person id major key time minor key sorting ascending order start time descending order shown table 
initial phase pass determine large atomic patterns called items repeatedly forming composite patterns iterations 
store large items item list shown table 
chapter 
mining temporal pattern appseq candidate efl large item fl overlaps efl fl overlaps efl fl fl fl fl fl fl efl cfl fl fl fl fl efl fl fl fl fl composition item list item count item count item count item count item count table partial large item list candidate generation subsequent pass add large atomic pattern composite pattern lk gamma set form new potentially large item items called candidates 
details described subsection 
large items generation generating candidates scan item list counting support candidate 
number sequences support temporal patterns window 
th pass algorithm determines large items 
elaborate mechanism generating large items section 
candidate generation array store candidates 
logical form candidates shown example table 
candidate generation obtain ck lk gamma done chapter 
mining temporal pattern appseq main algorithm input set atomic patterns 
output large items klk algorithm main algorithm large tuples containing items minimum support lk gamma generate refer section ck candidate gen lk gamma lk large items ck refer section main algorithm item item overlaps overlaps overlaps 
table candidates adding large item time 
generate candidates combining events atomic patterns composite patterns 
set candidates consider combinations form 
binary temporal pattern form rel implies time late sure true generate candidate form fa bg 
passes large items formed 
items composite patterns 
generate ck lk gamma 
case knowledge regarding temporal relations composite patterns atomic patterns applied 
prune irrelevant candidates phase 
algorithm candidate generation describe pruning step 
instance item pattern shown table aim find temporal relation item event previous pass pattern form rel rel large exclude possibility having candidate generation large item 
table shows chapter 
mining temporal pattern appseq input lk gamma output ck candidate set algorithm candidate gen lk gamma pair composite patterns bi lk gamma atomic patterns aj bi gamma item ai ai gamma aik gamma rel ai aik gamma generate candidate element fbi candidate generation algorithm item count item count item count item count overlaps table partial large item list generation candidates 
lemma algorithm generates potentially large items 
proof algorithm try form candidate gamma item item 
gamma item item 
event type ai event type aik gamma event type pruning sure ai aik gamma form pattern relations pattern support min sup 
suppose rel support min sup 
relations rel 
consider 
bef ore holds sequence events mapped mapped 
equal equal holds sequence means starting time event mapped ai equal starting time mapping relation starts true 

meets meets holds sequence implies event mapped aik gamma meets mapping chapter 
mining temporal pattern appseq 
overlaps overlaps holds sequence event mapped aik gamma may overlaps starts mapping 
holds sequence events mapped relation mapping 
starts starts holds sequence event mapped ai starts mapping 
event latest time finishes cases generated candidate 
large items generation phase divided 
support counting phase generation large items 
support counting need find supports candidates generated 
determine number sequences support temporal relation composite pattern candidate 
compare endpoint values elements lk gamma determine temporal relation holds composite atomic items 
large items formed support greater threshold 
facilitate efficient counting hash tree store relevant part item list hash tree store lk gamma part gamma item list 
value event key hashing hash tree 
hash tree composite patterns values events included temporal relations form key simple concatenation 
leaf nodes hash tree corresponds large item records mappings pattern mappings stored form item list start times times 
candidate composite pattern event search keys find hash trees corresponding lk gamma items 
search hash tree hashing done internal nodes reach leaf nodes perform exact matching composite atomic pattern 
consider pattern large gamma item pattern large item 
identify temporal relation holds mapping mapping start times times recorded chapter 
mining temporal pattern appseq input ck output lk algorithm large items ck candidate ck relation reli rel count reli support count respect reli lk gamma satisfying win size threshold 
count reli min sup lk lk bi reli aj bi lk gamma aj bi aj elements bi reli aj ts min bi ts aj ts bi reli aj te aj te support counting candidates corresponding hash trees 
composite pattern count candidate respect specific temporal pattern increased 
counts kept auxiliary information table candidate items 
counts candidate temporal relationship 
forming large items second subphase form large items 
table shows partial set large items 
identifying temporal relation items ck generate lk lk gamma corresponding temporal relation 
new item lk composite pattern pass 
resultant interval obtained union intervals gamma item item 
instance shown table start time time mapping composite pattern overlaps algorithm forming large items summarized 
lemma algorithm generates large items 
proof item large support min sup sequence supports set events mapped temporal pattern appear interval smaller user specified window size threshold 
subset support great events appear interval smaller window size chapter 
mining temporal pattern appseq threshold 
subsets considered candidate generation guaranteed discover large items 
lemma large item generated algorithm represents frequent temporal pattern 
proof formation large item generate resultant interval composite pattern union intervals gamma item item 
resultant interval obtained minimum interval includes gamma item item associated time occurrence item formed 
hand support counting phase th iteration determine temporal relations gamma item item examining endpoint values 
time item equal greater item endpoint constraints shown obtain corresponding temporal relations having support form large items 
result obtain temporal relation preceding events gamma item appended event item appseq 
item formed generates corresponding frequent temporal pattern 
lemmas show method appone correctly finds complete set frequent temporal patterns 
see mining process scans original database 
formation large items composition item lists takes place candidate 
main cost method composition item lists gamma jl determined size candidate set jl 
mentioned size item lists comparatively smaller original database size candidate set shrink iterations 
early stage mining process time memory spent generation large number lk 
mining temporal patterns previous section mining temporal pattern generate large adding atomic pattern time 
consider slightly complex form temporal patterns call temporal pattern 
temporal pattern defined recursively temporal pattern size temporal pattern 
overlaps 
temporal pattern chapter 
mining temporal pattern appseq item count item count item count overlaps overlaps overlaps finishes table partial large item list formed temporal pattern size rel rel rel temporal pattern 
example composition shown 
patterns generate number events items 
focus temporal relations events adding item time 
modifying previous method appone accommodate adding item case derive method method called mining temporal pattern 
fact works similarly appone candidate generation phase formation large items 
candidate generation formation process 
start generate examine gamma compositions elements item list gamma 
prune irrelevant candidates phase need consider newly added atomic patterns time say aj aj aj 
added items combined composite pattern say bi bi gamma conditions hold 
relation leftmost atomic pattern bi aj aj 

relation rightmost atomic pattern bi aj aj 
example consider item overlaps shown table 
find large items include combination overlaps candidates 
candidate generation algorithm second method shown 
lemma algorithm generates potentially large items 
chapter 
mining temporal pattern appseq input gamma output ck candidate set algorithm candidate gen second gamma pair composite items bi gamma composite item bj bi gamma item ai ai gamma ai gamma rel bj item aj aj ai ai ai gamma ai gamma generate candidate element fbi candidate generation algorithm proof algorithm candidates generated gamma item item 
gamma item item 
ai earliest start time ai gamma latest time aj earliest start time aj time pruning sure ai ai gamma relations aj aj suppose related relations rel 
consider 
bef ore events 
equal means starting time event ai equal starting time aj time event ai gamma equal time aj ai starts aj ai gamma finishes aj 

meets implies ai aj ai gamma meets aj 
overlaps case starting time event ai starting time aj time event ai gamma time aj ai meets overlaps aj ai gamma meets overlaps starts aj 

starting time event ai time event aj time event ai gamma time chapter 
mining temporal pattern appseq event aj ai ai gamma meets overlaps starts aj 

starts event earliest start time starts aj time event ai gamma time event aj ai starts aj ai gamma meets overlaps starts aj 

starting time ai time event aj event time finishes aj ai meets overlaps aj ai gamma finishes aj 
cases generated candidate 
generating large items divide phases support counting generation large items 
general second method works manner method generate incrementally larger items combining composite patterns candidate 
difference shall item list gamma 
observe patterns formed combination quite complex natural easily understandable 
table shows items example 
see items overlaps ambiguous represent relation events 
deal restricts temporal pattern temporal relations gamma meet 
results obtain meaningful interesting temporal patterns 
example overlaps obtained 
modified appone apriori approach generating temporal pattern methods suffer high cost handling huge number candidate sets iterations especially pruning strategy applied 
deal problem try way generate generation 
tree structure storing information binary predicates proposed 
traversing tree obtain list directly data 
method runs follows 
chapter 
mining temporal pattern appseq 
scan database derives list potential candidates forming large sequences 

scan database 
sequence examine pair items form set binary predicates 
database shown table take sequence example obtain binary predicates shown 
scanning sequences obtain complete set binary predicates potential candidates forming 

construct tree depth binary predicates collected 
distinct binary predicate branch created parent node precedent event child node second event 
store temporal relation corresponding count pid start time list associated child node 
exist branch representing binary predicate increment corresponding count insert pid start time associated list 
tree formed scanning sequence database shown 
traversing tree child root obtain giving branches having counter values greater threshold 
see binary predicates generated sequence fact potential candidates forming events binary predicate frequent events 
examining corresponding support temporal relations pair events stored tree obtain list result 
iterations form lk previous methods mining temporal patterns 
difference formation candidate formed phase 
see size tree formed depends solely number binary predicates 
observe maximum size tree jl jl may greater jc 
suppose number binary predicates formed far jc generating possible cases formation expected efficient 
assumption holds repetition binary predicates high distinct binary predicates formed 
obtain modified appone modified applying technique appone respectively 
comparison study performance methods section 
chapter 
mining temporal pattern appseq afl bfl cfl fl fl fl fl fl fl fl fl fl fl overlaps fl fl fl finishes meets meets fl fl ffl bfl fl fl bfl cfl fl fl fl fl fl fl bfl fl fl forming jdj number sequences jp average number events large item ns number maximal potentially large item number event types table parameters performance study evaluate performance proposed methods large range data conducted experiments ultrasparc workstation mb main memory 
methods written consider synthetic data application domain medical database example 
person record sequence clinical records stating different diseases contracted 
experimental setup synthetic data generation program took parameters shown table 
data generation model mining sequential pattern modification model patient database :10.1.1.40.9892
formed table large items number items set ns 
generated large chapter 
mining temporal pattern appseq temporal relations frequency distribution temporal relations events item picking number events poisson distribution mean equal jp chose event types randomly 
picked temporal relation events formed pattern 
temporal relations chosen set rel 
generated patterns contain temporal relations distribution shown 
values represent starts overlaps bef ore meets equal respectively 
distribution determined arbitrarily intuitive expectation relations 
person assigned potentially large item chosen table items 
time interval event followed exponential distribution mean equal 
item time event took place chosen randomly time interval time units 
events item followed temporal relation held events 
temporal relation bef ore time events separated followed exponential distribution mean equal 
relation overlaps time interval events overlaps restricted exponential distribution mean equal 
relation time event delays exponential distribution mean equal 
generated dataset setting ns jdj jp mb data 
studied effect different values min sup win size number sequences events sequence methods 
experimental results studied effect minimum support processing time 
values minimum support min sup shown time units chapter 
mining temporal pattern appseq window size win size test 
shows decrease execution time minimum support increases patterns 
support threshold increases large items generated size candidate set iteration decreases dramatically 
execution time decrease time required support counting hash tree searching large items 
comparing methods appone needs time appone 
due large amount computation time pruning candidates addition atomic patterns considered 
observe modified appone modified help little mining process especially large support threshold 
generate forming early stage process 
iterations high cost candidate generation dominate mining process especially small support threshold iterations involved 
minimum support time sec modified appone appone minimum support time sec modified pattern pattern variation minimum support shows execution time pass finding patterns 
set min sup temporal pattern min sup temporal pattern 
appone fifth pass onwards time needed 
large items formed passes support counting lk dominates execution time 
iterations size item list shrinks support counting process faster 
behave appone 
ran fewer passes took time candidate pruning support counting phase large generated 
modified appone little time second pass form 
iterative apriori approach passes execution time passes chapter 
mining temporal pattern appseq appone 
number large items generated pass shown 
set min sup appone min sup 
number large items generated appone greater compare length patterns 
jl appone compared jl 
pass number time sec modified pass number time sec modified pattern pattern execution time pass pass number number sequences pass number number sequences pattern pattern number large items generated pass studied effect window size processing time 
chose values min sup appone modified appone modified 
see window size increases execution time increases patterns 
sequences included time support counting phase increases 
number iterations increases requires longer execution time 
chapter 
mining temporal pattern appseq 
max 
seq 
min sup resulting seq 
length number patterns 
max 
seq 
min sup resulting seq 
length number patterns table number appseq different min sup modified appone modified better original methods time generating reduced 
window size time sec modified window size time sec modified pattern pattern variation window size table shows number appseq obtained various values min sup win size set time units 
patterns number patterns decreases rapidly min sup increases 
number pattern far pattern 
may due complex structure pattern number patterns formed 
scale experiment target consider scale effects 
examined performance varies number sequences 
shows methods scale number sequences increased fold ranging min sup patterns 
execution time appone chapter 
mining temporal pattern appseq increase increasing number sequences 
regarding modified appone modified large number generated approach generating data improves performance greatly 
number time sec modified number time sec modified pattern pattern scale number sequences studied scale increase average number events sequence 
number sequences kept constant 
vary average number events sequence 
shows scalability results methods 
set min sup methods 
execution time increases rapidly increasing number events sequence 
average number events item increases items longer patterns formed 
large items formed results candidates generated iteration 
increases computation time hash tree searching support counting dramatically 
items longer pattern formed results greater number iterations execution time lengthened 
modified appone modified outperform appone respectively 
medical data real life data experiment data set contains clinical records patients patients suffer spinal deformation 
patient may curves spine 
curves severe deformations identified major curves 
experiment aim find frequent temporal patterns temporal pattern data set corresponding common features cover 
database stores patients chapter 
mining temporal pattern appseq number events sequence time sec modified number events sequence time sec modified pattern pattern scale number events sequence record stores person id date birth family history class contracted treatment 
stores measurements patients number curves curve locations degree curvature direction curve numerical data temporal nature age height weight degree curvature 
categorical non temporal data 
pay special attention spine curvature values reflect level spine deformation 
consecutive records visit sequence curvature values captured patient 
examining changes values view sequence may discover temporal knowledge stored database 
start eliminating missing data database angle measured spine crucial diagnosis 
extract useful essential attributes finding frequent sequence 
partition curvature degrees different interval values find common pattern way mining quantitative data 
patient obtain curvature values different parts spine visit 
map curvature values event model simple concatenation 
example patient spine curve degrees different directions location 
match corresponding numerical values different intervals say interval take degree interval range 
represent data event model 
intuition spine characterized combining degrees curve direction location 
regard curvature values feature spine 
represent data single event 
obviously form tremendous chapter 
mining temporal pattern appseq different types events depending segment interval values curvature degrees 
keep person id distinguish sequences 
transform number visit ordering time start time time number visit actual visit date simplicity 
consecutive visits change curvature values merge records setting time visit 
obtain sequence points interval events take event representing different spine deformation appone find interesting temporal pattern database 
view treatment process patient set win size largest number visit stored database 
table presents statistics finding large temporal pattern database various min sup 
look sequence visits involved database patients visits 
talk min sup suppose focus potential sequences stored 
number large items decreases rapidly min sup increases 
values curvature degrees diverse distribution sparse common sequence short length terminated 
practical point view expect find complex temporal relation difficult interpreted 
results obtained depends way partitioning curvature values intervals wide range values may grouped category 
look changes spine deformation classify similar spines distinguishing special ones 
expert knowledge indication curvature values may help partition better results obtained 
common sequences attributes type treatment family history stored database investigation 
results follows isis conf sup read patient spine deforms category changes second part spine determined having 
results may lead interesting findings data 
summary chapter propose methods discovering interesting temporal patterns appseq 
consider special type temporal pattern simple chapter 
mining temporal pattern appseq min sup 
sequences iterations total time table mining appseq database meaningful 
show iterative method flavor apriori gen function mining 
item list format perform fast simple composition temporal patterns candidate generation support counting 
set experiments conducted demonstrate performance methods 
comparison consider mining slightly complex type temporal pattern modification original temporal pattern 
experiments find computation time required pattern acceptable 
hand approach generating help cases compositions item lists needed 
approach especially favors case large support threshold held 
real set data containing clinical records patients 
interested finding temporal pattern data 
appone mining purpose obtain experimental results may need examination expert knowledge interpretation 
mining method propose apriori approach forming large number ck intermediate steps 
investigate data structure algorithms help reduce high cost candidate generation mining process 
chapter mining temporal pattern ii linkseq introduce second temporal pattern known linkseq chapter 
give notion temporal representation linkseq section 
methods mining temporal patterns section different data structures facilitate efficient support counting process 
experimental results showing performance methods section 
summary section 
problem statement discussed previously chapter form pattern linking binary predicates common event binding point 
composition results form rel rel delta delta delta ak gamma gamma ak 
extract temporal knowledge events pair investigate relations events binary predicates sequence 
formation pattern linkseq defined follows definition temporal pattern linkseq temporal pattern defined recursively follows ffl temporal pattern size form rel binary predicate linkseq ffl linkseq binary predicate common event type ak gamma rel rel delta delta delta ak gamma gamma ak gamma ak gamma gamma ak linkseq chapter 
mining temporal pattern ii linkseq size temporal pattern number distinct events pattern 
definition temporal pattern overlaps linkseq formed sequence size equals 
focus temporal relations pair events adding binary predicate time 
idea window size support defined previous section applicable little modification follows 
definition window size window size temporal pattern holds sequence ak te gamma ts win size event temporal pattern ak event 
definition item ai bag event types reli rel item form rel rel delta delta delta ak gamma gamma ak event sequence support item temporal pattern holds event sequence 
support temporal pattern set sequences defined total number occurrence patterns total number sequences support holds sjs support item support temporal pattern item 
large item item having support greater threshold min sup provided users support min sup 
method mining linkseq linkseq looks similar appseq sequence 
obtain patterns emphasizing different temporal structure formed events 
observe may find linkseq deriving appseq mechanism 

obtain lk appseq frequent events involved 

lk derive corresponding linkseq examining pairs events pattern 
looking list previously follow order events link sequence 
chapter 
mining temporal pattern ii linkseq intuition frequent events form appseq form large items process 
formation appseq order events preserved form linkseq 
point note appseq excludes case event embedded pattern time preceding events 
words shorter sequence formed 
despite derive linkseq easily appseq 
approach forms linkseq appseq denote method 
section show results find linkseq appseq 
second method mining linkseq way tackle mining problem modify appone introduced section previous chapter accommodate needs second pattern 
formation linkseq suggests mapping start time time composite pattern needed 
obtain linkseq linking binary predicates common event binding point keeping orders binary predicates sequence 
come method links events time 
works similarly appone candidate generation phase formation large items 
candidate generation formation process 
previous chapter form approach developed modified appone choose approach generating linkseq 
start generate ck examine lk gamma compositions elements item list lk gamma 
prune irrelevant candidates examining common event lk gamma say aj aj aj common event 
added items combined linkseq say bi bi lk gamma common event aj event pattern 
example consider item shown table find large items include combination candidates 
generating large items general works manner appone generate incrementally larger items combining patterns lk gamma candidate 
formation large items simple appone 
support counting phase shall chapter 
mining temporal pattern ii linkseq item list lk gamma examine pid attribute ensure events associated person sequence 
second sub phase form large items union start time time patterns needed simply link binary predicates 
investigation temporal relations performed 
alternative method mining linkseq methods apriori approach divides mining process candidate generation phase support counting phase 
facilitate checking pid candidate 
see linkseq examination start time time required 
argue relative order events provides sufficient information mining linkseq start time time appseq 
transform database item list may keep order events properly 
item list mining process inspired idea frequent pattern tree fp tree short suggested mining frequent patterns propose tree structure store sequence data seq tree :10.1.1.40.6757
chapter introduced structure fp tree key idea mining algorithm 
fp tree suggested avoids generating huge set candidates keeping useful information storing compact data structure 
scanning original database needed mining process 
experimental results show fp tree mining frequent pattern outperforms previous apriori method 
motivates investigate tree structure captures essential information mining process 
linkseq focus relative order binary predicates basically depends start time time event propose seq tree store relative order binary predicates reduce high cost support counting large candidate set 
alternative method mining temporal pattern denote 
sequence tree design design structure seq tree observations 
relative order events crucial information determining temporal patterns 
time start time determine order nodes chapter 
mining temporal pattern ii linkseq bfl bfl bfl ofl bfl bfl cfl seq tree constructed sequence placed paths tree 
consider event parent node event child node binary predicate 
secondly number occurrences binary predicate recorded count counts number sequences include binary predicate 
count kept seq tree traversing tree obtain list frequent binary predicates sequence examining counter values 
scanning database needed 
thirdly frequent events appear sequence frequent events placed path root node tree 
ensures correctness frequent patterns events path comes sequence contains sequence binary predicates 
generation candidates scanning database support counting required costly mining temporal pattern 
addition problem deals complex temporal structure complex structure seq tree required capture essential information form linkseq 
consider sequence shown 
glance obtain longest temporal pattern overlaps 
store pattern main branch main bh seq tree 
patterns interesting 
store patterns subsidiary branch sub bh 
resultant seq tree shown 
fact main bh sub bh structure 
store binary predicates 
divide set binary predicates groups construction seq tree described 
introduce terminologies discussion 
definition main branch main branches main bh short defined sequence binary predicates forms longest temporal pattern 
definition subsidiary branch subsidiary branches sub bh defined set binary predicates shows temporal relations events chapter 
mining temporal pattern ii linkseq main bh overlaps overlaps bh fl main bh overlaps overlaps bh overlaps fl cfl bfl afl tfl cfl bfl afl tfl identical pattern main bh sub bh sequence stored main branch 
branch edge nodes seq tree 
main branches form skeleton tree subsidiary branches store temporal relations events useful mining complex structure temporal pattern 
main branches basically reveal temporal behavior events sequence 
may find discrepancies sequences having form main bh 
instance obtain sequences different sub bh overlaps give main bh overlaps overlaps suggests different temporal patterns 
say sequences identical temporal pattern share main bh sub bh 
definition path path exists nodes branch coming node directly sequence branches starting node intermediate nodes link target node 
length path number branches visited 
finding paths main bh sub bh seq tree obtain set temporal patterns 
instance seq tree shown path ha gamma gamma di obtain corresponding pattern 
path corresponds pattern obtain sequence 
seq tree need ensure valid path corresponds temporal pattern 
consider example shown sequences common partial main bh overlaps merge path 
come invalid path obtained tree ha overlaps gamma overlaps gamma di 
need exclude case splitting node shown 
distinguish paths showing clearly overlaps overlaps chapter 
mining temporal pattern ii linkseq 
realize sequences having identical patterns share paths seq tree 
main bh overlaps overlaps overlaps bh fl main bh overlaps overlaps bh overlaps fl cfl bfl afl tfl dfl ambiguity overlaps overlaps exist 
bfl ofl fl ofl fl ofl dfl efl ofl bfl cfl bfl afl tfl efl overlaps flor overlaps fl bfl ofl fl ofl ofl ofl cfl dfl cfl efl afl splitting node splitting node splitting node different sub bh observations tree structure seq tree proposed considerations 

included tree nodes potential large patterns kept 

tree nodes path arranged order events happened corresponding sequence 
start time events 
preserved relative order events important information mining process 

branch nodes stores primitive temporal relation events binary predicate 
associated temporal relation count store occurrences binary predicate 

sequence corresponding path tree constructed 
sequences share identical temporal pattern merge path 

similarly case sequences share common prefix pattern shared parts merged prefix structure 
encode temporal pattern compact form information stored seq tree mining process 
introduce design construction seq tree 
consider example database shown table illustration 
suppose minimum support window size set time units 
chapter 
mining temporal pattern ii linkseq item count table large items construction seq tree scan database derive list large items shown table 
transform database sequences group events belonged person sequence large items included 
sequence find possible binary predicates formed exist sequence divide groups 
sequence consists kinds branches main bh sub bh construction seq tree mainly main bh 
generate binary predicates main bh considering consecutive large item pair 
sort records time events ensure previous event stops late 
words longest pattern formed linking consecutive large item sequence main bh 
considering temporal relations events form set binary predicates sub bh 
binary predicates formed sequence listed shown table 
secondly table binary predicates obtained construct seq tree 
start creating root labeled null 
look transformed database sequence construct path tree main bh ha overlaps gamma gamma gamma finishes gamma meets gamma bi 
note event type stored nodes event taken parent node event child node 
branch stores temporal relation corresponding count pair nodes indicated 
notice starting third node onwards path obtain sub bh node preceding nodes 
looking table binary predicates add corresponding sub bh nodes shown chapter 
mining temporal pattern ii linkseq person id sequence form main bh sub bh main bh sub bh main bh sub bh nil main bh sub bh main bh sub bh main bh sub bh table transform database sequence form chapter 
mining temporal pattern ii linkseq small dotted lines 
second sequence main bh shares common prefix ha overlaps gamma gamma ci existing path tree corresponding sub bh gamma count branch prefix incremented reaching node new branch created starting node hc meets gamma finishes gamma gamma gi 
observe nodes second sequence excluding node sequence different temporal relations main bh lead new branches 
regarding third sequence sequence shares common node new branch starts gamma binary predicate sequence sub bh added 
scan fourth sequence leads construction second branch tree gamma gamma add corresponding sub bh 
fifth sequence observed shares common main bh gamma gamma different sub bh meets gamma existing path 
new branch added merging sequences 
sequence event types corresponding relations main bh sub bh identical sequence excluding event prefix path shared count relation path incremented 
facilitate tree traversal look table built event points occurrence tree head node link 
nodes event type linked node links shown dotted arrows 
scanning sequences tree associated node links shown 
example leads definition sequence tree 
definition seq tree sequence tree seq tree tree structure defined 

consists root labeled null set event prefix subtrees children root look table 

node event prefix subtree consists event type node link list branches event type registers event node represents node link links node seq tree event type null 
list branches link current node nodes path 
branch stores temporal relations connected nodes corresponding count registers number chapter 
mining temporal pattern ii linkseq bfl afl bfl cfl dfl cfl bfl afl efl dfl afl dfl efl efl ffl ofl fl bfl fl bfl fl dfl fl ffl fl bfl dfl dfl bfl bfl fl bfl fl bfl bfl fl bfl fl bfl fl bfl main ffl dfl fl dfl bfl bfl bfl bfl bfl bfl bfl ffl lfl fl look sfl seq tree constructed example occurrences binary predicate represented connected node associated temporal relation 

entry look table consists fields event type head node link points node seq tree carrying event type 
definition obtain algorithm seq tree construction follows 
scan database twice 
pass determines set large items form large items mining process 
scan transform original database sequence form sorted order time start time events 
find binary predicates group categories main bh sub bh 
build corresponding seq tree data structure defined 
construction algorithm shown 
construction process mainly divided steps large items pass determines large item frequent temporal patterns formed set large items 
chapter 
mining temporal pattern ii linkseq input temporal database minimum support min sup output sequence tree seq tree algorithm seq tree construction large tuples containing items min sup sequence sk gen main branch sk considering consecutive large item pair gen branch sk examining temporal relations events create root seq tree labeled null sequence sk node main bh build main branch sk add branch sk add node link nodes event type construction sequence tree seq tree generate sequence form pass group records sequences different persons 
form main bh examining temporal relations consecutive events sequence 
find temporal relations events sub bh 
main bh sub bh sequences example summarized table 
build main branch main bh sub bh collect essential information construct corresponding seq tree 
main bh add branches tree 
insert nodes root examine common prefix including identical sub bh create new node branch links new nodes corresponding relations binary predicate 
sequence shares main bh sub bh stored seq tree simply increment corresponding relation counts 
algorithm building main branches summarized 
add subsidiary branch sequence building tree main bh need sub bh store temporal relations pair events sequence 
add main bh sub bh node 
adding main bh node add corresponding sub bh looking table storing binary predicates 
notice sub bh chapter 
mining temporal pattern ii linkseq input sequence sk root seq tree output seq tree added path corresponding sequence sk algorithm build main branch sk pair rel rel binary predicate main bh sk child event child event rel rel increment rel count create new node event rel rel add branch create new node event create new node event rel rel add branch branch building main branch exists third nodes onwards main bh preceding nodes 
add sub bh nodes shown dotted lines 
case sequences having main bh different sub bh splitting nodes needed 
algorithm adding subsidiary branches shown 
lemma sequence database user defined minimum support min sup corresponding seq tree contains complete information mining linkseq 
proof observe construction process sequence database mapped path seq tree 
order events preserved insert new sequence root follow order stored main bh 
sequence temporal relations binary predicates stored seq tree main bh sub bh 
possible temporal relations events sequence stored 
associated support count records number sequences shares set temporal pattern 
seq tree contains complete information database relevance mining linkseq 
lemma considering root height seq tree bounded chapter 
mining temporal pattern ii linkseq input sequence sk root seq tree output seq tree added subsidiary branches sequence sk algorithm add subsidiary branches sk pair rel rel binary predicate sub bh sk child event corresponding main bh node event sub event exist new sub bh added sub event sub rel rel add branch sub bh sub rel rel sub bh existing branch increment sub rel count main bh different sub bh create new node create new path separate different branches adjust corresponding counters mark node splitting node having main bh different sub bh adding subsidiary branches chapter 
mining temporal pattern ii linkseq longest temporal pattern sequences database size tree bounded number sequences 
proof see maximum number nodes path determined maximum number events obtained corresponding sequence 
height tree bounded longest temporal pattern sequence database 
regarding size seq tree see complex structure main bh sub bh case sequence having main bh different sub bh splitting nodes needed 
size tree quite large 
chances having main bh different sub bh high expect sequences share path tree size tree smaller original database 
number main bh seq tree number distinct frequent sequences database 
size seq tree bounded number sequences height bounded longest pattern 
fact longest pattern obtained determined window size specified users 
height seq tree bounded 
paths tree constructed main bh window size refers time interval binary predicate binary predicate formed main bh 
binary predicates subsequence sub bh excluded longest pattern formed main bh exceeds limit 
leads different mining results compare performance previous methods 
sections assume window size set maximum value includes binary predicates sequences 
mining linkseq seq tree section study explore information stored seq tree mining complete set frequent temporal patterns 
observe interesting properties seq tree structure facilitates mining process 
property large item ai possible temporal pattern contains ai obtained ai node links starting ai look table 
property directly construction process seq tree nodes event type linked node links 
facilitates extraction valid path traversing seq tree ai node links 
chapter 
mining temporal pattern ii linkseq property node branch connecting nodes 
sequence main bh stores temporal relations preserved order events 
temporal relations unique consecutive events sequence 
branches exist nodes main bh 
similarly temporal relations kept unique events sub bh sequence 
hand construction process identical pattern shares path tree 
discrepancy sub bh sequences having main bh lead splitting nodes 
different branches connect nodes 
words valid path node node obtain specific temporal pattern 
property calculate frequent temporal patterns node ai path prefix sub path node ai path need accumulated support count relation prefix path carry count branch connected ai 
nodes path event types delta delta delta order root prefix sub tree leaf subtree path ai node referenced 
construction process prefix node ak branches occur ak exactly ai rel count times 
prefix node carry count branch connected ai 
postfix node am path occurs node ai 
patterns am generated examination postfix node am enclosing lead redundant generation patterns generated am 
need examine prefix sub path ai path 
constructed seq tree outline mining method 
generating large number candidates explore information stored seq tree follows 
construction seq tree nodes path belong sequence pair having parent node child node showing order 
ordering information kept induced pairs nodes path 
seq tree example start event look table event type order event look table arbitrarily assigned 
note mining process performed independently ai starting look table prefix sub path node ai included chapter 
mining temporal pattern ii linkseq mining ai 
paths tree ignored 
simplicity start node paths leading node paths fha overlaps gamma gamma meets gamma finishes gamma gamma gi hd gamma gamma gi hd gamma gamma gi different sub bhg examining counter values branches connecting node lk containing consider intermediate nodes connecting node main bh sub bh 
consider binary predicates having support count 
path containing node find main bh sub bh obtain 
support 
paths support 

look path connecting node length reaching nodes path 
time start intermediate nodes included previously traversing main bh paths 
find path having length greater support count search node terminates 
node event type focus prefix selected path avoid repetition patterns generated 
considering path reaches node obtain prefix paths fha overlaps gamma gamma gamma finishes gamma ha overlaps gamma gamma meets gamma finishes gamma ig 
considering binary predicates main bh sub bh finishes 
search path having length starting previously finishes overlaps finishes finishes 
proceed find finding path having length overlaps overlaps finishes finishes finishes 
longest pattern overlaps finishes 
find path length longer search large sequence associated terminates 
consider nodes event type derive prefix paths fha overlaps gamma gamma gamma ei ha overlaps gamma gamma meets gamma eig 
similarly finding binary predicates obtain 
overlaps chapter 
mining temporal pattern ii linkseq node linkseq finishes finishes overlaps finishes finishes overlaps overlaps finishes finishes finishes overlaps finishes overlaps overlaps overlaps overlaps table mining linkseq traversing seq tree 
longest pattern gives overlaps terminates search 
nodes event type find path length ha starts gamma di 
support 
lk search node terminates 
nodes event type mining mechanism finding path seq tree lk 
linkseq generated node summarized table 
mining process mainly focuses discovery valid path starting event look table preceding nodes path seq tree different path lengths 
valid paths support count obtained generation temporal patterns 
algorithm mining temporal pattern seq tree shown 
summarized chapter 
mining temporal pattern ii linkseq steps look table start event look table 
order events look table arbitrarily assigned 
find corresponding pattern associate event separately order events start mining process independent results obtained 
path extraction determining associated event temporal pattern extract path seq tree leads associated event support counting 
prefix path considered 
valid path finding valid path links associated event preceding nodes gamma length generate potential item 
examination counter values having support count large item result 
pattern generation item obtained generate corresponding temporal pattern linkseq easily item corresponds temporal pattern 
search valid paths leading node ai prefix path start neighboring nodes length path form 
form starting corresponding nodes previously say bi 
find neighboring nodes bi form path length 
intuition nodes connecting bi ai 
obvious find valid path neighboring node say ci reaching bi intermediate node reach ai branch previous 
mining process performed recursively prefix paths generate lk 
lemma algorithm finds potentially large items traversing tree examining valid paths 
proof lemma certain binary predicates sequences kept tree 
find binary predicates events sequences ordered events preserved paths tree possible temporal pattern sequence finding valid path linking nodes 
identical pattern shares path events stored path belong sequence 
property possible temporal pattern chapter 
mining temporal pattern ii linkseq input seq tree minimum support min sup output set frequent temporal patterns algorithm mining frequent temporal patterns seq tree branch return valid paths generated branch node branch rel count min sup node event type ei look table extract prefix paths associates ei exist path node event type ei preceding nodes length rel count min sup generate corresponding lk mining frequent temporal pattern seq tree including associated events 
scanning events look table traversing tree generate large items 
lemma large item formed algorithm represents frequent temporal pattern 
proof property ensure path starting node lead deterministic node 
path represents non exist temporal pattern sequence 
words path corresponds temporal pattern 
examining counter values generate large item represents specific frequent temporal pattern 
properties lemmas show algorithm correctly finds complete set frequent temporal patterns linkseq 
candidates generated process obtain lk traversing tree independently ai look table 
frequent event ai extracted set prefix paths extracted 
mining process performed recursively prefix paths generate lk 
seq tree usually smaller size database mining process takes storage previous methods chapter 
mining temporal pattern ii linkseq linkseq large number candidates formed 
performance study set synthetic data introduced previous chapter 
compare performance methods including modified 
modified basically generates approach developed chapter methods described previous sections 
note forms previous chapter approach helps improving mining process 
start studying effect minimum support min sup processing time 
values min sup shown 
window size win size set time units test 
shows execution times methods decrease minimum support increases 
large items formed support threshold increases size candidate set iteration methods modified decreases dramatically 
time required support counting 
hand lk formed process time searching valid path decreases greater support threshold 
observe outperforms methods especially small support threshold 
slight increase execution time 
generation candidates needed avoid high cost support counting phase large number candidates generated process 
comparing methods works better 
modified generate appseq iteration get linkseq 
computation time needed search corresponding binary predicates addition find lk 
table shows number linkseq obtained different values min sup 
number sequences decreases increasing value min sup 
study scale effects examine performance variates number sequences 
number sequences increased fold ranging 
set min sup methods 
shows scalability results 
grows rapidly comparing methods 
modified scales linearly manner 
large items formed passes mining process chapter 
mining temporal pattern ii linkseq minimum support time sec modified variation minimum support min sup 
resulting sequences max 
sequence length table number linkseq obtained different min sup chapter 
mining temporal pattern ii linkseq number sequences time sec modified scale number sequences approach generating help generating linkseq modified 
hand scales better methods 
number sequences grows difference methods larger larger 
shows advantage eliminating generation large number candidates process 
studied scale increase average number events sequence 
number sequences kept constant 
vary average number events sequence set min sup methods 
shows methods scale number events sequence increased 
case increasing number sequences execution time grows dramatically increasing number events sequence modified scales linearly manner 
tremendous number formed increasing number events sequences suffers high cost passes 
modified uses approach avoid problem 
regarding number events sequence increases execution time increases rapidly modified 
may due fact longer sequences formed longer paths tree obtained 
longer execution time searching valid paths generating lk required 
chapter 
mining temporal pattern ii linkseq number events sequence time sec modified scale number events sequence discussions see sequence tree structure facilitates efficient support counting large items 
linkseq general simple nature relative order events concerned 
information maintained seq tree formed insert nodes root 
suggest apply similar mechanism mining appseq 
look formation appseq linkseq appseq complex structure requires mapping start time time composite patterns mining process 
involves storage pid list pid start time composite item represented node 
example composite item overlaps time associated node result memory needed store pid list processing time needed looking corresponding temporal relations composite pattern atomic pattern path 
overhead increasing processing time mining favourable employ tree structure mining appseq 
summary chapter propose methods discovering second temporal pattern linkseq 
linkseq comparatively simpler structure appseq examination start time time neglected 
orderings binary predicates essential mining process 
tree structure mining algorithm proposed 
suggest extract chapter 
mining temporal pattern ii linkseq linkseq appseq modifying previous method appone obtain second method 
compare performance methods set experiments 
suitable mining minimum support threshold reduces 
chapter previous studies temporal data mining mining sequence data proposed studied methods mining temporal patterns interval events 
extend current accommodate temporal interval data long overlooked past 
discovery temporal pattern involving interval data useful number complex data analysis scenarios 
serial parallel ordering events inter relations overlaps enriches expressive power temporal patterns 
interesting relationships events give insight causal relationships 
interesting patterns appseq linkseq suggested describe complex relations events 
patterns simple useful capture temporal behavior events 
developed methods discovering interesting patterns set experiments compare performance methods 
regarding appseq comparison consider mining slightly complex temporal pattern variate original pattern 
apriori approach iterative method mining patterns 
propose item list format store temporal data facilitate fast computation support counting phase 
experiments find computation time required original pattern acceptable 
hand approach generating binary predicates generating candidates tree structure proved useful improving efficiency 
investigate data structures algorithms facilitate efficient mining process 
chapter 
temporal pattern linkseq forms similar way previous pattern appseq comparatively simpler structure 
iterative method item list suggested 
tree structure mining algorithm proposed finding linkseq 
stores crucial information compact way tree scanning database required find frequent pattern 
generating candidates obtain complete set temporal patterns traversing tree 
approach shown efficient mining linkseq 
fact tremendous way express temporal relations interval data 
discover number temporal patterns prohibitively large patterns may complicated little value users 
restrict interest types temporal patterns simple meaningful 
far considered discovery frequent large temporal patterns 
may consider generation association rules form reli temporal patterns 
meaning rule temporal relation reli support frequent patterns form reli percentage support pattern reli sufficiently high 
give indication causal relationship temporal patterns events studied 
contrary case time points ordering events measure finding interesting pattern may take length time interval interacts events measure temporal relations 
instance overlaps overlapping interval lasts time units 
read event overlaps event time units event ends 
accurate information extracted study approach consideration time intervals event lasts 
hand far mainly approaches discovery patterns 
apriori approach item list facilitate efficient support counting process 
tree structure mining linkseq 
fact data structure frequent item matrix proposed find sequential pattern may help mining problem 
investigate approach 
bibliography agrawal faloutsos swami 
efficient similarity search sequence database 
proceedings th international conference foundations data organization algorithms pages october 
agrawal gehrke gunopulos raghavan 
automatic subspace clustering high dimensional data data mining applications 
proceedings acm sigmod international conference management data pages june 
agrawal ghosh imielinski iyer swami 
interval classifier database mining applications 
proceedings th international conference large data bases pages august 
agrawal imielinski swami 
mining association rules sets items large databases 
proceedings acm sigmod international conference management data pages may 
agrawal lin sawhney shim 
fast similarity search presence noise scaling translation time series databases 
proceedings st international conference large databases pages september 
agrawal psaila wimmers 
querying shapes histories 
proceedings st international conference large databases pages september 
agrawal srikant :10.1.1.40.6757
fast algorithms mining association rules 
proceedings th international conference large database pages september 
agrawal srikant :10.1.1.40.9892
mining sequential patterns 
proceedings th international conference data engineering pages march 
bibliography allen 
maintaining knowledge temporal intervals 
communications acm 
kanamori 
implementing time interval class managing temporal data 
proceedings th international workshop database expert systems applications pages august 
berger tuzhilin 
discovering unexpected patterns temporal data temporal logic 
temporal databases research practice pages 
bettini wang jajodia 
temporal semantic assumptions databases 
ieee transactions knowledge data engineering 
bettini wang jajodia lin 
discovering frequent event patterns multiple granularities time sequences 
ieee transactions knowledge data engineering 
chakrabarti sarawagi dom :10.1.1.34.184
mining surprising patterns temporal description length 
proceedings th international conference large databases pages august 
chandra segev stonebraker 
implementing calendars temporal rules generation databases 
proceedings th international conference data engineering pages february 
chen 
architecture temporal data mining 
iee colloquium knowledge discovery data mining pages may 
chen 
language support temporal data mining 
proceedings nd european symposium principles data mining knowledge discovery pages september 
chen 
mining temporal features association rules 
proceedings rd european conference principles practice knowledge discovery databases pages september 
chen 
discovering temporal association rules temporal databases 
international workshop issues applications database pages july 
bibliography das gunopulos mannila 
finding similar time series 
proceedings st european symposium principles data mining knowledge discovery june 
das lin mannila smyth 
rule discovery time series 
proceedings nd european symposium principles data mining knowledge discovery pages september 
elmasri wuu 
time index monotonic tree 
temporal databases theory design implementation chapter 
elmasri wuu kim 
time index access structure temporal data 
proceedings th international conference large data bases pages august 
ester kriegel sander 
density algorithm discovering clusters large spatial databases 
proceedings nd international conference knowledge discovery data mining pages august 
faloutsos ranganathan manolopoulos 
fast subsequence matching time series databases 
proceedings acm sigmod internation conference management data june 
fayyad haussler 
mining scientific data 
communications acm 
fayyad piatetsky shapiro smyth uthurusamy 
advances knowledge discovery data mining 
aaai press mit press 
schneider 
data model data structures moving objects databases 
proceedings acm sigmod international conference management data may 
friedman geiger goldszmidt 
bayesian network classifiers 
machine learning 
galton 
temporal logics applications 
london academic press 
bibliography garofalakis rastogi shim 
spirit sequential pattern mining regular expression constraints 
proceedings th international conference large database pages september 
guha rastogi shim 
cure efficient clustering algorithm large databases 
proceedings acm sigmod internation conference management data pages june 
srivastava 
event detection time series data 
proceedings th acm sigkdd international conference knowledge discovery data mining pages august 
srivastava 
pattern directed mining sequence data 
proceedings nd international conference knowledge discovery data mining pages 
han dong yin 
efficient mining partial periodic patterns time series database 
proceedings th international conference data engineering pages march 
han pei asl chen dayal hsu 
freespan frequent pattern projected sequential pattern mining 
proceedings th acm sigkdd international conference knowledge discovery data mining august 
han pei yin 
mining frequent patterns candidate generation 
proceedings sigmod internation conference management data pages may 
kersten mannila toivonen 
perspective databases data mining 
proceedings st international conference discovery data mining pages august 
jensen consensus glossary temporal concepts february version 
temporal databases research practice lecture notes computer science pages 
jensen snodgrass 
temporal data management 
ieee transactions knowledge data engineering 
bibliography bayardo jr agrawal 
mining interesting rules 
proceedings th acm sigkdd international conference knowledge discovery data mining pages august 
keim kriegel seidl 
supporting data mining large databases visual feedback queries 
proceedings th international conference data engineering pages 
klemettinen mannila ronkainen toivonen verkamo 
finding interesting rules large sets discovered association rules 
proceedings rd international conference information knowledge management pages november december 
kline 
update temporal database bibliography 
sigmod record 
koperski han 
efficient step method classification spatial data 
proceedings international symposium spatial data handling july 
korn kotidis faloutsos 
ratio rules new paradigm fast quantifiable data mining 
th international conference large databases pages august 
rousseeuw kaufman 
finding groups data cluster analysis 
john wiley sons 
mcdonald forster 
representation collections temporal intervals 
proceedings th national conference artificial intelligence pages august 
mannila 
data mining machine learning statistics databases 
proceedings th international conference scientific statistical database management pages june 
mannila toivonen :10.1.1.42.5048
discovering generalized episodes minimal occurrences 
proceedings nd international conference knowledge discovery data mining pages august 
mannila toivonen verkamo 
discovering frequent episodes sequences 
proceedings st international conference discovery data mining pages august 
bibliography mckenzie 
bibliography temporal databases 
sigmod record 
montanari pernici 
temporal reasoning 
temporal databases theory design implementation pages 
ng han 
efficient effective clustering methods spatial data mining 
proceedings th international conference large database pages september 
ramaswamy silberschatz 
cyclic association rules 
proceedings th international conference data engineering pages february 
padmanabhan tuzhilin :10.1.1.28.536
pattern discovery temporal databases temporal logic approach 
proceedings nd international conference knowledge discovery data mining pages august 
park chen yu 
effective hash algorithm mining association rules 
proceedings acm sigmod internation conference management data pages june 
pei han asl zhu 
mining access patterns efficiently web logs 
proceedings pacific asia conference knowledge discovery data mining april 
piatetsky shapiro frawley 
knowledge discovery databases 
aaai press mit press 
quinlan 
induction decision trees 
machine learning 
swami agrawal imielinski 
database mining performance perspective 
ieee transactions knowledge data engineering 

accommodating temporal semantics data mining knowledge discovery 
phd thesis computer information science university south australia november 
roddick 
attribute oriented induction rules temporal interval data 
proceedings th international database workshop pages july 
bibliography roddick 
adding temporal semantics association rules 
proceedings rd european conference principles practice knowledge discovery databases pages september 
ramaswamy mahajan silberschatz 
discovery interesting patterns association rules 
proceedings th international conference large databases pages august 
roddick spiliopoulou 
bibliography temporal spatial spatio temporal data mining research 
proceedings th acm sigkdd international conference knowledge discovery data mining pages august 
john roddick spiliopoulou 
temporal data mining survey issues 
ieee transactions knowledge data engineering 
salzberg 
comparison access methods time evolving data 
acm computing surveys 

knowledge discovery temporal databases 
proceedings iee colloquium knowledge discovery databases pages february 
selfridge srivastava wilson 
idea interactive data exploration analysis 
proceedings acm sigmod international conference management data pages june 
shenoy sudarshan bawa shah 
turbo charging vertical mining large 
proceedings acm sigmod international conference management data pages may 
snodgrass 
tsql temporal query language 
kluwer academic publishers 
spiliopoulou 
wum tool www utilization analysis 
proceedings international workshop web databases webdb march 
bibliography srikant agrawal 
mining quantitative association rules large relational tables 
proceedings acm sigmod international conference management data pages june 
srikant agrawal 
mining sequential patterns generalizations performance improvements 
proceedings th international conference extending database technology pages march 
stam snodgrass 
bibliography temporal databases 
data engineering 
tansel 
temporal relational data model 
ieee transactions knowledge data engineering 
tansel clifford gadia jajodia segev snodgrass 
temporal databases theory design implementation 
benjamin cummings 
tansel tin 
expressive power temporal relational query languages 
ieee transactions knowledge data engineering 
toman 
point vs interval query languages temporal databases 
proceedings th acm sigact sigmod sigart symposium principles database sys tems pages june 
tuzhilin clifford 
temporal relational algebra basis temporal relational completeness 
proceedings th international conference large data bases pages august 
weiss hirsh 
learning predict rare events event sequences 
proceedings th international conference knowledge discovery data mining pages august 
wu jajodia wang 
temporal database bibliography update 
temporal databases research practice lecture notes computer science pages 
ye keane 
mining association rules temporal databases 
ieee international conference systems man cybernetics pages oct 
bibliography zaki 
efficient enumeration 
proceedings th international conference information knowledge management pages november 
zaki lesh ogihara 
sequence mining plan failures 
proceedings th international conference knowledge discovery data mining pages august 
zaki parthasarathy ogihara li 
new algorithms fast discovery rules 
proceedings rd international conference knowledge discovery data mining pages august 
zhang ramakrishnan livny 
birch efficient data clustering method large databases 
proceedings acm sigmod international conference management data pages june 
