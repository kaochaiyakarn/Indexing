secure group communication asynchronous networks failures integration experiments yair amir giuseppe ateniese damian hasse kim cristina theo john schultz jonathan stanton increasing popularity diversity collaborative applications prompts need highly secure reliable communication platforms dynamic peer groups 
security mechanisms groups tend expensive complex integration reliable group communication services presents formidable challenge 
discusses important integration issues reports implementation experience provides experimental results 
approach utilizes distributed group key management developed cliques project 
enhance handle processor network faults fail crash recover model asynchronous membership events joins leaves merges network partitions 
approach leverages strong properties provided spread group communication system message ordering clean failure semantics membership service 
result secure group communications layer api provide application programmer standard group communication services flexible security services 
fault tolerant scalable reliable communication services critical modern computing 
major focus today traditional centralized services supported part national security agency program 
department computer science johns hopkins university baltimore md usa 
email cs ateniese cs cs cnds cs jonathan cs jhu edu computer networks division usc information sciences institute marina del ray ca usa 
email hasse isi edu information computer science department university california irvine irvine ca usa 
email gts ics uci edu gene tsudik file sharing authentication web mail services distributing multiple systems networks 
distributed applications inherently collaborative applications conferencing white boards shared instrument control control systems difficult implement 
common successful approach developing types applications reliable group communication toolkit base messaging fault tolerant service 
reliable group communication systems offer set low level services provide efficient messaging membership ordering fault detection services peer groups 
typically distributed collaborative applications require fairly low latency message delivery small large messages 
may involve communication patterns 
number membership events applications generate vary minutes hours tens membership changes second 
commonly number joins leaves second network failures recoveries causing merges groups partitions hour 
aim secure group communication system support level performance practical setting 
rest organized follows 
subsections outline general terms security problems peer groups justify focus group key management 
section details security goals various issues arising group key management 
sections provide overview spread group communication toolkit cliques group key management service respectively 
secure spread architecture described section 
section illustrates discusses experimental results obtained secure spread section summarizes related 
section concludes discussion going 
security peer groups just peer group communication tends complex party communication security multi party setting harder define specify achieve 
communication channel specifics relatively little impact ability parties communicate securely 
unreliable communication channel may drop corrupt data worst prevent communication 
known cryptographic methods utilized assure data privacy data integrity source authentication properties 
techniques exist hiding communication patterns preventing hostile traffic analysis 
result adversary choice reduced binary allow communication prevent altogether 
contrast secure group communication dependent composition group 
group pair points mutates time 
collapse pairwise channels group single group channel state expressed binary value 
fluctuations group channel state cause caused members joining leaving group 
achieve highest level security state fluctuation accompanied corresponding adjustment group security parameters 
apparent group shared keying material group secret 
leads classical case chicken egg problem security events immediately follow group state change events secure 
argue certain group communication events fundamentally impossible secure 
notably include kinds fault events leading group partitions involuntary member disconnects 
concrete example consider situation network faults individual node disconnects constantly perturb group membership 
setting trying differentiate possible causes clever adversary truly faulty network impossible 
events members joining group singletons en masse secure 
important matter trust 
trust vague notion party case vague group context 
group membership changes trust group members may change time 
security focus purpose discussion motivate need specialized group security mechanisms 
routine security services bulk data privacy data integrity usually contingent sharing common secret group key establishing managing group keying material fundamental group security mechanism 
concentrate group key management integration reliable group communication platform impact 
consider impact data privacy data integrity services different peer groups traditional party communication setting 
tradeoffs choosing type key management protocols security system 
include number messages sent event number participants event amount serial computation computation done group event fault tolerance amount trust members group fairness load distribution 
discuss tradeoffs evaluate group key management protocols distributed key management protocol suite cliques centralized protocol providing roughly equivalent level security 
tackling security issues reliable group communication consider certain components needed comprehensive security 
group access control generally group policy 
group member certification 
aim underestimate importance research area just 
believe designed group key management data security protocols coupled ad hoc policy framework deployed rapidly 
believe group key management system coupled better policy framework exists 
security goals main security goal natural fairly standard achieve authentic private communication group 
requirement expressed secure group setting dynamic peer group context leads number interesting corollaries 
second security goal provide authentic private communication secure group members entities non members 
third goal obtain strong authentication non repudiation individual group members outside group 
secure group viewed microcosm sorts authentication non repudiation individuals granularity members permanent identities 
called conventional cryptography requires parties share common secret order communicate securely 
contrast public key cryptography allows parties share common secret communicate securely :10.1.1.37.9720
owing computational cost orders magnitude greater conventional encryption public key encryption secure communication parties small amount data involved 
practice public key encryption means distribute agree common secret key subsequently conventional cryptography provide authenticity privacy bulk data 
obtain security peer group setting construct obvious extension party security mechanism ssl ssh establishing group size pair wise secure channels group members 
pair wise channel associated unique secret key known endpoints 
order send private data group sender encrypt times recipient producing copies sent individually recipient single message broadcasted entire group 
easy see approach involves overhead terms computation bandwidth consumed 
group key management discussion essentially implies practically speaking private authentic communication group achieved sort common group secret 
consequently starting point security set mechanisms obtaining maintaining secret 
refer collectively group key management problem 
fact forms basis security services important reasons focus group key management security group key management paramount importance 
data privacy authenticity integrity mechanisms formed defining message format selecting basic underlying algorithm block cipher des privacy keyed mac hmac data integrity 
key management mechanisms involve intricate protocols addition methods 
adversary aiming attack system note exception secure multi destination electronic mail pem recipient groups constructed message basis 
data encryption standard 
message authentication code 
waste efforts attacking privacy integrity mechanisms key management presents attractive target 
cost group key management represents pure form security overhead 
compared cost encryption done overhead certain types stream ciphers integrity obtained certain macs key management typically requires relatively heavy weight arithmetic operations additional communication group members 
centralized vs distributed key management main issues group key management center generates group key generated 
part relatively simple extreme new key generated group membership change 
issues involved collectively determine actual key management protocol 
group key generated single party distributes group members call key management centralized members participate key generation call key management distributed 
centralized key management takes flavors controller 
notion trusted third party ttp fixed highly secure entity kerberos authentication server charged user authentication generation distribution keys 
ttp fixed approach tolerate ttp partitions ttp failures limited utility peer group 
alternative fix certain group member oldest newest group controller duty generate distribute keys group 
failures partitions group controller effectively dealt selecting appropriate member remaining group 
approach workable fact point comparison experimental results see section appendix 
allow authentication individual group members security goals 
furthermore fixed controller presents attractive attack target member security entire group 
drawback inability authenticate certain membership changes 
distributed key management involves group members collectively generating agreeing group key 
cliques protocol suite described detail section sake clarity consider hybrid methods subset members generating group key 
falls category 
group secret essentially function group members individual contributions 
time member contribution known member property aids authentication individual members member show knows unique secret portion common group secret 
cited drawbacks distributed key management relative complexity computational overhead cryptographic protocols implement 
hand illustrated experimental results section overhead comparable centralized controller key management 
spread group communication toolkit group security services discussed built top spread wide area group communication system 
spread group communication system local area wide area networks 
spread provides services traditional group communication systems including unreliable reliable delivery fifo causal total ordering membership services strong semantics 
spread creates overlay network impose arbitrary network configuration including example point multi point trees rings trees subgroups combinations adapt system different networking environments 
spread architecture allows multiple protocols links sites site 
spread useful applications need traditional group communication services causal total ordering membership delivery guarantees need run wide area networks 
addition applications may find spread useful technical properties scalability number collaboration sessions 
spread support large number different collaboration sessions spans internet small number participants 
reason spread utilizes unicast messages wide area network routing spread nodes overlay network 
scalability number groups 
spread scale number groups application imposing overhead network routers 
group naming addressing longer shared resource ip address multicast large space strings unique collaboration session 
spread supports extended virtual synchrony model view synchrony model provide strong semantic guarantees membership events message delivery 
spread uses daemon client architecture 
architecture benefits important wide area settings resultant ability pay minimum necessary price different causes group membership changes 
simple join leave processes translates single message 
daemon disconnection connection pay heavy cost involved changing wide area routes 
network partitions different local area components network requires heavy cost membership change 
luckily strong inverse relationship frequency events cost practical system 
process daemon membership correspond common model lightweight groups heavyweight groups rg 
spread toolkit available publicly 
early version system organizations research practical projects 
toolkit supports applications ported unix platforms windows java environments 
supported group communication semantics spread supports extended virtual synchrony evs model view synchrony vs model 
evs vs guarantee group members see set messages sequential group membership events 
guarantee order messages requested application fifo causal total preserved 
evs provides general service vs semantics implemented top evs semantics performance penalties evs implemented top vs significant latency penalty 
evs provides general benefits vs better performance prevents applications blocking system allows open groups non members group send messages group 
evs guarantees messages delivered recipients membership message originally sent network 
evs property critical difference vs evs 
vs contrast guarantees stricter property messages delivered recipients membership sending application thought details spread system www spread org white programming documentation 
member time sent message 
providing property requires round application messages installing new membership 
need application level requires groups closed allowing members group send messages 
knowledge message received membership application believed sent provided vs semantics implementing secure group system easier message encrypted key receiver believes current message delivered 
services provided security layer require closed groups members group shared group key encrypt sign messages 
additionally implement group key agreement protocol top evs require security layer implement semantics similar vs correctly maintain messages sent key 
see significant benefit building security requiring evs semantics 
spread system provides extended virtual synchrony 
flush layer built atop spread provided spread system provides view synchrony model 
overview cliques clq api cliques cryptographic protocol suite provides authenticated contributory group key management security services 
cliques protocols guarantee key independence key confirmation perfect forward secrecy resistance known key attacks 
refer detailed definitions attacks 
short cliques guarantees group keys obtained active passive attackers 
past group members collusion obtain group keys subsequent leaving group similarly current group members obtain group keys joined group 
cliques group extensions known diffie hellman key exchange technique :10.1.1.37.9720
cliques defines special role group controller member join group 
role floats group membership changes 
controller charged initiating key adjustments membership changes 
special security tasks privileges 
clq api group key agreement api built top cliques protocol suite 
main purpose implement cryptographic primitives cliques 
underlying communication system assumed deal group communication network events par true daemon implementation 
failures abnormalities 
clq api small concise containing function calls 
cliques guarantees system invariants 
group members agree identity current group controller 
point time controller newest joined group member 

group secret key contributed equally group member 
point time group secret function members private shares 
current group members access group secret 
cliques supports group key agreement operations join new member added group 
merge members added group 
leave members removed leave group 
key refresh generates new group secret 
result outcome group secret changed members obtain authenticated key 
rest section briefly explains clq api performs operations 
details reader referred 
group secret members form member private share large prime number generator agreed systemwide parameters just plain party diffie hellman setting :10.1.1.37.9720
join 
group controller generates new private share computes partial group secrets existing group member 
hands partial group secrets joining member new controller 

receiving information new member adds share partial group secrets users broadcasts result entire group 

reception broadcasted message user computes group secret 
merge merge operation cliques requires list merging members available current group controller 
merge member list new group controller 

current controller generates new private share computes new partial group secret 
value sent openly new merging member 

new member turn adds private share group secret sends new member 

new member add share broadcasts partial group secret group 

receipt broadcast member removes factors private share partial group secret sends result back new member new group controller 

having received messages new controller computes new partial group secret members adding private share value received 
broadcasts set partial group secrets entire group 

reception broadcast member computes new group secret 
leave 
current controller updates private share recomputes partial group secrets remaining group members broadcasts result group 

reception broadcast user computes new group secret 
key refresh key refresh identical leave exception triggered unilaterally controller 
api support option group member just controller cause key refresh updating private share 
secure spread architecture mentioned previously spread supports vs evs group semantics 
currently secure spread uses vs group semantics 
spread uses daemon client communication architecture 
current implementation secure spread implemented layer extends spread client library adding new security features discussed 
client applications link secure library provided api similar regular spread api 
different way construct secure spread graft security features directly spread daemon 
refer approaches client model daemon model respectively 
benefits model drawbacks 
client model advantage implementation daemon trusted correctly implement ordering reliability membership services 
daemon responsible cryptographic security services 
providing correct implementation ordering services trivial requirement security wise 
systems networks possible subvert ordering guarantees provided group communication system 
done modifying content data messages daemons send 
system message stream client layer way detecting mis ordered messages reimplementing full agreed ordering protocol 
contrast pointto point secure communication systems ssh run top tcp 
point point systems packets nodes modified reordered ssh decryption integrity checks detect corruption tcp 
daemons deploy mechanisms protect malicious network attackers client model 
note requirement trust daemons client model requires trust daemon model 
corporate network employees may trust shared spread network setup system administrator correctly perform ordering reliability services 
may trust data remain confidential sent spread network system administrator read 
want encrypt client level 
main advantages client model different lesser amount trust placed daemon implementation library rely spread application semantics cryptographic code control user 
advantage client design demonstrates secure group communication system supports vs model 
daemon model denies user access security implementation especially daemon network user control 
offer advantages 
main advantage substantial increase performance 
keys longer need group 
daemons encode communication daemon group key 
daemons long lived entities update key connectivity changed daemon crashed recovered daemons choose refresh key occasionally 
kind events rarer individual processes joining leaving group 
daemon model number key agreements occurring system drastically reduced comparison client model 
note communication clients daemons secured manner 
example client assume ipc secure encrypted communications ssl sockets 
advantage daemon model security policy easily configured enforced 
model administrator change policy editing daemon configuration 
users connecting daemons authenticated connection 
access control daemons specific groups easily enforced 
daemons easily authenticate users members specific groups 
summarize despite apparent advantages daemon model client model confidentiality advantage daemon model 
daemon model daemon key obtained messages group compromised daemons re key 
contrast client model group key obtained messages group compromised group 
due different levels security offered models approaches useful 
high level design major consideration designing secure communications toolkit security trust depend algorithms toolkit 
time goes trust algorithms may change ciphers broken algorithms proven insecure better algorithms designed system hoping secure communications viable long run needs flexible easily modified 
desirable feature security policy easily changed administrators users 
way achieve goals design extremely modular system 
shows basic architecture modular secure system 
necessary secure group layer calls different modules implement encryption key management key generation routines 
secure layer needs know call modules functions type design allows drop replacement different modules 
new module needs added modifications 
application secure group communication group communication network key generation module encryption module 
generic secure architecture code written implementing new module 
second module chosen run proper times 
secure spread modules basic design secure spread follows modular design closely 
core functionality secure spread event handling loop 
network events generated vs group communication layer 
secure spread takes events depending context passes proper module handles event 
interesting addition design secure spread modules implementing security policies algorithms system chosen run time new groups created 
mechanism allows different groups choose different event handlers simultaneously running group communication system 
example group decide centralized key management group distributed key management time 
currently secure spread designed allow drop replacement encryption key agreement protocols 
hope extend architecture allow modules access control policy decisions 
early stage development secure spread small set modules 
shows current implementation secure spread 
flush layer provides view synchrony semantics secure spread layer 
note application connections open time multiple groups 
groups application secure spread flush spread network cliques protocols blowfish cliques library 
secure spread implementation secure view synchrony semantics flush layer evs semantics provided spread 
application chooses services 
currently bulk data encryption secure spread uses open source implementation bruce schneier blowfish algorithm 
near hope add ability openssl cryptographic library provides abundant selection encryption algorithms 
secure spread currently different modules key agreement cliques protocol suite 
cliques key management group diffie hellman 
simple centralized key management described appendix table 
complexity secure spread contained entirely modules 
implementation cliques group key management cliques key management suite corresponding api section independent particular implementation group communication system 
protocols implemented specifically secure spread subject section 
order easily accommodate cliques protocols underlying group communication system needs provide certain fundamental features 
include group multicast group member group member unicast fifo ordering messages mechanism knowing identifying members group 
services provided spread 
furthermore cliques api tuned allow types membership changes singleton join singleton leave multi join multi leave 
types membership events provided spread 
addition vs model spread generates event combination multi join multi leave event requesting application ok group membership change 
implementing cliques protocols group communication system requires mapping group communication events cliques events 
table simple mapping spread vs group events cliques events 
table 
mapping spread events group key events spread vs group group key membership events management operations join join leave leave disconnect leave partition leave merge merge partition merge leave merge group change request key refresh spread generates vs group event event passed security layer 
secure spread examines event determines group message corresponds 
retrieves event handler particular group gives event handler 
handler responsible mapping network vs event set proper actions taken 
handler considers current state group key agreement protocol described section 
implementation cliques protocols implemented state machines 
state machine current state member group collectively referred member state member state current event affecting group determine actions taken member 
cliques library keeps state information associated group current group controller 
calls clq api general group members function call return values calls determine member state member changes actions take 
fifo ordered messages communicate partial keys key shares group particular entities 
done fifo ordered messages extremely low overhead stronger message orderings required 
cascading failure handling merging security protocols high reliability group communication protocols obvious premise security imply robustness system secure robust 
security protocol secure built reliable communication platform robust 
instance security protocols group communication assume messages received certain order protocol parties time connected ready receive messages 
real systems assumptions fulfilled 
adding reliability group communication system assumptions realistic protocols usable 
focusing problem hand recall fluctuations group channel state coupled group key adjustments 
adjustments require availability reachability group member 
group channel state changes adjustment stemming earlier change progress appropriate actions taken maintain security preserve group integrity 
stark contrast party communication cascading fluctuations simply occur 
significant challenge integrating reliable group communication group security protocols lies straightforward mapping spaced communication events security counterparts proper robust handling various cascading events perturb group channel state 
far implemented key agreement membership events 
allows benchmark system learn performance essentially common cases 
specifically compared performance centralized decentralized join leave operations 
basic difficulty handling cascading membership events arises key agreement protocol takes time communication generate new key subsequent membership changes completing process impossible produce incorrect results 
solving problem requires modification key agreement protocol addition cases handling possible changes possible times 
note just vs properties allow application delay new membership finished time security layer asked ok new membership change know time sec spread sparc spread pentium flush layer pentium group size 
spread flush layer timings membership event join leave partition involved 
know event safe defer 
experimental results section experimental results obtained secure spread 
performed experiments different machine architectures group scenario 
set machines sun ultra model mhz ultrasparc mb running solaris set machines pentium ii mhz mb running red hat linux 
timings obtained performing multiple batches operation times averaging batches 
setup consisted identical machines running spread daemon 
machines single member third machine contained members processes utilizing single daemon 
ethernet network connected sun ultra ethernet network connected pentium ii machines 
clq api linked openssl diffie hellman dh exponentiation bit modulus costs msecs sun pentium platforms respectively 
total number serial exponentiations required join leave operations illustrated tables join operation includes new member leave operation includes leaving member 
cliques table 
detailed number exponentiation join update key share member controller long term key computation new member new session key computation total long term key computations new member encryption session key new session key computation total long term key computation new member pairwise key computation new member controller new session key computation encryption session key total long term key computation controller pairwise key computation controller new member encryption pairwise secret controller decryption session key total table 
detailed number exponentiation leave remove long term key previous controller cliques new session key computation encryption session key total new session key computation encryption session key total long term key computations pairwise key computation new user controller new session key computation leaves encryption session key total table 
total number serial exponentiation operation join leave controller leaves number members operation cliques time sec join group size cliques sparc sparc cliques pentium pentium respectively 
table summarizes total number serial exponentiations performed course operation 
shows total time join leave operation costs versus group size 
time graph includes network overhead 
flush layer timings graph linear due fact messages broadcast member 
fact clients running machine size test required local machine 
practice client widely distributed 
presents total time join leave operations versus group size separate graphs 
times reported graphs cpu times measured function 
graphs follow closely total number expected exponentiations tables 
shows network overhead small comparison time required exponentiation relatively large groups 
words results clearly show exponentiation dominant operation 
cpu time required join leave exponentiation operations 
example join operation group fifteen members takes seconds modular exponentiation total cpu time experimentally takes seconds pentium 
cpu modular exponentiation 
flush layer values sparc architecture included show new 
time sec 
timings leave related group size cliques sparc sparc cliques pentium pentium related falls categories cryptographic protocols group key management architectures frameworks secure multicast implementation secure group communication systems 
systems orientation concentrate 
readers interested referred 
choose dwell related secure multicast security communication models differ greatly dynamic peer groups 
suffice say typically assumes communication paradigm emphasizes scalability strong security specifically focus minimizing bandwidth overhead re keying large group 
generation distribution group keys assumed performed trusted servers discussed approach unsuitable peer group setting 
group communication systems lan environments developed history isis systems transis horus totem rmp 
systems explored different models group communication virtual synchrony extended virtual synchrony 
area focuses scaling group membership wide area networks wans 
research securing group communication systems secure multicast taken place aegis internet research task force irtf secure multicast group see www com information 
fairly 
actual implementations group communication systems focusing security issues secure distributed corba immune system built top securering group communication ucsb horus ensemble cornell 
earlier rampart system cornell concentrated byzantine robustness 
immune system ucsb provides protection byzantine failures cryptographic techniques secure low level ring protocol forms base totem system replicating protected corba objects sufficiently detect recover fixed number compromised objects machines 
ensemble security exemplifies stateof art reliable group communication security addresses problems consider 
allows application dependent trust models optimizes certain aspects group key generation distribution protocols 
problems address generating shared group keys rekeying respective approaches quite different 
ensemble relies extensions conventional group oriented cryptographic tools pgp kerberos distribute refresh group keys 
approach notable advantages summarized section generation group keys distributed uses peer group model ensemble uses centralized key generation done group leader 
ensemble entire group relies member ability generate strong secure keys 
group leader member 
role group leader changes current group leader leaves group voluntarily gets partitioned 
second ensemble key distribution performed help encryption pgp expensive key encrypted individually member 
importantly compromise just member longterm secret pgp private key exposes previous group session keys prior group communication 
may suffice practice secure solution provide called perfect forward secrecy pfs 
pfs guarantees compromise long term secret shared private key result compromise previously short term secrets ephemeral group keys 
contrast cliques key agreement protocols avoid encryption altogether offer pfs 
approach differs ensemble far member authentication 
group member ensemble authenticated common group key member long term secret kerberos pgp key 
authenticates membership specific member authenticates long lived entity group member 
approach supports allows group member authenticate unique short term secret secret contribution common group key 
follow cornell produced interesting decentralized optimized group keying protocols 
protocols loosely wong 
represents tip iceberg 
remains done constructing comprehensive architecture implementation secure reliable group communication 
time writing way implement secure robust handling cascaded group events sketched section 
focused application client security step securing spread 
core functions spread embodied daemon logical task integrate cliques security mechanisms spread daemons 
result security membership change events remove undue trust assumptions security daemons 
experimentation needed better assess impact security group communication 
short term need consider important specialized group security services built top basic services distributed key management data privacy integrity 
include intra group member authentication secure communication non members group integrity group member anonymity membership nonrepudiation 
fundamental long term research topics addressed 
dynamic peer groups interesting policy considerations traditional party communication 
new policy constraints include altering group membership policy contingent current membership time group admission constraints 
group certification open research problem including issues issue manage revoke certificates constantly changing groups 
need extend peer group security tiered groups composed small number senders comparatively large number receivers 
group key management protocol gkmp specification request protocol secret public keys group controller respectively 
mod assume group members wants join group 
protocol runs follows round selects random selection performed round selects random round selects random group secret computes comments experimental internet engineering task force july 
diffie hellman new directions cryptography ieee transactions information theory vol :10.1.1.37.9720
pp 
nov 
kent internet privacy enhanced mail communications acm vol 
pp 
aug 
national bureau standards data encryption standard des data encryption standard model operation government printing office washington 
federal information processing standards fips 
krawczyk bellare canetti hmac keyed hashing message authentication request comments informational internet engineering task force feb 
steiner neuman schiller kerberos authentication service open network systems usenix winter conference pp 
jan 
amir stanton spread wide area group communication system tech 
rep johns hopkins university department computer science 
moser amir melliar smith agarwal extended virtual synchrony proceedings ieee th international conference distributed computing systems pp 
ieee computer society press los alamitos ca june 
table 
protocol fekete lynch shvartsman specifying group communication service proceedings th annual acm symposium principles distributed computing santa barbara ca pp 
august 
amir replication group communication partitioned network 
phd thesis institute computer science hebrew university jerusalem jerusalem israel 
steiner tsudik waidner key distribution extended groups nd acm conference computer communications security pp 
acm press mar 
steiner tsudik waidner cliques new approach group key agreement ieee international conference distributed computing systems may 
ateniese steiner tsudik new multiparty authentication services key agreement protocols ieee journal selected areas communication vol 
march 
menezes oorschot vanstone handbook applied cryptography 
crc press series discrete mathematics applications crc press 
isbn 
ateniese hasse kim tsudik design group key agreement api darpa information security conference exposition discex january 
schneier blowfish encryption algorithm dr dobb journal pp 
apr 
openssl project team openssl may 
www openssl org 
ssh communications security ssh secure shell jan 
www ssh org 
birman renesse reliable distributed computing isis toolkit 
ieee computer society press march 
amir dolev kramer malki transis communication subsystem high availability digest papers nd international symposium fault tolerant computing systems pp 
ieee computer society press los alamitos ca 
renesse birman maffeis horus flexible group communication system communications acm vol 
pp 
april 
amir moser melliar smith agarwal totem single ring ordering membership protocol acm transactions computer systems vol 
pp 
november 
montgomery kaplan high performance totally ordered multicast protocol theory practice distributed systems international workshop lecture notes computer science september 
birman joseph exploiting virtual synchrony distributed systems th annual symposium operating systems principles pp 
november 
chockler dolev keidar scalable group membership services novel applications proceedings workshop networks distributed computing merritt shavit eds dimacs series discrete mathematics theoretical computer science 
moser melliar smith securering protocols securing group communication proceedings ieee st hawaii international conference system sciences vol hawaii pp 
january 
narasimhan moser melliar smith providing support survivable corba applications immune system proceedings th ieee international conference distributed computing systems austin tx pp 
may 
rodeh birman hayden xiao dolev ensemble security tech 
rep tr cornell university department computer science september 
reiter distributing trust rampart toolkit communications acm vol 
pp 
apr 
zimmerman official pgp user guide 
prz acm org 
mit press press 
www pegasus esprit ec org people arne pgp html 
rodeh birman dolev optimized group rekey group communication systems proceedings isoc network distributed systems security symposium february 
wong gouda lam secure group communications key graphs proceedings acm sigcomm pp 

centralized key distribution protocol centralized key distribution protocol simple group key distribution scheme 
provides level security cliques far key independence key confirmation perfect forward secrecy resistance known key attacks 
contributory group secret generated member current group controller 
membership change current controller generates secret distributes group secure manner 
cliques controller oldest member 
protocol regardless group operation key distribution protocol consists phases 
group member controller agree key authenticated party diffie hellman 
key need change long users remain group 
controller leaves group new controller perform operation member 
hand regular member leaves controller simply discards key 

group controller unilaterally generates distributes group secret 
term current mean protocol suite controller fail partitioned causing controller role reassigned oldest surviving member 
