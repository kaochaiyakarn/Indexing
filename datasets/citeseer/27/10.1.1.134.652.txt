automatic predicate abstraction programs thomas ball majumdar microsoft com cs berkeley edu microsoft research berkeley todd millstein sriram rajamani todd cs washington edu sriram microsoft com univ washington microsoft research research microsoft com slam model checking widely successful validating debugging designs hardware protocol domains 
state space explosion limits applicability model checking tools model checkers typically operate abstractions systems 
significant interest applying model checking software 
infinite state systems software abstraction critical 
techniques abstracting software prerequisite making software model checking reality 
algorithm automatically construct predicate abstraction programs written industrial programming language implementation tool bp 
bp tool part slam toolkit uses combination predicate abstraction model checking symbolic reasoning iterative refinement statically check temporal safety properties programs 
predicate abstraction software applications including detecting program errors synthesizing program invariants improving precision program analyses predicate sensitivity 
discuss experience applying bp predicate abstraction tool variety problems ranging checking list manipulating code preserves heap invariants finding errors windows nt device drivers 
hardware protocol domains model checking validate debug systems algorithmic exploration state spaces 
state space explosion major limitation typically model checkers explore state space abstracted system 
software permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi snowbird utah usa 
copyright acm typically infinite state abstraction critical 
effort model check software construct model software 
promising approach construct abstractions automatically called predicate abstraction proposed graf sa idi 
predicate abstraction concrete states system mapped states evaluation finite set predicates 
automatic predicate abstraction algorithms designed implemented finite state systems infinite state systems specified guarded commands 
demonstrated automatic predicate abstraction programming language tool called bp performs automatic predicate abstraction programs 
program set predicates pure boolean expressions containing function calls bp automatically creates boolean program bp abstraction boolean program essentially program type available boolean boolean program language additional constructs 
boolean program control flow structure contains jej boolean variables representing predicate example predicate integer variables boolean variable bp truth program point implies true statement bp automatically constructs corresponding boolean transfer functions conservatively represent effect predicates resulting boolean program analyzed precisely tool called bebop performs interprocedural dataflow analysis binary decision diagrams 
details bp algorithm results applying bp variety problems programs ffl applied bp bebop programs identify invariants involving pointers 
example invariants lead precise aliasing information possible alias analysis 
example show list manipulating code preserves various structural properties heap done shape analysis 
noteworthy predicate language quantifier free logic powerful logic 
ffl applied bp bebop examples necula proof carrying code automatically identify loop invariants examples pcc compiler required generate 
ffl bp slam toolkit check temporal safety properties windows nt device drivers 
slam toolkit uses bp bebop statically determine assertion violation take place code 
unique part toolkit demand driven iterative process automatically find predicates relevant particular assertion examination 
current set predicates boolean program abstraction induces insufficient show assertion doesn fail new predicates refine abstraction 
slam process may converge theory due undecidability assertion violation problem converged nt device drivers analyzed contain loops 
detailed proof soundness abstraction algorithm interested reader referred technical report 
andreas podelski framework abstraction interpretation formalize precision bp algorithm single procedure programs pointers 
section reviews soundness theorem bp proved describes precision results 
rest organized follows 
section gives example applying bp procedure 
section lists challenges performing predicate abstraction programs 
section describes predicate abstraction algorithm detail 
section describes extensions optimizations bp tool 
section presents results applying bp tool variety programs 
section reviews related section concludes 
example invariant detection programs section presents application bp bebop model checker pointer manipulating procedure 
combination tools determines program invariants procedure refine pointer aliasing information 
bp consider partition function 
procedure takes pointer list integers integer partitions list lists containing cells value greater returned function containing cells value equal original list destructively updated 
input program predicate input file bp partition curr null prev null curr val prev val predicate input file specifies set predicates local procedure partition 
shows boolean program resulting abstraction procedure partition respect predicates 
boolean program declares variables type bool procedure partition corresponding predicates predicate input file 
variables initial values unconstrained 
boolean program guaranteed abstraction program sense feasible execution path program feasible execution path boolean program 
course may feasible execution paths boolean program infeasible program 
paths lead imprecision subsequent model checking 
informally describe bp tool translates statement program corresponding set statements boolean program 
assignment statement program translated set assignments capture effect original assignment statement input predicates 
example assignment statement prev null program translated assignment statements boolean program 
true reflects truth predicate prev null assignment 
value predicate prev val undefined assignment invalidated assignment statement val vg unknown 
unknown function defined bool unknown return true return false unknown function uses control expression non deterministically chooses branch return true false 
bp tool determines predicates unaffected assignment prev null need updated 
bp tool uses points analysis resolve aliases pointers 
program pointer variables set curr prev newl address taken variables aliased expression procedure 
result bp resolves predicates assignment prev null affects prev null prev val 
example assignment prev curr abstracted assignments predicates involving prev 
predicates assigned values corresponding predicates curr expected 
bp determines assignment newl null affect input predicates assignment translated skip statement boolean program op 
examples input predicates updated accurately 
example assignment boolean program shown exact output bp simplified aid readability 
boolean programs variable identifiers regular identifiers arbitrary string enclosed 
typedef struct cell int val struct cell list list partition list int list curr prev newl curr prev null newl null curr null curr curr val prev null prev curr curr newl newl curr prev curr curr return newl void partition bool curr null prev null bool curr val prev val curr null unknown curr curr val unknown prev null true prev null prev val unknown skip newl null curr null assume curr null skip curr curr val assume curr val prev null assume prev null skip prev curr skip skip curr newl skip newl curr assume curr val prev null curr null prev curr prev val curr val curr null unknown curr curr val unknown assume curr null list partition example boolean program list partition example abstracted respect set input predicates curr null prev null curr val prev val unknown function generate value true false non deterministically see body text explanation 
boolean program exactly represents effect assignment prev curr predicate prev null 
possible exact information unavailable necessary predicates input bp 
case replace exact information conservative approximation 
example assignment curr affect predicates involving curr 
predicates predicate input file way deduce correct truth value predicates 
represents worst case sorts input predicates provide absolutely information appropriate truth values predicates updated 
result predicates invalidated unknown function defined 
bp tool translates conditional statements program non deterministic conditional statements boolean program control expression 
inserts assume statements capture semantics conditionals respect input predicates 
example statement inside loop assume 
assume acts filter state space boolean program case impossible reach program point assume variable true 
way faithfully model guard original loop 
bebop boolean program output bp input bebop model checker computes set reachable states statement boolean program interprocedural dataflow analysis algorithm spirit sharir pnueli reps horwitz sagiv 
state boolean program statement simply valuation boolean variables scope statement words bit vector bit variable scope 
set reachable states invariant boolean program set bit vectors equivalently boolean function set variables scope 
bebop differs typical implementations dataflow algorithms crucial ways 
computes sets bit vectors statement single bit vectors 
necessary capture correlations variables 
second uses binary decision diagrams bdds implicitly represent set reachable states program transfer functions statement boolean program 
bebop uses explicit control flow graph representation compiler encoding control flow bdds done symbolic model checkers 
example bebop outputs invariant representing reachable states label boolean program curr null curr val prev val 
prev null bp sound boolean function invariant state program label invariants different purposes give examples section 
interesting usage invariant refine alias information 
particular invariant implies prev curr aliases label procedure partition 
words variables prev curr point memory location label seen follows ffl prev null prev curr curr null 
ffl prev null curr val prev val follows prev val curr val implies prev curr 
fact deduced automatically invariant 
particular decision procedure determine invariant implies prev curr 
way automatically refine existing alias analysis 
traditional flow sensitive alias analyses discover prev curr aliases label analyses values fields prev val eliminate possible aliasing relationships 
summary shown bp compute boolean program sound abstraction program respect set predicates subsequent model checking boolean program discover strong invariants expressed boolean functions predicates challenges predicate abstraction complexities programming language gives rise technical challenges performing predicate abstraction ffl pointers 
closely related subproblems dealing pointers assignments dereferenced pointers original program pointers pointer dereferences predicates abstraction computed 
handle cases uniform manner describe points analysis improve precision abstraction 
ffl procedures 
programs procedures handled allowing procedural abstraction target language 
particular boolean programs global variables procedures local variables call byvalue parameter passing 
having explicit procedures allows abstraction analysis efficient exploiting procedural abstraction program 
allows handle recursive contrapositive rule usually applied unification alias analysis lambda lambda 
lambda lambda 
mutually recursive procedures additional mechanism 
differs approaches software model checking inline procedure calls 
section describe modular abstraction process procedures procedure abstracted signatures abstractions callees signatures constructed procedure isolation 
ffl procedure calls 
abstraction process procedure calls challenging particularly presence pointers 
call caller conservatively update local state may modified callee 
provide sound precise approach abstracting procedure calls takes side effects account 
ffl unknown values 
possible determine effect statement program predicate terms input predicate set deal non determinism directly boolean program non deterministic control expression allows implicitly express valued domain boolean variables 
ffl precision efficiency tradeoff 
computing transfer function statement program respect set predicates may require theorem prover 
obtaining precise transfer function requires jej calls theorem prover worst case 
explored optimization techniques reduce number calls theorem prover 
techniques result equivalent boolean program trade precision computation speed 
predicate abstraction section describes design implementation bp detail 
program set ng pure boolean expressions variables constants language bp automatically constructs abstraction respect 
abstraction represented boolean program bp program identical control structure contains boolean variables 
particular bp contains boolean variables fb boolean variable bi represents predicate 
described section bp guaranteed abstraction set execution traces bp superset set execution traces tool handles syntactic constructs language including pointers structures procedures 
main limitation uses logical model memory analyzing programs 
models expression pointer integer yielding pointer value points object pointed sequel assume program converted simple intermediate form intraprocedural control flow accomplished statements gotos expressions free side effects short circuit evaluation contain multiple dereferences pointer function call occurs top level expression example replaced 
weakest preconditions cubes statement predicate denote weakest liberal precondition respect statement defined weakest predicate truth entails truth terminates terminates 
assignment scalar variable expression appropriate type 
predicate 
definition occurrences replaced denoted 
example weakest precondition computation central predicate abstraction process 
suppose statement occurs program points predicate corresponding boolean variable safe assign value true bp program points boolean variable corresponding true program point variable may exist example suppose seen predicate case bp uses decision procedures theorem prover strengthen weakest precondition expression predicates example show 
true true 
formalize strengthening predicate follows 
cube conjunction ci ci ci fbi bi bi variable bi bi denote corresponding predicate bi denote predicate 
extend cubes disjunctions cubes natural way 
predicate set boolean variables fv denote largest disjunction cubes implies 
predicate fv represents weakest predicate implies 
example fv 
useful define corresponding weakening predicate 
define gv fv 
predicate gv represents strongest predicate implied 
cube implication check involves call theorem prover implementing required decision procedures 
implementation bp uses theorem provers simplify nelson oppen style provers 
naive computation fv delta gv delta requires exponentially calls theorem prover worst case 
section describes optimizations fv gv computations practical 
pointers aliasing presence pointers necessarily 
example lambda lambda lambda aliases lambda true assignment similar problem occurs pointer dereference left hand side assignment 
handle problems adapt morris general axiom assignment 
location variable int bar int int bar int 
return void foo int int foo int bar 
example input bp 
left simple procedures bar shown entirety 
right set predicates model 
structure field access location dereference location 
consider computation location location mentioned predicate 
cases consider aliases assignment cause value aliases assignment leaves unchanged 
define 
yn locations mentioned 
defined yn 
example lambda 
lambda absence alias information predicate locations occurring weakest precondition syntactic disjuncts disjunct considering possible alias scenario locations bp uses pointer analysis improve precision weakest precondition computation 
pointer analysis says aliased program point prune disjuncts representing scenario aliased partially evaluate disjuncts representing scenario aliased effect improving precision resulting boolean program bp produced bp 
implementation uses das points algorithm obtain flow insensitive context insensitive may alias information 
predicate abstraction assignments consider assignment statement label boolean program bp produced bp contain label parallel assignment boolean variables scope 
boolean variable bi bp value true fv holds 
similarly bi value false fv holds 
note predicates simultaneously true 
predicates holds bi set non deterministically 
happen predicates strong provide appropriate information theorem prover incomplete 
bp contains parallel assignment label bn choose fv fv choose fv fv choose function part bp defined follows bool choose bool pos bool neg pos return true neg return false return unknown example consider abstracting statement procedure foo respect predicates declared local foo 
call statement example may alias analysis reveals lambda alias weakest precondition lambda lambda alias fv lambda lambda 
similarly lambda lambda fv lambda lambda 
weakest preconditions respect predicates respective predicates lambda alias bp contain statement place assignment statement feg denote boolean variable representing predicate choose choose choose note abstraction process assignment statements weakest precondition computations local assignment computed purely syntactic manipulation predicates 
bp compute compositions weakest preconditions paths complex control flow 
particular bp require programs annotated function pre postconditions loop invariants 
predicate abstraction gotos conditionals goto statement program simply copied boolean program 
translating conditionals involved 
consider conditional program branch predicate holds 
branch corresponding conditional bp condition gv known hold 
similarly branch know holds gv known hold program point bp 
bp contain abstraction conditional lambda assume gv assume gv note test abstracted conditional lambda paths conditional possible 
branches assume statement retain semantics original conditional test 
assume statement dual assert assume fails 
executions hold point assume simply ignored 
example consider conditional procedure foo 
abstraction conditional respect predicates local foo lambda assume fx assume fx predicate abstraction procedure calls describe bp handles multi procedure programs 
notation recall input bp program set predicates 
gp global variables program predicate annotated global bp local particular procedure bp see predicates local bar foo global predicates example determining scope corresponding boolean variable bp 
global predicate refer variables gp denote global predicates vg denote corresponding global boolean variables bp 
procedure er denote subset predicates local vr denote corresponding local boolean variables bp 
distinguish boolean variable corresponding predicate unambiguous context context bp mean context mean 
fr formal parameters lr local variables lr fr return variable assume loss generality return statement form return 
vars set variables referenced expression set variables dereferenced expression determining signatures key feature approach modularity procedure abstracted bp signatures procedures calls 
signature procedure determined isolation rest program er 
bp operates passes 
pass determines signature procedure 
uses signatures procedure calls statements second pass 
procedure abstraction bp 
signature procedure tuple fr ef er ffl fr set formal parameters ffl return variable ffl set formal parameter predicates defined fe er vars lr ffl er set return predicates defined fe er vars vars frg lr 
vars gp fr set formal parameter predicates subset predicates er refer local variables predicates er gamma ef locals er set predicates returned boolean programs allow procedures multiple return values 
return predicates serve purposes 
provide callers information return value purpose provide callers information global variables call parameters local predicates callers updated precisely 
handle concern er contains predicates er mention mention locals callers know locals 
handle second concern er contains predicates global variable dereference formal parameter example consider procedure bar 
signature bar ef lambda er fy lambda yg 
handling procedure calls consider call aj procedure label procedure abstraction bp contains call label 
signature fr ef er 
formal parameter predicate ef bp computes actual value pass call 
aj fj fr ff fjg 
expression represents predicate translated calling context 
actual parameter computed formal choose fv fv 
explain bp handles return values call assume er fe epg 
bp creates fresh local variables ft tpg procedure assigns parallel return values tp final step update local predicate value may changed result call 
predicate es mentions updated 
addition update predicate es mentions global variable possibly transitive dereference actual parameter call alias kinds locations 
bp uses pointer alias analysis determine conservative approximation eu set predicates update 
es gamma eu 
predicates predicates er update predicates eu 
vs vg boolean variables bp corresponding bp translates predicates er calling context 
particular ei er ei aj fj fe define ti ti eu corresponding boolean variable vs assigned value choose 
example consider call bar 
recall signature bar formal parameter predicates lambda return predicates er fy lambda yg 
abstraction call boolean program follows prm choose formal prm choose false formal bar prm prm choose choose formal properties give properties relate bp 
property soundness states abstraction feasible path feasible 
boolean program allows paths feasible sound need state sense precise 
terminology interpretation 
soundness 
path feasible guaranteed feasible bp 
omega state program executing path exists execution boolean program state gamma holds omega iff bi true gamma proof soundness bp 
precision 
framework interpretation specify abstractions declaratively 
boolean abstraction maps concrete states states evaluation finite set predicates 
cartesian abstraction maps set boolean vectors vector obtained ignoring dependencies components vectors see example set analysis 
example set boolean vectors mapped cartesian abstraction valued vector represents don know value 
single procedures pointers simplicity assume formal refers value corresponding actual call 
checked standard modification side effect analysis 
formal proven refer value corresponding actual call predicates mention formal removed er signature abstraction computed bp equivalent composition boolean cartesian abstractions 
improve precision disjunctive completion focus operations implemented bebop bdds 
extensions section describes various techniques applied increase precision efficiency bp 
enforce construct predicates correlated way 
example consider predicates 
semantics associated predicates forbids predicates simultaneously true 
uninterpreted boolean variables predicates bp preclude execution boolean program variables evaluate true state 
order rule executions containing spurious situations add enforce construct boolean programs statement enforce procedure effect putting assume statement procedure 
ensures data invariant maintained procedure execution 
compute procedure simply fv false 
example predicates 
optimizations method described constructing models programs impractical important optimizations 
profiling shows running time bp dominated cost theorem proving making exponential number calls prover program point 
optimization efforts focused cutting number calls theorem prover 
computing fv cubes considered increasing order length 
cube shown imply know cube contains subset imply redundant safely pruned 
way computation produces disjunction prime implicants fv 
cube imply implies cube contains subset imply safely pruned 
second assignment statement updating values boolean variable scope update variables truth value definitely change result assignment 
truth value variable definitely change result assignment 
third computation fv perform analysis produce set contains predicates possibly part cube implies 
fv safely replaced reducing number cubes explore 
set determined syntactic cone influence computation 
starting empty set find predicates mention location alias location add predicates determine set locations mentioned predicates iterate reaching program lines predicates thm 
prover runtime calls seconds floppy ioctl log table device drivers run bp 
fixpoint 
set boolean variables fourth try syntactic heuristics construct fv directly 
simple example exists boolean variable return requiring calls theorem prover 
fifth cache computations theorem prover alias analysis repeated 
worst case complexity computing abstraction exponential number predicates optimizations dramatically reduce number calls theorem prover examples 
optimizations property leave resulting bp semantically equivalent boolean program produced optimizations 
optimizations described rely existence enforce data invariant soundness 
willing sacrifice precision optimization opportunities 
example limit length cubes considered computation constant lowering function complexity exponential 
practice setting provides needed precision cases 
optimization compute function atomic predicates 
recursively convert 
allows existing optimizations function described finer grained manner 
distribution loses precision distribution lose precision 
experience implemented bp ocaml top ast toolkit modified version microsoft compiler exports syntax tree interface clients simplify theorem provers das points analysis 
applied bp problem areas checking safety properties windows nt device drivers context slam project slam toolkit discovering invariants regarding array bounds checking list manipulating code 
slam toolkit application nt device drivers goal slam project automatically check program respects set temporal safety properties interfaces uses 
safety properties class properties state bad happen 
example requiring lock released acquired see formal definition 
program safety property wish validate code respects property find execution path shows code violates property 
safety property check program slam process phases abstraction model checking predicate discovery 
developed slam toolkit support phases ffl bp topic ffl bebop tool model checking boolean programs ffl newton tool discovers additional predicates refine boolean program analyzing feasibility paths program subject 
slam toolkit provides fully automatic way checking temporal safety properties system software 
violations reported slam toolkit paths program toolkit reports spurious error paths 
detects paths uses automatically refine boolean program abstraction eliminate paths consideration 
property checking undecidable slam refinement algorithm may converge 
addition may terminate don know answer due incompleteness underlying theorem provers 
experience usually converges iterations definite answer 
reason properties checked control intensive relatively simple dependencies data 
ran slam toolkit drivers windows driver development kit internally developed floppy device driver check proper usage locks proper handling interrupt request packets see details properties checked 
device drivers supposed exemplars base device drivers 
properties checked slam toolkit validated drivers errors 
floppy driver development slam toolkit error interrupt request packets handled 
table shows sizes drivers number predicates predicate input file number theorem prover queries bp run time bp 
examples section bebop ran seconds boolean program output bp 
array bounds checking heap invariants table shows results running bp set toy illustrative examples 
program kmp knuth string matcher qsort array implementation quicksort examples necula 
program partition list partition example list search example reverse example reverses list twice 
cases cone heuristics bp able reduce number theorem prover calls manageable number 
case reverse example pair pointers potentially alias cone influence heuristics avoid exponential number calls theorem prover 
freely available www microsoft com program lines predicates thm 
prover runtime calls seconds kmp qsort partition reverse table array heap intensive programs analyzed bp 
struct node int mark struct node void mark struct node list struct node tmp prev prev list traverse list mark setting back pointers mark break mark tmp prev prev prev tmp traverse back resetting pointers prev tmp prev prev prev tmp list traversal back pointers experiments able construct useful invariants code modeling predicates occurred program 
example array bounds checking examples kmp qsort array indexed loop variable index simply model bounds index index length order produce appropriate loop invariant 
cases component predicates invariant easy guess looking conditionals programs 
list reversal example reverse simplified version mark sweep garbage collector 
show program 
loop list traversed forward direction maintaining back pointers previous nodes 
second loop pointers reversed get original list 
wish verify procedure mark leaves shape structure unchanged node list points node procedure mark 
check introduced auxiliary variables code 
variable chosen non deterministically point non null element list initialized 
input predicates bp program mark prev prev choice predicates bp constructs program analyzed bebop 
bebop shows mark procedure holds 
related inspired predicate abstraction graf saidi 
predicate abstraction verification cache coherence protocols 
efforts specification level language guarded commands 
doing predicate abstraction general purpose programming language novel aspect 
method constructing models java programs developed bandera project 
tool requires user provide abstractions data types 
predicate abstraction implemented bp general allows finite partitioning variable possible values additionally allows relationships variables defined 
approach richer type systems model finite state abstractions programs 
shape analysis uses form predicate abstraction predicate language order logic augmented transitive closure 
contrast predicates quantifier free 
shape analysis requires user specify statement affects predicate interest bp tool computes transition system automatically theorem prover 
predicate abstraction general technique add predicate read path sensitivity program analyses 
ammons larus code duplication followed traditional dataflow analysis achieve path sensitive results 
bodik symbolic back substitution weakest preconditions followed value numbering improve results subsequent valued dataflow analysis 
combination predicate abstraction bp path sensitive dataflow analyses bebop achieve similar results 
prior generating loop invariants symbolic execution concrete semantics augmented widening heuristics 
houdini tool guesses candidate set annotations invariants uses esc java checker refute inconsistent annotations convergence 
contrast tools bp bebop combination abstraction program boolean program iterative analysis abstracted program find loop invariants expressible boolean functions set predicates 
summarize main contributions ffl bp predicate abstraction tool works general purpose programming language 
ffl taken efforts handle features procedures pointers sound precise way 
ffl explored optimizations reduce number calls theorem prover bp 
ffl demonstrated bp programs varying domains device drivers programs pointer manipulating programs 
fully support pointers bp predicates quantifier free 
stating certain properties unbounded data structures may require expressive logic 
purpose interesting enrich predicate language dependent types recursive types 
things aliasing problem complicated setting 
example type denotes lists length predicate true points object type consider assignment form null 
update consider possibility point inside list pointed way difficulty linear types encode external pointers list interesting investigate predicates expressible pointer logics 
focused predicate abstraction singlethreaded programs interesting extend bp multi threaded code 
issues need resolved 
needs establish appropriate notion atomicity execution 
abstracting statement account possibility interference thread 
abstraction possible model checking boolean programs threads undecidable 
possible solution boolean programs finite state machines traditional model checking algorithms explore interleaving executions finite state machines 
problem certain situations possible know number threads advance 
boolean programs finite state machines possible parameterized model checking handle arbitrary number threads 
clear abstractions performed automatically 
chosen source language predicate abstraction 
fundamental contribution set techniques handle procedure calls pointers predicate abstraction 
techniques adapted construct predicate abstractions programs written imperative languages java 
plan improve inefficiencies implementation 
theorem prover currently started separate process time inefficient 
fundamental issue currently theorem provers black boxes 
plan investigate opening internals theorem prover improve efficiency abstraction process 
generating predicates predicate abstraction tool bp open research problem 
currently building tool called newton slam toolkit frank pfenning observation 
generate predicates model checker counterexamples path simulation 
exploring predicate generation value flow analysis program respect properties interest 
current approach long properties interest relatively simple dependencies data 
data intensive properties predicate generation may widening heuristics 

andreas podelski helping describe bp tool terms interpretation 
das providing flow analysis tool 
developers ast toolkit microsoft research manuel ahndrich providing ocaml interface ast toolkit 
craig chambers interesting discussions bp 
members software productivity tools research group microsoft research enlightening discussions program analysis programming languages device drivers numerous contributions slam toolkit 
ammons larus 
improving data flow analysis path profiles 
pldi programming language design implementation pages 
acm 
ball chaki rajamani 
parameterized verification multithreaded software libraries 
tacas tools algorithms construction analysis systems lncs 
springer verlag 
ball millstein rajamani 
polymorphic predicate abstraction 
technical report msr technical report microsoft research 
ball podelski rajamani 
boolean cartesian abstractions model checking programs 
tacas tools algorithms construction analysis systems lncs 
springer verlag 
ball rajamani 
bebop symbolic model checker boolean programs 
spin spin workshop lncs pages 
springer verlag 
ball rajamani 
automatically validating temporal safety properties interfaces 
spin spin workshop lncs may 
blei proof generating theorem prover www eecs berkeley edu 
bodik 
path sensitive value flow analysis 
popl principles programming languages pages 
acm 
bryant 
graph algorithms boolean function manipulation 
ieee transactions computers 
corbett dwyer hatcliff pasareanu robby laubach zheng 
bandera extracting finitestate models java source code 
icse software engineering 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
popl principles programming languages pages 
acm 
das 
unification pointer analysis directional assignments 
pldi programming language design implementation pages 
acm 
das dill park 
experience predicate abstraction 
cav computer aided verification lncs pages 
springer verlag 
deline ahndrich 
enforcing high level protocols low level software 
pldi programming language design implementation 
acm 
detlefs nelson saxe 
simplify theorem prover research compaq com src esc simplify html 
dijkstra 
discipline programming 
prentice hall 
dwyer hatcliff laubach pasareanu robby visser zheng 
tool supported program abstraction finite state verification 
icse software engineering appear 
flanagan joshi leino 
annotation inference modular checkers 
information processing letters appear 
graf sa idi 
construction state graphs pvs 
cav computer aided verification lncs pages 
springer verlag 
gries 
science programming 
springer verlag 
heintze 
set analysis ml programs 
lfp lisp functional programming pages 
acm 
hearn 
bi assertion language mutable data structures 
popl principles programming languages pages 
acm 
lamport 
proving correctness multiprocess programs 
ieee transactions software engineering se 
landi ryder zhang 
interprocedural side effect analysis pointer aliasing 
pldi programming language design implementation pages 
acm 
morris 
general axiom assignment 
theoretical foundations programming methodology lecture notes international summer school pages 
reidel publishing 
necula 
proof carrying code 
popl principles programming languages pages 
acm 
nelson 
techniques program verification 
technical report csl xerox palo alto research center 
reps horwitz sagiv 
precise interprocedural dataflow analysis graph reachability 
popl principles programming languages pages 
acm 
reynolds 
intuitionistic reasoning shared mutable data structure 
perspectives computer science pages 

sagiv reps wilhelm 
parametric shape analysis valued logic 
popl principles programming languages pages 
acm 
sharir pnueli 
approaches interprocedural data analysis 
program flow analysis theory applications pages 
prentice hall 
suzuki 
implementation array bound checker 
popl principles programming languages pages 
acm 
xu miller reps safety checking machine code 
pldi programming language design implementation pages 
acm 
