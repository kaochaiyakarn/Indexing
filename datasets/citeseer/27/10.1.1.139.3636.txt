logic programming context multiparadigm programming oz experience peter van roy brand seif haridi martin christian schulte june oz multiparadigm language supports logic programming major paradigms 
multiparadigm language designed support different programming paradigms logic functional constraint object oriented sequential concurrent equal ease 
article goals give tutorial logic programming oz show logic programming fits naturally wider context multiparadigm programming 
experience shows classes problems call algorithmic search problems logic programming help give practical solutions 
algorithmic problems known efficient algorithms 
search problems known efficient algorithms solved search 
oz support logic programming targets classes specifically concepts needed 
contrast prolog approach targets classes set concepts results optimal support problem classes 
give examples run interactively mozart system implements oz 
explain essential difference algorithmic search programs define oz execution model 
model subsumes concurrent logic programming committed choice style search logic programming prolog style 
furthermore consequences multiparadigm nature model supports new abilities class top levels deep guards active objects sophisticated control search process 
horn clause syntax oz simple fully compositional higher order syntax accommodates abilities language 
give brief history oz traces development main ideas summarize lessons learned 
give entry points oz literature 
experience logic programming help give practical solutions 
problems divided classes uses totally different approach article extended version tutorial talk logic programming oz mozart international conference logic programming las cruces new mexico nov 
knowledge traditional logic programming prolog concurrent logic languages assumed universit catholique de louvain louvain la neuve belgium 
email pvr info ucl ac swedish institute computer science sweden 
email sics se universit des saarlandes germany 
email ps uni sb de royal institute technology kth sweden 
email seif kth se national university singapore singapore 
email comp nus edu sg royal institute technology kth sweden 
email schulte kth se 
algorithmic problems 
problems efficient algorithms known includes parsing rule expert systems transformations complex symbolic data structures 
problems logical specification algorithm simpler imperative specification 
case deterministic logic programming concurrent logic programming natural ways express 
simpler 
imperative specification better problems state updating frequent 
graph algorithms ofthe type 
search problems 
problems efficient algorithms known may algorithms possible principle algorithms explicit 
cite np complete problems problems complex specifications algorithms difficult reason 
examples search problems optimization problems planning scheduling configuration natural language parsing theorem proving 
kinds problems solved doing search nondeterministic logic programming 
dangerous tool 
naively scale real applications 
size search space grows exponentially problem size real application possible effort reduce need search strong global constraints concurrency cooperative constraints heuristics forthe search tree 
see 
problems complex specifications sufficiently strong constraints results polynomial time algorithm see 
consider logic programming programming executable simple logic order predicate calculus 
oz support logic programming targeted specifically classes algorithmic problems problems 
part article sections shows write logic programs oz problems 
section introduces deterministic logic programming targets algorithmic problems 
simple direct way doing logic programming oz 
section shows nondeterministic logic programming style 
targets algorithmic search problems pedagogical interest 
section shows concurrent logic programming tradition 
targets algorithmic problems 
section extends section state 
experience state essential practical concurrent logic programming section expands section show search practical 
second part article sections focuses essential difference techniques solve algorithmic search problems 
leads wider context multiparadigm programming 
section introduces oz execution model strict functional core extensions concurrency lazy evaluation exception handling security state search 
section explains extensions dif ferent combinations provide different programming paradigms 
particular section explains abstraction computation spaces main tool doing search 
spaces possible deep synthesis concurrent constraint logic programming 
section gives overview research multiparadigm programming oz 
section summarizes lessons learned oz project practical logic programming multiparadigm programming article gives informal precise targeted prolog programmers 
complete presentation logic programming oz programming concepts textbook 
deterministic logic programming call deterministic logic programming case algorithm control flow com pletely known specified programmer 
search needed 
perfectly adapted sequential algorithmic problems 
example deterministic naive reverse canbe written follows oz append xs ys zs case nil zs ys xr zr zr append xr ys zr proc nrev xs ys case xs nil ys nil xr nrev xr append ys syntax vaguely familiar people knowledge prolog func tional programming 
explain briefly pointing differs prolog 
capitalized identifiers refer logic variables constraint store nrev procedures arguments passed unification prolog 
declares new global identifiers append nrev bound newly created procedure values 
means order declarations matter 
local variables declared scope zr declare scopes enclosing keyword 
list atom nil element list xr written xr 
empty list case statement similar guarded command case sequential 
explain briefly semantics naive reverse highlight relationship programming 
constraint store consists equality constraints rational trees similar provided modern prolog systems 
statements 
basic operations store ask tell tell operation ys nil adds constraint performs unification 
tell isan incremental tell constraint inconsistent store consistent part added exception raised see formal definition :10.1.1.14.1008
ask operation case statement case xs xr 
waits information store decide matched entailment matched 
example written functional syntax 
find functional greatly improves readability programs 
especially useful follows data flow input output arguments 
oz definition nrev follows append xs ys case xs nil ys xr append xr ys including append nrev bound procedure values lexically scoped closures 
fun nrev xs case xs nil nil xr append nrev xr just syntactic sugar procedural definition 
oz function just writing procedure procedure argument function output 
statement ys nrev xs identical semantics procedure call nrev xs ys semantics outlined follows append nrev search information continue computation simply block 
example take calls declare append append declare introduces new variables 
call append completion append need value second argument 
binding second call append suspend executing 
case statement information decide binding done 
thread binds execution 
oz supports deterministic logic programming 
purely declarative operational semantics fully specified deterministic 
programs translated straightforward way horn clause syntax 
tions performed resolution 
execution seen functional programming logic variables dynamic typing carefully designed logical semantics 
higher order procedures functional language higher order logic programming 
higher order procedures useful help structure programs 
find adding logic variables functional programming important reasons 
allows deterministic logic programming straightforward way 
second increases expressiveness allowing powerful programming techniques basedon incomplete data structures tail recursive append difference lists 
third reason important adding concurrency execution useful form concurrent programming called declarative concurrency 
nondeterministic logic programming call nondeterministic logic programming situation search 
search allows finding solutions algorithm known 
oz provides choice statement simple way introduce search 
choice choice point alternatives 
choice statement allows prolog style generative execution 
programming scale real world search problems 
opinion primary value pedagogical exploratory 
small explore understand problem structure 
understanding efficient precise search general technique works problem giving just problem specification impractical brute force exploration potentially large search space 
search efficient incorporating problem specific knowledge games programmed alpha beta search 
problems small search space may sufficient 
example practical diagnostics generator vlsi bam microprocessor written prolog 
algorithm designed 
naively search large search space explosion 
search fundamental part constraint programming 
area techniques devised reduce greatly search space explosion 
see section scalable way search nondeterministic naive reverse choice proc append xs ys zs choice xs nil zs ys xr zr xs xr zs zr append xr ys zr proc nrev xs ys choice xs nil ys nil xr xs xr append nrev xr ys examples leave declare brevity 
higher order programming direct translation horn clause syntax prolog append xs ys zs xs nil zs ys 
append xs ys zs xs xr zs zr append xr ys zr 
nrev xs ys xs nil ys nil 
nrev xs ys xs xr nrev xr yr append yr ys 
oz program run depth search semantics identical 
controlling search program nondeterministic naive reverse called ways search similar prolog top level eager search interactive search explorer tool 
search abilities programmed oz computation space see section 
programmer spaces directly predefined search search module see section example introduce abstraction called search object similar prolog top level 
depth search queried obtain 
steps needed declare 
define new search query proc append sol 
set new search engine new search object script 
get display solution repeated local browse explain steps lazy search different lazy evaluation program explicitly request solution see section 

procedure defines query returns solution single argument oz higher order language query statement 
example solution parts pair tuple sol 

search object instance class search object 
object new initialized message script 

object invocation finds solution query isa solution bound list containing single element 
solutions bound nil 
browse tool provided system data structures 
running example call displays solution sol nil element list containing solution 
successive calls display solutions sol sol nil 
solu tions nil displayed element list standard oz approach search problems require 
solve algorithmic problems need learn search language 
thisis prolog search ubiquitous procedure application defined terms resolution search 
oz choice statement explicitly creates search abstractions search object encapsulate 
choice statement bit simplistic choice point statically placed 
usual way add choice points oz abstractions create choice point depending state computation 
heuristics called distribution strategy 
example procedure fd distribute specify distribution strategy problems finite domain constraints 
section gives example approach 
concurrent logic programming concurrent logic programming programs written set don care predicates concurrently 
clause chosen predicate invocation nondeterministic way clauses guards true 
style incomplete just deterministic logic programming 
small part search space explored due guarded clause selection 
advantage concurrent concurrency essential programs interact environment agents gui programming os interaction type 
concurrency permits program organized parts execute independently interact needed 
important property 
section show concurrent logic programming oz 
fact language allows concurrency search see section 
clean integration single language major strengths oz 
achieved oz immediate ancestor akl 
oz shares aspects akl improves particular compositional higher order 
implicit versus explicit concurrency early concurrent logic programming systems concurrency implicit driven solely dependencies 
body goal implicitly ran thread 
hope parallel execution easy 
hope realized 
overhead implicit concurrency high parallelism limited rewriting programs detecting program termination hard 
reduce overhead possible lazy thread creation create new thread thread suspend 
approach nice slogan sequential possible concurrent necessary allows efficient implementation 
approach inadequate reasoning programs remains hard 
implementing experimenting implicit concurrency lazy current oz decision explicit thread creation see section 
explicit thread creation simplifies debugging reasoning programs efficient furthermore experience shows parallelism speedup harder obtain programmer responsibility know parts program run parallel 
concurrent producer consumer classic example concurrent logic programming asynchronous producer consumer program asynchronously generates stream integers sums 
stream list tail unbound logic variable 
tail bound forth 
proc generate limit xs limit xr xs xr generate limit xr xs nil proc sum xs case xs xr sum xr nil local xs generate xs producer sum xs consumer thread browse executes expected concurrent logic programming framework 
producer generate consumer sum run threads 
communicate variable xs stream integers 
case statement sum xs bound value example exactly producer feeding exactly consumer 
need nondeterministic choice 
general cases client server clients feeding server 
server know client send request 
nondeterministic choice added directly operation section 
turns practical state 
nondeterministic choice consequence having state concurrency shown section 
lazy producer consumer producer consumer example producer decides generate 
called supply driven eager execution 
efficient technique total amount finite system resources memory calculation time 
hand total potentially uses resources may better demand driven lazy execution 
lazy execution consumer decides list elements generate 
extremely potentially unbounded number list elements needed lazy execution fewer system resources point time 
problems impractical execution practical lazy execution 
lazy execution implemented ways oz 
way language explicit triggers 
producer consumer modified consumer asks producer additional list elements 
example logic variables explicit triggers 
consumer binds stream producer waits binds list element explicit triggers cumbersome require producer accept explicit communications consumer 
better way language support 
language semantics ensure function evaluated result needed 
oz supports syntactically annotating function lazy previous example lazy function generates potentially infinite list fun lazy generate generate proc sum xs limit limit case xr sum xr limit local xs xs generate thread sum xs browse consumer sum decides list elements generated 
addition implicitly triggers generation new list element lazy execution part execution model section explains works 
coroutining sequential systems support coroutining simple way get abilities 
coroutining form non preemptive concurrency single locus control switched manually different parts program 
experience efficient preemptive concurrency needs coroutining 
modern prolog systems support coroutining 
coroutining ic prolog indirectly means operation called provides data driven computation 
freeze operation called prolog ii pioneered sets system invoke goal variable bound 
freeze possible non explicitly hand control binding variables 
prolog search global backtracking threads independent threads may forced backtrack 
prolog programming techniques depend backtracking search deep conditionals exceptions program switch threads 
explicit state theoretical point view explicit state considered forbidden fruit programming 
find explicit state important fundamental reasons related program modularity see chapter exist tools state prolog keeping logical semantics possible 
see example sicstus objects prolog logical state 
ancestor help write prolog compiler functional programmers incorporated state functional languages means set operations lisp scheme ml monads :10.1.1.100.9674
cells mutable state explicit part basic execution model oz 
model defines cell kind mutable 
cell pair name operations cells create new cell name content exchange update content bind old content exchange atomically accesses current content defines new content oz full featured concurrent object system completely defined terms cells 
object system includes multiple inheritance fine grained method class messages 
sections gives information cells explains underlie object system 
ports communication channels section equivalent way add state basic model 
isthe concept port pioneered akl 
port pair name stream xs 
operations ports newport xs create new port name stream xs send add port stream asynchronously send asynchronously adds element port stream 
port keeps stream unbound tail 
repeated sends thread cause elements appear order sends 
ordering stream 
ports gives ability named active objects 
active object form pairs object thread 
thread reads stream internal external messages invokes object message 
erlang language basedon idea 
erlang extends adding object mailbox retrieval pattern matching cells natural define non active objects called passive objects shared threads 
ports natural define active objects send messages 
theoretical point view programming styles expressiveness cells ports defined terms 
practice depending application style convenient 
database applications centered shared data repository shared object style natural 
multi agent applications defined terms collaborating active entities find active object style natural 
relevance concurrent logic programming perspective concurrent logic programming explicit state amounts constant time way stream merge grow arbitrarily large run time 
thatis number threads concurrently send port send take constant time 
seen ability give identity active object 
class value stored data structure passed argument 
know identity send message active object explicit state impossible build kind merge 
known run time solution build tree stream mergers 
senders message sending time log 
know simple way solve adding explicit state execution model 
creating active object example uses port active object proc xs case xs xr browse xr skip declare global xs xs local scope newport xs thread xs sending sends active object 
number clients send active thread send send client thread send send client elements appear fairly stream xs 
port fairness thread fairness mozart implementation 
compact way define active object thread thread forall xs proc browse notation proc defines anonymous procedure value identifier 
forall high order procedure applies unary elements list 
forall keeps dataflow synchronization traversing 
example higher modularize program iteration separated action performed iteration 
search introduced search section means choice statement andthe lazy depth abstraction search object 
programming style shown realistic problems 
section shows search practical oz 
scratch surface search oz information finite domain finite set tutorials mozart system documentation 
aggregate search powerful features prolog ability generate aggregates built operations setof bagof 
easy oz just special cases search abstractions 
section show implement bagof 
consider small database taken proc father choice abraham abraham isaac lot consider prolog predicate children kids bagof father kids 
defined oz follows proc kids proc father search base kids procedure lexically scoped closure external hidden inside written compactly anonymous procedure value proc kids search base proc father kids search base abstraction takes argument procedure returns list solutions procedure 
example call browse returns abraham 
definition deterministic known returns kids 
search different values give definition proc kids father search base proc father kids call father creates choice point syntactic sugar local xin just new variable tiny scope 
example call browse search base kids kids kids returns sol abraham sol abraham sol abraham sol abraham isaac sol lot sol lot sol lot prolog bagof existential quantification 
example prolog predicate children kids bagof father kids 
collects children exists father 
defined oz follows proc children kids search base proc father kids oz solution uses add new existentially scoped variable 
prolog solution hand introduces new concept existential quantifier notation meaning terms setof bagof 
fact existential quantifier arbitrary 
oz solution introduces new concepts 
really existential quantification inside search query 
simple search procedures procedure search base shown previous section just set procedures provided oz elementary nondeterministic logic programming 
give short overview information see system modules documentation system 
procedures take argument unary procedure solution generated 
lazy search provide depth search solution branch bound search cost function 
procedures basic search 
simplest extra parameters needed 
general purpose search 
allows parameterizing search distance optimizing time memory asynchronous kill procedure allow stopping infinite searches option return solu tions directly encapsulated computation spaces see section 
search implemented spaces strategies combining cloning recomputation com time memory systems trailing 
encapsulation general purpose search primitive build sophisticated searches 
parallel search 
provided list machines spread process machines transparently 
benchmarked realistic constraint problems machines linear speedups 
search tree explored nondeterministic different depth breadth 
entire tree explored number steps depth search 
speedup consequence fact spreading 
lazy search 
provides solution solution operations opera tion close operation 
class prolog top level 
explorer search 
explorer concurrent graphic tool allows interactively guide search process 
invaluable search debugging gaining understanding structure problem 
procedures implemented oz computation spaces see section specialized search procedures available constraint programming user easily define 
scalable way search original motivation doing search oz comes constraint programming 
todo search oz uses concurrent version approach widely sequential constraint logic programming declaratively specify problem means constraints 
constraints operational declarative reading 
operational reading specifies deductions constraints locally 
get results able deductions big parts problem deductions consider problem variables 
constraints called global 
second define explore search tree controlled way heuristics problem structure 
general technique called propagate distribute alternates propagation steps constraints distribution steps choice selected choice point see explanation 
approach widely applicable 
example applied successfully com putational linguistics 
section show solve simple integer puzzle 
consider problem finding distinct digits holds bc ef hi bc represents integer constraint problem follows functor fractions name module fd needs module script script defines proc script sol bc ef hi sol sol bc fd decl ef fd decl hi fd decl constraints sol letter represents digit fd distinct sol digits definition definition definition ef hi bc hi bc ef bc ef hi main constraint distribution strategy content search tree fd distribute ff sol unary procedure script sol fully defines problem distribution strategy problem specified conjunction constraints sol bound contains solution 
record fields solution variable 
problem constraints expressed terms finite domains finite sets integers example notation represents set 
constraints defined inthe module fd 
example fd distinct global constraint asserts component variables distinct integers 
term distribution refers distribution logical formula distributed systems 
precise sol bound feature tree logical formulation record 
sn 
constraint store person age monotonic mutable store nonmonotonic proc thread store trigger store xc oz store fractions defines script inside functor module specification oz ogy 
functor defines explicitly process specific resources module needs 
allows set parallel search engine spreads constraint solving 
execution process functor needed define procedure script 
set parallel search engine new search adventure rsh galley rsh rsh sets engine machines adventure galley 
implemented computation spaces see section mozart support distributed computing see 
single process created machines usingthe remote shell operation rsh operations possible including secure shell ssh communication local shell sh shared memory multiprocessors 
parallel search problem specified fractions local fractions browse installs functor fractions machines generates 
example scalable way search global constraints search heuristics parallel execution necessary performance oz currently advanced languages programming search 
competitors claire salsa opl 
search important part programming general 
oz execution model far highlighted different parts oz showing interact thing elephant different things different people 
section gives simple execution model underlies 
define execution model store section kernel language section 
section explains different subsets kernel language support different programming paradigms 
sec tion explains supporting multiple paradigms useful 
section defines computation spaces program search 
hsi skip xi hxi xi hli hfi hxi si hsi local xi hsi xi hsi hsi case xi hli hfi hxi hsi hsi proc hxi hyi hsi hxi hyi core thread hsi concurrency hxi hyi laziness try hsi catch hxi hsi raise xi exceptions newname hxi security hxi hyi hxi hyi exchange hxi hyi state search oz kernel language store oz store consists parts see thread store constraint store store trigger store 
constraint store contains equality constraints domain rational trees 
words store contains logic variables bound 
bound variable term atom record procedure name arguments may bound unbound 
unbound variables unbound variables case identical 
constraint store monotonic bindings added removed changed mutable store consists mutable constraint store 
mutable called cells 
mutable consists parts name value content constraint store 
mutable store nonmonotonic mutable changed trigger store consists triggers pairs variables argument procedures 
triggers part basic execution model implicit triggers opposed explicit triggers section 
triggers implement need computation lazy execution installed operation 
say triggers article 
information see 
thread store consists set threads 
thread defined statement si threads constraint store stores 
means way threads communicate synchronize constraint store 
say thread runnable called ready execute statement 
threads dataflow threads thread runnable arguments needed statement bound 
argument unbound thread automatically suspends argument bound 
constraint store thread runnable stay runnable executes step statement 
system guarantees weak fairness implies runnable eventually execute 
kernel language oz execution defined terms simple kernel language syntax 
full oz language provides syntactic support additional language entities functions ports objects classes functors 
system hides respecting definitions terms kernel language 
performance optimization seen second kernel language full oz andthe kernel language 
second kernel language implemented directly 
kernel language viewpoint ary functions just ary procedures argument function output 
statements denoted hsi computation space operations see logic variables hxi hyi record labels li record field names hfi semantics kernel language spaces spaces 
comparison semantics original oz language kernel language splits naturally parts core core strict functional programming constraint store 
ex deterministic logic programming explicit sequential control 
statement expects boolean argument true false 
case statement patternmatching 
local statement introduces new variables declare syntactic variant scope extends program 
concurrency concurrency support adds explicit thread creation 
core gives dataflow concurrency form declarative concurrency 
compared sequential program gives results 
deterministic logic programming flexible control core 
discussed length 
laziness laziness support adds operation allows ex press lazy execution basic idea nonstrict functional languages haskell core gives demand driven concurrency form declarative concurrency 
lazy execution gives results eager execution calculates needed achieve results 
deterministic logic programming flexible control core 
important resource management program modularity 
lazy give results cases eager execution terminate 
exceptions exception handling support adds operation try exception context operation raise jump innermost enclosing exception context 
security security support adds name values unforgeable printable representation 
calling newname creates binds name class right key supports techniques related security encapsulation 
state state support adds explicit cell creation exchange operation reads cell content replaces new content 
sufficient sequential object oriented programming :10.1.1.14.1008
equivalent way state means ports explained section 
mozart module value contains operation value 
search search support adds operations computation spaces shown ash explained section 
allows express tic logic programming see sections 
computation space encapsulates choice point don know nondeterminism allowing program decide alternatives 
section explains spaces detail shows program search 
choice statement examples sections programmed spaces see section 
concurrency state adding concurrency state core results expressive 
basic approaches program message passing active objects atomic actions shared state 
active objects erlang 
atomic java concurrent object oriented languages 
approaches expressive power appropriate different classes applications multi agent versus data centered 
nondeterministic choice concurrent logic programming obtained extending core concurrency choice 
gives model expressive declarative concurrency expressive concurrency state 
means wait concurrently conditions true 
example add operation core concurrency 
bound nonvariable term returns 
return bound bound 
need added programmed core concurrency state 
lazy functions lazy annotation section defined terms 
calling adds trigger trigger store 
behave read variable doing computation needs attempts bind block computation execute new thread bind continue 
say value needed thread executing operation suspend value 
example function fun lazy generate generate defined fun generate proc generate called value generate needed 
definition 
lazy annotation explicitly programmer functions eager 
second mozart threads extremely lightweight definition practical 
different approach nonstrict languages mozart module record contains operation written record 

concurrent lp concurrency sequential oop declarative concurrency nondeterministic lp lazy fp deterministic fp concurrent oop dataflow passive objects threads concurrent lp fast merge active objects messages kernel language concurrency concurrency different viewpoints concurrency lp search programming core core core core state core state programming paradigms oz haskell lazy evaluation default strictness analysis regain eager evaluation 
multiparadigm programming different programming styles paradigms possible limiting oneself dif ferent subsets kernel language 
popular styles object oriented programming programming state encapsulation inheritance functional programming pro gramming values pure functions constraint programming programming deduction search sequential programming programming totally instructions 
interesting subsets kernel language shown 
full oz language provides syntactic implementation support paradigms equally easy 
execution model simple general allows different styles coexist comfortably 
ability known programming 
justification limiting oneself particular paradigm program easier write reason 
example thread construct program purely sequential 
operation program 
experience shows different levels abstraction need different paradigms see section 
basic functionality provided may view different paradigms depending application needs 
possible simple kernel language support different 
paradigms concepts common figures show 
example sequential object oriented programming built adding just state see details procedures behave objects internally state :10.1.1.14.1008
methods different procedures state 
classes records group related method definitions 
inheritance operation takes set method definitions records constructs new class record 
creation new object instances done higher order procedure takes associates new state pointer 
oz syntactic support style easy implementation support efficient 
applies declarative paradigms functional logic programming 
strict functions restricted versions procedures binding 
lazy functions implemented logic programming procedures relations logical semantics addition operational semantics 
true core 
remains true adds concurrency laziness core 
illustrate logical semantics examples article starting section 
core case statements logical semantics check entailment 
execution complete find constructive proof exists necessary 
oz supports search means computation spaces 
combined rest model possible program wide variety search algorithms oz explained section 
computation spaces computation spaces powerful abstraction permits high level programming abstractions deep guard combinators important constraint logic programming 
spaces natural way integrate search 
spaces implemented efficiently real world problems mozart implementation copying recomputation competitive time memory traditional systems trailing backtracking 
spaces compositional nested important building structured programs section defines computation spaces operations performed see gives examples program search 
section follows model 
model implemented mozart refines articles :10.1.1.14.1008
space abstraction language independent describes implementation similar abstraction supports trailing copying 
definition computation space just oz store parts 
store seen single computation space equality constraints rational trees 
deal search extend ways 
allow spaces nested 
second constraint systems space 
spaces encapsulate potential variable bindings important precise visibility variables bindings 
gives example 
general rules structure computation spaces follows top level computation space threads may interact world 
top level space just store section 
top level space interacts external world constraint store variable binding changes 
thread tries add inconsistent binding top level raise failure exception 
thread may create new computation space 
new space called child space current space child parent space 
time tree computation spaces top level space root 
respect space tree closer root called ancestor lower called descendant 
space space top level space ancestors ta term threads ta tb tc variable tb binds tb tc binding 
ta won space merged space space tc descendants parent parent binding sees sees current space sees parent tc sees ta tb don 
visibility variables bindings nested spaces thread belongs exactly computation space 
variable exactly computation space 
thread sees may access variables belonging space 
thread see variables descendant spaces 
thread see variables child space child space parent 
space merging explicit program operation 
causes child space disappear child content added parent space 
thread may add bindings variables visible 
means may belonging space ancestor spaces 
binding visible current space descendants 
parent space binding current space merged 
thread child space tries add inconsistent binding constraint store space fails 
state space space runnable descendant contains runnable thread blocked run threads space descendants space blocked 
space states space stable 
means additional bindings done ancestor space runnable 
stable space states space succeeded 
means contains choice points 
contains solution 
space distributable 
means space thread choice point alternatives 
space choice point attempting create gives run time error 
space failed 
defined previous section means attempted bind variable different values 
execution happens space 
space merged 
means space discarded store added parent 
operation space error 
state space lifetime 
space suspended 
means additional bindings done ancestor space runnable 
suspended usually temporary condition due concurrency 
means ancestor space transferred space 
space stays suspended indefinitely usually indicates programmer error 
programming search search strategy defines search tree explored depth search best search branch bound search 
distribution strategy defines shape content search tree alternatives exist constraint added alternative 
computation spaces program search strategies distribution strategies independent 
search strategy distribution strategy 
done create space initialize running internal program defines constraints space 
propagate information inside space 
constraints space 
oz terminology operationalized version constraint called propagator 
propagators execute concurrently propagator executes inside 
propagator reads arguments attempts add information constraint store restricting domains arguments 
propagators execute information added store 
fixpoint calculation 
information added fixpoint reached space stable 
space execution computation inside space decide create point 
decision constraint add alternative defines distribution strategy 
space threads suspend choice created 
space stable execution continues outside space 
different possibilities depending choice point created space 
execution return solution 
search strategy decides alternative choose commits alternative 
notice distribution strategy problem dependent add constraint know problem constraints 
hand search strategy pick alternative need know constraint 
section explains operations need implement approach 
section gives examples program search 
hxi hyi choose hxi hyi ask hxi hyi commit hxi hyi clone hxi hyi inject hxi hyi merge hxi hyi primitive operations computation spaces space operations know define primitive space operations 
see 
unary procedure creates new computation space space fresh variable called root variable created new thread 
choose operation executes inside space 
creates alternatives 
blocks waiting alternative chosen commit operation space see 
choose call defines numberof alternatives specify alternative 
choose alternative chosen 
maximum choice point space time 
ask asks space status 
soon space stable 
failed merged succeeded bound failed merged succeeded 
distributable alternatives number 
commit distributable space causes blocked choose call continue result 
may cause stable space 
space resume execution new fixpoint reached 
integer satisfy argument choose call 
clone stable space creates identical copy clone alternatives distributable space explored independently 
inject similar space creation uses existing space new thread space invokes thread root variable 
may cause stable space stable 
space resume execution new fixpoint reached 
adding constraints space necessary search strategies branch bound saturation 
merge binds root variable space discards space 
spaces primitive operations define search strategies distribu tion strategies 
basic technique choose ask commit inside space outside space 
shows communication works space informs search strategy total number ask case alternatives commit 
choose case 
block 
synch alternative pass 

run alternative 
pass 
synch stability parent space search strategy computation space 

calculate alternative 
block 
communication space search strategy alternatives 
search strategy picks informs space 
briefly examples spaces 
complete information examples examples refer reader 
depth search 
example implements search strategy 
program depth single solution search case binary choice points 
explores search tree depth manner returns solution finds 
defined unary procedure script sol gives solution sol just example section 
solution returned element list sol 
solution nil returned 
script choice points choose operation 
naive choice point 
second example implements distribution strategy 
naive choice point defines set alternative statements chosen 
defined follows case choose 
oz provides convenient syntax technique choice 
sn exactly choice statement defined 
statement strategy depth strategy defined previously strategies 
andorra style disjunction dis statement 
define slightly distribution strategy 
define dis statement extension choice eliminates failed alternatives commits immediately single dis 
gn sn fun dfe case ask failed nil succeeded alternatives clone commit case dfe nil commit dfe procedure script sol returns solution sol nil fun dfs script case dfe script nil nil merge depth single solution search contrast choice alternative dis statement guard body guards immediately check failure 
guard gi fails eliminated 
extension called determinacy directed execution 
discovered warren called andorra principle dis statement programmed space operations follows 
encapsulate guard dis statement separate space 
execute stable 
discard failed guards 
choose operation create point remaining guards 
see details implementation 
optimized argument indexing similar way prolog systems 
implementation written language 
fail strategy 
practice dis strong solving real 
static alternatives defined textually program code 
sophisticated distribution strategy look closely actual state 
example fail strategy finite domain constraints looks variables places choice point variable domain smallest 
fail implemented choose set reflective operations finite 
mozart system provides fail preprogrammed strategies 
deep guard combinators 
constraint combinator operator takes arguments combines form constraint 
spaces powerful way implement constraint combinators 
spaces compositional resulting con straints inputs constraint combinators 
reason combinators called deep guard combinators 
powerful reification flat input constraints limited simple combinations built constraints 
examples deep guard combinators deep negation generalized reification propagation disjunction dis constructive disjunction deep committed choice 
related give brief overview research area multiparadigm programming 
give short history oz 
multiparadigm languages integration paradigms active area research produced variety differ ent languages 
give brief glimpse area 
pretend exhaustive subject 
far know covers paradigms oz equitable way simple formal semantics efficient implementation 
early discussion programming oz 
gives examples functional logic object oriented styles short term solution integrate different paradigms coordination model 
prototypical coordination model linda provides uniform global tuplespace accessed small set basic operations concurrent reads writes process connected 
linda layer act glue different paradigms 
look substantive solutions 
imperative paradigm efforts add abilities programming 
smalltalk blocks lexically scoped closures 
java inner classes minor limitations lexically scoped closures 
final annotation allows programming stateless objects 
ner classes final allows functional programming java 
verbose discouraged 
ambitious efforts libraries fc language extensions pizza brew translate 
provide better support functional programming 
functional paradigm easiest way allow imperative programming locations destructive assignment 
route taken languages lisp scheme sml 
structures id successor ph fall category 
objective caml popular object oriented dialect ml takes approach 
oz takes approach building object system core adding cell location primitive 
haskell state integrated monadic style programming continuation passing style :10.1.1.100.9674
haskell nonstrict language easily add locations destructive assignment 
monadic style allows control necessary various kinds side effecting error handling nondeterministic choice 
imposes global state threading integrated concurrency 
see discussion relative merits state threading approach versus location approach logic paradigm attempts add object system 
prominent examples prolog sicstus objects 
approaches primitives functional approach 
functions added ways logic languages 
approach life provides functions kind relation called entailment function call waits arguments information 
delaying mechanism 
second approach extends basic resolution step include deterministic evaluation functions 
execution strategy called narrowing curry language 
third approach taken lambda prolog 
uses powerful logic horn logic basis programming 
particular supported providing terms data structures handled aform higher order unification 
fourth approach taken hilog introduces higher order syntax encoded order predicate calculus 
oz approach provide class procedure values consider purposes unification 
approach cleanly separates logical aspects higher order programming aspects 
approaches mentioned tied resolution operation 
addition oz approach provides full power lexically scoped closures values language 
oz provides entailment operation allows implement call entailment 
erlang notable example multiparadigm language especially 
erlang programs consist active objects send messages 
strict functional language program internals active objects active object contains thread runs recursive function 
object state contained function arguments 
model extended distribution tolerance 
layered approach taken ph language designed defining implicit parallelism 
core haskell nonstrict functional language 
extensions 
extension single assignment data type structures 
write functional programs dataflow behavior 
second extension mutable data type structures 
allows stateful programs 
design similarities oz logic variables single assignment extension cells mutable extension 
concurrent logic programming investigated depth logic variables syn communication 
expressive mechanisms practical concurrent programming 
logic variables constrained monotonically allow express monotonic synchronization 
allows declarative concurrency concurrent programming observable nondeterminism 
concurrent strand evolved coordination language pcn imperative languages 
functional programming community futures multilisp id allow synchronize result concurrent computation 
realize restricted form logic variable 
goffin project uses order language coordination language haskell processes 
multiparadigm language leda developed educational purposes 
se supports strict functional object oriented programming basic support backtracking simple form logic programming subset prolog 
history oz oz part long line logic languages originated prolog see summarize briefly evolutionary path give important milestones way 
experiments concurrency done ic prolog coroutining simulate concurrent processes 
led parlog concurrent prolog introduced process model logic programming concurrent logic programming 
advent ghc guarded horn clauses simplified concurrent logic programming considerably introducing quiet guards 
clause matching goal fire guard entailed constraint store 
formulation theoretical underpinning maher saraswat gave solid foundation concurrent logic programming 
main insight logical notions equality operational reading 
saraswat concurrent constraint model model concurrent programming logical foundation 
model basis languages including akl oz 
practical side systems flat guards limited basic system provided tests focus 
flat versions concurrent prolog ghc called fcp respectively developed large systems 
kl kernel language language derived implemented high performance system 
system runs sequential parallel distributed ghc akl life 
oz oz oz kl fcp explicit thread creation computation spaces distribution resources laziness quiet guards parlog concurrent prolog ic prolog coroutining concurrent logic programming encapsulated search state ports prolog sequential logic programming maher saraswat flat guards higher order compositional solve combinator history oz machines 
implementation techniques current mozart system notably distributed garbage collection algorithm 
important subsequent development akl andorra kernel language added state form ports encapsulated search efficient implementation deep guards :10.1.1.21.1017
akl language combines abilities constraint concurrent logic programming 
akl implements encapsulated search precursor computation spaces 
local propagation space different disjuncts program try disjunct cloning computation space initial oz language oz inspired akl life added higher order procedures programmable search solve combinator expressive spaces compositional syntax cell primitive mutable state :10.1.1.14.1008
oz features new record data type inspired life 
concurrency oz implicit lazy thread creation 
statement blocks new thread created contains blocked statement 
main thread suspended statement 
oz features concurrent object system designed lazy thread creation state threading monitors oz improves predecessor oz improved concurrency model improved model encapsulated search 
oz replaces solve combinator oz spaces 
contrast solve combinator spaces allow programming important search strategies parallel search oz explorer strategies 
oz abandons implicit concurrency favor explicit thread creation construct 
thread suspension resumption dataflow logic vari ables 
experience shows explicit concurrency easier user resources 
allows language efficient expressive object system sequential state threading method definitions 
allows simple easy add exception handling language 
current oz language oz conservatively extends oz support class module specifications called functors open robust distributed programming 
functor specifies module terms modules 
distribution transparent language semantics unchanged independent program distributed 
respect logic programming properties top level space efficiently distributed multiple processes 
particular level store implemented practical algorithm distributed rational tree unification 
child computation space stationary entity exists completely process due communication overheads involved worthwhile distribute child space multiple processes 
constraint propagation space completely centralized 
parallel search engines see example section implemented putting child spaces different processes 
versions oz concurrency intended primarily model logical concurrency achieve parallelism speedup implementation 
distributed implementation useful parallel execution 
optimized par efficient shared memory multiprocessors 
case experimented implementation interprocess communication shared pages 
lessons learned goals oz project logic programming real world problems course project tried implementations programming techniques built applications 
experience learned practical logic programming multiparadigm programming 
summary important lessons 
agree higher order procedures essential laziness demand driven execution useful 
explicit magic provide explicit concurrency older concurrent logic programming systems im plicit concurrency 
important interaction environment efficiency facilitating reasoning termination debugging 
important programming 
provide explicit search prolog implicit search 
majority prolog algorithmic problems need search prolog learning search 
furthermore search problems search scale real applications 
prolog implicit search weak means inefficient approaches meta interpreters 
conclude prolog search ineffective algorithmic search problems 
provide explicit state java state implicit java variables declared final 
explicit state mean language declare mutable needed 
explicit state complicates reasoning programs costly implement distributed system 
hand explicit state crucial modularity change program component having change components 
provide explicit laziness haskell laziness implicit functions 
functions lazy easy implement documents programmer intention 
allows system pay laziness second reason declarative concurrency supporting requires eager lazy functions 
third reason explicit state 
implicit laziness harder reason functions explicit state 
order function evaluation determined syntax 
provide primitives building abstractions full compositionality essential nested 
requires higher order procedures lexical scoping 
user defined abstractions carefully designed fully compositional 
language complete easy define new abstractions developer primitives necessary build powerful abstractions 
example addition lexical scoping important read allow build abstractions export logic variables protect 
distinction built abstractions application possibly regarding performance 
examples built abstractions object system reentrant locks distribution support user interface support 
factorize lean complexity source problems reduced possible factorize design levels abstraction language implemen tation 
keep number primitive operations minimum 
goal conflict goal having efficient implementation 
satisfying difficult possible 
approach helps second kernel language explained section 
approach loosening tightening 
develop system semi independent stages stage factored stage brings factors 
typical example compiler consisting code generator followed smart peephole optimizer 
important sophisticated module system lazy loading mutually dependent modules support application deployment 
mozart oz modules loaded lazily module needed way system lean lots functionality 
lazy loading oz modules implemented operation see section 
support dependent oz modules means cyclic dependencies need bottom run time load time 
turns important practice depend 
support application deployment includes ability statically link collection modules single module 
modules offered users 
final point module system written language records explicit laziness functors implemented order procedures 
important powerful interface lower level language 
mozart ac interface allows add new constraint systems 
constraint systems fully integrated system including advantage computation spaces 
current mozart system constraint systems rational trees bound records free records finite sets 
mozart supports memory management interface garbage collection oz side finalization manual control side 
support true multiparadigm programming large programming project idea different parts best programmed different paradigms example handler may defined active object new state function previous state external event 
uses object oriented encapsulates concurrency active object 
different levels abstraction best expressed different paradigms 
forexample consider multi agent system programmed concurrent logic language 
language level system concept state 
isa higher level agent level consisting stateful entities called agents sending messages 
strictly speaking concepts exist 
reason agent level better specified graph active objects 
possible encode paradigm terms 
usually 
explain particularly interesting case pure concurrent logic programs state 
canonical way encode state pure concurrent streams 
active object recursive predicate reads internal stream 
object current state internal stream element 
active object stream read object 
sender object sends messages binding stream tail 
sender messages third object coded streams feeding stream merger output stream feeds third object 
new created merger created 
system complex system state communication graph active objects encoded network stream mergers 
network object tree stream mergers feeding 
trees created incrementally execution object system 
regain efficiency compiler run time system smart dis cover network equivalent simpler structure senders send directly receivers 
decompilation algorithm complex pure concurrent logic system implements 
hand adding state directly execution model system sim uniform 
case programmer visible state active objects identities mapped directly execution model state ports compiled directly machine state 
compiler run time system simple 
may argue stateful execution model longer pure 
true irrelevant stateful model allows simpler reasoning pure stateless 
approach multiple languages defined interfaces 
complex 
similar examples concepts higher concurrency exception handling search laziness 
case encoding concept increases complexity program system implementation 
case concept execution model gives simpler uniform system 
conclude programming language support multiple paradigms 
combine dynamic static typing define type set values set operations values 
say thata language checked types system enforces operations executed values correct type 
basic approaches checked typing static typing 
static typing variable types known compile time 
type errors occur run time 
dynamic typing variable type known variable bound 
type error occurs run time exception raised 
oz dynamically typed language 
examine trade offs approach dynamic typing puts fewer restrictions programs programming static typing 
example allows oz incremental development environment part ofthe run time system 
allows test programs program fragments incomplete inconsistent state 
allows truly open programming independently written components come interact assumptions possible 
allows programs operating systems run indefinitely evolve 
hand static typing advantages compared 
allows catch program errors compile time 
allows efficient implementation compiler choose representation appropriate type allows partial program verification program properties guaranteed type checker experience find approach dominates 
flexibility matters times having guarantees important 
thatthe right type system mixed combination static dynamic typing 
allows development methodology consistent 
early stages application development building prototypes dynamic typing maximize flexibility 
part application statically typed maximize correctness guarantees efficiency 
example module interfaces procedure arguments statically typed detection errors 
executed part program statically typed maximize efficiency done add advantages dynamic typing language keeping properties static typing polymorphism adds flexibility functional object oriented languages 
type inferencing pioneered ml relieves programmer burden type program explicitly 
proposal mixed type system go opposite direction 
system default dynamic typing 
static typing done soon needed 
means trade flexibility having guarantees language design available programmer 
design mixed type system subject research mixed typing related concept soft typing approach type checking dynamically typed languages 
soft typing type checker compile time program correctly typed 
decide inserts run time checks ensure safe execution 
mixed typing differs soft typing avoid inefficiency run time checking potentially change time complexity 
statically typed parts truly statically typed 
evolutionary development methodology development methodology oz project refined years largely responsible combination expressive power semantic simplicity implementation efficiency mozart 
methodology fully described print partial explanations 
summarize 
times development working implementation 
design continuous flux 
system developers continuously introduce new abstractions solutions practical problems 
burden proof abstraction prototype show application necessary 
net effect new abstraction simplify system increase expressive power 
case intense discussion takes place developers simplify abstraction possible 
completely expressed modifying system 
possible 
better modify system extend replace new 
decision accept abstraction aesthetic ones 
major acceptance criteria related implementation formalization 
abstraction acceptable implementation efficient simple 
methodology extends approaches put forward hoare ritchie son 
hoare advocates designing program specification concurrently 
explains importance having simple core language 
ritchie advises having system development period 
mozart prolog systems possible development environment part time system 
thompson shows power designed abstraction 
success unix possible due simple powerful appropriate abstractions respect traditional software design processes methodology closest exploratory programming consists developing initial implementation exposing user comment refining system adequate 
main defect exploratory programming results systems ill defined structure avoided abstractions refined double requirement efficient implementation simple formalization step process generating abstractions selecting analogous basic process evolution 
evolution source followed filter survival fittest 
analogy individuals abstractions filters acceptance criteria efficient simple formalization 
abstractions thrive compositionality lexical scoping die generate test approach search dead propagate distribute born mature dynamic scope currently discussion instances general ones basic implemented spaces 
perspectives oz language provides powerful tools algorithmic search classes problems 
particular tools taming search real world situations 
tools include global constraints search heuristics interactive visualize guide search process 
oz lean execution model subsumes deterministic logic programming concurrent logic programming nondeterministic logic programming constraint programming strict nonstrict functional programming concurrent object oriented program ming 
oz supports declarative concurrency little known form concurrent programming deserves widely 
appropriate syntactic paradigms easy 
say oz multiparadigm 
important multiparadigm program design requires different paradigms tobe different parts program 
competent oz programmer conventional boundaries paradigms artificial irrelevant mozart system implements oz continuing development mozart consortium :10.1.1.14.1008
research development started 
current release full featured development environment serious application development 
article covers basic language primitives oz 
briefly discussed system module system functors constraint programming space limitations 
addition ongoing research constraint programming distribution fault tolerance security transactions persistence programming environments software component architectures tools collaborative applications user interfaces 
important topic unexplored design mixed type system combines advantages static dynamic typing 
distribution related areas started 
areas traditionally short logic functional programming communities attention due importance real world applications 
article people years 
con developers mozart system 
opinions expressed shared members mozart consortium 
danny suggest ing iclp tutorial article 
krzysztof apt manuel hermenegildo ueda questions comments iclp tutorial original talk 
anonymous referees comments helped improve presentation 
give special 
research partly financed region belgium 
harold abelson gerald jay sussman julie sussman 
structure computer programs 
mit press cambridge mass 
hassan kaci bruno richard meyer andreas podelski peter van roy 
wild life handbook 
available www info ucl ac people pvr handbook ps 
hassan kaci patrick lincoln 
life natural language natural language mcc technical report aca st mcc aca program february 
hassan kaci roger nasr 
integrating logic functional programming 
jour nal lisp symbolic computation 
hassan kaci andreas podelski 
meaning life 
log 
prog july august 
joe armstrong mike williams om robert virding 
erlang 
prentice hall englewood cliffs 
ken arnold james gosling 
java programming language second edition addison wesley 
robert susan graham editors 
acm turing award lectures years 
acm press 
henri bal jennifer steiner andrew tanenbaum 
programming lan guages distributed computing systems 
acm computing surveys september 
gerald baumgartner marin christophe 
support func tional programming brew 
workshop multiparadigm programming object oriented languages european conference object oriented pro gramming ecoop volume nic pages 
john von neumann institute computing june 
timothy budd 
multiparadigm programming leda 
addison wesley 
mats carlsson sicstus prolog december 
available www sics se 
nicholas carriero david gelernter 
linda context 
communications 
nicholas carriero david gelernter 
coordination languages significance communications acm february 
robert cartwright mike fagan 
soft typing 
proceedings acm sigplan conference programming language design implementation pldi pages toronto ontario june 
yves caseau fran cois xavier fran cois laburthe 
claire search rules better express algorithms 
proceedings international conference logic programming iclp pages las cruces nm usa november 
mit press 
yves caseau fran cois laburthe glenn silverstein 
meta heuristic factory routing problems 
jaffar editor proceedings fifth international conference principles practice constraint programming cp pages alexandria va usa october 
emmanuel pascal bruno 
applications avec objective caml 
reilly paris france 
french 
chakravarty guo 
goffin higher order functions meet con current constraints 
international workshop concurrent constraint programming may 
venice italy 
chen michael kifer david warren 
hilog foundation higher order logic programming 
log 
prog february 
keith clark 
parlog language applications 
de bakker editors proceedings conference parallel architectures languages europe parle 
volume ii parallel languages volume lecture notes computer science pages eindhoven netherlands june 
springer verlag 
keith clark frank mccabe 
control facilities ic prolog 
michie editor expert systems micro electronic age pages 
edinburgh university press edinburgh scotland 
keith clark frank mccabe steve gregory 
ic prolog 
keith clark sten ake editors logic programming pages 
academic press london 
keith clark sten ake 
order theory data programs proceedings ifip congress pages toronto canada august 
north holland 
william clinger jonathan rees 
revised report algorithmic 
lisp pointers iv july september 
alain colmerauer 
prolog ii manual theoretical model 
universit aix marseille ii groupe intelligence artificielle october 
guy cousineau michel mauny 
functional approach programming 
cam bridge university press december 
charles darwin 
origin species means natural selection favoured races struggle life 
harvard university press originally john murray london 
andrew davison 
survey logic programming object oriented languages research directions concurrent object oriented programming 
mit press 

axiomatizing dependency parsing set constraints 
mathematics language mol orlando florida july 
claire joachim 
concurrent con straint programming oz natural language processing 
lecture notes www ps uni sb de oz natural language script html 
tobias uller christian schulte peter van roy system modules 
technical report mozart consortium january 
available www mozart oz org 
christian schulte gert smolka 
higher order module discipline separate compilation dynamic linking pickling 
technical report programming systems lab dfki universit des saarlandes 
draft 
ian foster 
strand pcn generations compositional programming lan guages 
technical report preprint mcs argonne national laboratories 
takashi chikayama 
portable implementation kl 
fifth generation computing systems fgcs pages december 
dov gabbay christopher hogger john alan robinson editors 
logic artificial intelligence logic programming volume 
oxford university press 
michael garey david johnson 
computers 

adele goldberg david robson 
smalltalk language implementa tion 
addison wesley 
robert halstead 
multilisp language concurrent symbolic computation acm transactions programming languages systems october 
michael hanus 
integration functions logic programming theory 
log 
prog 
michael hanus 
unified computation model functional logic programming proceedings th acm sigplan sigact symposium principles programming languages popl pages paris france january 
seif haridi brand 
andorra prolog integration prolog committed choice languages 
institute new generation computer technology icot editor proceedings international conference fifth generation computer sys tems fgcs volume pages tokyo japan november 
ohmsha springer verlag 
seif haridi janson 
kernel andorra prolog computation model proceedings th international conference logic programming iclp pages jerusalem israel june 
mit press 
seif haridi peter van roy brand michael mehl ralf 
efficient logic variables distributed computing 
acm transactions programming languages systems may 
seif haridi peter van roy brand christian schulte 
programming distributed applications 
new generation computing may 
robert harper dave macqueen robin milner 
standard ml 
technical lfcs university edinburgh dept computer science 
martin 
objects concurrent constraint programming volume international series engineering computer science 
kluwer academic publishers boston november 
martin 
objects oz 
phd thesis universit des saarlandes saarbr germany june 
martin tobias uller ka boon ng 
library 
workshop parallelism implementation technology constraint logic programming international conference logic programming iclp las cruces nm usa november 
charles antony richard hoare 
emperor old clothes 
graham 
turing award lecture 
bruce holmer barton sano michael carlton peter van roy alvin de spain 
design analysis hardware high performance prolog 
log 
prog november 
paul hudak simon peyton jones philip wadler brian boutel jon joseph fasel mar ia guzm kevin hammond john hughes thomas johnsson richard kieburtz nikhil partain john peterson 
programming language haskell non strict purely functional language 
acm sigplan notices 
john hughes 
functional programming matters 
computer journal 
institute new generation computer technology editor 
fifth generation com puter systems volume 
ohmsha ios press 
isbn 
janson 
akl multiparadigm programming language 
phd thesis sics 
janson seif haridi 
programming paradigms andorra 
logic programming proceedings international symposium pages san diego ca usa october 
mit press 
janson johan seif haridi 
ports objects concurrent 
research directions concurrent object oriented programming 
mit press 
andreas peter van roy bruno 
logical january 
sicstus prolog package available www info ucl ac people pvr implementation html 
alexander koller joachim 
constraint programming 
barker plummer beaver van benthem di editors proceedings csli workshop logic language computation csli press 
fran cois laburthe yves caseau 
salsa language search algorithms 
maher jean fran cois puget editors proceedings fourth international conference principles practice constraint programming cp volume lecture notes computer science pages pisa italy october 
springer verlag 
hugh lauer roger needham 
duality operating system struc tures 
second international symposium operating systems october 
reprinted operating systems review april pp 

doug lea 
concurrent programming java second edition 
addison wesley 
michael maher 
logic semantics class committed choice programs 
proceed ings fourth international conference logic programming iclp pages melbourne australia may 
mit press 
david maier david warren 
computing logic logic programming 
addison wesley january 
kim marriott peter stuckey 
programming constraints mit press january 
martin uller tobias uller peter van roy 
multiparadigm programming 
donald smith olivier peter van roy editors workshop logic programming international logic programming symposium ilps december 
brian mcnamara yannis smaragdakis 
functional programming 
inproceedings fifth acm sigplan international conference functional programming icfp pages montreal canada september 
michael mehl 
oz virtual machine records transients deep guards doctoral dissertation universit des saarlandes im stadtwald saarbr germany 
michael mehl tobias uller christian schulte ralf 

technical report mozart consortium january 
available www mozart oz org 
michael mehl ralf christian schulte 
machine 
manuel hermenegildo doaitse swierstra editors programming languages implementations logics programs seventh international symposium plilp volume lecture notes computer science pages utrecht netherlands september 
springer verlag 
michael mehl christian schulte gert smolka 
futures need synchro oz 
draft programming systems lab universit des saarlandes may 
robin milner mads tofte robert harper 
definition standard ml 
cambridge ma usa 
chris moss 
prolog power object oriented logic programming addison wesley 
mozart consortium :10.1.1.14.1008
mozart programming system oz version january 
available www mozart oz org 
tobias uller 
problem solving finite set constraints oz 
tutorial 
mozart consortium january 
available www mozart oz org 
tobias uller 
mozart constraint extensions tutorial 
technical report january 
available www mozart oz org 
nadathur dale miller 
higher order logic programming chapter 
vol ume gabbay 
nikhil 
id language manual version 
technical report memo mit computation structures group july 
nikhil 
overview parallel language id foundation ph parallel dialect haskell 
technical report digital equipment cambridge research laboratory 
nikhil arvind 
implicit parallel programming ph 
morgan mann 
martin odersky philip wadler 
pizza java translating theory prac tice 
proceedings th acm sigplan sigact symposium principles programming languages popl pages paris france january 
simon peyton jones philip wadler 
imperative functional programming 
inproceedings th acm sigplan sigact symposium principles programming languages popl pages january 
didier emy er ome vouillon 
objective ml effective object oriented exten sion ml 
theory object systems 
dennis ritchie :10.1.1.24.3472
reflections software research 
graham turing award lecture 
santos costa david warren rong yang 
andorra parallel transparently exploits parallelism 
proceedings rd acm sigplan symposium principles practice parallel programming ppopp pages williamsburg va usa august 
vijay saraswat martin rinard 
concurrent constraint programming 
proceed ings th acm symposium principles programming languages popl pages san francisco ca usa january 
vijay saraswat 
concurrent constraint programming 
mit press 
ralf 
design implementierung und einer mas chine ur oz 
doctoral dissertation universit des saarlandes im stadtwald saarbr germany december 
german 
richard schlichting thomas 
multi paradigm programming lan guage constructing fault tolerant distributed systems 
technical report tr university arizona department computer science october 
christian schulte 
oz explorer visual constraint programming tool 
lee naish editor proceedings fourteenth international conference logic programming iclp pages leuven belgium july 
mit press 
christian schulte 
programming constraint inference engines 
gert smolka ed proceedings rd international conference principles practice constraint programming volume lecture notes computer science pages schloss austria october 
springer verlag 
christian schulte 
comparing trailing copying constraint programming 
de schreye editor proceedings international conference logic programming iclp pages las cruces nm usa november 
press 
christian schulte 
oz explorer visual constraint programming support 
mozart consortium january 
available www mozart oz org 
christian schulte 
parallel search simple 
nicolas warwick har martin fran cois laburthe eric tobias uller laurent perron christian schulte editors proceedings techniques programming systems post conference workshop cp number tra pages science drive singapore september 
christian schulte 
programming constraint inference services 
doctoral dissertation universit des saarlandes fachbereich informatik saarbr germany 
christian schulte 
programming deep concurrent constraint combinators 
santos costa editors practical aspects declarative languages second international workshop padl volume lecture notes com puter science pages boston ma usa january 
springer verlag 
christian schulte 
programming constraint services volume lecture notes intelligence 
springer verlag berlin germany 
christian schulte gert smolka 
encapsulated search higher order concur rent constraint programming 
maurice bruynooghe editor logic programming proceedings international symposium pages ithaca ny usa november 
mit press 
christian schulte gert smolka 
finite domain constraint programming oz tutorial 
technical report mozart consortium january 
available www mozart oz org 
christian schulte gert smolka org 
encapsulated search oz 
alan borning editor second workshop principles practice constraint programming volume lecture notes pages orcas island wa usa may 
springer verlag 
ehud shapiro 
subset concurrent prolog interpreter 
technical institute new generation computer technology icot cambridge mass january 
ehud shapiro editor 
concurrent prolog collected papers volume 
cambridge mass 
ehud shapiro 
family concurrent logic programming languages 
acm com puting surveys september 
gert smolka 
definition kernel oz 
constraints basics trends volume lecture notes computer science pages 
springer verlag 
gert smolka :10.1.1.14.1008
oz programming model 
computer science today volume lecture notes computer science pages 
springer verlag 
gert smolka 
problem solving constraints programming 
acm es december 
electronic section 
gert smolka christian schulte peter van roy 
distributed programming oz 
bmbf project proposal 
available www ps uni sb de february 
gert smolka ralf 
records logic programming 
log 
prog april 
ian sommerville 
software engineering 
addison wesley 
guy steele jr common lisp language 
digital press 
leon sterling ehud shapiro 
art prolog advanced programming tech niques 
series logic programming 
mit press 
ken thompson 
reflections trusting trust 
graham 
turing award lecture 
simon thompson 
haskell craft functional programming second edition addison wesley june 
evan tick 
concurrent logic programming 
log 
prog may 
ueda 
guarded horn clauses 
wada editor logic programming proceedings th conference volume lecture notes computer science pages tokyo japan july 
springer verlag 
pascal van hentenryck 
opl programming language 
mit press february 
software available ilog france 
peter van roy 
useful extension prolog definite clause grammar notation acm sigplan notices november 
peter van roy 
vlsi bam diagnostic generator 
prolog program language diagnostics project uc berkeley alvin despain 
peter van roy 
logic programming oz mozart 
danny de schreye editor proceedings international conference logic programming iclp pages las cruces nm usa november 
mit press 
mild version 
peter van roy 
separation concerns distributed programming applica tion distribution structure fault tolerance mozart 
international workshop parallel distributed computing symbolic irregular applications university sendai japan july 
peter van roy alvin despain 
high performance logic programming prolog compiler 
ieee computer pages january 
peter van roy seif haridi 
concepts techniques models programming practical applications distributed computing intelligent agents 

book progress draft available www info ucl ac people pvr book html 
peter van roy seif haridi brand 
distributed programming mozart 
technical report mozart consortium january 
available www mozart oz org 
peter van roy seif haridi brand gert smolka michael mehl ralf 
mobile objects distributed oz 
acm transactions programming languages systems september 
peter van roy michael mehl ralf 
integrating efficient records constraint programming 
proceedings eighth international symposium programming languages implementations logics programs plilp aachen germany september 
springer verlag 
philip wadler :10.1.1.100.9674
essence functional programming 
proceedings th sigact symposium principles programming languages popl pages albuquerque nm usa january 
invited talk 
om 
distributed programming erlang 
st international parallel symbolic computation pages singapore september 
world scientific 
contents deterministic logic programming nondeterministic logic programming concurrent logic programming implicit versus explicit concurrency 
concurrent producer consumer 
lazy producer consumer 
coroutining 
explicit state cells mutable 
ports communication channels 
relevance concurrent logic programming 
creating active object 
search aggregate search 
simple search procedures 
scalable way search 
oz execution model store 
kernel language 
concurrency state 
nondeterministic choice 
lazy functions 
multiparadigm programming 
computation spaces 
definition 
state space 
programming search 
space operations 
spaces 
related multiparadigm languages 
history oz 
lessons learned explicit magic 
provide primitives building abstractions 
factorize lean 
support true multiparadigm programming 
combine dynamic static typing 
evolutionary development methodology 
perspectives 
