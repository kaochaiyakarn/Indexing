computationally sound implementations equational theories passive adversaries mathieu baudet cortier steve kremer france loria cnrs inria lorraine projet france lsv cnrs inria projet ens cachan france study link formal cryptographic models security protocols presence passive adversaries 
contrast works consider fixed set primitives aim results arbitrary equational theories 
define framework comparing cryptographic implementation idealization respect various security notions 
particular concentrate computational soundness static equivalence standard tool cryptographic pi calculi 
soundness criterion theories sufficient necessary 
illustrate framework establish soundness static equivalence exclusive theory ciphers lists 

today ubiquity computer networks increases need theoretic foundations cryptographic protocols 
years communities separately developed families models 
views useful increasing understanding quality security protocol design 
hand formal logical models developed seminal dolev yao 
models view cryptographic operations idealized way 
hand cryptographic computational models closer implementations cryptographic operations modeled algorithms manipulating bit strings 
models cover large class attacks implementable probabilistic polynomial time turing machine 
advantage formal models security proofs generally simpler suitable automatic procedures complex protocols 
unfortunately high degree abstraction limited adversary power raise extended published proceedings icalp conference 
email addresses mathieu baudet fr mathieu baudet cortier loria fr cortier kremer lsv ens cachan fr steve kremer preprint submitted elsevier december questions regarding security offered proofs 
potentially justifying symbolic proofs respect standard computational models tremendous benefits protocols analyzed automated tools benefit security guarantees computational model 
past years significant research effort directed linking approaches 
seminal abadi rogaway prove computational soundness formal symmetric encryption case passive attacker 
results obtained 
results considers fixed set primitives instance symmetric publickey encryption 
aim presenting general results arbitrary equational theories encryption studied ones groups exclusive 
interest approach develop general unified framework treatment cryptographic primitives 
conceptually offers better understanding equational theories modeling algebraic properties primitives 
years formal models considered equational theories theory exclusive abelian groups homomorphic encryption survey algebraic properties see instance order model cryptographic aspects 
priori unclear equations considered provide realistic security guarantees 
real attacker exploit additional properties cryptographic primitive modeled 
propose setting proof techniques allow formally define prove equations considered 
concentrate static equivalence standard notion originating applied pi calculus 
intuitively static equivalence asks attacker distinguish tuples messages called frames exhibiting relation holds tuple 
static equivalence provides elegant means express security properties pieces data instance observed passive attacker run protocol 
context active attackers static equivalence characterize process equivalences line guessing attacks 
exist exact approximate algorithms decide static equivalence large family equational theories 
contribution general framework comparing formal computational models presence passive attacker 
define notions soundness faithfulness cryptographic implementation respect equality static equivalence non deducibility 
soundness holds formal notion security computational interpretation 
instance statically equivalent tuples messages frames computationally indistinguishable 
conversely faithfulness holds formal attack notion security mapped efficient computational attacker 
illustration consider equational theory modeling abelian groups exponents taken commutative ring 
show soundness static equivalence implies hardness classical problems cryptography notably decisional diffie rsa problem 
completely surprising results illustrate expressive power static equivalence defined tailored equational theories 
second contribution sufficient criterion soundness respect static equivalence intuitively usual computational semantics terms indistinguishable idealized 
define study useful class frames called transparent frames arbitrary equational theories 
informally frame transparent secret deducible frame 
transparent frames enjoy notable properties simple characterization static equivalence case uniform distributions fact statically equivalent transparent frames yield concrete distribution indistinguishable sense information theory 
study transparent frames allows exhibit class equational theories soundness criterion necessary 
third contribution consists applying framework obtain soundness results static equivalence 
equational theory consider deals exclusive 
simple important primitive largely cryptographic constructions time pad protocols see examples 
interestingly proof soundness reflects unconditional security information theoretic sense time pad 
second consider theory symmetric encryption lists 
result similar spirit abadi rogaway 
consider deterministic length preserving symmetric encryption schemes known pseudo random permutations ciphers abadi rogaway consider probabilistic symmetric encryption 
choice motivated famous examples ciphers des aes 
examples specificity prove soundness standard formal notion static equivalence specialized relation 
related 
study link formal computational approaches cryptographic protocols started seminal abadi rogaway passive setting 
extensions abadi rogaway passive case studying completeness considering deterministic encryption detailed comparison provided time pad length revealing key revealing encryption allowing composed keys key cycles 
results active setting achieved backes pfitzmann waidner 
works prove soundness rich language including digital signatures public key symmetric key encryption presence active attacker kind security properties 
quite similar results established classical dolev yao models asymmetric encryption signatures 
easily full automation results offer universal composability guarantees previous ones 
canetti herzog obtained similar soundness theorem restricted class protocols mutual authentication key exchange protocols public key encryption offer strong composability properties universal composability framework 
laud presents automated procedure computationally sound proofs confidentiality case active attacker symmetric encryption number sessions bounded 
datta introduce symbolic logic allows cryptographically sound security proof 
blanchet proposed computationally sound mechanized prover relies directly games transformations proof technique commonly cryptographic setting 
previously mentioned results dedicated fixed set cryptographic primitives 
goal restricted obtaining particular soundness result set primitives security properties 
aim developing general setting reason adequacy functional symbols equipped equational theory corresponding cryptographic implementations 
best knowledge approach new distinct existing 
discuss related concerning theories exclusive ciphers lists considered illustrate framework 
regarding soundness exclusive backes pfitzmann independently shown impossibility result framework reactive simulatability presence active adversary 
soundness result presence passive adversary 
consider application exclusive pure random values backes pfitzmann deal arbitrary payloads 
clear framework reactive simulatability presence passive adversary compares framework static equivalence 
concerning theory ciphers list laud presents soundness results style abadi rogaway ciphers 
results close laud notion formal equivalence apparently pessimistic regarding secrecy encryption keys 
instance opposed consider encryption fresh random value known key indistinguishable random value formally pair enc indistinguishable 
reason absence tags encryption key cipher yields permutation space values 
follows uniform distribution implementation section term enc 
provided suitable set equations static equivalence naturally accounts property natural immediate way express equivalences patterns style abadi rogaway 
sense abadi warinschi seen attempt fragment equivalences modeling guessing attacks 
techniques developed applied successfully abadi baudet warinschi generalize ideas justify modeling guessing attacks purely static equivalence 
laud provides computationally sound proof system handling ciphers exclusive presence passive attacker 
proof system prove security encryption modes including cbc 
approach differs developed aims direct cryptographic proofs security 
comparison approach aims exhibit class protocols absence formal attacks entails existence computational proof security 
related 
publication preliminary version article papers addressed computational soundness static equivalence 
mentioned abadi baudet warinschi study resistance offline guessing attacks modelled terms static equivalence framework developed show soundness equational theory including ciphers symmetric asymmetric encryption 
bana argue notion static equivalence coarse sound interesting equational theories 
introduce general notion formal indistinguishability relation 
highlights soundness static equivalence holds restricted set formed frames vein abadi rogaway restrictions forbid key cycles 
illustrate unsoundness static equivalence modular exponentiation 
kremer framework define soundness static equivalence presence adaptive purely passive adversary 
show soundness results static equivalence equational theory modelling modular exponentiation class formed frames contradicting symmetric encryption composed keys computed modular exponentiation exclusive 
active version static equivalence observational equivalence relation introduced milner hoare early 
intuitively processes equivalent observer tell difference processes 
observer particular intercept send messages processes 
comon cortier shown observational equivalence processes fragment applied pi calculus implies cryptographic indistinguishability active attackers context symmetric encryption 
extended version soundness static equivalence called tree soundness key step proof 
outline 
section introduce concrete models notions indistinguishability 
define notions soundness faithfulness illustrate consequences soundness respect static equivalence groups 
section define ideal semantics terms soundness criterion prove necessary large family equational theories 
illustration section prove soundness theories modeling exclusive ciphers lists 
conclude section 
appendix contains detailed proofs formal lemmas related static equivalence 

modeling cryptographic primitives algebras section introduce notations set concrete models 

algebras models called algebras consist term algebras defined sorted order signature equipped equational theories 
specifically signature set sorts elements denoted set symbols written arities form ar 
sk 
symbols take arguments called constants arity simply written fix set names written set variables 
assume names variables sorts infinite number names variables available sort 
set terms sort defined inductively term sort variable sort name sort 
tk application symbol case require ti term sort si ar 
sk write var names set variables names occurring respectively 
term ground closed iff var 
may write var 
tk var 
tk similarly names 
context term holes formally term distinguished variables 
context distinguished variables 
xn may write 
xn order show variables 
tn terms may write 
tn result replacing variable xi corresponding term ti 
substitutions written 
xn tn domain dom 
xn 
consider sorted substitutions substitutions 
xn tn xi ti sort 
closed iff ti closed 
var var ti names names ti extend notations var 
names 
tuples sets terms substitutions obvious way 
application substitution term written 
position expression denotes subterm position expression denotes term obtained replacing subterm position symbols intended model cryptographic primitives names model secrets concretely random numbers 
intended behavior primitives described equational theory equivalence relation terms written compatible applications symbols sorted substitutions ary symbol terms 
tk 
appropriate sorts ti implies 
fk 
sorted substitution terms 
sequel require stable sorted substitution names 
equational theories consider satisfy properties 
instance symmetric deterministic encryption modeled theory generated classical equation dec enc 
symbol free respect equational theory iff exists set equations generating occur sort degenerated iff terms sort equal modulo useful orient equations rewriting rules equational theory 
formally rewriting rule expression terms sort 
set rewriting rules called rewriting system write exists rule position sorted substitution write reflexive transitive closure reflexive symmetric transitive closure 
equational theory rewriting system write relation define similarly 
terminating iff admits infinite sequence reductions 
tn 
confluent iff exist 
convergent iff terminating confluent 
syntactic equality yields usual notions termination confluence convergence 

frames deducibility static equivalence frames represent sequences messages observed attacker instance execution protocol 
formally closed frame expression 
xn tn set bound restricted names ti closed term sort xi 
simplicity consider closed frames 
xn tn restrict name names 
tn 
name may disclosed explicitly adding mapping xa frame 
tend assimilate frames underlying substitutions 
xn tn 
definition deducibility 
closed term deducible frame equational theory written iff exists term var dom names names follows simplicity consider deducibility problems names names 
consider instance theory frame 
enc enc name deducible dec deducible 
deducibility sufficient account knowledge attacker 
instance lacks partial information secrets 
consider naive vote protocol agents simply send vote encrypted key security problem attacker learn values attacker tell difference message contains vote message contains vote 
classical notion formal methods static equivalence 
definition static equivalence 
frames statically equivalent theory written iff dom dom terms var dom names names 
instance frames enc enc statically equivalent respect 
frames enc enc consider test dec set terms deduced frames constants known attacker 

concrete semantics give terms frames concrete semantics parameterized implementation primitives 
provided set sorts set symbols computational algebra consists non empty set bit strings sort effective procedure implementing function 
sk symbol ar 
sk effective procedure deciding congruence sort order check equality elements element may represented different bit strings congruence mean reflexive symmetric transitive relation 
ek sk 
ek 
remaining omit write effective procedure draw random elements denote drawing drawing may follow uniform distribution equivalence class probability 
assume fixed computational algebra associate closed frame 
xn tn distribution drawings computed follows 
name sort appearing 
tn draw value 
xi sort si compute ti si recursively structure terms 

values defined step names 

return value 
xn tn 
values 
xn en ei si called concrete frames 
extend notation tuples closed terms natural way 
en 
tn denotes drawing 
xn en 
xn tn appropriate variables 
xn 
generalize notation tuples terms variables specifying concrete value 
xn en 
notice term frame contains names translation deterministic case notation denote distribution unique value 
rest focus asymptotic notions cryptographic security consider families computational algebra indexed complexity parameter 
parameter thought size keys secret values 
concrete semantics frame family distributions concrete frames 
consider families computational algebras algebraic operations functions associated symbols congruence relation drawing functions computable uniform probabilistic polynomial time algorithms complexity parameter 
ensures concrete semantics fixed term frame efficiently computable sense 
families distributions ensembles concrete frames benefit usual notion cryptographic indistinguishability 
intuitively families distributions indistinguishable written iff probabilistic polynomial time adversary guess sample probability significantly greater formally ask advantage adv ind negligible function 
recall function said negligible integer exists 
note regard negative functions negligible 
function overwhelming iff negligible 
family distributions collision free respect family congruences iff probability collision random elements negligible function 
note classical properties probability equivalent requiring probability sampling modulo negligible function bounded negligible function 
convention adversaries considered access implicitly complexity parameter fresh random coins needed 

comparing computational algebras previous section defined computational algebras 
relate formal notions equality non deducibility static equivalence computational counterparts equality wayness indistinguishability 

soundness faithfulness introduce notions sound faithful computational algebras respect formal relations studied equality static equivalence deducibility 
equational theory 
family computational algebras sound iff closed terms sort implies overwhelming faithful iff closed terms sort implies negligible sound iff frames domain implies faithful iff frames domain implies exists polynomial time adversary distinguishing concrete frames adv ind overwhelming sound iff frame closed term names names implies polynomial time adversary negligible faithful iff frame closed term names names implies exists polynomial time adversary overwhelming 
possible prove stronger notions soundness hold restriction computational power adversaries 
particular unconditionally sound iff closed terms sort implies unconditionally sound iff frames domain implies unconditionally sound iff frame closed term names names drawings independent drawing collision free 
fact unconditional notions stronger computational counterparts clear definitions 
unconditional soundness observe drawings independent drawing collision free adversary negligible probability retrieving value sup generally unconditional soundness construction 
true formal equations correspond expected behavior primitives hold concrete world overwhelming probability 
criteria difficult fulfill 
interesting restrict frames formed ones order achieve soundness faithfulness instance abadi rogaway forbid encryption cycles see section 
worth noting notions soundness faithfulness introduced independent 
proposition 
sound family computational algebras 

faithful 
faithful faithful 
proof 

suppose names names exists var dom names names define adversary deduce follows 
concrete frame xi ei returns sample sound names names probability success greater minus negligible function 

suppose exist terms var dom names names instance 
adversary tests returns result test 
runs polynomial time soundness faithfulness advantage minus negligible function 
theories soundness implies notions soundness faithfulness 
emphasizes importance soundness provides additional motivation study 
illustration consider arbitrary theory includes keyed hash functions 
proposition 
family sound computational algebras 
assume free binary symbols hs key hash available sort sort key degenerated drawing random elements sort hash hash collision free 

faithful 
sound 
assume implementations symbols hs collision resistant assume sort fresh name sort key quantity proof 
hs hs negligible 
sound faithful faithful 

terms sort 
consider frame hs hs fresh name sort key 
hs free distinct fresh names sort hash proposition appendix 
assumption entails 
particular hash collision free quantity negligible 
hs hs 
frame closed term sort names names hs fresh variables fresh name sort key fresh name sort hash 
proposition appendix 
assumption 
contradiction suppose exists polynomial time adversary able deduce concretely non negligible probability success 
build adversary distinguishes follows sample analyzed 
answer restriction dom 
returns definition advantage hs 
dom hs dom hs dom dom hs probability expression observe drawn distribution hash independently 
distribution hash collision free advantage nonnegligible contradiction 

terms sort 
consider frame hs hs 
hs free fresh name sort hash proposition appendix 
assumption entails hs hs negligible function 
implementation hs deduce negligible 
properties follow proposition 

soundness implies classical assumptions groups section interesting consequences soundness 
inspired rivest pseudo freeness prove standard cryptographic assumptions groups implied soundness static equivalence 
concentrate abelian groups relevant cryptographic applications 
believe similar techniques apply non commutative groups 
model abelian group exponents taken commutative ring algebra signature exp infix notation operators write ga denote exp 
note inverse operation represented exp consider equational theory generated equations variables sort variables sort xu xu xv xu xu yu recall classical problems groups 
cryptographic applications desirable problems hard feasible probabilistic polynomial time adversary discrete logarithm dl problem find computational diffie hellman cdh problem find ab decisional diffie hellman ddh problem distinguish ab random element rsa problem elements find detailed presentation hard problems 
assume family computational algebras signature sound subset formed frames wf consider frames 
assume wf probabilistic polynomial time adversary solve ddh problem non negligible probability 
suggested question computationally distinguishing frames exactly encodes ddh problem 
equational theory prove formal equivalence lemma appendix 
soundness ddh problem hard 
clearly solve dl problem solve cdh problem allows solve ddh problem 
hardness ddh implies hardness problems 
similar way see soundness augmented signature implies hardness rsa 
directly encoding rsa problem introduce slightly weaker decision problem hardness implies hardness rsa 
encoding problem requires extension signature unary function symbol hash adding equation theory 
consider frames 
prove lemma appendix implementation sound subset formed frames wf including rsa problem efficiently solved 
adversary rsa problem turned equally efficient adversary simply follows sample side result applied return left hand side equals 
interesting open question soundness implies implied rivest notion pseudo free groups equivalently strong rsa property 
conjecture notions fact incomparable 
hand notion implies hardness ddh remains open question strong rsa 
hand pseudo freeness strong rsa deal form adaptive attackers model purely nonadaptive 

sufficient necessary criterion soundness useful results proving soundness properties general 
notably provide sufficient criterion soundness section prove necessary additional assumptions section 

ideal semantics soundness criterion implementation primitives defined section concrete semantics associated frame define ideal semantics frame intuitively conditional distribution concrete values appropriate space pass formal test satisfied 
specifically frame define tests test var dom names names 
eq set tests true eq test note definition iff test test 
family computational algebras 
xn tn frame si sort xi 
define set eligible formed values 
xn en 
en sn write val process drawing random value si 
xn en drawings ei way 
consider subset concrete frames intuitively pass valid tests val xn en natural note provided unconditionally sound val nonempty contains values usual semantics 
definition ideal semantics 
unconditionally sound family computational algebras frame 
ideal semantics family distributions ideal obtained distri bution val set values val 
words probability draw ideal val val val val 
say uniform distributions sort finite set usual equality distribution associated uniform 
classical property conditional probabilities note case uniform distributions ideal semantics frame coincides family uniform distributions finite non empty sets val 
instance sort stable substitution names test 
unconditional soundness deduce ideal simply uniform distribution 
state soundness criterion intuitively semantics concrete ideal indistinguishable 
proposition soundness criterion 
unconditionally sound family computational algebras 
assume frame holds ideal 
sound 
proof 

equality test test entails val val distributions ideal ideal equal 
transitivity indistinguishability relation conclude ideal 
ideal 
transparent frames section show soundness criterion necessary general class equational theories called transparent theories 
theories frame associated equivalent transparent frame defined easier analyze 
definition transparent frames 
frame transparent equational theory subterms deducible example 
theory frame enc enc enc transparent deducible frame enc enc proposition finitely characterizes equations verified transparent frame 
proposition 
transparent frame form 
am 
xn cn 
am 
cn necessarily linear contexts names 
cn 
am 
cn 
am closed 
am distinct deducible names ai 
ai mai term var mai 
xn names mai names mai ai 
equation holds logical consequence equations xj cj ma 
mam written xj cj ma 
mam eq 
logical consequence refer usual order theory equality variables 
xn considered constants 
proof 
eq 
definition xj cj 
am xj cj 
am stable substitution names obtain xj cj ma 
mam xj cj ma 
mam equalities xj cj ma 
mam transitivity obtain xj cj ma 
mam nice useful property transparent frames concrete ideal semantics coincide 
proposition 
unconditionally sound family computational algebras having uniform distributions 
transparent frame 
concrete ideal semantics yield family distributions ideal proof 

am 
xn cn 
am mi ai 
si sort ai sort xj complexity parameter 
usual concrete semantics consists mapping drawing names set sm value 
note function defined 
em 
ym ym em 
xn cn 
ym ym em yi fresh variables respectively sort si omit subscript sake clarity 
mi define function 
mm note distribution mi equals mi equivalently mi en 
en mi ai unconditionally sound element probability obtain de 
injective yields bijection image 
assumption equipped uniform distribution concrete semantics uniform distribution satisfies cj 
ym ym mi xj cj 
mm xj transparent proposition implied equations cj 
mm xj unconditional soundness deduce values pass tests words val 
conversely element val trivially val 
equipped uniform distribution obtain ideal semantics coincides uniform distribution concrete semantics 
noticeable consequence proposition case uniform distributions statically equivalent transparent frames indistinguishable 
argument similar proposition 
motivates definition purpose studying soundness converse proposition 
definition 
equational theory transparent frame exists necessarily unique transparent frame 
transparent frames theories related notion patterns introduced abadi rogaway subsequent define computationally sound formal equivalences 
messages mapped patterns replacing non deducible subterms boxes 
definition messages equivalent yield pattern renaming names 
example denotes probabilistic encryption key message mapped pattern 
compare example notion transparent frames defined equational theory 
case frame corresponds transparent frames 
example consider theory exclusive section frame 
transparent frames equivalent instance 
believe notion transparent frames relevant theories useful cryptography 
matter fact theories exclusive ciphers considered section transparent 
notion transparent frames subsume patterns defined abadi rogaway 
particular theory probabilistic symmetric encryption sdec sdec success ok unclear associate equivalent transparent frame frame arguably pattern sense abadi rogaway cast syntax 
reason random coin deducible term replaced fresh name visible equation sdec success ok exclude subterm modifying notion subterms example abadi rogaway random factor appear explicitely terms 
undermine properties transparent frames mentioned 
regard notions patterns transparent frames complementary 
note proved en decidable transparent theories decidable provided reduction equivalent transparent frames effective 
frames associate statically equivalent transparent frame respectively 
straightforward check equivalent finite characterization eq proposition 
establish completeness result soundness criterion cases transparent theories 
theorem 
assume transparent theory family computational algebras uniform distributions sound unconditionally sound 
soundness criterion proposition satisfied frame ideal 
proof 
transparent exists transparent frame 
soundness deduce 
proposition ideal 
altogether conclude ideal implies ideal ideal 

examples apply framework sections establish results concerning theory exclusive ciphers lists 

exclusive study soundness faithfulness problems natural theory implementation exclusive xor constants pure random numbers 
formal model consists single sort data infinite number names infix symbol data data data constants data 
terms equipped equational theory generated implementation define computational algebras concrete domain data set bit strings length equipped uniform distribution interpreted usual xor function setting statically equivalent frames enjoy algebraic characterization 
ac equational theory corresponding left hand equations associativity commutativity 
equations rewriting system allow arbitrary ac manipulations rewriting step 
easy show ac convergent 
specifically term ac normal form simply normal form name variable constant occur occur 

distinct names 
rewriting system ac closed term names 
written aj aj mutually distinct convention aj aj aj 
see element field terms modulo form vector space 
similarly frame names 
written aj 
xm aj 
group coefficients matrix 
described formal relation xm 



characterize set eq equations valid 
terms var dom names names 
note 
study case 
assume normal form 
names names implies names 
ac xi 
condition equivalent vectorial equation 

belongs kernel noted 
frames names 
dom dom 
xm 
corresponding matrices defined 
previous discussion deduce write im image duality im im 
characterization key point main result theory xor 
theorem 
implementation xor considered signature unconditionally sound 
faithful 
proof 
unconditional soundness clear faithfulness proposition 
show faithful 
assume terms 
equivalent 
sufficient consider case closed term normal form 
semantics constant uniform distribution negligible 
faithfulness holds proposition faithfulness 
address unconditional soundness 
frame matrix associated 
see linear function simplicity fix order variables dom assimilate possible concrete values set bits added technical reasons 
usual concrete semantics consists drawing random vector uniformly value names applying linear function 
specifically see similarly function defined 

fn fj 
fj linear inverse images im cardinal 
concrete semantics uniform distribution im assume second frame define similarly 
equation im im 
see 

similarly im im 
im may write im 
im im implies concrete semantics 
unconditionally sound 
prove unconditional soundness 
frame term normal form names names 

associated ac aj 
matrix obtained augmenting row equal 




particular exists normal form names words linearly independent rows matrix 
particular independent row 
exists 
deduce distribution uniform collision free 
condition unconditional soundness similar reasoning concrete semantics uniform distribution image defined similarly 
see linear function define previously 
prove image cartesian product sets 
follows drawings independent 
inclusion trivial 
independent rows exists vector ker ker implies 
prove exists see corresponding bases 

xi yi zi xi yi xi 






implies coordinate coordinate zi conclude section proof transparent announced section 
proposition 
equational theory transparent 
proof 
frame associated matrix 
dimension im 
exists submatrix injective im im consider maximal independent set columns 
column independent starts start may assume loss generality column 
particular 

distinct names 
frame associated described relation xm im im 
injective exists identity matrix 
entails deducible transparent 

symmetric deterministic length preserving encryption lists detail example symmetric deterministic length preserving encryption schemes 
schemes known pseudo random permutations ciphers widely practice famous examples fixed length inputs des aes 
formal model consists set sorts data list list 
list infinite number names sort data list symbols decn list data list encryption decryption consn data list list list constructor list data head list list list tail list nil list empty list data constants consider equational theory esym generated equations name sort list decn decn consn consn consn enc nil nil dec nil nil tail nil nil variables appropriate sorts case 
effect equations sort list degenerated esym terms sort list equal 
oriented left right equations form convergent rewriting system written notice term unique sort 
subscripts function symbols redundant sorts tend omit terms 
instance data may write enc cons nil enc cons nil 
concrete meaning sorts symbols computational algebras defined follows carrier sets data list equipped uniform distribution usual equality relation decn implemented cipher data size keys size discuss required cryptographic assumptions nil empty bit string consn usual concatenation returns digits bit strings size returns digits 
emphasize tags added messages 
tags particular tags encryption harmful esym soundness 
expect formal equivalence enc esym enc holds computational world case tagged encryption 
case tagged encryption adversary tag check success decrypting enc simplicity assume loss generality encryption keys size blocks data 
assume keys generated uniform distribution 
difficult prove implementation unconditionally esym sound induction structure terms equational proofs true formal equality holds probability concrete world 
note equation decn satisfied encryption key length preserving injective surjective 
studying esym soundness need characterize statically equivalent frames 
specifically show theory transparent 
proposition 
closed frame 
exists transparent frame esym 
proof proposition relies lemma stepwise rewrite frame transparent frame 
lemma 
closed frame normal form 
subterm form enc dec head tail fresh name sort assume deducible esym esym obtained replacing occurrence proof lemma appendix prove proposition applying lemma repeatedly initial frame 
procedure terminates rewriting step decreases total size non deducible subterms frame 
resulting frame transparent 
contradiction suppose transparent define father largest subterm easy see necessarily form enc dec head tail esym lemma applies 
note subterm esym implies esym 
consequence procedure yields unique transparent frame modulo renaming matter order subterms substituted 
provided esym decidable procedure associating transparent frames frames effective 
noticed section obtain proof decidability esym proposition 
notice statically equivalent transparent frames may equal modulo renaming consider instance enc esym 
study esym soundness problem classical cryptographic assumptions 
standard assumptions ciphers include notions super pseudo random permutation notions indistinguishability ind pi cj 
particular ind denotes indistinguishability chosen plaintext chosen ciphertext attacks 
notions relations studied notably 
initially ind assumptions apply block ciphers specialized plaintexts size 
interestingly sufficient imply esym soundness frames contain plaintexts heterogeneous sizes encrypted key 
introduce strengthened version ind applying collection ciphers complexity parameter number blocks size contained plaintexts ciphertexts 
may note exist operation modes turn fixed size block cipher realizing cipher handles variable length inputs preserving 
refer reader example mode 
define ind assumption considering experiment stage adversary key randomly chosen stage access encryption oracles decryption oracles outputs plaintexts possibly data stage random bit drawn receives data challenge ciphertext mb outputs bit successful iff submitted encryption oracle decryption oracle 
classical characterization deducibility entailing decidability detailed lemma appendix define advantage adv ind successful ind assumption holds iff advantage probabilistic polynomial time adversary negligible 
holds inverse encryption scheme iff holds collection ciphers 
previous restrict frames atomic keys encryption cycles 
specifically closed frame atomic keys subterms decn name 
atomic keys say encrypts written iff exists subterm form decn appears key appears position right hand argument decn 
encryption cycle tuple 
km 
km 
effect condition key allow considering terms free encryption cycles instance 
improvement suggested 
state esym soundness theorem 
closed frame formed iff normal form atomic keys contains encryption cycles uses head tail symbols 
theorem esym soundness 
formed frames domain 
assume concrete implementations encryption inverse satisfy ind assumption 
esym 
proving theorem establish computational counterpart lemma 
lemma 
closed frame normal form atomic keys encryption cycles 
subterm form enc respectively dec name sort data fresh name sort assume occurrences positions encryption decryption key enc dec appear encryption decryption concrete implementations encryption inverse satisfy ind assumption 
obtained replacing occurrence notice hypothesis lemma stronger formal version lemma 
instance encryption key required atomic condition implies deducible 
said head tail symbols 
proof lemma 
proving lemma consider example formed frame enc enc appear esym 
frame statically equivalent 
problem prove indistinguishable 
hard see case probability concrete value negligible 
consequence phenomenon intuitively need prove lemma limited form esym faithfulness time 
formally write number distinct subterms head symbols enc dec occurring respectively frame term pn qn properties pn lemma holds provided normal closed frame containing atomic keys encryption cycles maximal subterm form enc dec fresh name sort occurrences key positions enc dec 
qn normal terms sort atomic keys frame encryption cycles probability negligible 
prove pn qn mutual induction precisely prove statements pn qn qn pn qn 
vacuously true 
pn qn 
subterm names satisfying conditions lemma 
naturally case decn similar 

xn 
provided adversary able distinguish build adversary ind assumption encryption described follows 
name sort appearing draw value 
draw value fresh name sort list 
xi sort si compute si recursively follows en decn dn 
tn 
tn remaining cases written en 
dn 
encryption decryption oracles ind game challenge ciphertext obtained submitting plaintexts 
subterm encryption decryption may assume computed call en 
dn 
submit concrete frame 
xn tn return answer 
distribution computed submitted equals depending whichever encryption respectively case en simply random number 
probability guesses right answer may happen meet second requirement winning ind game exists subterm ii exists subterm decn 
probability negligible construction 
subterms subterm frame encryption cycles 
induction hypothesis qn implies probability negligible 
ii challenge ciphertext encryption second argument en probability negligible en 
recall normal form decn 
decn subterms subterm decn frame decn encryption cycles induction hypothesis qn implies probability en negligible 
simplify case analysis convenient introduce lemma lemma 
terms sort list define th projection term sort list head tail 
tail times esym iff esym ii negligible iff negligible 
notation stands normal form lemma sufficient prove sort data normal form 
notice encryption cycles encryption cycles sorting system rewriting rules reduced term sort data may forms 
constant 
name sort data 
projection name sort list 
projection encryption decryption sort list enc dec dec enc 

contain encryption decryption symbol cases case analysis occur property follows directly 
qn pn qn 
distinct closed normal terms 
assume encryption cycles composed keys 
terms say form constant name projection name 
form instance enc dec 
pn fresh name particular probability components equal negligible 
assume yields concrete value significant probability 
list sort build adversary ind game follows name sort appearing draw value ii 
draw value iii 
compute recursively follows fresh name sort list en decn dn 
vn 
vn remaining cases conventions iv 
en return return 
guesses correct answer non negligible probability 
property qn conclude advantage non negligible 

suppose enc enc cases decryption symbols similar 
encryption cycle may assume instance maximal 
maximal subterm form enc dec 
pn fresh name apply qn 
proof lemma 
point easily shown induction equations esym 
ii notice clear unconditional esym soundness proof theorem 
unconditional esym soundness prove property frames normal form 
proving lemma lemma 
assume concrete implementations encryption inverse satisfy ind assumption 
formed normal frame transparent frame associated algorithmic proof proposition transparent frame uniquely defined modulo renaming names 
recall proposition ideal ideal soundness criterion holds formed normal frames conclude proposition 
notice ideal semantics easily avoided statically equivalent transparent frames may equal modulo renaming bound names 
proof lemma 
prove property induction number encryptions decryptions non deducible keys 
formedness condition transparent frame 
suppose 
encryption cycle choose atomic key appearing maximal encryption relation 
deducible maximal contains head tail symbols occurrences encryption decryption keys 
maximal subterm form enc dec 
apply lemma conclude induction hypothesis obtained frame 
note cryptographic assumptions 
cryptographic assumptions theorem may appear strong compared existing passive adversaries 
unavoidable allow frames contain encryption decryption symbols 
case frames compared contain decryption symbols proofs easily adapted encryption scheme ind ind defined similarly ind adversary access decryption oracle 
assumption realizable practice variable input length cipher 
possible recover classical assumption ind modeling mode electronic code book 
consider new symbols enc data data data dec data data data define symbols decn formally concretely recursively consn enc decn consn dec decn equations dec enc enc dec define formed frames normal forms contain encryption cycles 
similar techniques applied show holds formed frames soon implementations enc dec ind equivalently enc 
note formedness assumptions 
may note possible slightly relax assumptions formedness frames 
particular allow encryption cycles deducible keys instance allow frame enc enc currently discarded 
extensions essential results prefer avoid unnecessary clutter keep definitions simple 

developed general framework relating formal computational models security protocols presence passive attacker 
results models allowing arbitrary equational theories 
define soundness faithfulness cryptographic implementations respect models 
provide soundness criterion sufficient necessary theories 
provide new soundness results exclusive theory ciphers lists 
direction study soundness theories 
interesting case combination theories considered modeling exclusive ciphers lists 
interesting open problem generalize notion transparent frames include probabilistic encryption retaining essential properties transparent frames 
ambitious extension consider case active attacker presence general equational theories 
acknowledgments 
anonymous reviewers helpful suggestions 
partially supported aci jc ara 
baudet cortier kremer computationally sound implementations equational theories passive adversaries proc 
nd international colloquium automata languages programming icalp vol 
lncs springer pp 

dolev yao security public key protocols ieee transactions information theory 
goldwasser micali probabilistic encryption journal computer system sciences 
abadi rogaway reconciling views cryptography computational soundness formal encryption proc 
st ifip international conference theoretical computer science ifip tcs vol 
lncs pp 

comon shmatikov possible decide cryptographic protocol secure journal telecommunications information technology 
cortier survey algebraic properties cryptographic protocols journal computer security 
abadi fournet mobile values new names secure communications proc 
th annual acm symposium principles programming languages popl pp 

corin analysing password protocol security line dictionary attacks proc 
nd international workshop security issues petri nets computational models vol 
entcs pp 

baudet deciding security protocols line guessing attacks proc 
th acm conference computer communications security ccs acm press pp 

abadi cortier deciding knowledge security protocols equational theories proc 
st international colloquium automata languages programming icalp vol 
lncs pp 

blanchet automatic proof strong secrecy security protocols proc 
th ieee symposium security privacy ssp pp 

ad bana scedrov computational information theoretic soundness completeness formal encryption proc 
th ieee computer security foundations workshop csfw pp 

micciancio warinschi completeness theorems abadi rogaway logic encrypted expressions journal computer security 
laud computationally secure information flow ph thesis universit des saarlandes 
laud corin sound computational interpretation formal encryption composed keys proc 
th international conference information security cryptology vol 
lncs pp 

ad herzog bana scedrov soundness formal encryption presence key cycles proc 
th european symposium research computer security esorics vol 
lncs pp 

backes pfitzmann waidner composable cryptographic library nested operations proc 
th acm conference computer communications security ccs acm press pp 

backes pfitzmann symmetric encryption simulatable dolev yao style cryptographic library proc 
th ieee computer science foundations workshop csfw pp 

backes pfitzmann waidner symmetric authentication simulatable cryptographic library proc 
th european symposium research computer security esorics lncs pp 

cortier warinschi computationally sound automated proofs security protocols proc 
th european symposium programming esop vol 
lncs pp 

lakhnech completing picture soundness formal encryption presence active adversaries proc 
th european symposium programming esop vol 
lncs pp 

canetti herzog universally composable symbolic analysis mutual authentication key exchange protocols extended proc 
rd theory cryptography conference tcc vol 
lncs pp 

laud symmetric encryption automatic analyses confidentiality active adversaries proc 
ieee symposium security privacy ssp pp 

datta derek mitchell shmatikov probabilistic polynomial time semantics protocol security logic proc 
nd international colloquium automata languages programming icalp vol 
lncs springer pp 
lisboa portugal 
blanchet computationally sound mechanized prover security protocols ieee symposium security privacy ieee computer society press pp 

backes pfitzmann limits cryptographic realization style xor proc 
th european symposium research computer security esorics vol 
lncs pp 

abadi warinschi password encryption analyzed proc 
nd international colloquium automata languages programming icalp vol 
lncs pp 

abadi baudet warinschi guessing attacks computational soundness static equivalence proc 
th international conference foundations software science computation structures fossacs vol 
lncs pp 

bana computational soundness formal indistinguishability static equivalence proc 
th asian computing science conference asian vol 
lncs springer pp 

kremer adaptive soundness static equivalence proc 
th european symposium research computer security es vol 
lncs springer pp 

comon cortier computational soundness observational equivalence proc 
th acm conference computer communications security ccs acm press pp 

abadi fournet mobile values new names secure communication proc 
th acm symposium principles programming languages popl pp 

cryptographic impact groups infeasible inversion master thesis mit 
rivest notion pseudo free groups proc 
st theory cryptography conference tcc vol 
lncs pp 

goldwasser bellare lecture notes cryptography 
micciancio rsa group pseudo free advances cryptology proc 
eurocrypt vol 
lncs pp 

phan pointcheval security ciphers semantic security pseudo random permutations proc 
selected areas cryptography sac vol 
lncs pp 

halevi invertible universal hashing encryption mode advances cryptology proc 
crypto vol 
lncs pp 

bellare rogaway construction variable input length ciphers proc 
th workshop fast software encryption fse vol 
lncs pp 

march cime rewrite tool cime lri fr 
general results static equivalence prove general properties static equivalence concerning free symbols 
establish useful interpolation lemma 
term 
un free symbol see section name sort cutting function cutu defined recursively follows cutu variable name ui ti cutu 
tk cutu 
cutu tk effect function cutu substitute subterms equal modulo lemma 

un term free symbol 
name sort terms implies cutu cutu 
proof 
birkhoff theorem means exist 
mn mn denotes step rewriting equation generating set oriented direction 
prove property induction suffices consider case 
precisely assume exists equation position substitution definition free symbols may assume occur consider cases depending cutting function cutu cuts subterm 
exists proper prefix 
tk ui ti 
consider smallest satisfies property 

ti 
tn 
terms 
tk 
ti 
tn substituted cutu cutu 
cutting position proper prefix means cutu cutu cutu cutu cutu fresh variable 
cutu cutu free 
deduce cutu cutu cutu cutu cutu cutu lemma establish simple properties free symbols 
corollary 
free symbol 
tn term type 


un appropriate sort 
tn 
un iff ti ui 

term sort appear proof 

tn 
right left implication trivial 

tn 
un 
contradiction assume exists ti ui 
fresh names sort 
apply lemma equation successively cutu 
un 
obtain degenerated contradiction 

assume 
tn lemma occur obtain fresh name degenerated contradiction 
ready prove propositions 
proposition 
terms sort 
assume free symbol hs key hash sort key degenerated 
consider frame hs hs fresh name 
distinct fresh names sort hash 

proof 
terms var dom names names 
assume 
substitution hs hs 
equational theory stable substitution names fresh names 
conversely assume 
hs 
lemma cutu cutu 
appear corollary holds cutu cutu 
prove cutu hs 
cutu hs hs cutu 
appear corollary cutu 
similarly applying cutu hs obtain cutu cutu 
proposition 
frame term sort assume free symbol hs key hash sort key degenerated 
hs fresh variables fresh name sort key fresh name sort hash 

proof 
terms var dom names names 
prove implies similarly proposition 
conversely assume 
hs 
lemma cutu cutu 
prove cutu 
exists subterm variable hs variable form hs implies deducible contradiction 
deduce cutu similarly cutu 

corollary appear cutu cutu 
proposition 
terms sort 
assume free symbol hs key hash key degenerated 
hs hs 
fresh name sort hash 
proof 
terms var dom names names 
prove implies similarly proposition 
conversely assume 
hs 
lemma cutu cutu 
appear corollary cutu cutu 
obtain cutu 

static equivalence groups establish properties static equivalence equational theory abelian groups defined section 
purpose characterize equivalence classes representation lemma 
xa xg respectively set variables sort hash respectively 
hash respectively set names sort hash respectively 
ac equational theory corresponding subset equations modeling associativity commutativity operators 
call unitary monomial sort function xa zero finite number entries 
function considered term sort modulo ac ac xa empty products considered term denotes term 
denote ma set unitary monomials times sort canonical form sort function ma zero 
consider function term sort modulo ac ac ma empty sums considered term integers naturally represented 

sort canonical form sort function mapping terms xn canonical forms sort zero function evaluates constant finite number entries 
consider canonical form term sort modulo ac ac xg empty products considered equal 
canonical form sort hash denoted variable sort hash name sort hash hash canonical form sort considered term 
lemma 
term sort hash respectively exists unique canonical form respectively respectively 
proof sketch 
show existence canonical form term induction structure instance canonical forms obtain canonical form rearranging product modulo necessary induction exponents 
show uniqueness normal form sufficient show canonical terms equal terms modulo equal mathematically 
formally established studying ac normal form canonical form respect ac convergent rewriting system 
xu xu xv xu xu yu xu xu rewriting system obtained orienting completing equations generating ac tool cime 
proposition 


proof 
terms sort var dom names names 
assume 
substitution 
equational theory stable substitution names names 
conversely assume 
sort var 
sort equivalent suppose 
var dom names names canonical form form 
xi represent closed terms disjoint names 
conclude xi 
proposition 
frame frame 

proof 
terms var dom names names 
assume 
substitution 
equational theory stable substitution names names 
conversely assume 
sort var 
sort hash 
suppose var cases trivial 
free symbol corollary equivalent var names names canonical form form terms variable contain contradicts static equivalence ciphers lists proving lemma introduce handy lemma characterize deducible terms 
lemma 
closed frame normal form term normal form 
esym 
tk ti deducible subterms context contain private names names 
proof 
definition esym exists term names names esym prove lemma induction size base case xi trivial 

mk 
consider case dec cases similar 

applying induction hypothesis obtain 

deducible subterms contexts contain names 
dec 
dec normal form 
case convergence dec result 
dec normal form 
convergence dec normal form enc 
enc 

means deducible subterm 
deduce deducible subterm result 
start proof lemma 
proof 
follows say term context public contain names occurring 
esym stable substitutions names 
prove introduce lemma 
set 

np names occurring 
lemma 
context esym 
np 
np exists public context 
np 
lemma proved inspection rules reduction occurs position reduction 
np occurs head 

np 
np instance lefthand side rule clearly 
np obtained replacing position instance left hand side rule normal form possibilities 
np 

np enc ni 
np 
case ni form dec 
np 
lemma esym 
np 
np subterm ni 
np deducible 
cases obtain contradiction 

np subterm 
np enc dec nj subterm contradicts normal form 
ni 
np deducible contradicts esym 
np dec ni nj 
case similar previous 

np cons ni 
np 
case ni form head 
np tail 
lemma esym 
np 
np subterm ni 
np deducible 
previously cases obtain contradiction 

np subterm 
np cons head tail subterm contradicts normal form 
ni 
np deducible tail deducible means head tail deducible deducible contradiction 

np cons 
np ni 
case similar previous 
show 
esym esym 
convergence exists term applying repeatedly lemma obtain 
assume proved 
esym concludes proof 
remains prove lemma 
lemma 
terms ti deducible esym ti ti subterm 
implies 
lemma proved induction sum size 
notice lemma subterm ti verifies deducible subterm base case trivial 



applying induction hypothesis obtain 
difficult case 

notice 
occur 
subterm impossible construction deducible 
subterm applying lemma get immediate subterms deducible contradicts choice 
