directions planning understanding flow time planning bart massey cis tr 
june notion general purpose planning artificial intelligence surprisingly little improvement efficiency planning algorithms 
efficient high speed search essential planning algorithms proposed date achieved search algorithms solid understanding search space 
concept search directionality searching temporally causally forward backward quite important designers planning algorithms 
concept appears poorly understood 
series constructions experiments shown successful planners capable forward chaining backward chaining behavior understanding directionality issues planning necessary precursor construction efficient planners 
begins discussing underpinnings directionality planning physical psychological computational temporal arrows directionally orient planning problems 
previously property directionality planning described direction planning problems fundamental property standard formalism 
planning problems reversed allowing planner search opposite normal direction change planning algorithm 
novel technique described determining directional behavior existing planners experimental results implementation technique reported 
analysis planner direction better understand search strategy modern planning algorithms satisfiability planning 
consequences extensions results 
results shed new light construction planning algorithms high speed search move closer making planning practical real problems 
department computer information science university oregon copyright bart massey technical report reformatted version author doctoral dissertation completed june 
examining committee dr matthew ginsberg chair dr amr sabry chair dr christopher wilson dr john dedication father dr william massey 
dedication science family inspired life tragic death left void life filled 
god flow 
wife putting baby benjamin just 
advisor matt ginsberg set track kept moving forward 
matt encouraged share small insights chapter challenged derive prove results chapter conceived need extrinsic planner directionality test eventually resulted chapters 
serious writing 
dissertation impossible complete 
amr sabry committee 
cynthia brown support past months project completed 
current past members university oregon computational intelligence research laboratory cirl including matt jimi crawford brian david etherington david joslin dave clements weiss andrew parkes great ideas useful discussions 
david etherington detailed reviews chapter 
dave clements reading early drafts 
faculty staff students university oregon computer information sciences department 
cirl support vital 
folks numerous list provided help advice encouragement 
sponsored part air force office scientific research agreement number defense advanced research projects agency air force research laboratory rome ny agreement numbers 
views contained author interpreted necessarily representing official policies endorsements expressed implied afosr darpa rome labs government 
contents history background 
planners 
early planners 
means analysis 
persistence 
strips planning 
propositional strips planning 
complexity props 
protection conditions causal links 
predicate strips planning 
extensions strips 
comments 
metaphysics directionality directionality planning 
time arrow directionality physics 
mind eye directionality thought 
electronic brain directionality algorithmics 
confounding issues 
directionality hierarchy 
directionality abstraction 
limits strips 

strips problem reversal props actions frame axiom 
reversibility deleted preconditions 
reversal compilation 
positive preconditions 
don care effects 
partial goal states reversal 
extensions reversibility 
reversal 

determining directionality planners search space planning 
search direction 
propagation 
propagating planners 
way functions 
boolean circuits 
nbc planning problems 
reversal 
planner directionality test 
construction 
bit commitment 
bit commitment network 
final construction 
correctness 

measuring planner direction implementation 
experiments 
methodology 
directionality asp 
directionality plan 
directionality ucpop 
directionality graphplan 
directionality blackbox 
parallel plans 
graphplan 
blackbox wsat 
blackbox relsat 
results 
directions planning don know don care props actions 
unrestricted dc effects 
dc effects initial state 
explicit dc action effects 
don know effects 
dc dk conditions 
composing way planning problems 
tractability circuit planning 
summary expressiveness directionality strips 
review 


list tables possible pairs possible pairs possible pairs possible pairs 



truth table left projection gate 
possible pairs possible pairs 

list figures scheme compilation positive preconditions 
scheme extending valued logic 
scheme reversal rules 
way function planning problems 
way planning problem bit commitment 
operators left projection gate 
schematic left projection gate 
gate fluent labeling bit layer 
bit commitment network 
forward way planning problem 
backward way planning problem 
way function 
detector testbed organization 
asp directional performance time 
asp directional performance search time 
asp directional performance nodes 
plan directional performance time 
plan directional performance nodes 
ucpop directional performance time 
ucpop directional performance nodes 
graphplan directional performance graph nodes 
graphplan directional performance time 
graphplan directional performance search nodes 
blackbox graphplan directional performance time 
blackbox wsat directional performance time 
blackbox relsat directional performance time 
blackbox relsat directional performance relsat time 
blackbox relsat directional performance variables valued 
parallel graphplan directional performance graph nodes 
parallel graphplan directional performance time 
parallel graphplan directional performance search nodes 
parallel blackbox wsat directional performance time 
parallel blackbox wsat directional performance wsat time 
parallel blackbox wsat directional performance wsat flips 
parallel blackbox relsat directional performance time 
parallel blackbox relsat directional performance relsat time 
parallel blackbox relsat directional performance variables valued 
reversal rules restricted dc effects 
scheme extending valued logic 
scheme full reversal rules 
bidirectional planning problem 
island planning problem 
chapter traditional distinctions planning forward chaining temporally causally earlier states states backward chaining earlier states 
modern planning algorithms exhibit behaviors biased direction 
earliest planners tended search forward state space generation planners tended backward means analysis 
surprisingly difficult pin notions forward backward chaining 
useful understand real differences planning algorithms motivated distinction 
planning known intractable general difficult distinguish efficiency planning algorithms worst case complexity arguments 
hard produce real world problems simplified assumptions propositional strips planning props 
fundamental claims successful planners capable forward chaining backward chaining behavior 
understanding directionality issues planning necessary precursor construction efficient planners 
results support claims 
various external internal considerations relevant directional chaining planning surveyed order understand scope nature problem 
shown construct reversal strips problem forward chaining reversed problem corresponds backward chaining original problem vice versa 
shown construct class strips problems property tractably solved directional branching 
results experimentally explore directionality existing planning algorithms analyzing performance differences planner implementations forward backward tractable problems underlying planning algorithm 
proceeds follows remainder chapter gives brief background planning concentrating props 
chapter discusses philosophy history directionality strips 
chapter describes algorithm transforming strips problem isomorphic problem planning direction transformed instance corresponds planning direction original instance 
chapter describes construct strips problems tractable direction chapter reports empirical results problems determine directionality existing strips planners 
chapter clears loose ends suggests topics research summarizes general draw 
history background ability formulate complex multi step plan achieving goal characteristics separates humans highest animals 
chimpanzees observed form plans steps 
compared skills planning skill language tool oft cited measures intelligence quite profound 
association intelligence planning skill natural pioneers artificial intelligence ai turn planning ai problem domain 
addition practical advantages computerized planning obvious early planning concentrated automatic programming computer constructs program specification problem solved 
planners notion planning difficult pin details definitions planning agree general outline problem current state world initial state desired state world goal state collection methods change world state actions generative planner mechanism selects actions transforming initial state goal state 
actions described terms world states executed preconditions world states produce executed effects 
useful distinguish action descriptions types part planning problem description action instances performed execution 
action types referred operators action instances actions 
single operator planning problem description may correspond actions plan produced planner 
common convention adopted referring operators actions situations context unambiguous 
kambhampati describes useful distinction classical planning arcane planning methods terms restrictions world states actions planning problem 
classical planning restrictions summarized follows world states discrete complete unchanging freely fully observable 
actions atomic deterministically conjunctive preconditions deterministic effects 
particular classical planning problems exclude forms hierarchical planning problem sort action domain hierarchy part problem description 
generally believed hierarchical problem decomposition important part human planning process 
classical planning hope hierarchical information extracted planning algorithm classical description 
plenty challenge non hierarchical domains 
concerned classical planning largely restricted versions classical planning 
problem considered hard widely hoped progress lead insight solution general planning problems 
early planners collections papers edited allen hendler tate provides early history planning 
historically research moved powerful general conceptions planning planners progressively simpler notions research planning probabilistic domains 
earliest planning treated form automated theorem proving available action types axioms theorem prover asked build constructive proof goal state reachable initial state 
descriptions states actions general largely result expressed powerful formalisms sort planning intractable realistically sized problem 
attempts understand computational difficulties led notions planning process widespread means analysis 
means analysis important consideration arising study human reasoning planning concept means analysis 
fundamental idea concept human reasoning contains strong notion cause effect 
reasonable suppose humans plan choosing particular goal achieved selecting action achieves means 
notion adopted nearly ai planning systems method controlling plan generation 
typical planner attempts choose goals elements goal description subgoals intermediate goals arising planning process reasonable order satisfying means action action sequence 
researchers mcdermott questioned means analysis best approach planner control 
large amount experience gained mechanism intuitive appeal suggest continue dominant choice planning algorithms 
persistence principal sources inefficiency theorem proving planners arises mccarthy hayes called frame problem 
problem termed persistence problem purely logical formulation planning explicitly enforce condition elements world state change spontaneously result action execution 
unfortunately enforcing persistence require quite general axioms order formulation axioms propositional formulation 
case reasoning plans may intractable due complexity 
strips planning advent fikes nilsson stanford research institute problem solver strips marks major change view planning problems 
strips formalism frame axioms encode persistence implicit formalism explicit 
strips introduces notion add lists delete lists action changes world state setting values state variables true false 
set values persist changed action 
approach persistence problem allows planner avoid having prove theorems state variables unaffected action planner automatically infer values variables action 
mcdermott provides general state strips planning 
short imposing restrictions formalism preconditions effects actions expressed strips planning today terribly different strips planning 
propositional strips planning simplest notion planning currently interest ai researchers propositional strips planning props 
props world states values finite set boolean state variables fluents 
preconditions operator list atomic formulae fluents hold order action executed 
effects operator list fluents forced true execution action add list list fluents forced false execution action delete list 
remainder adopt standardized notation similar bylander props planning problems 
principal difference formalism bylander introduces notion legal actions plans 
bylander follows notion originally due mccarthy action may executed world state effect preconditions satisfied 
convenient ways important follows chapters understand conditions plan legal 
props planner works domain consisting operators preconditions effects expressed terms propositional conjunctions ground state variables fluents 
preconditions effects operators initial goal states problem represented conjunctive formulae fluents definition element wise negation element wise negation set defined denoted syntactic definition negation leads naturally notion set consistent collection atoms 
definition consistent set set consistent consistent set atoms thought conjunction 
definition conjunctive formulae set conjunctive formulae set defined consistent set conjunctive formulae error denoted defined distinguished element denoting error condition 
definitions provide basis formal definition operators 
denoted definition props operator props action type operator tuple conjunctive formula denoting preconditions conjunctive formula denoting effects 
effects empty formula 
op operators usually included real domain descriptions 
action instantiation operator plan 
conventional specify fluents added deleted world state action 
definition props additions deletions additions action collect fluents occur positively deletions collect fluents negations occur specifically example action additions deletions definition action execution closely follows bylander explicit error state definition props action execution state resulting executing action state defined action legal state part definition action execution result executing legal action consistent state consistent state 
desire expect property hold 
note set true error state produced action execution preserve error state 
bit confusing alternatives notationally cumbersome 
proposition legal action consistent state consistent 
proof contradiction 
inconsistent fluent cases 
mention definition way achieve case definition impossible contradiction 
consistent definition definition implies definition contradiction 
consistent definition definition implies definition contradiction 
operators written horizontal bar conjunctive formula specifying preconditions bar conjunctive formula specifying effects 
props operator moves block block block standard formulation infamous blocks world domain look clear clear clear clear action executed state block clear block clear block block action executed block clear block block block clear block block longer clear 
operator mentions fluent appears precondition effect operator regardless sign operator mentions different fluents 
straightforward define props planning domains planning problems plans 
definition props domain problem props domain tuple set fluent symbols set operators 
problem tuple domain conjunctive formulae fluents representing initial goal states respectively 
state commonly goal state partial fluent domain mentioned positively negatively specified 
states total definition props plan plan sequence actions state executing actions turn plan legal state plan valid state legal satisfies goal 
plan executed blocks different blocks implicit fact ground rule variables explicit uniqueness conditions needed 
see pp 
discussion predicate strips 
plan legal actions legal 
proposition plan legal state legal proof induction length base case quantified condition trivially true legal inductive case assume proposition true action legal state illegal illegal definition action execution 
legal definition proposition holds action execution legal 
complexity props classic analysis props complexity bylander 
shows variety strong restrictions restrictive props model planning pspace complete measures size problem description number operators number fluents 
intuition result length plan actions exponential number fluents state 
best known example towers hanoi problem disks 
encoded props planning problem fluents indicating pair disks top second operators possible move disk second third 
minimum length solution problem requires actions 
prove props planning pspace hard sufficient observe dtm transition encoded planning operator details see bylander 
checking correctness props plan done just bit fluent starting initial state simply checks preconditions action hold modifies state effects action 
action produces goal state plan solves problem 
props planning problem pspace pspace complete 
restrictions props planning may increase tractability 
foremost evident fixing polynomial length limit plans asking related question exist plan length solves props planning problem brings complexity planning np 
props planning proven np complete restriction 
bylander gives restrictions form operators problem np complete surprisingly difficult 
ginsberg shows props planning np complete requirement preconditions operators met relaxed slightly 
general planning appears high complexity discouraging result ai researchers 
protection conditions causal links classical planning domain fluent value may thought caused effects particular action 
common tactic formalizing classical planning regard initial conditions effects dummy action plan goal preconditions dummy action plan 
notion natural expression notion means reasoning 
natural outgrowth means reasoning protection condition causal link annotation plan indicating action effect causes particular value fluent needed action preconditions 
causality flows forward time precede expecting produce precondition interval value changed 
annotation regarded protection condition actions effect naturally allowed phenomenon referred shadowing 
annotation regarded causal link shadowing naturally disallowed 
choices reasonable complex tradeoffs 
predicate strips planning propositional strips useful tool algorithmic analysis design planning systems 
practice proven insufficiently expressive easily encode realistic planning domains 
formulation known predicate strips preds standard planning 
persistence assumption original strips formulation strongly resembled axiomatic order logical planning methods preceded 
indicated formalism simplified significantly reducing expressive power 
simplified preds formalism easier understand control looks props effects preconditions restricted conjunctions ground atomic formulae 
conjunctions predicate formulae implicitly universally quantified 
details differ system system generally uninteresting ways sufficient consider flat predicates variables quantified set ground objects 
allowing variables shared preconditions effects action possible succinctly describe class actions action schemata 
blocks world planning problem just action schemata table table clear clear clear clear table table clear clear clear table table clear clear note initial state extended addition specification actual blocks world problem type predicate table defined 
closed world assumption require large number ground initial conditions table table table table awkward simple extension preds removes requirement discussed heading types 
extensions strips convenience increased expressive power cases number extensions strips formalism proposed implemented 
included options pddl problem description language 
common extensions described considered subsequent chapters 
closed world assumption convenient assume fluent explicitly mentioned state description false called closed world assumption cwa implicit planning literature 
props assumption useful primarily specifying initial state practice set initially true fluents smaller set fluents 
goal state typically specified partial state description fluents specified may true false goal state 
simple fluent renaming permits recoding arbitrary props problem description fluents false initial state 
systems graphplan initial state goal description may explicitly false fluents 
general require extra fluents translate arbitrary problem description described pp 
chapter change expressiveness complexity props planning 
preds cwa problematic 
usually stated way variables range finite sets ground values closed world referred 
situation cwa previous paragraph holds 
types cwa standard preds formulation odd property closed world implicit explicitly described 
distinction arguments various predicates 
example distinction table block blocks world description provided awkward timeless predicate sole purpose define table 
natural formulation preds allows explicit declaration typed objects domain permits implicit type predicates 
conditional effects realistic environments effect action differs depending situation executed 
ginsberg smith comment giving various examples household robot environment 
point objects move particular problems strips planners exponential number operators required correctly handle possible subsets objects may need move unit 
proper indexing allows correct operator selected linear time better large size problem description generally viewed making approach intractable 
standard solution problem conditional effect allow specified additions deletions action conditional properties preceding state 
conditional effects straightforward planners deal easy planning domain engineers understand making popular addition strips 
domain axioms preds implementations normally require explicit representation world states props fluent values usually stored explicitly 
problematic reasons 
size representation large difficult reason 
second action effects quite complicated attempting maintain complex state information 
blocks world example clear fluents normally maintained block block move action 
desirable maintenance performed invoking obvious rule block clear block top 
domain axiom enforce exactly condition clear fluents derivatives world state part 
bit tricky give sound useful semantics domain axioms tractable planners 
domain axioms written full order logic may tractable 
safety constraints safety constraint mechanism ensuring specified condition holds states plan dont disturb constraint weld etzioni 
name implies mechanism suitable mainly ensuring plan includes state undesired consequences 
support safety constraints appears easy add existing planners utility mechanism somewhat unproven 
small selection extensions proposed strips planning noted extensions considered mainly understanding research results apply modern general purpose planners 
comments noted ai researchers working planning years classical planning years 
time surprisingly little progress 
possible exception wilkins sipe author aware domain independent classical planning engine fielded application 
limited toy domains blocks world latest general purpose classical planners able provide provably optimal solutions problems humans probably 
humans provide solutions problems reasonably quickly permitted neglect optimality considerations existing automatic mechanisms 
relating properties planning algorithms problem domains strips formalism essential identifying expanding classes tractable classical planning problems 
success graphplan achieving dramatic speedups large class benchmark problems entire ai planning community 
unfortunately poorly understood graphplan achieves level success appears planner serves sort test planning researchers see exactly desire expect see 
remainder takes different approach improving planning performance 
selecting particular feature strips planning distinction forward backward chaining planners distinction explored terms interaction formalism planners problems 
important results established showing ultimately unidirectional planners poor performance certain classes tractable problems giving method transforming problems increase tractability simple planners 
hope similar approach applied strips issues eventually lead high performance planners built principles driven science engineering 
time tell hope come 
chapter metaphysics directionality early history ai planning important distinction forward backward chaining planners 
distinction observation superficially forward flow time plan execution appears induce asymmetry distinguishes direction chaining 
distinction supported human introspection planning empirical results showing forward backward chaining planners superficially similar dramatically different performance characteristics 
result intuitions directionality ai researchers fairly strong assumptions advantages backward chaining 
typical kambhampati comment compared forward state space refinement planning backward state space refinement generates plan sets fewer number sic components concentrates actions relevant current goals 
focus relevant actions turn leads lower branching factor planners consider plan set components different branches 
kambhampati apparently intuition number subgoals active time small real world problems backward chaining produce narrower search tree 
construct artificial problems forward search tree narrow backward search tree large apparently kambhampati believes realistic 
sort comment hard evaluate difficult separate facts hypotheses 
mcdermott suggests working backward forward done symmetrically 
planning forward direction starts complete situation description computing result action retains complete description 
planning backward direction proceeds goal statement merely constrains aspect final situation 
requires solving regression problem 
suggestion asymmetry forward backward planning result asymmetry total initial state partial goal description 
truth somewhat deeper natural formulation regression leads partial intermediate states presence total goal state 
clear role time direction planning poorly understood 
remainder chapter attempts build framework somewhat easier understand role time planning execution 
facilitate presentation chapters follow 
putative advantage backward chaining discussed light framework 
directionality planning major reasons planning appear temporally asymmetric fact temporal asymmetry physical world temporal asymmetry thought processes humans appearance apparent temporal asymmetry strips formalism 
section factors considered turn determine role picture strips temporal asymmetry 
time arrow directionality physics physicists reasonable understanding role flow time physical universe 
flow time characterized terms statistical laws known laws thermodynamics state certain changes physical systems normally proceed forward time 
particular second law thermodynamics pp 
states entropy physical system measure disorder tend increase time 
observable consequences law entropy include things tendency objects reach equilibrium temperature surroundings inclination liquids run downhill 
forward temporal direction may defined direction entropy tends increase 
planning perspective key question strips formalism expressive capture physical notions entropy capture temporal arrow 
strips captured physical entropy mean planning entropically illegal action running water uphill impossible formalism 
clearly formalism normally encode physical world case write run water uphill operator just easily run water downhill 
science information theory notion entropy 
confused thermodynamic notion core entirely different 
principal connection notions entropy theoretical lower bound amount energy transferred transmitting single bit information 
purposes key distinction information theoretic entropy appears carry temporal arrow obvious notion information flowing particular time direction 
mistake characterize planning directional informational entropy 
mind eye directionality thought known working example intelligent system biological brain 
human animal brains handle time direction planning 
evidence far clear 
popular view held ginsberg human planners backward goals personal communication 
achieved selecting range operators available produce subgoal 
proponents view point means analysis supposed capture real world problems usually large number actions available world state actions achieve specific subgoal 
form goal directed search employed humans avoid searching large number possible plans humans effectively manage plans simultaneously 
hand humans appear better reasoning state world action state solving regression problem 
faced puzzle mode problem tendency appears try solve 
example trying solve peg solitaire puzzle commercially marketed hi goal initial position appears harder people solving initial goal state 
surprising puzzle principle completely reversible 
writes principle puzzle easy difficult original counterpart 
discovered far theory goes easier visualize full configurations empty ones 
leibniz noted regressing peg feels intuitively different updating state jumping 
fundamental problems forward planning humans appear largely assumptions classical planning pp 

classical planning unexpected happen plan execution world states persist perfectly actions desired effects 
simplifying assumptions humans appear forward planners realworld problems 
puzzle mode problems tend hard humans largely reasons unrelated temporal direction having large amount short term state rapid search required solution 
question directional bias human generated encodings strips domains appears largely 
due part fact large real world problem domains strips encodings 
characteristics small artificial problems generalize typical encoding problems typically addresses qualification problem pruning fluents involved problem 
example gratuitous preconditions trivially satisfied reachable world state side effects unintended unavoidable effects action normally modeled toy problems 
suspect humans routinely constructing operators certain distinctive properties example purpose purpose operator single effect expected reason insertion action plan 
humans may concentrate intended effect omit effects purpose side effects described constructing strips operators 
operator operators available domain exactly undo effects 
humans may wary execution difficulties associated actions undone eschew operators constructing strips problem descriptions 
repeatability action repeatable having executed action possible re establish preconditions 
humans may include operators perceived general utility constructing strips problem descriptions operators essence specificity 
kind reasoning confusing humans tend structure world sorts properties order planning tractable 
properties met real world operators strips descriptions correspond 
absence extensive study notorious unreliability introspection difficult strong assumptions role human thought planning 
formal results succeeding chapters especially important understanding directionality strips planning 
electronic brain directionality algorithmics appear possible sources directional bias strips planning 
strips formalism may easier solve direction due nature persistence 
second particular strips problem domains may easier solve direction 
planning algorithms may choose operate particular direction 
results chapter imply bias strips formalism illusory 
strips problems problem domains individual actions domains shown reversible forward backward reasoning due formalism 
planning problems may biased 
example including operators far effects preconditions problems larger forward branching factor 
leaving goal state partly unspecified extra branching introduced near root backward search tree 
biases real underscore need planners bidirectional optimal performance 
research progress area 
general classes strips planning algorithm typify distinction forward backward planning algorithms 
forward state space search starts initial state produces successor states applying actions preconditions satisfied attempt produce goal state 
argument favor approach total states produced step complicated reasoning actions legal required efficient pruning 
second plan space search typified partial order causal link planning :10.1.1.18.4442
planning starts goal state attempts insert actions plan effects achieve goal state actions satisfy unsatisfiable preconditions actions forth initial state satisfies remaining preconditions 
effects causes means analysis inserting new actions order supply unavailable preconditions leads characterization planning backward 
arguments favor backward planning arise chiefly apparent reduction size search space causes 
initial state totally specified uncommon fluents specified goal state 
number actions needed achieve goal state may limited 
course actions preconditions effects large number fluents usually involved plan just backward steps 
second actions inserted blindly plans response need achieve specific fluent values 
branching factor step planning process lower 
additional reasoning preconditions require additional actions inserted plan accounts slower search rates planners 
hoped reduced search space compensate slowdown 
trend away planners suggested case 
summarize possible sources bias strips planning reality biases appear illusory problematic 
thing certain algorithmic advantage planning forward backward strips formalism uncertain difficult quantify 
confounding issues noted chapter popular extensions strips important concepts planning fails capture 
concepts hierarchy abstraction 
concepts confuse issues directionality introducing approximations planning process jump difficult areas 
may strips formalism appropriate choice general purpose planning implications directionality 
directionality hierarchy discussed chapter hierarchical planning domain problem planner operators considered subordinate 
typical hierarchical planner plan features complex language describing composite operators specifying fashion planner break insert plans 
plan operating non hierarchical domain backward planner shown chapter 
plan partial order techniques favor carefully controlled simple goal regression 
operation plan hierarchical domain raises interesting questions 
hierarchical problem plans subgoal level tend short long plans typically result breakdown levels hierarchical structure 
supposedly backward planner quickly planning problem 
establish invariants hold initial state planning level decomposition hierarchy 
mode operation suggests forward planning state properties prune action selection plan suffixes 
mode operation different typical bidirectional planner deliberately works ends problem 
hierarchical planner asymmetric ability reach front plan quickly accident hierarchy computationally important 
directionality abstraction historically important planners built idea tractable planning achieved operator domain abstraction 
approach salient features operator domain temporarily ignored order get approximate solution problem 
candidate solution refined introducing greater greater levels detail 
approach rarely modern planning systems node cost search decreased point extra complexity dealing abstractions longer profitable 
system earliest planning system incorporate abstraction fundamental feature 
uses simple operator abstraction iteratively refine proposed plan 
notion abstraction extensively context macro operators subplans part domain commonly computed runtime 
idea macro operators avoid repeatedly rediscovering plan hard subproblem 
macro operators fit nicely operator abstraction abstraction produce macro operators may detailed expanded 
hierarchical case abstraction macro operators raise interesting questions directionality planners 
planner strips planner fundamentally forward planner 
possible select single operator highest level abstraction comprises entire plan 
subsequent refinements operator add actions arbitrary points plan order successively preconditions true 
forward nature strips somewhat obscured abstraction 
limits strips noted earlier pp 
chapter assumptions classical planning impose strong constraints planning problem expressiveness hope achieving computationally feasible version planning problem 
soundness strips formalism dependent assumptions classical planning 
unfortunately appears computationally difficult find plans restrictive conditions 
reasonable ask classical planning constraints relaxed formal descriptions planning problems accurate plans obtained useful 
historically done relaxing requirements classical planning world state freely fully observable allowing sensing actions world state complete unchanging searching robust plans actions atomic temporal logic 
strong interest taken allowing world states incomplete dynamic actions nondeterministic means partially observable markov decision process planning 
attempts relax classical planning assumptions planning problem difficult 
addition appear significantly affect issue directionality 
extent regression problem harder relaxed assumptions backward planning difficult 
example zeno planner permits limited regression actions contain preconditions including systems linear inequalities machinery required feat decidedly nontrivial 
popular assumption planning literature backward planners inherent advantage general appears weak foundation 
strips formalism expressive capture physical laws directly physical notions entropy introduce temporal arrow formalism 
similarly human planning appears performed different temporal directions different situations 
appear toy problems sort examples ai humans tend reason backward may say problems general inherent advantage backward planning 
computational properties strips formalism appear directionally biased 
real world problems may favor backward chaining author unaware detailed study assertion 
chapter show forward backward chaining equivalent strong sense strips formalism 
planning algorithms proposed variety result limitations approach 
philosophical discussion directionality planning constrained concepts mechanisms available 
wide range techniques brought bear strips planning appear strongly favor backward planning 
strips encoding may inadequate particularly attractive substitute proposed 
reason believe expressive encodings planning problem backward planning attractive may 
directional arrows planning scarce confusing 
physical world mental world nature formalism provides unambiguous clue 
better understanding obtained detailed theoretical experimental study sort undertaken remainder 
chapter strips problem reversal assumed discussed pp 
inherent directional asymmetry strips formalism independent particular problems domains arising persistence fluent values central strips 
asymmetry largely illusory directional asymmetry strips planning arises specific planning problem specific choice planning algorithm strips formalism 
show simple tractable construction technique domain compilation 
props problem construction produces problem isomorphic set operators fluents set reversals plans exactly isomorphic set plans strong correspondence original reverse domains possible treat forward planning backward planning extends preds allow unidirectional planners plan direction opposite natural direction 
methods transforming operators explored previously example knoblock simplify preds domains graphplan 
methods operator transformation chapter distinguished previous goal controlling search extensive nature compilation schema rewrite operator problem description 
props actions frame axiom vice versa 
technique discussed previously principal advantage claimed strips formalisms earlier predecessors requiring general purpose theorem proving incorporation persistence information strips formalism 
relieves planner burden making inferences general purpose mechanism 
corollary long assumed persistence values past creates causal temporal asymmetry strips planning backward planners goal conditions planning problem initial conditions necessity take different approach forward planners initial conditions goals 
assumption arisen view means analysis central strips planning 
traditional view means analysis chapter fixes fluent value achieved particular point plan means earlier action achieves ensures intervening actions plan interfere persistence achieved value 
sort reasoning central operation original strips system initial version system non interference intermediate actions fluent persistence assumed 
definition seen led directly notion planning 
careful examination props actions suggests actions time symmetric exchanging preconditions effects appears largely locally sound 
persistence effects appears persistence preconditions action preconditions persist action produced 
observation leads notion reversal props planning problem exchanging preconditions effects action exchanging initial goal conditions order obtain problem isomorphic original plans reversal plans original problem 
reversibility deleted preconditions simplest planning algorithm forward state space search plans built initial state repeatedly appending actions 
note produce total state result action apparently know total state preceding action know values fluents unaffected action 
superficially straightforward produce total state preceding action knowing total state action solve regression problem chapter factors intervene 
common strips problem descriptions give partial goal description total goal state 
second importantly strips actions set value fluents mentioned preconditions resulting inability backward planner assume fluent value action taken 
consider fluent cooking problem represents spoon wet action liquid 
forward planner infer spoon wet liquid backward planner determine solely succeeding state formalism spoon preceding state 
action appears irreversible 
total state space search appears require proceeding forward initial state 
section mechanism reversing irreversible operators allowing total state space search direction 
reversal compilation reasonable view process converting props domain problem domain compilation process takes actions fluents source domain translates isomorphic actions fluents target domain 
section gives examples loss information equated entropy physical systems application irreversible planning operator regarded increasing entropy see chapter detailed discussion view 
preds domains contain reversible operators fluents mentioned effects mentioned preconditions 
appears particularly true toy domains actions carefully crafted particular roles plans 
compilation schema culminating domain compilation scheme reverses props domain 
done transforming fluent space operators slightly way irreversible operators may reversed initial goal states may interchanged potentially producing partially specified initial state 
operator corresponding operator reversal fluent corresponds pair fluents values change lock step 
props planning algorithms reason forward effectively effectively reasoning reasoning backward algorithms reason backward forward positive preconditions uncommon props restrict actions planning domain allow positive preconditions 
known lead restriction expressive power planning domains 
reason simple 
force action maintain versions original fluent true true true false 
action adds effect delete vice versa 
definition signed fluents set signed fluents corresponding set fluents shows compilation rules compilation scheme converts planning domain arbitrary preconditions positive preconditions possible way fluent appear action source domain exists rule shows render terms compiled domain 
compilation rules props domain may extended compilation rules props problem obvious fashion simply transforming fluents initial goals states domain compilation rule 
definition signed formula conjunctive formula permits precise description problem compilation props problem compiled problem definition signed note combinations fluents source domain omitted obtained existing combinations persistence example appearance fluent action indistinguishable planning point view appearance explicit persistence useful proofs follow 
scheme compilation positive preconditions compile action compiles fluents separately 
example transformed persistence explicit yielding compile rules subtlety immediately apparent conditions explicitly effects stage implicitly hold preceding state consequence domain structure 
example consider rule 
apparent hold state legally preceding action type compiled domain redundant delete part effect 
reasons clear shortly convenient 
course necessary prove compilation scheme change problem 
definition compilation correctness compilation scheme props problem complete valid plan source domain compiled valid plan compiled domain 
compilation scheme sound valid plan compiled domain produced compiling valid plan source domain 
compilation scheme correct complete sound 
complete compilation scheme existing plans eliminated compiled problem sound compilation scheme new plans allowed compiled problem 
technique proving complete sound somewhat unusual justified fact proof structure repeatedly 
basic idea proof correctness compare goal state preconditions action source problem corresponding formulae compiled problem 
essentially proof proceeds showing valid plan source problem precondition goal state satisfied corresponding plan compiled problem completeness 
valid plan compiled problem shown precondition goal state satisfied source problem soundness 
achieve proofs sufficient note way persistence actions eliminated encoding precondition satisfied earlier effect establishes precondition action establishing effect precondition mentions precondition fluent 
fluent mentioned action normalized form part effect action 
implies establishing action unique 
sufficient compare compilation rules source compiled domains pairwise fashion checking set legal action pairs domain exactly 
table possible pairs proposition correct 
proof completeness soundness argued separately 
completeness loss generality consider valid plan source problem action plan mentions fluent affects due normalization described 
part valid plan precondition satisfied 
happen ways 

may sign initial state precondition action preceding mentioning 
action preceding adds appropriate sign action mentions consider corresponding sequence actions compiled problem particular compiled action mentioned preconditions require exactly see precondition satisfied consider previous cases 
initial state provides precondition appears appro priate sign satisfy 
action provided precondition places restriction treat table enumerates possible ways follow assuming mention intervening action 
left column table indicates rule matches right column indicates rule matches table shows ways supply appropriate sign relation identical source domain 
example instance 
compiled domain source domain mention form follow note argument applies goal fluent goal fluents satisfied compiled problem problem satisfied source problem 
precondition action goal fluent valid plan satisfied compiled problem satisfied source problem compilation scheme correct 
soundness soundness argument similar completeness argument 
loss generality consider valid plan compiled problem action plan mentions fluent part valid plan precondition satisfied 
symmetry assume loss generality precondition precondition satisfied ways 

may occur initial state action preceding mentioning 
action preceding adds action mentions consider corresponding sequence actions source problem particular source action mentioned preconditions require precondition 
see precondition satisfied consider previous cases 
compiled initial state provides precondition positively satisfy appears 
action provided precondition places restriction table shows ways follow source domain treat identical supplies note argument applies goal fluent goal fluents satisfied source problem satisfied compiled problem 
precondition action goal fluent valid plan satisfied source problem satisfied compiled problem compilation scheme sound 
don care effects define new type effect props actions don care dc effect 
fluent dc indicated writing definition effects actions may extended include atomic formulae type 
semantically dc effect puts fluent state allows satisfy positive negative preconditions example scheme extending valued logic valid plans 
dc effects restricted fluents mentioned precondition action 
valid action 
supposed restricted dc effects increases expressive power props 
turns case simple extension produces new compilation scheme translates props domain restricted dc effects standard props domain positive preconditions added bonus 
shows extra compilation rules props restricted dc effects 
props problem compiled problem proof correctness compilation scheme required 
proof technique mirrors principal difference set legal pairs changes 
proposition correct 
proof proof structure 
table possible action pairs contains extra entries shown table 
reversal moment consider restricted class props problems total initial goal state mention fluents 
compilation scheme provides way reverse props problem 
props problem table possible pairs scheme reversal rules reversal valid plan source problem reversal similarly valid plan compiled problem reversal 
see correct sufficient establish plan source problem valid compiled problem valid plan compiled problem valid source problem 
accomplished showing preconditions goal conditions plan satisfied isomorphic actions 
proposition correct 
proof essentially structure proof proofs propositions preconditions source problem correspond effects compiled problem vice versa 
completeness loss generality consider valid plan source problem effect fluent possibilities effect produced 
produced initial state 
produced action possibilities effect 
action mentions precondition mentions mention correct sign 

actions mentioning correct sign goal state 
interesting case exist 
case precondition supplied required source problem 
problem reversed effect supply precondition table enumerates possible ways precede effect table enumerates possible ways precede effect note relations defined tables inverse action supply precondition action source problem action supply precondition compiled problem 
reversed plan valid 
case precondition source problem supplied initial state corresponds effect goal state compiled problem 
initial state satisfy precondition source problem compiled problem goal condition produced compiled action initial conditions source problem affected action true goal states reversal initial goal states change 
goal state achieved compiled problem 
valid plan source problem valid compiled problem sound 
table possible pairs table possible pairs soundness completeness proof mirrors structure soundness proof shows valid plan compiled problem valid plan source problem 
unique part proof showing compiled action precede respect follow source problem 
tables show 
sound complete correct 
note role dc effects play intuitively reason rules looking backward decision positive negative may deferred known sign needed satisfy precondition action 
compilation scheme plays critical role allows standard props planning domains represent dc effect boolean fluent values 
reverse props problem step process 
compilation scheme applied produce props problem may contain actions dc effects 
applied remove dc effects converting description problem standard props formalism 
resulting problem property forward plans backward plans vice versa 
action treated singly separately number fluents doubles compilation takes linear time measures 
partial goal states reversal uncommon props problem goal description corresponding partial total goal state 
reversal technique easily extended apply problem making goal state total compilation 
essentially unspecified goal fluents source definition formalizes problem correspond dc initial fluent values process 
definition state expansion state expansion fluents partial state consists fluents dc fluents remaining fluents compilation dc fluent state extension definition signed formula definition 
definition signed formula conjunctive formula signed formula possibly containing dc fluents reverse props problem partial goal states necessary expand goal state reversal 
props problem may partial goal description reversal semantics dc fluents initial state dc effects proof correctness proposition seen cover 
produce standard props version goal description may partial step process 
compilation scheme applied producing props problem may contain actions dc effects may contain dc fluents initial conditions 
applied new definition signed fluent translate dc fluents remove dc effects fluents converting description problem standard props formalism 
extensions reversibility discussed earlier number extensions props proposed 
important consider compatible reversal technique order gauge generality applicability 
preds extensions described chapter pp 
considered turn predicate strips inspection reversal proof indicates lifts easily predicate case ground atomic conjunctive formulae proof replaced conjunctive formulae universally quantified predicates formalism unchanged 
reverse predicate strips planning domains props domains 
closed world assumption presence absence cwa props preds formulations affect reversal mechanism mechanism dependent fluent values fluents available 
preds formulations fluents explicit inferred needed compilation mechanism planner normally uses suffice 
types type assignment applied fluents original problem transfer straightforward fashion fluents reversed problem 
type predicates timeless need compiled reversal purposes 
conditional effects reversing actions conditional effects presumably producing reversed actions conditional effects problematic 
possible conditional portion action reversed complete action 
formalism chapter quite sufficient describing case obvious interactions absolute conditional preconditions action adversely affect reversal 
reversal question conditional effects open important topic 
domain axioms domains containing domain axioms reversible compilation 
presence domain axioms forward backward search really fundamentally different domain axioms introduce temporal arrow problem 
example sufficiently powerful formalism domain axioms possible specify way function see chapter set fluents domain axiom force problem tractable direction 
hand semantics tractability problems associated domain axioms arguably significant limitation reversal technique practice 
safety constraints safety constraints imposed states actions special mechanism required impose identical safety constraints reversed domain 
catch 
weld etzioni formulation safety constraints specifies safety constraint violated initial conditions may remain violated 
purpose odd looking proviso sidestep undecidability mutual consistency order safety constraints 
unfortunately permitting actions maintain safety constraint violation forward direction obvious backward analogue 
alternative insist restricted form safety constraints mutual satisfiability decidable 
natural safety constraints expressible horn clauses 
reversal mechanism appears sufficiently general handle interesting cases 
general approach may extensible specific technique 
sensible talk reversal strips actions domains problems probably longer sensible talk directionality strips actions domains problems 
temporal directionality provided persistence appears illusory action preconditions time symmetric effects 
time asymmetric action replaced isomorphic action time symmetric 
suggests temporal asymmetry strips problems arises problems strips encoding 
domain compilation provide simple tractable strips problem reversal algorithm consequences 
implies common belief nature strips formalism persistence induces temporal arrow formalism mistaken 
second provides way squeeze extra performance existing preds planning systems allowing reverse problems needed deal problem specific directional biases 
illustrates utility domain compilation technique providing powerful planning operators 
chapter determining directionality planners considering directionality planning algorithms questions arise 
directionality planning algorithm defined 

directionality planning algorithm defined question determined 

directionality test question practice 
chapter answers question giving intuitively acceptable formal definition planning direction addresses question giving powerful technique determining planner direction provably correct poorly understood strips style planners sufficient power 
question answered chapter modification technique chapter applied experimentally order better understand performance planners 
focus chapter extrinsic black box technique determining directionality strips planner 
technique operates feeding planner problems drawn class artificial problem domains measuring planner performance 
idea constructing artificial problems determine planner behavior new 
exploiting properties certain functions cryptographic way functions possible greatly strengthen meaningfulness confidence results technique 
chapter restricts study directionality props 
preds planners capable operating props domains restriction lose generality extra simplicity greatly eases construction analysis 
approach suited planners fundamentally propositional nature 
search space planning consideration develop general model action planners order provide intrinsic definition forward backward planning 
important discussed previously chapter pp 
issue search direction really confused planner discussed 
applies planners operate searching 
model kambhampati refinement planning encompasses arbitrary planners may inappropriately broad discussion planning direction 
model attempts capture mechanism common search planners 
basic idea model observation search planning types action selection action ordering 
typical planner interleaved treated entirely separately 
search planner searches state space consisting plans actions selected ordering decisions 
potential terminological confusion planning fresh terminology adopted partially formulated plans referred approaches 
definition approach development approach planning problem tuple set action instances drawn partial order 
problem dropped required avoid ambiguity 
development approach approach development nontrivial approach general partial plan notion definition approach corresponds partial links kind goal protection 
developments approach correspond action selection action ordering 
planner explores space developments starting empty approach search space planner 
definition search space planner search space planner performs combinatorial search explicit implicit space nodes approaches 
root node empty approach 
child node legal development leaves total order ordered set actions linear plan 
note leaf linear plans necessarily legal 
important distinction explored planners traverse legal nodes search space state space planners allow arbitrary exploration 
definitions far constrains planner select order actions particular way search space planner principle proceed iterative sampling making repeated random walks search space 
search direction order talk search direction necessary specify planning algorithm 
key intuition planner direction method action selection 
consider planner developing approach adding new action 
definition new actions development approach set new actions defined planner searches forward attempts append new action existing actions approach backward attempts prepend new action existing actions 
planner searches backward strongly backward planner planner searches forward strongly forward planner 
action added directional search step may legal plan possibly arise irrelevant 
relevant action added shape actions added earlier 
approach explored strongly forward planner developments approach new actions plausibly appended existing actions explored 
definition strongly forward planner established conditions set actions union action effects note may consistent set 
established conditions approach effects actions approach initial conditions action satisfies forward chaining property approach requires established condition approach preconditions 
development new actions satisfy forward chaining property forward search step 
strongly forward planner search space planner development approach constructed forward search step 
example consider forward state space planner asp 
forward state space planner search space consists developments empty approach partial order total order actions approach 
new action added approach development initial conditions supplied established fluents approach legal state produced current plan prefix 
forward state space planner strongly forward definition 
approach explored strongly backward planner developments approach new actions plausibly prepended existing actions explored 
definition strongly backward planner required conditions set actions union action preconditions note may consistent set 
required conditions approach preconditions actions approach goal conditions action satisfies backward chaining property approach provides required condition approach effects op 
development new actions satisfy backward chaining property backward search step 
strongly backward planner search space planner development approach constructed backward search step 
example consider planner ucpop 
planner new action added partial plan satisfy open condition partial plan 
action supplies required fluent partial plan satisfies open condition 
planner strongly backward definition 
propagation reasonably object definitions somewhat restrictive 
consider situation action provably part plan planning problem simple reason 
example action achieve goal condition case unreasonable say forward planner add immediately 
similarly action executable initial state unreasonable disallow backward planner immediately adding development 
allow sorts cases useful relax strong definitions bit 
wanted notion immediate addition approach actions logically entailed approach simply proven notion generally known propagation 
unfortunately notion simple proofs action entailment hard pin 
fortunately case peripheral issues hand definitions action propagation sufficiently general cover obvious case general definitions affect proofs chapter 
propagation definition requires identifying portion approach linear plan actions occur approach establishes state forward propagation proceed 
definition plan prefix approach planning problem initial state pre 

pre 
longest sequence actions totally ordered ordering precedes actions pre plan prefix pre pre prefix state prefix state pre approach goal state approach plan solving forward state space planner actions approach considered plan prefix approach 
portion approach corresponding plan suffix identified establish state backward propagation 
unfortunately definition bit trickier requiring new machinery 
order say state corresponds plan suffix notion regression goal state touched chapter needs explicit formalized 
regression definition regression plan state minimal state subset partial ordering state exists 
regression uniquely defined 
see sufficient consider reversal technique described chapter state unique omitting dc effects leads desired regression 
details complicated direct proof 
lemma regression uniquely defined plan state unique 
proof definition unique 
suppose unique state unique minimal state 
suppose states minimal states supply necessary initial conditions produce intersection provide necessary initial conditions produce intersection sets subset proper superset minimal contradicting earlier assumption 
identification portion approach linear plan actions occur approach having defined definition regression hand allows identification state backward propagation proceed 
definition plan suffix approach planning problem goal 
longest sequence actions 
suf totally ordered ordering 
succeeds actions suf plan suffix suf definition suffix state suf suf concepts workable form propagation described 
idea action way proceed forward prefix state approach backward suffix state successful development approach plan contain action point may added directly 
dealing prefix states suffix states avoids having complex logical inferences decide propagation allowed 
forward propagation defined adding sole action approach legal prefix state 
definition forward propagation step approach pre legal pre set actions pre pre pre approach failed 
pre forward propagation step taken forward propagation step development action set pre partial order union ordering constraints precede actions append actions pre issues arise 
definition constructed forward propagation steps usefully iterated forward propagated action part plan prefix permitting new propagations 
forward propagation affect soundness search space planning action ordering constraints added approach forward propagation step affect legality plans resulting approach 
forward propagation affect completeness search space planning forward propagated actions legal actions occur prefix state approach added approach prefix state changing legal plans ultimately produced 
backward propagation step similar forward adds action head plan suffix 
definition backward propagation step approach tions suf regressed suf set ac suf suf suf approach failed 
suf backward propagation step taken backward propagation step development action set suf partial order union ordering constraints succeed actions prepend actions suf forward propagation backward propagation steps sound complete reasons 
propagating planners having definitions forward backward propagation time return original question restrictions strong forward backward planning weakened allow propagation 
answer evident simply allow opposite directional propagation steps 
definition forward planner forward planner search space planner development approach constructed forward search step definition backward propagation step definition 
definition backward planner backward planner search space planner development approach constructed backward search step definition forward propagation step definition 
addresses objection definitions may restrictive general forward backward planners treated remainder chapter 
way functions detailed treatment cryptography outside scope 
fuller view principles techniques consult introductory text schneier stinson 
concerned certain class cryptographic algorithms definition captures essential properties definition way function cryptographic hash function way function binary function input bits output bits property tractable compute intractable invert 
specifically computing output input computing input output fairly simple assumptions prove way functions exist 
believed researchers computing inverses way functions common cryptography md np hard 
case ability efficiently compute inverses important practical consequences assumption may safely employed 
assumption way function inversion family way functions constructible property computed time computed time boolean circuits notion boolean circuit crucial expressing way functions form useful planning 
definition boolean circuit boolean circuit directed acyclic graph dag vertices labeled names boolean functions logic gates variables inputs outputs 
purposes boolean circuit dag vertices gates labeled function defined 
edges lines connects output input 
function logic gate defined map truth table giving legal combination boolean inputs gate value edges vertex boolean outputs gate values edges vertex 
edges boolean circuit graph called lines labeled signals 
truth table logic gate map element set conjunctive formulae definition input signals conjunctive formula output signals example truth table boolean gate input signals output note definition require way function 
see zar az details 
class functions uniform class boolean circuits compute functions particular interest way function way boolean circuit computes definition logic gate extended bit 
limit gate output input extended definition allow gate nondeterministically select number outputs input 
modification turns convenient purposes completing analogy gate set actions plan 
definition nondeterministic boolean circuit nondeterministic boolean circuit nbc boolean circuit truth table nbc gate map possible input set possible outputs 
evaluation gate involves nondeterministically selecting element set output gate 
example nbc gate input output truth table gate evaluate successfully input true case output may true false 
advantage working straightforward correspondence planning problems 
correspondence heavily exploited understanding constructions chapter 
nbc planning problems nbc planning problems particular class planning problems associated nbc evaluating nbc solving planning problem class isomorphic tasks 
basic idea construction set actions gate represent possible evaluations 
exactly action set chosen appropriate point building legal plan problem action chosen corresponds evaluation gate 
entire plan consists topologically ordered sequence gate evaluations 
definition nondeterministic boolean circuit gates labeled topological sort order boolean circuit planning problem constructed follows 
set inputs set outputs define fluents problem recall definition gives meaning define initial state problem goal state problem intuitively uniformity captures notion circuit particular size easily describable 
detailed explanation see savage 
circuit classes chapter uniform 
actions problem defined truth table gates follows 
conjunctive formulae action requires produces vertex defined gate truth table input associated input set actions set actions entire domain set actions inputs gates 
key fact solving corresponds evaluating corresponding nbc 
lemma nbc evaluation planning nbc corresponding plan solving exists computes outputs inputs 
proof dual implication 
circuit solution plan existence consider input values output values actions gate form definition 
construction action corresponding set call action plan constructed follows empty plan vertex turn append action obtain vertices occur topological sort order inputs vertex drawn outputs earlier vertices input fluent values fixed 
precondition satisfied effect previous action initial state 
action output chosen 
plan action time goal conditions satisfied valid plan existence action definition corresponding circuit solution consider preconditions effects gate input produce output consider action producing input precondition circuit evaluated follows action produce goal conditions correspond appropriate evaluation gate set inputs outputs correspond gate output input set inputs outputs continue values gates set 
happen fluents uniquely labeled signals evaluation correct 
deterministic boolean circuits plan unique 
nondeterministic ones may multiple possible evaluations circuit correspond unique plan 
reversal interesting useful consider reversal planning problems discussed previous chapter interacts construction 
helpful consider construction plans reversal circuit evaluations 
note reversal technique chapter obtain construction forward version 
unfortunately actions definition reversed contain dc effects compiled possible obscures symmetry forward backward problems leads larger difficult problems 
construction avoids creating backward planning problems similar forward problems definition 
definition reverse reverse associated circuit constructed reversing initial goal states input output fluents actions 
definition define initial state problem goal state problem conjunctive formulae action defined gate truth table input associated input set actions set actions entire domain set actions inputs gates 
important thing definition reversal plan evaluation isomorphic lemma reverse nbc evaluation planning nbc corresponding reverse plan solving exists computes outputs inputs 
proof dual implication 
circuit solution plan existence consider input values output values gate set actions form definition 
construction action corresponding plan constructed follows empty plan vertex turn prepend action obtain inputs vertex drawn earlier vertices action satisfies precondition required occur earlier final plan fluents uniquely labeled signals action way actions ordered 
delete precondition 
conditions satisfied valid plan existence circuit solution consider preconditions effects action definition corresponding gate input produces output action circuit evaluated follows require fluent initial state correspond output gate set inputs outputs consider action consuming effect correspond gate output input set inputs corresponding continue values gates set 
happen fluents uniquely labeled signals evaluation correct 
planner directionality test machinery introduced classes forward backward props planning problems constructed 
classes property forward planner definitions find forward problems easy backward problems intractable 
similarly backward planner find backward problems easy forward problems intractable 
describing construction directional problems proof correctness construction outlined 
features limitations implementation discussed 
construction basic idea construction take way boolean circuit transform planning problem construction definition 
planner tries start wrong planning problem attempting compute input way function output assumption intractable 
planner works correct hand computing output way function input easy 
boolean circuit planning problem oriented input oneway function corresponds unspecified initial state output corresponds unspecified goal state producing forward problem 
alternatively backward problem input oneway function corresponds unspecified goal state output unspecified initial state 
unspecified initial states unspecified goal states produced total states simple fashion exhibited 
illustrates concept arrow indicates easy direction way function 
initial conditions initial conditions bit commitment forward backward way function planning problems goal state goal state subtle problem arises point 
consider behavior backward search space planner searching depth produce plan forward way function planning problem 
argument planner find problem infeasible 
planner may proceed follows 
select open goal bit value bit 

chain backward problem matching operator selecting action resulting plan 
planner easily check condition verifying preconditions chosen operator satisfied initial state 

chaining proceed discard actions selected goal bit start step value open goal bit 

include chosen action action partial plan 

forward propagate chosen action completion 

repeat steps goal bits chosen 
depth planning problem polynomial size resulting plan polynomial polynomial time algorithm solving problem 
catch arises intractable problem find input way function produces output bit definition backward planner allows planner way front starting bit 
solution modify definition backward planner unacceptable backward input bits output bits forward commitment goal initial commitment input bits output bits backward way planning problem bit commitment planners search fashion behavior discovered examination execution traces ucpop 
order take advantage way problems detect planner directionality apparently necessary force wrong directional planner commit output bits way function proceeding 
illustrates concept 
construction explicitly achieves commitment property seen impossible 
consider operator operators assign values output fluents way function 
operator sets fluents planner proceed working way operator 
operator sets fluent values simultaneously exponential number operators problem intractable planner requires predicting input produce output way function 
lost possible construct problem way search tree commits output bit implicitly committed output bits extension approach sets output bit plan output bits take single value 
bit commitment network bit commitment network correct problem probably best described terms correspondence circuit props representations 
forward version version follows forward way function forces backward planner commit described backward version simply reversal forward 
table truth table left projection gate operators left projection gate fundamental gate corresponding set operators network left projection gate output left input right input ignored 
truth table left projection gate inputs output table leads construction definition operators 
graphically follows operators represented 
basic idea construction backward search space planner selecting particular left projection gate operator match output commit particular value commitment single fluent value commitment fluent values obtained 
layers left projection gates assembled continue effect layers commitment bits achieved 
left projection gate labeled bit commits layer network 
fluents named gate producing 
shows labeling gates inputs outputs form bit layer graph 
structure uses labeling provides commitment bits 
fluents left hand side referred inputs bit commitment network single fluent right hand side output network 
reversed network inputs right output left 
convention arbitrary motivated notion outputs way function inputs commitment schematic left projection gate gate fluent labeling bit layer network 
reverse bit commitment network planning problem constructed exactly fashion forward reverse construction lemma produces bit commitment planning opposite direction 
final construction final construction forward tractable search problems proceeds concatenating components circuit producing nondeterministic value circuit way function bit commitment network previous section 
result way boolean circuit translated way planning problem definition 
nondeterministic value circuit consists gate input may produce true false value 
note truth table previous example 
motivation boolean circuits sort gate naturally represented set actions planning framework 
forward tractable way planning problem construction 
forward search space planner may select values inputs way problem picking action nondeterministic value gates forward propagating inputs way function forward propagating way outputs bit commitment network 
backward search space planner hand working backward bit commitment network implicitly commit particular output value way function commit solving intractable problem 
note planner forward propagate allowed definition nondeterministic value gates inhibit propagation 
reverse tractable problem exactly forward tractable problem constructed reverse construction definition 
shows conceptual design problem 
note illustrates nondeterministic consequences reversal nondeterministic value gates translate deterministic actions bit commitment gates nondeterministic outputs 
initial bit commitment network forward way planning problem commitment goal initial commitment correctness backward way planning problem see planning problems constructed correctly detect direction sufficiently powerful search space planner sufficient show goal 
commitment input bits way function portion problem tractable easy direction 

commitment output bits way function portion problem intractable hard direction 

bit commitment network portion problem commit output bits way function 

bit commitment network tractable easy direction 
difficult prove arbitrary search space planners deliberately bad planners capable getting lost problem choices 
blindly fixing inputs way portion problem merely propagating repeatedly yield outputs 
reasonable planner able emulate strategy 
lemma way evaluation easy search space planner working easy direction committed output discover plan bit way planning problem time asymptotically proof construction 
consider situation planner working easy direction chosen arbitrary input way circuit 
circuit deterministic means operators choose layer gates way circuit uniquely determined 
definition directional propagation definitions means propagating planner proceed output backtracking 
problem non backtracking solution obtained polytime 
prove sufficient appeal assumption 
lemma way inversion hard search space planner committed output discover plan bit way planning problem time asymptotically proof contradiction 
commitment set output bits assume search space planner find plan time asymptotically construction lemma input bits way circuit generating read time input way function generating input produces output determined polynomial time 
contradicts assumption 
prove sufficient show bit commitment network works fashion described informally previously pp 

lemma bit commitment network commits consider search space planner definition ing approach contains operator fixes value input bit exists development legal plan working output inputs bit commitment network 
currently consider input bit proof induction number bits bit commitment network 
base case input bit network 
sole bit clearly fixed planner 
appear cases planner fixed input bit planner fixed input bit 
case planner done selecting operator implement sole left projection gate network selection committed input bits 
inductive case assume lemma true bit commitment network 
reaching input layer planner committed inputs 
search space planner searching output inputs definitions select operators layer output gate satisfy input layer inductive hypothesis means layer committed exactly values bits layer operator gate selected layer value fluent committed selection legal plan developed approach containing operator selected operators gates layer consistent value fluent reaching input layer planner committed inputs implying lemma true bit commitment network 
difficult prove arbitrarily bad planners 
essentially sort propagation argument lemma holds fixed input simple directional propagation definitions suffices plan network 
chapter posed questions 
answered 
reasonable formal account behavior large class planning algorithms notion search space planner definition reasonable definition directionality search space planners provided definitions 
directional classes planning problems described performance directional planner sufficient power necessarily scale differently problems forward backward classes 
proof sketched correctness result 
answer third question variant directional problem classes described implemented performance variety existing planners measured 
chapter describes implementation results experiments 
chapter measuring planner direction chapter construction classes forward backward way planning problems 
forward way planning problem easy forward search space planner intractable backward search space planner backward way planning problem easy backward search space planner intractable forward search space planner 
chapter specific class directional way planning problems described novel hash function 
directionality variety planners evaluated problems verify technique better understand behavior planners 
implementation construction chapter way planning problems quite specific excepting failure prescribe particular way function core problem 
ideally way function believed cryptographically sound md determining planner directionality 
cryptographic quality way function required proofs chapter depend assumption 
unfortunately cryptographically sound way functions tend large circuits 
corresponding planning problem require tens hundreds thousands operators far current planners deal efficiently 
cryptographically sound way functions tend deep circuits lead corresponding planning problems requiring long solutions experience indicates deep planning problems especially difficult existing planners 
importantly empirical way estimate asymptotic running time planner determine direction give planner class problems increasing size 
existing cryptographic hash functions fixed size 
reasons new scalable cryptographic hash function modest size fixed shallow depth designed experimentation current planners 
definition hash function bit vectors 
denote high order bits denote low order bits similarly random function lookup table bits bits 
function defined way function exclusive operation addition gf 
illustrates function 
solves problems discussed 
expressed planning problem requires operators sufficiently small constant factor viable reasonably large values depth constant respect extremely important 
trivial evaluate resulting planning problem shown simple solve easy direction 
course comes price 
far intractable invert reason believe human mathematician construct closed form evaluable polytime certainly search techniques tuned problem invert output approximately linear time 
function constructed known techniques elementary cryptography diffusion confusion authors colleagues unable construct inverses 
general purpose planners sort thing experimental tests forward backward problems show planners studied chapter find inversion tractable 
second problem exponential growth number operators problem asymptotically intractable easy direction 
experiments show planners studied section index operators large problem 
address construction better way functions existence better planners solve problem allowing standard cryptographic hash functions 
rate straightforward transform planning problem 
functions implemented operators domain element preconditions random output effect 
operators needed implement xor operations truth table xor construction definition 
experiments having derived directional test planners shown workable principle remains apply practice feed forward backward version way planning problem constructed previous section planners 
section directionality test applied planners previous generation directionality understood planners fully understood 
process insight performance modern planners 
methodology hash function commitment network associated machinery described previously implemented testbed composed mainly macros 
powerful general purpose macro processor 
macro processor approach lends implementation core primitives independent target syntax 
collection definitions constructed new target planning language describing language syntax fluents operators initial goal states 
planner collection support routines provides syntax conveniently describing problems 
noted previously forward backward versions problem specified independently 
deemed necessary provide sufficient control implementation 
alternative automatically reverse forward description require compiling forward version positive preconditions comparability 
problem descriptions larger behavior difficult understand 
implementation hash function requires generation random functions specification definition 
lack pseudo random number generator plus difficulty expressing sort bit arithmetic necessary generate check functions macros candidate portion task 
random matrices generated java applet selects enumeration possible inputs input output pair deterministic process selecting pair java applet collects statistics show formal statistical analysis performed remains reasonably collision resistant grows outputs produced inputs large outputs applet consist collision statistics sat formula version hash function testing cryptographic strength collection macros implementing hash function testbed 
saved reproducibility results experimental runs 
structure testbed illustrated 
diagram solid boxes represent executable code source language parentheses 
dashed boxes represent data 
program data distinction somewhat arbitrary macro processor diagram represented explicitly inputs shown data 
dashed arrows represent invocation downward dashed arrows source indicate human invocation 
solid arrows represent data flow 
testbed code available anonymous ftp may useful conducting planning experiments providing way replicate extend results reported 
experiments performed mhz intel pentium ii machine mb memory red hat linux operating system version linux kernel version 
table generator java statistics planner description macros sat problem problem description template input data analysis display tools bourne shell awk macros planning problem execution data driver bourne shell detector testbed organization planner driver various planner various plan execution info 
planner output analyzer planners written programming language compiled gcc version highest optimization level planners written lisp programming language compiled executed common lisp acl linux version speed safety settings recommended planner authors 
times reported cpu seconds cases real time seconds 
differences quantities appeared negligible experiments expected planners appeared completely cpu bound 
general philosophy experiments attempt obtain measure planner performance sort node count platform dependent time 
feasible cases cases agreement measures seen 
graphs sections show forward backward planner performance log linear scale log scale base 
appropriate number operators planning problem roughly doubles increase bits linear graph expected successful planner conditions 
different experimental instances generated bit size direction uniformly planners 
instances appears particularly anomalous agreement obtained runs cases 
methodology bit questionable possible functions case effort ensure distinctness randomly chosen candidates 
proven problem practice 
directionality asp asp provides nice experimental results section behavior straightforward 
asp plans forward state space search guided goal distance heuristic 
complete may report failure soluble problems heuristic difficult calculate available resources 
spite simple structure asp shown competitive modern planners graphplan standard benchmark problems 
asp proceeds stages planner generator stage generates engine problem description search engine compiled executed second stage solve planning problem 
shows total time solution generation compilation execution forward problems 
note asp fails early problems due incompleteness 
simple change resource allocation planning allow asp solve larger problems evident superficial study 
shows just execution time search engine shows roughly number nodes searched execution number hash table hits search 
forward times shown asp unable solve backward problem case 
verification correctness problem description irrelevant actions backward problem deleted asp expected plan time comparable forward case 
detector gives determination forward planning asp serves nice empirical validation experimental technique 
lg time secs lg time secs forward forward failed bits asp directional performance time forward forward failed bits asp directional performance search time lg nodes forward bits directionality plan asp directional performance nodes plan entirely goal regression planner partial order features planner perform backward problems 
results figures show case 
times shown wall clock times entire planning process 
note plan solve instance forward problem able successfully negotiate backward problem size addition note performance backward problem appears scaling linearly increasing 
times reported spuriously large due second granularity timer employed 
results reported older slightly weakened version problem plan unable tractably plan direction constraints placed order actions definition 
actual implementation nondeterministic input gate actions ordered 
results plausible taken grain salt point 
intriguing plan ucpop previous generation backward planners difficulty apparently simple problems 
experiments conducted version plan release may new code 
minor modifications necessary plan run linux acl modifications executed sun sparcstation running sunos appear way affect plan performance 
best author understanding modifications folded back release tree 
author jeff dalton aiai edinburgh extensive help hand holding getting lg time secs lg nodes forward forward failed backward bits plan directional performance time forward backward bits plan directional performance nodes planner integrated system brian currently cirl aiai role patiently answering numerous questions providing necessary contacts 
directionality ucpop results directionality test applied ucpop satisfying plan results 
argued previously partial order planner ucpop adds actions satisfy goal conditions regresses plan tractably backward 
unfortunately key feature ucpop specific planning algorithm interacts construction problem ucpop backward performance 
result ucpop performs slightly better forward backward direction difference believed significant rate ucpop solve case containing operators direction 
disappointing great deal effort devoted producing detection problem ucpop handle 
attempt largely abandoned understanding crucial property ucpop action selection mechanism 
imagine outstanding goals point partial plan construction actions available action effect action effect action satisfy goals 
plan construction partially ordered possible part successful plan require action subsequent achieve unfortunately ucpop prefer search performs check exists prior inserting partial plan 
result way force ucpop compute efficiently 
plan solves problem preferring explains ability obtain results 
figures show cases ucpop appears capable solving increasing time search limits order magnitude allow instances solved 
bottom line explained previously fact simple propagation arbitrarily selected state quickly produce plan mean arbitrary search space planners 
ucpop 
experiments conducted ucpop version parameters set defaults shipped 
node counts represent plans explored statistic reported ucpop 
exploratory experiments reported suggest popular ucpop flaw repair strategies comparison strategies see significantly change result addresses question action selection heuristics filling open conditions 
ucpop flexible modular principle possible principle encode custom flaw repair strategy select desired open conditions require effort case address directionality standard ucpop configurations 
directionality graphplan graphplan provides interesting test directional detector technique planner directional behavior completely understood 
graphplan typically described creators forward planner actual search mechanism simple goal regression 
regression graph actions states built previous forward pass 
forward pass eliminates states actions impossible graph graph brian personal communication 
lg time secs lg nodes forward backward backward failed bits ucpop directional performance time forward backward backward failed bits ucpop directional performance nodes lg graph nodes forward backward bits graphplan directional performance graph nodes creation time yielding graph consisting polynomially sized layers heavily prunes backward search space 
size plan graph nodes confused search nodes function 
forward backward graph sizes appear grow slightly sub exponentially seen slightly sub linear growth 
graphs polynomial size length solution polynomial 
polynomial high order length solution size layer graph size general 
suggests forward graph may grow slightly faster backward graph increasing expected forward plan graph tries capture increasingly large way functions backward graph capture information way portion problem 
performance graphs figures reflect search space planner definition graphplan bidirectional 
time performance shown reflects largely cost graph construction 
plan graph crucial allowing efficient backward search forward problems 
graph construction begins significant percentage total cost forward problems 
note search cost nodes forward problems shown highly variable increases indi degree plan graph construction able help search particular hash function 
time cost including cost graph construction increases orderly nearly linear fashion 
backward problems solved straightforward fashion resulting low search cost dominated cost graph construction 
lg time secs lg nodes forward backward bits graphplan directional performance time forward backward bits graphplan directional performance search nodes results illustrate reasons graphplan inspiring research community introduced 
ability adapt different sorts problems ability handle large problems placed far fully general purpose planner 
experiments conducted latest version graphplan graphplan dated june obtained ftp graphplan home page defaults parameters memory sizes increased allow larger experiments conducted 
minor modifications observed affect performance allow imposing search limit improve error reporting 
directionality blackbox blackbox planner result combining fundamental successful ideas planning research graphplan approach described graph constructed reduce planning search space planning satisfiability approach kautz selman represented satplan planner :10.1.1.38.4843
approach planning problem transformed boolean formula fast modern satisfiability engines find satisfying assignment formula 
kautz selman way plan graph construct small simple boolean formulae permitting quick discovery satisfying assignment 
progress understanding search satisfiability planners matter conjecture blackbox achieves high levels performance sorts problems effective 
understanding directional properties planning algorithm difficult derive understanding inner workings 
detection technique described extrinsic test especially useful answering questions 
operates graphplan graph construction phase blackbox offers choice solvers proceed point 
possibility emulate graphplan achieve solution 
typically blackbox asked produce satisfiability problem graph solve problem variety built solvers 
focuses wsat nonsystematic sat engine bayardo schrag relsat systematic sat engine 
kautz selman report results rapid restart approach anbulagan li satz engine highly inefficient preliminary trials forward backward detector problems considered 
measurements version default settings memory sizes time limits increased allow larger experiments run 
problems pddl encodings 
preliminary versions experiments performed version graphplan input format 
slight improvement speed better robustness better error reporting newer version appears similar 
blackbox emulating graphplan ability emulate graphplan running problems encoded different input language provided nice check experimental methodology 
graph sizes search node counts identical graphplan depicted figures execution times shown significantly different 
provided lg time secs forward backward bits blackbox graphplan directional performance time faithfully implemented graphplan graph generation problem encodings produced planners functionally identical 
blackbox wsat execution times wsat solver shown disappointing 
essentially problems appear unsolvable blackbox wsat 
tuning parameters wsat improve performance 
experience simpler problems suggests wsat may generally unsuitable solving planning problems requiring large plans 
blackbox relsat relsat solver currently far away best systematic sat solver available competitive wsat structured problems 
execution times blackbox relsat shown reflect superiority instances 
measured range problem sizes performance relsat search engine quite acceptable simple backward search graphplan appears superior 
note graphs show problems size problem encodings large fit physical memory approximately mb causing unacceptable swapping search 
andrew parkes tools author helped develop explore behavior wsat sat encodings logistics planning problems observed wsat tends get stuck local minima planning problems requiring long plans 
lg time secs lg time secs forward forward failed backward backward failed bits blackbox wsat directional performance time forward backward bits blackbox relsat directional performance time lg time secs forward backward bits blackbox relsat directional performance relsat time separating component solution cost due search apparent forward problems easier relsat implementation 
search time shown small roughly exponential 
search cost nodes shown similar 
nodes searched represented variables valued statistic relsat 
parallel plans performance graphplan blackbox variants detector problems slightly disappointing 
planners generally quite solving problems significantly larger detector problems 
paradoxically important constraint performance planners problems condition actions occur sequential order 
planners construct parallel plans non interacting actions may occur simultaneously search greater depth time construct temporally shorter plans 
constraints actions preconditions definitions 
constraints prevent gate evaluated simply discarded 
replaced constraints delete inputs gate gate evaluated 
definitions capture notion 
definition negative signed formula conjunctive formula negative signed formula definition lg nodes forward backward bits blackbox relsat directional performance variables valued definition parallel boolean circuit parallel nbc planning problem constructed follows define fluents problem define initial state problem goal state problem conjunctive formulae action requires produces defined gate truth table input associated input set actions set actions entire domain just set actions inputs gates 
definition parallel reverse parallel reverse nbc planning problem associated circuit constructed reversing initial goal states actions parallel definition define initial state problem see definition goal state problem conjunctive formulae action defined gate truth table input associated input set actions set actions entire domain just set actions inputs gates 
proof correctness similar lemma 
proof forward problem definition proof definition similar 
lemma nbc evaluation parallel planning nbc corresponding parallel plan solving exists computes outputs inputs 
exists exists length plan number gates circuit 
proof dual implication 
circuit solution plan existence consider input values output values gate corresponding set actions definition 
construction action preconditions effects plan constructed follows take topological sort vertices empty plan vertex input fluent values turn append action obtain inputs vertex drawn outputs earlier vertices fixed 
action output chosen 
earlier observation plan produce required goal state fluents valid plan existence consider preconditions effects action circuit solution definition corresponding gate input produce output circuit evaluated follows action produce goal conditions correspond appropriate evaluation gate set inputs outputs consider action producing precondition output input set inputs outputs continue values gates set 
happen fluents uniquely labeled signals evaluation correct 
correspond gate lg graph nodes forward backward bits parallel graphplan directional performance graph nodes note may exist plans corresponding circuit evaluation corresponding different topological sorts circuit 
parallel planning problems implemented planning systems described previously results quite consistent previous section ability experiment larger problem sizes provides nice confirmation data 
graphplan expected polynomial graph size expected length plan sub linearity pronounced sequential case 
graphs similar character sequential case 
especially variability forward problems increases rapidly increasing note impressive size problems solved problems operators 
performance emulating graphplan nearly identical shown 
blackbox wsat parallel problems enable evaluation blackbox wsat solver reducing encodings manageable size 
running times shown interesting similar character graphplan results somewhat worse absolute performance 
particular solving larger forward detector problems wsat appears result longer run times higher variance runtime 
result expected lg time secs lg nodes forward backward bits parallel graphplan directional performance time forward backward bits parallel graphplan directional performance search nodes lg time secs forward forward failed backward bits parallel blackbox wsat directional performance time surprising inasmuch satisfiability solvers satplan medic wsat reported competitive graphplan variety problems 
shows time consumed wsat solved instances 
shows wsat flip count effectively number search nodes wsat solution 
forward backward plots similar variances directions high noticeable backward bias search 
author speculates may result bias satisfiability encoding 
encoding inspired partly study graphplan expected reverse biased 
possible underlying axioms encoding directionally biased surprising 
case blackbox wsat appears behave bidirectional planner slight backward bias 
blackbox relsat execution times relsat parallel problems shown quite impressive 
comparison wsat times times similar character times shorter show little variance 
search time shown extremely small roughly exponential grows large measure 
behavior nodes searched shown interesting 
nodes searched represented variables valued statistic relsat forward cases tried variables problem valued 
indicates ease relsat solves problems 
lg time secs lg nodes forward forward failed backward bits parallel blackbox wsat directional performance wsat time forward backward bits parallel blackbox wsat directional performance wsat flips lg time secs lg time secs forward backward bits parallel blackbox relsat directional performance time forward backward bits parallel blackbox relsat directional performance relsat time lg nodes forward backward bits parallel blackbox relsat directional performance variables valued results experimental results chapter summarized follows asp forward planner 
surprising provide validation methodology 
plan appears backward planner 
ucpop inefficient allow drawn directionality methodology 
graphplan bidirectional planner 
blackbox directional characteristics similar graphplan sat solvers vary slightly performance directionality 
chapter began questions 
directionality planning algorithm defined 

directionality planning algorithm defined question determined 

directionality test question practice 
answer question reasonable formal definition search planning 
answer question theoretically sound extrinsic technique determining planner directionality 
chapter answer question series planner directionality experiments permitting insight operation poorly understood modern planners 
chapter directions planning necessary ingredient achieving results chapters discovery problem props problem 
chapter reversed problem compiled somewhat richer language props problem 
chapter way hash function encoded props problem 
chapter issues related discussed bearing planning directionality 
leads naturally discussion expressive power strips bearing directionality 
chapter concludes discussion impact existing planning algorithms general 
don know don care props actions compilation schemes chapter sufficient purposes reversal algorithm 
notion dc effect pp 
generalized natural fashion 
resulting language satisfying intellectual point view extra expressiveness sort may prove useful standard props encoding real world problems 
unrestricted dc effects chapter notion don care dc effect described context compilation scheme props variant containing dc effects isomorphic problem standard props 
dc effect effect satisfy positive negative preconditions action sort wild card effect 
dc effects implemented compilation scheme pair effects setting positively negatively signed fluents problem positive preconditions 
dc effects restricted occur actions fluents mentioned precondition action 
reason restriction discussed chapter necessary reversal 
reversal rules dc effect appears reversed problem fluent mentioned effects action original problem 
reason generalize unrestricted dc effects permit explicit dc effects problem encodings 
seen shortly approach features pitfalls 
dc effects initial state natural explicit dc effects allowed initial state problem descriptions 
discussion reversal problems partial goal states chapter explicitly describes compile dc effects initial conditions simple extension necessary handle initial states obtained reversing problems partial goal states allowing dc effects explicitly initial conditions encoding problems props advantages 
thing initial state treated literature effect initial action purpose simplifying proofs dc action effects permitted dc initial conditions 
importantly explicit dc initial conditions allow easy expression notion particular problem actions domain unrestricted initial conditions 
notion useful real world problems 
consider example problem domain actions executable days executable odd days 
obvious props encoding fluents odd day day normally set initial conditions 
obvious encoding involves odd day fluent set true false initially 
domain encodings convenient pose planning problem find plan problem particular day fluents set true initial state problem encoding odd day day actions may mixed resulting plan 
things worse encoding obvious way express problem 
encoding action added domain executed effect making day odd 
uncomfortable inelegant modify domain order handle particular problem planners fail scale additional actions added domains 
encoding appears best done pose planning problems actions odd days enabled actions days 
unfortunately fluents considered leads combinatorial explosion 
fortunately problem encoding initial dc value fluent odd day allows desired problem posed directly 
treatment dc values described chapter plan problem may contain odd day actions odd day actions 
notion intuitively reasonable simple implement compilation permits problem reversal note dc initial conditions actions dc effects different anomalous actions due ambiguity situational calculus described manna waldinger 
note plans expressed standard formulation situation calculus permit actions executable real world 
example consider problem monkey boxes informed box contains banana bomb told 
goal get banana goes near bomb explode 
stated problem solution 
manna waldinger go point theorem proving standard situational calculus yields plan monkey takes action roughly equivalent go box get banana went sort non executable action indicate problem standard situational calculus manna waldinger suggest solution 
dc initial conditions effects different nature deterministic require known preconditions 
dc initial conditions effects expressible props add real logical power planning 
sort problem described manna waldinger arises context 
explicit dc action effects having admitted notion explicit dc values initial state logical question permit explicit dc values operator effects dc effects directly problem encoding result reversal chapter 
questions addressed 
explicit dc effect semantics useful real world encodings 

explicit dc effect semantics implemented traditional planners 

domains problems containing explicit dc effects reversible 
considering question difficult think situations effect action fluent true false whichever needed explained include sort nondeterminism allows actions dump water hole fire sure hole sort action expressible props dc effects 
generally action effect encoded domain description effect useful unavoidable side effect 
case effect invariably specific setting clearing fluent 
little motivation introduce explicit dc action effects domain encodings 
question easy see extend compilation scheme handle unrestricted explicit dc action effects compilation scheme unrestricted dc effects consists rules plus compilation rule answer question points real problem unrestricted dc effects 
reversal rules written unidirectional rules simplify presentation 
notable rules manifestly symmetric read right left rules remaining rules interchanged 
rules reversal rules restricted dc effects problematic inspection proof correctness shows rules may read right left giving new rules shown 
rules cover case reversal explicit restricted dc effects un restricted case problematic 
obvious approach analogy rule delete fluent rule yielding rule unfortunately rule easily seen incomplete considering problem initial state goal state sole operator single action plan legal forward domain reversal illegal reversed domain 
suspect trouble case reading rule right left yields rule obviously nonsensical 
operator containing unrestricted dc effect reversed author currently unaware better procedure doing simply removing unrestricted dc effects reversal compiling reversal planning problem containing unrestricted dc effects inelegant say 
appears explicit unrestricted dc action effects marginal utility unpleasant deal probably avoided problem encodings 
case restricted dc effects clear considered 
don know effects scheme extending valued logic don know dk effect complement dc effect discussed previously 
representing non deterministic value satisfies true false preconditions fluent dk effect represents unknown value satisfies true false preconditions fluent 
actions follow dk effect fluent preconditions involving dk effect represented extension compilation rules valued logic handles dk effects straightforward 
dk effects especially useful components initial state 
fluent initial state represents piece unknown information initial state plan execute actions conditional set true false set 
note dk values usefully appear goal state dk action effects way combination non dk effect operators achieve dk effect fluent 
dk action effects useful expressing effects representing loss knowledge fluent state 
fluent represents coin showing heads tails effect correspond flipping coin 
qualitative approximation real loss knowledge strips planner conclude example robust plan contains separate actions heads tails flips succeed 
strips expressive describe notion case 
strips planner dk effect representation conclude plan follows coin flip setting coin known state succeed 
acceptable safe plans containing actions dk effects executable 
reversal actions containing unrestricted dk effects unrestricted dc effects problematic 
compiling dk effects reversal works ugly 
dc effects explicit dk initial conditions clearly desirable explicit restricted dk action effects tolerable explicit unrestricted dk action effects problematic 
dc dk conditions treatment explicit dc dk operator effects explicit dc dk values initial state obvious question explicit dc dk values operator conditions goal state 
question simple meaning assigned symbols operator conditions goal conditions 
obvious choice explicit tests dc dk effects 
action precondition satisfied effect similarly easily implemented compilation simply compiling dc dk conditions fluent combinations corresponding effects 
objections choice semantics 
semantics obviously useful encoding real world domains 
second representation explicit dk conditions induces negative preconditions compiled domain major problem 
reversal complicated difficult appears compiling conditions reversal hope reversing domain conditions 
attractive semantics suggested inspection reversal rules figures 
note dc effects rules correspond completely absent preconditions 
right way proceed assign condition meaning condition substituting blank conditions various compilation rules conditions 
making substitution various compilation schemes discussed previously advantages realized 
notationally things clearer fluent mentioned action mentioned preconditions effects 
semantics intuitive sense just dc action effect means subsequent actions don care value dc action condition means action doesn care value provided previous actions 
semantics dc goal conditions expected expansion partial goal state total goal state operator definition change correctness 
expansion deleted compilation 
reversal rules summarized natural fashion reverse operator switch preconditions effects preconditions effects normalized appropriate form 
normalization noted chapter technique quite correct 
meaning assigned restricted explicit dk preconditions 
arguably right semantics compiling preconditions attractive properties dc case 
semantics intuitive sense dk precondition satisfied fluent known true false 
dk conditions naturally translate nicely dk condition satisfied dc effect 
gives satisfying meaning dk goal conditions 
scheme full reversal rules reversal rules involving dk effects expected 
reversal actions involving restricted dk effects swapping effects preconditions 
reversal initial goal conditions problem interchange 
item requires proof 
point sensible summarize extended reversal rules compilation scheme sketch proof correctness proposition correct 
proof essentially structure proof proof proposition tables need extended handle new reversal rules 
tables show legal pairs source compiled problems 
notion restricted dc dk effects conditions properly implemented provides expressive easily implemented reversible planning language 
composing way planning problems chapter construction directional planning problem figures 
purpose decide directionality existing planners 
interesting table possible pairs table possible pairs initial initial bidirectional planning problem island planning problem implications existence directional planning problems result fact way problems concatenated concatenating circuits 
consider planning problem 
diagram boxes arrows represent way planning problems type described chapter 
interesting thing problem forward search space planner backward search space planner solve efficiently planner traverse half problem wrong direction 
bidirectional planning required solve problem 
solution obtained polynomial length plan 
bidirectional planner solve problem polynomial time 
facts suggest bidirectional search space planner strictly powerful principle unidirectional 
practice situation clear 
discussed chapter humans encode planning problems unidirectional fashion presumably breaking unidirectional pieces 
hard see possible cases author suspects large planning problems bidirectional quality 
certainly problems simple domains blocks world rubik cube towers hanoi manifestly reversible difficult solve 
mean bidirectional planning help domains problems may intractable matter tackled 
surely true optimal blocks world important intractability results proven 
append way planning problem circuits opposite direction shown creating problem tractable forward backward search space planner 
note correct nondeterministic guess necessary intermediate state break planning problem halves tractable directional planner 
ginsberg refers intermediate state island argues automatic discovery islands correct way perform hierarchical planning 
problem shown intractable search space planners may kind planner solve problem easily author find goal goal surprising 
create problems arbitrarily islands daunting imagine hard real world problems sort structure 
tractability circuit planning chapter fact nondeterministic boolean circuits natural representation planning operators planning problems constructed solution corresponds nbc evaluation 
circuit classes considered chapter uniform boolean function circuit computing function inputs constructed time polynomial deterministic turing machine 
interestingly restriction uniform circuits planning problems appears arbitrary 
non uniform class boolean circuits circuit input size may constructed arbitrary fashion 
result non uniform boolean circuits recognize languages recognizable turing machine 
restricting non uniform circuits size polynomial size inputs allows recognize languages class larger class languages presumably smaller polynomial hierarchy collapses second level 
boolean circuit transformed planning problem polynomial time construction definition producing planning problem size polynomial size circuit 
reasonable define classes non uniform planning problems time solution polynomial polynomial amount advice 
relevant 
places lower bound complexity props planning 
polynomially sized domain restriction action leaves planning complexity class believed harder lower bound improved noting definition lemma apply just ordinary boolean gates nbc gates 
interesting reformulation nbc gate adding auxiliary inputs gate auxiliary inputs normal inputs gate deterministic 
clear correct nondeterministic guess auxiliary inputs gates nbc boolean circuit evaluated polytime 
just non uniform boolean circuits recognize languages shown proven see zar az exercise circuits gates form recognize languages translation nbc evaluation planning implies complexity planning larger expect simple cases 
summary expressiveness directionality strips chapter different extensions previous considered 
appear point similar 
props planning appears especially expressive 
ability express dc dk conditions effects shows props able express somewhat sophisticated concepts hidden knowledge nondeterminism 
translation nbc evaluation props planning points expressiveness illustrating concomitant danger implied intractability restricted forms props general problems 
composition way functions illustrates danger showing simple problem structures may profound effects directionality 
reversibility reverse construction symmetric composition operators produce bidirectional island planning problems argue complexity strips arise merely persistence strips fluents 
apparently bidirectional planning hard 
appears mere choice planning direction sufficient solve strips tractability problem general 
tractable formalism better understanding real world problems needed strips planning tractable 
review chapter fundamental claims directionality planning 
successful planners capable forward chaining backward chaining behavior 
understanding directionality issues planning necessary precursor construction efficient planners 
section summarizes material previous chapters highlights underlying themes discusses impact claims draws role search direction planning 
discussed chapter speculation relative merits forward backward search planning 
reported replaces speculation concrete results 
discussion chapter examines relationship planning algorithms planning problems strips encodings 
chapters put principles practice illustrating important properties directional domains 
construction chapter reversing domain interesting things shows directionality property planning problem encodings property strips 
construction shows directionality property arising shape particular operators operators reversed shape planning problems 
construction chapter expands theme showing particular planning problem encodings property tractably solved direction 
interestingly global properties problem special characteristics operators induce directional asymmetry 
construction built encoding planning problems construction nature consists simple operators 
chapter builds construction implementing general way exploring directionality variety planners 
interesting result experiments latest generation planners including graphplan satplan largely 
jury directional planners equal performance ones encodings real world problems asp forward planner performs real world problems artificial forward way problems 
experiments provide example problem domains directional planners exhibit vastly inferior performance experiments provide evidence hurts performance planners 
chapter themes preceding chapters amplified examination extensions 
extension reversal schema chapter exhibits proper superset standard props expressive reversible 
discussion composition way problems chapter highlights ways global properties problems contribute interesting constraints search direction 
discussion computation complexity nbc planning points expressiveness consequent potential intractability simple props problems 
immediate extensions promising 
props planning language chapters implemented preprocessor existing planners expressiveness tractability evaluated encodings real world problems 
planners powerful hash function chapter replaced detector way function considered secure general cryptographic community 
cryptography smart cards similar tiny computing environments helpful providing strong way functions evaluable minimal computational resources 
results chapters applied construction planning algorithms high speed bidirectional search 
state space search properly conceived implemented basis efficient planning algorithm 
results suggest attention paid construction planning domain description languages 
needed languages tractable strips expressive describe real world problems 
intractability strips long understood planning designed increase expressiveness usually expense tractability 
constructions previous chapters indicate sacrifice may necessary interesting real world concepts expressed indirectly simple props formalism 
resource bounded scheduling enterprise planning expressive formalisms appear tractable strips able encode large classes real planning problems 
unclear formalisms intermediate expressive power tractability scheduling strips developed definitely worth exploration 
formalism compilation strips challenges 
suggests desired formalism need implicit notion persistence directionality result may useful development 
poor choice direction doom strips planner particular problems bidirectionality ability choose appropriate direction planning easy 
argue advantages backward planning advocates planning forward planning advocates languages expressive potentially intractable strips provides strong argument concentration effort finding planning languages algorithms bidirectional real world problems tractable 
bibliography james allen james hendler austin tate editors 
readings planning 
morgan kaufmann san mateo ca 
anbulagan chu min li 
heuristics unit propagation satisfiability problems 
proceedings fifteenth international joint conference artificial intelligence pages august 
bacchus teh 
making forward chaining relevant 
simmons pages 
jos luis zar josep az 
structural complexity springer verlag 
anthony barrett daniel weld 
partial order planning evaluating possible efficiency gains 
technical report tr university washington may 
roberto bayardo jr robert schrag 
csp look back techniques solve realworld sat instances 
proceedings national conference artifical intelligence pages 
berlekamp conway guy 
winning ways mathematical plays volume 
academic press 
blum furst 
readme graphplan 
carnegie mellon university 
www cgi cs cmu edu afs cs cmu edu usr avrim planning graphplan readme 
blum furst 
fast planning planning graph analysis 
artificial intelligence 
alexander 
reverse solitaire 
web document 
www knot com proofs html 
bonet bor ctor geffner 
robust fast action selection mechanism planning 
proceedings national conference artifical intelligence pages 
boppana sipser 
complexity finite functions 
van leeuwen editor handbook theoretical computer science volume mit press elsevier 
britannica online 
animal learning types learning complex problem solving insight reasoning 
web document october 
www eb com macro html 
tom bylander 
complexity results planning 
proceedings twelfth international joint conference artificial intelligence volume pages august 
anthony cassandra 
optimal policies partially observable markov decision processes 
technical report cs brown university august 
ken currie austin tate 
plan control open planning architecture 
proceedings conference expert systems pages london england 
cambridge university press 
readings planning 
richard fikes nils nilsson 
strips new approach application theorem proving problem solving 
artificial intelligence 
readings planning 
eugene fink jim blythe 
complete bidirectional planner 
simmons pages 
craig knoblock 
combining expressiveness ucpop efficiency graphplan 
advances ai planning th european conference september 
michael genesereth nils nilsson 
logical foundations artificial intelligence 
morgan kaufmann los altos ca 
matt ginsberg 
essentials artificial intelligence 
morgan kaufman san mateo ca 
matthew ginsberg 
approximate planning 
artificial intelligence 
matthew ginsberg smith 
reasoning action possible worlds approach 
artificial intelligence 
green 
application theorem proving problem solving 
proceedings international joint conference artificial intelligence pages san mateo ca 
morgan kaufmann 
readings planning 
gupta dana nau 
complexity results blocks world planning 
proceedings national conference artifical intelligence pages 
joslin pollack 
cost flaw repair plan refinement strategy planning 
proceedings national conference artifical intelligence pages 
kambhampati 
refinement planning unifying framework plan synthesis 
ai magazine summer 
henry kautz bart selman :10.1.1.38.4843
pushing envelope planning propositional logic stochastic search 
proceedings national conference artifical intelligence pages 
henry kautz bart selman 
blackbox new approach application problem solving 
working notes workshop planning combinatorial search held conjunction aips pittsburgh pa 
kernighan ritchie 
macro processor 
unix programmer manual 
bell laboratories murray hill nj 
hector levesque 
planning presence sensing 
proceedings national conference artifical intelligence pages 
manna waldinger 
theory plans 
georgeff lansky editors reasoning actions plans proceedings workshop pages 
morgan kaufmann publishers san mateo ca 
bart massey 
planner directionality testbed 
ftp able compressed tar archive 
ftp ftp cirl uoregon edu pub users bart testbed 
mcallester rosenblitt :10.1.1.18.4442
systematic nonlinear planning 
proceedings national conference artifical intelligence pages 
john mccarthy patrick hayes 
philosophical problems standpoint artificial intelligence 
machine intelligence 
drew mcdermott 
current state ai planning research 
international conference industrial engineering applications ai expert systems 
drew mcdermott planning domain definition language manual 
technical report computer science cvc report yale university 
ftp ftp cs yale edu pub mcdermott software pddl tar gz 
alan newell herbert simon 
gps program simulates human thought 
computers thought 
new york mcgraw hill 
readings planning 
pednault 
synthesizing plans contain actions context dependent effects 
computational intelligence november 
penberthy 
planning continuous change 
phd thesis university washington 
available technical report uw cse 
penberthy weld 
ucpop sound complete partial order planner adl 
proceedings third international conference knowledge representation reasoning october 
john pierce 
information theory symbols signals noise 
dover 
martha pollack david joslin massimo paolucci 
flaw selection strategies planning 
journal artificial intelligence research 
proceedings ninth national conference artificial intelligence anaheim california july 
aaai press morgan kaufman 
proceedings twelfth national conference artificial intelligence 
aaai press mit press august 
proceedings thirteenth national conference artificial intelligence 
aaai press mit press august 
proceedings fourteenth national conference artificial intelligence 
aaai press mit press july 
jussi rintanen 
planning algorithm directional search 
proceedings sixth international conference knowledge representation reasoning pages june 
earl sacerdoti 
planning hierarchy abstraction spaces 
artificial intelligence 
readings planning 
john savage 
models computation 
addison wesley 
bruce schneier 
applied cryptography 
wiley second edition 
schubert alfonso gerevini 
accelerating partial order planners improving plan goal choices 
technical report tr university rochester computer science department january 
bart selman 
near optimal plans tractability reactivity 
proceedings fourth international conference knowledge representation reasoning pages 
reid simmons manuela veloso steven smith editors 
proceedings fourth international conference artificial intelligence planning systems 
aaai press 
douglas stinson 
cryptography theory practice 
crc press 
gerald jay sussman 
nature bugs 
allen 
paul 
physics 
worth publishers new york ny second edition 
dan weld oren etzioni 
law robotics call arms 
proceedings national conference artifical intelligence pages 
david wilkins 
practical planning extending classical ai planning paradigm 
morgan kaufman san mateo ca 

