typed closure conversion minamide greg morrisett july cmu cs robert harper school computer science carnegie mellon university pittsburgh pa published fox memorandum cmu cs fox research performed author visiting fox project carnegie mellon university current address research institute mathematical sciences kyoto university kyoto japan 
research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 
part national science foundation 
ccr 
views contained document authors interpreted representing cial policies expressed implied advanced research projects agency government 
opinions ndings recommendations expressed material authors necessarily re ect views national science foundation 
study typing properties closure conversion simply typed polymorphic calculi 
accounts closure conversion treat untyped calculus translate typed source programs typed target programs 
allows compiler phases take advantage types representation analysis tag free garbage collection facilitates correctness proofs 
account closure conversion simply typed language takes advantage simple model objects mapping closures existentials 
closure conversion polymorphic language requires additional type machinery style harper lillibridge module calculus express type closure 
keywords closure conversion type theory polymorphism usual operational models programming languages calculus compute substituting terms variables terms 
substitution expensive requires traversing copying term order nd replace occurrences variable 
awell known technique mitigating costs delay substitution binding variable required evaluation 
accomplished pairing open term environment providing values free variables term 
open term may thought immutable code acts environment 
code immutable generated shared instances function 
closure conversion program transformation achieves separation code data 
functions free variables replaced code abstracted extra environment parameter 
free variables body function replaced environment 
abstracted code partially applied explicitly constructed environment providing bindings variables 
partial application code environment fact suspended function applied argument suspended application called closure data structure containing pure code representation environment 
critical decision closure conversion choice representation environment data structure example linked hybrid representation 
decision uenced desire minimize closure creation time space consumed environment time access variable environment 
important property closure conversion representation closure visible outside 
ords considerable exibility representation environments exploited advantage shao appel wand :10.1.1.34.3197
accounts consider closure conversion transformation untyped terms irrespective source term typed 
adequate compilers little types back run time 
compiling typed languages advantageous propagate type information stage compiler types link run time 
example leroy representation analysis uses types determine procedure calling conventions ohori record compilation uses run time access components record 
current compilers phases occur closure conversion output closure conversion untyped 
compilation strategies polymorphic languages proposed morrison harper morrisett rely analyzing types run time support unboxed representations non parametric operators including printing structural equality 
tag free garbage collection monomorphic polymorphic programming languages relies types run time determine size pointers objects 
support implementation strategies necessary propagate type information closure conversion generated code 
consequently purpose show conversion formulated type preserving transform 
interested type transformations basis compiling polymorphic languages 
crucial idea de ne compiler series transformations program type possibly relying type information guide transformation 
stage compiler viewed type preserving translation typed intermediate languages 
examples translations leroy ohori harper lillibridge harper morrisett 
addition practical advantages propagating type information stages compiler type directed translation facilitates correctness proofs de ning invariants transformation type indexed family logical relations 
describe closure conversion stages 
rst stage closure conversion isa type translation source language target language explicit closures 
translation described deductive system representation environment may chosen independently closure 
way various environment representations cam fam hybrid strategies suggested shao appel explained uniform framework :10.1.1.34.3197
second stage closure representation translation implementation closures determined 
main idea represent closures objects contrast proposed representation objects closures 
pierce turner consider objects packages existential type consisting single method code part closure single instance variable environment part type environment representation held :10.1.1.17.9345
captures critical privacy property representations closures 
simply typed case pierce turner model objects 
polymorphic case addition exploit notion manifest types express type polymorphic closure 
correctness closure conversion closure representation stages proved method logical relations 
main idea de ne type indexed family simulation relations establish correspondence source target terms translation 
suitable system relations de ned relatively straightforward prove induction de nition compilation relation source target translation related closed program compilation evaluate result 
closure conversion discussed descriptions various functional language compilers :10.1.1.34.3197
closely related lifting eliminates free variables bodies abstractions di ers making representation environment explicit data structure 
making environment explicit important exposes environment construction variable lookup optimizer 
furthermore shao appel show environment representations safe space choosing environment representation important part compilation :10.1.1.34.3197
wand optimizations basic closure conversion strategy called selective lightweight closure conversion provide correctness proof untyped setting 
hannan re casts wand setting provides correctness proofs wand optimizations 
hannan translation deductive system lifting consider important issue environment representation preferring account consider typing properties closure converted code 
wand hannan consider closure conversion type passing interpretation polymorphism 
ideas practical separate compilers ml compiler study novel approaches tag free garbage collection compiler provides general framework analyzing types run time determine shapes objects 
propagating types closure conversion necessary compilers types examined run time 
typed closure conversion type preserving translations possible nd eliminate compiler bugs automatically type check output compiler phase 
compilers ml representation analysis propagate type information closure conversion 
information type check resulting programs polymorphism implemented coercions polymorphic types represented single type 
assume reader familiar standard calculus presentations ml language syntax various type theoretic constructs including existential types module calculus harper lillibridge 
standard notation possible 
example write denote capture avoiding substitution value free variable remainder organized follows section closure conversion typing issues involved simply typed calculus 
section provide details type preserving transform simply typed case 
section overview closure conversion typing issues involved predicative fragment polymorphic calculus 
formal development conversion section 
overview simply typed closure conversion main ideas closure conversion may illustrated considering ml program val val val val function contains free variables may eliminate variables body abstracting environment env replacing environment 
compensation suitable environment containing bindings passed applied 
leads translation val val val val env 

env env fx yg body replaced projections eld selections access corresponding component 
code closed may hoisted enclosing de nition de ned top level 
ignore hoisting phase concentrate process closure conversion 
preceding example environment contains bindings small possible 
body contain occurrence sensible include environment resulting code val val val val env 

env env fx zg example chose fam representation environment asa record eld variable 
alternatively choose linked cam representation example binding separate frame attached front remaining bindings 
idea leads translation val val val val env 

link link env link env fz link fy link fx linked representation facilitates sharing environments expense introducing link traversals proportional nesting depth variable environment 
linked representation support constant time closure creation requires re current environment result bindings environment occur free function asz leading space leaks 
simple translations fail delay application code environment call value evaluation 
natural representation delayed application closure ordered pair code env consisting code environment 
application closure argument proceeds projecting code part closure applying simultaneously environment argument calling convention 
example val val val val code env 
env env val env fx yg val code env code form type environment env closure type showing type environment explicitly 
violates privacy environment representation 
result translation typed source program general result typed target program 
example consider ml source program type int int pack ftg fx open ftv typing rules existentials val true performing translation yields val true env 
fy yg env 
fg program fails type check arm expression type fy intg int int fy intg arm type fg int int fg 
order preserve types target language representation environment may hidden existential types 
gives typing rules existentials 
pack operation pairs type value existential holding type variable open operation takes package opens binding type value package scope 
type constrained leave scope open construct restriction appear free type variables pack hide type environment closure value follows pack code env tve tve tve closure type represented package type tve tve tve held tve 
translation example translated val true pack fy intg env 
env fy yg tve tve int int tve pack fg env 
fg tve tve int int tve types arms expression agree target code typed type tve tve int int tve 
application correspondingly translated expression open tve tve tve opens package extracts code environment applies code environment argument 
representation closures bears striking resemblance model objects suggested pierce turner :10.1.1.17.9345
model object type form type instance variable type method 
foregoing account closures may thought objects instance variable environment method code 
account simply typed closure conversion section details closure conversion call value simply typed calculus 
conversion described increasing detail stages rst stage closure conversion converts function closure holds representation closure 
simplify presentation freedom allowed construction environments shared environments 
second stage environment sharing adds structure translation allowing environments shared 
third stage closure representation representation closures explicit translucent sums 
stage de ned type directed translation correctness translations established logical relations 
syntax source language de ned follows types expressions values types consist base types function types 
expressions consist constants base type variables abstractions applications 
denote sequence type bindings form fx xn ng xi distinct 
judgement results easily extended source types including products sums 
asserts expression type type assignment derived standard typing rules simply typed calculus 
de ne dynamic semantics language judgement form 
evaluates 
judgement derived standard inference rules call value evaluation 




closure conversion target language closure conversion cl de ned follows types ni code expressions eni xve hhe ii values xve hv ii informally closures partial applications 
noted wish delay partial application closure applied argument code environment remain separate code shared instantiation closure 
account closure conversion represent delayed partial application closure form hhe code eve environment 
allows distinguish delayed partial applications closures closure application 
code expressions xve restricted form closed expressions environment xve argument 
types code expressions distinguished types closures written code types environment argument return value respectively 
cl typing rules standard code closures de ned follows xve code code eve hhe require code closed order may hoisted top level xve environment argument assumed typing body code 
closure consisting code type code environment oftype type corresponding directly typing partial application code environment 
tuple types ni tuples eni introduced represent environments closures 
evaluation language de ned inference rules allow conclude judgement form 


en 
vn eni 
hv hv 
vi 

hhe ii 
ii 
hh xve 
xve 

closure applied argument environment argument substituted corresponding variables body code evaluated 
de ne closure conversion type directed translation source language cl 
translation formulated deductive system judgements form source type assignments const arg env fx xn ng xi xve abs eve hh xve app context xn en fx xn ng eni fx xi simply typed closure conversion source type source expression target expressions 
variable considered current argument free variables source expression accessed current environment translation 
judgement asserts translation assumption fx judgement asserts expression evaluates environment corresponding assumption binding occurs fx note order bindings important considered sequence set 
translated expression xve hold current 
consequently translation rule env maps source variable xi ith position type assignment projection environment variable xve rule arg translates argument variable 
translation abstraction produces closure consisting code environment 
construct environment choose type assignment eve derivable context rule constraints summarized saying binding fx detailed formulation obtained fx application strengthening exchange rules 
furthermore required contain bindings free variables original function may contain bindings fx occur free function 
choices chose minimize running time space consumed target code 
environment constructed context rule translating variables occurring xn target expressions en 
resulting expressions placed tuple eni form environment data structure closure 
environment hastype ni writing produce code closure translate body source function strengthened assumptions producing body code environment argument resulting xve derivation translation closely related typing derivation source program 
particular examination translation rules virtue source language explicitly typed clear exists unique construct derivation fx consequently easily show translation preserves type source program sense lemma fx proof 
induction derivation case arg 
case env 
xn ng 
fx xi xve ni 
xve case abs 
second induction hypothesis 
xve code 
construction eve clear eve 
typing rule closures hh xve 
case app 
know fx induction implies 
fx induction implies 
dummy argument closed program clear previous lemma translation preserves program type 
theorem prove operational correctness translation indexed family logical relations relating closed source expressions closed target expressions closed source values closed target values 
relations de ned induction source types follows 


vv extend relation nite source target substitutions mapping variables respective class values 
relations de ned follows fx xn ng hv xve xi vi xve xve lemma shows translation variable environment evaluates corresponding value 
lemma 


eve eve 
xve 
proof 
claim clear 
proof 
case arg 
clear de nition 

case env 
xn ng 
xve 
vi 
de nition xi vi 
lemma hand establish correctness translation 
theorem operational correctness 
fx proof 
induction derivation case arg env 
clear lemma 
case abs 
rst induction hypothesis know eve 
easy show eve 

lemma xve 
second induction hypothesis xve 

hh xve 
case app 
induction hypothesis 




andv de nition 
theorem de nition relations imply closed program base type results evaluation original program translation 
corollary clear various translations program operational behavior 
corollary coherence 

sharing environments implementations functional programming languages environments nested structures may share portions environment closures 
sharing environments decreases amount space consumed closure decreases time construct closure environment 
sharing require extra instructions access variable binding environment 
furthermore sharing environments naively lead space problems presence standard tracing garbage collector 
section extend closure conversion allow require shared environments 
adding extra structure typing contexts translation judgement extra structure guide construction possibly shared environments 
show resulting translation subsumes wide variety representations practice 
previous section translation judgements form type assignment form fx xn ng 
add extra structure translation judgement type assignments de ned follows fx mi nested type assignment single type binding sequence nested type assignments 
environment corresponding type assignment represented target language type jfx gj jh mij hj 
clearly wecan obtain arg fx fx env xve var fx env tuple ni xve xve en ni eni simply typed closure conversion nested environments non nested type assignment assignment simply dropping extra structure 
consider represent nested type assignment aswell corresponding type assignment 
relevant translation rules closure conversion nested environments 
translation rules replacing arg rule translates nested type assignment consisting current argument variable 
env current environment directly xve allowing avoid creating copy 
rule coupled env tuple rule allows construct shared environments nested tuples 
translate type assignment rule lets translate xve xve type assignment contains ith component 
variable translated nested type assignment fx var 
example translation current environment reused construct environment closure hx int inti int 
int hh xve int xve xve xve hx hint hint 
new environment closure constructed pairing current argument current environment xve 
reusing portion environment reduce cost creation closure 
translation constructing new environment require projecting values current environment values current argument need placed newly allocated tuple 
type assignments easy prove translation program nested type assignments preserves type program operational correctness translation may logical relations 
nested type assignments exible represent various environment representations practice 
example categorical machine cam uses linked lists represent environments 
re ected framework restricting shape nested type assignments restricting env tuple rule cons current argument current environment cam context fx hfx ci env tuple hx ci hx advantage cam strategy cost construction new environment constant 
worst case accessing values environment takes time proportional length environment 
contrast fam uses environments sharing 
closure conversion accurately models environment strategy fam choose speci strengthening strategy abs rule free variables function preserved resulting closure environment 
advantage fam environment representation cost variable lookup constant representation safe space appel de nition 
constructing environment closure takes time proportional number free variables function closures share portions environment 
clearly variety strategies forming environments 
example shared closure strategy described appel shao safe space formulated framework :10.1.1.34.3197
determine representation closure environment requires deal information including estimate times variable accessed garbage collection occur garbage collection algorithm closure representation closure conversion chooses environment representation closure construction closures explicit 
making environment construction explicit facilitates variety strategies attempt minimize space consumed running time resulting program 
furthermore construction explicit expose operations implicit source level optimizer target level 
particular optimizer notice environment constructed places replace second construction rst 
closure conversion extraction code environment application implicit operational semantics 
ideally extraction operations explicit optimizer eliminate redundant projections 
instance closure repeatedly applied arguments loop able extract code environment closure time name values names loop 
rst attempt making extraction code environment explicit represent closures pairs tuples target language simply projection 
argued naive translation preserve types 
di culty environment type exposed translated type 
consequently expressions source type general target types translated 
problem solved hiding type environment existential types pierce turner objects :10.1.1.17.9345
de ne target language existential types follows types ni code exp xve eni pack open values xve hv pack cl language addition package values type pair type value type function types 
longer necessary represented type constructors code 
order prevent partial application code environment restrict applications form 
typing judgements form list type variables assignment 
assume free type variables free type variables contained typing rules similar rules cl elimination rules existentials pack ftg fx ftv open similarly operational semantics cl rules involving existentials application 
pack 
pack 
pack 
open 





de ning translation cl types denoted de ned follows jbj jh nij hj nji code vej tve hcode tve translation arrow type pair consisting code environment environment type tve held existential 
translation mapping cl terms terms summarized 
translation de nes judgements form cl type assignment expression type respectively expression 
interesting rules closure cl app 
rules simply map constructs counterparts 
closure translated pair code environment packed type environment 
translation application extracts package pair code environment applies code environment argument 
easy prove translation preserves type program translation type 
extending type translation type assignments writing jfx xn fx xn njg theorem proof 
induction derivation operational correctness translation proven logical relations cl expressions cl values cl substitutions 
relations de ned 
var const proj ni tuple ei eni ni ni code xve xve vej closure code eve hhe pack vej app open tve hcode tve dom important rules simply typed closure representation theorem operational correctness 
proof 
induction derivation case var 

case closure 
hhe pack vei 
induction hypotheses code eve 


code eve 

letv 
hand open pack vei tve tve 

hhe 
pack vei 
case code 

xve code xve vej clear xve xve 
induction hypothesis xve xve hh xve xve vej 
xve code xve vej case app 
rst induction hypothesis 


second induction hypothesis 

de nition relation open tve tve 
open tve tve 
case tuple proj 
induction 


code 
vv open tve code tve hv ni hv ni vi logical relations simply typed closure representation operational semantics pack considered pair type expression 
implementations treat type environment closure uniformly held expect environment value compiled single machine word environment boxed 
implementations conceptually erase type information pack execution 
implementations types treated uniform matter representation remain part data structure runtime 
particular calculus described harper morrisett supports typecase mechanism allows type examined di erent code selected type 
example support calling conventions environment unboxed placed registers 
example tag free garbage collection relies type information associated closures shape values environment reconstructed garbage collection 
essence garbage collection typecase non parametric operation allowed examine types select code type 
type closure conversion type information needed support non parametric operations explicit 
provides evidence treatment closures existentials type theoretically proper 
overview polymorphic closure conversion closure conversion language ml style predicative explicit polymorphism follows similar pattern simply typed case additional complication account free type variables free value variables code abstraction value abstractions terms type abstractions terms induce creation closures 
section typing di culties encountered closure converting value abstractions 
treatment oftype abstractions similar see section details 
eliminate free occurrences type variables ordinary variables code respect type environment value environment replacing free variables appropriate environment 
abstracting free type variables free value variables code closed hoisted top level 
abstracted code partially applied suitable representations type value environments form polymorphic closure 
simply typed case need data structure represent delayed partial application code environments 
need kind type environment type value environment representations remain private closure 
abstraction run typing problems encountered simply typed case 
running example consider expression 
int type 
int free type variables free value variables type int respectively 
closure conversion expression translated partial application val code tenv ft fy tenv intg 
tenv code ft fy zg code abstracts type environment tenv value environment arguments 
actual type environment ft constructor record kind ft kind monotypes 
actual value environment fy zg record type fy intg 
keep code closed may hoisted free type variables type come tenv 
type fy tenv intg 
similarly code argument type tenv 
consequently part closure closed expression closed type tenv ft fy tenv intg tenv tenv tenv int easy check entire expression type 
int type original function preserved 
translate partial application code environments data structure 
structure mixed phased needs hold type type environment values code value environment 
rst attempt represent data structure package pack ft code fy zg tte te 
code code closure te ft fy tte intg easy verify typed typing rule pack 
unfortunately problem approach application argument open package extract code type value environments prior call open tte te tte obvious translation application fails typed 
di type expression tte type culty tte tte tte int 
tte provably equivalent tte translation application fails typecheck 
problem existentials provide certain kind mixed phase data structure type portion 
hide representations need know type environment order determine type closure 
short need mixed phase data structure hide type component 
problem encountered study ml module systems :10.1.1.104.171
solutions idea translucent sums types provide power existentials weak sums transparent sums strong sums 
ascribing translucent sum type tte ft 
closure equation tte ft propagated scope abstraction particular tte ft translation application type correct 
step hide representation value environment case 
simply type type expression obtain tte ft tve tve tve type value environment 
fails type sense type value environment closure corresponding argument type code closure 
translation application ill typed value environment type tve domain type tte fy intg 
tve types considered distinct 
order simultaneously type value environment corresponding argument type code need replace types type tve 
todo show types equivalent 
accomplished requiring formal type environment argument tenv instantiated type environment tte 
way toachieve perform application code tte goal closure conversion delay partial applications 
alternative approach coerce code type tenv tte te 
fy tenv intg tenv tenv tenv int adding constraint tenv tte type code ect performing type application type level delays application term level 
note supertype original code type rules translucent sum calculus 
consequently code remains closed hoisted top level 
contrast performed type application resulting code closed containing free tte 
tenv tte tte ft follows tenv ft ti tenv ti 
consequently data structure holding components closure coerced equivalent type tte ft 
fy intg tenv tte te fy intg int equivalent type mention type environment tte constraint tenv type value environment fy intg kind type environment te obtain closure type tte tve tve tenv tte tve int easy derive atype preserving translation application corresponding representation closures 
simply open existentials pass type environment value environment argument code 
careful consideration foregoing discussion reveals limited 
equational constraint dropped existential ensure privacy environment representation universally quanti ed variable tenv occur scope abstraction 
suggests substantially simpler mechanism full translucent sum calculus appropriate closure conversion 
introduce special type written functions applied constructor yield value type rules govern new type constructor rst rule restricts domain type application speci constructor corresponds restricting type propagating equivalence actual type application permitted constructors equivalent rules naturally come necessity delaying type applications closure conversion 
notation type translation tte tve tte tve tve type closures abstracts kind type environment type value environment ensuring may separately closure system 
simply typed case obtained object oriented representation polymorphic closures exploiting combination type systems proposed pierce turner objects harper lillibridge modules :10.1.1.17.9345
account closure conversion section conversion predicative subset second order calculus 
argued predicative fragment captures essence ml style polymorphism strati cation monotypes types involving quanti er instantiation type variables restricted monotypes 
restrictions easy logical relations argue correctness fashion simply typed calculus 
syntax source language de ned follows kinds constructors types expressions values type constructors described kinds 
kind subsequent languages kind structure introduce kinds uniformity 
closed constructors kind correspond subset types monotypes particular types include quanti ers 
constructors kind injected types 
leave injection implicit treat constructor type 
kind assignment sequence maps type variables kinds form ft tn ng 
typing judgements form free type variables contained domain free value variables contained domain 
typing judgement standard typing rules second order calculus see example 
interesting rules elimination rules quanti ed types ft dom ftv dom rule allows conclude expression polymorphic type extending kind assignment allows conclude body expression type elimination rule allows conclude type application type monotype free type variables contained domain expression type operational semantics de ned inference rules 







closures simply typed case break closure conversion closure conversion closure representation stages closure conversion stage converts abstractions abstractions closures consisting code type environment value environment 
material environment sharing carries straightforward manner 
target language syntax target language cl de ned follows kinds con ni ni types ni vcode tte te tcode tte te exp eni tte te xve tte te xve hhe ii values hv tte te xve tte te xve ii product kind ni specify shape type environments just product type speci es shape value environments 
constructors kind constructor ni kind ni type environment consisting translated program 
types codes code ordinary abstraction tte te xve code type abstraction tte te xve codes take atype environment value environment type value argument respectively 
weintroduce types vcode tcode distinguish types codes types closures avoid partial applications codes 
intuitively correspond standard types follows vcode tte te tte te tcode tte te tte te types excluding vcode tcode named constructor 
closure hhe ii consists code atype environment constructor environment 
typing cl kind assignments map type variables kinds type assignments map value variables types 
judgements static semantics follows formed constructor kind formed type 
equivalent constructors 
equivalent types 
formed expression type typing rules language de ned figures 
require code values closed respect type variables value variables 
allows hoist code inner de nitions top level 
code closure hhe ii type type vcode tte te vcode tte te tte tte 
operational semantics cl 
closure expression evaluated code type environment value environment evaluated closure consisting components created 
argument applied closure type environment value environment argument passed code closure 
formedness constructors ft dom ni ni ni ni formedness types ft dom ni ftte ftte ftte vcode tte te ftte ftte te tcode tte te primary rules equivalence constructors ni ni ni tte ni ni formation equivalence types constructors en eni ni ni ftte tte te xve vcode tte te ftte te tte te xve tcode tte te vcode tte te te te tte hhe te ii te tte tcode tte te te te te tte hhe te ii te tte typing rules cl 

en 
vn eni 
hv 

hhe ii 
ii hv 
vi 
hh tte te xve te 
te tte xve 


hh tte te xve te 
te tte xve 
operational semantics cl various strategies evaluation constructors including call value call need lazy evaluation reach normal form 
simplicity doesnot evaluate constructors explicitly 
operational correctness strategies may proved changes 
translation env arg ft tn arg ti tte env arg dom arg env arg env arg env arg env arg env arg env arg ft ni env arg ft env arg env arg env arg env arg fx xn ng fx xn ng polymorphic closure conversion types type assignments closure conversion formulated type directed translation cl bythe deductive system figures 
judgement env arg means translation env kind assignment corresponding type environment arg kind assignment corresponding type argument 
judgement implicitly de nes translation constructors constructors source level constructors subset types translation maps constructors constructors 
translated programs type variable tte type environments 
judgement env arg env arg means translation env arg type translation env arg type assignments corresponding value environment value argument respectively 
depending translating atype abstraction value abstraction arg arg empty 
atype environment corresponding env value environment corresponding env implemented target language types form respectively de ned 
tn ni jfx xn ni simplicity representations value type environments considered translation 
interesting rules term translations value type abstractions 
case appropriate type environment value environment constructed part closure 
assignments env env chosen subsets current assignments env arg env arg respectively 
assignments chosen free value variables term contained env free type variables term value environment contained env 
const env arg env arg env env arg fx xn ng arg xi xve arg env arg env arg dom arg abs env arg env arg env te env arg env arg env eve env env env env env env fx env arg env arg hh tte xve te tabs env arg env arg env te env arg env arg env eve env env env env ft env env arg env arg hh tte xve env te app env arg env arg env arg env arg env arg env arg tapp env arg env arg env arg env arg env arg context env env arg env arg xi arg env arg fx xn ng ni polymorphic closure conversion terms primary subtlety rules type assignments env env describe value environment closure depending context 
env constructed context env arg env arg build environment eve context constructing closure 
contrast env obtained env translation corresponds type value environment context closure 
ensures code closure closed type ascribed value environment argument refer free type variables context closure created 
env env env type correctness lemma shows type translation commutes substitution 
lemma env arg ft env arg env arg env arg 
proof 
induction derivation env arg ft case env arg ft assumption env arg case env arg ft de nition translation types env arg case env arg ft ti tte 
ti env env arg ti tte 
case env arg ft induction hypotheses env arg ft env arg ft 
de nition substitution type translation env arg ft 

case env arg ft derived env arg ft conversion chosen di erent assumption de nition translation env arg ft induction hypothesis env arg ft 
substitution env arg 
lemma shows types suitably equivalent translated current kind assignment kind assignment derived current kind assignment 
lemma env arg env te env arg env arg arg ftte envjg arg arg te tte 
proof 
induction derivation env arg 
case env arg clear 
case env arg tte 
env ft tn arg fs sm subcase tj 
env arg arg tj tte envjg te tte 
subcase sj 
env arg arg sj sj ftte envjg te sj 
case env arg 
clear induction hypotheses 
case env arg derived env arg ft 
env arg arg ft ftte envjg arg arg ft te tte 
env arg arg ftte envjg arg arg te tte simply typed case value environment produced env type obtained translating env lemma env arg env arg env eve env arg env env env arg env arg eve 
type correctness translation proved induction derivation translation 
theorem type correctness env arg env arg env arg env arg ftte envjg arg env jg arg env arg env arg env env env arg arg arg proof 
induction derivation env arg env arg case env 
env fx xn ng 
env fx xn ng env arg ftte envjg arg envjg arg xve case arg 
arg fx xn ng 
arg fx xn ng env arg ftte envjg arg envjg arg xi case abs 
env env env env env env env env fx induction hypothesis ftte envjg env envjg arg 
ftte envjg arg tte xve vcode tte env arg env arg env env ftte envjg arg te tte ftte envjg te tte ftte envjg arg eve lemma ftte envjg arg hh tte env xve env te case tabs 
env ft env env env env 
env ft env induction hypothesis ftte envjg env ft 
envjg arg 
ftte envjg arg tte xve tcode tte env arg env arg env env 
lemma ftte envjg arg te tte ftte envjg arg te tte ftte envjg arg eve ftte envjg arg hh tte xve te case tapp 
env arg env arg 
induction hypothesis ftte envjg arg envjg arg env arg ft env arg ftte envjg arg env arg 
lemma env arg 
case app 
rst induction hypothesis ftte envjg arg envjg arg env arg 
second induction hypothesis ftte envjg arg envjg arg 
ftte envjg arg envjg arg 
operational correctness prove operational correctness translation logical relations fashion simply typed case source language restricted predicative polymorphism 
de ne relation closed source target constructors 
de ne logical relations inductively lexicographic order number quanti ers type size instantiation restricted types contain quanti ers measure decreases type application 
relations de ned follows 


vv extend relation substitutions follows fx xn ng hv xve xi vi 
fx xn ng xve vn xn xve xi vi 
de ne relation constructor substitutions indexed source kind assignments 
source kind assignments bind type variables kind omit kinds ft tng ni tte ti ft tng tte tn tte ti important property translation applying related type substitutions type translation result types related 
lemma env arg env arg 
proof 
induction derivation env arg case tj env ft tng 
tte 
de nition tte ni ti tte ti tte 
case arg 
de nition 
case 
induction 
lemma env arg env arg env te env te tte 
proof 
env ft tn te ni env arg ti su cient ifwe show ti 
follows previous lemma 
lemma env arg env arg 
env arg env arg env arg env arg 

env arg env arg env eve eve 
env xve 
lemmas hand translation preserves operational behavior program 
theorem operational correctness env arg env arg arg 
env arg env arg env arg env proof 
induction derivation env arg env arg case arg env 
clear lemma 
case abs 
eve 

lemma env fx xve 
te lemma env tte 
induction hypothesis tte xve 

hh tte xve case tabs 
eve 

lemma env xve 
te lemma tte 
induction hypothesis tte 
hh tte xve case tapp 
env arg env arg induction hypothesis 

lemma 

case app 
induction hypothesis 


induction hypothesis 




closure representation section closure representation second order language 
types existential kinds representation type environments existential types representation value environments 
introduce type derived translucent types solve typing problems discussed overview 
target language target language polymorphic closure representation called de ned follows kinds ni types ni ni exp eni pack open pack open distinction types constructors type application longer restricted just monotypes 
needs impredicativity monotypes source language translated types quanti ers 
simplify language provide full abstractions codes argument time 
provide types existential kinds kind variables kind contexts typing judgements simply sequence kind variables fk 
typing judgements language consist kind equal types kind type typing rules de ned figures 
described overview typing rule type applications split rules ins tapp 
rule ins restricts domain type application speci type corresponds restricting type propagating equivalence actual type application permitted type rule tapp 
interesting rules kpk types existential kinds 
analogous rules ordinary existential types 
type abstracted kind formed necessarily true formed 
example formed type 
operational semantics language de ned 
lemma substitution 
fkg 

ft 

fx formedness types ft dom ng ni ni ni ft dom ft dom fkg primary rules equivalence types ng ni formation equivalence types lemma implicitly proof type preservation theorem 
lemma 

proof 
lemma proved de ning reduction types ih ni 

reduction church rosser strong normalizing 
decision procedure theorem type preservation 
proof 
induction derivation 
proof write assume rule drive rule 
rule exists derivation rule 
show cases application type application open expressions 
case 
derived 


derived 
rst induction hypothesis 

fx 
substitution lemma 
second induction hypothesis 
ins tapp var fx const tuple en eni ni proj abs ni fx dom app tabs ft dom tpk pack top ft fx open ftv dom kpk pack fx open dom typing rules 

en 
vn eni 
hv 



hv 
vi 


pack 

pack 
open 

pack 
pack 
pack 
open 

pack operational semantics case 
derived 

derived rst induction hypothesis ft substitution lemma 
induction hypothesis case open 
derived 
pack 
de nition typing derivation 
induction hypothesis pack 

hand fkg fx substitution lemma advantage fact 
case open 
derived 
pack 
de nition typing derivation 
induction hypothesis pack 

hand ft fx substitution lemma advantage fact ftv 
translation de ne closure representation stage type directed translation cl de ning translation source constructors types target type follows jtj jbj jh nij hj nji jh nij hj nji vej vej code types translated corresponding types described previous section 
translation function type abstracts kind type environment type value environment 
type environment paired code existential type 
type code instantiated type environment closure code 
code value environment paired simply typed case 
translation structure arrow type 
translation expressions 
simplify presentation introduce derived forms expressions pack pack pack pack open open open open kind type environment type environment environment packed pair code value environment 
translation applications type environment obtained closure expression code value environment obtained projections 
type environment value environment argument application passed code 
straightforward show type translation preserves equality commutes substitutions 
lemma 
cl 
cl lemma var const vcode tcode prod proj en eni ni ni ni ftte 
tte te xve vcode tte te tte te xve vej ftte te 
tte te xve tcode tte te tte te xve vej vcl vcode tte te eve hhe pack te vej vei app open tte tve tve tte tcl tapp tcode tte te eve hhe pack te vej vei open tte tve tve tte closure representation proof 
induction structure case 
induction hypothesis type correctness translation proven induction derivation translation 
typing rules essential prove cases translations closures 
theorem type correctness proof 
induction derivation translation 
show important cases 
cases clear de nition induction hypothesis 
case vcl 
induction hypothesis 
tte te vej 
vej 
vej tte lemma vej 

pack vej te 
pack pack vej 
pack pack pack vej case tcl 
induction hypothesis 
tte te vej 
vej 
vej lemma tte vej 
rest similar case 
case app 
induction hypothesis 
ftte fy tve tte 

case tapp 
similar case app 
case 
induction hypothesis lemma operational correctness prove translation cl preserves operational behavior program 
de ne logical relations indexed sources types 
de nition complicated due presence types form source language 
consider reduction types generated orienting type equivalences follows ih ni 

clear reduction church rosser strong normalizing 
exists unique normal form 
normal forms syntactically equal 
write nf normal form logical relation type formal form de ned relation nf 
de nition relations fact normal form form 
relations de ned inductively lexicographic order number vcode constructors size 

nf normal form 
vcode ii tcode ii 
vv open ti open hv ni hv vi ti de nition clear value relation extends substitutions straightforward manner 
write operational correctness translation proved induction derivation translation 
theorem operational correctness 
proof 
induction derivation case var const 
clear de nition 
case prod proj 
clear induction hypothesis 
case 
induction hypothesis 

case vcl 
induction hypothesis vcode eve 


andv vcode eve 

andv 

jv 
hand pack vej vei ht 
open 
jv 
hhe 

case vcode 
tte tte andv tte xve xve 
induction hypothesis xve xve 
fv fx ftv hh tte te xve tte tte te xve vej jv 
tte te xve vcode tte te tte xve vej 
case app 
induction hypothesis 


induction hypothesis 


de nition open tte tve tte tve tte 
open tte tve tte tve tte 
case tcl 
induction hypothesis tcode eve 


tcode eve 

andv 
ii jv 
hand pack vej ht 
open 
jv 
hhe 
case tcode 
tte tte 
xve xve 
induction hypothesis xve xve 
fv ftv ftte sg hh tte te xve ii tte tte xve vej jv 
tte xve tcode tte tte xve vej 
case tapp 
induction hypothesis 

de nition open tte tve tte tve tte lemma 
open tte tve tte tve tte 
summary type theoretic account closure conversion simply typed polymorphic calculi 
translations unique map typed source terms typed target terms 
facilitates correctness proofs allows type directed transforms conversion unboxing applied closure conversion supports run time examination types tag free garbage collection 
ideas practical separate compilers ml compiler study novel approaches tag free garbage collection compiler provides general framework analyzing types run time determine shapes objects 
propagating types closure conversion necessary compilers types examined run time 
simplicity current implementations compilers closure conversion 
compilers compilers avoid creation closures known functions 
optimization introduce problem 
lightweight closure conversion proposed wand formulated type preserving translation closure conversions 
de nition translation may complicated type closure translation abstraction depends free variables passed directly 
implementation closure represented folding code pointer environment record 
representation may formulated closure conversion modi cations 
closure representation closures need powerful type system 
andrzej filinski mark leone benjamin pierce david tarditi comments suggestions 
abadi cardelli 
curien levy 
explicit substitutions 
acm symp 
principles programming languages 
appel 
runtime tags aren necessary 
journal lisp symbolic computation 
appel 
compiling continuations 
cambridge university press 
appel jim 
continuation passing closure passing style 
acm symp 
principles programming languages 
britton 
heap storage management programming language pascal 
master thesis university arizona 
cardelli 
functional machine 
polymorphism 
cousineau 
curien mauny 
categorical machine 
functional programming languages computer architecture pages 
friedman 
equality functionals 
parikh editor logic colloquium 
holland 
hannan 
type system closure conversion 
workshop types program analysis 
harper lillibridge 
explicit polymorphism cps conversion 
acm symp 
principles programming languages 
harper lillibridge 
type theoretic approach higher order modules 
acm symp 
principles programming languages pages 
harper macqueen milner 
standard ml 
technical report ecs lfcs laboratory foundations computer science edinburgh university mar 
harper mitchell 
type structure standard ml 
acm transaction programming languages systems 
harper morrisett 
compiling polymorphism intensional type analysis 
acm symp 
principles programming languages pages 
johnsson 
lambda lifting transforming programs recursive equations 
functional programming language computer architecture lncs pages 
springer verlag 
kelsey hudak 
realistic compilation program translation detailed summary 
acm symp 
principles programming languages pages 
kranz orbit optimizing compiler scheme 
proc 
sigplan symp 
compiler construction 
landin 
mechanical evaluation expressions 
computer journal 
leroy 
unboxed objects polymorphic typing 
acm symp 
principles programming languages 
leroy 
manifest types modules separate compilation 
acm symp 
principles programming languages pages 
macqueen 
modules standard ml 
proc 
acm conf 
lisp functional programming pages 
revised version appears 
milner tofte harper 
de nition standard ml 
mit press 
mitchell plotkin 
types existential type 
acm transaction programming languages systems 
morrisett felleisen harper 
models memory management 
functional programming languages computer architecture pages june 
morrison dearle connor brown 
ad hoc approach implementation polymorphism 
acm transaction programming languages systems 
ohori 
compilation method ml style polymorphic record calculi 
acm symp 
principles programming languages 
pierce turner :10.1.1.17.9345
simple type theoretic foundations object oriented programming 
journal functional programming apr 
preliminary version appeared principles programming languages university edinburgh technical report ecs lfcs title object oriented programming recursive types 
plotkin 
lambda de nability full type hierarchy 
curry essays combinatory logic lambda calculus formalism 
academic press 
reddy 
objects closures 
proc 
acm conf 
lisp functional programming 
reynolds 
de nitional interpreters higher order programming languages 
proceedings annual acm conference pages 
shao appel :10.1.1.34.3197
space cient closure representations 
proc 
acm conf 
lisp functional programming 
shao appel 
type compiler standard ml 
programming language design pages 
statman 
completeness invariance lambda de nability 
journal symbolic logic 
statman 
logical relations typed calculus 
information control 
steele jr rabbit compiler scheme 
master thesis mit 
tait 
intensional interpretation functionals nite type 
journal symbolic logic 
tolmach 
tag free garbage collection explicit type parameters 
proc 
acm conf 
lisp functional programming pages june 
wand 
selective lightweight closure conversion 
acm symp 
principles programming languages 

