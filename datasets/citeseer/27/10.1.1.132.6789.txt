uniqueness typing redefined de vries rinus plasmeijer david abrahamson trinity college dublin ireland david cs tcd universiteit nijmegen netherlands rinus cs ru nl 
modify clean uniqueness type system ways 
clean functions partially applied unique argument necessarily unique lose uniqueness just require unique applied 
ultimately subtyping redundant 
second extend type system allow higher rank types 
able explicitly associate type constraints attribute inequalities type schemes 
consequently types system precise constraint propagation 
background problem modelling side effects pure functional languages losing referential transparency known 
consider function freadi reads integer file 
type function freadi file int able return integer invocation freadi advances file pointer returning 
side effect causes loss referential transparency 
instance interchangeable file freadi file freadi file file freadi file way freadi side effect explicit modifying signature freadi world file world int world data type representing world 
redefine world file world freadi world file world freadi world file world supported irish research council science engineering technology funded national development plan subscripts able refer particular versions part code 
world file world freadi world file world clear fact different functions 
problem gone away stopping writing world file world freadi world file world freadi world file world language haskell problem essentially solved hiding state threading monad giving direct access world object 
programs correct construction affects style programming 
contrast uniqueness typing enforces correct state threading type system 
main idea ensure single unique particular world state 
reflected type freadi freadi world file world int bullets indicate freadi requires unique world turn promises return unique 
compiler typechecks finds world violates uniqueness requirements accepted 
type system depends sharing analysis program explained briefly sect 

typing rules rank easier understand typing rules arbitrary rank rank typing rules sect 
extend arbitrary rank sect 

consider examples sect 
outline type inference algorithm sect 
compare system original clean type system sect 
list sect 

sharing analysis typing rules depend sharing analysis marks variable uses unique non unique 
sharing analysis sophisticated derivation program variable evaluated twice marked non unique :10.1.1.36.3338
assume sharing analysis done leaving formal definition 
look example 
compare definitions sect 

correct definition variable marking indicates world unique required freadi world file world freadi world file world freadi world file world marking incorrect definition indicates world state violating uniqueness requirement world file world freadi world file world freadi world file world sect 
look example typed sophisticated sharing analysis applied 
introducing uniqueness typing uniqueness type system allows rank types showing full type system sect 

expression language type language modified support arbitrary rank types typing rules section easier understand better way introduce type system 
language define type system core lambda calculus expression variable abstraction application integer typing rules assign attributed type expression type environment uniqueness attribute explained sect 
denoted language types uniqueness attributes defined type uniqueness attribute type variable variable int function constant type unique non unique syntax arrows warrants closer look 
domain codomain arrow attributed types arrow additional include definitions corresponding typing rule look quite different typing rule eventually point including 
give typing rule definitions sect 

attribute role apparent discuss rule abstractions 
adopt notational convention writing normal uniqueness attribute arrow 
customary type attribute variables attributed type implicitly universally quantified outermost level course true arbitrary rank system 
section type environment maps variable names attributed types sect 
map variable names type schemes 
integers specify alternative rules integers int int int int int says integers type int arbitrary programmer free assume integer unique non unique 
alternatively int states integer unique 
discuss prefer int sect 

variables rule variables marked unique var simply states find type variable look variable environment 
variables marked non unique correct type non unique var var note var leaves uniqueness attribute variable environment arbitrary 
means variables lose uniqueness 
example function defined type assuming product type words matter uniqueness input pair non unique 
abstractions discuss typing rule abstractions return example discussed sect 
point subtlety 
consider world file world freadi world file world freadi world file world compiler able reject definition world marked nonunique cause type inferred non unique rule var happens curry freadi 
world file curried freadi world world curried file world curried file world programs semantically equivalent type checker reject programs 
argument world freadi fact unique second example detect type error 
general principle function accesses unique objects closure closure function unique example curried accesses unique file handle closure unique resulting type error 
approximate function curried curried argument unique result function unique applied lambda calculus functions single argument notion currying translates lambda abstractions returning new lambda abstractions 
rephrase lambda abstraction returns new lambda abstraction argument outer lambda abstraction unique inner lambda abstraction unique applied type language additional attribute arrow type indicates function required unique applied 
purpose typing rules indicate currently body outer lambda abstraction argument unique 
arrive rule abs abs rule similar normal rule abstractions hindley milner type system exception attribute inequalities premise rule 
operator read implication unique unique implies 
approximation function may curried argument 
body function uniqueness need affect type function 
constraint establishes body outer lambda abstraction argument unique inner lambda abstraction unique applied 
second constraint near direct translation premise 
simply propagates premise holds continue body abstraction 
note abs rule changes value rules simply propagate 
typing expression initially assumed non unique 
probably instructive consider example point 
show type derivation function returns arguments var abs abs noting vacuously true irrelevant referenced imply transitivity arrive type constraint says curry function specify happens unique result function unique application attribute 
consider rule int says integers unique definition abs imply curry function passing integer result function unique application unnecessary 
example want expression type correct fst fst reason abs constrains actual uniqueness function left free 
application rule function application relatively straightforward 
difference rule usual definition app enforces constraint functions unique applied fact unique applied app arbitrary rank types rank system clean type system constraints explicitly associated types left implicit typing rules 
types simpler longer want support arbitrary rank types 
generalise type type scheme may constrained set constraints constraints associated type scheme stage instantiate get type set constraints apply 
types complicated precise see sections 
define type scheme type scheme type inference arbitrary rank types undecidable possible combine type inference type checking allow higher rank types lambda arguments explicit type annotation 
extend expression language annotated lambda expressions expressions expression ctd 
annotated abstraction local definition modify type language allow type schemes domain arrow type 
follow allow type schemes codomain type type variable int arrow type functions constant type typing derivations structure says type environment uniqueness attribute see sect 
provided constraints satisfied environments map variable names type schemes 
full typing rules listed fig 
explain separately 
variables type environment associates variable names type schemes types find type variable lookup associated type scheme environment instantiate 
instantiation defined inst sx inst int inst inst gen gen subs freevars freevars gen inst sx freevars subs sx subs subs subs subs subs fig 
uniqueness typing rules int var var abs app gen inst subs subs subs sx substitution 
mapping variables fresh variables 
associate set constraints type scheme type sx instance type scheme constraints satisfied 
abstraction rule abstraction remains unchanged fact domain arrow operator type scheme 
infer rank types type scheme annotated lambda expressions degenerate type scheme quantified variables words type application rule application look slightly different rank version 
previously app required type actual parameter equal type formal parameter function app rank case requirement type actual parameter instance type formal parameter 
infer type scheme actual parameter subsumption check gen subs app explain subsumption separately section infer type scheme infer type generalise free variables type excluding free variables environment freevars freevars gen annotated lambda abstractions gen rule annotated lambda abstractions similar rule ordinary lambda abstractions programmer specify type scheme manually allowing higher rank types arrow overloaded arrow arrow 
notion types arrows type careful defining 
obvious answer correct universally quantified 
example consider uf ua uf ua 
note rank type 
question constraint question mark 
possible solution equivalent saying ua ua avoid unnecessary complication introducing universal quantification constraint language define subsumption rules subsumption defined nearly exactly collapsed rules spec rule subs added additional premise 
subs main rule checks type scheme generic instance freevars subs sx subs subs constraint new probably best explained example 
suppose functions types uf ua uf ua 
application type check 
intuitively expects able function passed obtain uniqueness say unique independent uniqueness promises return unique unique 
application disallowed 
conversely define uf ua uf ua 
application allowed type general type expected condition symbol logical entailment propositional logic says constraints satisfied constraints satisfied words constraints offered type restrictive constraints requested type 
examples section consider example expressions associated types 
start simple expressions slowly build 
consider single integer int rule int says integers type int arbitrary uniqueness universally quantified consider identity function id uf ua uf ua type may look bit complicated really show top level attributes degenerate type schemes 
slightly formal uf ua way type expect identity function 
note function polymorphic constraints argument argument type constraints result type set constraints satisfied 
haskell behaves identity function restricted function types uf ua uf ua uf ua ua ua ua uf uf ua type apply self explanatory exception constraints 
consider constraint turn constraint variable apply unification entailment check 
type ua constraints satisfied type constraints satisfied cf 
constraint type id ua ua executed words unique application ua unique executed 
ua uf unique executed direct consequence currying rule sect 

uf ua apply unique application require fact unique 
example emphasises point respect sharing analysis marking variable uses 
suppose primitive type array functions resize destructively resize array size return current size array uf resize array int ua uf uf size array int ua array expression correctly marked type correct arr size arr resize arr resize arr expression marked correctly branches conditional executed non unique mark arr condition guarantees condition modify arr 
conclude section consider examples contain type error cases detected subsumption check different reasons 
example simple case argument polymorphic uf idf ua int id example idf demands argument polymorphic fact works unique integers 
type checker give error message similar unify rigid attribute second wrong example consider fails due entailment check explained section uf ua uf ua function returns arguments delegates task function passed 
function passed type uf ua uf ua ua type specified argument allow constraint ua type checker fail entail ua type inference written prototype implementation type system 
typing rules fig 
allow relatively straightforward translation algorithm style type checker prototype just lines long subtleties observed 
doing unification unification goal expanded subgoals 
words base types uniqueness attributes unified independently 
unification unify functions far unification concerned compare type schemes need subsumption obviously give different answers subs subs 
implemented properly time need unification subsumption rules taken care arrows implement subsumption check technique suggested peyton jones skolem constants modification introduce skolem constants uniqueness attributes rigid attributes type error sect 

logical entailment sets constraints implemented validity check propositional logic formula operator regarded implication complexity additional polymorphic constraint variables types leaving conciseness 
due distinction functions functions unification deal arrows arrow type unnecessary approach 
checking validity functions propositional logic exponential matter practice formulae generated type checker small 
see sect 
simple algorithm 
generalising type respect set constraints set checked inconsistencies reported type errors 
readability types useful take transitive closure add relevant inequalities type scheme rule abs generate unnecessary constraints body abstraction demonstrated example sect 

comparison clean uniqueness type system uniqueness type system functional programming language clean turn strongly related substructural logics see accessible :10.1.1.36.3338:10.1.1.49.4346
number important differences 
obvious difference clean system defined graph rewrite rules lambda calculus gives type system different feel 
important difference treatment curried functions 
clean function partially applied unique argument unique 
unique functions necessarily unique lose uniqueness 
curry example sect 
curried causing curried marked 
type correction rule var trivial operation system check variable fact represents function reject program 
solve curried function problem far reaching consequences type system 
consequence type variables allowed lose uniqueness type variable instantiated function type 
example clean function type type assigned clean restrictive due clean subtyping relation unique type considered subtype nonunique counterpart 
example correct clean program int start start assigned type int int 
course subtyping relation adapted arrows iff things note definition 
unique function subtype non unique version condition functions allowed lose uniqueness similar restriction applies type variables 
second thing note subtyping contravariant function argument 
surprising complicates type system especially presence algebraic data types 
discussed algebraic data types see sect 
easy add system 
algebraic data constructors include arrows example data fun fun means arguments constructors analysed check covariant contravariant invariant subtyping behaviour 
contrast system notion necessarily unique add single additional attribute explained condition curried functions executed local constraint rule function application 
global effects example type variables unaffected need subtyping point worth emphasising 
subtyping relation clean shallow 
advantage subtyping pass unique object function expects non unique object 
clean marking formal parameter non unique really means care uniqueness parameter 
system attribute variable mean thing 
possible clean type variables allowed lose uniqueness type assign function illegal clean 
subtyping functions require arguments unique non unique indicate uniqueness input matter 
clean possible require arguments unique uniqueness attribute matter due subtyping 
experience tell extra functionality useful 
sect 
uniqueness type inference states treatment higher order functions involving restricting subtype relation variables case lifting general solution fails specific instance attributable 
principal uniqueness type theorem 
argue subsumption introduces subtyping type schemes due predicative nature type system effect algebraic data type arguments see discussion sect 

formal proof authors hope system principal types 
original motivation fact clean uniqueness system allow arbitrary rank types 
additional benefit allowing type schemes domain arrows necessary support higher rank types fact associating uniqueness inequalities constraints types 
example clean function apply sect 
type function type clean type checker assigns type type quite reasonable fact similar type assign 
contain constraints appear type apply suggests type apply assigned clean typechecker incomplete 
type assign apply explicit propagation constraints leaving attributes arrows designed uniqueness type system lambda calculus add side effects pure functional language losing referential transparency 
type system type system functional programming language clean modifies number ways 
defined lambda calculus graph rewrite system 
second treatment curried functions completely different type system simpler particular need subtyping anymore 
system supports arbitrary rank types careful associating constraints types 
system deals core lambda calculus extensions deal algebraic data types recursive definitions straightforward 
recursive definitions type corrected non unique approach taken letrec expressions 
main principle dealing algebraic data types unique object extracted enclosing container enclosing container turn unique slightly permissive definition clean 
need define semantics small core language show number standard properties type system respect semantics particular subject reduction 
prove system principal types 
appropriate semantics explicit representation sharing example launchbury natural semantics lazy evaluation graph rewriting semantics prove type system fact guarantee object unique type 
inference algorithm described briefly sect 
algorithm inherits associated problems particular unhelpful error messages 
planning investigate feasibility approaches constraint algorithm proposed looks promising 
formalisation constraint language precise precise definition difficult give 
constraints considerably complicate type system types assigned terms 
currently investigating possible remove constraints altogether replacing inequalities constraints equalities 
type system restrictive type system simpler 
remains seen trade simplicity generality desirable 
explanation rule abstractions abs sect 
mentioned method constraining conservative 
example constraint ua uf ua uf ua ua necessary referenced may possible relax rules conservative 
affect established change type language 
original motivation wanting extend clean uniqueness system arbitrary rank fact generic programming frequently generates higher rank types 
plan extend prototype implementation system support generics ultimate goal proving function defined generically type correct respect generic uniqueness type system functions derived generic function type correct 
give experience type system may give insights extra power uniqueness system gives clean system see sect 
useful practice 
wish john gilbert wendy smetsers comments various drafts 

barendsen smetsers conventional uniqueness typing graph rewrite systems 
technical report csi university nijmegen 
odersky ufer putting type annotations 
popl proceedings rd acm sigplan sigact symposium principles programming languages new york ny usa acm press 
peyton jones shields practical type inference arbitrary rank types 
consideration publication functional programming 
damas milner principal type schemes functional programs 
popl proceedings th acm sigplan sigact symposium principles programming languages new york ny usa acm press 
huth ryan logic computer science modelling reasoning systems 
cambridge university press new york ny usa 
barendsen smetsers uniqueness typing functional languages graph rewriting semantics 
mathematical structures computer science 
wadler taste linear logic 
mfcs proceedings th international symposium mathematical foundations computer science london uk springer verlag 
launchbury natural semantics lazy evaluation 
popl proceedings th acm sigplan sigact symposium principles programming languages new york ny usa acm press 
hage swierstra generalizing hindley milner type inference algorithms 
technical report uu cs institute information computing science university utrecht netherlands 
plasmeijer generic programming extension clean 
ifl selected papers th international workshop implementation functional languages london uk springer verlag 
