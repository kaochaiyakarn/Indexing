describes gburg generates tiny fast code generators finite state machine pattern matching 
code generators translate postfix intermediate code machine instructions pass course backpatching ad dresses 
stack virtual machine known lean virtual machine lvm tuned fast code generation described 
gburg translates page lvm specification code generator fits entirely kb cache emits code mb set mhz 
just time code generator translates executes small benchmarks speeds factor executables derived conventional compile time code generator 
execute virtual machine vm code client processor typically requires vm interpreter just time jit translator 
conventional wis dom dictates space time tradeoff favors interpreter approach space scarce interpreters small simple favors presumably larger jit translators speed important size simplicity 
interpreters typi cally give factor execution speed com pared jit translated code 
describe tiny fast simple code generators microsoft research microsoft way redmond wa 
email microsoft com 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advan tage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigplan atlanta ga usa acm finite state code generation christopher fraser todd proebsting microsoft research produce native code speed including jit trans lation typical compiler generated code 
factor compared conventional compile time code generator system 
code generator fits kb generates code mb set technology represents desirable alter native interpretation extremely memory limited machines cellular phones personal dig assistants 
furthermore system gener ates code generators concise machine spec greatly simplifies retargeting 
pattern matching code generators map patterns intermediate representation ir operators equiva lent target instructions 
tree pattern matching code generators target machine instruction costs guide selection cost opti mal mappings dynamic programming re quire tree walk passes bottom pass dynamic programming top pass selecting cost match 
systems gee ir rewriting technology heuristically search better target instructions emit 
techniques excellent job instruction selection new applications code generators load time translation mobile code embedded computers fly code generators interpreters emulators program specializers benefit alterna tives smaller faster 
explores spectrum code generation technology code genera tor size speed important code qual ity 
extreme spectrum macro expanding code generator reads ir instruc tion immediately emits appropriate target instructions 
approach simple fast misses opportunities emit efficient target multiple ir operations 
instance macro expansion add followed load exploit target machine addressing modes 
systematically studied costs pre vious pattern matching schemes eliminated inefficiency possible able generate local code 
system gburg au generates code generators underly ing pattern matching technology common finite state machine 
simplicity results small simple efficient code generators able generate complex target instructions 
gburg reads tree grammars automatically generates code generators 
gburg oper ate trees linearized postfix nota tion stack code 
furthermore code gener require pass buffer ing stack code select instructions 
pass matchers greedy pattern matching guarantee cost matches 
emitted assembly language examined code quality suitable purposes fast code generation important 
gburg handle arbitrary tree grammars processes grammars equivalent descriptive power regular expressions allows gburg generate simple finite state machine pattern match ers 
designed new lean virtual machine lvm intermediate representation 
lvm instruction set design helps gburg generate code quickly 
page lvm code generator specifi cation generates code generator fits entirely kb 
run mhz code generator capable generating code mb set 
background generating fast code generators machine specifi cations new gg fhp fhp agt pw 
graham code generators parse pre fix tree ir identify large instructions ad dressing modes simpler ir operators 
graham code generators suffer left bias translating binary operators 
prefix code binary operator right operand arbi instructions away operator left operand separates 
graham code generator defer parsing deci sions arbitrarily far lr pars ing technology code gen eration decisions left operand prior know ing sibling right operand 
having decisions complete information lead sub optimal code 
gburg suffers similar left bias matches postfix notation design lvm instruction set compensates problem 
engler vcode system represents vm instruc tion set code generation technology efficient dynamic code generation eng 
vcode includes complex instructions anticipate modern architectures terms addressing modes means macro expansion vcode target code addressing modes 
gburg code generators vcode code generators generated specifications extremely efficient vcode relies entirely design instruction set allow macro expansion rea code 
system distribution safely executable mobile programs 
relies machine independent vm code efficiently translated native code macro expansion 
vcode instruction set design anticipates target machine instruction sets including complex addressing modes 
free software foundation gcc compiler uses general tuple rewriting system instruction selection 
po system rewriting reg transfer language developed davidson fraser system extremely flexible powerful known speed df df 
tree pattern matching technologies combined dynamic programming yield efficient optimal local code generation tree irs 
previous tree pattern matching schemes dynamic pro gramming combined sophisticated matching gorithms plg pro produce cost tree matches time proportional size input tree 
problem np complete dag irs 
dynamic programming systems re quire passes ir pass annotates tree dynamic programming information second pass selects optimal match 
gen erating provably optimal code trees code generators cost passes ir 
furthermore second pass requires top tree walk ir implies format com plex simple postfix stack code 
gburg pass pattern match trades optimality instruction selection speed 
gburg wburg generates pass tree pattern matchers machine specifications pw 
wburg matchers burg generated automata means relatively large pro 
furthermore wburg matchers oper ate pass buffering small fixed size stack previously seen operations deferred matches overhead stripped gburg matchers 
typically tree pattern matching code generators automatically generated concise machine specifications map ir patterns target machine instructions 
code generators differ pattern matching algorithms disambiguation techniques dynamic programming greedy selec tion specifications quite similar 
grammars consist cost augmented tree rewriting rules associate patterns nonterminals derive actions code generator execute rule chosen 
sample grammar ap pears 
nonterminals appear left hand side rules 
terminals ir language operators 
base rules clude terminal symbol right hand side rules 
chain rules simply derive nonterminal 
costs appear parentheses 
lean virtual machine bases ir examples lean virtual machine lvm developing cle research code generation compression 
lvm simple stack machine designed enable things efficient translation target machine code 
lvm lean sense instruction set eliminates redundant op erations 
instance addressing mode lvm indirect loads stores find target addresses evaluation stack 
lvm includes primitive operations accessing literal values pushes compile time constant stack pushes link time constant stack 
operations come different sizes types course 
stack lvm includes registers 
convention lvm registers may may map specific hardware registers 
lvm instruction set include assume particular source languages calling conventions object models 
instance lvm include instructions pass ing arguments checking types entering monitors operations built prim itive lvm operations 
including necessary primitive operations map operations particular target machine avoiding hard wiring particular language bias lvm function universal target source lan guages 
lvm borrows heavily icc ir fh 
large icc trees postfix specific operators expanded primitive opera tors operators renamed somewhat self explanatory new incarnation struction names 
greedy pattern matching code generator generator gburg greedy bottom rewrite generator generates tiny extremely fast code generators tree pattern matching way mapping postfix instructions target machine instructions 
gburg dy namic programming unrestricted tree matching simpler faster scheme matches patterns greedily restricted tree pattern grammar 
fortunately quality generated code suffers little code generation speed size im prove dramatically 
gburg traverse trees reads postfix representation 
grammar compare gburg schemes 
con sider lvm code represents simple load 
addu loadu simple risc target map cleanly load instruction load rx 
dynamic programming system find legal parses tree choose expensive grammar load rx 
code generator responsible assigning register implicit temporary rx 
problems pass system example 
translating lvm instruction oses subtle choice 
rule matches produces reg nonterminal obvious chain rules 
general impossible know chain rules applied subsequent operators inspected precisely reason dynamic programming tems require passes 
sys ahead finding instruction help 
examination grammar reveals operands left children reg nonterminals code generator knows apply necessary chain rules reduce left child nonterminal reg case rules 
note ahead revealed loadu instruction addr reg chain rule applied get necessary addr nonterminal 
cnsti ni emit reg cnsti emit reg ni emit reg loadu addr emit load reg addu reg reg emit addi addr addu reg cnsti iii emit addr reg emit addr cnsti emit chain rules applied reduc ing 
re duced cnsti addr reg 
unfortunately answered looking just instruc tion ahead 
required nonterminal depends addu rule depends instruction instruction uses computation 
general bound far ahead pattern matcher need look determine best rule apply 
avoid looking arbitrarily far ahead gburg generated pattern matchers greedily match base rules defer applying chain rules instruction examined 
example means reduced cnsti base rule 
tering addu pattern matcher attempt apply addu rule turn matched possible assistance chain rules encountered operand rule 
reg addu reg reg forcing application chain rule promote reg 
addu reg turn promoted addr matcher hit loadu instruction 
note impossible greedy scheme addr addu reg cnsti rule directly creates addressing mode 
follows cause cnsti converted reg anytime second addu rule applica ble 
gburg input grammars concept costs means necessary overcome deficiency 
fortunately come rewriting grammar rules reversed 
unfortunately grammars require deferring chain rules instruction 
adding rule root addr reg intro duces problem 
addr operand binary operator rules reg nonterminals left operand sible know chain rules applied sample grammar nonterminal left operand knowing parent operator 
rule causes left bias problem 
deferring decisions effectively require second pass input 
fortunately simple way problem change instruction ir take target address right child 
risc targets sparc eliminates left bias translation 
definition solve re lated code generation problem 
possible store immediate value target location specified complex addressing mode 
generating instruction requires rule root imm addr matched simple pass matcher gburg code load constant register stor ing memory 
code generator generator machine specifications gburg line icon program gg simple analysis input grammar produce code generator kr 
input consists parts token declarations specification includes declarations operators grammar including external encoding 
encodings fit bits 
constructive grammar specification cludes grammar describes legal tree derivations 
gburg eliminates case analy sis pattern matcher constructive grammar constrained ma chine specification grammar 
constructive grammar declares bytes immediate value follow operator instruction stream 
constructive grammar root int int root float int int int int int int int float float float float float float int float int loadu int float int machine specification grammar root reg addr printf root reg addr root reg addr printf root reg addr reg addu reg cnsti printf reg addu reg cnsti reg addu reg reg printf reg reg reg reg reg cnsti printf reg reg cnsti reg reg reg reg reg reg reg subf reg reg cnsti reg loadu addr reg addr reg reg cnsti addr addr cnsti code printf reg reg reg printf reg reg reg printf reg subf reg reg printf cnsti printf printf reg loadu addr printf reg addr printf reg printf reg cnsti printf addr reg printf addr cnsti machine grammar specification includes parsing rules annotated actions encoded 
rule includes left hand side pattern action 
rules take possible forms chain rule nonterminal pattern base rule tree pattern terminal operator nonterminals children 
matcher executes action selects rule 
auxiliary routines specification includes arbitrary code compiles links generated matcher 
gburg emits single function compile takes argument array postfix code matched 
contains sample grammar simply echo derivation sequence 
sample specification generating matchers gburg matchers read stack input perform actions operator 
forming appropriate action associated operator may necessary apply chain rule ac tions preceding nonterminal enable match 
allow pass matcher chain rules ap plied nonterminal produced immediately preceding operator 
instance preceding op erator produced reg operator rule addr reg applied applying loadu rule 
note subtle asym exists chain rules applied nonterminal generated preceding operator base rules applied current operator 
discussed matchers apply chain rules nonterminals generated preceding operator 
unary binary op erator encountered simple determine chain rule apply chain rules necessary get appropriate nonterminal ma 
base rule exists operator rule applied requires application chain rules 
greedy matcher 
nullary operator leaf operator tree encountered chain rules ap plied previous nonterminal exists 
determined analysis grammar 
grammar nullary operators cause appli cation chain rules derive reg nonterminal 
gburg determines trivially noting left child nonterminals grammar regs matches match reg 
follows observation stack ma chine values top stack consumed binary operators 
gburg allows nonterminal appear left child various binary operators gburg analysis prove conservative analysis presents ambiguity match 
conservative analysis trivial 
deter mine rules operator nonterminal left child 
impossible pick rule solely right child 
check nonterminal derived distinct left child nonterminals chain rules 
impossible determine chain rules apply original nonterminal pushing stack finite state machine immediately preceding nonterminal affect pattern matching process nonterminal needs remembered matches 
pattern matching determined single non current operator 
course defines simple finite state machine nonterminal state current operator input symbol 
state corresponds machine specification grammar 
fore machine grammar states root reg cnsti addr 
necessary realize state machine code mechanism performing appropri ate actions associated grammar rules mak ing appropriate state transitions 
note transition zero chain rules applied preceding nonterminal state nd ex base rule applied 
determining rules applied nonterminal operator pair easy 
gburg determines base rule apply greed ily trying order allowing chain rules necessary match 
gburg greedy respect base rules chain rules 
alternative sequences chain rules conversion gburg choose shortest breaking ties arbitrarily 
analysis emitting pattern matcher easy opportunities optimization 
schemes hard coded matcher interpretive table driven matcher 
hard coded matchers generate avoid explicit storage nonterminal encoding program pc 
recursive descent parser encoding current execution particular procedure 
switch statement nonterminal translates code handling operator reduction nonterminal 
switch statement choose actions possible operators 
application rule causes ex ecution associated action transfer code corresponding left hand side rule state transition 
applying base rule ad operator 
lvm includes program operator action returns matching procedure 
grammar abbreviated translations reg addr non terminals appear 
code simple improved 
com identical case arms decrease size 
instance addr switch statement ma de smaller case arm addu 
operator propagation ck previous scheme operator may flow switch statements fact execute switch statement rule chain base forces 
inefficiency easy eliminate exploiting fact switch statement known exactly case arm subsequent switch statements executed 
simple transfer control switch statement directly appro priate case arm switch statement 
state reg operator loadu case applying chain rule addr reg rule reg loadu addr applied jumped directly 
optimized way switch statements appear 
reg switch operator case addu printf reg addu reg reg operator pc goto reg case printf reg reg operator pc goto reg case loadu printf addr reg goto addr 
default error handling code addr switch operator case addu printf reg addr got reg case subm printf reg addr got reg case loadu printf reg loadu addr operator pc goto reg 
default error handling code simple state machine addr switch operator case addu share chain rule case printf reg addr got reg case loadu printf reg loadu addr operator pc goto reg 
default error handling code optimization base rules transfer control switch statement 
chain rules contain actions optimization introduces branch chains fortunately compilers able eliminate 
unfortunately previously de scribed case arm sharing disappears 
chain rule inlining possible take previous optimization step eliminate intermediate control transfers altogether 
inlining possibly locations chain rules possible guarantee ex control transfer operator regardless number applied chain rules 
inlining code transformed code downside transformation course code bloat 
compiler doing cross jumping optimization re introduce eliminated jumps decrease bloat 
code sharing equivalence classes gburg supports crude macro facility hat en ables optimization 
gburg specifications group operators identical rule ac tion templates 
instance nearly identical grammar gburg supports grammar specification form 
reg reg reg printf shorthand writing rules operators 
shorthand operators equivalence class left hand side macro defi nitions shorthand right hand side definition 
gburg restricts right hand side macro definitions integers stored table indexed operator left hand side 
macros specifications concise provide gburg optimization reg switch operator reg addu case addu reg printf reg addu reg reg operator pc goto reg case reg loadu printf reg subm reg reg operator pc goto reg case loadu 
printf addr reg goto addr loadu default error handling code addr switch operator addr addu case addu printf reg add goto reg addu addr case printf reg add goto reg addr case loadu printf reg addr operator pc goto reg 
default error handling code propagation reg switch operator case printf reg addu reg reg operator pc goto reg case printf reg reg reg operator pc got reg case loadu printf addr reg note rules applied printf reg loadu addr operator pc got reg 
default error handling code addr switch operator case addu printf reg add note rules applied printf reg addu reg reg operator pc goto reg case printf reg addr note rules applied printf reg reg reg operator pc goto reg case loadu printf reg loadu addr operator pc got reg default error handling code inlining opportunity 
gburg create matchers oper ate operator equivalence classes indi vidual operators 
equivalence class case arm operator 
course requires associated rules parameterized macro substitutions 
extra level direction equivalence classes provide simple tech nique decreasing size specification nd matcher 
lvm design development gburg influenced lvm instruc tion set design choices 
lvm instruction set avoids possible left bias yield inferior code quality 
left children binary operators create ambiguity translation machine code target machines 
note left bias relative particular target machine 
designing lvm avoid left bias ex current machines nd try anticipate machines 
commutative operators addu provide challenge 
machine provides add immediate instruction symmetric rules 
reg addu cnsti reg reg addu reg cnsti rules introduce left bias problem matcher know promoted reg left operand 
solve problem second rule rely lvm generator produce lvm code canonical form literal values right children commutative operators 
noted previously poses potential left bias 
target machines sort ad dressing mode complex simple indi rect 
addressing modes imply machine specifica tion nonterminal addressing mode computa tion addr 
target machines store values registers potential left bias prob lem avoided designing lvm instruction take target address right operand 
grammar rule root reg addr left bias assuming reg left operand cause bias 
takes care common case architectures 
slightly difficult situation occurs interaction relational operators nd condi tional jumps 
relational operators produce logical value conditional jumps require logical value jump target 
original design relational operators producing integer value logical created left bias matcher literal target address came gener ated register conditional came value computed register 
course machines condi tional jumps constant targets 
solution conditional operators produce logical values require explicit operation convert value 
requires lvm instructions express value producing conditional expressions expressions rare 
restrict legal lvm code number ways fa fast code generation 
instance require programs sequence completely formed trees postfix notation ing complications tree pattern matcher process incompletely formed trees directed acyclic graphs dags th restriction means eval uation stack empty start tree start ba sic block 
restriction eliminates need sort control flow analysis determine stack configurations branch targets 
contrast restrictive rule java vm ly 
impossible create directed acyclic graph dag lvm code lvm struction set include dup instruction create value 
restricting lvm trees eliminates need ing complicated algorithms doing pattern matching dags problem known complicated 
furthermore lvm include swap instruction ble expression code instance create second operand operand binary operator 
restriction enables lvm design avoid possible left bias pass pattern match 
legal lvm code type consistent 
instance legal integer add instruc tion ting point numbers 
weaker restriction java verifiability re typing primitive level integers floats memory com pletely untyped 
evaluation stack typed 
lvm code type consistent code gen erator spared costly checks 
experimental results code generator generator code generator size speed read lvm emit kb mb set 
mb set 
gburg burg iburg table code generator sizes pattern matching speeds translation system perm sec 
sec 
sec 
sec 
sec 
gburg icc timing ratios perm queens towers gburg lcc gburg gburg gburg generated code generators tiny produce code quickly 
complete code gen erator small kb code data generate code mb set mhz machine 
machine specification complete includes rules fit gburg constraints abbreviated reduce size 
experiments ansi compiler icc generates lvm code fh 
code generator size speed tests compare tree pattern matching code generators created gburg iburg burg 
iburg burg pass systems rely tree pattern match ing dynamic programming select instructions differ burg dynamic programming compile compile time iburg com pile time 
iburg burg tuned speed 
table compares sizes speeds code generators generated base grammars 
systems compiled microsoft visual maximum speed optimizations en 
timings done mhz translating kb lvm code machine code times 
code generator sizes include ini text data attributable code gener table small benchmark timings executions 
test conjecture gburg code genera tors compile execute programs faster typical interpreters compiled run programs stanford benchmark suite programs comparable size small applets 
table compares run times different lation strategies microsoft visual maximum optimization microsoft visual default options lee gburg generated lvm translator 
compiler systems generate stand applica tions execute individual test times 
gburg system reads lvm code file translates native code executes times 
please note translates lvm code iteration translation cost amortized runs 
icc generated lvm means gburg vs icc closest apples apples comparison 
compared highly optimizing compiler charged compilation time gburg generated compile execution times twice fast expected slowdown interpretation 
furthermore compared native programs derived source icc lvm code slowdowns remarkable factor 
code generators fit entirely kb suitable re placements interpreters space limited devices 
agt df df en fh fhp alfred aho ganapathi steven tjiang 
code genera tion tree matching dynamic programming 
cm transactions programming languages systems october 
ali reza adl tabatabai geoff lang dale steven lucco robert wahbe 
efficient language independent mo bile programs 
proceedings sigplan conference program ming language design implementa tion pages 
jack davidson christopher fraser 
design application retargetable peephole optimizer 
cm transactions programming languages systems april 
jack davidson christopher fraser 
code selection object code optimization 
acm transactions programming languages sys tems october 
engler 
vcode retargetable extensible fast dynamic code gen eration system 
proceedings sigplan conference program ming language design implementa tion pages may 
christopher fraser david hanson 
retargetable compiler design implementation 
ben jamin cummings redwood city cal 
christopher fraser david han son todd proebsting 
engi neering simple efficient code generator generator 
acm letters program ming languages systems september 
christopher fraser robert henry todd proebsting 
burg gg gg ho kr ly plg pro pw fast optimal instruction selection tree parsing 
sigplan notices april 
steven susan gra ham 
new method compiler code generation 
proceedings th symposium principles pro gramming languages pages 
ralph griswold gris wold 
icon programming language 
prentice hall 
isbn 
christoph hoffmann michael donnell 
pattern matching trees 
journal acm jan 
brian kernighan dennis ritchie 
programming language 
prentice hall second edition 
isbn 
tim lindholm frank yellin 
java virtual machine specification 
addison wesley 
isbn 
eduardo susan graham 
optimal code generation expression trees application burs theory 
proceedings th annual symposium principles programming languages pages new york 
acm 
todd proebsting 
burs automata generation 
acm transactions programming languages systems may 
todd proebsting benjamin whaley 
pass optimal tree parsing trees 
inter national conference compiler con struction pages april 
