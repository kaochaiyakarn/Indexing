study allocation behavior specjvm java benchmarks sylvia urs lzle department computer science university california santa barbara ca urs cs ucsb edu 
analysis memory usage java programs specjvm benchmark suite 
programs realworld applications high demands memory system 
program measured low level data possible including age size distribution type distribution overhead object alignment 
things non pointer data usually represents allocated space instance objects java objects tend live longer objects smalltalk ml fairly small 
java brought garbage collection mainstream truly popular language tradition requires garbage collection gc 
java differs respects languages requiring gc smalltalk ml lisp gc behavior java programs may differ programs written languages 
understand gc performance system study allocation behavior targeted applications 
gc implementation leaves room knobs impact performance tuning difficult right settings depend characteristics executed program depends greatly language features implementation style 
better identify optimize garbage collectors implementors need detailed empirical information allocation behavior applications 
reason published studies analyze allocation behavior context languages including smalltalk sml nj lisp ung sm hmn hh zor zg 
depth analysis java programs published date part lack standardized benchmark suite 
depth analysis memory usage realistic java programs 
study programs specjvm benchmark suite released system performance evaluation spec 
programs real world applications high demands memory system 
program measure low level data practical 
test generational hypothesis measure age distributions 
allow implementors judge impact segregating objects type size analyze heap composition identify object groups free instance objects benefit special treatment 
determine impact byte object alignment simulate rachid guerraoui ed ecoop lncs pp 

springer verlag berlin heidelberg effects 
system different possible gc variants generally refrain making recommendations data 
objective provide gc community detailed data allows researchers predict impact gc implementation decisions java applications 
remainder organized follows 
section discusses related previous studies allocation behavior section describes benchmarks 
section presents experimental setup 
section discuss results including observations object lifetimes density heap composition 
section compares numbers reported languages possible section summarizes results 
related study allocation behavior implementing language garbage collection essential understand expected allocation behavior 
allocation patterns depend executed applications generally language characteristics researchers studied question independently programming languages 
earlier papers focus lifetime survival rates order estimate overhead generational gc 
basic characteristics gc understood researchers interested segregation approaches special allocation strategies 
ungar example implemented generation scavenging ung berkeley smalltalk bs analyzed dependencies survival rate nursery size smalltalk wil 
baker suggested theoretical models explain allocation behavior bak bak 
hayes analyzed survival rates long lived objects cedar modula language objects survive certain age tend die clusters hay 
zorn statistical numbers large lisp applications analyzed object level runtime system simulator zor 
studies including zorn memory counts metric object lifetimes 
zorn studied large programs context lifetime prediction memory allocation bz zs gjs zg zg 
moss analyze allocation behavior sml nj sm 
gon alves discusses object age distribution study cache performance gon 
discuss studies section 
nettles developed oscar language independent gc testbed analyze object allocation behavior 
simulator oscar trace heap activity records frequent heap snapshots 
hicks oscar analyze sml nj java applications hmn hh focus execution time 
studies java focus depth allocation behavior study 
best knowledge analysis specjvm benchmark suite published 
benchmarks measurements programs specjvm benchmark suite spec released august system performance evaluation spec 
spec nonprofit organization hardware vendors objective establish standardized set vendor neutral relevant benchmarks applicable newest generation high performance computers 
popular spec benchmarks measure various system aspects cpu nfs web server performance 
specjvm shipped set java class files intended measure efficiency java virtual machine jvm implementations combination jit compiler runtime system os hardware platform 
individual programs chosen spec member companies criteria including high bytecode content flat execution profile tiny loops repeatability heap usage allocation rate cache cache misses platform 
tests represent real applications integer floating point computation library calls awt window networking graphics covered suite 
result spec benchmarks execute little native code java system classes program contains application specific native code 
programs mtrt single threaded 
specjvm consists different programs see table computing performance score check validates correctness vm 
test contribute result executed correctly order obtain valid score omit numbers 
exclude mpegaudio barely allocates data 
benchmarks spec provides different inputs referred problem size 
input names may suggest specjvm scale linearly input size run th space th time 
largest input may publish benchmark results runs input mentioned 
programs compress jack javac iterate multiple times input explains repetitive shape graphs example see 
order produce valid results spec requires user run applications harness sets environment times experiment 
study harness start programs add constant small amount long lived data results 
program descriptions describe analyzed programs detail 
compress implements file compression 
performs iterations set tar files mbytes mbytes large 
file read compressed result written memory read uncompressed new file size checked 
cycle compress allocates large byte arrays input output allocates heap objects 
result live profile compress program description class file size kbytes table 
specjvm programs total size class files delivered part actual application 
numbers include harness code jvm system classes 
numbers simulation exclude space consumed alignment handle space extra header words see section details 
specjvm documentation reports significantly higher numbers verified real jvm implementations sun jdk closely correlate numbers 
run time spec machine mhz ibm powerpc running interpreter 
looks somewhat odd continuous curve shows vertical bars plot large object allocations single data points followed gap length corresponds age object 
compress long sequence small allocation requests continuous curve form 
section discusses treatment large objects detail 
believe compress typical representative objectoriented application drop suite assume java applications style compress exist 
exclude summarizing statements doesn conform general trend 
db program study derived real world application 
simulates simple database management system file persistent records list transactions inputs 
task build database parsing records file apply transactions set 
accordingly db distinct live heap profile heap size grows linearly building database stays fixed level entire time execution transactions 
max 
live heap mbytes total allocation mbytes time sec heap loads loads heap stores check test jdk java features compress db jack javac utility compress uncompress large files lempel ziv method passes input small data management program performs db functions memory resident database parser generator lexical analysis early version javacc passes input jdk java compiler compiling lines code study allocation behavior stores jess java expert system shell nasa clips expert system mpegaudio mpeg audio stream decoder 
mtrt dual threaded raytracer jack commercial application parser generator shipped source code 
traces know jack performs iterations building live heap structure collapsing 
spec documentation repeatedly generates parser input 
data survives iterations jack run fairly small live heap 
javac jdk java compiler iterating times lines java code source code jess serves input javac 
jess expert system reads list facts word games input file attempts solve 
run computationally intensive allocates lot memory jess store temporary results prolonged time 
live heap stays relatively constant level entire run application new objects allocated continuously 
mtrt picture dividing input data sections starting new working thread section 
multithreaded application suite 
unfortunately largest problem size currently create threads 
addition threads yield voluntarily means tracer jdk cooperative thread model executes sequentially hol 
hesitate consider mtrt truly multithreaded program 
experimental setup experimental setup consists independent phases 
instrumented version sun jdk vm produces trace file executing benchmark application 
second phase simulator written java reads trace simulates allocation pointer assignments garbage collections computing statistics shown rest 
sections describe components 
specjvm spec output tracer jdk tracing trace file zombies java stack heap simulator 
experimental setup thread locality age distribution live heap size tracer modified sun jdk vm log runtime information interest 
recorded events include object creation updates heap stack operand stack call back 
thread dat age dat live dat study allocation behavior method invocation 
reduce trace size record updates non variables 
despite restriction reasonably space efficient encoding trace events subsequent compression gnu gzip trace lengths range gigabytes 
traces benchmarks comprise gigabytes data 
object creation tracer records class bytes allocated arrays object id jdk relocate heap objects handle addresses real addresses identification 
jdk vm assigns handle heap object support heap compaction 
handle forwarding pointer object handle referring object directly 
vm decides relocate object updates forwarding pointer opposed object 
consequently handle address changes lifetime object ideal object identifier 
recorded heap stores object creation data sufficient reconstruct heap structures complete object allocation history trace 
trace contains method invocation return events operands bytecode affects pointers stack operand stack trace records allow simulator reconstruct pointers stack 
currently ignore pointer stores code jdk vm contains places directly manipulate java objects going jni interface 
order determine impact simplification compensate simulator trace file augments events expected value result simulator able deduce current state 
example pointer loads record address location value loaded 
reason trace records handles objects freed jdk vm interested dependent jvm gc algorithm 
fortunately omitting stores native code negligible impact results discuss exact impact detail section 
simulator second component experimental setup consists heap simulator written java 
simulator reads interprets trace file reconstruct heap stack activity performs garbage collection fixed intervals determine object lifetimes 
java object allocated application simulator creates instance hold pointer fields application object capture variety gc relevant information provide additional space temporary counters markers 
simulating heap activity application simulator gathers variety statistics 
experiments coded independent units creates partially redundant output data 
experiments event driven registering interest certain events new object free object simulator calls back events occur 
experiments distinguish live dead objects simulator performs exact garbage collections simulated heap 
currently force full collection kbytes allocation believe finer resolution improve result slow simulation significantly 
typical simulation currently takes days mhz ultrasparc workstation 
simulator determines object unreachable notifies registered statistics objects moves zombie region 
trace contain jvm code object appear dead simulated heap alive real application 
trace reports jdk gc freed zombie object simulator discards 
object live simulator discover time referenced 
case simulator object notifies statistics objects correct data 
discussed previous section trace data contains redundant information detect premature deaths recover 
total objects allocated objects corrected compress jess db javac mtrt jack table 
error due simulation table shows simulator fewer objects 
javac jack retrieve larger amount zombies objects allocated objects 
addition single object get multiple times actual error smaller shown 
error show limited segment simulation point simulator falsely collects object gets detected error jdk frees original 
believe numbers strong indication inaccuracies introduced ignoring native code minor influence results 
applications specjvm adds native code native code standard java system classes potentially cause discrepancy 
verify correctness simulator compared simulation results numbers reported tracing vm 
example ran tracer compared result simulator data order verify total allocation size 
added extra counters monitor overhead byte alignment amount memory live applications 
numbers obtained tracer agreed closely simulator 
adding experiments simulator usually implemented algorithms sure outcome identical 
example update live heap counter dynamically graphs kbyte intervals 
analysis kbyte intervals better accuracy 
significant differences kbytes kbytes 
death event 
addition periodically scan snapshot live heap determine size 
cross checked experiments consistency 
sum live bytes type numbers experiment instance correspond currently live bytes measured experiment 
sure tracer important events kept log warnings issued simulator due recovery points state inconsistencies 
object model keep study general possible consider aspects occur universally java implementations 
away effects implementation dependent fragmentation special object headers resulting object model see simple close realistic implementation 
instance class pointer field field 
study allocation behavior array class pointer length cell cell cell 

simulator object model 
class class pointer static static 
regular objects contain class pointer arbitrary number fields assume additional header words 
fields bit aligned simulator attempt pack smaller fields 
example point object integer fields consumes bytes heap space 
similarly arrays contain class pointer followed bit length field space host cell size length array elements cell size bytes depends array element type 
example integer array size char array size byte array size consume bytes 
virtually processors require bit aligned addresses impose significant penalty addresses assume objects aligned bits fractional words byte array size padded word boundary 
alignment assumptions bit alignment long double space impact alignments depends heavily allocator choices unified heaps vs size segregated allocation 
similarly reserve space element type pointer arrays type required array store checks 
vms sun jdk vm add extra word arrays 
vm store element type array class object eliminating array overhead 
arrays usually fairly large don expect issue difference way 
assume class objects class pointer space accommodate static fields ignore metadata method blocks field blocks constant pools class metadata add kbytes data jvm implementor decide stored 
example jdk allocates bytes struct heap class object points remaining metadata heap 
case total allocation programs high overhead added class objects influence results 
experimental results heap size object lifetimes shows amount live data application better readability graph right shows enlarged subsection data 
customary gc related measure time axis terms mbytes allocated 
metric popular number bytes allocated correlates directly amount allocator gc invest 
mbytes currently live compress db jack javac jess mtrt mbytes allocated peak value curve indicates minimum heap size required run program completion 
data points graphs spaced kbytes apart simulator performs garbage collection kbytes allocation 
jack example generates distinct live heap curve oscillates sixteen times mbyte peaks spaced mbytes jack allocates approximately mbytes sixteen iterations 
data dies soon little mbyte stays alive cycle point collapses remainder mbytes 
allocated object larger kbytes graphs show gap length corresponds size object just allocated 
effect especially apparent compress allocates large arrays 
compress allocates color versions graphs available www cs ucsb edu papers 
mbytes currently live compress db jack javac jess mtrt mbytes allocated 
minimal size live heap total enlarged graphs show amount bytes currently live total amount space allocated point 
example mbytes allocation live heap db slightly larger mbytes 
right graph shows enlarged portion left graph 
virtually data arrays cause curve take shape series vertical bars height bar distance right represents size allocated object 
refer section description compress 
specjvm programs allocate mbytes memory run fairly small heap mbytes runtime performance issue 
maximum live heap size established relatively early point time may important presence automatic heap expansion applications require heap expansion quarter execution 
jack javac repeatedly build large live structures collapse instantaneously phase terminates 
db jess mtrt hand maintain constant amount live data application data structure kept alive jess dying objects continuously replaced new allocations 
fraction bytes live compress db jack javac jess mtrt age mbytes allocated study allocation behavior age mbytes allocated 
age distribution total allocated total enlarged shows object age distributions 
previous axis measured mbytes allocation age distribution treat large allocation requests differently clipping kbytes 
words megabyte array garbage allocation object age kbytes mbyte 
believe clipping sense main reason gc community interested age distribution estimate success generational gc determine optimal configuration 
clipping large objects automatically look long lived fact die shortly allocation 
allocation large object uses heap space trigger equal amount gc justifying age definition presents young 
specjvm suite clipping affects compress allocates mbytes age distribution appears mbytes 
essentially allocating large byte array compress performs long allocation free computations array garbage 
array live seconds real time appears short lived garbage collector 
fraction bytes live compress db jack javac jess mtrt graphs show fraction bytes live time creation time measured allocated bytes 
curves start objects live immediately creation 
example roughly allocated bytes survive kbytes javac 
note graphs stretched different dimensions better readability clipped axis left graph axis right graph 
age distributions specjvm applications confirm weak generational hypothesis hay objects die young effect pronounced programming languages 
example moss report allocated bytes survive kbytes sml nj applications sm ungar measured smalltalk objects survive kbytes allocation ung 
contrast specjvm objects live kbytes jess lower db upper ignoring compress 
megabyte allocation allocated bytes live javac db jack 
data implies java benefit generational gc allows collect younger objects aggressively 
nursery java heap substantially larger functional languages ml smalltalk 
age distribution older objects application dependent applications show clusters objects dying roughly age leading sudden steep drops age distribution graph 
jack javac show relatively smooth age distributions 
observation consistent hayes study behavior old objects hay suggests multi generation collectors necessarily java 
may worth investigating techniques hayes key object opportunism 
instance objects vs arrays turn analyses heap composition starting distinction instance objects arrays 
garbage collector may want treat arrays specially particularly free strings 
left graph shows applications initially allocate arrays 
part objects attributed jvm initialization vm allocates kbytes byte arrays user application started 
spec benchmark harness actual benchmark setup appear perform higher ratio array allocations 
mbytes allocation applications stabilize array instance object ratio 
mtrt allocates twice instance objects arrays entire run 
right graph shows arrays fraction live objects 
trends clear easily generalize 
fraction arrays live heap varies significantly close application appears maintain fairly constant ratio entire execution 
applications show extreme spikes correlated aware decision clip large objects manner 
looked alternative approaches allocating large objects special area technique arbitrary sense unsatisfying simulation 
applications allocate objects kbytes question treat cases arises 
compress treating large objects way affects results 
compress normal application sense allocates large arrays unclear age curve application means place 
believe matter age curve compress computed aware unusual allocation behavior application 
array bytes total allocated compress db jack javac jess mtrt mbytes allocated study allocation behavior 
fraction array bytes mbytes allocated clear spikes occur instance objects die input data set 
apparently arrays live entire execution time causing variations appear disproportionately large live heap contracts sharply 
density investigate allocated space contains primitive types bytes integers 
distinguish objects instance objects vs arrays instance objects mix non fields 
object model includes class pointer object count non section 
class pointer may special cased gc implementation immutable class objects copied 
garbage collection class objects switched altogether jdk scanned 
shows applications allocate high percentage non fields startup 
programs allocate half space 
jess db allocate higher fraction ends total allocated 
programs jack javac jess generally balanced live heap non bytes 
periodic heap contractions programs applications appear irregular 
programs maintain fairly constant density live heap live space dedicated non 
data helps estimate number pointers collector scan update 
non fields easier skip particular arrays faster skip non fields scattered instance objects 
refine data separating arrays instance objects 
complements graphs show arrays fields instances arrays instances fields instances arrays respectively 
live array bytes live heap compress db jack javac jess mtrt graphs show amount array bytes right graph live array bytes left fraction total bytes allocated left live heap size right time measured allocated bytes 
example mbytes allocation jess heap arrays close live objects arrays 
non bytes total allocated compress db jack javac jess mtrt mbytes allocated 
fraction non bytes live non bytes live heap compress db jack javac jess mtrt mbytes allocated graphs show amount non bytes left graph live non bytes right fraction total bytes allocated left live heap size right time measured allocated bytes 
jess example mbytes allocation allocated non fields live objects point non fields 
non array bytes total allocated compress db jack javac jess mtrt mbytes allocated live non array bytes live heap compress db jack javac jess mtrt mbytes allocated 
fraction non bytes arrays graphs show amount non array bytes left graph live non array bytes right fraction total bytes allocated resp 
live heap time measured allocated bytes 
jess example mbytes allocation space allocated non arrays live objects point non arrays 
non ref inst field bytes total allocated compress db jack javac jess mtrt mbytes allocated live non ref instance field bytes live heap compress db jack javac jess mtrt mbytes allocated 
fraction non bytes instances graphs show amount non instance bytes left live non instance bytes right fraction total bytes allocated resp 
live heap time measured allocated bytes 
jess example mbytes allocation space allocated non instance field bytes live bytes point non instance field bytes 
behavior arrays varies widely programs allocating arrays exclusively compress allocating hardly non arrays jess rest 
non fields instance objects show somewhat uniform pattern applications jess mtrt considerably higher compress zero 
surprised see high fraction non fields instances investigated possibility segregating instances contain class pointer 
suggests segregation general case mtrt creates significant amount free instance objects 
bytes ref free instances total allocated compress db jack javac jess mtrt mbytes allocated study allocation behavior mbytes allocated 
fraction bytes free instances heap composition previous section revealed arrays non arrays fairly frequent show kinds arrays occur frequently 
specjvm programs allocates significant number arrays type boolean double float int short 
graphs arrays summarized arrays programs allocate arrays mtrt 
object kinds instance objects byte char arrays fairly common entire suite individual programs may certain types arrays 
instance objects represented compress 
instance objects array type consume allocated space 
dominant kinds depend entirely application db jess contain high fraction arrays jack javac allocate char arrays mtrt allocates instance objects exclusively 
programs distribution stabilizes time jack jess db note java true multidimensional arrays example java represents dimensional int array dimensional array elements int arrays rows dimensional array 
live bytes ref free instances live heap compress db jack javac jess mtrt graphs show amount bytes consumed free expect class pointer instance objects left free live instance objects right fraction total bytes allocated resp 
live heap time measured allocated bytes 
mtrt example mbytes allocation space allocated free instance objects live bytes point free instance objects 
bytes type total allocated bytes type total allocated bytes type total allocated compress jack jess instance objs byte arrays char arrays ref arrays arrays mbytes allocated instance objs byte arrays char arrays ref arrays arrays mbytes allocated instance objs byte arrays char arrays ref arrays arrays mbytes allocated 
heap composition total allocated mbytes allocated mtrt 
informal study applications confirmed trend applications allocate bulk space kinds dominating heap 
results suggest may worthwhile segregate non arrays 
picture changes live objects consideration 
seen previously live graphs contain noise caused heap contractions repetition 
ignoring spikes live heaps show relatively distribution differs markedly numbers 
example db allocates space instance objects arrays char arrays appears keep char bytes type total allocated bytes type total allocated bytes type total allocated db javac mtrt instance objs byte arrays char arrays ref arrays arrays instance objs byte arrays char arrays ref arrays arrays mbytes allocated instance objs byte arrays char arrays ref arrays arrays mbytes allocated application graphs show fraction total allocated space dedicated certain object type time measured allocated bytes 
example mbytes allocation heap javac consists instance objects char arrays arrays byte arrays array types 
live bytes type live heap live bytes type live heap live bytes type live heap compress instance objs byte arrays char arrays ref arrays arrays mbytes allocated jack jess instance objs byte arrays char arrays ref arrays arrays mbytes allocated instance objs byte arrays char arrays ref arrays arrays mbytes allocated study allocation behavior mbytes allocated arrays alive 
live heap contains char arrays arrays 
general char arrays common live heap percentage total allocation suggest 
differences composition live heap versus total allocated suggest basic types different age distributions 
example intuitively expect char arrays represent strings small short lived temporary results permanent 
graphs investigate age distribution average object size separated object kind 
show numbers age distribution organizes data application presents object kind live bytes type live heap live bytes type live heap mbytes allocated javac mtrt instance objs byte arrays char arrays ref arrays arrays instance objs byte arrays char arrays ref arrays arrays mbytes allocated 
heap composition live objects application graphs show fraction current live heap dedicated certain object type time measured allocated bytes 
example mbytes allocation live portion heap jess consists ref arrays instance arrays char arrays byte arrays array types 
live bytes type live heap db instance objs byte arrays char arrays ref arrays arrays fraction type bytes alive fraction type bytes alive fraction type bytes alive compress instance objs byte arrays char arrays ref arrays arrays age mbytes allocated jack instance objs byte arrays char arrays ref arrays arrays age mbytes allocated jess instance objs byte arrays char arrays ref arrays arrays age mbytes allocated age mbytes allocated javac instance objs byte arrays char arrays ref arrays arrays frequent kinds 
graphs easier read eliminated line represent total allocation case line label marked letter useful keep mind object kinds equally important correlate graphs actual heap composition shown 
discussed section large fraction objects dies young 
jess example objects don survive kbytes allocation resolution upper graph appear blank 
longer living data type 
db keeps char arrays jack retains arrays mtrt fraction type bytes alive fraction type bytes alive fraction type bytes alive age distribution total db instance objs byte arrays char arrays ref arrays arrays age mbytes allocated mtrt instance objs byte arrays char arrays ref arrays arrays age mbytes allocated application graphs show fraction bytes certain type live time creation time measured allocated bytes 
example instance object bytes array bytes char array bytes survive mbytes allocation jess 
better readability prune object types represent total allocation mark labels letter fraction type bytes alive fraction type bytes alive fraction type bytes alive compress enlarged instance objs byte arrays char arrays ref arrays arrays age mbytes allocated jack enlarged instance objs byte arrays char arrays ref arrays arrays age mbytes allocated jess enlarged instance objs byte arrays char arrays ref arrays arrays age mbytes allocated study allocation behavior age distribution enlarged age mbytes allocated javac enlarged instance objs byte arrays char arrays ref arrays arrays uses longer living arrays various types 
age distribution graphs show steep drop jess shows smooth age distribution especially instance objects arrays 
worthwhile adaptive strategy recognizes long lived types collects aggressively 
compress keep instance objects prolonged time 
case numbers slightly misleading due fact clip large object allocations kbytes measuring age 
compress uses large byte arrays arithmetic computation allocate space lifetime arrays 
consequently byte arrays die young 
fraction type bytes alive fraction type bytes alive fraction type bytes alive db enlarged instance objs byte arrays char arrays ref arrays arrays age mbytes allocated mtrt enlarged instance objs byte arrays char arrays ref arrays arrays age mbytes allocated application graphs show fraction bytes certain type live time creation time measured allocated bytes 
example instance object bytes array bytes char array bytes survive mbytes allocation jess 
better readability prune object types represent total allocation mark labels letter fraction instance bytes live fraction array bytes live fraction char array bytes live age mbytes allocated arrays compress db jack javac jess mtrt instances compress db jack javac jess mtrt age mbytes allocated char arrays enlarged compress db jack javac jess mtrt age mbytes allocated age mbytes allocated instances enlarged compress db jack javac jess mtrt shows arrays tend survive longer instance objects especially char arrays 
smoother age distribution types 
character arrays hand die young jack javac stay alive execution time db 
observation suggests segregating arrays type specific heaps applying different collection strategies pay 
benchmark suite may small draw reliable general type specific age characteristics 
fraction char array bytes live fraction instance bytes live fraction array bytes live char arrays compress db jack javac jess mtrt age mbytes allocated arrays enlarged compress db jack javac jess mtrt age mbytes allocated 
age distribution selected types second row shows enlarged graphs type graphs show fraction bytes application live time creation 
example char object bytes db javac jack survive mbytes allocation 
better readability prune object types represent total allocation mark labels letter object size table lists average object sizes computed separately frequent object kinds 
normalized numbers misleading cases small sample size 
type table includes percentage total allocation entry entries total allocation shaded 
instance objs byte arrays char arrays ref arrays arrays sum mean median total mean compress kb median total mean study allocation behavior median instance objects clearly smallest objects heap 
depending application average size varies bytes 
char arrays fairly small average size bytes 
array types predictable depending application range bytes kbytes 
small average object size appears imperative implementors keep number header words minimum example single extra header word object increase mtrt heap 
object alignment program heaps dominated relatively small objects object alignment add significant space overhead 
numbers bit aligned object sizes explained section 
real jvm implementations may align objects boundaries simplify memory management satisfy hardware alignment requirements 
example sun jdk vm aligns objects byte boundaries 
extra alignment increases heap size see table 
programs suffer alignment jack mtrt high percentage small objects 
reverse implication programs small objects show high overhead necessarily hold size frequently allocated objects may multiple 
total mean median total mean kb median kb total mean kb median total db kb kb jack javac jess mtrt table 
average object size bytes cell shaded type comprises total allocated heap space total allocated mbytes byte aligned mbytes comparison studies increase mbytes total allocated compress db jack javac jess mtrt table 
heap size increase due byte alignment general difficult compare empirical gc studies study uses different assumptions nursery size large object area different techniques simulation code instrumentation different metrics different benchmarks different languages 
attempt comparisons 
barrett zorn report lifetime quantiles allocation intensive programs bz 
find objects survive bytes objects short lived die kbytes allocation 
moss report similarly high object mortality sml nj sm smallest nursery size setting kbytes ml applications survival rates approximately 
addition survival rate drops dramatically nursery size increased kbytes 
lisp programs measured sha slightly lower mortality survive kbytes approximately live mbyte 
comparison java objects appear objects surviving kbytes allocation live kbytes 
eleven benchmarks study programs detlefs average object sizes bytes programs bytes 
comparison benchmarks compress exceeds average object size bytes 
wilson wj measure average object size distinguish popular object sizes presenting memory profile programs 
programs larger object sizes java examples objects kilobytes fairly common 
studies report numbers type composition shaw lisp sha gon alves ml gon 
moss analyze nursery survival rate depending object kind ml sm 
studies different categories types cons vect string float object ratio symbol lisp numbers difficult compare 
appears lisp programs analyzed sha allocate space arrays typical java applications 
effect pronounced ml benchmarks studied gon uses arrays 
addition space free objects real 
analyzed memory allocation behavior large java programs specjvm benchmark suite 
applications allocate significant amounts memory mbytes mbytes run minimal heap size mbytes 
observations confirm weak generational hypothesis young objects die result pronounced languages megabyte allocation java objects live 
regarding heap composition arrays instance objects contain high fraction non fields 
application mtrt allocates considerable number instance objects containing class pointer 
analyzing heap object types kind object instance objects byte arrays dominates allocation dominates applications 
byte alignment technique real jvm implementations increase allocation rate median 
extra header words top class pointer average object sizes bytes single extra word increase allocation rate 
currently working additional experiments extended version 
new data illuminate influence strings heap composition average density incoming point object 
analyze different alignment packing strategies match results detailed histograms showing distribution object sizes 
furthermore investigate possibility thread local heap studying thread locality 
hope information prove useful jvm implementors optimizing java garbage collection memory allocation 
acknowledgments steffen mark reinhold members group ucsb valuable comments earlier versions 
funded part sun microsystems state california micro program national science foundation career ccr 
study allocation behavior bak baker 
infant mortality generational garbage collection 
acm sigplan notices april pages 
bak baker 
thermodynamics garbage collection 
acm sigplan notices april pages 
bz barrett zorn 
lifetime predictors improve memory allocation performance 
proceedings sigplan conference programming languages design implementation acm sigplan notices albuquerque nm june acm press pages 
cw wirfs brock 
third generation smalltalk implementation 
oopsla acm conference object oriented systems languages applications acm sigplan notices portland october acm press pages 
detlefs zorn 
memory allocation costs large programs 
software practice experience 
ga 
spec performance evaluation measure 
computer august 

gon gon alves 
cache performance programs intensive heap allocation generational garbage collection 
ph thesis princeton university may 
technical report cs tr 
gjs gosling joy steele 
java language specification 
addison wesley 
hay hayes 
key object opportunism collect old objects 
proceedings oopsla conference object oriented systems languages applications acm sigplan notices phoenix arizona october 
acm press pages 
hay hayes 
key objects garbage collection 
ph thesis stanford university march 
hh hicks hornof moore nettles 
study large object spaces 
proceedings international symposium memory management vancouver october acm press pages 
hmn hicks moore nettles 
measured cost copying garbage collection mechanisms 
proceedings international conference functional programming amsterdam june 
hol 
programming java threads real world part 
javaworld sept 
www javaworld com javaworld jw jw threads html jl jones lins 
garbage collection 
john wiley sons 
lh lieberman hewitt 
real time garbage collector lifetimes objects 
communications acm 
ly lindholm yellin 
java virtual machine specification 
addison wesley 
moore hicks nettles 
oscar gc testbed 
position oopsla workshop garbage collection memory management 
atlanta ga october 
sha shaw 
empirical analysis lisp system 
ph thesis stanford university 
technical report csl tr 
spec standard performance evaluation 
specjvm documentation release 
august 
online version www spec org osg jvm jvm doc index html study allocation behavior sm moss 
characterization object behavior standard ml new jersey 
conference record acm symposium lisp functional programming 
acm press june 
ung ungar 
generation scavenging non disruptive high performance storage reclamation algorithm 
acm software eng 
notes sigplan notices software engineering symposium practical software development environments acm sigplan notices pittsburgh pa april 
ung ungar 
design evaluation high performance smalltalk system 
acm distinguished dissertations 
mit press cambridge ma 
ph dissertation university california berkeley february 
wil wilson 
uniprocessor garbage collection 
proceedings international workshop memory management lecture notes computer science springer verlag 
wj wilson johnstone neely boles 
dynamic storage allocation survey critical review 
proceedings international workshop memory management lecture notes computer science scotland september 
springer verlag 
zor zorn 
comparative performance evaluation garbage collection algorithms 
ph thesis university california berkeley march zg zorn grunwald 
empirical measurements allocation intensive programs 
acm sigplan notices pages december 
zg zorn grunwald 
evaluating models memory allocation 
acm transactions modeling computer simulation 
zs zorn seidl 
segregating heap objects behavior lifetime 
eighth international conference architectural support programming languages operating systems san jose ca october 

