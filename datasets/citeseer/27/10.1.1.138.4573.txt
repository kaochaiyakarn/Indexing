efficient authentication signing multicast streams lossy channels adrian perrig ran canetti tygar dawn song uc berkeley ibm watson perrig tygar cs berkeley edu canetti watson ibm com multicast stream authentication signing important challenging problem 
applications include continuous authentication radio tv internet broadcasts authenticated data distribution satellite 
main challenges fourfold 
authenticity guaranteed sender data trusted 
second scheme needs scale potentially millions receivers 
third streamed media distribution high packet loss 
system needs efficient support fast packet rates 
propose efficient schemes tesla emss secure lossy multicast streams 
tesla short timed efficient stream loss tolerant authentication offers sender authentication strong loss robustness high scalability minimal overhead cost loose initial time synchronization slightly delayed authentication 
emss short efficient multi chained stream signature provides nonrepudiation origin high loss resistance low overhead cost slightly delayed verification 
began summer adrian perrig dawn song visiting ibm watson research lab 
initial research stream authentication done summer ran canetti adrian perrig dawn song ibm 
additional improvements suggested tygar fall uc berkeley 
implementation done fall adrian perrig uc berkeley 
stream signatures done tygar adrian perrig dawn song uc berkeley 
additional performed ran canetti spring 
ran canetti ibm watson research center adrian perrig dawn song tygar computer science division uc berkeley 
research part defense advanced research projects agency darpa contract supervision space naval warfare systems center san diego national science foundation fd united states postal service usps 
views contained document authors necessarily represent official opinion policies expressed implied government agencies darpa nsf usps ibm 
online population continues expand internet increasingly distribute streamed media streamed radio video 
expect trend continue 
enable widespread trusted streamed media dissemination provide sufficient security guarantees 
prominent security risk user point view data authenticity 
user needs assurance data stream originated purported sender 
malicious isp replace parts stream material 
example adversary alter stock quotes distributed ip multicast 
scenario receiver needs strong sender data authentication 
problem continuous stream authentication solved case sender receiver standard mechanisms 
sender receiver agree secret key conjunction message authenticating code mac ensure authenticity packet 
case multiple receivers problem harder solve symmetric approach allow holding key receiver forge packets 
alternatively sender digital signatures sign packet private key 
solution provides adequate authentication digital signatures prohibitively inefficient 
real time data streams lossy security problem harder 
receivers typically high variance bandwidth receivers high packet loss receivers relatively low bandwidth 
want assure data authenticity presence high packet loss 
number schemes solving problem authenticating data sender setting sender trusted suggested past years schemes completely sat 
discuss schemes section 
presents different solutions problem authenticating data streams efficiently lossy environment 
solution called tesla timed efficient stream loss tolerant authentication uses symmetric cryptographic primitives pseudorandom functions prfs message authentication codes macs timed release keys sender 
specifically scheme idea sender commits random key revealing transmits receivers 
sender attaches message authenticating code packet uses key mac key 
packet sender decommits allows receivers verify commitment mac packet verifications correct guaranteed packet sent packet received receiver knows packet authentic 
start scheme sender uses regular signature scheme sign initial commitment 
subsequent packets authenticated chaining 
scheme tesla properties low computation overhead 
authentication typically mac function hash function computation packet sender receiver 
low packet communication overhead 
overhead low bytes packet 
arbitrary packet loss tolerated 
packet received time authenticated 
unidirectional data flow 
data flows sender receiver 
acknowledgments messages necessary connection setup 
implies sender stream authentication overhead independent number receivers scheme scalable 
sender side buffering 
packet sent soon ready 
high guarantee authenticity 
system provides strong authenticity 
strong authenticity mean receiver high assurance authenticity long timing cryptographic assumptions enforced 
freshness data 
receiver knows upper bound propagation time packet 
scheme provide non repudiation 
recipient convince third party stream arrived claimed source 
second scheme called emss efficient stream signature signing small number special packets data stream packet linked signed packet multiple hash chains 
achieved appending hash packet including possible appended hashes previous packets number subsequent packets 
appropriate choice parameters scheme guarantees arriving packets authenticated highly lossy channels 
main features scheme amortizes cost signature operation mul tiple packets typically signature operation packets 
tolerates high packet loss 
low communication overhead bytes packet depending requirements 
provides non sender trans data 
tesla timed efficient stream authentication section describe schemes stream authentication 
scheme builds previous improves solve shortcomings 
scheme call tesla short timed efficient stream loss tolerant authentication satisfies properties listed 
cryptographic primitives section reviewed appendix contains sketch security analysis scheme 
notation denotes concatenation stands sender stands receiver 
stream divided chunks call messages message sent packet additional authentication information 
threat model security guarantee design schemes secure powerful adversary capabilities full control network 
adversary eavesdrop capture drop resend delay alter packets 
adversary access fast network delay 
adversary computational resources may large unbounded 
particular means adversary perform efficient computations computing reasonable number pseudo random function applications macs negligible delay 
adversary invert pseudorandom function distinguish random function non negligible probability 
security property guarantee receiver accept authentic message sent sender 
scheme provides guarantee called secure stream authentication scheme 
note security requirements include protection message duplication 
protection added separately standard mechanisms nonces serial numbers 
schemes iii protection message duplication 
note address denial service attacks 
initial synchronization preliminary discussion schemes initial synchronization protocol receiver compares local time sender registers difference 
rough upper bound clock difference sufficient 
fact receiver needs value sender clock time units ahead receiver clock order multiple seconds 
section describe simple protocol discuss scalability issues related initial synchronization 
basic assumption underlies security scheme local internal clocks sender recipient drift session 
scheme basic scheme summary scheme sender issues signed commitment key known 
sender uses key compute mac packet discloses key packet enables receiver verify commitment mac packet verifications successful packet authenticated trusted 
commitment realized pseudorandom function collision resistance 
details requirements pseudorandom functions appendix protocol similar guy fawkes protocol 
describe basic scheme detail 
scheme depicted 
assume receiver authenticated packet clock synchronization algorithms exist example mills ntp security analysis 
mac mac authenticated authenticated reception pi mac authenticated 
basic stream authentication scheme 
stands message packet denotes secret key pseudo random functions mac computes mac packet secret key mac start meanings 
message contained packet 
fields packet commits key secret key compute mac revealing 
functions different pseudo random functions 
commitment value important authentication subsequent packet bootstrap scheme packet needs authenticated regular digital signature scheme example rsa 
send message sender picks fresh random key constructs packet mac mac mac computes message authenticating code key receiver receives packet verify mac instantly know reconstruct packet discloses allows receiver verify correct equals commitment sent packet second compute check authenticity packet verifying mac packet receiver authenticated commitment authenticated receiver repeats scheme authenticate received 
scheme subverted attacker gets packet receiver gets attacker know secret key compute mac allows change message commitment forge subsequent traffic 
prevent attack receiver checks security condition packet receives drops packet condition hold 
security condition data packet arrived safely receiver unambiguously decide synchronized time sender send corresponding key disclosure packet stream authentication scheme secure long security condition holds 
emphasize security scheme rely assumptions network latency 
order receiver verify security condition receiver needs know precise sending schedule packets 
easiest way solve problem constant packet rate 
sending time packet forge packet stream 
security condition prevents key chain prevents attack initial commitment commits entire key chain computationally infeasible attacker invert find collisions pseudo random function 
time sender clock packet rate number packets second 
case security condition receiver checks psfrag replacements additional benefit key commitment need embedded packet 
due intractability inverting pseudo random function value chain commitment entire chain 
commitment initial authenticated packet sufficient 
shows example scheme ii 
form stands arrival time synchronized receiver clock packet main problem scheme order satisfy security condition sending rate slower network delay sender receiver 
severe limitation throughput transmission 
addition basic scheme tolerate packet loss 
particular packet dropped packets authenticated 
gradually extend basic scheme eliminate deficiencies 
scheme ii tolerating packet loss authenticate lossy multimedia streams tolerating packet loss paramount 
solution generate sequence keys sequence generated pseudo random function applications 
denote con applications pseudo random function convention sender picks random pre computes sequence key values call sequence values key chain 
looks pseudorandom attacker particular attacker invert compute hand receiver compute received receiver received packet subsequently received packet allow compute verify authenticity scheme tolerates arbitrary number packet losses 
similarly dropping unsafe packets packets security condition hold cause problems authentication packets 
basic scheme adversary try capture consecutive packets recipient received mac mac mac authenticated authenticated reception pi authenticated 
scheme ii 
packet format scheme commitment omitted keys form way key chain 
scheme iii achieving fast transfer rates mentioned earlier receiver needs assured receives packet corresponding key disclosure packet sent sender 
condition severely limits transmission rate previous schemes sent receiver received solve problem disclosing key data packet packet packet delay parameter set sender announced session set 
sender determines delay packet rate maximum tolerable synchronization uncertainty infeasible find attacker find collision able forge single message forging additional messages require inverting find ing tmax maximum tolerable network delay nmax 
setting nmax tmax allows receiver suc verify security condition case maximum allowable network delay maximal synchronization error 
choice tmax nmax presents tradeoff large delay values cause large results long delays packet tion 
hand short maximum delays cause security condition drop packets receivers slow network connection 
multimedia data packets obsolete received segment stream played user 
case dropping unsafe packets interfere multimedia stream packets obsolete 
stress choice affect security scheme usability 
case constant packet rate security condition easy state 
assume sending time packet sending time packet verify security condition incoming packet receiver checks arrival time packet receiver 
scheme iv dealing dynamic packet rates previous schemes fixed predictable sender schedule recipient knowing exact sending time packet 
severely restricts flexibility senders design scheme allows senders send dynamic transmission rates requirement receiver needs know exact sending schedule packet 
solution problem pick mac key disclosed key packet time interval basis packet index basis 
sender uses key compute mac packets sent interval packets sent interval disclose key session set sender announces values starting time interval duration interval 
addition delay parameter announced 
announcements signed sender 
interval index time period determined key associated interval keys chained way scheme ii 
sender uses key compute mac packet sent interval packet carries interval index discloses key previous interval refer disclosure lag 
format packet mac shows example scheme scheme receiver verifies security condition follows 
receiver knows values 
value obtained initial synchronization protocol 
assume receiver gets packet local time packet apparently sent interval sender interval ply ensures packet discloses value key sent 
illustrates verification security condition 
remains describe values picked 
stress choice values affect security scheme usability 
sender pick values needs determine maximum tolerable synchronization uncertainty tmax maximum tolerable network delay nmax 
security condition case sim sender defines max tmax sender choice max tradeoff 
large value max allow slow receivers verify security condition correctly requires long delay packet authentication 
conversely short max cause slow receivers drop packets nmax cause security condition satisfied 
second tradeoff long interval duration saves computation storage overhead key chain short determining tmax nmax disclosure lag tmax nmax scheme provides numerous advantages 
sender predict long pre computed key chain lasts number necessary keys time dependent number packets sent 
second receiver conveniently verify security condition sender need send packets specific intervals discuss details section 
advantage new receivers easily join group moment 
new group member needs synchronize time sender receive interval parameters commitment key chain 
closely achieves desired max 
scheme accommodate broad spectrum receivers previous schemes showed tradeoff choice key disclosure period 
time difference short packet authenticated quickly packet travel time long security condition hold remote receivers forces drop packet 
conversely long time period suit remote receivers authentication time delay may unacceptable receivers fast network access 
scheme needs scale large number receivers expect receivers wide variety network access need solve tradeoff 
approach multiple authentication chains chain scheme iv different disclosure periods mac mac mac 
scheme iv 
mac key disclosed key dependent time interval 
authentication key disclosed packets sent interval case packet discloses key allows receiver compute authenticate packet point packets authenticated mac key sent time interval 
sent received 
security condition visualized 
packet sent interval key active 
receiver receives packet sender interval due sender interval discloses key problem current packet key disclosed security condition satisfied packet safe 
simultaneously 
receiver chain minimal disclosure delay sufficient prevent spurious drops caused security condition hold 
receiver verifies security condition authentication chain drops packet conditions satisfied 
assume sender uses authentication chains chain smallest delay disclosure packet sent th chain longest delay 
furthermore assume incoming packet security conditions chains satisfied condition chain satisfied 
case long key disclosure packets chains arrive receiver confidence authenticity packet increasing 
soon key disclosure packet chain arrives receiver assured authenticity packet initial synchronization discussion stream authentication scheme relies loose time synchronization sender recipients 
call synchronization loose synchronization error large 
requirement client knows upper bound maximum synchronization error 
time synchronization protocol scheme long robust active adversary 
proof concept simple time synchronization protocol suffices requirements 
basic protocol follows mac mac receiver uses nonce packet prevent attack replays previously signed synchronization reply 
mac current time sender sender sends information necessary define intervals commitment active key chain 
disclosure lag defines difference intervals key values disclosed 
packet signed regular signature scheme 
purposes stream authentication scheme receiver interested maximum possible time value sender 
simplifies computation 
shows timing diagram synchronization 
receiver sets computes latest possible sender time follows current receiver time estimated sender time 
ideal case receiver initial packet arrives sender delay denoted time 
maximum time discrepancy round trip time 
rtt receiver sender 
receiver synchronizes time sender 
scalability major concern widely deployed system 
receiver needs synchronize time sender sender bottleneck 
better solution distributed secure time servers 
initially sender synchronizes time time server computes maximum synchronization error sender periodically broadcast interval information current timestamp digitally signed ensure authenticity 
receivers independently synchronize time synchronization server individually compute maximum synchronization error receivers add values verify security condition 
scheme step hierarchy synchronization servers maximum errors need propagate 
terms sender receiver appear reversed description time synchronization protocol keep role respect stream authentication scheme 
receiver synchronizes time sender imagine synchronizing synchronization servers satellite signal example gps 
combining multicast group control centers 
general ip multicast model assumes host join multicast group receive group data send data group 
join multicast group receiver needs announce interest local router takes care forwarding packets receiver 
joining group member contacts central server group controller negotiate access rights session keys 
model supported secure multicast users group adopt secure authentication scheme requires receiver performs initial registration time synchronization interval timing information sender central server 
sketch scalable synchronization mechanism uses infrastructure senders receivers synchronize time synchronization servers dispersed network 
synchronization entity knows time maximum er ror sender periodically broadcasts signed message contains interval key chain commitment information authentication chain 
new receiver need wait broadcast packet allowing compute synchronization error sender receiver determines minimum delay authentication chain 
receiver need send messages sender provided sender receiver method synchronize receiver knows upper bound synchronization error dealing clock drift 
authentication protocols assume clock drift sender receiver 
practice software clock drift heavy load timer interrupt get serviced 
attacker able change victim time sending spoofed ntp messages 
solution problems receiver consults internal hardware clock small drift hard attacker disturb 
furthermore longer authentication chains scheme tolerate authentication delay order tens seconds giving large security margin 
reasonable assume hardware clock drift tens seconds session 
receiver re synchronize periodically hardware clock appears drift substantially 
implementation issues implemented tesla prototype java 
md hash function conjunction hmac construction pseudo random function mac 
limit communication overhead significant bits output saves space standard bits gives sufficient security 
initial synchronization packet signed bit rsa signature 
design functionality tesla remains application layer 
design principle follows approach alf tennenhouse clark introduce 
alf application knows best handle data opposed placing services network transport layer osi stack 
alf ideally suited tesla 
authentication packets delayed application knows best handle unauthenticated information declared invalid 
see main possibilities application interact tesla module receiver side 
buffer incoming packets deliver authenticity assured 
second deliver incoming packets directly inform application upcall soon packet authenticated packet faulty 
implemented second alternative 
hand arguments implementing tesla transport layer security services 
variants interaction application possible 
case network layer buffers stream data forwards soon data authenticity guaranteed 
second case network layer directly forward data application require mechanism network layer inform application validity data 
prevent applications data authentic imagine scheme sender encrypts data packet separate key releases key packet 
case application receive encrypted data receives decryption key 
udp datagrams communication simulate multicast datagrams 
point reliable transport protocol tcp sense setting tcp interferes timing packet arrival announce incoming packets application previous packets arrive 
problem tesla module resides application space 
furthermore tesla partic argumentation method claims put burden network layer buffer data packet 
case ip fragmentation network layer buffers data forwards application entire packet complete 
suited lossy data streams udp perfect sense tcp settings require reliable communication 
simplify exposition protocols consider case scheme iv uses authentication chain 
sender tasks sender needs define parameters tesla number authentication chains interval rate authentication chain disclosure delay authentication chain number authentication chains dependent heterogeneity network delay receivers delay variance desired authentication delay 
example tesla lan setting small network delay low delay variance sender single authentication chain disclosure lag rtt low milliseconds 
extreme radio broadcast internet millions receivers 
receivers high speed network access low delay dialup modem lines connected wireless link considerable delay order seconds 
accommodate category large synchronization error order seconds longest authentication chain needs disclosure de lay long acceptable high speed users 
second authentication chain small disclosure delay seconds appropriate 
close wide gap high low users third chain delay seconds appeal modem users 
initially sender picks random key computes stores entire chain keys receiver tasks seconds 
long delay receiver initially synchronizes sender determines accuracy sender sends interval information disclosure lag receiver necessary verify security condition 
authenticated synchronization packet contains disclosed key value commitment key value chain 
incoming packet receiver verifies security condition 
checks disclosed key value correct verified applying hmac md pseudo random function verify equality previously authenticated commitment 
block size md hmac md table 
performance primitives native java library 
performance displayed number operations second 
minimize computation overhead receiver reconstructs stores chain key values 
mac verified time receiver adds triplet list packets verified sorted interval value 
storing entire packet receiver computes stores hash value packet 
incoming disclosed mac key new receiver updates key chain checks verify mac packets packet list 
case mac verify correctly library throws exception warn application 
packet delivered application 
possible denial service attack attacker sending packet marked interval far 
receiver spend time update key chain 
simple remedy attack receiver reject packets sent lines security condition 
drawback stream authentication scheme receiver needs store key chain packet information verify packet authenticity 
key chain small intervals seconds practice amount storage required large long authentication delays fast sender rates 
implementation bit hash interval stored packet amounts bytes 
performance outgoing packet sender needs compute hmac function packet authentication chain key chain pre computed 
table shows performance md hmac md functions provided running mhz pentium iii linux pc 
java code executed jit compiler comes jdk provided ibm 
analyze performance stream authentication scheme measuring number packets second sender create 
table shows packet rates different packet sizes different numbers authentication chains 
suspect optimized implementation twice fast 
packet size bytes authentication chain authentication chains authentication chains authentication chains table 
performance packet authentication scheme varying number authentication chains 
performance numbers packets second 
communication overhead prototype bytes authentication chain 
bit hmac md disclosed key mac bytes long 
remaining bytes send interval index 
overhead pre computing key chain minimal 
experiments interval length th second 
pre compute key chain long authenticate packets hour sender pre computation time computational overhead receiver side sender side receiver needs recompute key chain sender pre compute 
overhead computing key chain negligible involves computing hmac functions time interval practice tens intervals second 
seconds 
emss efficient multi chained stream signature tesla provide non repudiation 
multimedia applications need non repudiation discard data decoded played 
stream signature schemes important cases 
applications really need continuous non repudiation data packet find compelling example 
second importantly settings time synchronization difficult tesla 
emss efficient multi chained stream signature achieve nonrepudiation achieves sender authentication 
requirements stream signature scheme follows non repudiation individual packet continuous non repudiation packets robust high packet loss mac low computation communication overhead real time stream content buffering packets sender required basic signature scheme achieve non repudiation rely conventional signature scheme example rsa rohatgi signature scheme 
unfortunately computation communication overhead current signature schemes high sign packet individually 
reduce overhead signature needs amortized multiple packets 
basic solution bases scheme achieve non repudiation sequence packets 
packet includes hash previous packet sending signature packet stream contains hash final packet signature achieve non repudiation packets 
achieve robustness packet loss packet contains multiple hashes previous packets furthermore final signature packet signs hash multiple packets 
shows example packet contains hash previous packets signature packet contains hash packet signature 
sig packet sj signature 
achieve non repudiation periodic signature packets contain hash data packets inclusion hash current packet packets 
inclusion multiple hashes achieves robustness packet loss 
order sender continuously verify signature stream sender sends periodic signature packets 
receiver verify signature packet receives signature packet clear receiver experiences delay packet verification 
simplify discussion describe scheme graph problem corresponding terminology 
term node packet edge hash link 
define length edge id corresponding nodes 
packet contains hash packet draw directed edge starting call supporting packet similarly edge points packet signature packet contains hash assume packets dropped sender receiver 
nodes correspond dropped packets removed graph 
packet verifiable exists path signature packet stream signature scheme parameters number edges node length distribution edges frequency signature nodes number distribution incoming edges signa ture nodes parameters influence computation communication overhead delay verification robustness packet loss 
want achieve low overhead retaining high robustness packet loss low verification delay 
simplify problem optimizing parameters simultaneously focus interplay number distribution edges achieve high robustness packet loss 
consider static edges means outgoing incoming edges node predefined lengths 
example scheme node outgoing edges incoming edges simplify problem initially assume independent packet loss packet equal loss probability 
computing probability precisely node wrote program perform simulations 
attempt devise analytical formula model probability node connected signature node 
unfortunately finding exact formula harder appears deriving analytical formula automatically edge distribution remains open problem 
illustrate complexity example recurrence relation describes simple scheme probability node connected node signed probability node dropped 
checked accuracy simulation program cases computed analytical solution simulation samples simulating packets signature packet absolute error mac veri mac fication probability cases 
mac ran extensive simulations find distribution edges high amounts dropped nodes 
largest simulation searched combinations edges node maximum length edge probability dropping node simulation assumed final nodes existed contained edge signature node 
simulation results illuminating 
important finding simulation study majority combinations robust 
illustrates point 
axis ranges average probability verification shows combinations average verification probability measured nodes preceding signature packet 
demonstrates combinations high robustness 
fact combinations give average verification probability finding motivates random edges static edges 
interesting result continuous case weakest combination exponentially increasing edge lengths poor robustness 
strongest combinations show performance combinations 
continuous case lowest verification probability exponential chain better case weaken distance signature packet increases 
assumption independent packet loss hold internet 
studies show packet loss correlated means probability loss higher previous packet lost 
paxson shows studies packet loss correlated length losses exhibit infinite variance 
borella draw similar furthermore find average length loss bursts packets 
yajnik show state markov model model internet packet loss patterns 
simulation purposes state model sufficient model simple patterns bursty loss 
main advantage randomizing edges visible consider correlated packet loss 
shows simulation packet loss average length burst loss packets 
clearly see fig chose edges node wanted achieve high average robustness case packet loss edges give high verification probability 
verifiable combinations distance final signature packet 
verification probability static cases top line 
middle line 
bottom line 
average probability packet verifiable 
number combinations hashes resulted average verification probability 
note assume packet loss probability 
ure verification probability static edge scheme drops exponentially random edges provide high verification probability 
verifiable distance final signature packet 
verification probability random vs static case 
top line random link distribution 
bottom line 
extended scheme basic scheme lot redundancy 
supporter packets carry hash value packet 
experiments hashes packet packets carry hash value 
removing redundancy give lower communication overhead improved robustness loss 
core idea split hash chunks quorum chunks sufficient allow receiver validate information 
approach rabin information dispersal algorithm precisely property 
approach produce hash function large number independent bits look limited number bits 
easily realized family universal hash functions 
main advantage scheme packets need arrive higher robustness circumstances receiving packet basic scheme 
example basic scheme bit hashes hashes packet communi cation overhead bytes probability packets arrives loss probability 
contrast extended scheme hash bits chunks bits probability receiver gets packets ter probability higher 
probabilities clearly lat provide upper bound verification probability gives intuition extended scheme provides higher robustness packet loss 
simulation confirmed findings 
extended scheme outperforms basic scheme robustness packet loss 
shows comparison schemes identical communication overhead 
verifiable distance final signature packet 
verification probability basic vs extended scheme 
top line extended scheme 
bottom line basic scheme 
signature packets important requirement scheme signature scheme receiver continuously verify signature packets 
clearly receiver verify signature trace authentication links signature packet 
verification delay depends frequency transmission reliability signature packets 
signature packet rate depends available computation communication resources 
bit rsa signatures dedicated server compute order signatures second 
corresponding communication overhead bytes signature plus bytes hash included 
performed simulations signature packets 
parameters included signature rate loss probability signature packets number hashes signature packet 
shows sawtooth shaped loss probability different signature packets sent redundantly higher service class context qos 
mac verification probability stream packet loss bursty loss average burst length dropped packets hash split chunks bits span ning maximum length packets chunks necessary verify packet gives bits signature 
communication overhead packet bytes packet 
signature packets sent packets contain bit hashes packets bit rsa digital signature amounts bytes 
signature packet sent twice loss probability signature packet reduced average packet overhead case bytes 
verifiable distance final signature packet 
verification probability extended scheme including periodic signature packets 
case study settings consider different cases stream distribution analyze overhead applying emss ensure non repudiation streamed data 
case streamed distribution traffic data assume traffic sensors distributed streets 
broadcasts data internet citizens robot driven vehicles improve trip planning 
system requirements follows data rate stream kbps packets bytes sent second 
packet drop rate average length burst drops packets 
verification delay seconds 
different instantiations emss result efficient schemes satisfy requirements 
scheme offers low overhead high verification probability 
packet hashes length hash chain element chosen uniformly distributed interval hash bits long hash necessary verification 
signature packet sent packets seconds necessary achieve robustness case ensure verification delay seconds high probability 
signature packet carries hash data packets 
simulation predicts average verification probability packet computation overhead minimal 
sender needs compute signature seconds hash functions second 
communication overhead low 
data packet carries bytes containing hash previous packets 
signature packet contains hashes signature length bytes plus signature length 
assuming bit rsa signature signature packet bytes long 
average packet overhead bytes lower previous schemes review section 
case ii real time video broadcast assume want broadcast signed video internet 
system requirements follows data rate stream mbps packets bytes sent second 
clients experience packet drop rates average length burst drops packets 
verification delay second 
high packet drop rate difficult signature packets reach receiver 
increase likelihood signature packets arrive send twice delay packet loss correlated 
approximate loss probability assuming signature packet id packet need stored packet reasons 
probability hash collision negligible receiver store hash data packets received 
packet contains hash value consider packet verified current packet verified 
alternatively build deterministically computable random graph packets receiver reconstruct 
alternative require packet id packet 
packet losses uncorrelated sent delay probability arrives approximately packet loss high veri fication delay relatively short send signature packet packets 
translates signatures second consider low computational overhead 
assume signature packets size data packets bytes fit bit rsa signature bit hash previous packets 
chose parameters engineering practice 
find better parameters number chunks hash split number chunks required verify packet simulation 
simulation shows best combination case uses bytes packet insert chunks bytes hash previous packets 
including signature packets average communication overhead bytes packet 
simulation predicts average verification probability final packets minimum verification probability previous review previous art deals problem continuous authentication signature streams 
gennaro rohatgi introduced techniques signing digital streams 
different schemes line case entire stream content known advance line case stream content generated real time 
line case suggest signing packet packet hash packet including hash stored 
method elegant provides stream signature tolerate packet loss 
biggest disadvantage entire stream packets needs known advance 
line scheme solves problem regular signature initial packet embedding public key time signature packet sign subsequent packet 
limitation scheme robust packet loss 
addition time signature communication overhead substantial 
wong lam address problem data authenticity integrity delay sensitive lossy multicast flows 
propose merkle signature trees sign streams 
idea asymmetric digital signatures efficient amortize signature generation verification multiple messages 
merkle describes construct hash tree messages signer digitally signs root 
scheme robust packet loss packet needs contain signature nodes necessary compute root requires large space overhead 
practice scheme adds bytes packet assuming bit rsa signature signature tree packets 
shortcoming messages need known compute signature tree 
causes delays sender side 
furthermore signature computation packets sent time causing bursty traffic patterns 
burstiness may increase packet drop rate network 
computational overhead amortized multiple packets substantial amount computation necessary signature verification consume substantial amount resources low receivers example battery power 
subtle point packet computation increases packet loss rate 
mobile receivers computational power higher packet loss benefit amortization lost 
schemes propose solve shortcomings 
rohatgi presents new scheme reduces sender delay packet reduces communication overhead time signatures previously proposed schemes 
introduces time signature scheme space efficient time signatures 
despite advantages scheme uses bytes time public key include certificate public key bytes signature 
server requires line hash function applications client needs hashes average verify signature 
canetti construct sender authentication scheme multicast 
solution different keys authenticate message different mac receiver knows keys verify mac keys distributed way coalition receivers forge packet specific receiver 
communication overhead scheme considerable message carries mac server compute macs packet sent expensive scheme 
furthermore security scheme depends assumption bounded number order receivers collude 
syverson stubblebine goldschlag propose system provides asymmetric unlinkable authentication 
system client proves right access vendor service blinded signature token renewed transaction 
vendor blind signature achieve unlinkability transactions 
scheme stream authentication communication computation overhead substantial 
furthermore scheme provides unlinkability needed authenticating multicast streams 
anderson scheme provides stream authentication parties 
guy fawkes protocol packet format denotes message number hash function 
assuming receiver received authentication packet stands random immediately authenticate packet similarly comes commitment drawback protocol send message message needs known 
furthermore scheme tolerate packet loss 
propose methods guarantee keys revealed soon 
method sender receiver lockstep receiver acknowledges packet sender send packet 
severely limits transfer time scale large number receivers 
second method secure scheme time stamp packet time stamping service introduces additional complexity 
basic authentication scheme propose similar guy fawkes protocol 
improve guy fawkes construct efficient stream authentication scheme limitations 
understand unpublished bob briscoe bt research dan boneh philippe proceeding similar lines 
best knowledge groups working independently 
contains commitment acknowledgments pankaj rohatgi help early stages project 
steve glassman mark manasse allan heydon helpful comments discussions 
indebted david wagner bob briscoe relevant feedback concrete suggestions improve presentation 
anonymous reviewers helpful suggestions 
ross anderson francesco bergadano bruno jong lee roger needham 
new family authentication protocols 
operating systems review october 
bellare kilian rogaway 
security cipher block chaining 
desmedt editor advances cryptology crypto pages berlin 
springer verlag 
lecture notes computer science volume 
bellare rogaway 
collision resistant hashing making practical 
burt kaliski editor advances cryptology crypto pages berlin 
springer verlag 
lecture notes computer science volume 
mihir bellare ran canetti hugo krawczyk 
message authentication hash functions hmac construction 
rsa laboratories cryptobytes spring 
matt bishop 
security analysis ntp protocol version 
sixth annual computer security applications conference november 
borella brewster 
internet packet loss measurement implications qos 
international conference parallel processing august 
ran canetti juan garay gene daniele micciancio moni naor benny pinkas 
multicast security taxonomy efficient constructions 
infocom 
carter wegman 
universal classes hash functions 
jcss 
clark tennenhouse 
architectural considerations new generation protocols 
proceedings acm symposium communications architectures protocols sigcomm pages september 

www org 
stephen deering 
multicast routing internetworks extended lans 
proceedings acm sigcomm august 
allen 
tls protocol version 
internet request comments rfc january 
proposed standard 
rosario gennaro pankaj rohatgi 
sign digital streams 
technical report ibm watson research center 
oded goldreich 
foundations cryptography fragments book 
www toc lcs mit 
edu oded frag html 
goldwasser micali rivest 
digital signature scheme secure adaptive attacks 
siam journal computing april 
mark handley 
private communication adrian perrig february 
ibm 
java web page 
www ibm com developer java 
ipsec 
ip security protocol ietf working group 
www ietf org html charters ipsec charter html 
michael george luby 
pseudorandomness cryptographic applications 
princeton computer science notes 
merkle 
certified digital signature 
gilles brassard editor advances cryptology crypto pages berlin 
springer verlag 
lecture notes computer science volume 
ralph merkle 
protocols public key cryptosystems 
ieee symposium security privacy 
david mills 
network time protocol version specification implementation analysis 
internet request comments march 
rfc 
naor yung 
universal way hash functions cryptographic applications 
proceedings annual acm symposium theory computing stoc 
paxson 
internet packet dynamics 
ieee acm transactions networking june 
rabin 
information dispersal algorithm applications 
ronald rivest 
md message digest algorithm 
internet request comments april 
rfc 
ronald rivest adi shamir leonard adleman 
method obtaining digital signatures public key cryptosystems 
communications acm 
pankaj rohatgi 
compact fast hybrid signature scheme multicast packet authentication 
th acm conference computer communications security november 
secure multicast user group 
www com community 
paul syverson stuart stubblebine david goldschlag 
unlinkable serial transactions 
financial cryptography springer verlag lncs 
wong lam 
digital signatures flows multicasts 
proc 
ieee icnp 
yajnik moon kurose towsley 
measurement modelling temporal dependence packet loss 
ieee infocom new york ny march 
proof security appendix formal statement security assumptions cryptographic primitives sketch proof security stream authentication schemes 
primitives schemes 
message authentication codes macs 
function family key length taken security parameter secure mac family adversary resources bounded polynomial succeeds game negligible probability 
random bit key chosen adaptively choose messages receive corresponding mac values succeeds manages forge mac outputs pair see details 
pseudorandom functions prfs 
function family key length taken security parameter pseudorandom function family adversary resources bounded distinguish function chosen randomly kept secret totally random function negligible probability 
function chosen random bit key random function range 
gets ask value points likes 
unable tell random pseudorandom 
see details 
schemes property pseudorandom functions long key random pseudorandom remains unknown value pseudorandom fixed known 
schemes arbitrary value allows securely iterate pseudorandom 
furthermore value dent long remains secret key different cryptographic transforms mac 
cryptographically indepen target collision resistance 
function family key length taken security parameter target collision resistant adversary resources bounded polynomial win game negligible probability 
generates value common domain bit key randomly chosen wins generates implies nd pre image collision resistance 
details 
see note target collision resistance scheme prf family flavor target collision resistance 
key chosen random adversary adversary assumed unable negligible probability find prf family secure mac family schemes function family purposes 
clarity sequel differentiate cryptographic functionality prf mac 
addition digital signatures secure chosen message attacks see sender holds signing key receivers hold corresponding public verification key 
way receivers obtain verification key left scope 
security analysis scheme iii brevity sketch proof security tesla schemes specifically scheme iii 
theorem 
assume prf mac signature schemes secure prf tcr property described section scheme iv secure stream authentication scheme 
proof sketch 
simplicity assume mac prf realized function family 
implementation hmac 
assume contradiction scheme iii secure stream authentication scheme 
means adversary controls communication links manages nonnegligible probability deliver message receiver fact need full security guarantee prf 
suffices length doubling pseudorandom generator similar tcr property described 
simplicity describe schemes ones full fledged prf 
sender sent authentic coming accepts show break security underlying cryptographic primitives 
specifically construct distinguisher uses break security function family gets access black box tell non negligible probability function random secret key alternatively totally random function 
purpose query inputs choice answered distinguisher works running follows 
essentially simulates network sender receiver random 
chooses number total number messages sent stream 
hopes forge th message 
chooses signing verification keys hands verification key 
hands initial message message signed signing key contains key plus starting time duration time interval 
key generated scheme twist recall scheme randomly chosen value appropriate length 

messages stream runs sender algorithm scheme iii modifications 
message generated handed 
message generated scheme iii exception scheme mac equal actual data message lets mac 
inspects messages delivers receiver moment receives time 
times taken locally delivers message different valid mac respect form decides chosen pseudorandom family successfully forge message decides random function 
sketch argument demonstrating succeeds non negligible probability 
truly random function negligible probability successfully forge th message stream 
random wrong decision negligible probability 
hand assumed authentication done message non negligible probability follows th message probability furthermore timing assumption guarantees prior time follows taken right decision probability non negligible 
argument fails hands forged initial message adversary finds key different time cases security signature scheme target collision resistance compromised respectively 

