storing semistructured data stored deutsch lambda univ pennsylvania gradient cis upenn edu mary fernandez labs mff research att com dan suciu labs suciu research att com systems managing querying semistructured data sources store data proprietary object repositories tagged text format :10.1.1.45.8397
describe technique relational database management systems store manage semistructured data :10.1.1.45.8397
technique relies mapping semistructured data model relational data model expressed query language called stored :10.1.1.45.8397
data instance stored mapping generated automatically data mining techniques :10.1.1.45.8397
interested applying stored xml data instance semistructured data :10.1.1.45.8397
show document type descriptor dtd exploited improve performance 
semistructured data ubiquitous :10.1.1.45.8397
emergence xml data format semistructured data increase availability semistructured data :10.1.1.45.8397
data best defined graph self describing object instance model :10.1.1.45.8397
data consists collection objects object atomic integer string image audio video complex set attribute object pairs :10.1.1.45.8397
attribute names stored data data self describing :10.1.1.45.8397
existing systems managing querying semistructured data sources store schema data :10.1.1.45.8397
lorel tsimmis store data graphs schema stored attributes labeling graph edges :10.1.1.45.8397
strudel stores data externally structured text internally graph 
xml stored proprietary object repositories text files tags encode schema :10.1.1.45.8397
storing schema data provides flexibility required semistructured data :10.1.1.45.8397
data integration example data new sources loaded immediately lambda part done author visited labs :10.1.1.45.8397
regardless structure changes structure old sources handled seamlessly 
flexibility incurs space cost schema replicated data item time cost additional processing replicated schema :10.1.1.45.8397
fundamental disadvantage commercial rdbms managing semistructured data :10.1.1.45.8397
describe technique rdbms store query manage semistructured data :10.1.1.45.8397
semistructured data stored ternary relation data edge labeled graph better storing schema data :10.1.1.45.8397
technique relies aggressive mapping semistructured data model relational model :10.1.1.45.8397
mapping expressed stored semistructured relational data declarative query language :10.1.1.45.8397
relational schema chosen stored mapping translates semistructured data instance schema :10.1.1.45.8397
mapping lossless parts semistructured data fit schema stored overflow graph :10.1.1.45.8397
expect technique store manage efficiently existing semistructured data sources convert relational sources semistructured format xml :10.1.1.45.8397
application semistructured data instance exists large xml file :10.1.1.45.8397
main issue generating relational schema stored mapping automatically patterns discovered data instance :10.1.1.45.8397
subsequently queries updates semistructured view automatically rewritten queries updates relational store :10.1.1.45.8397
query mix known advance may generation phase :10.1.1.45.8397
data query mix changes performance relational storage may degrade new mapping generated relational data reorganized 
second application relational data source exported semistructured view xml view :10.1.1.45.8397
case stored mapping defined application writer :10.1.1.45.8397
application easier mapping need generated automatically :10.1.1.45.8397
expect application important information providers export data xml :10.1.1.45.8397
semistructured data instance gen erate relational schema stored mapping schema :10.1.1.45.8397
meaning depends application usually includes minimizing disk space reducing data fragmentation satisfying constraints rdbms maximum number attributes relation :10.1.1.45.8397
query mix semistructured data known relational storage reduces weighted cost queries :10.1.1.45.8397
modeled cost optimization problem :10.1.1.45.8397
optimization problems query plans data warehouse design input data instance set queries :10.1.1.45.8397
problem np hard size data :10.1.1.45.8397
reason pursue cost bases approach developed heuristic algorithm :10.1.1.45.8397
wang li described data mining algorithm semistructured data adapt algorithm problem :10.1.1.45.8397
result data mining phase produce reasonable relational schema stored mapping :10.1.1.45.8397
relational mapping stored query system automatically generates overflow mapping necessary ensure semistructured instance stored :10.1.1.45.8397
part stored mapping specifies objects object parts stored overflow graph :10.1.1.45.8397
mapping lossless data instance support updates propagated relational store overflow graph 
overflow mappings unnecessarily conservative xml data show dtd simplify overflow mappings 
complete stored mapping system accepts queries updates semistructured source rewrites queries updates relational source :10.1.1.45.8397
rewriting relational datalog queries understood problem :10.1.1.57.1452:10.1.1.45.8397
stored new query language novel features revisit query rewriting :10.1.1.45.8397
show arbitrary queries semistructured data regular expressions tree patterns rewritten terms stored mappings :10.1.1.45.8397
updates important 
show insertions semistructured data automatically rewritten insertions relational overflow stores :10.1.1.45.8397
contributions ffl stored declarative language specifying storage mappings semistructured data model relational model plus overflow graphs :10.1.1.45.8397
ffl schema generation algorithm constructs relational schema stored mappings semistructured data instance possibly query mix :10.1.1.45.8397
ffl algorithm automatic generation stored overflow mappings relational mapping exploit dtd 
ffl query update rewriting algorithm 
may consider input query mix size negligible compared data :10.1.1.45.8397
audit taxpayer taxpayer taxpayer audited owner address street number zip name name instance semistructured data :10.1.1.45.8397
values object identifiers omitted 
audit taxpayer name address street zip audited taxamount taxpayer name address street number zip audited audited taxamount taxpayer name address russia audited taxamount name rocket propulsion owner textual representation data example mapping 
semistructured model ordered version oem model :10.1.1.45.8397
data consists collection objects object complex atomic :10.1.1.45.8397
complex object ordered set attribute object pairs atomic object atomic value type int string video data graph edges labeled attributes leaves labeled atomic values :10.1.1.45.8397
data exchanged text representation data graph fig :10.1.1.45.8397
represented textually fig :10.1.1.45.8397

order object attributes difference oem model order storing data :10.1.1.45.8397
order order text representation obtained way 
text representation specifies data format 
specify arbitrary graphs write object identifiers value audit owner attribute fig 
object :10.1.1.45.8397
consider data tree :10.1.1.45.8397
object identifiers text representation optional 
object identifier specified object assigned unique identifier automatically :10.1.1.45.8397
assumptions consistent xml :10.1.1.45.8397
taxpayer oid name street apt zip audit audit taxamount taxpayer oid name address audited taxamount name owner rocket propulsion relational storage example kind mapping relational schema base technique :10.1.1.45.8397
choice relational schema corresponding instance fig :10.1.1.45.8397

separate objects types taxpayers companies stored separately 
separate taxpayers complex address string valued address 
decomposition objects uniform nulls :10.1.1.45.8397
table taxpayer attributes audit audit accommodate objects occurrences audit attribute 
object identifiers semistructured data omitted :10.1.1.45.8397
actual mapping explicitly defined implied choice attribute table names :10.1.1.45.8397
instance path audit taxpayer name mapped name taxpayer name taxpayer path audit taxpayer audited mapped audit audit taxpayer audit taxpayer :10.1.1.45.8397
data fig 
managed rdbms 
semistructured data schema stored data :10.1.1.45.8397
course choice unique necessarily best :10.1.1.45.8397
example store taxpayers relation split addresses depending structure 
updates semistructured data instance accommodated chosen relational storage :10.1.1.45.8397
example add new taxpayer phone attribute 
store data overflow graph 
semistructured data repository store overflow graph :10.1.1.45.8397
efficiency crucial overflow graph small :10.1.1.45.8397
system issues arise integration relational storage semistructured overflow addressed :10.1.1.45.8397
sec 
introduce stored language sec 
describe algorithm automatically generating relational stored mappings data instance 
sec 
shows generate automatically overflow mappings 
sec 
describes query update rewriting algorithms sec 
reports experimental results 
stored describe stored semistructured relational data :10.1.1.45.8397
relational schema collection relation names rm arities nm :10.1.1.45.8397
overflow schema collection graph names gk :10.1.1.45.8397
conceptually graph gi contains unary relation gi roots ternary gi edges object identifiers attribute name 
mixed schema contains relational schema overflow schema 
stored mapping translates semistructured data instances mixed schema :10.1.1.45.8397
stored restrictive query languages semistructured data doesn joins expressions :10.1.1.45.8397
ensures possible reconstruct data instance transformation mixed schema :10.1.1.45.8397
simple storage queries 
stored mapping consists store queries :10.1.1.45.8397
clause single pattern binds variables :10.1.1.45.8397
store clause states values bound variables stored 
example nested addr objects flattened ary relation audit taxpayer name addr street zip store clause defines unique key variable default variable pattern :10.1.1.45.8397
binding key variable matches pattern causes tuple stored store clause 
patterns sequences attribute constants 
variables clause store clause intermediate variables may removed pattern necessary write addr zip zg 
store optional attributes audit taxpayer name addr street zip opt audited taxamount store name addr street addr zip required attributes columns non null audited taxamount optional 
missing attributes null :10.1.1.45.8397
check audited taxamount independently audit taxpayer name addr street zip opt audited opt taxamount store stored pattern required subpattern arbitrary number opt subpatterns nested opt subpattern required subpattern opt subpatterns 
matching succeeds object required subpattern matches object successful matching binds required variables 
opt subpatterns tentatively matched starting required subpatterns 
stored mapping may contain queries 
example shows cluster taxpayers relations combinations attributes audit taxpayer name addr opt audited opt taxamount typeof string store audit taxpayer name addr street opt city opt zip opt audited opt taxamount store ap taxpayers addr attribute type string stored :10.1.1.45.8397
case street city optional :10.1.1.45.8397
city zip optional :10.1.1.45.8397
store clause refer distinct relation example simplify reconstructing semistructured data :10.1.1.45.8397
example succeed object conditions addr mutually exclusive :10.1.1.45.8397
general queries may succeed single object may stored multiple relations 
replication desirable rewriting queries permits system choose target relation best matches query incurs higher cost disk space :10.1.1.45.8397
multiple attributes 
characteristic semistructured data objects may multiple occurrences attribute example person may phone attributes subordinate attributes :10.1.1.45.8397
distinguish classes multiply occurring attributes :10.1.1.45.8397
small set attribute usually low cardinality people phone may :10.1.1.45.8397
collection attribute denotes collection objects usually high cardinality usually subordinates 
small set attributes may increase number columns relation accommodate occurrences collection attributes may store attributes nested separate relation 
show express classes stored 
audited attribute occasionally occurs twice audit taxpayer name audited opt audited store stores objects audited attribute value may null 
declarative semantics object audited attributes values valid bindings 
context suffices store single permutation 
order data model 
conceptually stored queries rewritten occurrence attribute name uniquely indexed audit taxpayer name audited opt audited store precise zip city stored city zip stored :10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
attributes key variable enumerated audit taxpayer 
data object enumerate attributes audited attributes audited audited guarantees matching pattern data unique :10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
collection attributes stored nested relations separate relations nested relations supported 
example assume collection attribute hearing audit store audit hearing tn decision key store stores mapping :10.1.1.45.8397
key variable variable declared explicitly :10.1.1.45.8397
stored requires key variable outside subpattern tn declared key variable 
label variables 
instances semistructured data store data attributes :10.1.1.45.8397
example person name attribute name data john phone fax joe phone fax 
stored supports label variables stored relations values 
label variables occur key variable example data phone fax store overflow queries 
far described relational queries target relations mixed schema 
describe overflow queries targeting overflow graphs 
example consider relational query audit taxpayer name opt address street city store complement overflow queries storing attributes name address street address city audit taxpayer name opt address overflow audit taxpayer name address street city overflow syntactically overflow queries resemble relational ones attribute variable occurs pattern stored overflow graph overflow statement :10.1.1.45.8397
illustrate semantics 
assume bound object identifier matching name possibly address bound successively attributes :10.1.1.45.8397
binding attribute name value stored roots edge stored edges subtree rooted stored edges :10.1.1.45.8397
note object name address attributes stored stored :10.1.1.45.8397
similarly stores subobjects address occurrence street city 
object reconstructed 
convenience value key variable stored roots actual root subgraph stored :10.1.1.45.8397
example stored roots edges actual value attribute :10.1.1.45.8397
overflow queries nested patterns containing attribute variable 
addition storing relations relational repository overflow graphs stored semistructured data object repository :10.1.1.45.8397
integrating relational overflow systems necessary preserve flexibility original semistructured data :10.1.1.45.8397
performance requirements overflow system demanding stand object repository relational system handles data 
generating storage mappings describe generate automatically relational stored mapping semistructured data instance overflow mapping deferred sec :10.1.1.45.8397

competing goals determine effectiveness 
want limit number tables 
rdbms limit number tables storing object separate table undesirable :10.1.1.45.8397
second want bound disk space :10.1.1.45.8397
size data instance fixed relational storage may arbitrarily large object may stored relation :10.1.1.45.8397
related goal minimizing number nulls :10.1.1.45.8397
rdbms store nulls efficiently null entry record requires byte nulls record take space 
want generate wide sparse tables byte null entry expensive 
related restriction rdbms impose upper limit number attributes table :10.1.1.45.8397
depending application goals may include reducing object splits redundant storage multiple relations contrary increasing object redundancy improve query evaluation 
goals best modeled cost optimization problem 
data instance generate stored mapping minimizes storage cost function cost storing 
generator accommodate hard constraints limit attributes table 
query mix fq considered 
stored mapping query qi rewritten relational query oracle imposes limit 
parameter name meaning max tables max attributes table max disk space collection size threshold supp min support table storage generation parameters sec :10.1.1.45.8397

weight fi query qi query cost function denotes cost evaluating relational data second goal minimize query cost function fid :10.1.1.45.8397
optimization problem applied combined cost 
unfortunately storage cost cost optimization problem np hard size input data reduction rectilinear picture compression problem :10.1.1.45.8397
theorem problem computing optimal storage mapping np hard size semistructured data daunting complexity :10.1.1.45.8397
typically query optimization problems np complete size query problem np hard size data :10.1.1.45.8397
search algorithms dynamic programming consider heuristics starting frequent patterns data discovered data mining :10.1.1.45.8397
wang li describe data mining algorithm semistructured data :10.1.1.45.8397
review briefly refer wl algorithm 
wl data mining algorithm 
wl data model large collection semistructured objects graph roots :10.1.1.45.8397
wl algorithms searches tree patterns trees consisting attribute constants symbol means attribute :10.1.1.45.8397
attributes indexed wl allow multiple attribute occurrences 
example wl pattern notation name phone phone address street city zip support pattern number root objects contain name phones address containing street city zip :10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
particular semistructured instance minimum support wl algorithm steps :10.1.1.45.8397
finds paths high support set paths called :10.1.1.45.8397
second step adaptation standard algorithm items replaced paths itemsets tree patterns wl setting ordered set paths uniquely corresponds pattern tree leaves :10.1.1.40.6984:10.1.1.45.8397
algorithm generates successively sets fk fk consists sets paths associated pattern trees high support :10.1.1.45.8397
storage generation algorithm 
storage generation algorithm parameters listed table :10.1.1.45.8397
generates relational storage tables having attributes total disk space assume fixed length records :10.1.1.45.8397
distinguishes small sets collections :10.1.1.45.8397
attribute occurrences small set algorithm attempts produce column member set :10.1.1.45.8397
attributes occurrences represented nested relations 
supp minimum support parameter datamining algorithm chosen tuned database administrator :10.1.1.45.8397
define type pattern called storage patterns different wl patterns 
storage pattern form prefix body :10.1.1.45.8397
prefix word lk labels lk attribute name wildcard similar wl :10.1.1.45.8397
label lk attribute name 
body form fl lp bpg bp bodies label indexed attribute denoting occurrences attribute denoting nested collection :10.1.1.45.8397
example pattern audit taxpayer name phone address street city intuitively pattern contained taxpayer objects name phones addresses streets cities :10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
note phone missing highest index occurs pattern :10.1.1.45.8397:10.1.1.45.8397
relationship patterns stored mappings formalized :10.1.1.45.8397
pattern semistructured data instance pattern support defined follows :10.1.1.45.8397
objects reachable root path matching prefix support defined number objects oi contain body containment defined follows :10.1.1.45.8397
replace occurrence label 
assuming fl lp bpg object contains iff label lj form object outgoing edges labeled objects oi oi contains pattern bj 
queries semistructured data data patterns specify paths match input data example queries sec :10.1.1.45.8397

algorithm converts query pattern data tree extends data mining algorithms new data items 
conditions queries patterns ignored 
weight query patterns converted occurrences corresponding data tree :10.1.1.45.8397
queries may contain regular path expressions data trees may edges labeled regular path expressions definition containment extended obvious way case oi contains regular path expressions :10.1.1.45.8397
query mix qk weights fk define query support storage pattern sum fi contained qi :10.1.1.45.8397
mixed support sum data support query support :10.1.1.45.8397
algorithm automatic storage generation input supp query mix output set relational stored mappings method step find minimal prefixes data support supp step run wl data mining algorithm changes text 
number maximally contained patterns step select patterns step patterns select set required attributes step patterns required attributes generate stored relational queries 
automatic storage generation algorithm explain step algorithm appears fig 

step compute minimal path prefixes 
generate prefixes lk support supp 
requires single pass data construct trie structure memory encodes prefixes data :10.1.1.45.8397
trie node uniquely corresponds prefix outgoing attributes discovered data plus wildcard :10.1.1.45.8397
start empty trie extend traverse data 
trie node stores support prefix 
trie node reaches minimal support supp delete tree underneath expand node 
prefix high support identifies collection objects semistructured data instance root objects data mining algorithm step :10.1.1.45.8397
step data mining 
wl data mining algorithm changes 
compute data support combined support data plus query support 
algorithm guided combined support patterns grown long combined support large :10.1.1.45.8397
second keep backpointers subpatterns high data support information step :10.1.1.45.8397
recall wl algorithm generates new set paths fk combining sets gamma paths fk gamma 
store backpointer whichever parent pattern higher data support 
means non maximal patterns fk gamma deleted phase increases memory usage :10.1.1.45.8397
increase prohibitive additional sets retained set fk :10.1.1.45.8397
terminate algorithm combined support decreases supp reaches step select patterns 
step maximally contained patterns support supp 
recall wl algorithm retains set highly supported paths 
greedy algorithm select subset patterns best cover paths 
sort data support start picking pattern covers contains paths highest support 
general pick pattern pk minimize maximum overlap pk gamma case ties cover paths highest support uncovered :10.1.1.45.8397
cover paths reaches maximum number relations allowed 
step select required attributes 
patterns selected step chain backpointers strictly smaller subpatterns rn increasing data support rn 
step choose pattern subpattern ri required part attempt choose small pattern fewest attributes pattern match semistructured objects mapping associated choosing small increase number nulls overlap set objects stored different relations increase total disk space :10.1.1.45.8397
disk space requirement computed data supports :10.1.1.45.8397
step initialize counter pattern increment round robin fashion limit allowed disk space addition incrementing patterns containing required part allow contain required part reducing required part :10.1.1.45.8397
step generate stored queries 
storage pattern required subpattern converted stored queries :10.1.1.45.8397
pretty straightforward :10.1.1.45.8397
example pattern subpattern audit taxpayer name phone address street city audit taxpayer name phone associate stored queries audit taxpayer name phone opt phone store audit taxpayer address street city key store collection attribute address results nested relation rdbms supports separate relation example assumed separate relation :10.1.1.40.6984:10.1.1.45.8397
generating overflow mappings sec 
showed generate automatically relational mapping data instance 
show construct accompanying overflow mapping ensures storage lossless :10.1.1.45.8397
known semistructured data overflow queries needed tend complex :10.1.1.45.8397
practice specifying overflow queries simpler information data structure :10.1.1.45.8397
information available instance structure xml data specified dtd :10.1.1.45.8397
discuss overflow mappings context semistructured data schemas :10.1.1.45.8397
consider schema schema audit taxpayer name string address string address string schema year string amount string extension string specifies data arbitrarily taxpayers name addresses arbitrarily 
type meaning year amount zero extensions 
multiple types defined recursion permitted :10.1.1.45.8397
example illustrates schemas may contain regular expressions usual operators alternation kleene star zero concatenation dtd :10.1.1.45.8397
dtds regular expressions unordered 
schemas may contain attribute variables simple inequalities may imposed variables 
example schema audit taxpayer name string address street string zip int 
zip name address schema taxpayers exactly name address number additional attributes different name address 
note schema semistructured data :10.1.1.45.8397
particular interest known data assume schema :10.1.1.45.8397
schemas lead quickly high complexity power needed practice :10.1.1.45.8397
instance allow define useless types schema fname string office string office string specifies person number offices 
consider restricted schemas 
restricted schema schema regular expression concatenation expressions form :10.1.1.45.8397
schemas defined restricted schemas :10.1.1.45.8397
schema converted restricted schema sr performing transformations repeatedly denote pairs 









algorithm automatic overflow generation input relational mapping schema output overflow mapping method step attribute construct set databases da step da compute stored generate overflow mapping generation overflow mappings remainder section abbreviated notation restricted schemas indicating attributes ranges :10.1.1.45.8397
example schema denoted audit taxpayer name address year amount extension range number number :10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
range abbreviated :10.1.1.45.8397
describe algorithm overflow generation relational stored mapping restricted schema presentation purposes assume non recursive variables attribute occurs equivalent tree attribute occurring exactly labeled range denoted range :10.1.1.45.8397
relax assumptions 
start indexing attribute names sec 

attribute name define high maximum index indexed occurs key variable high :10.1.1.45.8397
illustrate algorithm stored mapping audit taxpayer name address opt year amount extension store audit taxpayer year amount key store high audit high taxpayer high name high address high high year high amount high extension algorithm shown fig :10.1.1.45.8397:10.1.1.45.8397
illustrated fig :10.1.1.45.8397
schema relational stored queries 
step constructs set da canonical databases attribute intuitively databases challenge prove store attribute da obtained recursively traversing tree associated creating attribute copies labeled possibly follows :10.1.1.40.6984:10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
range ffl ancestor create copies :10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
taxpayer taxpayer audit name audit name name taxpayer audit address name address name address address audit taxpayer taxpayer amount audit extension extension year address amount address amount year year year amount extension named canonical databases schema ffl ancestor choose certain create copies labeled :10.1.1.40.6984:10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
value results different database da 
high choosen :10.1.1.45.8397
number choosen min :10.1.1.45.8397
fig 
depicts construction da attributes attributes audit taxpayer similar 
step algorithm evaluates canonical database da checks stores value attribute overflow query generated :10.1.1.45.8397
fig 
happens cases address extension edges :10.1.1.40.6984:10.1.1.45.8397:10.1.1.45.8397
corresponding overflow queries generated obvious fashion 
example queries audit taxpayer name address address overflow audit taxpayer name address year amount 
extension overflow address restrictions algorithm 
recursive types handled unfolding 
general results infinite tree finite portion needs considered queries non recursive regular path expressions :10.1.1.45.8397
second label variables occur constants canonical databases 
conceptually attribute constants occurring algorithm query rewriting input stored mapping user query output set rewritten queries qk mixed schema method step preprocessing construct inversion rules construct canonical data instance step compute ignoring conditions step answer compute minimal covers answer inversion rules step cover generate query qi adding conditions gluing inversion rules rewriting algorithm query schema algorithm takes account evaluating repeated attributes schema handled replacing concatenation attributes :10.1.1.45.8397
query update rewriting stored mapping system accepts queries updates semistructured data rewrites queries updates relational store overflow graphs :10.1.1.45.8397
section describes rewriting algorithm :10.1.1.45.8397
start query rewriting address update rewriting 
algorithm appears fig 

explain illustrate stored mapping ma audit taxpayer name firstname fn lastname ln addr street city opt taxamount store taxpayer fn ln mb audit taxpayer addr street city overflow mc audit taxpayer name opt taxamount overflow example query returns names ers taxamount come form address contains philadelphia select audit taxpayer name taxamount form income address philadelphia note query returns set name oids firstname lastname :10.1.1.45.8397:10.1.1.45.8397
queries consider patterns regular expressions clause arbitrary conditions clause joins allowed 
ia taxpayer fn ln construct audit audit taxpayer taxpayer name name firstname firstname fn lastname lastname ln addr addr street street city city ia taxpayer fn ln null construct audit audit taxpayer taxpayer taxamount taxamount ib roots edges construct audit audit taxpayer taxpayer addr addr ic roots edges taxamount construct audit audit taxpayer taxpayer inversion rules query common features query languages semistructured data :10.1.1.32.3916:10.1.1.45.8397
step preprocessing step starts constructing inversion rules queries step adaptation inversion rules query rewriting :10.1.1.57.1452:10.1.1.45.8397
context rules generated internally system intended user 
describe concrete syntax presentation purposes 
rule consists construct clause :10.1.1.45.8397
construct clause contains tree constructor node oids generated skolem functions turn correspond attribute names including indexes 
example inversion rules shown fig 
skolem functions audit taxpayer name relational query inversion rule created required subpattern inversion rule opt subpattern :10.1.1.45.8397
overflow query single inversion rule created required subpattern opt subpatterns ignored :10.1.1.45.8397
ia ia created ma ib ic created mb mc respectively 
inversion rules property reconstruct entire semistructured data :10.1.1.57.1452:10.1.1.45.8397
step continues constructing single canonical data instance inversion rules 
fusing symbolic objects construct clauses inversion rules fig :10.1.1.45.8397

nodes labeled skolem function names overflow graph names edges unlabeled target overflow graph labeled attribute name :10.1.1.45.8397
addition edges annotated name inversion rule ia ia ib ic 
steps actual rewriting related query decomposition algebraic optimization mediator specification language msl :10.1.1.45.8397
step simple computation query conditions clause checked ia audit ia ia ib ic taxpayer taxamount ia ia ic addr ia ib ia taxamount street ia city ia ib addr city name name firstname lastname street taxamount audit ia ia ib ic taxpayer canonical data instance dotted edge extension updates :10.1.1.45.8397
unlabeled edges may match attribute query 
example result evaluation taxpayer name taxamount street taxpayer name taxamount city taxpayer name taxamount taxpayer name street taxpayer name city taxpayer name taxpayer taxamount street taxpayer taxamount city taxpayer taxamount taxpayer street taxpayer city taxpayer step considers row answer relation finds minimal covers corresponding subgraph inversion rules :10.1.1.45.8397
consider row edges corresponding subgraph highlighted fig 
unique minimal cover ia ia icg minimal cover step constructs query mixed schema :10.1.1.45.8397
query essentially obtained joining inversion rules cover results new conditions adding conditions original query example resulting query select name firstname firstname fn reconstruct lastname lastname ln name taxpayer fn ln ia ia roots form income ic null ia glue ia ic taxpayer philadelphia query checks philadelphia street position query check city position :10.1.1.45.8397
query reconstructs name skolem functions 
clause contains mixed relational goals taxpayer semistructured data patterns overflow graphs :10.1.1.45.8397
clause may join conditions 
updates 
consider strict subset lorel update statements update object selector :10.1.1.45.8397
object expression 
update object selector 
value expression 
statements object selector 
query result single object identifier object expression :10.1.1.45.8397
constant expression denoting complex value object syntax fig :10.1.1.45.8397

statement adds attribute value pairs order 
second statement replaces value atomic object value expression 
describe rewriting update statement second easier handled similarly :10.1.1.45.8397
update rewriting steps 
object selector 
evaluated canonical database illustrate stored mapping update update select audit taxpayer name lastname smith taxamount referring fig :10.1.1.45.8397
results step taxpayer lastname taxpayer 
illustrate sequel result 
second step row result extend object expression dotted edge fig :10.1.1.45.8397

execute stored query extended object consider results edge extension dotted edges 
result generate update instruction mixed schema 
illustrate queries ma mc 
bindings ma variables taxpayer fn firstname ln street city corresponds update update taxpayer fn ln set ln smith evaluating mc order taxamount attributes fig :10.1.1.45.8397
matters 
bindings mc consider binds new taxamount taxamount mc bound edge :10.1.1.45.8397
translates update update roots edges taxamount taxpayer fn ln ln smith null preliminary experiments ran preliminary experiments automatic stored generation algorithm :10.1.1.45.8397
data set dblp popular database bibliography web site collection xml files :10.1.1.45.8397
explicit structure 
xml file corresponds publication proceedings journal article book phd thesis directory structure captures information :10.1.1.45.8397
example top level contains books conf journals ms persons phd directories 
conf subdirectory www informatik uni trier de ley db instr html bib inproceedings author opt author opt author opt title opt pages pp opt year opt booktitle opt url store pp bib article author opt title opt pages pp opt year opt volume opt journal opt number opt url store pp bib article author author opt author opt pages pp opt year opt volume opt number store pp stored query conference total directory information fully recovered publications :10.1.1.45.8397
typical entry inproceedings key abiteboul :10.1.1.45.8397
author serge abiteboul author title querying semi structured data title pages pages year year booktitle icdt booktitle url db conf icdt icdt html abiteboul url 
inproceedings 
publication data irregular entries multiple author optional url citation attributes unfamiliar attributes :10.1.1.45.8397
attributes scalar values structure 
publications represented semistructured data edges :10.1.1.45.8397
total disk space :10.1.1.45.8397
decided ignore directory structure moved files directory 
chose minimum support :10.1.1.45.8397
articles inproceedings minimum support books phd thesis :10.1.1.45.8397
separate experiment reported lack space considered query mix query high weight referred books 
experiment books minimum support system generated relation storing book objects 
collection attributes citation candidate high support 
nested attributes high support 
fig 
contains example generated stored mapping 
attributes high support inproceedings combination high support single stored query maps inproceedings 
attributes high support article objects split relations tries cover objects requiring author attribute requires authors giving best chance store objects stored 
ran sets experiments varied maximum number attributes relation queries coverage space nulls nulls coverage table effect varying maximum number attributes relation maximum disk space :10.1.1.45.8397
varied total disk space allocated relations results shown table :10.1.1.45.8397
varied attributes high support 
assessed quality algorithm measuring number queries data coverage number nulls 
queries total number relational stored queries generated relations :10.1.1.45.8397
coverage percentage edges stored relations :10.1.1.45.8397
space estimated disk space required relational storage assuming fixed length records :10.1.1.45.8397
nulls represent amount space occupied nulls 
table shows data fragmentation directly depends maximum relation arity 
small objects need split relations joined query time :10.1.1.45.8397
hand space better utilized small number null entries smaller :10.1.1.45.8397
coverage total number edges stored relational part consistent approximately :10.1.1.45.8397
actual overflow graphs larger data overlap exist overflow graphs relational store :10.1.1.45.8397
second set results show clear degradation coverage disk space relations limited :10.1.1.45.8397
small algorithm generates required attributes sec :10.1.1.45.8397
decrease number nulls improve utilization relations covers fewer objects :10.1.1.45.8397
summary reasonable assumptions generated stored queries cover large percentage data exploiting regularities dbpl data instance :10.1.1.45.8397
related discussion data clustering problem grouping large number points rd sets clusters distances points cluster small :10.1.1.45.8397
birch produces clusters just passes large data set 
problem hard model data clustering problem objects widely different structures may stored 
nestorov abiteboul motwani describe clustering algorithm semistructured data extracts schema data :10.1.1.45.8397
sellis describe algorithm relational database instance set queries generates optimal set views best support query set :10.1.1.45.8397
related storage generation problem search relational views semistructured data :10.1.1.45.8397
problem input data instance query set views lossless :10.1.1.45.8397
pioneered idea achieving physical data independence means relational views 
stored follows similar philosophy achieving independence underlying relational storage 
linguistically stored closely related query languages semistructured data lorel unql msl struql provide path expressions matching attribute paths semistructured data :10.1.1.32.3916:10.1.1.45.8397
due unique requirements stored strictly weaker languages :10.1.1.45.8397
object oriented databases store sgml xml documents explicitly storing schema require dtd derive object oriented schema 
effective storage mechanism xml data dtd known applications dtd may exist :10.1.1.45.8397
technique increase data fragmentation new classes objects created convert dtd class hierarchy 
technique complementary require dtd uses rdbms :10.1.1.45.8397
wang li extended data mining techniques semistructured data :10.1.1.45.8397
algorithm finds interesting patterns subtrees high support 
data mining foundation stored generation algorithm search complex patterns attempt cover data :10.1.1.45.8397
applied directly wang li patterns generate simple relational storage covers small fragment data 
storing semistructured data relations ambitious goal models apparently incompatible :10.1.1.45.8397
hypothesis semistructured data sources regular structure outliers structure exploited storing data :10.1.1.45.8397
preliminary experiments dblp bibliography database support hypothesis particular dblp data quite regular outliers escape normal classification :10.1.1.45.8397
abiteboul quass mchugh widom wiener :10.1.1.45.8397
lorel query language semistructured data :10.1.1.45.8397
international journal digital libraries april 
agrawal imielinski swami :10.1.1.40.6984
mining association rules sets items large databases 
proceedings acm sigmod conference management data pages washington dc 
beeri tova milo 
schemas integration translation structured semi structured data 
proceedings international conference database theory 
appear 
peter buneman susan davidson gerd hillebrand dan suciu :10.1.1.32.3916
query language optimization techniques unstructured data 
proceedings acm sigmod international conference management data pages 
christophides abiteboul cluet scholl :10.1.1.45.8397
structured documents novel query facilities 
richard snodgrass marianne winslett editors proceedings acm sigmod international conference management data minneapolis minnesota may :10.1.1.45.8397
mary fernandez daniela florescu kang alon levy dan suciu 
catching boat strudel experience web site management system 
proceedings acm sigmod international conference management data 
mary fernandez daniela florescu alon levy dan suciu 
query language web site management system 
sigmod record september 
garey johnson 
computers intractability guide theory completeness 
freeman san francisco :10.1.1.45.8397
ginsburg 
mathematical theory context free languages 
mcgraw hill 
ohm aberer neuhold yang 
structured document storage refined declarative navigational access mechanisms :10.1.1.45.8397
vldb journal november 
alon levy alberto mendelzon yehoshua sagiv divesh srivastava 
answering queries views 
proceedings th symposium principles database systems san jose ca june 
volz aberer ohm 
applying flexible oodbms irs coupling structured document handling 
conference data engineering february 
nestorov abiteboul motwani 
extracting schema semistructured data :10.1.1.45.8397
proceedings acm conference management data pages 
michael genesereth oliver duschka :10.1.1.57.1452
answering recursive queries views 
proceedings acm symposium principles database systems pages 
papakonstantinou abiteboul garcia molina 
object fusion mediator systems 
proceedings large data bases pages september 
papakonstantinou garcia molina widom 
object exchange heterogeneous information sources 
ieee international conference data engineering pages march 
quass rajaraman sagiv ullman widom 
querying heterogeneous information :10.1.1.45.8397
international conference deductive object oriented databases pages 
dimitri sellis :10.1.1.45.8397
data warehouse configuration 
proceedings international conference large data bases pages athens greece august 
solomon ioannidis :10.1.1.45.8397
gmap tool physical data independence 
proc 
th international vldb conference 
jeffrey ullman 
principles database knowledgebase systems ii new technologies 
computer science press md 
ke wang liu 
discovering typical structures documents road map approach :10.1.1.45.8397
acm sigir conference research development information retrieval august 
tian zhang raghu ramakrishnan miron livny :10.1.1.45.8397
birch efficient data clustering method large databases 
proceedings acm conference management data pages 

