real time occlusion culling models large occluders efficiently identifying polygons visible dynamic synthetic viewpoint important problem computer graphics 
typically visibility determination performed buffer algorithm 
algorithm examine triangle input scene buffering consume significant fraction graphics processing especially architectures low performance software buffer 
way avoid needlessly processing invisible portions scene occlusion culling algorithm discard invisible polygons early graphics pipeline 
exploit presence large occluders urban architectural models design real time occlusion culling algorithm 
algorithm features conservative overestimates set visible polygons exploits spatial coherence hierarchical data structure exploits temporal coherence reusing visibility information computed previous viewpoints 
new algorithm significantly accelerates rendering complex test models 
cr categories subject descriptors computer graphics dimensional graphics realism visible line surface algorithms computer graphics computational geometry object modeling object hierarchies 
additional keywords conservative visibility temporal coherence spatial coherence kd trees 
identifying visible polygons eliminating hidden polygons important component efficient scene rendering algorithms 
despite availability high performance buffer hardware significant fraction graphics machines lesser hardware address technology square cambridge ma email seth 
lcs nit edu permission copies part material fee provided copies distributed profit commercial adv copyright notice title publication date appear notice copyright hy pem acm copy republish post servers redistribute lists specific pem md symposium interactive graphics 
providence lisa copyright acm seth teller computer graphics group mit laboratory computer science buffering capabilities 
software buffering personal computers rendering eck 
architectures test occurs graphics processing shading texture mapping wasting computation invisible portions model 
way address problem develop occlusion culling algorithms efficiently identify render visible portions model tightly bounded superset thereof 
exploit presence large occluders typical architectural urban models design real time occlusion culling algorithm 
algorithm ideas 
propose simple fast visibility test identifies region model completely partially occluded set occluders 
second describe cheap preprocessing step identifies nearby large occluders viewpoints 
hierarchical visibility algorithm repeatedly applies visibility test determine status tree nodes spatial hierarchy 
related model viewpoint exact visibility algorithms compute description image terms visible polygon fragments 
description available processing cm restricted involve visible portions scene 
techniques tend complex difficult interactive applications 
buffer algorithm typically implemented hardware widely 
availability hardware buffers promising overestimate set visible polygons buffer render final image 
idea overestimated conservative visibility exploited design fast architectural walkthrough systems idea subdivide input model cells roughly corresponding rooms building cell cell visibility bound exact visibility method eliminates invisible polygons architectural models generalization models apparent cell structure city models appears difficult 
approach octree spatial subdivision render polygons lie viewing frustum 
algorithm exploit occlusion properties model 
hierarchical buffer algorithm nodes octree hierarchy pyramid resolve visibility queries 
promising approach implementing occlusion culling hardware support difficult realize algorithm current graphics architectures visibility queries supported hardware simulating software entails significant overhead 
reliance image space queries algorithm susceptible aliasing artifacts accompanying incre complexity possible avoid 
dynamic temporally coherent conservative visibility algorithm described identifies relevant visibility events changes visibility occur near 
drawback algorithm reconstruct visibility information continuous sequence points discrete pair subsequent viewpoints assumed moving observer 
algorithms proposed accelerate rendering approximating sets polygons texture maps 
visibility resolved computing texture approximation corresponding set polygons 
textures render frames reducing visibility processing 
texture approximation usually effective faraway polygons little change image viewpoint 
contrast occlusion culling eliminate invisible nearby polygons 
algorithm overview assume input model static set convex polygons number vertices polygon bounded constant 
system uses preprocessing step merge identical input vertices 
useful identifying polygons share edges 
assume priori knowledge observer motion 
algorithm chooses small set occluders culling 
strategy motivated observation interesting models occlusion caused polygons instantaneous viewpoint 
crucially occluders chosen dynamically viewpoint changes polygons typically act occluders nearby viewpoints culled objects remote oblique viewpoints 
usually just single polygon convex region space hierarchical bounding box containing polygons 
viewpoint occluder polygons objects instantaneous viewpoint 
rest organized follows 
section describes algorithm determine conservative visibility status respect set occluders 
test basis visibility oracle dynamic algorithm section 
section presents performance characteristics algorithm section concludes 
conservative testing section addresses problem viewpoint set convex occluders convex visible 
exists line segment viewpoint point meets occluder 
method answering query uses notion supporting planes 
separating planes objects planes formed edge object vertex objects lie opposite sides plane 
supporting planes analogous objects lie side plane 

shows occlusion dimensions planar cross section 
separating supporting planes occluder shown synthetic viewpoint 
interaction single occluder typically bounding box 
completely described terms plane occluder supporting separating planes occluder 
occlude viewpoint lies half space contain region divided qualitatively distinct regions shown 
region occluded region partially occluded region completely occluded supporting separating planes detect cases holds 
planes oriented occluder form half spaces 
say viewpoint satisfies plane iff inside plane positive half space relation checked performing inner product viewpoint plane equation 
full occlusion occurs supporting planes satisfied viewpoint intersection supporting half spaces region 
partial occlusion occurs oriented separating planes satisfied supporting plane region 
occlusion region 
shows occlusion caused connected occluders share edge 
viewpoint shaded region occluded combined effect occludes 
case handled ignoring supporting planes non silhouette shared edges edge polygons adjacent partially occlude note occlusion occurs lie opposite sides seen viewpoint intuitively relevant silhouette edge occluder seen viewpoint 
shows case ignoring supporting plane dashed cause classified incorrectly fully occluded 
general set occluders ai jointly occludes 
ak partially occlude fully occludes occluders aj share edge lie opposite sides seen viewpoint shows supporting planes shared silhouette edges ignored 
signed distances viewpoint supporting common edges positive 
algorithm simple implement supporting separating planes corresponding single occluder 
efficient way compute described section 



occlusion connected occluders shows occlusion seen viewpoint 
part shows occlusion caused connected occluders silhouette convex image 
part shows occlusion connected occluders having non convex silhouette 
part shows occlusion set disconnected occluders 
consider depicts different occlusion cases 
test described detects occlusion supporting planes internal edges ignored lies entirely convex silhouette image 
conservative visibility test may detect occlusion silhouette edges form non convex polygon 
case test fails appears cross line supporting edge image 
test detect occlusion caused set disconnected occluders 
practice reasonable tradeoff architectural urban models occlusion due large occluders acting part connected set 
note visibility test conservative misclassifies visible entity occluded 
computing supporting separating planes principle possible precompute planes formed pairs 
wasteful fraction planes 
hy method combines preprocessing run time table lookups compute supporting sepa rating formed arbitrary occluder axial bounding box 
tangent planes polygon edge restrict sep ating supporting planes occluder pair set tangent planes formed occluder edges vertices ignore formed occluder vertices edges 
assembling planes provides exact test full occlusion conservative test partial occlusion 
tangent vertices consequently tangent planes occluder edge computed steps 

translate occludes bounding box origin vertex edge 
determine silhouette bounding box seen origin table lookup box vertices 
projection respect origin direction box occluder edge projects single point 
determine tangents point box silhouette 
property tangency origin silhouette edges axial bounding box viewed origin 
retained projection tangent vertices determined tangent vertices 
computing tangent vertices table lookup location edge projection respect silhouette edges 
due special properties silhouette edges projection axial edges respect origin computation easily performed 
projection box respect origin shown 
regions induced extended silhouette edges numbered bit codes consisting signs dot products directed silhouette lines 
tangent vertices determined location occluder edge projection 
method speeds computation supporting separating planes key component visibility test order magnitude naive method computing checking planes vertex bounding box 
kd tree node viewpoint os occlude subtree visible report gather os occluded subtree invisible omit return leaf gather os conservative report visible ai lj determine occluder set ai partially occludes lj ai child apply subtrees visible os visibility algorithm applying visibility test possible visual interaction resources polygons expensive 
techniques reduce number tests performed 
operates data structure tree organizing model polygons 
second dynamically maintained set occluders near viewpoint determine occlusion section 
kd tree visibility algorithm reports polygons kd tree occluded specified 
algorithm gather os simply collects polygons reachable kd tree node unions set os 
determines visibility status respect occluders set viewed algorithm described section 
visibility algorithm recursively applies conservative visibility test determine visibility stat kd tree node 
conservative visibility test ia applied determine current node invisible 
algorithm returns performing entire subtree rooted current node occluded 
fails algorithm recurses occluders partially kd tree node occluders occlude descendant kd tree node 
complexity complexity th algorithm ku number kd tree nodes visited aud visibility algorithm 
number occluders 
worst case complexity kn algorithm tests kd tree occluders 
practice complexity lower ss fraction kd tree nodes tested occluder see section details 
kd tree nodes classified respect single occluder consecutive viewpoints 
clarity subdivision kd tree assumed occur center kd tree node 
spatial coherence shows kd tree visited visibility classification hierarchy respect single occluder consecutive viewpoints 
note hierarchy exploits spatial coherence avoiding testing nodes completely occluded node completely visible node 
temporal coherence moving observer algorithm caches occlusion relations list supporting separating planes visited kd tree node 
viewpoint changes algorithm need check existing occlusion relations update kd tree nodes visibility stat changed 
example nodes dark region node checked occluder traversals 
nodes separating supporting planes needed determine visibility status computed viewpoint reused 
cache entries corresponding node maintained node longer involved visibility calculation ancestor node fully occluded fully visible 
frustum culling view frustum culling incorporated algorithm straightforward way checking kd tree node inside viewing frustum invoking visibility algorithm 
supporting separating planes computed nodes outside viewing frustum retained cache reused 
dynamic occluder selection algorithm described maintains state kd tree node respect set 
viewpoint moves crucial update occluder set contain polygons large image occlude substantial portions model 
likewise polygons small apparent size ejected set 
simple metric occlusion potential polygon position solid angle position 
reasonable estimate solid angle quantity fi lld represents area occluder represents normal represents viewing direction represents vector viewpoint center occluder 
area angle metric captures properties subtended solid angle polygon making useful approximation 
larger polygons larger area angle 
second area angle falls square distance viewpoint subtended angle 
third maximum area angle occurs viewing direction head occluder falls dot product occluder viewed 
metric differs consider actual shape occluder simpler compute serves useful heuristic identify large occluders near viewpoint 
parameters area angle metric 
possible viewing directions occluder preprocessing algorithm uses area angle metric associate kd tree leaf viewing direction occluders effective viewpoints leaf number occluders supplied preprocessing stage 
interactive model viewing begins algorithm locates kd tree leaf contains initial viewpoint 
algorithm uses set occluders associated kd tree leaf discrete viewing direction closest current viewing direction 
viewpoint moves outside kd tree cell viewing direction changes substantially set occluders modified correspond current viewing position direction 
note observer moving smoothly set occluders effective current viewpoint similar set occluders effective viewpoint little changes need occluder set 
detail objects polygon complexity urban architectural models arises due presence small detail objects furniture building foliage city 
part kd tree hierarchy objects may culled hierarchical culling algorithm 
objects culled axe subjected additional tests 
object tested occluders near object 
tests cull objects large occluders near viewpoint 
detail objects dl occluders determine visibility 
occluders near detail objects determined follows 
detail objects usually limited spatial extent usefully approximated single point center object 
second problem determining detail object visible viewpoint identical problem determining viewpoint visible detail object visibility points 
occluders large viewed center object viewing direction viewpoint candidates test 
identified stored object data structure computed section 
course occluders determined necessary perform visibility test entire detail object separating supporting planes just midpoint 
results implemented algorithm described tools visualizing operation 
models consisting large occluders hundreds additional detail objects algorithm maintains interactive rates sgi workstation mhz processor mb main memory sgi tm graphics pipeline significant fraction models average 
color plate shows snapshots interactive walkthroughs 
studied performance algorithm models fifth floor berkeley soda hall building furniture soda city viewpoint city 
implementation kd tree constructed splitting current node alternately dimensions choosing splitting plane results roughly balanced partitioning polygons 
kd tree height nodes number occluders fixed direction directions experiments 
initialization kd tree construction seconds 
results reported averaged viewpoints visited smooth walkthroughs models 
table shows efficacy culling algorithm 
occlusion culling reduces rendering load terms polygons drawn factor frustum culling 
speedup obtained due reduction rendering load depends performance hardware graphics pipeline lower performance higher benefit occlusion culling 
table shows time spent culling drawing models report times onyx sgi indigo workstation mhz processor powerful graphics hardware 
note algorithm reduces total rendering time factor onyx factor elan 
scene polygons frustum occlusion soda city table column shows percentage polygons drawn view frustum culling column occlusion shows percentage polygons drawn frustum occlusion culling 
scene occlusion cull draw lt ot raw total table columns labeled show culling drawing times view frustum culling 
columns labeled occlusion show culling drawing times frustum occlusion culling 
times reported milliseconds 
spatial temporal coherence visibility algorithm maintains tests kd tree nodes frame nodes viewing frustum reflecting spatial coherence exploited algorithm 
temporal coherence indicated table shows time spent algorithm excluding culling speed observer varied 
experiment observer moves path different speeds 
algorithm spends lesser time slow moving observers reflecting temporal coherence exploited algorithm 
scene time visible msec lx soda city table time spent visibility processing observer moving increasing speed 
speeds multiples slowest speed corresponds walking speed tables 
describes efficient occlusion culling algorithm exploits presence large occluders urban architectural models significant fraction test scenes 
algorithm conservative uses simple object space tests detect occlusion 
organizing polygons kd tree exploits spatial coherence 
caching occlusion relations large occluders viewpoints temporal coherence motion observer 
interesting apply techniques developed models contain large occluders cad models airplanes 
promising approach construct fictitious occluders conservatively approximate occlusion caused large mesh triangles 
investigating strategies adaptively choosing size occluder set dynamically maintained visibility algorithm 
interesting area research integration occlusion culling techniques texture approximation 
occlusion culling techniques especially table lookup may amenable hardware implementation yielding speedups 
jr image realism interactive update ates complex virtual building environments 
acm special issue symposium interactive 
graphics 
sig graph conference proceedings 
bentley multidimensional binary search trees associative searching 
communications acm 
catmull computer display curved surfaces 
phd thesis university utah dec 
teller temporally ent conservative visibility 
proc 
th annual acm computational geometry pp 

funkhouser sequin teller management large amounts data interact ive building 
oc 
workshop interactive pp 

baum interactive viewing large geometric databases multiprocessor graphics workstations 
siggraph course notes parallel thms architectures image generation 
greene kass error bounded rendering complex environments 
ph conference proceedings pp 

greene kass miller hierarchical buffer visibility 
siggraph conference proceedings pp 

luebke georges portals mirrors simple fast evaluation potentially visible sets 
proc 
symposium interactive graphics pp 

shirley visual navigation large environments textured clusters 
proc 
symposium graphics pp 

naylor partitioning image representation generation geometric models 
proc 
graphics interface pp 

shade salesin derose snyder hierarchical image caching accelerated walkthroughs complex environments 
sig graph conference proceedings pp 

sutherland 
sproull schumacher characterization hidden surface algorithms 
computing surveys 
teller sequin visibility preprocessing interactive walkthroughs 
sig graph conference proceedings 
xiong stratified rendering algorithm virtual walkthroughs large environments 
masters thesis eecs department mit may 
