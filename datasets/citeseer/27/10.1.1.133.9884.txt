evolution agents mohammad dissertation submitted partial fulfillment requirements degree doctor philosophy university london 
department computer science university college london january genetic programming gp technique automatically program computers perform required task 
technique kind genetic algorithm rep resentation program parse tree bit string fitness parse trees evaluated executing computer program represents 
subject thesis investigate gp automatically program multiagent systems 
achieve goal consider general problems creating multiagent systems show gp provide solutions 
key contributions follows show possible evolve multi agent systems gp exhibit coordinated coherent behaviour communicate explicitly doing decide communicate resolve conflicts integrated existing society agents consider scalability problems involved gp generally par ticular technique automatically programming agents propose solutions problems 
department computer science ucl awarding ep src phd quota award funded 
supervisor jon crowcroft encouragement support 
william langdon introducing gp providing useful pointers reviewing chapters thesis 
thomas haynes answering questions relating research 
ucl computer science java training jb international allowing machines compute intensive task evolving agents 
contents genetic programming genetic algorithms 
variable length hierarchical representations 
genetic programming 
basic steps 
function terminal sets 
fitness function 
run parameters 
termination criteria 
gp extensions 
automatically defined functions 
strongly typed gp 
steady state gp 
indexed memory data structures 
evolution 
theory 
fitness landscapes 
gp schema theorem 
gp applications 
gpsys 
java programming language 
application programmers interface 
internal data structures 

intelligent agents multiagent systems agents 
contents deliberative architectures 
reactive architectures 
hybrid architectures 
systems 
evolving agents gp 
gp learning technique agents 
evolving complete agents 
task allocation conflict resolution pursuit problem 
pursuit domain investigate task allocation conflict resolution pursuit rules 
fitness function 
fitness evaluation 
function terminal sets 
behavioural analysis 
experiment basic pursuit 
results 
experiment identity 
results 
experiment mixed agents 
results 
experiment conflict resolution 
results 
comparison random search 

communication experiment communicating agents 
architecture 
results 
run 
run 

communicating agents 
contents results 
pursuit agents 
results 

scalability genetic programming solving space problems 
implementation 
tuning problem definition 
performance 
solving processing problems 
speeding fitness processing 
hardware 
machine code gp 
efficient high level languages 
compiled code 
parallel distributed architectures 
reducing fitness function evaluation costs 
deadlock detection 
caching 
reducing wasted computation aborting runs 
simplifying code 
sampling test cases 
redundancy test cases 
improving efficiency gp algorithm 

genetic programming software testing fitness evaluation 
software testing quality control 
definition software testing 
black box testing 
equivalence partitioning 
boundary value analysis 
cause effect graphing 
error guessing 
white box testing 
contents statement coverage 
decision coverage 
condition coverage 
decision condition coverage 
multiple condition coverage 
applying software testing gp 
training phase 
generalisation 
paradox 
testing distributed multi agent systems 

review 
solving key issues mas research 
methodology automatically programming multiagent systems gp environment 
agent classes 
architecture 
function terminal sets 
fitness function 
termination criteria run parameters 
critical assessment 

algorithmic complexity computer programming evolution 
summary 
best evolved pursuit agents experiment basic homogeneous best run 
experiment basic heterogeneous best run 
experiment identity best run 
experiment basic best run 
experiment basic best run 
experiment basic best run 
experiment cro homogeneous best run 
experiment cro homogenous best run generation 
experiment cro homogenous best generations run 
contents experiment cro heterogenous best run 
experiment cro homogenous full evaluation best run 
best evolved communicative agents experiment best agent run 
experiment best agent run 
best agents experiment best communicating agent run 
experiment best pursuit agent run 
experiment best heterogeneous pursuit agent run 
bibliography list figures ga mutation 
ga crossover 
gp mutation 
gp crossover 
difficult search fitness landscape 
easy search fitness landscape 
gpsys high performance gp system 
gpsys parameters uml diagram 
gpsys uml diagram 
screenshot 
environment pursuit domain consists dimensional usually world predators try capture prey surrounding 
pursuit domain movement restricted orthogonal directions capture positions cells immediately adjacent prey prey captured capture positions occupied predators conflicts occur agents try occupy cell 
collision conditions agents tries move cell occupied agent agents try exchange positions agents try move cell 
video player trace movement pursuit agents 
experiment performance graphs evolved homogeneous agents 
experiment performance graphs evolved heterogenous agents 
experiment capture assignment 
experiment performance graphs evolved homogeneous agents identity 
experiment performance graphs evolved mixed agents 
experiment performance graphs evolved mixed agents 
experiment performance graphs evolved mixed agents 
experiment capture position assignment 
list figures experiment capture position assignment 
experiment capture position assignment 
experiment performance graphs evolved homogeneous agents cro 
experiment performance graphs evolved heterogenous agents cro 
experiment test game trace agent movement 
experiment test game trace agent movement 
experiment performance graphs evolved communicating agents 
experiment evolved parse tree best individual run 
experiment evolved parse tree best individual run 
experiment performance graphs communicating agents 
experiment performance graphs homogeneous pursuit agents experiment performance graphs heterogenous pursuit agents experiment capture position assignment 
parallel gp 
experiment performance graphs evolved homogeneous agents full evaluation 
experiment performance graphs evolved homogeneous agents fittest generation 
list tables gp algorithm 
gpsys design goals implementation 


fitness 

pursuit domain parameters 
fitness evaluation pseudo code pursuit problem 
experiments common functions terminals 
experiment problem definition 
experiment fitness best evolved homogeneous agents 
experiment fitness best evolved heterogenous agents 
experiment additional functions terminals 
experiment problem definition 
experiment fitness best evolved homogeneous agents identity 
experiment problem definition 
experiment fitness best evolved mixed agents 
experiment fitness best evolved mixed agents 
experiment fitness best evolved mixed agents 
experiment additional terminals functions 
experiment problem definition 
experiment fitness best evolved homogeneous agents cro 
experiment fitness best evolved heterogenous agents cro 
experiment actions performed terminals functions 
experiment 
evaluation pseudo code 
experiment results evolved communicating agents 
experiment simplified code run 
list tables experiment trace agent movement run 
experiment simplified code run 
experiment trace agent movement run 
experiment results communicating agent 
experiment simplified code run 
experiment fitness best homogeneous pursuit agents 
experiment fitness best heterogenous pursuit agents 
experiment fitness best evolved homogeneous agents full evaluation experiment fitness best evolved homogeneous agents generation experiment fitness best homogeneous agents run re evaluation chapter nature successful programming sophisticated multiagent systems ranging simple agents ants bees sophisticated cognitive agents 
mechanism create systems darwinian evolution 
hypothesis tech nique darwinian evolution called genetic programming gp automati cally program software multiagent systems 
multiagent system interacting intelligent agents pursue set goals perform task 
central question systems agents interact order achieve goals 
answering question difficult raises number issues discussed chapter 
propose genetic programming provide solution question related issues creates problem domain 
genetic programming gp koz relatively new technique uses principle darwinian evolution daw automatically program computers 
gp advantages techniques attempt automatically program agents neural networks conventional genetic algorithms 
important repre sentation gp computer program 
possible humans understand generated solutions predict behaviour compare neural networks 
fur thermore generated programs easily executed current computer architectures require specialised environments 
second advantage gp shown general successfully applied wide variety problems koz koz 
koza claims gp general machine learning technique koz 
prove hypothesis genetic programming automatically program multi agent systems attempt answer questions key issues implementing multiagent systems 
gp capable providing solutions 
problems scaling gp real world multi agent applications 
solve scalability problems 
answers questions supported results experiments 
key contributions follows show possible evolve multiagent systems gp exhibit coordinated coherent behaviour communicate explicitly doing decide communicate resolve conflicts integrated existing society agents consider scalability problems involved gp generally partic ular technique automatically programming agents propose solutions prob lems 
related scalability discuss importance formal software testing techniques development gp technology look issues involved testing mas 
lastly designed implemented state art gp system java programming language freely available complete source code documentation gp community 
system supported kept facilitated gp research believe key contribution gp community 
layout thesis follows chapters introduce genetic programming multiagent systems 
set technical grounding thesis 
research combining fields surveyed overview genetic programming system called gpsys provided 
pursuit problem designed tested researching mas architectures 
haynes sandip hs hs gp evolve heterogeneous homogeneous agents problem 
note whilst successful demonstrating gp decompose tasks conflict resolution provided automatically environment evolved 
main focus chapter show evolve agents resolve conflicts gp 
investigate task allocation pursuit domain 
communication important aspect multiagent systems chapter demonstrates gp evolve agents communicate explicitly 
able add agents society previously created agents solve new problems 
chapter show gp evolve agents society existing agents learn interact 
gp general technique creating multiagent systems need assess scalability 
chapter looks scalability issues gp particular emphasis issues relate application mas 
fitness programs evolved gp evaluated testing 
believe gp community benefit formalised software testing techniques developed test human coded programs software engineering 
chapter looks software testing techniques distributed multiagent systems 
chapter summarises critically evaluates 
areas research stemming proposed 
appendices list best evolved programs experiments performed 
chapter genetic programming purpose chapter introduce genetic programming means automatically generating computer programs 
part chapter provides overview powerful genetic programming system designed implemented 
sophisticated programs existence human coded evolved nat 
inside cells living creatures form dna 
programs coded process natural selection described charles darwin responsible highly optimised machines see 
surprising ai community active tying harness power natural evolution build hardware software 
genetic algorithms john holland hol devised class algorithms inspired darwin theory evolution natural selection called genetic algorithms 
algorithms key mechanisms natural evolution selection reproduction variation tion search gol 
population trial solutions problem generated randomly 
new solutions bred fittest solutions selected old population applying genetic operators 
genetic operators vary solutions new solutions generated 
results new population solutions 
repeatedly generating subsequent solutions manner theoretically generate progressively better 
best solution obtained far tracked process 
best solution meets termination criteria decide maximum number generations permit exceeded terminate run 
representation solutions genetic algorithms commonly consists bit strings fixed length 
engineering optimisation problem example bit strings encode set design parameters trying find optimal combination values 
parent 
genetic algorithms parent child ga mutation parent child child ga crossover initial population consists randomly generated set bit strings 
fitness bit string evaluated measuring useful example decode bit string obtain parameters apply model evaluate model behaves 
selection schemes commonly fitness proportionate selection tournament selection 
fitness proportionate selection individuals selected probabil ities proportion fitness 
requires sum fitness values entire population known parallel distributed implementations difficult 
alternative fitness proportionate selection tournament selection 
tournament selection small group individuals chosen randomly population typically ordered fitness values 
fittest individuals selected take part creating new individual 
steady state gas individual replaced individual lowest fitness tournament 
advantage tournament selection simple implement secondly varying tournament size vary fitness pressure 
genetic operators create new individuals include reproduction mutation crossover 
reproduction operator simply creates exact copy selected individual 
mutation operator copies selected individual randomly changes portion bit string 
crossover operator takes individuals exchanges random por tion bit strings individual 
operator potentially creates new individuals 
single individual created discarding resultant springs 

variable length hierarchical representations gas successfully applied wide variety problems including engineering cial imaging vlsi circuit layout gas pipeline control production scheduling dav shown provide near optimal solutions 
mathematical explanation suc cess called schemata theorem proposed holland hol backed empirical support gol 
space bit strings length partitioned sets set consists strings similarities certain positions string 
example consider set bit strings 
describe string similarity template schema represents wild card don care value 
properties schemas schemata theorem order defining length 
order schema denoted number fixed values bit string 
example string order 
schemas higher order specific ones lower orders 
defining length schema denoted distance fixed values 
example string defining length 
schemata theorem predictions processing schemas ga expressed mathematically follows number strings schema average fitness strings schema average fitness population length strings probability crossover probability mutation population time population theorem predicts short defining length low order average schemas called building blocks receive exponentially increasing trials subsequent generations 
possible explanation gas combining building blocks partial solutions form strings high fitness optimal near optimal solutions 
variable length hierarchical representations variable length representation gas proposed smith smi create variant classifier systems evolved production systems defined holland reitman hr 
parent 
genetic programming child gp mutation ga evolve complete rule programs playing poker 
crossover op erator smith set restrictions crossover applied evolving structure 
inspired cramer cra tree representation evolve symbolic expressions sub tree crossover 
koza developed technique sub tree crossover evolve ex lisp programming language successfully demonstrated usefulness technique wide range problems koz 
technique known genetic programming 
genetic programming genetic programming technique automatically programming computers 
uses power gas search space possible computer programs find suitable programs de application lq 
koza describes general machine learning technique claim substantiated large number applications suc applied koz koz 
representation commonly gp program parse tree 
program parse trees advantage represents syntactically correct computer programs easy manipulate 
branches parse tree repre sent functions take arguments leaves represent zero argument functions variables constants 
fitness gp measured testing program represents 
fitness awarded programs proportion perform 
reproduction mutation crossover operators program parse trees bit strings 
reproduction creates clone selected individual 
mutation works copying parent parse tree selecting node copy random replacing randomly created subtree 
created process generation initial population 
crossover operator works copying parse trees parents 
genetic programming parent parent child child gp crossover selecting random nodes copies swapping 
children potentially created gp implementations discard 
standard gp algorithm essentially ga described pseudo code table 
common selection methods gp fitness proportionate selection tournament selection way gas 
initial population created randomly generating program parse trees 
parse trees formed selecting functions terminals problem specific sets defined user 
specific selection mechanism described section run parameters 
allow arbitrary trees generated functions function set accept arguments chosen primitives function terminal sets 
property called closure 
dur ing tree generation function selected subtrees arguments created recursively process 
tree growth restricted naturally tree leaves outer node artificially branch tree reaches maximum depth 
possibilities include tree maximum allowable nodes typically linear representations 
prevent short trees root node usually 
genetic programming table gp algorithm initialise population randomly generated individuals evaluate fitness individuals population termination criteria met size population endfor endwhile choose genetic operator select parent current population fitness create offspring selected operator parent place offspring new population evaluate fitness offspring current population new population chosen function set 
basic steps preparatory steps required code gp application koz 
involve defining 
terminal set 
functions set 
fitness function 
run parameters 
termination criteria koza describes steps defining search space problem fitness measure means determining outcome search 
function terminal sets function terminal sets form limited language gp generate programs 
function set contains primitive functions language take arguments 
functions selected priori believed useful solving problem 
functions typical constructs programming languages conditionals switch statements loops recursive function calls variable assignments indexed memory operations array manipulation math functions logical bitwise operations 
genetic programming alternatively user defined functions peculiar application domain sendmessage 
noted inclusion loops recursion create possibility program loops recurses indefinitely making fitness evalu ation difficult 
solutions iteration koz recursion bra bra wl yc problems provided 
terminal set contains variables constants zero argument functions random ephemeral constants application 
random ephemeral constants real numbered integer constants initialised random values start run maintain values run 
fitness function fitness function measures success fitness evolved program 
value typi cally obtained executing program set test cases measuring closely programs generates desired output 
fitness program contain mea efficiency size code 
measured fitness program determine selected take part production generation 
fitness functions accurate highly sensitive differences performance programs 
fitness measure thought means specifying high level requirement spec solution 
describes needs done 
run parameters important parameters population size number generations 
parameters determine amount exploration exploitation performed ga small population evolved large number generations biased exploitation 
sim large population evolved small number generations biased greater 
gp extensions exploration 
carefully choosing value parameters balance exploration exploitation 
reproduction crossover mutation probabilities select genetic operator create offsprings 
specify probability genetic operators chosen 
reproduction mutation probabilities usually set small mutation rates quite common 
shape depth trees created initial population specified cre ation method maximum depth parameters respectively 
creation methods commonly called full grow methods 
full method creates symmetric trees maximum depth branch root 
achieved selecting root node randomly function set continuing recursively select randomly function set sub nodes maximum allowable depth reached point node selected terminal set 
selecting grow method creates asymmetric trees 
full trees root chosen function set time continue recursively selecting children function terminal set terminal selected maximum depth reached point terminal selected 
third method called ramped half half ensure population diversity initial population 
size trees created ramped maximum allowable depth 
half trees created full method half created grow method 
termination criteria termination criteria determines algorithm 
typical termination criteria include number evolved generations exceeds maximum fitness best individual reaches desired value genetic information known needed solution lost effectively abort successful run 
gp extensions original gp technique advanced extensions 
referenced thesis described section 
complete survey techniques lq 
automatically defined functions 
gp extensions chart development programming languages see steady trend higher higher levels abstraction applied 
earliest languages machine code quickly replaced assembly level languages 
turn lead development high level languages fortran 
facilitated code reuse form subroutines easily parameterised forms functions procedures 
useful functions available form libraries higher form functional abstraction 
object oriented languages support data abstraction data types adts increased amount code reuse 
advantages abstraction allows control complexity facilitates code reuse 
code reuse particularly useful gp means block useful code need independently rediscovered different places program needed 
section look key technique introduce abstraction gp 
automatically defined functions adfs koz koz evolvable functions subroutines evolving genetic program main result producing branch program possible adfs call 
adf separate tree consisting terminal functions sets 
terminal sets adfs take arguments contain terminals argument 
terminals get instantiated values parameters passed adf called fitness evaluation 
functions sets adfs contain primitive functions adfs defined 
result producing branch just special adf called fitness function evaluating pro gram 
adfs effectively act functional units building blocks combined create programs 
crossover mutation operations modified adfs mutation mutates adf random crossover exchanges subtrees adfs individual 
depending implementation crossover performed single adf adfs 
adfs successfully problems proved difficult genetic programming adfs 
addition adfs adds extra step preparatory steps gp appli cation 
extra step defines architecture terms number adfs arguments take result producing branch 
strongly typed gp 
gp extensions koza early gp system restricted functions terminal designed type 
property koza calls closure allowed functions take terminals function calls arguments return terminals function calls results 
advantage approach greatly simplified tree generation manipulation crossover mutation operators 
montana mon relaxed restriction strongly typed genetic programming stgp system allowing functions terminals type specifications 
stgp supports generic types help reduce number different function definitions needed 
implementation gp algorithm modified ensure arguments functions correct type generated program adf returns correct type 
tree generation facilitated type possibility tables computed start run list functions terminals available tree depth 
care taken tree mutated root subtree replacing node mutated type 
similarly crossover restricted subtrees roots type may exchanged 
montana argues increase complexity gp algorithm compensated considerable reduction size search space turn reduces effort required find solutions 
concern approach effect connectivity search space 
highly restrictive grammars may search space sparse making difficult move point 
turn cause premature convergence 
steady state gp standard gp evolutionary engine described generational works stages called generations 
initial population created subsequent generation created applying genetic operators individuals selected generation form entire new population replaces old 
new individuals available reproduction entire new population created 
steady state gp engine rey rey rey notion new old generations just continuous change individuals population 
new individual created replaces existing individual population imme available reproduction 
benefits approach memory efficient easy parallelize 
memory efficient population needs memory standard generational engine required 
indexed memory data structures 
gp extensions earlier koza named memory allow state maintained 
function set value conjunction terminal representing named memory location variable set value memory location 
teller tel added indexed memory capability gp 
array memory locations manipulated read write functions 
take index memory location argument 
langdon lan lan lan lan gp indexed memory successfully evolve queue stack data types adts chromosome structure multi ple trees 
tree chromosome represent required adt member functions 
results suggest may possible extend level abstraction gp pure functional abstraction adfs full adts 
may help increase scalability gp 
evolution nature organisms interact just environment 
direct competition happens predators prey parasites hosts 
fitness organisms relative 
predator deemed fit catch prey necessary survival 
conversely fit prey better able escape predators 
dawkins daw describes competitive evolution leads arms race organism evolves counteract improvement evolution competitor 
approach applied gp koz ap jan rey involves creating evolving populations 
fitness individuals population measured relative individuals vice versa 
testing individual population 
individual 
random subset 
current best method compute intensive practical techniques normally 
cooperative evolution comparable symbiosis nature sap programs tested pairs programs rewarded higher fitness 
theory fitness landscapes 
theory traditional ga individuals population represented fixed length bitstrings 
total number possible individuals equal total number permutations bitstring bits bitstring 
suppose plot individuals points horizontal plane distant individuals equal number bit changes required get individual hamming distance 
suppose give points vertical component proportional fitness values individuals represent 
called fitness landscape peaks represent location high fitness valleys locations poor fitness 
actual ruggedness landscape depend difficulty fitness function 
particularly difficult function result fitness landscape flat virtually featureless exception widely distributed 
conversely easy fitness function consist mountain single peak 
generate initial random population individuals effectively placing mesh fitness landscape simultaneously sampling fitness function different places 
ge operators mutation crossover provide means exploring landscape 
single bit mutation allows move point time landscape 
crossover multi bit mutation allow take giant leaps landscape 
assumption ga select individuals higher fitness applying genetic operators landscape point high fitness 
correlation parents children notion called auto correlation 
fitness landscape provides powerful tool visualising difficulty problem 
try tool gp run major difficulty decide points adjacent 
fixed length standard ga hamming distance possible gp representation bit oriented fixed length 
individuals gp program trees compared way determine far apart plotted fitness landscape 
obvious 
ear kin examines structure fitness landscape gp operates analyses landscapes range problems known difficulty order determine correlation landscape measures problem difficulty 
landscape analysis techniques employs include adaptive walks autocorrelation fitness values random walks 
results indicate shows better correlation problem difficulty gp 
gp schema theorem 
theory difficult search fitness landscape 
easy search fitness landscape 
number attempts provide schema theorem st gp 
early attempts position sts information position schema compo nents omitted 
position schemas instantiated times program 
koza defined schema set trees having subtrees common koz 
reilly oppacher oo extended definition include incompletely defined expres sions called tree fragments 
tree fragment tree don care symbol leaf 
definition schema multiset subtrees tree fragments 
attempts positioned schemas schemas represented rooted trees tree fragments 
rooted schemas position schemas instantiated tree 
rosca ros rb devised rooted tree schema theorem schema tree composed function terminal sets run exception terminal set includes stand valid subtree 
poli langdon schema pl don care symbol case restricted appearing leaves schema trees furthermore representing valid sub 
gp applications tree represents single node 
schema represents set trees size shape defined nodes schema places 
schema theorem applies point crossover asymptotically converges holland ga schema theorem 
theorem pol allow terminals schema contain wild card represents node valid sub tree 
gp applications gp successfully applied wide range problems including image processing computer graphics process control autonomous agents robotics data mining circuit design neural networks modeling natural language processing classification pattern recognition signal processing art survey applications lq koz koz 
william langdon maintains bibliography published material gpsys www cs bham ac uk wbl biblio readme html 
help advance research genetic programming designed developed extendable gp system java programming language 
system consists lines code comments documentation 
environment experiments thesis gp researchers worldwide current release recorded downloads 
gpsys downloaded cs ucl ac uk staff gpsys html 
design goals gpsys realised shown table 
deemed useful gp extensions stgp adfs consequently design 
noted adf implementation crossover performed adf 
original design gpsys engine improve memory efficiency current release memory efficient generational engine 
design goals realised just choosing java implementation language 
newly created restored disk population generations fitness tournament size rng seed rng engine 
gpsys save disk functions terminals maxdepth gpsys events event processor new individual new generation exception gpsys high performance gp system java programming language java robust powerful efficient multi threaded distributed object oriented programming language 
java compiles bytecode machine code virtual machine called java virtual machine jvm 
jvm interprets bytecodes execute program ported different platforms operating systems processors provides java excellent portability 
jvms contain code speed execution java programs including just time compilers run time 
dynamically compiles byte code machine code target processor monitors program execution optimises executing code 
techniques overcome performance arguments java 
java language designed robustness achieved minimising program ming errors 
programming errors minimised replacing pointers 
differ pointers jvm generate arithmetic operations create new 
feature removes pointer errors plague languages segmentation violations bus errors 
arrays access checked runtime bound errors 
inclusion exception handling forces programmer consider deal run time exceptions compile time 
reduces probability errors 
gui design goal implementation 
gpsys easy plug play model support useful gp extensions adfs stgp extensibility oo design flexibility oo design portability java factory observer observable design patterns robustness java exception handling high performance java efficiency memory efficient generational engine support persistence java serialization gzip compression support parallel distributed architectures java networking rmi table gpsys design goals implementation java extremely rich library pre built objects included jvm 
objects include support graphics databases networking input output advanced data struc tures string manipulation compression algorithms 
small powerful programs written minimal effort 
excellent support distributed computation form sockets remote method invocation 
jvms included web browsers allows applets java code designed run browser loaded executed securely browser opening possibility massively distributed computing 
application programmers interface key goals gpsys easy requiring code changes gp engine user 
created plug play model depicted 
gpsys instantiates gpsys object calls evolve method starts evolution 
order instantiate gpsys pass constructor object 
object codes parameters required gpsys addition gpsys store state information run 
class definition includes methods allow object saved restored disk allowing gpsys run suspended restarted 
full set parameters specified include parameters run parameters problem table 
gpsys supports adfs parameters adf tree specified table 
function terminal set adf specified function terminal 
gpsys arrays 
function terminal arrays implements factory design pattern ghj gpsys create instances objects calling factory methods 
common gp primitives provided part primitives package gpsys including conditionals arithmetic functions indexed memory operators 
primitives support generic types 
object store measure fitness individual specified fitness object object 
factory design pattern fitness objects created instance 
fitness object abstracts user implementation fitness function fitness representation 
methods define contract user fulfill allow fitness object gpsys table 
termination condition specified fitness function 
gpsys observer observable design pattern ghj provide clean way monitoring run 
users need create register observer object gpsys observable object order told interesting happens 
observer object instance class implements interface registered passing object 
interface specifies call back methods communicate information gpsys user table 
internal data structures internal data structures gpsys shown 
population consists things array individuals 
individual associated array chromosomes adfs fitness 
result producing branch rpb normally adf array changed 
chromosome consists tree genes 
kind genes tree 
rep resent function calls array gene arguments associated 
leaves gene tree represent terminals 
genes hold primitives contain type code definition primitive represent 
kinds primitives functions terminals 
functions represent primitives take arguments contain type specifications argument take 
terminals represent zero arity primitives just contain code definitions 
subtypes functions terminals represent automatically de fined functions terminals respectively 
contain code definitions contain index chromosome defines individual chromosome array 
parameter name description 
gpsys run parameters size population 
generations maximum number generations 
probability mutation operation chosen 
probability reproduction operation chosen 
size tournament tournament selection 
rng random number generator 
seed random number generator 
engine gp engine evolution 
possible selections include parameter name description generational engine steady state engine 
problem definition parameters adf array define parameters chromosome adf evolved 
fitness fitness definition problem 
observer observer object information evolution sent 
table users create functions terminals extending function terminal classes 
functions terminals evaluated gpsys gp executed fitness evaluation 
return value type depending type user override evaluation methods forms part contract user defined function terminal 
evaluation methods divided efficiency reasons return java primitives byte short int long char boolean float double return object array 
population object contains data structure 
implement memory efficient crossover generational evolutionary en described koza 
gp systems maintain populations run active population create population 
new population active population iteration 
memory efficient crossover process divides task generating new population phases 
phase decide parents current population going reproduce genetic operation 
information stored book keeping data structure 
second phase execute parameter name description 
gpsys method create initial population 
possible values include full grow ramped half half 
maximum creation depth gene tree chromosome 
maximum depth trees created mutation 
maximum depth trees chromosome 
functions function set chromosome 
terminals terminal set chromosome 
type type returned chromosome 
types set types chromosome 
table function description void add fitness add fitness fitness object 
void divide int divisor divide fitness specified integer 
boolean equals fitness tests fitness boolean lessthan fitness tests fitness boolean greaterthan fitness tests fitness fitness instance creates default fitness object 
fitness instance individual creates fitness object evaluating table fitness genetic operations create new individuals 
fitness advantage approach carefully scheduling order execute genetic operations greatly reduce amount individuals need hold memory 
pigeon hole argument calculate population contains individuals need space individuals individuals normally 
data structure holds lists 
lists hold information parents genetic operations involved 
parents genetic operations outstanding stored lists respectively 
executing genetic operations individual replaced chosen list initialised contain information extra slots mentioned earlier 
parent genetic operation parent number function description 
void invoked new generation created 
int cm cm specifies generation created creation stream evolved void invoked new individual created 
individual int cm cm specifies individual created randomly reproduction mutation crossover 
void invoked unusual event occurs java lang string indicates happened 
void exception invoked exception occurs 
outstanding genetic operations 
table think gp different perspectives 
machine learning perspective mit gp general technique allows machine learn solve task training examples test cases 
ml researchers describe gp beam search population computer programs beam evaluation metric fitness function 
algorithmic complexity theory perspective lv view gp com pression algorithm creates compressed representation computer program set input output tuples test cases 
gpsys terminal gpsys terminals adf engine generations population rng load save primitive gpsys instance tostring maxdepth gpsys functions gpsys function gpsys uses uses 
gpsys gpsys parameters uml diagram fitness observer type gpsys type typeid argtypes typename types type type tostring add divide equals greaterthan instance lessthan tostring fitness gpsys exception interface gpsys get put gpsys argtypes type uses uses typename uses uses type uses uses reset crossover crossovers generation mutation mutations reproduction population evolve report sort tostring type gpsys typeid tostring get put gpsys gpsys local package population gpsys gpsys local package parent creates creates uses creates uses creates uses function gpsys gpsys terminal gpsys add divide equals greaterthan instance lessthan uses uses tostring busy fitness gpsys gpsys local package dead free id state kill gpsys reset tostring gpsys prev fitness gpsys local package primitive gpsys instance tostring uses creates uses individual gpsys complexity individual complexity uses parent gpsys local package tostring uses creation evolved creation crossover mutation 
gpsys reproduction exception interface gpsys uses uses uses uses gpsys complexity depth tostring adf chromosome adf complexity chromosome chromosome complexity cross mutate gpsys tostring gpsys uml diagram gpsys index type vector size gpsys creates complexity uses arguments child parent creates uses gene gpsys depth tostring gpsys complexity depth tostring chapter intelligent agents multiagent systems chapter provide brief overview concepts agents systems look key problems designing implementing 
survey applica tion genetic programming automatic programming agents setting background rest thesis 
agents universally agreed definition term agent definition agents thesis jennings wooldridge jsw wj agent computer system situated environment capable flexible au action order meet design objectives definition concepts autonomy agents ability act direct intervention humans agents control actions internal state situatedness agents situated environment part perceive manipulate flexibility agents possess properties responsiveness pro activity social ability responsiveness agents perceive environment respond timely fashion changes occur pro activity agents simply act response environment able exhibit goal directed behaviour initiative social ability agents able interact agents possibly humans com plete problem solving help activities 
agents define agent system key abstraction agent 
system comprised agents 
composed agent referred multiagent systems 
key question agent research build agents desirable properties stated 
number architectures building agent systems proposed 
classified deliberative reactive hybrid architectures 
deliberative architectures deliberative architectures derived classical approaches artificial intelligence treat agents knowledge systems 
emphasis knowledge representation techniques inference methods 
typically model environment goals agent capabilities represented symbolically form symbolic reasoning determine action perform 
weakness approach time taken reasoning may invalidate reduce utility action responsive behaviour may possible 
furthermore symbolic representation environmental information may easy accomplish consider visual information 
bdi agents class deliberative agents draw inspiration theory human practical reasoning developed philosopher bratman bra 
agents built components consisting data structures representing beliefs desires intentions agent functions represent deliberation means reasoning 
infor mation agent environment represented beliefs 
desires rep resent options available agent intentions agent decides com mit resource achieving 
deliberation process deciding goals desires want achieve means reasoning determines achieve wei jsw 
reactive architectures reactive architectures pioneered brooks bro take radically different approach build ing agents classical ai reject symbolic representation reasoning 
stress importance situatedness embodiment creation intelligent rational behaviour 
intelligent behaviour seen emerging interaction agent environment interaction simpler behaviours bro 
test ideas brooks developed agent control architecture called subsumption architecture proper ties 
subsumption architecture agent composed collection task accomplishing behaviours arranged layers task accomplishing behaviours extremely sim ple consisting finite state machines map sensory input action 
prevent multiple 
systems behaviours simultaneously activated layers priorities lower layers inhibit behaviours upper layers 
hybrid architectures hybrid architectures attempt combine deliberative reactive approaches 
archi vertical horizontal software layers arranged hierarchy different levels abstraction 
distinction layering methods horizontal layering layers access sensors effectors vertical layering sen sors effectors dealt layer 
typically layers starting lowest layer include reactive level knowledge level social knowledge level 
knowledge level symbolic representation agent envi ronment social knowledge level symbolic representation agents wei jsw 
systems dai subfield artificial intelligence concerned situations sys tems interact order solve common problem cc 
systems may include humans machines 
classical ai metaphor intelligence individual human behaviour emphasis put knowledge representation inference methods metaphor dai social behaviour emphasis placed actions interactions sdb 
research dai traditionally divided subfields distributed problem solving dps multiagent systems cc gas 
dps concerned dividing involved solving particular problem number nodes divide share knowledge problem developing solution 
emphasis dps task decomposition solution synthesis 
mas research concerned behaviour collection autonomous agents aiming solve problem problem solved knowledge capabilities individual agent wei cc 
weiss uses modern definition systems interchangeable dai covers dai subfields wei 
definition thesis 
potential benefits mas increased reliability better performance lower software complexity 
characteristics systems follows jsw agent incomplete information capabilities solving problem agent limited viewpoint global system control data decentralised computation asynchronous 

evolving agents gp owing characteristics task designing agents difficult 
list taken jsw represent key problems design implementation mas 
formulate describe decompose allocate problems synthesise results group intelligent agents 

enable agents communicate interact 
communication languages protocols 
communicate 

ensure agents act coherently making decisions action dating nonlocal effects local decisions avoiding harmful interactions 

enable individual agents represent reason actions plans knowledge agents order coordinate reason state coordinated process initiation completion 

recognize reconcile disparate viewpoints conflicting intentions collection agents trying coordinate actions 

effectively balance local computation communication 
generally manage allocation limited resources 

avoid mitigate harmful system behaviour chaotic oscillatory behaviour 

engineer constrain practical dai systems 
design technology plat forms development methodologies dai 
general answer questions gp evolve agents ously solve problems 
furthermore suggesting gp general methodology developing multiagent systems 
evolving agents gp apply gp agent computing ways gp learning planning technique agents evolve complete agents 
evolving agents gp combine gp evolve agents gp learning technique research applying gp agents date focussed approaches 
research gp suggests gp generic learning technique learning technique agents highly attractive 
gp learning technique agents clack cla example gp evolve document classifying agents 
gp search space document classification expressions find expressions correctly classify users information needs 
evolutionary process need allowing classifications evolve changes users information needs 
plans effectively just computer programs gp plan generation ing 
genetic planner devised handley han han han achieves planning searching space plans 
search space defined usual gp way set functions operators planning terminology terminals 
plans evaluated fitness simulation world executed 
handley showed gen erate plans navigation robot world reasoning mechanism avoid traditional planning issues sussman anomaly dynamic temporal world problems 
furthermore gp process point ask best evolved solution handley argues genetic planner anytime algorithm 
key problem approach requires model environment evaluate relative success plan executing 
furthermore measuring relative success plan requires generation fitness function consider example plan needs switch light room 
basing fitness function desired outcome state environment changed light switched 
partial plans get close switch example rewarded scheme 
second problem time space problems associated evolving large population plans 
evolving complete agents done applying gp evolve agents focussed mainly reactive agent ar 
key techniques developed 
creating homogeneous agents involves evolving single gp instantiated times agent koz koz 
fitness evaluation performed executing program context agent repeatedly fixed number iterations task agents trying solve completed 
fitness value assigned gp measured terms close agents solving problem hand 
second technique create heterogeneous operating agents involves evolving gp consists 
evolving agents gp multiple trees similar adfs heterogeneous agents hs hs 
fitness evaluation agent instantiated trees gp 
fitness assigned way homogeneous agents heterogeneous agents treated unit team 
advantage architectures avoid credit assignment problem min assign credit participating agents 
third technique evolve competing agents separate populations competing agents hs 
fitness evaluation pits agents population agents fitness agents population relative performance tested agents population 
competing agents share fitness team approach mentioned 
technique evolve operating agents iba problem credit assignment approach difficult 
koza gp evolve wall behaviour simulated autonomous mobile agent subsumption architecture koz 
wall problem originally devised mataric mat consists robot situated irregular room task walls room 
guide provided sonar sensors covering degree sectors additional sensor detect robot stopped 
robot capable moving forwards backwards constant distance rotating left right degrees stopping 
mataric developed subsumption architecture comprising programs control robot called avoid align correct 
architecture sufficient achieve task modeling planning design non reactive robotic systems 
koza showed gp evolve subsumption architecture problem automatically 
paved way gp evolve reactive agents 
koza evolved homogeneous reactive agents solve painted desert problem koz 
definition problem ants grains sand colours 
ants grains placed random positions dimensional grid size 
ants driven common program ants homogeneous sense information current grid position 
direct communication ants permitted 
goal arrange grains vertical bands grains band colour 
addition band colour occupy predefined column grid black grey striped bands occupy columns respectively 
parallel movement ants simulated executing evolved program ant sequentially 
process repeated iterations 
simple function terminal sets suitable fitness function koza able evolve complete solution problem demonstrated homogeneous reactive multiagent systems cooperate solve task evolved gp 
similar approach program 
evolving agents gp ants homogeneous reactive agents collectively find transport food efficient manner nest koz 
andre gp evolve programs capable storing representation environment map making representation control actions simu lated robot 
gp effectively evolve programs making adfs individual 
split fitness evaluation individual phases 
phase program run extract store features environment 
program provided set functions probe environment 
second phase second program executed stored representation control actions robot 
fitness value awarded success second phase 
approach able successfully evolve programs solve simple problems ing environment storing representation representation control action 
programs viewed communicating agents 
reynolds rey competitive evolution evolve vehicle steering control programs pursuers evaders game tag 
obtained near optimal solutions expert pursuers expert evaders 
haynes hw evolved programs control autonomous agent needs survive hos tile environment 
simulated environment consisted dimensional grid cells contain agents mines energy 
goal agents sense mark location mines energy moving 
sensing possible tallies available cell count number items available neigh cells game minesweeper 
agent access memory containing formation visited cells 
fitness function uses fluctuating environments able evolve robust implementation handle environment 
haynes sandip hw hs hs hs hs hs evolved homogeneous heterogeneous agents pursuit domain 
competitively evolved predators prey 
techniques mentioned section detailed chapter 
luke spector ls compared cloned homogeneous free heterogeneous crossover allowed trees representing different agents restricted crossover permitted tween trees representing agents breeding policies predator prey domain called 
compared range coordination mechanisms including sensing predators unable sense positions deictic sensing predators sense relative manner position nearest agent name sensing position agents sensed referenced names 

evolving agents gp heterogeneous approaches produced better results homogeneous approaches furthermore restricted breeding method worked best 
name sens ing produced better results sensing turn produced better results sensing 
show gp evolve agents send receive operators explicit communication 
evolved homogeneous agents operative domain learn communicate 
detailed chapter 
iba compared homogeneous heterogeneous evolutionary operative breeding agents tile world problem iba 
different tile world problems heterogeneous worked best second evolutionary ap proach worked best 
operative evolution approach populations population agent third common pool evolving shared building blocks 
individuals shared pool migrated common pool lations generation 
fitness individuals agent populations evaluated generation picking random partners subse quently best population 
iba performed experiments evolved homogeneous heterogeneous agents send receive prim similar robot navigation domain iba iba 
send deictic operators sends position vector ith nearest agent operators agents receive operator returns message fifo queue receiving agent 
experiment specialised send send ir send iy operators total nearest agents send random yield commands specified agents 
commands cause recipients stay place move randomly move adjacent vacant square respectively 
targeted agents execute explicit receive primitive achieve tasks evolve code perform intended task control code gets executed 
behaviour simulator operators direct control operators 
evolved heterogeneous tory agents pursuit domain name primitives called com com com com request position information agents respectively 
effect operator return displacement vector calling agent target receiving agent fixed range prey argument function returned 
agent recipient request evolve code respond request simulator 
operator fore conditional sensor 
details provided chapter 
iba evolved heterogeneous agents acl communication commands propose 
evolving agents gp screenshot accept reject negotiate cooperation tile world domain iba 
approach haynes evolve team represents agent separate tree adf 
number agents evolved specified advance number trees 
koza architecture altering operations bennett ben ben developed method evolving number agents code 
number researchers luk investigated gp evolve agents robotic soccer played simulator soccer server shown 
robocup competition softbot part soccer teams consisting play ers softbots play real time tournaments teams 
luke luk evolved players team gp 
player consisted move program kick program 
luke investigated possibility evolving homogeneous hetero agents domain 
evolution heterogeneous agents required individual gp population consisted trees move kick tree pairs 
chose evolve pure homogeneous agents hybrid pseudo heterogeneous teams 
consist smaller number heterogeneous agents required multiple times form generate team team consists sets homogeneous agents heterogeneous respect 

evolving agents gp homogeneous pseudo heterogeneous approaches disallowed crossover kick move trees 
furthermore restricted crossover approach mentioned ear restrict crossover pseudo heterogeneous approach occurs 
allow fitness evaluation competitive fitness approach evolving teams team represented individual team individual chosen randomly population 
fitness measure crudely number goals scored 
number goals scored individuals initial population surprisingly high 
best evolved solution neous type submitted robocup competition won games human crafted opponent teams 
andre teller similar approach create robotic soccer team call darwin united 
created heterogeneous agents represented trees individual share adfs trees individual 
restricted breeding scheme crossover occurs trees representing player num bered adfs 
approach luke andre teller indexed memory evolved agents longer just reactive 
complex fitness evaluation approach 
fitness value team consist ordered list items ranging important getting close ball kicking important scoring goal winning games 
fitness evaluation involves team represented individual evaluated progressively players 
individual gets play successive teams succeeds earlier teams score average games played 
teams individual range empty field team winning team robocup competition team represented individual succeeds teams represented individuals got stage 
chapter task allocation conflict resolution task allocation conflict resolution key research areas multiagent systems 
chapter show gp evolve agents automatically allocate tasks statically dynamically resolve conflicts arising interaction 
pursuit problem pursuit problem called predator prey problem studied testbed dai research 
benda bjd formulated original problem definition consisting predators need capture single prey 
predators prey situated dimensional world consisting cells 
movement world possible directions takes agents cell 
goal predators move capture prey 
capture prey predators occupy cells immediately adjacent prey call capture positions 
prey moves randomly slower predators usually implemented en prey stationary percentage time 
implementations agent may occupy cell time conflicts occur agents try occupy cell agents conflict 
variations original definition devised changing key domain parameters parameters described sv listed table 
gasser proposed solution call lieb configuration 
lieb configuration grid divided quadrants diagonal lines pass cell occupied prey predators occupy different quadrant 
proposed predators try achieve lieb configuration follow set lieb rules capture prey 
merx sm investigated pursuit domain control strategies gov 
pursuit problem environment pursuit domain consists dimensional usually tor world predators try capture prey surrounding 
parameter examples grid size finite infinite table pursuit domain parameters grid shape square hexagonal continuous edged capture definition prey surrounded predator square prey legal moves orthogonal diagonals permitted movement agents take turns move agents move simultaneously sensors sensed far away predator communication permitted disallowed range implicit explicit prey movement random stationary deterministic predator prey numbers predator agents 
control strategies included local control distributed control central control 
local control strategy predator agents pursue local goals communicate occupy capture position broadcasting position 
formation picked predators update list potential local goals 
distributed control strategy predators shared convention communication achieve capture 
start move cycle agent computes straight line distance capture positions chooses closest position intention 
intention broadcast predators 
shared convention agent straight 
pursuit problem pursuit domain movement restricted orthogonal directions capture positions cells immediately adjacent prey prey captured capture positions occupied predators conflicts occur agents try occupy cell 
line distance intended capture position allocated position 
central con trol strategy predator complete accurate information position predators plans broadcasts commands 
control strategies predators accurate information position prey 
tested control strategies randomly generated initial placements predator agents prey centered grid 
agents moved speed moves ordered avoid collisions prey moved randomly 
results report central control strategy successful local control strategy successful 
central control efficient distributed control suffers having central point failure 
korf kor proposed pursuit problem solved explicit coordination 
investigated purely greedy strategies predators 
korf conducted experiments orthogonal diagonal hexagonal grid variations prey actively tries evade predators moving neighbouring cell nearest predator 
diagonal grid configuration agents move diagonally orthogonally consequently predators 
hexagonal grid predators cover exit cell 
conflicts avoided ordering movement agents prey moved speed predators prey stays probability 
initial positions agents randomly generated 
simplest solution solves problems grid configurations 
pursuit problem predators try minimise distance prey 
efficient solution employs diagonal hexagonal versions game uses attractive force prey repulsive force predators 
korf concludes results lend support theory coordination cooperation viewed emergent property interaction greedy agents presence environmental constraints 
campbell mc agreed korf predators prey game solved explicit coordination argued pursuit game having prey 
ga optimise parameters hand coded predators communicate 
introduced concept boredom similar timeouts prevent predators repeatedly executing actions getting closer goal 
haynes hs gp evolve homogeneous predator agents pursuit domain 
argued ordered execution moves korf form communication helps coordinate predators 
agents version pursuit game move concurrently 
agents try move cell bumped back original position 
predator may push predator cell occupies decides move 
push operator available function set gp system 
form conflict resolution executed environment agents 
orthogonal game board agents move orthogonally stay randomly generated training test cases consisting prey center predators placed randomly 
prey moves speed predators 
stgp system allow functions terminals different types combined tree argue reduces search space 
demonstrated superior standard gp applied domain comparison experiments 
trees return direction move north east south west random instances generated constants terminal set 
indicates agent stay put 
provide function called takes parameters agent second compass direction tack terminology return cell positioned specified tack relative cell occupied specified agent 
terminal set includes prey current predator 
functions include ifthenelse md md returns distance cells provided arguments 
fitness function employ awards agents getting close prey occupying capture positions capturing prey 
ensure stable captures opposed shadow captures continue simulation prey captured approaches mentioned point 
time steps training comparing evolved 
pursuit problem predators handcrafted greedy algorithms devised korf timesteps 
varied type prey randomly moving move away nearest predator competitively evolved preys 
gp evolved solutions competitive hand coded greedy algorithms korf 
results evolved prey successful 
anticipated performance predators prey oscillate populations learns latest strategy 
simple strategy employed prey prey chooses random direction continues move direction referred linear prey successfully predator strategies considered 
investigation showed strategies performed badly prey 
analysis suggested act prey moving helps predators get deadlock situations created greedy approach 
evolved heterogeneous predator agents hs hs hs games rules including implicit push operator function terminal sets homogeneous approach 
heterogenous agents evolved team representing agent separate tree individual mentioned previous chapter 
resulted successful strategy evolved note success attributed ability heterogeneous agents avoid potential deadlocks 
iba iba gp evolve heterogeneous predators pursuit domain 
game configuration iba orthogonal grid prey tries avoid predators moving away centre gravity 
training generalisation test cases agents placed randomly generated lieb configurations 
individual evaluated simulator runs maximum time steps agent move maximum times 
simulation stopped prey captured maximum simulation time expired 
agents choose stay current position move orthogonal cells 
fitness calculated summing total distances predators prey time step simulation 
lower fitness values correspond fitter individuals 
fitness function effectively rewards individuals capture prey shortest simulation time 
unclear description agents move order concurrently 
function terminal set operate vector types evolved trees return value type 
mapping functions maps returned vector movements mentioned earlier 
terminal set included primitives return displacement vector prey agents global information available predators time 
function set included various vector operators conditionals 
runs executed population individuals evolved generations 
best individual experiment resulted success rate ranging close 
iba repeated variations experiment explore 
pursuit domain investigate task allocation conflict resolution communication 
curiously experiment employed randomly moving prey evading prey earlier 
range primitives sense location prey agents reduced sense agents circle radius position 
experiments conducted identical earlier experiment changes mentioned 
second experiment added iba calls communication primitives function set 
mentioned previous chapter view primitives conditional name sensors 
communication primitives called com com com com request position information agents respectively 
effect operator return displacement vector calling agent target receiving agent fixed range prey argument function returned 
penalty associated operators predator wait time unit moving 
third experiment addition communication primitives added view primitive evaluates argument prey visible caller 
motivation enable reduction reliance communication prey visible 
iba reports communication view primitive gave best results reduced amount communication necessary 
pursuit domain investigate task allocation conflict resolution pursuit domain conflicts arise agents try occupy cell 
conflicts resolved result deadlock 
just concurrent distributed systems ways handling deadlocks pursuit domain deadlock avoidance deadlock detection resolution 
deadlock avoidance simplest effective approach employ 
predators need coordinate movement eliminate minimise conflicts 
deadlock detection resolution far complex 
agents conflict able detect conflict coordinate behaviour resolve 
note research conflict resolution avoided providing en mechanisms resolving conflicts avoiding 
examples include ordered execution moves sm korf kor implicit push operator haynes hs 
important points haynes raised homogeneous agents evolved agents driven deterministic algorithms get conflict situations act prey moving 
preys effective causing deadlocks 
furthermore large number simulation cycles predators 
pursuit domain investigate task allocation conflict resolution collision conditions agents tries move cell occupied agent agents try exchange positions agents try move cell 
get deadlock situations result prey moving randomly capture prey 
note separate non gp study haynes sandip hls hs employed case reasoning approach learning conflict situations sub avoided predators 
main purpose chapter directly evolve conflict resolution strategies 
pursuit rules pursuit games designed maximise probability conflicts reduce inadvertent resolution conflicts occur due movement prey 
rules pursuit games follows goal capture prey occupying orthogonal positions prey maintaining positions rest simulation 
simulation lasts cycles new simulation run test case simulation cycle agent allowed move moves north east south west agent move remain agents move concurrently ordering moves agents occupy cell collision occurs agents involved moves cancelled collisions occur agents try move cell occupied adjacent agents try exchange cell positions agent try move cell 
pursuit domain investigate task allocation conflict resolution randomly moving prey moves time 
rules differ haynes sandip hs allow cycles test case upto reported 
reduces probability deadlocks resolved movement prey 
furthermore agents exchange positions involving crossing paths 
clear papers haynes sandip possible 
restriction introduced maximise likelihood conflicts occurring 
pursuit game feature implicit environmental mechanisms resolving conflicts 
fitness function fitness function reported haynes sandip hs 
cycle test measure distance agents prey sum added current fitness value 
simulation give rewards agent occupying capture position add bonus prey captured 
fitness function rewards movement close prey occupying capture positions bonus capturing prey 
table fitness evaluation pseudo code pursuit problem initialise positions agents test case fitness cycle move predators evolved code prey stationary move prey time check see moves valid undo invalid moves commit valid moves foreach predator fitness prey endfor fitness prey captured fitness fitness evaluation training purposes randomly generated test cases prey center predators random positions 
test case deployed randomly moving stationary preys 
helps maximise conflict situations discussed earlier 
test cases 
computational costs evaluation infeasible run test case individual generation 
agents code need 
pursuit domain investigate task allocation conflict resolution evaluated times test case individual generation 
just generation computational costs population size 
population size experiments evaluates evaluations 
reduce computational cost reducing population size parameter known important successful application gp 
sampling technique generation select test cases ran dom test cases evaluate individual 
allows fairly compare fitness individuals generation whilst minimising cost evaluation 
cost evaluating generation reduced th 
penalty technique need run evolutionary process longer number generations give chance test case evaluated times 
dou bled number generations normally bringing reduction computation rd original number 
key problem approach move generation best generation may outperform current best run generally better sampled test cases easier 
ideally weight fitness value difficulty test cases passed 
unfortunately easy pursuit domain discuss issue chapter 
overcome problem devised technique generation re evaluate best individual generation full test cases store individual variable fitness value better value 
mechanism provides effective way track best individual run 
run took best individual run re evaluated individual randomly generated new test cases 
comparison purposes run 
results evaluation measure compare generality evolved solutions 
function terminal sets table lists functions terminals common pursuit experiments performed 
additional primitives experiment variations described appropriate sections 
functions terminals operate types cell direction agent 
cell type represents cells playing field direction type allows evolved programs return suitable direction move allows cells orthogonal cell accessed 
compass directions permitted north east south west additional direction called represents null direction 
return value evolved programs indicate agent stay current cell conjunction 
pursuit domain investigate task allocation conflict resolution table experiments common functions terminals primitive purpose direction north return ifnorth cell cell direction direction return direction east return ifeast cell cell direction direction return direction equal return ifcellsequal cell cell direction direction return cell cellyofx agent direction return cell cell direction north north direction direction east east direction direction south south direction direction west west direction direction direction agent agent evaluated agent agent prey direction arg arg arguments current adf cellyofx function access cell agent 
cellyofx function function operates agent equivalent function haynes sandip 
functions ifnorth ifeast allow relative position cells compared depending result allow direction resulting expressions evaluated returned 
functions aware geometry playing field designed simplify task sensing relative direction prey 
terminal instantiated run time current agent evaluated 
behavioural analysis enable behavioural analysis evolved code run re evaluated best individual run full set training test cases 
evaluation start test subsequent simulation cycle wrote state game board file 
file effectively video game board state frame 
java video player application written allows videos viewed shown 
video player controls allow test experiment selectively viewed compared 
pause button frame advance reversal allow test carefully analysed 
frame shows board state agents represented numbers 
pursuit agents numbered prey labelled 
numbering useful analysing 
experiment basic pursuit 
experiment basic pursuit version pursuit game primitives evolved homogeneous heterogeneous pursuit agents 
improve scalability adfs architecture agent consists result producing branch rpb adf 
homogeneous agents run code architecture requires set rpb adf evolved 
heterogeneous agents require sets 
detailed architecture approach shown table 
results results experiments detailed tables shown graphs figures 
evolved heterogenous agents show high capture rates 
best individual runs best run successfully captures prey training test cases 
individual generalises successfully capturing prey generalisation test cases 
behavioural analysis agents show strict task allocation divide capture task 
agent assumes different capture position prey 
allows easily avoid conflicts results high capture rate 
generalisation solution reason 
specific capture position assignment best individual run shown 
different runs evolved different assignments 
expected homogeneous agents performed badly best individual runs succeeding capture test cases 
behavioural analysis individual revealed environmental conflict resolution small number permitted moves prey test cases agents frequently got conflict situations unable resolve resulting deadlock 
homogeneous agents heterogenous agents allocate tasks dynamically 
knowing tasks allocated improbable choose task conflict agent 
way problem assign agent unique identity allow agents access identity compare identities set assignable identities 
allow homogeneous agents select tasks identity 
interested seeing tasks allocated mixture homogeneous heterogenous agents 
issues investigated subsequent experiments 

experiment basic pursuit video player trace movement pursuit agents 
experiment basic pursuit table experiment problem definition objective move agents directions enable capture 
homogeneous agents functions terminals adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf heterogenous agents functions terminals adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf fitness test cases randomly selected generation fixed test cases 
fitness average raw fitness scores test cases 
parameters pop 
termination condition best solution captures prey test cases 

experiment basic pursuit table experiment fitness best evolved homogeneous agents homogeneous basic training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean table experiment fitness best evolved heterogenous agents heterogeneous basic training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean fitness homogeneous pursuit agents basic generation 
experiment basic pursuit best average worst captures homogeneous pursuit agents basic generation best average worst experiment performance graphs evolved homogeneous agents fitness heterogeneous pursuit agents basic best average worst generation captures heterogeneous pursuit agents basic best average worst generation experiment performance graphs evolved heterogenous agents experiment capture assignment experiment identity 
experiment identity previous experiments evolved heterogenous agents successful cap turing prey noted success result static allocation tasks team members 
experiment assigned identities agents provided operators allow agents identity compare identity set identities allocated see table 
purpose experiments see evolve homogeneous agents identity allocate tasks 
experimental setup described table 
table experiment additional functions terminals primitive purpose direction agent id id return agent agent id direction return direction id identity id direction id identity id direction id identity id direction id identity id table experiment problem definition objective move agents directions enable capture 
homogeneous agents functions terminals adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast adf agent north south ifcellsequal cellyofx east west id id id id fitness test cases randomly selected generation fixed test cases 
fitness average raw fitness scores test cases 
parameters pop 
termination condition best solution captures prey test cases 
results results experiment shown table graphs 
seen evolved homogeneous agents significantly successful capturing prey 
experiment identity table experiment fitness best evolved homogeneous agents identity homogeneous identity training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean fitness homogeneous pursuit agents identity generation best average worst captures homogeneous pursuit agents identity best average worst generation experiment performance graphs evolved homogeneous agents identity percentile comparison homogeneous agents experiment 
behavioural analysis confirms allocation tasks agents identities 
fact best individual runs best run employed assignment capture positions best evolved gp heterogeneous agents experiment best run 
probably result bias created initial placement agents training set 
just experiment variations capture position assignments best gps runs 
whilst evolved agents better experiment fall short heterogenous agents experiment 
possible explanation homogeneous agents far fewer opportunities crossover single set adfs heterogenous agents crossover occurs multiple sets adfs agent 

experiment mixed agents furthermore separate set adfs allow better functional decomposition 
repeat experiments multiple adfs ability invoke adfs rpb identity agent able substantially improve results 
experiment mixed agents purpose set experiments investigate tasks allocated evolved mixture homogeneous heterogenous agents 
possible experiments instantiation pursuit domain 
experiment set homogeneous agents agent heterogeneous respect 
experiment sets homogeneous agents agents set neous respect 

experiment set homogeneous agents agents heterogeneous respect homogeneous set experiment evolved sets agent code set agents labelled second agent 
effective agents homogeneous agent heterogenous respect 
similar setup experiment sets agent code evolved time set agents second set agents 
effectively creates sets homogeneous agents sets heterogenous respect 
experiment required sets agents code developed set homogeneous agents second third heterogenous agents respectively 
problem definitions similar experiment see table archi tecture modified appropriately 
experiments architecture sets agents code evolved need adf adf adf adf 
exper adf adf rpb homogeneous agents agent heterogeneous respect uses adf adf rpb 
experiment adf adf rpb homogeneous agents set adf adf rpb second set homogeneous agents 
experiment sets agent code evolved architecture requires adf pairs total 
homogeneous agents share adf adf rpb remaining agents adf adf rpb adf adf rpb respectively 
fitness fitness fitness best average worst 
experiment mixed agents mixed pursuit agents generation captures mixed pursuit agents generation best average worst experiment performance graphs evolved mixed agents mixed pursuit agents generation best average worst captures mixed pursuit agents best average worst generation experiment performance graphs evolved mixed agents mixed pursuit agents best average worst generation captures mixed pursuit agents best average worst generation experiment performance graphs evolved mixed agents results results experiment listed tables shown graphs figures 
behavioural analysis best solutions experiments shows static task allocation possible 
experiment captures positions allocated homogeneous agents shared positions remaining capture position allocated agent 
conflicts occurred homogeneous 
experiment mixed agents experiment capture position assignment agents need dynamically choose capture positions allocated 
best individual runs experiment best run assigned cap ture positions north west south prey homogeneous agents capture position east prey agent shown 
experiment capture position assignment best solution experiment allocated sets capture positions sets agents 
conflicts avoided sets agents conflicts set 
best individual runs best run assigned capture positions north south prey homogeneous agents assigned capture positions east west prey homogeneous agents shown 
experiment capture position assignment best solution experiment best result experiments expect 
capture positions allocated homogeneous agents remaining captures positions allocated agent agent 
conflicts mainly homogeneous agents minimal compared experiments static task allocation 
best individual best run assigned capture positions north west prey homogeneous agents 
remaining capture positions east south prey assigned agents respectively shown 
results suggest gp tries optimise allocation tasks agents 

experiment mixed agents table experiment problem definition objective move agents directions enable capture 
mixed agents functions terminals adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf mixed agents functions terminals adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf adf ifnorth ifeast north south ifcellsequal east west arg arg rpb adf ifnorth ifeast agent north south ifcellsequal east west cellyofx adf fitness test cases randomly selected generation fixed test cases 
fitness average raw fitness scores test cases 
parameters pop 
termination condition best solution captures prey test cases 

experiment mixed agents table experiment fitness best evolved mixed agents mixed training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean table experiment fitness best evolved mixed agents mixed training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean 
experiment mixed agents table experiment fitness best evolved mixed agents mixed training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean 
experiment conflict resolution experiment conflict resolution purpose set experiments main focus chapter see evolve agents local information avoid resolve conflicts 
local information provided operator allows agents detect cell neighbouring cell prey occupy occupied see table 
particularly interested addition operator help homogeneous agents resolve conflicts heterogenous agents static task allocation avoid conflicts 
experimental setup detailed table 
table experiment additional terminals functions primitive purpose direction cell occupied return ifcelloccupied cell cell direction direction return results fitness homogeneous pursuit agents ifcelloccupied best average worst generation captures homogeneous pursuit agents ifcelloccupied best average worst generation experiment performance graphs evolved homogeneous agents cro fitness heterogeneous pursuit agents ifcelloccupied best average worst generation captures heterogeneous pursuit agents ifcelloccupied best average worst generation experiment performance graphs evolved heterogenous agents cro results experiment listed tables shown graphically fig 
experiment conflict resolution ures 
expected little difference performance heterogenous agents continue static task allocation avoid conflicts 
results homo agents showed substantial improvement capture rate compared homogeneous agents experiment 
behavioural analysis best individuals revealed mechanism agents improve performance far sophisticated expected expected 
intended ifcelloccupied operator ho agents avoid movement cell occupied resolving conflict 
evident test cases test cases agents viewed polite social conventions stigmergic communication resolve conflicts 
careful behavioural analysis training test cases revealed total distinct behaviour patterns combined yield sophisticated conflict resolution strategies 
behaviour patterns described 
descriptions read cell north prey read cell east cell north prey north east prey 
agents named agent agent illustration agents homogeneous behaviour peculiar agents 
behaviour en agent occupies cell agent occupies cell agent responds moving upwards freeing behaviour nn agent occupies agent occupies agent reacts moving position freeing behaviour nw 
experiment conflict resolution agent occupies agent occupies agent reacts moving position freeing behaviour ws agent occupies agent occupies agent reacts moving position freeing behaviour se agent occupies agent occupies freeing behaviour ee agent reacts moving position agent occupies agent occupies agent reacts moving position freeing simple behaviours combined create complex patterns behaviour 
example pass behaviour shown 
pass behaviour starts agent occupying agent occupying agent invokes behaviour en moves 
agent simultaneously pies position agent invokes behaviour nn moving cell freed cell simultaneously re occupied agent 
effect agent agent pass position example works agents play parts agent invokes conflict resolution behaviour cooperates resolution 

comparison random search examples behaviours shown frames captured video player ap plication behavioural analysis 
maximise illustration examples chosen test cases prey behaviours agents capturing moving prey 
minimise space frames cropped prey frames omitted change cropped region 
examples shown figures frames read left right top bottom 
example shown fifth frame agent setup follow behaviour ee move north 
happens frame agent takes occupies vacant position 
turn sets agent invoke behaviour en 
frame agent moves north agent occupies position 
agent setup behaviour nn frame moves west agent re occupies previous position 
frame agent moved position setup behaviour nw 
agent moves south frame agent occupies displaced agent occupies vacant capture position moving east 
example uses total different behaviours ee en nn nw resolve conflicts capture prey 
example similarly shows behaviours nn nw ws 
note movement predators driven best individual experiment prey examples anti clockwise 
best individuals runs similar behaviours moved clockwise 
experiment test game trace agent movement comparison random search comparison equivalent number individuals created run randomly created technique similar generate initial population 
row result tables experiment details performance best 
experiment test game trace agent movement individuals 
seen tables nearly experiments best individual created random search manage capture prey training generalisation test cases 
exception experiment single capture achieved generalisation test cases 
shows solutions evolved chance 
gp application clearly superior random search 
shown gp evolve agents allocate tasks statically dynamically identities task allocation try optimise allocation tasks detect resolve conflicts 
table experiment problem definition objective move agents directions enable capture 
homogeneous agents functions terminals adf ifnorth ifeast ifcellsequal north south east west arg arg rpb adf ifnorth ifeast ifcellsequal agent north ifcelloccupied cellyofx adf south east west heterogenous agents functions terminals adf ifnorth ifeast ifcellsequal north south ifcelloccupied east west arg arg rpb adf ifnorth ifeast ifcellsequal agent north ifcelloccupied cellyofx adf south east west adf ifnorth ifeast ifcellsequal north south ifcelloccupied east west arg arg rpb adf ifnorth ifeast ifcellsequal agent north ifcelloccupied cellyofx adf south east west east west adf ifnorth ifeast ifcellsequal north south ifcelloccupied east west arg arg rpb adf ifnorth ifeast ifcellsequal agent north ifcelloccupied cellyofx adf south east west adf ifnorth ifeast ifcellsequal north south ifcelloccupied east west arg arg rpb adf ifnorth ifeast ifcellsequal agent north ifcelloccupied cellyofx adf south east west fitness test cases randomly selected generation fixed test cases 
fitness average raw fitness scores test cases 
parameters pop 
termination condition best solution captures prey test cases 

table experiment fitness best evolved homogeneous agents cro homogeneous cro training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean table experiment fitness best evolved heterogenous agents cro heterogeneous cro training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean chapter communication sophisticated multi agent systems require agents able communicate just environment agents achieve goals 
communication may achieved implicitly changes environment explicitly direct message passing 
chapter show gp evolve agents communicate explicitly 
experiment communicating agents purpose experiment see gp evolve agents communicate solve problems 
purpose defined simple problem necessary communication take place furthermore easy measure effectiveness communication 
problem involves homogeneous agents steer vehicles placed dimensional grid 
vehicles constantly moving direction currently pointing 
movement discrete vehicles integer coordinates 
initially vehicles pointing random compass directions 
steering mechanism allows orientation vehicles changed compass directions 
goal evolve code agents steer vehicles enable meet 
vehicle model closely follows reynolds rey 
agents know positions access bi directional un buffered communication channels send receive messages 
communication channels wired connected vehicle vehicle 
message sent received vice versa 
channels send receive messages form integers 
attempt read channel message received delivered default value 
clearly agents evolve behaviours communi 
experiment communicating agents cation channels exchange position information 
vehicles equal amount energy start simulation single energy unit consumed time vehicle moves step direction 
game ends vehicles run energy meet 
fitness evolved code measured function composed parts 
part measures degree success second measures efficiency 
comparing fitness values success measure priority efficiency considered success values identical 
success measured follows euclidean distances exe cution respectively 
function produces range values varying value indicates agents moved infinite distance apart value means met 
efficiency defined percentage energy remaining simulation total amount energy allocated agents simulation total energy remaining simulation 
started providing vehicle constant surplus amount energy test case 
result code evolved social conventions obviate need communication 
agents evolve meet agreed location location 
energy test case total value times initial euclidean distance agents 
provides sufficient energy allow solutions diagonals evolve time inhibits solutions merely social conventions 
important aspect fitness function takes account difficulty test case fitness evaluation 
merely measuring distance agents simulation take account far apart start test case 
ensures test cases agents located closer starting positions test cases distances greater 
concept weighting test cases difficulty discussed greater detail chapter 
architecture 
architecture tables provide details architecture evolve programs steer agents 
single result producing branch adf returns compass direction steer vehicle 
table experiment actions performed terminals functions primitive purpose direction boolean test direction direction test return return boolean ge int int return false return true boolean lt int int return true return false int add int int return int sub int int return int senda int send message channel return int sendb int send message channel return int getx get current coordinate return int gety get current coordinate return int recva get message received channel message received return return message received int recvb get message received channel message received return return message received direction north north direction direction northeast northeast direction direction east east direction direction southeast southeast direction direction south south direction direction southwest southwest direction direction west west direction direction northwest northwest direction fitness evaluation sampling technique mentioned previous chapters 
test cases randomly generated 
test case consists random initial positions orientations agent located region 

architecture table experiment primitives functions terminals adf rpb add sub ge lt north northeast east senda sendb southeast south southwest test cases randomly generated fixed test cases 
west northwest recva recvb energy fitness average raw fitness scores test cases 
parameters pop grid range 
generation select sample unique test cases previously generated ones evaluate individual population 
fitness value awarded average raw fitness test cases 
best individual generation re evaluated complete set test cases best run highest fitness recorded far 
run best individual re evaluated test generality solution randomly generated test cases 
individual population evaluated steer achieved alternately executing gp context context result execution steer respective vehicle moved forward unit 
process repeated agents run energy meet 
pseudo code table illustrates approach 
agent table evaluation pseudo code met agent direction eval gp context agent agent agent move agent energy agent agent agent ordered execution agents important consequence delayed communication agents 
agents communication exchange position information 
results sender different position time recipient receives message 
problem definition agents meet exactly coordinates time 
agents need compensate communication delays 
results results runs experiment listed table summarised graphs 
comparison purposes number individuals generated run created technique similar generating initial population 
fitness best individual method listed table seen performed significantly worse weakest evolved individual meetings versus significantly energy energy saved versus 
table experiment results evolved communicating agents evolved code training tests generality tests run size success efficiency meetings success efficiency meetings mean furthermore runs code evolved successfully passed test cases 
solutions channels exchange coordinates adapted movement achieve goal 
addition evolved solutions means overcoming delays communication 
run run evolved best solution training tests generality tests 
gp tree representing individual shown nodes labelled pruned represent branches gp contain redundant code shown 
complete code lt fitness success recva communicating agents best mean worst generation 
results meetings communicating agents generation best mean worst experiment performance graphs evolved communicating agents senda sub recvb add senda senda sendb gety senda gety getx ge sendb sendb gety getx lt getx pruned ge recva pruned senda senda getx ge recvb lt gety ne gety recva nw recva lt nw sw senda experiment evolved parse tree best individual run table experiment simplified code run senda sendb recva recvb recva nw recvb ne recva sw se appendix simplify code shown 
clearly channels exchanging coordinates respectively 
information received channels compared local coordinates determine movement 
noted code mainly diagonal movement orthogonal movement 
result restricted amount energy allocated efficiency pressure fitness function 
getx se getx sendb getx sub sendb getx ge recva recvb ge recvb senda gety sub senda gety lt getx ge sendb getx nw lt gety 
results sw recvb sendb recvb se pruned getx ne sub recva sub ge senda gety ge sendb getx pruned experiment evolved parse tree best individual run sample traces agents movement shown 
illustrate effects evolution compared best evolved individual run test case generation generation final generation 
key differences generation whilst evolved code discovered communicate code take account staleness information 
solution misses meetings pixel distances 
code generation minimises energy uses strategies overcome communication delay 
note agents capable moving directions ne nw se sw 
terminals representing directions lost evolution 
despite absence direction agents learned achieve movement direction alternately moving sw se shown test case 
run gp tree representing best evolved solution run shown simplified code represents shown 
shown time channel communicate coordinates channel coordinates 
figures show snapshots output trace individual sample test cases 
ne recvb ge sendb getx pruned recvb 
snapshots taken point agents met ran energy 
note solution involves diagonal movement angles degree compass directions 
possible alternately moving different directions 
example repeatedly moving sequences se se ne moving se direction far steep angle just moving se direction 
shown gp evolve agents learn information transmitted received transmit receive information channel transmit receive piece information adapt behaviour communicated information solve problem deal staleness data associated communication delay conclude possible gp evolve agents explicitly communicate solve global problem 
key limitations evolved simple homogeneous agents carry state working symmetric problem 
earlier version gp conference published proceedings 
showing gp evolve communicating agents 

table experiment trace agent movement run run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent senda sendb 
table experiment simplified code run recva recvb sw se recvb recvb nw ne recvb recva ne 
table experiment trace agent movement run run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent run generation test red agent blue agent chapter able design agents existing society agents 
new agent capable interacting environment agents help achieve individual group goals 
human programmed mas ability programmed new agents 
focus chapter show gp evolve agents automatically 
particular show agent learns evolution assume purpose team communicate team members resolve conflicts interact environment achieve goals 
name process similar sociological term describes humans trained integrated members society 
previous chapters shown gp evolve homogeneous neous agents solve problems 
evolved agents learn decompose task communicate resolve conflicts 
build open mas able evolve agents society previously created agents 
devised experiments chapter determine gp achieve task 
build experi ments performed previous chapters 
communicating agents experiment best evolved communicating agent chapter best agent run instances agent evolve new agent replaces counterpart 
new agent learn communicate agent allow meet 
original experiment new agent ily exchange information channels allocated learn previously assigned purposes channels 
success experiments suggest gp create agents learn communicate society existing agents solve problem 
architecture experiment remains identical just fitness function changed fitness success communicating agents best mean worst generation 
communicating agents meetings communicating agents generation best mean worst experiment performance graphs communicating agents agent instantiated best evolved agent run original experiment 
results table experiment results communicating agent evolved code training tests generality tests run size success efficiency meetings success efficiency meetings mean results runs experiment listed table summarised graphs 
previous experiments number individuals generated dur ing run created technique similar generating initial population 
fitness best individual method listed table seen performed significantly worse weakest evolved individual terms fitness number meetings efficiency 

pursuit agents runs generated complete solutions whilst remaining close 
struc tural analysis solutions shows learned correctly communicate previously evolved agent 
furthermore agents learned communicated information account effects communication delay order achieve meetings 
note task quite complex 
new agent needs predict information sent agent agent alter behaviour 
time new agent needs learn information received govern behaviour ensure successful meetings 
simplified version best evolved solution run shown table gp tree large displayed 
seen solution correctly communicates coordinates channels respectively 
differences information agents longer homogeneous 
pursuit agents table experiment simplified code run senda sendb recvb recva recvb recva recva ne recvb nw recvb recvb nw recvb recva sw second third experiments best evolved solutions homogeneous heterogeneous conflict resolution experiments pursuit domain chapter 
homogeneous agents case instantiate predator agents previously evolved solution grow new program instantiated twice serve purpose re predators 
new agents learn homogeneous society existing agents previously evolved dynamically allocate tasks 
pursuit agents resolve resulting conflicts 
know analysis best evolved agent homogeneous conflict resolution experiment agents deal conflicts avoidance detection resolution 
conflict resolution achieved mainly means social rules conventions 
new evolved code instantiated twice forms ho subgroup agents 
agents learn social rules resolve conflicts free determine new rules help resolve conflicts 
purpose third experiment see new heterogenous agents evolved heterogenous society agents 
know best heterogeneous evolved solutions pursuit problem static task allocation minimise conflicts 
interested see evolve new agents determine tasks team overlapping tasks chosen previously evolved agents 
architecture experiments identical conflict lution experiments chapter heterogeneous predators evolving trees different agents need evolve trees different agents 
fitness func tion modified appropriately predators instances previously evolved code predators individual evaluated 
homogeneous society agents instances individual consisting adf adf 
heterogeneous agents adf adf predator adf adf predator 
experiments executed population size number generations restricted 
test case sampling scheme fitness evaluation described previous experiments 
results fitness homogeneous pursuit agents ifcelloccupied generation best average worst captures homogeneous pursuit agents ifcelloccupied generation best average worst experiment performance graphs homogeneous pursuit agents results runs homogeneous predator experiments shown table graphs 
evolved homogeneous subgroup successful original agents scoring maximum captures test cases 
behavioural analysis 
pursuit agents table experiment fitness best homogeneous pursuit agents homogeneous cro training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean best individual revealed learned behaviours described experiment ee nn 
remaining behaviour learned resulting deadlocks conflicts 
evolved subgroup learn conflict resolution capabilities previously evolved agents relatively high capture rate 
result promising suggest principle gp evolve agents learn social conventions programmed existing society agents furthermore train new agents behave social conventions 
believe scalability methods mentioned chapter greatly improve performance agents 
fitness heterogeneous pursuit agents ifcelloccupied generation best average worst captures heterogeneous pursuit agents ifcelloccupied best average worst generation experiment performance graphs heterogenous pursuit agents results runs heterogenous predator experiments shown table 
table experiment fitness best heterogenous pursuit agents heterogeneous cro training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean experiment capture position assignment graphs 
evolved heterogeneous agents spectacularly successful runs achieved capture rate 
generality best run scored capture rate 
behavioural analysis best evolved code confirmed new agents selected captures positions allocated previously evolved agents 
new agents learned interaction society role society 
shows capture position assignments best individual 
shown gp create agents 
agents evolved existing society agents 
shown society homogeneous heterogeneous communicating non communicating 
demonstrated new agents learn identify role society communicate ex members implicitly explicitly 
detect resolve conflicts 
existing members 
involve learning social conventions society 
important concept software engineering code reuse 
code reuse reduces effort required large complex systems whilst increasing robustness systems 
ability gp previously coded agents provides excellent code reuse improves scalability gp 
chapter scalability genetic programming small sized problems memory processing requirements gp quite significant 
consider example pursuit problem homogeneous predators 
assume population size individuals gp system uses bit integers node program tree 
assume worst individual consists nodes estimate space requirements assume generational engine depending implementation assume memory requirements double calculated value 
assume execute runs problem run evolves population generations evaluation generation involves running fitness function individual population total number fitness evaluations pursuit problem fitness evaluation involves testing program total test cases test case program executed times predator cycles total number evaluations program evaluations 
clearly brings question scalability gp solving medium large problems 
issue particular importance gp evolving complex multi agent systems 
key factors space required store population time taken execute fitness function 
impact factor reduced improving performance gp system requires smaller population running fewer number generations solve problems 
solving space problems reduce memory requirements genetic programming algorithm ways 
categorised main groups improving implementation gp 
solving space problems system improving performance tuning problem definition optimise performance 
implementation implement gp algorithm ways reduce space requirements 
efficient way representing population gp system directed acyclic graph dag 
handley han method represent entire population parse trees single directed acyclic graph dag 
advantage approach eliminates duplication identical subtrees 
handley reported fold reduction number nodes generation representation 
alternative linear representation tree represented polish notation byte array 
possible total number terminals functions exceed including ephemeral constants 
approach significantly reduces memory requirements 
program nodes represented kb kb calculation 
widely gp engines steady state engine generational engine 
generational engine defined koza generates entire new population old replacing 
suggest implementation require space sufficient hold twice population individuals 
koza describes memory efficient crossover algorithm requires space little populations size 
approach implemented number gp systems including gpsys 
steady state engine works placing newly created individuals population created require single population memory 
techniques cause problems population size program size scales 
memory requirements increase operating system virtual memory causing process start paging 
memory database store population 
possible need indi memory time 
fitness evaluation requires individual memory crossover requires 
store population database retrieve individuals required 
important requirement approach time taken download individual database significantly smaller evaluation time 
current rdbms allow fast storage retrieval large number objects order terra bytes retrieval individuals database impede performance significantly 
furthermore concurrent access requirements application require database locking able significantly increase performance database access 

solving space problems rdbms able apply gp particularly difficult domains population sizes large size evolved programs need large 
calculations beginnings chapter quite easily increase population size orders magnitude running problems current databases 
alternatively addition increase size individuals orders magnitude 
allow evolve megabyte size code populations millions individuals 
whilst hopeful section shall see real constraint computational load 
databases brings additional benefits results stored relational database allow easy post processing tools integrate rdbms spreadsheet calculators assuming transactions write new generation database easily restart runs system crash reboot saved generation store generation run allow analysis evolutionary flows 
need store information genetic operator create individual trees subtrees parents involved 
may help better understand gp algorithm 
population grows generation generation individ removed 
reduce loss population diversity 
tuning problem definition choose gp parameters lower space requirements 
obvious ones restrict size population size individuals population 
restricting size individuals population usually requirement nearly gp systems 
problems approach 
predict advance size solution programs 
whilst algorithmic complexity theory suggest lower bound size program actual size evolved program known 
possible solution application parsimony pressure fitness function 
second problem gp scalable need able evolve bigger programs 
adfs automatically evolved data structures may help 
single important factor successful gp application reported gp practitioners population size 
reduction population size help gp scalable 
possibility investigated ross gr 
solving space problems report small populations evolved large number generations better large populations generations 
noted high mutation rate 
considerable done demonstrate automatically defined functions evolve code re koz 
code reuse reduce size evolved solution reduce computational effort required find consequently possible 
performance optimise gp algorithm minimise required population size 
involve making better smaller population main obstacles premature conver gence bloat 
gp run prematurely converged programs start increase size reach maximum allowed sized 
code added solutions referred bloat introns effect fitness evolved program 
cause bloat studied langdon lp lp lan lp lan ang 
suggestions reduce bloat size evolved solutions 
little difference appearance bloat marks premature convergence 
premature convergence leads population converging optimal solution early run 
explanations premature convergence lack genetic diversity population 
happens proliferation fit individuals earlier run obviate need primitives needed 
small populations prone problem convergence happens rapidly 
detect loss diversity employ technique re inject population may able reduce effective population size 
ways maintaining population diversity include changing fitness test cases prevent individuals easiest test cases dominating population 
approach experiments thesis 
alternatives include competitive evolution evolve difficulty test cases programs solve 
creates continuous arms race prevents simple solutions dominating population 
technique evolve checkers program win expert checkers players having played expert cf 
demes simple effective means combating premature convergence discussed chapter 
common method defend premature convergence mutation help re create diversity re introduce lost genetic material 
koza initially avoided mutation gp relied entirely crossover changed policy 
solving processing problems 
solving processing problems ways reduce computational requirements gp run 
reduce cost evaluation reduce number evaluations required 
relies improving efficiency fitness functions improving optimising gp algorithm 
addition various techniques speed evaluation times including hardware solutions parallel distributed processing 
processing requirements aggravated paging caused excessive memory utilisation 
solution covered previous section examined 
speeding fitness processing hardware considerable progress evolutionary techniques evolve hardware 
technique involves evolving connections field programmable gate arrays fpgas reconfigured high speeds allows low level signalling exploited simulation 
doubtful technique faster simulation spice fastest general purpose processors 
fpgas tend bandwidths mhz top pentium processor exceeded ghz 
machine code gp principle get gp directly evolve machine code 
idea code generated extremely fast execution 
cost lose abstraction provided high level languages resulting larger code sizes particularly deal complex problems 
turn affects search space fewer permutations combinations operators operands node tree node tree 
efficient high level languages argued efficient high level languages offers performance advantage languages lisp note koza uses implementation gp 
languages java offer alternatives run time optimization results gpsys suggest may necessary 
compiled code code generated gp typically interpreted times fitness evaluation 
speed evaluation time significantly writing code file compiling generate machine code 
sense evaluation time takes times 
solving processing problems longer compilation time 
harris hb hb approach speed evaluation time feature detection code generated gp 
parallel distributed architectures parallel distributed architectures provides significant ways making gp scalable 
scalability comes able add processing power tally required 
parallel computers minimise costs associated having multiple processors sharing computer hardware motherboard disks memory peripherals tween processors 
main disadvantage single point failure 
limit processors added parallel processing system scalability limited 
comparison distributed architectures costly cpu offer greater flexibility easy add remove processing power 
theoretically limit computers added distributed architectures extremely scalable 
networked computer fail affecting distributed system fault tolerant 
main disadvantages cost management issues 
trend combine parallel distributed architectures produce super computing clusters offer best approach 
linux beowulf architecture example 
number techniques employ exploit parallel distributed processing evaluate individuals population parallel evolve demes parallel allowing communication demes execute number runs parallel technique works similar standard gp farm evaluation number processors 
processors may parallel processing computer hosted multithreaded operating system distributed networked comput ers 
effective time taken evaluate individual significantly larger time take communicate individuals evaluation results 
disadvantage approach fault tolerant 
processors fail need ensure evaluation individuals allocated restarted 
distributed systems complex failure semantics difficult 
technique extremely simple gp practitioners 
execute 
solving processing problems separate run processor host 
communication overheads approach 
standard gp breeding policy described panmictic potentially allows population breed individual 
alternative divide population subpopulations called demes islands 
demes typically positioned dimensional grid breeding restricted parents higher probability selected deme geographically close demes 
approach investigated haeseleer db tack ett tc 
tackett explicitly defined demes different sizes problem tunable difficulty donut problem 
results suggest demes significantly improves performance 
contrast haeseleer ex plicit demes introduce locality form geographic neighbourhoods select parents neighbourhood place child neighbourhood 
detected spontaneous emergence deme structures results report locality significantly improves population diversity conjunction slightly increased generality individuals yields substantial improvement generality population 
recalling loss population diversity reasons premature convergence demes delay convergence 
advantages approach easy implement parallel distributed architectures low communication overheads 
second advantage extremely fault tolerant loss demes halt run 
koza andre ka ak ak ak developed gp system network transputers exploit parallelism inherent model 
processor allocated separate deme 
results experiments parity problems indicated linear speed solving problem gp obtained 
shows architecture koza 
demes connected form structure advantage communication neighbouring demes ability maintain high connectivity face node failure 
bennett koza employed architecture effectively combines distributed parallel architectures provide scalable processing power 
architecture evolving programs gpps orders magnitude greater processing requirements traditional gp systems 
internet millions networked computers offers excellent possibilities ing 
exploited seti project works means specialised screen 
kicks operation long periods inactivity connects 
solving processing problems parallel gp specific computer download data processed 
results shipped back computer completion 
easy create gp system works principle 
architecture probably shaped part 
com puter hosting gp system form hub allowing communication demes occur collection results 
approach chong cho cho cho cl java gp system running applet 
poli pol pol pol devised new form gp called parallel distributed genetic programming 
uses graph representation provides fine grain parallelism 
poli shown experiments standard gp problems performs significantly better standard gp 
additional advantage allows symbolic neural processing elements combined freely pol pol 
reducing fitness function evaluation costs reducing evaluation cost ultimately relies making fitness function efficient possi ble 
effective way achieving test case sampling 
remainder simple rules thumb 
deadlock detection evolving mas programs normally repeatedly execute evolved program test case maximum number iterations permitted expended 
situations deadlock occurs executing programs needlessly reached maximum number iterations 
detection deadlock allow test case aborted save processing time 
caching 
solving processing problems fitness evaluation particularly involving adfs possible evaluation branch adf gives results regardless times executed idempotent 
case cache results memory value re evaluating code repeatedly 
handley han exploited dag representation population implement ex efficient method caching 
duplicated subtrees represented just dag representation caching computed value subtree able avoid re evaluation instantiation sub tree occurs different population 
possible restricting functions side effects fixing test cases fitness function 
approach reduced number node evaluations fold run 
reducing wasted computation aborting runs detect premature convergence abort runs ultimately fail 
detection premature convergence non trivial 
simple check ensure genetic material known part solution lost 
teller andre ta describe method reduce wasted computation fitness evaluation choosing optimal number fitness cases individual 
ross gr concept error limit prevent individuals exceed limit evaluated 
allows reduce number fitness test cases applied individual 
simplifying code copy individual evaluated remove redundant code known introns copy just evaluating 
justified long time take evaluate significantly larger time taken simplify code 
care taken prevent code side effects removed 
example subtraction resulting zero operands calls functions expensive 
koza developed lisp program automatically removed redundant code koz evaluation 
sampling test cases reducing amount tests cases program tested part fitness function simple highly effective way reducing evaluation cost 
mechanism experiments thesis variation test case sampling 
test case sampling applying full set test cases fitness evaluation sample 
solving processing problems set test cases 
typically sample size significantly smaller test case set chosen 
experiments sample size ranged th pursuit problem th communicating agents problem 
approach generation randomly sampled fixed number test cases set test cases evaluate individual generation 
fitness value assigned individual average test cases 
approach allows individuals generation compared easily 
mentioned chapter key problem approach move generation best generation may outperform current best run generally better sampled test cases easier 
ideally weight fitness values difficulty test cases passed 
unfortunately easy pursuit domain particular arrangement agents difficult measure effort required enable capture 
overcome problem devised technique generation re evaluate best individual generation full training set test cases 
individual best run full fitness value greater current best 
justify approach conducted comparison experiment experiment 
imple mented experiment identical experiment homogeneous pursuit conflict resolution operators fitness evaluation test cases individual samples size 
significantly higher computational costs meant run experiment generations 
results experiment shown table graphs 
total number evaluations indi vidual approach estimated original experiment total number evaluations estimated new experiment required times evaluations original experiment 
results new experiment compared results original experiment justify extra computational effort 
furthermore results original experiment show greater generality 
argued new experiment run generations fore total number individuals explored fewer 
comparison fairer results experiment generation table 
clearly results show just generations runs produced average general solutions 
best individual run slightly worse test cases passing significantly general 
furthermore effectively halved number evaluations state approach reduces evaluation cost significantly creates general solutions 
problem fixed set test cases overfitting 
results surprise 
solving processing problems fitness test cases generation allows successful individuals early generations swamp subsequent generations turn causes loss genetic diversity leads premature con vergence 
contrast sampling approach individuals successful generation may successful subsequent generations 
believe sampling effectively creates niches population niche contain individuals successful particular set test cases 
demes niches help preserve population diversity delay convergence 
furthermore move generation individuals propagate going score high fitness regardless test cases meaning general 
graphs show fitness capture count best generation varies generations 
graphs show averages runs best run worst 
point needs testing re evaluation best individual generation full training set test cases comparing current best run 
alternative compare full evaluation 
results obtain experiment shown table 
clearly results significantly worse original results justifying approach 
technique described ross gr random subset selection similar technique described 
fitness homogeneous pursuit agents ifcelloccupied best average worst generation captures homogeneous pursuit agents ifcelloccupied best average worst generation experiment performance graphs evolved homogeneous agents full evaluation redundancy test cases note approach run number test cases failed smaller smaller 
population converged solutions easiest test cases early run 
wasteful test cases run 
solution assign weights test cases dynamically test cases frequently passed deemed easier smaller weights infrequently passed 
scheme fitness sampling approach 
solving processing problems table experiment fitness best evolved homogeneous agents full evaluation homogeneous cro training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean fitness homogeneous pursuit agents ifcelloccupied generation captures homogeneous pursuit agents ifcelloccupied generation experiment performance graphs evolved homogeneous agents fittest generation discussed earlier augmented select test cases probabilities proportion weights 
danger approach population may forget solve earlier test cases 
dynamic way weights defined 
approach investigated ross implemented dynamic subset selection gr gat 
improving efficiency gp algorithm reduce cost evaluation reducing number evaluations required 
number generations required find solution closest highly dependent problem domain 
minimise number 
solving processing problems table experiment fitness best evolved homogeneous agents generation homogeneous cro training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean reduce size search space improve quality search space sparse improve genetic operators navigate search space improve starting population run important configuration parameters population size choice number func tions terminals maximum allowed size trees 
increasing population size increases probability obtaining solution earlier generations significant cost added evaluating generation cancel useful gains 
choice number functions terminals directly affects size search space high level functions terminals better simpler ones 
estimate upper bound number possible program trees generate 
assume trees represented polish notation treat simple strings code 
assume maximum size strings restricted symbol set size total number functions terminals 
total number strings shows importance parameters 
note significant overestimate assumed symbols equal may combined arbitrarily 
practice symbols functions whilst terminals 
terminals subtrees restriction generate strings 
furthermore strongly typed gp system mon reduce number possible strings 
solving processing problems table experiment fitness best homogeneous agents run re evaluation homogeneous cro training tests generality tests run size fitness av 
cycles captures fitness av 
cycles captures mean generate 
may impact quality search space negative way making sparse example making difficult find solutions cancelling gains 
adfs restrict maximum size evolved solution reduce size search space 
mechanism known negatively impact quality search space koz 
improving quality search space difficult 
major factors difficulty problem choice functions terminals fitness function 
ideal fitness function sensitive extremely subtle changes performance continuous measurement discrete 
challenge describe problem fitness function characteristics 
standard crossover mutation genetic operators generate new individuals blindly parent 
result new individual probability fit portions code disrupted 
creating intelligent genetic operators avoid disrupting part code marked useful may help evolution 
teller tv tel developed intel crossover operator learns select crossover points information execution path evolved programs 
reported significant improvements rate production fitter children operator 
langdon analysed shape trees generated initial population affect performance run lan 
suggested problems divided types solutions trees deep wide 
creation 
method parameter gp systems specify shape initial population values including grow full ramped half half koz 
grow method tends create short trees full method creates deep trees 
choose wrong type problem may disadvantage run 
analysis fittest individuals randomly shaped trees may provide insight value parameter 
provided solution space complexity issues gp database shown key issue fitness evaluation 
reviewed techniques currently alleviate demands fitness evaluation shown experimentation fitness sampling extremely effective 
chapter genetic programming software testing compare human software development cycle software generated gp note test cases software engineering verify program conforms requirement specifications gp test cases fitness function requirement specifications 
analog traditional software testing phase gp testing perform run generalization evolved code 
note comparing results tests specifications test cases specification 
strong dependency gp software testing suggests formal software testing techniques extremely important gp 
surprising little done formal software testing gp 
chapter consider formal software testing techniques comment suitability genetic programming 
particular look techniques suitable testing distributed multiagent systems 
fitness evaluation evolving programs gp measure programs fitness testing program measuring success 
test programs initialising inputs predefined parameters executing program measuring way difference desired output output obtained 
tuple consisting input values desired outcome define test case 
gp desired outcome effectively encoded fitness function input values test case required 
test cases needed test program 
ideally apply possible test cases application get accurate measure program correctness fitness 
practice seldom feasible due large number test cases possible 
consider example pursuit problem 
predators prey placed cells board 

fitness evaluation place prey positions choose positions need choose positions predators 
predators homogeneous choose cells order independent manner 
heterogeneous predators order matters need consider permutations different orderings 
number possible combinations selecting cells homogeneous agents positions binomial efficient evaluates positions 
multiplying prey positions gives approximately test cases 
heterogenous agents additional factor consider ordering predators important 
gives approximately test cases 
things worse multiply values different number programs drive prey effectively different test case 
typical gp run consisting population individuals evolved generations allowing cycles test case require evaluations program 
clearly exhaustive testing program going possible 
forced take small subset test cases training purposes 
experiments pursuit problem chose test cases different placements different types prey 
furthermore test cases reduce time taken evaluate individuals exposed generation sample test cases chosen random generation 
note implementation pursuit problem agents stateless new test case effectively created simulation cycle 
effective number test cases seen individual evaluation times number scheduled test cases 
small number considering full space test cases 
testing generality evolved solution run sample full space possible test cases high cost evaluations 
experiments generated unique random positions agents created test cases randomly moving preys 
software testing central gp conclude gp research community benefit greatly experience gained formal software testing human coded programs 

software testing quality control software testing quality control testing human coded computers programs established part software engi neering 
number developed techniques test software hope show techniques test programs evolved gp 
definition software testing intuitive think testing means checking program achieves tended purpose 
definition quite reasonable random set inputs compare output desired output 
classic book art software testing mye myers argues better definition testing process executing program intent finding errors successful test case detects error 
definition apparent random input testing effective 
myers describes random input test ing probably poorest testing methodology 
think tests terms probability finding errors clear approach optimal close optimal 
weakness myers definition testing relies entirely program execution testing techniques require program executed 
leads het general definition testing measurement software quality 
quality means meets customers requirements definition advantage allows metrics program success may judge quality software size code economy resources execution time 
furthermore doesn just rely program execution 
weakness definition requirement specifications whilst clear program seldom specify undesirable features 
surprising list undesirable behaviour larger list desirable behaviour 
beizer bei lists part reasons testing software falsify object respect stated unstated requirements validate object show works help evaluate quality software 
tests falsify software called dirty tests negative tests 
validation called clean tests positive tests 

black box testing types tests get measure correctness program 
falsification validation important aims fitness function 
know discussion earlier chapter exhaustive testing impossible 
testing perform incomplete 
goal cover errors possible minimum number test cases 
key issue software testing test case design subset possible test cases highest probability detecting errors techniques developed software testing help answering question 
techniques divided sets black box testing white box testing 
hybrid techniques combine maximise test coverage 
black box testing black box behavioural functional dynamic testing names testing techniques test programs executing 
treat program black box inputs outputs concerned structure internal behaviour underlying code 
tests performed applying different inputs checking output conformance requirements 
clearly complete testing require tests possible set inputs possible 
consider example testing optimizing compiler 
equivalence partitioning boundary value analysis cause effect graphing error guessing methods design black box test cases maximise error coverage minimum number test cases 
beizer mye lists techniques require building graph model program tested rely assumptions structure code tested 
equivalence partitioning equivalence partitioning powerful means reducing number test cases needed 
approach involves partitioning input domain program finite num ber equivalence classes testing value class equivalent test value 
test class detects error error detected tests class 
equivalence classes overlap possible test case may simultaneously representative tests class 
type test cases useful fits single equivalence class 
consider communicating agents chapter easy see kind equivalence partitions create 
axis creates quadrants agents located quadrant different quadrants possibility seen 
white box testing equivalence class 
case easy enumerate total number relative positions terms quadrants 
alternatively partition test case space just relative positions coordinates equivalence partition 
schemes invariably result overlaps satisfied fewer test cases total number equivalence classes 
boundary value analysis general principle boundary value analysis test cases explore situations near edges equivalence classes higher probability finding errors 
just picking value equivalence class select values put edge equivalence class test 
furthermore approach input equivalence partitions output equivalence partitions 
typically values selected boundary near boundary boundary segment near boundary segments 
technique called extreme value testing 
partitions defined inequalities set inputs referred domains term domain testing boundary analysis 
cause effect graphing cause effect graphing useful finding errors associated combinations input values 
type errors exposed previous methods 
general principle translate hand requirement specification boolean graph cause effect graph set graphs cause distinct input condition equivalence class effect output condition system change 
graph annotated constraints eventually converted limited entry decision table column table represents test case 
error guessing error guessing involves predicting type errors system knowl edge application domain statistical information relative frequency occurrence different types errors 
white box testing white box structural logic driven static testing names test techniques source code 
tests created examining program logic selecting inputs exercise logic possible 
analogue exhaustive input testing white box testing exhaustive path testing 
exhaustive path testing requires execute possible 
white box testing paths control flow program 
infeasible due large number flows created conditionals loops function calls 
number methods available white box testing including statement decision condition decision condition multiple condition coverage 
methods automated enable white box test cases generated program 
test generation tools white box testing 
statement coverage statement coverage requires design test cases statement program gets executed 
weakness approach exercise condi tional statements 
result paths containing errors may exercised 
decision coverage decision coverage requires write test cases decision statement program true false value 
assuming program contains decision statement examples include switch decision coverage provide statement coverage 
condition coverage decision statement consists condition ensure condition tested condition coverage 
condition coverage requires write test cases condition decision assumes possible values 
decision condition coverage condition coverage subsume decision coverage 
consider example note condition coverage requires create test cases represented tuples true false false true 
clearly cause statement guarded clause executed 
needs decision coverage 
decision condition coverage requires write test cases condition decision decision takes possible outcomes 
multiple condition coverage programming languages lazy evaluation evaluate condition operations example condition expression false second condition evaluated 
similarly expression condition true second evaluated 
ensure errors logical expression detected multiple condition coverage 
requires test case written possible combinations conditions decision covered 
multiple condition coverage subsumes decision condition condition decision coverage 

applying software testing gp applying software testing gp test cases important phases gp 
phase training purposes second generalisation 
training phase training phase program generation tested function 
fitness function executes program set test cases measures success 
test cases designed software testing techniques white box black box testing 
programs testing gp constantly changing tests generated white box testing techniques reused need re generated program evolutionary 
clearly costly 
black box testing techniques ideal rely structure code tested 
implication design test cases black box techniques testing generated program 
black box techniques equivalence partitioning boundary value analysis help design minimum number test cases cover large areas test space 
theory better random testing techniques commonly fitness functions accurate efficient 
turn help scale gp 
noted black box techniques number test cases high evaluating individual sampling technique detailed previous chapter experiments applicable 
main difference test cases sampled designed maximum coverage 
mentioned earlier clean tests validation dirty tests cation 
key issue needs researched ratio clean versus dirty tests affects evolution 
generalisation run gp practitioners usually retest program unseen test cases check generality solution 
typically done larger sample randomly generated tests 
quality control mechanism far optimal 
better strategy combination white box black box test techniques provide accurate measure quality program 
white box test techniques run single program need generate test cases 
paradox 
testing distributed multi agent systems human coded software information errors detected set tests edit programs remove occurrences errors 
usefulness set test cases decreases 
similar process happens gp 
evolution pro test cases passed individuals population 
effectiveness test cases decreased 
software testing techniques evolved program errors try detect 
suggest research evolve test cases application interesting 
testing distributed multi agent systems surprising shortage research testing distributed systems 
reasons testing distributed multi threaded applications times diffi cult testing non distributed systems 
research focussed formalised design techniques try reduce errors 
non exhaustive list issues associated testing distributed systems apply equally multiagent systems transient failures distributed programs suffer failures caused temporary condi tions network delays due high volumes traffic router failures causing network partitions 
communication delays result timing errors cause process fail turn causes tests fail 
tests repeated errors may occur 
reproducibility execution distributed application may depend order component processes executed order messages received 
execution application inputs may yield results 
observability attempt gain information behaviour distributed appli cation may change behaviour example errors disappear introduced observer 
known probe effect 
timing distributed system global clock 
analysis system logging test execution accurately provide information sequence events 
notion logical time causal ordering 
krawczyk hk provide detailed analysis issues testing distributed software applications 

low chen lcr propose methodology automatically generating test cases test bdi agents 
methods white box testing techniques 
divide test coverage node criteria plan criteria 
nodes similar statements node criteria similar statement coverage 
key differences nodes fail 
plan consists set nodes connected arcs create node path 
plan successfully executed executing nodes path 
failure plan occurs nodes path fail 
communicative interaction agents modeled notion connected plans 
propose gp practitioners benefit significantly better understanding soft ware testing techniques developed software engineering 
shown black box techniques design efficient accurate fitness functions shown combining black box white box test techniques accurately mea sure quality programs evolved gp 
noted lack documented sys methods testing distributed multiagent systems may difficult apply gp domains 
hope strong dependency gp software testing intensive manner testing may help advance research software testing 
chapter elegance gp programming multiagent system comes able search desired behaviour individual group level simultaneously 
gp avoid having deal micro macro problem 
generate agents micro level evaluate macro level 
agents best evaluations fitness create new agents micro level 
process iterated desired micro macro level behaviours emerge 
fitness function need detail agent behave interact environment 
just needs provide relative measure successfully agents solve global problem 
potential ways agents interact environment agents specified function terminals sets 
advantages gp approach rely extensive domain knowledge focussed performance matters 
note performance measured number ways ranging effectively systems meets goals efficiently achieved 
review chapters gp evolve agents show coordinated coherent 
chapter evolved homogeneous heterogeneous pursuit agents game rules test cases biased creating conflicts 
showed easier evolve successful heterogeneous agents homogeneous agents 
explanation heterogeneous agents avoided conflicts statically allocating tasks 
homogeneous agents allocate task dynamically difficult 
showed identities homogeneous agents perform heterogeneous agents 
noted problem dynamic task allocation agents prone task overlap 
task overlap turn results greater conflicts 
added operator thought helpful resolving conflicts 
tried evolve agents pur suit problem additional operator showed homogeneous agents developed 
solving key issues mas research social conventions help detect resolve potential conflicts 
chapter showed gp create multiagent systems agents communicate explicitly 
showed evolutionary process create programs learn send receive information channels 
programs decided information sent channels interpret information received channel achieve task hand 
chapter evolved agents learn society existing agents 
agent evolved learns communicate best agent evolved chapter 
evolved program interaction environment agent learned cor rectly interpret information received communication channels information needs transmit communication channels 
showed evolve pair heterogeneous agents learn heterogeneous agents best evolved heterogeneous agents experiment 
heterogeneous agents chapter strict task allocation avoid conflict 
new agents learned divide remaining tasks 
showed evolve program drives pair homogeneous agents interact existing society homogeneous agents best evolved homogeneous agents experiment predefined social conventions resolve conflicts 
showed newly program part learn behave social convention existing society certainly exploit conventions 
chapter considered scalability issues genetic programming reviewed possible solutions 
concluded fitness evaluation key scalability issue 
chapter proposed software testing techniques software engineering may useful genetic programming 
believe gp evolve agents shifts emphasis effort required building mas designing ways testing 
argue area research emphasis may limit gp 
solving key issues mas research rough attempt gp tackle key issues mas described chapter 
important point jennings jsw issues intertwined 
answers propose rely single coherent methodology tries address issues simultaneously 
shift emphasis particular problems solving 
accept view proposed extreme view create questions answers formulate mas problem defining fitness function 
fitness function needs 
solving key issues mas research encode way measuring successful agents solving problem 
principle way achieving generate test cases specifications desired behaviour 
decompose problem automatically specifying agents evolved capabilities agents possess specified function terminal sets 
furthermore evolve agents allocate tasks statically dynamically 
quality result synthesis measure evaluating programs agents constrain search programs drive agents synthesising results 
shown chapters gp evolve agents communicate implicitly explicitly 
agents decided communicate develop interpretation communicated 
chapter shown agents learn communicate existing agents predefined interpretation communicated information 
model communication function calls act sending message calling function 
act responding message executing function called returning result 
demonstrated gp evolve functions adfs koz able evolve sophisticated communicative behaviour quite easily 
providing fitness function measures success evolved agents group level believe able eliminate programs cause agents incoherent manner 
similarly harmful interactions may removed 
avoid mitigate harmful system behaviour chaotic oscillatory behaviour design fitness function penalises behaviour 
communication delays agents chapter caused agents early evolution exhibit behaviour eventually removed natural selection 
showed chapter agents evolved recognize reconcile conflicting intentions trying coordinate actions 
agents experiment learned avoid detect resolve conflicts 
gp create programs agents may may need interact agents 
application requires agents need interact implicitly encoded fitness function possible primitives provided 
evolutionary process favour programs cause agents interact desirable ways 
shown chapter knowledge agents gained purely 
tasks initiation completion implicit fitness function rewarding agents correctly identify conditions 
pursuit domain chapter evolved predator agents moved prey completely surrounded 
methodology automatically programming multiagent systems gp maintained position prey surrounded 
recognised state coordinated process 
chapter evolved agents having primary goal secondary goal reduce expenditure resource energy 
showed evolve agents solve problem simultaneously economical resources 
just easily attach penalties fitness function reduce consumption resource utilisation needs control communication 
believe technique balance local computation communication 
propose gp general methodology developing dai systems 
careful design function sets terminal sets fitness functions engineer constrain practical dai systems 
methodology automatically programming multiagent systems gp methodology automatically programming mas requires computing en vironment strongly typed genetic programming system supporting adfs gpsys 
environment identical closely simulates environment agents safely test agents controlled manner 
scalable computer architecture support 
preparatory steps required code gp mas application 
involve ing 
environment 
agent classes 
architecture 
function sets 
terminal sets 
fitness function 
run parameters 
termination criteria 
methodology automatically programming multiagent systems gp environment need define environment agents operate 
environment iso lated predefined agent society operating environment populated agents 
agent classes need choose agents cooperative competitive homogeneous heterogeneous mixed agents reactive deliberative memory communicative non communicative choice decide agents wish generate cooperate compete 
competitive agents generally require separate populations evolved cooperate trading agents 
cooperative agents evolved heterogenous teams homogeneous agents 
create purely reactive agents omit memory operators provide means storing state information 
communicative agents require operators allow communication take place explicitly agents chapter implicitly agents chapter experiment 
helpful know agents require may possible discover number automatically evolution ben ben 
architecture agent class needs evolved need define set adfs including result producing branch 
alternatively parameterise gp system evolve architecture architecture altering operations reported koza 
function terminal sets class agent need evolve need define function terminal sets 
contain functions terminals compute decisions communicate agents sense manipulate environment 
fitness function key evolving mas correctly define fitness function 
fitness function measure closely agents achieve intended purpose awarding higher fitness 
critical assessment individuals successful 
add criteria fitness function measure efficiently agents achieve purpose 
penalise unwanted behaviour defining laws cost repercussions broken penalties human legal systems 
fitness evaluated testing evolved code test cases representative real problems agents solve 
evaluation involves instantiating desired number agents class evolved code iteratively executing test case problem solved maximum number iterations expired 
termination criteria run parameters described chapter 
critical assessment key limitations symmetric problem domains limited complexity 
apply technique real world problems 
focussed attention evolving evolving cooperative agents homo heterogeneous investigate competitive evolution neous agents 
evolved purely reactive agents 
proposed software testing techniques may useful gp perform experiments support proposal 
lists research directions stemming gp real world large scale mas applications gp mas problems competitive evolution heterogeneous agents evolving agents memory diverse agent societies 
adfs communicating agents modeling communication function calls design patterns mas agent learning baldwin effect evolving distributed algorithms scalability gp software testing gp automated software testing mas investigating evolution human languages evolving communicating agents addition propose kolmogorov chaitin complexity theory may prove useful gp discussed 
algorithmic complexity computer programming evolution algorithmic complexity theory roots information theory proved useful diverse domains including probability theory cryptography communication compression algorithms lv 
may help formulate theoretical framework genetic programming 
process programming computer thought creating sequence bits code algorithm generate right output sequences set input sequences 
algorithms codes 
simplest uses table lookup map input output number bits input pairs 
note program try generalisation inputs outputs fail new inputs tables 
compares concept overfitting gp 
program code shorter number bits required mapping table higher complexity simplest program 
complex program shortest program describe algorithm abstracts relationship input output pairs general 
furthermore expect binary sequence representing program random program incompressible irreducible 
note pattern mapping inputs outputs program equivalent table lookup 

assuming fitness function rewards programs generate correct output input rewards parsimony expect evolutionary process lead fit programs small 
demonstrated gp applications 
fitness function try find minimal program 
compressible 
way describing evolution means generating random sequence bits program input sequence bits encodes computation required generate required sequence bits output 
think fitness function kind test randomness finite sequence bits 
fitness proportionate selection selects bit sequences proportions related randomness 
describe crossover process take sequences bits high complexity fitness exchange random subsequence bits sequence yield new sequences 
point operation generate random sequences bits higher fitness 
mutation thought replacing subsequence bits sequence bits randomly generated bits 
conclude generation random bit strings side effect evolutionary process 
obstacle theory inclusion introns real life dna programs evolved gp 
introns redundant segments code effect program increasing size 
effect execution really part algorithm description exclude tests compressibility 
carry experiments test theory measuring compression ratios individual fitness see correlation 
general compression programs gnu gzip compress text representation individual calculate compression ratio size compression divided size compression 
possible large programs provided remove introns evaluating compressibility 
true average fitness population increases expect population converge bit sequences difficult compress 
simple test general compression program gnu gzip compress populations generation run see relationship average fitness compressibility 
compressibility uncompressed size divided compressed size 
find compressibility tends population converges solution 
summary 
summary achieved objectives showing gp evolve mas automatically 
particular shown gp evolve agents exhibit coordinated coherent behaviour chapters resolve conflicts chapter communicate explicitly doing decide communicate chapter integrated existing society agents chapter examined scalability issues involved gp generally par ticular technique automatically programming agents proposed solutions problems 
related scalability examined importance formal software testing techniques development gp technology looked issues involved testing mas 
lastly proposed methodology automatically programming multiagent systems gp 
appendix best evolved pursuit agents experiment basic homogeneous best run adf ifeast adf arg adf arg south ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg east ifnorth adf arg adf arg north ifeast adf arg adf arg east north east north ifnorth adf arg adf arg ifnorth adf arg adf arg east east ifeast adf arg adf arg east ifnorth adf arg adf arg ifnorth adf arg adf arg west ifnorth adf arg adf arg north south west adf ifeast cellyofx ifnorth cellyofx south cellyofx agent ifeast cellyofx agent north cellyofx agent south north adf cellyofx west cellyofx ifeast cellyofx east cellyofx west north east adf cellyofx agent north cellyofx agent ifeast cellyofx east cellyofx agent ifcellsequal cellyofx agent north cellyofx west adf cellyofx west cellyofx agent south south ifeast cellyofx adf cellyofx north cellyofx west cellyofx agent ifnorth cellyofx agent cellyofx agent south west ifcellsequal cellyofx agent south cellyofx agent east east ifcellsequal cellyofx agent cellyofx east west south ifeast cellyofx agent adf cellyofx agent west cellyofx agent south cellyofx ifnorth cellyofx south cellyofx east east east ifeast cellyofx agent south cellyofx west adf cellyofx west cellyofx south ifeast cellyofx east cellyofx south east north cellyofx south adf cellyofx west cellyofx ifnorth cellyofx west cellyofx agent ifeast cellyofx agent south cellyofx agent south adf cellyofx east cellyofx north adf cellyofx agent west cellyofx south adf cellyofx east cellyofx agent ifeast cellyofx agent east cellyofx agent north ifcellsequal cellyofx agent south cellyofx west west north north adf cellyofx agent west cellyofx ifnorth cellyofx agent adf cellyofx agent south cellyofx north cellyofx ifeast cellyofx west cellyofx agent adf cellyofx west cellyofx agent north east ifeast cellyofx agent south cellyofx west north west adf cellyofx cellyofx agent north adf cellyofx agent north cellyofx south fitness fitness complexity 
experiment basic heterogeneous best run experiment basic heterogeneous best run adf ifnorth adf arg adf arg east ifnorth adf arg adf arg north ifcellsequal adf arg adf arg ifeast adf arg adf arg ifnorth adf arg adf arg north ifnorth adf arg adf arg north ifnorth adf arg adf arg ifnorth adf arg adf arg south east east west west adf adf cellyofx agent adf cellyofx agent adf cellyofx cellyofx west cellyofx agent ifcellsequal cellyofx agent north cellyofx west south cellyofx west adf ifnorth adf arg adf arg ifeast adf arg adf arg south west ifnorth adf arg adf arg ifeast adf arg adf arg north west ifeast adf arg adf arg ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifnorth adf arg adf arg south south ifnorth adf arg adf arg ifcellsequal adf arg adf arg north ifnorth adf arg adf arg ifcellsequal adf arg adf arg north south west north ifeast adf arg adf arg north west ifnorth adf arg adf arg south east adf adf cellyofx agent ifnorth cellyofx ifnorth cellyofx cellyofx agent ifnorth cellyofx cellyofx west ifnorth cellyofx east cellyofx east west ifnorth cellyofx agent east cellyofx east cellyofx ifnorth cellyofx west cellyofx west ifeast cellyofx south cellyofx agent west west east south ifnorth cellyofx east cellyofx south west west ifnorth cellyofx west cellyofx west east south cellyofx ifeast cellyofx north cellyofx agent ifcellsequal cellyofx cellyofx west north adf ifeast adf arg adf arg ifeast adf arg adf arg ifcellsequal adf arg adf arg ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg north east east north ifeast adf arg adf arg ifcellsequal adf arg adf arg east north east ifnorth adf arg adf arg ifeast adf arg adf arg west ifeast adf arg adf arg west west ifeast adf arg adf arg ifnorth adf arg adf arg ifnorth adf arg adf arg north south north ifeast adf arg adf arg ifcellsequal adf arg adf arg north north ifcellsequal adf arg adf arg north east ifeast adf arg adf arg ifcellsequal adf arg adf arg ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg north south north north ifeast adf arg adf arg ifcellsequal adf arg adf arg east north east ifnorth adf arg adf arg ifeast adf arg adf arg west ifeast adf arg adf arg west north ifeast adf arg adf arg ifnorth adf arg adf arg south ifnorth adf arg adf arg north south north ifcellsequal adf arg adf arg north north adf ifnorth cellyofx adf cellyofx agent east cellyofx ifeast cellyofx south cellyofx ifnorth cellyofx east cellyofx west north ifcellsequal cellyofx cellyofx agent north south east cellyofx ifeast cellyofx south cellyofx agent adf cellyofx agent south cellyofx ifnorth cellyofx east cellyofx west east west north ifnorth cellyofx agent south cellyofx west north west ifnorth cellyofx agent north cellyofx agent east adf cellyofx agent adf cellyofx east cellyofx ifeast cellyofx south cellyofx ifnorth cellyofx east cellyofx agent west east ifcellsequal cellyofx cellyofx agent north west east cellyofx north south adf ifnorth adf arg adf arg ifeast adf arg adf arg ifeast adf arg 
experiment identity best run adf arg ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg east south west ifnorth adf arg adf arg south south ifcellsequal adf arg adf arg ifeast adf arg adf arg east west ifeast adf arg adf arg west ifeast adf arg adf arg west ifnorth adf arg adf arg south west ifnorth adf arg adf arg west east adf ifcellsequal cellyofx agent cellyofx agent ifcellsequal cellyofx agent ifnorth cellyofx ifeast cellyofx west cellyofx agent south west north cellyofx agent ifeast cellyofx agent cellyofx agent west ifeast cellyofx north cellyofx south north south north cellyofx agent east ifcellsequal cellyofx adf cellyofx agent west cellyofx cellyofx west south south ifeast cellyofx agent ifeast cellyofx north cellyofx cellyofx agent ifeast cellyofx agent ifeast cellyofx agent west cellyofx north east north cellyofx ifcellsequal cellyofx ifnorth cellyofx agent west cellyofx south south cellyofx agent adf cellyofx agent cellyofx north west ifnorth cellyofx agent north cellyofx west ifcellsequal cellyofx agent south cellyofx agent west south adf cellyofx ifeast cellyofx agent north cellyofx south north cellyofx agent adf cellyofx cellyofx north ifnorth cellyofx ifeast cellyofx west cellyofx agent south south north cellyofx agent ifeast cellyofx agent ifeast cellyofx agent west cellyofx agent south south south cellyofx agent west ifeast cellyofx north cellyofx north south north west fitness fitness complexity experiment identity best run adf ifeast adf arg adf arg west ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg east ifnorth adf arg adf arg north ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg east west north east ifnorth adf arg adf arg north ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg east south west east adf adf cellyofx west cellyofx agent ifeast cellyofx agent ifeast cellyofx agent ifcellsequal cellyofx agent north cellyofx id west south south cellyofx ifnorth cellyofx agent north cellyofx agent id north east ifcellsequal cellyofx agent cellyofx agent id north west adf cellyofx agent south cellyofx agent south ifeast cellyofx agent id equals agent id south cellyofx ifcellsequal cellyofx agent cellyofx agent north agent id west east south ifcellsequal cellyofx cellyofx id south north ifnorth cellyofx agent cellyofx agent ifeast cellyofx north cellyofx north north ifcellsequal cellyofx cellyofx agent agent id agent id north id south south cellyofx ifnorth cellyofx id north east cellyofx agent id north west west adf cellyofx cellyofx west ifeast cellyofx agent id 
experiment basic best run agent id south east cellyofx agent ifeast cellyofx agent ifcellsequal cellyofx agent cellyofx agent agent id north south south cellyofx ifnorth cellyofx agent north cellyofx agent id north east ifcellsequal cellyofx agent north cellyofx agent west id north west adf cellyofx cellyofx agent south ifeast cellyofx agent id id south cellyofx ifcellsequal cellyofx agent cellyofx agent north id west south ifcellsequal cellyofx cellyofx id south south north ifnorth cellyofx agent cellyofx agent ifeast cellyofx north cellyofx north south north ifcellsequal cellyofx cellyofx agent agent id north west south ifnorth cellyofx agent agent id cellyofx west ifeast cellyofx agent cellyofx west north fitness fitness complexity experiment basic best run adf ifcellsequal adf arg adf arg ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg ifnorth adf arg adf arg east ifnorth adf arg adf arg north east east south ifnorth adf arg adf arg south ifnorth adf arg adf arg north ifeast adf arg adf arg ifnorth adf arg adf arg ifcellsequal adf arg adf arg south east east south east adf ifeast cellyofx agent ifeast cellyofx ifeast cellyofx adf cellyofx east cellyofx agent south cellyofx agent east ifcellsequal cellyofx agent north cellyofx south east east cellyofx south ifeast cellyofx agent ifnorth cellyofx north cellyofx west west north cellyofx adf cellyofx agent south cellyofx north ifnorth cellyofx agent north cellyofx north west north adf cellyofx ifcellsequal cellyofx north cellyofx east east cellyofx agent west cellyofx ifeast cellyofx east cellyofx agent ifcellsequal cellyofx agent cellyofx agent west ifcellsequal cellyofx agent adf cellyofx north cellyofx agent south cellyofx north adf cellyofx agent west cellyofx north west north ifcellsequal cellyofx agent south cellyofx east ifeast cellyofx north cellyofx east adf cellyofx agent north cellyofx agent east west adf cellyofx east cellyofx south adf cellyofx agent ifeast cellyofx ifnorth cellyofx agent north cellyofx east west north cellyofx east north north cellyofx adf cellyofx agent ifcellsequal cellyofx agent north cellyofx agent north north south cellyofx agent west adf ifnorth adf arg adf arg ifeast adf arg adf arg ifnorth adf arg adf arg south north ifnorth adf arg adf arg ifnorth adf arg adf arg ifeast adf arg adf arg north ifnorth adf arg adf arg south north north ifnorth adf arg adf arg ifnorth adf arg adf arg ifeast adf arg adf arg ifnorth adf arg adf arg north north east ifnorth adf arg adf arg ifnorth adf arg adf arg north south ifcellsequal adf arg adf arg south ifcellsequal adf arg adf arg east south adf ifnorth cellyofx east cellyofx agent ifeast cellyofx agent north cellyofx west ifeast cellyofx agent cellyofx agent north north south ifnorth cellyofx agent adf cellyofx agent ifeast cellyofx west 
experiment basic best run cellyofx agent south north cellyofx east cellyofx ifeast cellyofx agent cellyofx north ifnorth cellyofx cellyofx west ifnorth cellyofx west cellyofx agent ifeast cellyofx agent cellyofx agent north north east west north east ifcellsequal cellyofx agent cellyofx west ifnorth cellyofx agent ifcellsequal cellyofx south cellyofx agent east ifnorth cellyofx agent cellyofx agent north ifnorth cellyofx east cellyofx agent west north cellyofx ifcellsequal cellyofx agent north cellyofx north ifnorth cellyofx cellyofx west ifnorth cellyofx west cellyofx agent north north west north west fitness fitness complexity experiment basic best run adf ifnorth adf arg adf arg ifeast adf arg adf arg west ifeast adf arg adf arg ifeast adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg south ifnorth adf arg adf arg west ifcellsequal adf arg adf arg ifnorth adf arg adf arg west ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg west west south ifeast adf arg adf arg east north adf ifeast cellyofx east cellyofx agent ifeast cellyofx ifcellsequal cellyofx south cellyofx agent south south east cellyofx ifeast cellyofx agent north cellyofx agent north east east west ifcellsequal cellyofx cellyofx west cellyofx east east north cellyofx ifcellsequal cellyofx agent cellyofx east adf cellyofx east cellyofx adf cellyofx agent east cellyofx north ifeast cellyofx west cellyofx agent west west adf cellyofx ifcellsequal cellyofx agent cellyofx east east cellyofx agent east east adf ifeast adf arg adf arg ifnorth adf arg adf arg ifeast adf arg adf arg north ifcellsequal adf arg adf arg north ifeast adf arg adf arg ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg south ifeast adf arg adf arg ifcellsequal adf arg adf arg north west north north ifnorth adf arg adf arg ifeast adf arg adf arg west ifcellsequal adf arg adf arg east ifeast adf arg adf arg ifcellsequal adf arg adf arg south north west north ifnorth adf arg adf arg east south adf ifeast cellyofx agent ifnorth cellyofx ifnorth cellyofx north cellyofx agent north east south cellyofx west east adf cellyofx south cellyofx agent west cellyofx agent south ifnorth cellyofx north cellyofx agent ifnorth cellyofx agent cellyofx agent west west west ifeast cellyofx agent ifcellsequal cellyofx cellyofx east adf cellyofx south cellyofx agent west cellyofx west adf cellyofx west cellyofx south west adf cellyofx agent ifnorth cellyofx ifnorth cellyofx agent west cellyofx south west south cellyofx east east adf cellyofx south cellyofx agent south cellyofx fitness fitness complexity 
experiment basic best run experiment basic best run adf ifnorth adf arg adf arg north ifeast adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifnorth adf arg adf arg north ifeast adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg south ifcellsequal adf arg adf arg north east ifcellsequal adf arg adf arg east north east ifcellsequal adf arg adf arg east ifcellsequal adf arg adf arg east north ifcellsequal adf arg adf arg east north east adf ifeast cellyofx south cellyofx agent ifnorth cellyofx agent ifcellsequal cellyofx agent cellyofx north ifcellsequal cellyofx agent cellyofx south south ifnorth cellyofx cellyofx agent south east north cellyofx south ifeast cellyofx ifeast cellyofx east cellyofx agent east west east cellyofx ifcellsequal cellyofx agent east cellyofx north north south west north north ifeast cellyofx agent cellyofx adf cellyofx agent west cellyofx agent ifeast cellyofx agent west cellyofx west east south adf cellyofx north cellyofx ifeast cellyofx agent adf cellyofx south cellyofx north cellyofx east ifeast cellyofx agent ifnorth cellyofx agent south cellyofx agent south east east cellyofx agent ifnorth cellyofx east cellyofx agent east west south ifnorth cellyofx agent east cellyofx north west west west ifcellsequal cellyofx agent ifcellsequal cellyofx agent ifnorth cellyofx north cellyofx agent east south ifcellsequal cellyofx agent north cellyofx agent north north east cellyofx agent ifeast cellyofx south cellyofx east west ifcellsequal cellyofx north cellyofx east ifcellsequal cellyofx north cellyofx east south adf cellyofx ifeast cellyofx cellyofx agent west north south cellyofx ifnorth cellyofx cellyofx west north cellyofx agent ifeast cellyofx ifeast cellyofx agent west cellyofx east south cellyofx ifnorth cellyofx cellyofx agent west south south adf cellyofx agent east cellyofx agent north adf cellyofx agent east cellyofx agent adf cellyofx ifeast cellyofx east cellyofx agent east west east cellyofx ifcellsequal cellyofx agent east cellyofx agent east south south south adf ifeast adf arg adf arg ifeast adf arg adf arg ifnorth adf arg adf arg west ifcellsequal adf arg adf arg west north ifnorth adf arg adf arg west ifnorth adf arg adf arg ifnorth adf arg adf arg ifnorth adf arg adf arg west west south ifcellsequal adf arg adf arg west north ifcellsequal adf arg adf arg east ifcellsequal adf arg adf arg ifcellsequal adf arg adf arg north ifnorth adf arg adf arg ifnorth adf arg adf arg ifnorth adf arg adf arg west west south ifcellsequal adf arg adf arg west west east adf adf cellyofx ifnorth cellyofx agent ifcellsequal cellyofx ifnorth cellyofx agent cellyofx east ifnorth cellyofx west cellyofx agent west south cellyofx ifnorth cellyofx cellyofx south west west cellyofx agent west adf cellyofx agent ifnorth cellyofx agent west cellyofx south north cellyofx agent ifnorth cellyofx agent west cellyofx south west north cellyofx ifnorth cellyofx ifcellsequal cellyofx west cellyofx agent ifnorth cellyofx agent south cellyofx agent south west south cellyofx agent north adf cellyofx agent cellyofx ifnorth cellyofx agent cellyofx south ifnorth cellyofx west cellyofx agent south east adf ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifeast 
experiment cro homogeneous best run adf arg adf arg ifnorth adf arg adf arg west east ifeast adf arg adf arg west north ifnorth adf arg adf arg ifeast adf arg adf arg east ifeast adf arg adf arg ifeast adf arg adf arg north ifnorth adf arg adf arg south north ifcellsequal adf arg adf arg ifeast adf arg adf arg ifnorth adf arg adf arg ifnorth adf arg adf arg west south ifeast adf arg adf arg ifcellsequal adf arg adf arg south ifcellsequal adf arg adf arg south east west west south adf adf cellyofx ifcellsequal cellyofx agent south cellyofx agent north ifnorth cellyofx agent cellyofx agent east north adf cellyofx north cellyofx agent west ifeast cellyofx agent cellyofx agent east ifeast cellyofx agent east cellyofx agent south adf cellyofx north cellyofx east ifnorth cellyofx east cellyofx agent south north adf cellyofx north cellyofx agent east cellyofx agent fitness fitness complexity experiment cro homogeneous best run ifeast adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifnorth adf arg adf arg ifcelloccupied adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg ifcellsequal adf arg adf arg west west east ifcellsequal adf arg adf arg east ifcelloccupied adf arg north east east ifcelloccupied adf arg west ifcellsequal adf arg adf arg north ifeast adf arg adf arg ifcelloccupied adf arg west ifcelloccupied adf arg north north east ifeast adf arg adf arg ifcelloccupied adf arg ifcelloccupied adf arg north north ifcellsequal adf arg adf arg ifeast adf arg adf arg east ifcellsequal adf arg adf arg ifeast adf arg adf arg north east ifeast adf arg adf arg north east ifcelloccupied adf arg west ifcellsequal adf arg adf arg ifeast adf arg adf arg south east north ifeast adf arg adf arg east east north adf ifnorth cellyofx agent ifcelloccupied cellyofx ifcelloccupied cellyofx south west adf cellyofx west cellyofx agent north ifcelloccupied cellyofx south ifeast cellyofx cellyofx agent adf cellyofx west cellyofx agent north south ifcelloccupied cellyofx ifnorth cellyofx south cellyofx east west ifcelloccupied cellyofx east ifnorth cellyofx agent south cellyofx agent east north adf cellyofx agent cellyofx south adf cellyofx cellyofx agent west cellyofx ifnorth cellyofx agent west cellyofx agent ifcelloccupied cellyofx ifcellsequal cellyofx agent east cellyofx north north adf cellyofx agent west cellyofx north south west west ifcellsequal cellyofx agent north cellyofx agent west ifcellsequal cellyofx west cellyofx west east west ifcellsequal cellyofx agent east cellyofx agent south west ifeast cellyofx south cellyofx agent south south adf cellyofx agent ifnorth cellyofx agent west cellyofx south ifcelloccupied cellyofx agent west cellyofx ifnorth cellyofx north cellyofx agent ifcelloccupied cellyofx east west south ifcellsequal cellyofx south cellyofx west adf cellyofx agent ifcellsequal cellyofx cellyofx agent west north east cellyofx agent east ifcellsequal cellyofx east cellyofx agent north south ifcelloccupied cellyofx west ifnorth cellyofx north cellyofx agent south west south ifeast cellyofx agent cellyofx ifcelloccupied 
experiment cro homogenous best run generation cellyofx south ifnorth cellyofx north cellyofx agent south south west east ifcelloccupied cellyofx agent south west west ifeast cellyofx ifeast cellyofx agent cellyofx agent adf cellyofx agent east cellyofx agent east ifcellsequal cellyofx agent north cellyofx adf cellyofx east cellyofx south ifnorth cellyofx agent south cellyofx adf cellyofx agent west cellyofx agent south ifeast cellyofx cellyofx north ifcelloccupied cellyofx agent east ifeast cellyofx south cellyofx agent south west west ifcelloccupied cellyofx agent ifnorth cellyofx agent cellyofx agent north north adf cellyofx east cellyofx agent west cellyofx agent ifcelloccupied cellyofx south ifcellsequal cellyofx south cellyofx agent ifcelloccupied cellyofx north west north north west ifeast cellyofx ifnorth cellyofx agent cellyofx west adf cellyofx agent north cellyofx south ifcellsequal cellyofx north cellyofx agent east south east cellyofx ifcellsequal cellyofx cellyofx agent north north south south west fitness fitness complexity experiment cro homogenous best run generation adf ifeast adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg west ifcelloccupied adf arg west ifcellsequal adf arg adf arg ifeast adf arg adf arg north west ifeast adf arg adf arg adf arg west ifcelloccupied adf arg north north east ifeast adf arg adf arg ifcelloccupied adf arg north north ifeast adf arg adf arg east north north adf ifnorth cellyofx agent ifcelloccupied cellyofx ifcelloccupied cellyofx south west north ifcelloccupied cellyofx south ifeast cellyofx cellyofx agent adf cellyofx west cellyofx agent north ifcelloccupied cellyofx ifnorth cellyofx north cellyofx agent east west north ifcelloccupied cellyofx east ifnorth cellyofx agent east cellyofx east north adf cellyofx agent cellyofx south adf cellyofx east cellyofx west cellyofx ifnorth cellyofx west cellyofx ifcelloccupied cellyofx ifcellsequal cellyofx agent east cellyofx south north adf cellyofx agent west cellyofx south east west ifcellsequal cellyofx agent ifeast cellyofx cellyofx south south north cellyofx agent west ifcellsequal cellyofx west cellyofx west east north ifcellsequal cellyofx agent east cellyofx agent west west ifeast cellyofx cellyofx agent south adf cellyofx agent ifnorth cellyofx agent ifcelloccupied cellyofx east ifcelloccupied cellyofx agent east west west cellyofx south ifcelloccupied cellyofx agent south cellyofx ifnorth cellyofx north cellyofx agent ifcelloccupied cellyofx east south ifcellsequal cellyofx agent south cellyofx west adf cellyofx agent ifcellsequal cellyofx cellyofx agent north east cellyofx agent south ifcellsequal cellyofx east cellyofx agent east ifcelloccupied cellyofx west ifnorth cellyofx north cellyofx agent south west south ifeast cellyofx east cellyofx east ifcelloccupied cellyofx agent south west west ifeast cellyofx south cellyofx agent ifcelloccupied cellyofx ifcellsequal cellyofx south cellyofx agent 
experiment cro homogenous best generations run ifcelloccupied cellyofx north west north north west ifeast cellyofx ifnorth cellyofx agent cellyofx agent north adf cellyofx agent north cellyofx agent west ifcellsequal cellyofx cellyofx agent east cellyofx ifcellsequal cellyofx cellyofx agent north north north south west fitness fitness complexity experiment cro homogenous best generations run adf ifeast adf arg adf arg ifcellsequal adf arg adf arg ifeast adf arg adf arg west ifcelloccupied adf arg north ifcellsequal adf arg adf arg ifeast adf arg adf arg north west ifeast adf arg adf arg adf arg west ifcelloccupied adf arg north north north ifeast adf arg adf arg west ifeast adf arg adf arg east west north adf ifnorth cellyofx agent ifcelloccupied cellyofx agent ifcelloccupied cellyofx east ifcelloccupied cellyofx agent east west west ifcelloccupied cellyofx south ifeast cellyofx cellyofx agent adf cellyofx agent west cellyofx north ifcelloccupied cellyofx ifnorth cellyofx north cellyofx agent west west north ifcelloccupied cellyofx east ifnorth cellyofx agent east cellyofx east north adf cellyofx agent cellyofx south adf cellyofx cellyofx agent west cellyofx ifnorth cellyofx west cellyofx ifcelloccupied cellyofx ifcellsequal cellyofx agent east cellyofx south north adf cellyofx agent west cellyofx agent south east west ifcellsequal cellyofx agent ifeast cellyofx cellyofx south south north cellyofx agent west ifcellsequal cellyofx west cellyofx west east north ifcellsequal cellyofx east cellyofx agent west west ifeast cellyofx cellyofx agent south adf cellyofx agent ifnorth cellyofx agent ifcelloccupied cellyofx east ifcelloccupied cellyofx agent east west west cellyofx south ifcelloccupied cellyofx agent south cellyofx ifnorth cellyofx north cellyofx agent ifcelloccupied cellyofx east south ifcellsequal cellyofx agent south cellyofx west adf cellyofx agent ifcellsequal cellyofx agent cellyofx agent north east cellyofx agent south ifcellsequal cellyofx east cellyofx agent east ifcelloccupied cellyofx west ifnorth cellyofx north cellyofx agent south west south ifeast cellyofx east cellyofx east ifcelloccupied cellyofx agent south west west ifeast cellyofx south cellyofx agent ifcelloccupied cellyofx ifcellsequal cellyofx south cellyofx agent ifcelloccupied cellyofx north west north north west ifeast cellyofx ifnorth cellyofx agent cellyofx agent north adf cellyofx agent north cellyofx agent west ifcellsequal cellyofx cellyofx agent east cellyofx ifcellsequal cellyofx cellyofx agent north north north south west fitness fitness complexity 
experiment cro heterogenous best run experiment cro heterogenous best run adf ifnorth adf arg adf arg ifnorth adf arg adf arg ifcellsequal adf arg adf arg ifcelloccupied adf arg north north ifnorth adf arg adf arg east ifcellsequal adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg north west north west north ifcelloccupied adf arg ifeast adf arg adf arg north south east adf ifcellsequal cellyofx agent ifcellsequal cellyofx agent ifcellsequal cellyofx east cellyofx north ifcellsequal cellyofx agent west cellyofx agent east south cellyofx ifcelloccupied cellyofx agent north east south ifnorth cellyofx agent north cellyofx agent ifeast cellyofx agent north cellyofx south east west ifeast cellyofx east cellyofx agent south ifcelloccupied cellyofx agent west east west south adf cellyofx agent east cellyofx south cellyofx agent ifnorth cellyofx agent cellyofx agent south ifeast cellyofx ifnorth cellyofx agent cellyofx agent north east north cellyofx ifcellsequal cellyofx south cellyofx agent east south ifcellsequal cellyofx cellyofx south west south west adf cellyofx ifnorth cellyofx agent west cellyofx ifnorth cellyofx agent cellyofx agent south south west south ifcellsequal cellyofx agent east cellyofx agent adf cellyofx ifcellsequal cellyofx agent west cellyofx agent east south west cellyofx east cellyofx agent south adf ifeast adf arg adf arg ifeast adf arg adf arg ifeast adf arg adf arg east ifeast adf arg adf arg north ifnorth adf arg adf arg north east ifnorth adf arg adf arg east south adf ifeast cellyofx east cellyofx agent east west ifeast cellyofx agent ifnorth cellyofx ifcellsequal cellyofx agent cellyofx south east cellyofx ifcelloccupied cellyofx north east north ifnorth cellyofx cellyofx agent ifeast cellyofx agent east cellyofx south east south east ifeast cellyofx agent south cellyofx agent south ifnorth cellyofx agent north cellyofx agent north ifcellsequal cellyofx cellyofx agent east south cellyofx agent east ifcelloccupied cellyofx agent ifcelloccupied cellyofx east ifcellsequal cellyofx south cellyofx north east west ifcelloccupied cellyofx agent east north east ifeast cellyofx agent cellyofx agent east ifcelloccupied cellyofx agent north south ifeast cellyofx north cellyofx agent north north east ifnorth cellyofx ifeast cellyofx west cellyofx agent east cellyofx ifnorth cellyofx south cellyofx agent south ifnorth cellyofx agent cellyofx agent east south north west ifcelloccupied cellyofx agent east east north adf cellyofx east cellyofx agent ifcelloccupied cellyofx east adf cellyofx east cellyofx agent north adf south adf ifcellsequal cellyofx agent ifeast cellyofx agent ifeast cellyofx cellyofx east cellyofx agent ifcelloccupied cellyofx east east ifcellsequal cellyofx south cellyofx west south east east cellyofx ifcelloccupied cellyofx agent east west ifcelloccupied cellyofx agent ifeast cellyofx east cellyofx east east west adf cellyofx agent east cellyofx west west ifnorth cellyofx east cellyofx agent east ifeast cellyofx ifnorth cellyofx west cellyofx south ifeast cellyofx agent cellyofx agent east north ifcelloccupied cellyofx west east east cellyofx agent ifnorth cellyofx agent north cellyofx agent west 
experiment cro homogenous full evaluation best run south east ifcelloccupied cellyofx west east ifcelloccupied cellyofx agent west west ifnorth cellyofx agent north cellyofx agent east south east ifnorth cellyofx south cellyofx agent west ifnorth cellyofx east cellyofx south south ifeast cellyofx agent cellyofx agent north east west ifeast cellyofx agent cellyofx east south north adf ifnorth adf arg adf arg south ifnorth adf arg adf arg south north adf ifcellsequal cellyofx adf cellyofx agent north cellyofx north cellyofx ifcellsequal cellyofx agent north cellyofx agent adf cellyofx west cellyofx agent ifcellsequal cellyofx north cellyofx agent adf cellyofx north cellyofx agent ifnorth cellyofx agent east cellyofx agent east north east west ifeast cellyofx ifcelloccupied cellyofx agent north ifnorth cellyofx north cellyofx east adf cellyofx agent north cellyofx east east north cellyofx agent ifcelloccupied cellyofx north north adf cellyofx agent cellyofx agent north ifcelloccupied cellyofx ifcelloccupied cellyofx agent west south ifcelloccupied cellyofx north south south ifcellsequal cellyofx agent north cellyofx north ifnorth cellyofx agent ifnorth cellyofx agent east cellyofx north cellyofx north ifnorth cellyofx north cellyofx agent east south ifcelloccupied cellyofx north south east west adf cellyofx ifcellsequal cellyofx agent cellyofx north north south cellyofx agent ifcelloccupied cellyofx agent east west west adf cellyofx agent north cellyofx north east fitness fitness complexity experiment cro homogenous full evaluation best run adf ifeast adf arg adf arg ifnorth adf arg adf arg ifcelloccupied adf arg west east ifcelloccupied adf arg south north ifnorth adf arg adf arg east ifcelloccupied adf arg ifnorth adf arg adf arg ifnorth adf arg adf arg ifnorth adf arg adf arg south east east ifcelloccupied adf arg ifcelloccupied adf arg ifcellsequal adf arg adf arg ifcelloccupied adf arg east ifcellsequal adf arg adf arg south west north ifcellsequal adf arg adf arg east north adf ifeast cellyofx agent ifcelloccupied cellyofx ifnorth cellyofx agent east cellyofx agent ifeast cellyofx south cellyofx south south west ifnorth cellyofx north cellyofx agent ifeast cellyofx agent west cellyofx south ifcelloccupied cellyofx north east north west adf cellyofx agent south cellyofx south cellyofx north east ifeast cellyofx agent east cellyofx ifcellsequal cellyofx agent south cellyofx west ifnorth cellyofx agent cellyofx adf cellyofx south cellyofx agent east west west ifcellsequal cellyofx cellyofx south west ifnorth cellyofx ifcelloccupied cellyofx east south north cellyofx agent north ifnorth cellyofx south cellyofx south north ifcelloccupied cellyofx west west west ifnorth cellyofx adf cellyofx agent cellyofx south cellyofx agent west ifeast cellyofx agent east cellyofx ifcelloccupied cellyofx ifcelloccupied cellyofx east south north east north south ifcellsequal cellyofx ifcelloccupied cellyofx east south north cellyofx agent east ifnorth cellyofx cellyofx agent east south 
experiment cro homogenous full evaluation best run ifcellsequal cellyofx agent south cellyofx south north west north west fitness fitness complexity appendix best evolved communicative agents experiment best agent run adf lt recva add senda sub recvb sendb gety senda senda getx ge senda gety sendb sendb gety lt getx getx ge sub getx sub getx recva recvb ge getx gety ge gety recva ge recvb sendb gety sw ge getx getx nw ge recva senda senda getx lt gety recva nw nw ge recvb gety ne lt recva senda getx sw se fitness fitness complexity experiment best agent run adf ge sub getx sendb getx sub recva senda senda gety ge sendb getx recvb sw se ge sendb getx recvb lt recvb getx nw lt senda gety gety lt getx senda gety ge recva recvb ge sendb gety getx se ge getx gety ge recvb recvb ne ne ne ge sub sendb recvb getx sub recva senda gety ge sendb getx recvb lt getx recvb se ne ge sendb getx recvb lt recvb getx nw lt senda senda recva getx lt getx senda getx ge getx recvb se se ge gety gety se nw ge add recvb recva recvb ge getx recvb ne ne fitness fitness complexity appendix best agents experiment best communicating agent run adf ge gety gety ge recvb sub getx sub senda senda senda recva sendb gety ge recvb sub recva sub senda getx sendb gety lt getx recva ne ge senda getx getx lt gety add sub getx getx recvb nw lt recvb sendb gety lt gety add sub recvb getx recvb lt gety gety ne ge senda senda sendb gety sub senda getx gety lt gety add sub recva recva recvb nw lt sendb getx sendb gety lt senda getx add sub getx recvb gety ge senda senda recva senda getx sw fitness fitness complexity experiment best pursuit agent run adf ifcelloccupied adf arg west ifcelloccupied adf arg ifcelloccupied adf arg ifcellsequal adf arg adf arg ifcelloccupied adf arg south south ifcelloccupied adf arg south ifnorth adf arg adf arg ifcellsequal adf arg adf arg south south east ifcellsequal adf arg adf arg ifeast adf arg adf arg ifcellsequal adf arg adf arg ifcelloccupied adf arg adf arg adf arg ifcelloccupied adf arg north south ifcelloccupied adf arg west west ifnorth adf arg adf arg ifcellsequal adf arg adf arg south west north west ifeast adf arg adf arg east south ifeast adf arg adf arg ifeast adf arg adf arg north west ifcellsequal adf arg adf arg south west adf ifeast cellyofx agent cellyofx agent north ifeast cellyofx east cellyofx agent west west ifeast cellyofx agent cellyofx south south ifnorth cellyofx east cellyofx ifeast cellyofx east cellyofx south south east west ifnorth cellyofx ifnorth cellyofx south cellyofx agent west adf cellyofx agent ifcelloccupied cellyofx agent north north east cellyofx east cellyofx agent ifeast cellyofx ifcelloccupied cellyofx north ifnorth cellyofx agent cellyofx north west east ifnorth cellyofx agent south cellyofx west cellyofx agent west south ifeast cellyofx agent ifcellsequal cellyofx agent south cellyofx agent east ifcelloccupied cellyofx agent south north north cellyofx ifeast cellyofx agent cellyofx south south ifnorth cellyofx east 
experiment best heterogeneous pursuit agent run cellyofx ifeast cellyofx east cellyofx south east east west ifcellsequal cellyofx agent ifcelloccupied cellyofx agent ifeast cellyofx south cellyofx agent west south cellyofx north ifcellsequal cellyofx ifcelloccupied cellyofx agent north east cellyofx agent north ifnorth cellyofx cellyofx south east north east north fitness fitness complexity experiment best heterogeneous pursuit agent run adf ifcelloccupied adf arg east south adf ifnorth cellyofx agent ifcelloccupied cellyofx ifeast cellyofx agent cellyofx south ifnorth cellyofx north cellyofx south north north ifcelloccupied cellyofx agent ifnorth cellyofx agent west cellyofx south ifcelloccupied cellyofx north west east cellyofx south ifeast cellyofx east cellyofx agent ifcellsequal cellyofx agent cellyofx agent west east ifnorth cellyofx agent cellyofx east north west west adf cellyofx ifnorth cellyofx agent ifeast cellyofx agent south cellyofx north north cellyofx agent ifnorth cellyofx cellyofx agent north east west ifnorth cellyofx north cellyofx agent west ifnorth cellyofx west cellyofx north south ifcelloccupied cellyofx north ifcelloccupied cellyofx south east east south cellyofx agent ifcellsequal cellyofx agent ifcelloccupied cellyofx agent south west north cellyofx agent ifcellsequal cellyofx agent cellyofx agent east ifcelloccupied cellyofx south south ifcellsequal cellyofx agent south cellyofx ifcellsequal cellyofx south cellyofx agent west east east adf ifeast adf arg adf arg ifcelloccupied adf arg ifeast adf arg adf arg east ifcelloccupied adf arg ifeast adf arg adf arg east south ifnorth adf arg adf arg ifnorth adf arg adf arg south east ifcelloccupied adf arg ifcelloccupied adf arg east east south ifnorth adf arg adf arg ifnorth adf arg adf arg east south ifcelloccupied adf arg ifcelloccupied adf arg south east east west adf ifnorth cellyofx cellyofx agent west adf cellyofx agent east cellyofx ifeast cellyofx agent south cellyofx east north ifcellsequal cellyofx agent ifcelloccupied cellyofx agent west cellyofx south ifcellsequal cellyofx east cellyofx agent east ifcelloccupied cellyofx agent east south south east north fitness fitness complexity bibliography ak david andre john koza 
parallel genetic programming network transputers 
rosca editor proceedings workshop genetic programming theory real world applications pages tahoe city california usa july 
ak david andre john koza 
parallel genetic programming scalable implementation transputer network architecture 
peter angeline kinnear jr editors advances genetic programming chapter pages 
mit press cambridge ma usa 
ak david andre john koza 
parallel implementation genetic programming achieves super linear performance 
hamid editor proceedings international conference parallel distributed processing techniques applications volume iii pages sunnyvale august 
csrea 
david andre 
evolution ability strategies evolution learning planning memory genetic programming 
proceedings ieee world congress computational intelligence volume pages orlando florida usa june 
ieee press 
ang peter angeline 
subtree crossover causes bloat 
john koza wolfgang banzhaf kumar chellapilla kalyanmoy deb marco dorigo david fogel max garzon david goldberg hitoshi iba rick riolo editors genetic programming proceedings third annual conference pages university wisconsin madison wisconsin usa july 
morgan kaufmann 
ap peter angeline jordan pollack 
competitive environments evolve better solutions complex tasks 
stephanie forrest editor proceedings th international conference genetic algorithms icga pages university illinois urbana champaign july 
morgan kaufmann 
andre teller 
evolving team darwin united 
asada kitano editors robocup robot soccer world cup ii volume lncs pages paris france july 
springer verlag 
bei boris beizer 
blackbox testing techniques functional testing software systems volume 
john wiley sons 
ben forrest bennett iii 
automatic creation efficient multi agent architecture genetic programming architecture altering operations 
john koza david goldberg david fogel rick riolo editors genetic programming proceedings annual conference pages stanford university ca usa july 
mit press 
bibliography ben forrest bennett iii 
emergence multi agent architecture new tactics ant colony foraging problem genetic programming 
pattie maes maja mataric jean meyer jordan pollack stewart wilson editors proceedings fourth international conference simulation adaptive behavior animals animats pages cape code usa september 
mit press 
bjd benda jagannathan 
optimal cooperation knowledge sources empirical investigation 
technical report bcs boeing advanced technology center boeing computing services seattle washington july 
wolfgang banzhaf peter nordin robert keller frank 
genetic programming automatic evolution computer programs applications 
morgan kaufmann verlag january 
bra bratman 
intentions plans practical reasoning 
university press cambridge ma usa 
bra scott brave 
genetic programming evolve recursive programs tree search 
louis editor fourth golden west conference intelligent systems pages 
international society computers applications isca june 
bra scott brave 
evolving recursive programs tree search 
peter angeline kinnear jr editors advances genetic programming chapter pages 
mit press cambridge ma usa 
bro rodney brooks 
robust layered control system mobile robot 
ieee journal robotics automation ra april 
bro rodney brooks 
intelligence reason 
ray john reiter editor proceedings th international joint conference artificial intelligence pages sydney australia august 
morgan kaufmann 
cc cristiano castelfranchi conte 
dai social science critical issues 
greg hare nick jennings editors foundations distributed artificial intelligence chapter 
john wiley sons 
cf chellapilla db fogel 
evolving checkers playing programs win lose draw 
keller fogel bezdek editors aerosense symposium applications science computational intelligence ii pages spie bellingham wa 
chris clack peter tina yu 
autonomous document classification business 
lewis johnson editor international conference autonomous agents agents pages marina del rey california usa february 
acm press 
cho sian chong 
java distributed approach genetic programming internet 
master thesis computer science university birmingham 
cho sian chong 
java distributed genetic programming internet 
technical report csrp university birmingham school computer science april 
bibliography cho sian chong 
java distributed genetic programming internet 
cantu paz bill punch editors evolutionary computation parallel processing orlando florida usa july 
cl sian chong langdon 
java distributed genetic programming internet 
wolfgang banzhaf jason daida eiben max garzon honavar mark robert smith editors proceedings genetic evolutionary computation conference volume page orlando florida usa july 
morgan kaufmann 
cla chris clack 
software generation evolving document classification 
white ucl andersen consulting university college london gower street london april 
cra lynn cramer 
representation adaptive generation simple sequential programs 
john grefenstette editor proceedings international conference genetic algorithms applications pages carnegie mellon university pittsburgh pa usa july 
dav lawrence davis editor 
handbook genetic algorithms 
van nostrand reinhold new york 
daw richard dawkins 
blind watchmaker 
harlow longman scientific technical 
db patrik haeseleer jason 
effects locality individual population evolution 
kenneth kinnear jr editor advances genetic programming chapter pages 
mit press 
gas les gasser 
social conceptions knowledge action dai foundations open systems semantics 
artificial intelligence 
gat chris 
investigation supervised learning genetic programming 
phd thesis university edinburgh 
erich gamma richard helm ralph johnson john vlissides grady booch 
ghj design patterns elements reusable object oriented software 
addison wesley january 
gol david goldberg 
genetic algorithms search optimization machine learning 
addison wesley 
gr chris peter ross 
dynamic training subset selection supervised learning genetic programming 
yuval davidor hans paul schwefel reinhard nner editors parallel problem solving nature iii pages jerusalem october 
springer verlag 
gr chris peter ross 
small populations generations beat large populations generations genetic programming 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
gr chris peter ross 
tackling boolean parity problem genetic programming limited error fitness 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
bibliography han handley 
automatic generation plans mobile robot genetic programming automatically defined functions 
proceedings fifth workshop neural networks international conference computational intelligence neural networks fuzzy systems evolutionary programming virtual reality 
han handley 
genetic planner automatic generation plans mobile robot genetic programming 
proceedings eighth ieee international symposium intelligent control 
han handley 
directed acyclic graph represent population computer programs 
proceedings ieee world congress computational intelligence pages orlando florida usa june 
ieee press 
han simon handley 
automatic generations plans mobile robot genetic programming automatically defined functions 
kenneth kinnear jr editor advances genetic programming chapter pages 
mit press 
hb christopher harris bernard buxton 
gp com distributed componentbased genetic programming system 
research note rn ucl gower street london wc bt uk january 
hb christopher harris bernard buxton 
gp com distributed componentbased genetic programming system 
john koza david goldberg david fogel rick riolo editors genetic programming proceedings annual conference page stanford university ca usa july 
mit press 
het william 
complete guide software testing volume 
collins professional technical books 
hk bogdan henry krawczyk 
analysis testing distributed software applications volume 
research studies press 
hls thomas haynes kit lau sandip sen learning cases compliment rules conflict resolution multiagent systems 
sandip sen editor working notes aaai symposium adaptation evolution learning multiagent systems pages stanford university ca march 
hol john holland 
genetic algorithms optimal allocation trials 
siam journal computation 
hol john holland 
adaptation natural artificial systems introductory analysis applications biology control artificial intelligence 
mit press 
published university michigan press 
hr holland reitman 
cognitive systems adaptive algorithms 
waterman hayes roth editors pattern directed inference systems pages 
new york academic press 
hs thomas haynes sandip sen evolving behavioral strategies predators prey 
gerhard wei sandip sen editors adaptation learning multiagent systems lecture notes artificial intelligence 
springer verlag berlin germany 
hs thomas haynes sandip sen evolving behavioral strategies predators prey 
sandip sen editor ijcai workshop adaptation learning bibliography multiagent systems pages montreal quebec canada august 
morgan kaufmann 
hs thomas haynes sandip sen cooperation fittest 
technical report mcs university tulsa april 
hs thomas haynes sandip sen cooperation fittest 
john koza editor late breaking papers genetic programming conference stanford university july pages stanford university ca usa july 
stanford bookstore 
hs thomas haynes sandip sen evolving behavioral strategies predators prey 
gerhard wei sandip sen editors adaptation learning multi agent systems lecture notes artificial intelligence pages 
springer verlag berlin germany 
hs thomas haynes sandip sen learning cases resolve conflicts improve group behavior 
milind tambe piotr gmytrasiewicz editors working notes aaai workshop agent modeling pages portland august 
hs thomas haynes sandip sen crossover operators evolving team 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
thomas haynes sandip sen dale roger wainwright 
evolving team 
siegel koza editors working notes aaai symposium genetic programming pages mit cambridge ma usa november 
aaai 
thomas haynes sandip sen dale roger wainwright 
evolving multiagent coordination strategies genetic programming 
technical report mcs university tulsa may 
hw thomas haynes roger wainwright 
simulation adaptive agents hostile environment 
george janice carroll ed dave oppenheim jim hightower editors proceedings acm symposium applied computing pages nashville usa 
acm press 
thomas haynes roger wainwright sandip sen evolving cooperation strategies 
technical report mcs university tulsa tulsa ok usa december 
thomas haynes roger wainwright sandip sen evolving cooperating strategies 
victor lesser editor proceedings international conference multiple agent systems page san francisco usa june 
aaai press mit press 
poster 
thomas haynes roger wainwright sandip sen dale 
strongly typed genetic programming evolving cooperation strategies 
eshelman editor genetic algorithms proceedings sixth international conference icga pages pittsburgh pa usa july 
morgan kaufmann 
iba hitoshi iba 
emergent cooperation multiple agents genetic programming 
hans michael voigt werner ebeling ingo rechenberg hans bibliography paul schwefel editors parallel problem solving nature iv proceedings international conference evolutionary computation volume lncs pages berlin germany september 
springer verlag 
iba hitoshi iba 
evolutionary learning communicating agents 
journal information sciences 
iba hitoshi iba 
evolving multiple agents genetic programming 
lee spector william langdon una may reilly peter angeline editors advances genetic programming chapter pages 
mit press cambridge ma usa june 
forrest bennett iii john koza james shipman oscar 
building parallel computer system performs half flop day 
wolfgang banzhaf jason daida eiben max garzon honavar mark robert smith editors proceedings genetic evolutionary computation conference volume pages orlando florida usa july 
morgan kaufmann 
hitoshi iba ueda 
evolving communicating agents genetic programming 
proceedings ieee international conference evolutionary computation indianapolis april 
ieee press 
noda 
soccer server simulator robocup 
ai symposium special session robocup december 
jan jan jannink 
cracking evolving 
kenneth kinnear jr editor advances genetic programming chapter pages 
mit press 
jsw jennings sycara wooldridge 
roadmap agent research development 
journal autonomous agents multi agent systems 
ka john koza david andre 
parallel genetic programming network transputers 
technical report cs tr stanford university department computer science january 
john koza david andre forrest bennett iii martin keane 
genetic programming darwinian invention problem solving 
morgan kaufman april 
kin kenneth kinnear jr fitness landscapes difficulty genetic programming 
proceedings ieee world conference computational intelligence volume pages orlando florida usa june 
ieee press 
kor richard korf 
simple solution pursuit games 
working papers th international workshop distributed artificial intelligence pages february 
koz john koza 
genetic evolution evolution computer programs 
christopher taylor charles langton farmer steen rasmussen editors artificial life ii volume sfi studies sciences complexity pages 
addison wesley santa fe institute new mexico usa february 
koz koza 
evolution subsumption genetic programming 
varela bourgine editors proceedings european conference bibliography artificial life 
practice autonomous systems pages paris france december 
mit press 
koz john koza 
genetic programming programming computers means natural selection 
mit press cambridge ma usa 
koz john koza 
simultaneous discovery reusable detectors subroutines genetic programming 
stephanie forrest editor proceedings th international conference genetic algorithms icga pages university illinois urbana champaign july 
morgan kaufmann 
koz john koza 
evolution emergent cooperative behavior genetic programming 
ray paton editor computing biological metaphors pages 
london chapman hall 
koz john koza 
genetic programming ii automatic discovery reusable programs 
mit press cambridge massachusetts may 
lan langdon 
evolving data structures genetic programming 
eshelman editor genetic algorithms proceedings sixth international conference icga pages pittsburgh pa usa july 
morgan kaufmann 
lan langdon 
data structures genetic programming 
phd thesis university college london september 
lan langdon 
data structures genetic programming 
john koza david goldberg david fogel rick riolo editors genetic programming proceedings annual conference pages stanford university ca usa july 
mit press 
lan william langdon 
data structures genetic programming 
peter angeline kinnear jr editors advances genetic programming chapter pages 
mit press cambridge ma usa 
lan langdon 
fitness causes bloat variable size representations 
technical report csrp university birmingham school computer science may 
position workshop evolutionary computation variable size representation icga 
lan langdon 
fitness causes bloat simulated annealing hill climbing populations 
technical report csrp university birmingham school computer science september 
lan langdon 
scaling program tree fitness spaces 
evolutionary computation winter 
lcr chi keen low chen ralph 
automated test case generation bdi agents 
autonomous agents multi agent systems 
sean luke charles jonathan gary jackson james hendler 
evolving soccer softbot team coordination genetic programming 
proceedings international workshop robocup international joint conference artificial intelligence nagoya japan 
lp langdon poli 
fitness causes bloat 
technical report csrp university birmingham school computer science birmingham tt uk february 
bibliography lp langdon poli 
fitness causes bloat 
roy pant editors soft computing engineering design manufacturing pages 
springer verlag london june 
lp langdon poli 
fitness causes bloat mutation 
john koza editor late breaking papers gp conference pages stanford ca usa july 
stanford bookstore 
lq william langdon 
genetic programming computers natural selection generate programs 
research note rn university college london gower street london wc bt uk october 
ls sean luke lee spector 
evolving teamwork coordination genetic programming 
john koza david goldberg david fogel rick riolo editors genetic programming proceedings annual conference pages stanford university ca usa july 
mit press 
luk sean luke 
genetic programming produced competitive soccer softbot teams robocup 
john koza wolfgang banzhaf kumar chellapilla kalyanmoy deb marco dorigo david fogel max garzon david goldberg hitoshi iba rick riolo editors genetic programming proceedings third annual conference pages university wisconsin madison wisconsin usa july 
morgan kaufmann 
lv ming li paul vitanyi 
kolmogorov complexity applications 
springer verlag 
mat mataric 
distributed model mobile robot environment learning navigation 
technical report mit ai lab cambridge ma 
mc mauro campbell 
designing pursuit problems testbeds distributed ai novel application genetic algorithms 
fifth european workshop modelling autonomous agents multi agent world tel switzerland august 
min marvin minsky 
steps artificial intelligence 
feigenbaum feldman editors computers thought 
mcgraw hill new york usa 
mit tom mitchell 
machine learning 
mcgraw hill 
mon david montana 
strongly typed genetic programming 
bbn technical report bolt beranek newman moulton street cambridge ma usa may 
mon david montana 
strongly typed genetic programming 
bbn technical report bolt beranek newman moulton street cambridge ma usa march 
mye glen myers 
art software testing 
john wiley sons 
peter nordin wolfgang banzhaf frank 
efficient evolution machine code cisc architectures instruction blocks homologous crossover 
lee spector william langdon una may reilly peter angeline editors advances genetic programming chapter pages 
mit press cambridge ma usa june 
peter nordin 
evolutionary program induction binary machine code applications 
phd thesis der universitat dortmund am informatik 
bibliography oo una may reilly franz oppacher 
troubling aspects building block hypothesis genetic programming 
darrell whitley michael vose editors foundations genetic algorithms pages estes park colorado usa july august 
morgan kaufmann 
pl riccardo poli langdon 
new schema theory genetic programming point crossover point mutation 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
pol poli 
discovery symbolic neuro symbolic neural networks parallel distributed genetic programming 
technical report university birmingham uk august 
rd international conference artificial neural networks genetic algorithms 
pol poli 
steps form parallel distributed genetic programming 
st online workshop soft computing wsc www nagoya ac jp wsc august 
nagoya university japan 
pol riccardo poli 
discovery symbolic neuro symbolic neural networks parallel distributed genetic programming 
technical report csrp university birmingham school computer science august 
pol riccardo poli 
discovery symbolic neuro symbolic neural networks parallel distributed genetic programming 
rd international conference artificial neural networks genetic algorithms university east uk 
pol riccardo poli 
evolution graph programs parallel distributed genetic programming 
thomas back editor genetic algorithms proceedings seventh international conference pages michigan state university east lansing mi usa july 
morgan kaufmann 
pol poli 
theory gp point crossover building blocks new results ga theory 
riccardo poli wolfgang banzhaf william langdon julian miller peter nordin terence fogarty editors genetic programming proceedings volume lncs pages edinburgh april 
springer verlag 

evolving agents 
john koza david goldberg david fogel rick riolo editors genetic programming proceedings annual conference pages stanford university ca usa july 
mit press 
rb rosca dana ballard 
rooted tree schemata genetic programming 
lee spector william langdon una may reilly peter angeline editors advances genetic programming chapter pages 
mit press cambridge ma usa june 
rey craig reynolds 
evolved vision behavioral model coordinated group motion 
meyer wilson editors animals animats proceedings simulation adaptive behaviour 
mit press 
rey craig reynolds 
competition coevolution game tag 
rodney brooks pattie maes editors proceedings fourth international bibliography shop synthesis simulation living systems pages mit cambridge ma usa july 
mit press 
rey craig reynolds 
evolution obstacle avoidance behaviour noise promote robust solutions 
kenneth kinnear jr editor advances genetic programming chapter pages 
mit press 
rey craig reynolds 
evolved vision behavioral model obstacle avoidance behaviour 
christopher langton editor artificial life iii volume xvii sfi studies sciences complexity pages 
addison wesley santa fe institute new mexico usa june 
ros rosca 
analysis complexity drift genetic programming 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
sap jan 
evolution association history symbiosis 
oxford university press 
sdb sichman demazeau 
knowledge systems called agents 
proc 
ix brazilian symposium artificial intelligence rio de janeiro brazil 
sm larry stephens matthias merx 
effect agent control strategy performance dai pursuit problem 
proceedings distributed ai workshop october 
smi smith 
learning system genetic adaptive algorithms 
phd thesis university pittsburgh pittsburgh pa 
sv stone veloso 
multiagent systems survey machine learning perspective 
report series cmu cs carnegie mellon university computer science department carnegie mellon university pittsburgh pa 
ta astro teller david andre 
automatically choosing number fitness cases rational allocation trials 
john koza kalyanmoy deb marco dorigo david fogel max garzon hitoshi iba rick riolo editors genetic programming proceedings second annual conference pages stanford university ca usa july 
morgan kaufmann 
tc walter tackett 
donut problem scalability generalization genetic programming 
kenneth kinnear jr editor advances genetic programming chapter pages 
mit press 
tel astro teller 
evolution mental models 
kenneth kinnear jr editor advances genetic programming chapter pages 
mit press 
tel astro teller 
evolving programmers evolution intelligent recombination operators 
peter angeline kinnear jr editors advances genetic programming chapter pages 
mit press cambridge ma usa 
tv astro teller manuela veloso 
pado learning tree structured algorithms orchestration object recognition system 
technical report cmu cs bibliography department computer science carnegie mellon university pittsburgh pa usa 
wei gerhard weiss editor 
multiagent systems modern approach distributed artificial intelligence 
mit press cambridge ma usa 
wj wooldridge jennings 
intelligent agents theory practice 
knowledge engineering review 
wl man leung wong kwong sak leung 
evolving recursive functions parity problem genetic programming 
peter angeline kinnear jr editors advances genetic programming chapter pages 
mit press cambridge ma usa 
yc tina yu chris clack 
recursion lambda abstractions genetic programming 
john koza wolfgang banzhaf kumar chellapilla kalyanmoy deb marco dorigo david fogel max garzon david goldberg hitoshi iba rick riolo editors genetic programming proceedings third annual conference pages university wisconsin madison wisconsin usa july 
morgan kaufmann 
