proving correctness compiler optimizations temporal logic david david comlab ox ac uk university oxford neil jones neil diku dk university copenhagen classical compiler optimizations elegantly expressed rewrite rules form intermediate language instructions property expressed temporal logic suitable describing program data flow 
reading current program contains instruction form control point flow condition satisfied replace purpose show transformations may proven correct 
methodology illustrated familiar optimizations dead code elimination constant folding code motion 
meaning correctness program rewrite exactly semantics 

shows temporal logic validate classical compiler optimizations strong sense 
typical optimizing transformations shown simply elegantly expressible conditional rewrite rules imperative programs conditions formulas suitable temporal logic 
temporal logic extension ctl free variables 
transformation example expresses dead code elimination second expresses constant folding third expresses loop invariant hoisting 
involves computational futures second computational third involves computational past 
second optimizing transformations proven fully semantics preserving case program research partially supported danish natural science research council plt project eec project microsoft research 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl jan portland usa acm isbn 
eric van wyk eric van wyk comlab ox ac uk university oxford carl christian diku dk university copenhagen result transforming induction relation established computations consequence terminating computation final answer terminating computation final answer vice versa 
compiler optimizing transformations great program transformations done optimizing compilers exhaustive catalog may 
great success pragmatically important serious doubt correctness transformed programs semantically equivalent derived 
proof transformation correctness nature semantics endeavor 
semantics program manipulation happened field path breaking cousot conference 
field interpretation arose mainly european theory counterpart pragmatic north american approach program analysis 
goal semantics program manipulation pepm conference series place program analysis transformation solid foundation semantics programming languages making possible prove analyses sound transformations change program behaviors 
approach succeeded placing solid semantic foundations program analyses optimizing compilers notable examples sign analysis constant propagation strictness analysis 
embarrassing fact admitted success achieved semantics approach goal validating correctness program transformations particular dataflow analysis optimizations actual compilers 
root problem semantic frameworks denotational operational semantics describe program execution precise mathematical operational terms representation data dependencies computational futures awkward continuation semantics 
worse dependency information lies heart widely compiler optimizing transformations 
semantics transformation correctness transformation correctness somewhat complex establish involves proving soundness relation actors condition enables applying transformation semantics subject program transformation 
denotational operational semantics typically example proofs equivalences program fragments 
small excepting purpose mainly illustrate proof methodology subtle questions involving scott domains program contexts support applications 
problem denotational operational methods ill suited validating transformations involve program computational computational past 
difficult transformations change program control flow notable examples code motion strength reduction formal proofs correctness transformations 
works relating semantics approaches transformation correctness nielson thesis unpublished chapter proving correctness constant folding omitted journal complexity development proof 
havelund thesis carefully explores semantic aspects transformations pascal mini language typical stack imperative intermediate code correctness proofs scope impractically complex denotational framework witness 
approach verifying correctness compiler optimizations kozen patron 
extension kleene algebra kleene algebra tests kat extensive collection instances program transformations proven correct concrete optimization proven correct concrete source program transformed program 
programs represented algebraic terms kat shown original transformed program equal algebraic laws kat 
instances kat terms ground contain variables reasoning applied general program transformations 
note sets different perspective program transformation 
geared establishing framework formally reason program manipulations specified kat equalities imply semantic equivalence 
results directly applicable compilers automatic method applying optimizations described applicable proof carrying code pcc efficient code certification ecc kozen patron state 
ecc optimized program contains proof verifying transformations applied sound case proofs specific instances exactly needed 
contrast aims formalize framework describing formally proving classical compiler optimizations 
claim specifications proven correct directly automatically utilized optimizing 
worth noting kozen patron study structured programs loops goto statements restriction 
transformation correctness proofs functional languages especially wand colleagues example logical relations methods mathematically sophisticated appropriate traditional intermediate code optimizations 
model checking program analysis situation improved advent model checking approaches program analysis :10.1.1.49.5907
steffen schmidt showed temporal logic suited describing data dependencies program properties exploited classical compiler optimizations 
particular knoop steffen thing showed new insights gained temporal logic enabling new stronger code motion algorithms part commercial compilers 
relevant code motion transformations proven correct 
model checking program transformation give formalism essentially subset succinctly expressing program transformations making temporal logic formalism prove universal correctness semantics preservation programs optimizing transformations dead code elimination constant folding loop invariant hoisting 
thrust just prove transformations correct establish framework wide spectrum classical compiler optimizations validated 
instances approach may 
optimizing transformations elegantly expressed rewrite rules form intermediate language instructions property expressed temporal logic suitable describing program data flow 
reading current program contains instruction form control point flow condition satisfied replace purpose show transformations may proven correct 
meaning correctness program rewrite exactly semantics 

programs transformations section provide fundamental definitions representations programs analyses transformations read sum sum sum goto write sum example program control flow 
correctness proofs 
section introduce simple imperative programming language demonstrate program transformations proofs correctness 
section describe control flow graph representation programs serves model temporal logic formulas rewrite rules checked 
temporal logic ctl free variables section 
rewriting rules defined section section provides specifications dead code elimination constant folding transformations 
simple programming language definition program form read 
im write 
im instructions labeled program labels nodes 

instruction initial read instruction im concluding write read write instructions appear respectively program 
syntax instructions grammar inst skip goto expr op various unspecified operators arity var 
label 
semantics expected formally defined section 
contains example program 
readability explicit instruction labels operators written infix position 
order provide simple framework proving correctness language exceptions procedures 
expect technique extended include fea tures maintain fundamental nature 
modeling program control flow order reason program view transform look control flow graph program 
type transition system 
introduce concept describe semantics program definition transition system pair set elements referred states nodes 
path maximal sequence nodes finite infinite 
ni ni backwards path path inverse written written 

closely related transition systems models model checking 
transition systems state labeled certain information definition model triple transition system labeling function labels state set propositions control flow transition system system states program points transitions pairs program points follow execution 
definition control flow transition system tcf nodes cf total relation cf defined cf skip read goto write set control flow model labeling states system program points case propositions interest 
include instruction program point plus information variables defined point 
shows example model node instruction sum labeled propositions node stmt sum def sum 
definition control flow model program defined mcf nodes cf nodes cf definition defined follows nodes finite path 
nm maximal nm 
nm successors 
node stmt read def node stmt def node stmt sum def sum node stmt def node stmt sum sum def sum sum node stmt def node stmt goto node stmt write sum sum control flow model example program 
stmt node def form read form goto write constant operator arity trans expression form read vars predicates stmt def trans building blocks conditions specify optimizing transformations safely applied 
conditions specified ctl fv formulas 
definition expression transparent program point variables expression defined point assigned read 
ctl free variables temporal logic ctl fv specifying transformation conditions respects generalization ctl 
common temporal path quantifiers extended quantify backwards paths obvious way 
notation paths may finite quantifications paths infinite maximal finite paths 
consider branching notion past may finite ct lbp ot 
branching past appropriate linear past ct branching time logics past time operators 
second propositions generalized predicates free variables 
traditional atomic proposition simply predicate arguments 
example formula stmt stmt free variables ranging program variables expressions respectively 
free variables henceforth called avoid confusion variables program points appearing program transformed analyzed 
effect model checking bind ctl variables program points bits program syntax dead variables available expressions 
ctl fv formulas state path formulas generated grammar non terminals terminals true false pr free variables 
xn start symbol productions true false pr 
xn operational interpretation model checker simply find nodes model satisfy state formula find instantiation substitutions satisfy formula 
mathematically model extending satisfaction relation include substitution binding free variables 
extended satisfaction relation hold 
relation defined 
usual interpretation maximal finite paths 
job model checker return set 
example program formula def model checker returns set instantiation substitutions 
brevity ctl variable bound program point substitutions 
sum particular interest analysing control flow model universal weak operator 
due lemma lemma maximal finite path 
nn exists nj ni 
similar result holds backwards paths 
proof omitted 
lemma correctness proofs maximal finite paths exactly set terminating program traces execution transition system definition 
rewriting definition rewrite rule form instructions built program ctl variables ctl fv temporal logic formula 
definition rewrite true substitution hold state formulas true iff true false iff false pr 
xn iff pr 
xn iff iff iff path iff iff iff paths path paths path formulas iff 
iff 
ni implies nj iff 
nk ni nk nk exists ctl fv satisfaction relation stmt read im write read im write may want alter program point 
case specify rewrites side conditions 
example transform nodes form rewrite operational interpretation find substitution satisfies stmt stmt substitution alter program relevant places 
sample transformations versions classical optimizations simplified comparison compiler practice easier follow techniques proofs 
convenience express code removal replacement instruction skip code motion simultaneous replacement instruction skip respectively skip instruction assume compiler remove useless occurrences skip 
programmers write code contains dead code opportunities constant folding results transformations especially automated ones 
dead code elimination dead code elimination removes assignment statements assign value 
model rewrite replaces assignment skip instruction skip side condition rewrite specify value assigned referenced 
exactly kind condition temporal logic specify 
rewrite rule side condition written skip ax true 
care current node skip past ax operator 
constant folding constant folding transformation replaces variable constant value method implementing constant folding variable check possible assignments assign constant value 
check condition past temporal operators specifying complete transformation follows def stmt code motion loop invariant hoisting restricted version code motion transformation cm covers loop invariant hoisting transformation defined skip skip node def node trans node transformation involves different statements subject program 
transformation moves assignment label label provided conditions met 
assigned variable dead remain reached 
requirement holds introducing assignment label change semantics program 

second requirement combination rewrite rule states expression available transformation 
introduced match non constant expression 
transformation obtained applying transformations inserts statement provided dead followed elimination available expressions transformation 
transformations need mechanism controlling insert assignments 
formulating transformation single transformation labels explicitly linked 
paths may reach possible move assignments labels available dead paths leading semantics preserving transformation 
skip 
program possible lift statement label label 
general transformation slow computation need compute expression expression needed 
note weak transformation disabled cycles control flow graph affect correctness transformation 
computational aspects discuss computational aspects briefly related papers 
model checking respect yields set pairs 
pk satisfying 
consequence 
pk set places rule applied 
instance places dead code elimination done single model check 
time model check transition system low degree polynomial near linear transition systems worst case 
course case model checking ctl fv formulas times higher depends size labelling function nodes ap definition 
node time proportional size instruction exception propositions trans take time proportional size 
greater efficiency treated specially maintaining single global table transparency relation 
experience related indicates algorithm model checking ctl fv expensive practice free variables impose unreasonable time cost 

program semantics section define semantics simple programming language introduced definition 
section semantics show program transformed version semantics 

definition semantic framework assume fixed advance apply programs set value values specified containing designated element true 
fixed interpretation ary operator symbol function value value 
note value 
definition expression evaluation store function store var value 
expression evaluation expr store value defined 
en 
en define store function restricted original domain minus maps definition semantics point computation program state form state nodes store 
initial state input value true variables appearing program 
state transition relation state state defined 
ip skip ip read 

ip 

ip goto true 

ip goto true 

store 
note read effect store initial value set initial state 
operational semantics program form transition system execution transition system 
definition execution transition system program input value definition nodes store definition 
definition semantic function partial function value value defined exists finite sequence 
st order reason computational history program executions introduce notion computational prefix corresponding transition system defined 
control flow model defined definition abstraction see lemma 
correctness proofs relate program semantics control flow model 

method showing seman tic equivalence rewrite rules need show rewrite implies input terminating computation program terminating computation program 
problem link temporal property concerns futures transformation sufficient regard states time due operators au giving access information computed earlier 
solution enrich semantics transition system considering computation prefixes form 
st suppose model checked 
resulting substitutions see lemma describe computation prefix results model check contain information state sequence relating past states 
futures 
choice build transition system identical additional state 
st st 
reasoning involves futures done ordinary induction assuming crc show implies rc rc 
definition program initial value alue computation prefix sequence finite infinite 
si si 
definition computation prefix transition system program input value definition set finite computation prefixes 
st 
st st 
st st state transition relation definition 
note symbol represent transition relation execution transition system computation prefix transition system relations distinguished context 
goal show computation prefixes input corresponding pair states relation states expresses correct simulation 
consider programs read 
im write read 
write aim show semantically equivalent 
value defined computation prefix 
exists computation prefix transformed program 
conversely 
naturally prove result induction length prefixes 
practice induction hypothesis needs strengthened proof 
general form strengthened hypothesis relation holds computation prefixes original program computation prefixes transformed program 
noting transitions prefixes deterministic language see proving step case induction achieved proving relation prefixes preserved step transition system 
lemma details needs done show semantic equivalence 
lemma program equivalence induction programs semantically equivalent exists relation values 
base case holds initial computation prefixes 

step case rc rc 
closer bi simulation 

equivalence crc 
pt 
pt pt ii pt proofs equivalence split steps 
unsurprising step case induction hardest prove 
flow condition rewrite rule holds states fact control flow graph 
relation graph computational prefix system captured lemma follows definitions systems lemma suppose 
st computation prefix si pi 

pj cf pj cf 
cf pt path tcf 
pj cf pj cf 
cf maximal backwards path tcf see flow graph abstraction semantics program 
know program point specified rewrite instruction original program transformed program coincide lemma suppose programs related rewrite iq know transformed point program original program new program behave identically lemma suppose programs differ having different instruction program point 
examples lemma states expression contain variable stores differ value evaluation stores 
lemma program variable expression store vars lemma see variable instruction stores differ variable program behave way lemma suppose program points stores proof ip skip trivially 
ip implies vars 
lemma 
required 
trivially 
ip goto implies 
statement affect stores trivially note lemma states series instructions define variable value store respect variable change 
lemma consider state sequence 
pt pi pi instruction pi define variable 
lemma consider state sequence 
pt pi pi expression transparent pi dead code elimination dead code elimination rewrite rule described earlier skip ax true 
definition rewriting rewrite apply model checker find particular program point substitution maps particular program variable particular expression case need prove original program transformed program equivalent 
assume rewrite skip ax true holds 
definition consider 
st 
si pi pi 
crc 
pi 
pj 
pj base case note crc reflexive 
particular hold prefixes length 
step case suppose rc 
language deterministic exactly 
need show rc 
definition 
pt 
pt ip instruction program instruction program suppose pi definition implying lemma rc 
alternatively suppose pt 
ip skip 
rc 
consider pt pk definition lemma ipt pt lemma sequence pk cf pk cf 
cf pt path flow chart tcf condition ax true conclude pi lemma implies pt 
rc 
equivalence program points computation prefixes terminates terminates 
need show variable written written side condition rewrite know programs terminate program point pn prefixes related know lemma conclude 
constant folding constant folding rule def stmt definition rewrite apply model checker find particular program point substitution maps particular program variable particular program variable particular constant case need prove original program transformed program equivalent 
case relation identity relation 
wish prove length computation prefix length equal computation prefix length 
base case vars vars 
step case suppose equality holds relations 
pt suppose semantics semantics 
wish prove 
proof split depending pt 
suppose pt lemma follows 
suppose pt ipt pt 
know side condition lemma path pt 
maximal finite backwards path flow graph 
side condition states def stmt pt substitution maps lemma know exists ip know pj define lemma instruction set value 

equivalence identity program points computation prefixes terminates terminates 
clearly terminating prefixes equal value final stores 
lemma 
code motion loop invariant hoisting code motion loop invariant hoisting rule skip skip node def node trans node definition rewrite apply model checker find particular program points substitution maps particular program variable particular program expression case need prove original program transformed program equivalent 
definition suppose 
pt 
define relation computation prefixes crc pi cases holds 
pi 
pi pj 
pi pj notation indicate crc holds case defined 
base case vars vars 
case relation holds trivially 
step case suppose 
assuming crc need show rc 
proof split cases depending label pt split depending case crc holds 
suppose pt ipt pt 
suppose 
assumption implying pt lemma 
holds 
ii cr holds 
side condition satisfied pi pi node 
control flow model describes possible computation prefixes lemma hold computation prefix assumption ii know pj pj satisfied particular holds assumption lemma conclude pt 
holds unchanged 

suppose pt ipt skip pt semantics induction assumption pt pt 
rc implies instructions alter conclude holds skip 
pt ipt pt semantics induction assumption pt pt 
suppose cr lemma side condition def node trans node rewrite rule implies maximal finite backwards path eventually ends state pk pk contradicts assumption 
ii suppose cr assumption exists pi side condition implies lemma pg node ph def node trans assumption pj follows pj def node 
induction assumption says pj implies pj def lemma 
pj trans lemma semantics pt skip argument cr semantics ip argument semantics ipt ipt changes variable conclude 

iii exists cr holds wish show rc holds case 
note statements ipt pt affect variable see need show 
assumption exists pi side condition implies lemma node def node trans assumption pj follows pj def node induction assumption says pj implies pj def lemma 
pj trans lemma 
observations shown maps value semantics ipt argument semantics ip skip vars cr vars semantics argument semantics pt skip case holds induction conclude crc computation prefixes length input equivalence program points computation prefixes terminates terminates 
suppose terminate input consider store write statement im write 
suppose crc case side condition exists pi terminates 
semantics pi leading contradiction 
case hold 
case implying 
follows lemma transformation semantics preserving 

discussion described framework temporal logic plays crucial role proofs correctness classical optimizing transformations performed compiler 
framework transformations specified rewrite rules side conditions written temporal logic formulas 
prove correctness transformations show transformation applied change semantics program 
creative part proof finding relation relation closely related temporal logic side conditions transformation 
remainder proof straightforward 
routine showing program states computation prefixes encountering transformed program point 
deals directly program transformation point 
proof cases dramatically simplified assume temporal logic side condition holds transformation happened assumption leads immediately proof case 
proofs done hand nature proofs suited semi automated theorem proving 
creative step proof create relation wish prove inductively 
rest proofs tend involve mechanically performing case splits applying small set lemmas 
creative step providing relation closely related temporal logic side conditions 
interesting direction discover relation mechanically created side conditions 
programming language transformations applied admittedly simple 
types statements include necessary language features exceptions procedures 
limiting number types statements reduces number cases proofs simplifies presentation adding additional statements affect applicability method 
exceptions procedures require changes control flow model transition systems proof 
specification transformations dramatically change 
follow describing required adjustments preparation 
language treated traditional compiler intermediate language 
anticipate method validate great traditional optimizing compiler transformations 
part larger project study declarative methods specifying optimizations means automatically generating optimizers specifications 
specifications optimizing transformations rewrite rules temporal logic side conditions atomically implemented graph rewriting system model checker 
oxford authors programming tools group oxford particular oege de moor fruitful discussions microsoft research support research part intentional programming project 

abramsky hankin 
interpretation declarative languages 
ellis horwood 
aho sethi ullman 
compilers principles techniques tools 
addison wesley 
clarke emerson sistla 
automatic verification finite state concurrent systems temporal logic specifications 
acm transactions programming languages systems toplas 
cleaveland jackson 
proceedings acm sigplan workshop automated analysis software 
paris france january 
cousot cousot interpretation unified lattice model static analysis programs construction approximation fix points 
fourth acm symposium principles programming languages los angeles california january pp 
new york acm 
cousot semantic foundations program analysis muchnick jones eds program flow analysis theory applications chapter pp 
englewood cliffs nj prentice hall 

correctness classical compiler optimizations ctl 
unpublished report university copenhagen 
www diku dk research groups bibliography html th 
thomas 
computation tree logic ctl path quantifiers monadic theory binary tree 
automata languages programming proceedings icalp volume lecture notes computer science pages 
springer verlag 
havelund 
stepwise development denotational stack semantics 
sc 
thesis university copenhagen 
hecht 
flow analysis computer programs 
north holland 
jones ed semantics directed compiler generation 
volume lecture notes computer science springer verlag 
jones 
semantic program manipulation techniques 
bulletin european association theoretical computer science 
jones nielson 
interpretation semantics tool program analysis 
handbook logic computer science edited abramsky gabbay maibaum pages oxford university press 
knoop thing steffen 
optimal code motion theory practice 
acm transactions programming languages systems toplas 
kozen efficient code certification 
technical report computer science department cornell university january 
kozen patron 
certification compiler optimizations kleene algebra tests 
lloyd dahl furbach kerber 
lau palamidessi pereira sagiv stuckey eds proceedings st international conference computational logic cl lecture notes artificial intelligence volume springer verlag london july pp 

kupferman pnueli 

proc 
th ieee symposium logic computer science pages san diego june 
de moor 
imperative program transformation rewriting 
proc 
th international conf 
compiler construction volume lecture notes computer science pages 
springer verlag 
milne strachey theory programming language semantics 
chapman hall 
muchnick 
advanced compiler design implementation 
morgan kaufmann 
muchnick jones eds 
program flow analysis theory applications 
englewood cliffs nj prentice hall 
necula proof carrying code 
th acm symposium principles programming languages paris france january pp 
new york acm 
nielson 
denotational framework data flow analysis 
acta informatica 
nielson 
semantic foundations data flow analysis 
sc 
thesis aarhus university daimi pb 
nielson nielson hankin 
principles program analysis 
springer verlag 
pinter wolper 
temporal logic reasoning partially ordered computations 
proc 
rd acm symposium principles distributed computing pages 
podelski steffen vardi 
schloss seminar model checking program analysis 
workshop february 
rus van wyk 
model checking parallelizing compiler 
parallel processing letters 
schmidt 
data flow analysis model checking interpretations 
proc 
th acm symposium principles programming languages acm 
schmidt steffen 
program analysis model checking interpretations 
proc 
th static analysis symposium levi 
ed pisa volume lecture notes computer science springer verlag 
paul mitchell wand 
lightweight closure conversion 
acm transactions programming languages systems acm january 
steffen cla en klein knoop margaria 
fixpoint analysis machine 
proc 
th international conference concurrency theory concur lee smolka eds philadelphia pennsylvania usa volume lecture notes computer science springer verlag pp 

winskel 
formal semantics programming languages 
boston ma mit press 
wolper 
relation programs computations models temporal logic 
proc 
temporal logic specification volume lecture notes computer science pages 
springer verlag 
