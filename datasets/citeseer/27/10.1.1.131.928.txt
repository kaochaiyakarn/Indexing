ieee transactions software engineering vol 
july model checking large software specifications william chan student member ieee richard anderson paul beame steve burns david notkin senior member ieee jon reese member ieee experiences symbolic model checking analyze specification software system aircraft collision avoidance 
symbolic model checking highly successful applied hardware systems 
interested model checking effectively applied large software specifications 
investigate translated portion state system requirements specification traffic alert collision avoidance system ii tcas ii input symbolic model checker smv 
successfully symbolic model checker analyze number properties system 
report experiences describing approach translating specification smv language explaining methods achieving acceptable performance giving summary properties analyzed 
experiences discuss possibility model checking aid specification development iteratively applying technique early development cycle 
consider data point optimism potential widespread application model checking software systems 
index terms formal methods state specifications requirements statecharts symbolic model checking binary decision diagrams software verification 
software specifications cost money cases threaten lives 
increase confidence specifications particularly safety critical systems 
formal methods offer opportunities mechanical verification existing techniques scale large systems require extensive human guidance limited verifying simple important properties deadlock freedom consistency completeness 
symbolic model checking binary decision diagrams bdds efficient automatic verification technique simultaneously capable scaling verifying wide range properties section :10.1.1.1.5124:10.1.1.41.863
applied successfully industry scale hardware circuits aggressively analysis software specifications 
describe experience analyzing large system requirements specification symbolic model checking 
experiment translated sections significant portion preliminary version traffic alert collision avoidance system ii tcas ii system requirements specification requirements state machine language rsml input symbolic model verifier smv 
tcas ii aircraft collision chan anderson beame notkin department computer science engineering university washington seattle wa 
mail anderson beame notkin cs washington edu 
burns strategic cad technologies intel jones farm campus 
mail intel com 
university pittsburgh pa 
mail fm cs cmu edu 
reese engineering seattle wa 
mail eng com 
manuscript received aug revised feb 
recommended acceptance garlan 
information obtaining reprints article please send mail tse computer org ieeecs log number 
ieee avoidance system required commercial aircraft described complex system incorporated avionics commercial aircraft 
able control size bdds representing specification section analyze number properties section 
include general robustness properties safety critical properties specific domain 
objective test effectiveness model checking software systems experiences applying technology important individual results 
intent convey overcame key obstacles hope techniques applicable situations 
stress approaches crucial overcoming complexity size specification making amenable symbolic model checking nondeterministic modeling primarily nonlinear arithmetic allow checking part specification iterative process analyze specification 
discuss related section point limitations current model checking techniques tools suggest research directions section 
analysis preliminary versions specification mainly version dated march 
access versions know properties identified versions 
article full length report conference version :10.1.1.1.5124
model checking model checking formal verification technique state exploration 
state transition system property model checking algorithms exhaustively explore state space determine system satisfies chan model checking large software specifications property 
fig 
schematic process modelchecking state specification instances components shown parentheses 
model specification property fed model checker 
result claim property true counterexample sequence states initial state falsifying property 
practice counterexamples provide valuable debugging information software engineer modify specification model property checked 
iterative process inherent 
rest section give overview basics ctl model checking smv model checker 
ctl model checking problem temporal logic model checking state transition system models software hardware system property specified formula certain temporal logic determine system satisfies formula 
common logic model checking branching time computation tree logic ctl extends propositional logic certain temporal operators 
typical formulas include meanings temporal operators ag ag safe reachable states safe 
ag af stable system stable infinitely 
ag request af response request followed response 
ag ef restart possible restart system reachable state 
formally state transition system consists set states state transition relation set initial states path infinite sequence states consecutive pair states set states encoded set state variables state corresponds valuation variables distinct states correspond valuation mapping variable valuations 
simplicity discuss just subset ctl subset temporal operators ag af ef sufficient understand examples 
recursively define restricted class ctl formulas follows say proposition boolean fig 

model checking specification 
combination predicates state variables 
formula proposition boolean combination formulas form ag af ef formula 
formula evaluated state proposition holds satisfies proposition 
operator means paths starting means path starting means state path means state path ag safe holds state path starting satisfies proposition safe 
system satisfies formula formula holds initial states 
model checker typically attempts find counterexample 
example formula ag safe false counterexample finite path starting initial state state safe 
readers familiar temporal logic model checking may notice ctl formula usually interpreted kripke structure state labeled set atomic propositions definition state explicitly labeled thought labeled implicitly corresponding state variable valuations 
restricted formulation sufficient presentation 
symbolic model checking bdds explicit model checking techniques truth value ctl formula determined graph theoretic manner traversing state diagram time complexity linear size state space length formula 
unfortunately size state space exponential size system description resulting state explosion problem 
important breakthrough model checking symbolic techniques visiting individual states conventional state space search symbolic model checkers visit set states time 
state set represented predicate state variables state set predicate true state 
efficiency symbolic model checking relies succinct representations efficient manipulations predicates 
state space finite assume loss generality state variables boolean finitely 
predicate variables simply boolean function represented reduced ordered binary decision diagrams ieee transactions software engineering vol 
july bdds :10.1.1.1.5124:10.1.1.41.863
intuitively bdd binary decision tree isomorphic subtrees combined resulting directed acyclic graph 
addition path contain variable comply fixed linear order variables 
bdds canonical boolean function variable order exists unique bdd represents function boolean operations conjunction disjunction negation computed polynomial time 
bdds usually small sizes depend critically variable order see section 
number bdd symbolic model checkers built mainly hardware circuit verification 
represent state sets transition relation bdds 
efficiency bdds algorithms hardware systems states analyzed industrial designs verified falsified 
smv smv ctl symbolic model checker bdds represent state sets transition relations 
summarize smv features pertinent discussion 
smv represents true false 
logical operators respectively 
smv program consists description finitestate transition system list ctl formulas 
recall transition system defined state space transition relation set initial states 
state space determined state variable declarations preceded keyword var 
example code var boolean declares boolean variable integer variable ranging variable value drawn set 
variable internally represented boolean variables 
transition relation initial states specified collection simultaneous assignments assignments simultaneously start subsequently state assignments simultaneously executed cycle 
assignments preceded keyword assign variable var init var refers value var initial states code assign init sets initial value 
define transition relation expression var represents value var states 
assign specifies state value negation current value value toggles forever 
operator appear right hand side assignment 
common way define state values case expression assign case esac says value currently incremented state reset 
words modulo counter 
branches evaluated sequentially means true second branch represents default case 
smv macro facility defining symbol represent expression keyword define 
notice state variable introduced defined symbols 
example define assign case esac code sets state value true false 
operator applied defined symbols appear right hand side assignment 
sym gives value sym state 
equivalent replacing variable var var definition sym 
example identical 
sources nondeterminism smv relevant 
expression set nondeterministically evaluates value set 
example code assign init restricts initial value 
addition initial state value variable specified nondeterministically evaluates value type 
alternative way specify transition relation keyword trans followed arbitrary expression involving state variables defined symbols versions 
expression directly defines transition relation proposition 
example assignment equivalent trans state assignments define transition relation imperatively trans statements define declaratively 
trans statements succinct strictly expressive 
robust example empty transition relation specified trans statements resulting strange analysis results 
problems hard track trans statements care 
program contain state assignments trans statements 
conjunction forms transition relation 
chan model checking large software specifications translation basics section give informal overview rsml provide intuition translation rsml smv showing example section 
general translation rules described section 
rsml overview rsml state machine language statecharts extending conventional state diagrams state hierarchies broadcast communications 
focusing subset rsml model system state hierarchy events inputs particular input output interfaces rsml ignored 
state hierarchy state hierarchies allow machine deep orthogonal structures 
precisely state may contain substates superstate state state state 
intuitively machine state machine substates state machine exactly substates 
state exactly default substate intuitively machine enters enters default substate explicitly enters substate 
state substates atomic state 
fig 
shows example rsml machine 
illustrates features rsml statecharts represent real device 
triggers alarm altitude aircraft low certain criteria 
hierarchical structure shown diagram containment 
highest level sys substates alt layer alarm substates state separated dashed lines 
alt layer state substates high mid low 
alarm state substates shutdown operating state containing mode volume 
default states mid indicated arrows origins 
fig 
shows hierarchy tree 
inputs events example contains input variables environment alt integer switch test 
input alt represents altitude aircraft switch controlled pilot 
states rsml synchronized events broadcast entire system 
events example generated environment called external events 
environment supposed generate periodically generated pilot changes volume alarm 
event generated machine internal synchronization 
simplicity assume general event generated environment rsml machine 
transitions transition represented arrow originating source state destination state 
statecharts notation label transition form fig 

example rsml machine 
fig 

state hierarchy drawn tree 
shaded nodes represent states unshaded nodes represent states leaves atomic states 
id trig cond acts id uniquely identifies transition presentation trig trigger event guarding condition cond predicate states inputs acts set action events 
guarding condition actions optional 
idea machine source state trigger occurs guarding condition true considered true absent transition enabled 
conflicting transitions enabled intuitively transitions conflict taken time ieee transactions software engineering vol 
july transition taken machine exits source state enters target state generates action events 
additional states may entered exited maintain integrity state hierarchy 
example taken state entered operating mode volume 
machine operates follows 
initially environment generates external events enabling transitions described 
maximal set enabled transitions mutually nonconflicting taken possibly generating new events 
called microstep 
notice conflicting transitions enabled maximal set unique resulting nondeterminism 
microstep events newly generated vanish 
new events broadcast machine may trigger transitions 
process continues transitions enabled point machine stable 
cascading microsteps point external events arrive point machine stable called step 
rsml assumes synchrony hypothesis says step new external event may occur values inputs remain unchanged :10.1.1.1.5124
words machine runs infinitely faster environment 
machine stable inputs change external events occur 
tables guarding condition transition complex fit fig 
shown fig 
table features distinguish rsml statecharts 
leftmost column table shows list predicates table represents proposition predicates disjunctive normal form 
column leftmost evaluates conjunction predicates marked column negations marked entire table evaluates true columns true 
informally expression prev expr refers value expr previous step 
special variable indicates current time exited time state exited 
note synchrony hypothesis implies value change step 
table reads row machine state low column current value alt column current previous values alt column machine exited mid time units ago 
fig 

transition 
reduce sizes tables rsml allows functions macros 
example fig 
input alt function defined requirements value depend inputs states 
similarly macro replace primitive predicate leftmost column defined table 
functions macros optionally take parameters 
translating example section translate rsml example smv code 
complete smv program shown appendix smv variables declare smv variables state hierarchy inputs events 
events easy naturally translated boolean variables 
example var boolean similarly events 
intended meaning variable true event just generated 
input switch straightforward switch test rsml machine specify upper lower bounds alt 
obviously lower bound upper bound greater sufficient 
fact alt represented values keep translation straightforward define range bdds handle range problem alt state hierarchy encoded follows 
hierarchy provides choice substates natural declare variable state substates form range variable alt layer high mid low alarm shutdown operating mode volume values variables completely determine current states machine 
note value alarm shutdown values mode volume irrelevant 
find convenient define symbol indicate exact condition machine particular state 
example define define sys alt layer sys alarm sys machine sys alt layer alarm 
high alt layer alt layer high operating alarm alarm operating mode operating mode mode conditions states defined similarly 
chan model checking large software specifications rsml transitions define transition say enabled define mid alt simply reflects definition transition enabled machine source state trigger event occurs guarding condition true 
specify state change self explanatory code assign alt layer case high mid low alt layer esac need specify event generated initialize states event init alt layer mid init alarm shutdown init note values mode volume initial states irrelevant need initialize initializing value harm 
inputs explicit constraints inputs machine modeled nondeterministically allow arbitrary environmental behaviors 
synchrony hypothesis precludes inputs changing machine stable 
define means stable define stable input alt changes assignment 
assign alt case stable alt esac default branch maintains synchrony hypothesis keeping value variable unchanged step 
code switch similar 
events unconstrained step step generated case stable esac inputs external events need initialized unconstrained start step 
prev timing constraints translated rsml machine predicates table fig 

referencing previous value alt requires extra variable prev alt remember value step var prev alt assign prev alt case stable alt prev alt esac timing constraints little tricky 
assume time discrete 
translate expression exited mid observe sufficient know exited mid represented variable time mid var time mid assign time mid case stable time mid time mid time mid esac timer time mid indicates number time units passed mid exited 
timer reset mid exited transitions 
step value timer incremented care timer specific values greater irrelevant 
note viewed exiting re entering mid 
consistent semantics rsml 
specified called identity transition transition reset timer 
case simply leave case branch 
simplicity discuss identity transitions 
translation rules explain translation rsml smv generally precisely formally define rsml machine state transition system section operational semantics rsml leveson 
definitions pnueli shalev 
simplicity assume absence timing constraints prev functions 
show translate deterministic rsml machines certain nondeterministic machines smv programs 
timing constraints prev functions considered section discussions alternative semantics translation rules 
rsml machines state transition systems define rsml machine state transition system distinguish rsml state element call global state call global transition relation 
rsml states states finite set rsml states children states states map state substates children 
ieee transactions software engineering vol 
july function required impose tree structure states distinguished element root root tree 
parent synonym superstate 
define children children transitive reflexive transitive closures children children children children children state states children children children children children say strict descendant ancestor related 
addition children strict descendant strict ancestor children atomic state 
state state case exactly default substate 
intuitively configuration maximal set states machine simultaneously 
states defined configuration root state substates state exactly substate substates example fig 
states sys alt layer high alarm shutdown configuration 
global states config states set configurations events finite set events inputs set possible assignments input variables 
set global states defined config events inputs 
words global state triple consisting configuration set events assignment input variables 
initial global states intuitively default completion state denoted complete unique configuration containing state default substate preferred substates 
state strict ancestor default substate example default completion sys alt layer mid alarm operating mode volume 
external events set external events 
set initial global states set triple complete root external inputs 
rsml transitions trans set rsml transitions 
transition tr trans attributes source state src tr states destination state dest tr states trigger event trig tr events guarding condition cond tr states inputs action events acts tr events external 
scope transition tr denoted scope tr defined lowest common strict ancestor source destination scope tr state strict ancestor src tr dest tr ancestor scope tr 
scope transition visualized state diagram smallest state strictly containing source destination intuitively minimal context transition 
require transition trans defined scope making instance transition root illegal 
example scopes alt layer scope alarm 
global transitions transition tr enabled global state config events inputs src tr machine source trig tr trigger occurs cond tr guarding condition holds 
say distinct transitions conflict scopes related 
example transitions alt layer pairwise conflicting scopes identical related 
transitions conflict scope alarm ancestor scope mode 
define tr unique child scope tr ancestor src tr tr unique child scope tr ancestor dest tr 
instance shutdown operating respectively 
transition tr taken descendants tr machine currently exited certain states descendants tr induced dest tr entered 
formally transition tr define exits tr children tr enters tr intersection complete dest tr children tr 
enters tr precisely specifies states machine enters transition tr 
exits tr little precise 
clearly transition tr taken machine states exits tr particular src tr tr taken machine longer state exits tr 
mere fact tr taken general specify information states machine prior transition 
example exits shutdown enters operating mode volume exits descendants operating enters shutdown 
global transition relation config events inputs defined set tuples exists set transitions trans satisfying transition enabled 
transitions conflict 
maximal transition enabled conflicts transition tr tr 
tr acts tr 
external inputs 
transitions said taken 
reachable global state choice unique machine nondeterministic 
point generates action events keeps input variables unchanged ac chan model checking large software specifications cording synchrony hypothesis generates subset external events assigns new values inputs indicating step 
translate global states recall global state consists configuration set events assignment inputs 
assume numbers rsml states events inputs range input finite global state space finite 
symbolically encode events declare boolean variable 
similarly naive encoding configurations set states declare boolean variable state 
encoding improved observation configuration uniquely determined intersection set atomic states 
need boolean variable atomic state 
method requires large number boolean variables state atomic substates requires boolean variables 
optimal encoding state obviously declare variable range size equivalently declare log boolean variables 
encoding described section natural extension idea 
recall state declare variable range children 
obtain succinct encoding flatten nested states substates states 
example taken tcas ii requirements fig 
shows example nested states composite ra ra positive states 
vertical bar right arrows attached transition bus implying transition pair states connected bus 
ra climb descend negative pairwise connected transition direction 
translated smv program contains code var composite ra ra climb descend negative climb vsl climb vsl vsl descend vsl descend vsl vsl define ra positive negative positive climb descend climb composite ra composite ra climb generally set states parents states set atomic states state parents 
set states consists states upper boundaries alternations states states state hierarchy 
note root contained may may 
leader denoted leader lowest ancestor set followers denoted followers consists leader note relationship identical parent child relationship nested states nested states atomic state state parent case example fig 

fig 
followers composite ra ra climb descend negative climb vsl children 
fig 

nested states tcas ii 
fig 
shows general smv code declaring initializing global state variables 
shown rule declare variable leader range followers 
state default default child default recursively defined default default default state default 
alternatively characterize default unique state complete followers 
rules tell system particular state 
note state corresponds exactly rules loops recursive definitions 
encoding scheme valuation variables corresponds legal configuration 
rules events inputs 
range denotes range input translate deterministic transitions deterministic machines easy translate set transitions taken exactly set enabled transitions 
fig 
shows translation rules correct deterministic machines 
rules applied nondeterministic machine behavior translated smv program identical rsml machine point conflicting transitions simultaneously enabled systems start exhibit diverging behaviors 
rule defines transition enabled taken 
section appendix simplicity define symbol tr defining tr enabled tr taken 
rule cond tr refers proposition describes guarding condition 
rule defines effects transition state hierarchy 
set followers enters tr contains follower machine enters tr 
note set empty singleton set 
rules generate appropriate events update inputs step 
argue informally correctness translation 
clearly rules ensure enabled transitions ieee transactions software engineering vol 
july fig 

rules declaring initializing smv variables rsml machines 
cause state change generate action events 
claim enabled transition causes necessary state change rule deterministic assumption case branch true enabled transition tr results updating variable follower enters tr 
virtue state encoding implies state enters tr entered state exits tr previously occupied exited 
easy see enabled transitions result generation action events inputs updated correctly 
note symbol stable indicates step defined events direct translation definition tr trans tr enabled 
versions nearly identical events occurring enabled transitions enabled transitions events occur microstep 
defining stable events concise usually far fewer events transitions 
second advantage bdd representing stable smaller 
efficiency issues discussed section 
example section translated rules 
careful readers may notice machine fig 

rules translating deterministic rsml transitions 
nondeterministic translation exact 
section discuss discover violating transitions 
translate nondeterministic transition principle translating machines arbitrary nondeterministic transitions straightforward 
strategy declare set auxiliary boolean variables representing transitions trans 
translate definition global transition relation literally order logic formula finitely auxiliary global state variables optionally quantify auxiliary variables 
conceptually simple method inefficient number transitions number auxiliary variables usually large 
potentially efficient ways constructing global transition relation general constructions expensive 
interested readers referred example 
give modifications rules fig 
handle rich class nondeterministic machines chan model checking large software specifications property transition taken appears taken 
rule fig 
replacing rule explains precisely assumption means transition taken enabled microstep machine enters appropriate states generates appropriate action events 
see shortly may true general 
fig 

rules translating class nondeterministic rsml transitions 
rules replace rule 
rule ensures machine remains state transition exiting state taken 
set conflict tr defined transitions conflict tr 
rule concisely says set transitions taken maximal nonconflicting transition enabled case taken taken conflicting transitions taken case conflicting transitions rules correct definition tr taken correct 
fig 
shows true 
events occur simultaneously machine state conflicting transitions enabled 
semantics machine take exactly tx ty go state generate event just look state change event generated machine appear taken tx ty making definition tr taken incorrect 
fact case translation prevents machine entering state rule ty taken true precluded rule 
hand rule prevents machine staying state resulting deadlock 
necessary sufficient condition correctness translation conflicting transitions fig 

transitions sources destinations 
may simultaneously enabled current configurations set actions machine gives information determine transitions taken 
simpler nondeterminism class machines captured quite rich translation introduce auxiliary variables resulting smv program large rule produces code size quadratic number transitions worst case 
furthermore defining transitions trans construct smv error prone assign 
certain nondeterminism easy model 
example suppose want specify state alt layer fig 
entirely nondeterministic machine guarding conditions omitted 
translation smv case trivial assign alt layer case high mid low alt layer esac example may want away guarding conditions code trick assign alt layer case high mid high mid low alt layer esac assignments similar model tcas ii machine proved sufficient experiments 
translate timing constraints rsml allows guarding conditions current time time state entered entered exited exited 
time grows bound underlying state transition system general infinite number global states model checking inapplicable 
fortunately common cases handled 
restrict predicates involving time comparing entered exited constant need keep track time lapses variables call timers 
finitely time predicates timer exists largest constant compared 
range timer bounded constant translated example section 
generally take timer entered example 
upper bound set transitions tr enters tr 
code ieee transactions software engineering vol 
july var 
assign case tr tr stable esac notice initialize timer 
state entered example value entered undefined 
catch undefined values including range timer special symbol indicates timer undefined initializing timer symbol 
reachability analysis tell machine may timer defined 
catching major concern simply leave initial value unconstrained model checker search initial value leads violation property checked 
comparing times entered exited handled introducing extra variables 
assuming discrete time model time natural number possible extend model checking handle dense time model time nonnegative real number restrict class time predicates 
entered exited arbitrary arithmetic expressions discrete time dense time machine precisely modeled finite state system fact model checking problem undecidable 
translate prev value prev input needed code var prev range assign prev case stable prev esac initialize prev reason initialize timers 
translation easily modified state macro function 
alternative translation prev remember truth values predicates involving prev value prev 
example predicate prev alt fig 
remember truth value alt numeric value alt 
method advantage possibly fewer bdd variables general 
example deal predicates involving previous current values prev alt alt 
miscellaneous rsml constructs exhausted rsml constructs rest easy translate macros functions arguments translated simply defined symbols 
arguments translated smv modules analogous templates instantiated call site macros functions 
rsml state machine arrays give succinct representation isomorphic substates state 
translated smv array module instances 
detailed translation conditional connectives fig 
roughly speaking factor common triggers guarding conditions set transitions 
conceptually simplest translation remove conditional connective conjoining pair incoming outgoing transitions efficient translations possible 
granularity global transitions note defined global transition relation section implicitly assumed global transition represents microstep natural choice 
alternatively global transition represent step 
may natural interested stable states machine analyzing properties step impossible 
addition need perform number analyses translation time ensuring step eventually terminate 
efficiency model checking affected representation may blow bdd size reduces number search iterations needed model checking algorithms 
clear priori method works better worse 
initial tcas ii experiments resulted huge bdds poor performance considered method 
possibility represent microstep series global transitions directly corresponds semantics rsml leveson 
defined maximal set nonconflicting transitions microstep equivalently defined loop initially empty enabled transitions added time maximal set obtained 
may choose represent iteration loop global transition 
obvious drawback increased number global transitions required encode microstep 
serious problem asynchrony model unique microstep deterministic general different orders picking transitions model checking algorithm need explore possibilities 
representation microsteps viewed way statically eliminating asynchrony 
alternative semantics variants statecharts translated similar rules 
example statemate semantics statecharts close semantics considered 
notable exception insist synchrony hypothesis provides option 
easily synchrony hypothesis changing rule fig 
set stable 
statemate provides internal variables allows assignments actions 
addition certain transitions considered conflicting assigned different priorities result nondeterminism simultaneously en chan model checking large software specifications 
trigger events optional 
slight modifications rules suffice differences 
constructs history connectors synchronization activities require new translation rules 
contrast semantics defined pnueli shalev quite different 
unclear translate semantics simple way introducing auxiliary global state variables 
rsml semantics defined heimdahl leveson slightly different semantics considered earlier leveson 
differences important conflicting transitions different triggers simultaneously enabled happen portion tcas ii requirements machine modeled 
general different translation rules required 
obstacles derived translation rules previous section overcome number obstacles model checking tcas ii specification feasible 
tcas ii tcas ii airborne collision avoidance system required united states federal aviation administration faa commercial aircraft enter airspace 
tcas equipped aircraft surrounded protected volume airspace 
aircraft volume tcas ii generates warnings traffic advisories suggests possible escape maneuvers resolution advisories ras vertical direction pilot 
examples ras include climb descend increase climb increase current climb rate increase descend climb vsl descend climb vsl descend ft min 
system requirements specification tcas ii page document written rsml 
obstacle analysis sheer size 
attempt decided try verify portion state machine called aircraft occupies percent specification 
aircraft close interactions state machine called aircraft tracks state aircraft vicinity possibly generates ras 
aircraft tracked 
ras instances aircraft aircraft derives composite ra generates visual audio outputs pilot 
state shown fig 
represents chosen composite ra substates aircraft 
aircraft supposed deterministic modeled mainly translation rules section abstraction discussed 
created variables states aircraft referenced aircraft allowed nondeterministic transitions states translation explained part section 
focused resolution maneuvers intruder aircraft modeled instance aircraft 
bdds addition boolean enumerated variables inputs system include numbers altitude tude rates 
different versions specification inconsistent numeric variables integers reals 
ranges specified 
bdds assume inputs bounded integers 
take altitudes example 
altitude variables specified granularity fine ft compared constants ranging ft bits needed represent 
numeric inputs referenced guarding conditions macros functions 
bdds suitable variable order efficiently represent equality inequality linear expressions alt alt alt provably efficient bdd representation multiplication division variables alt time distance variable order :10.1.1.20.461
needed avoid 
functions aircraft involve multiplication division values measured altitudes altitude rates 
measurements input variables modeled nondeterministically 
abstraction treat calculated values nondeterministic 
eliminated model input variables referenced functions 
abstraction cause problems properties checked report section 
smv bdd size linear arithmetic performance bdd algorithms directly related bdd size 
early attempts checking generated enormous bdds point bdds consumed mb physical memory runs terminated bdd constructed 
attempts check formulas large bdds generally unsuccessful slow initial success identifying nondeterminism discussed section overnight run reduced minutes 
bdd size reduced dynamic variable reordering conjunctive partitioning supported version smv release 
techniques dramatically improved performance checking formulas solve problems 
bdd size sensitive ranges variables representing altitudes altitude rates 
fact smv efficiently handle simple example program appendix initially got problem redefining constants reducing variables small ranges example altitudes altitude rates 
increasing variables bit exploded checking time min hr 
able build bdds way check formulas ad hoc solution unsatisfactory ways 
obvious drawback small ranges distinct constants specification identical mapping example ft ft 
changed behaviors model caused invalid analysis results 
leave results addition comparison nondeterministic multiplication ieee transactions software engineering vol 
july division section addition comparison essential logic aircraft 
example descend ra prohibited difference current altitude aircraft estimated ground level altitude threshold 
subtraction comparison modeled nondeterministically safety requirement violated trivially 
problem ranges due smv inefficient implementation limitations bdds 
yang observe smv extremely inefficient constructing bdds integers building bdd simple assignment requires time space exponential number bits expressions involving multiple variables additional problem variable ordering 
example bit integers xn xn yn yn bdd size linear variable order xn yn xn yn requires exponential size order xn xn yn yn 
declared smv code var 

smv interleaves bits bdd variable order produces bdds predicate considered ways attacking problem changing internals smv doing addition comparison source code level 
principle may better long term solution yang give efficient algorithm constructing bdds linear predicates method simpler approach able great success 
wrote simple awk scripts automatically generate code var boolean boolean xn boolean yn boolean declare xn yn represent equality addition subtraction inequality similarly translated 
model altitudes altitude rates precisions required specification 
changing variables altitudes bits altitude rates bits blows size state space roughly increase precision increased run time number bdd nodes factor 
wrote awk back smv convert bits back integers easy interpretation counterexamples 
counterexample search counterexamples performance problems 
generating counterexample took hours formula determined false minutes 
evaluating formula finding counterexample done model checker separate searches reachability graph 
example verify invariant ag safe reachable state safe model checker started set unsafe states iteratively searched backward find set states reach unsafe state 
set contained initial state model checker determine formula false start second forward search initial state find counterexample 
modified model checker storing certain state information search eliminating second search 
result formula evaluated false counterexample instantly 
changes model checker detailed 
results analysis overcame obstacles ready analysis specification model checker 
properties analyzed include general properties hold rsml specifications sections domain specific properties sections 
violation properties unknown analysis sections 
note arbitrary system obvious domain specific properties verify 
experiments properties published documents knowledge system 
section report interesting results 
discuss approaches identifying properties check section 
table shows resources needed analyze properties 
time number bdd nodes memory allocated reported smv 
include resources construct global transition relation evaluate formula find counterexample formula evaluated false 
row gives resources just build global transition relation 
experiments performed lightly loaded sun sparcstation running sunos mb main memory 
modeled global state space boolean variables events states aircraft states aircraft altitude altitude rates inputs altitude altitude rates purposes 
size state space size reachable state space obtained lower bound executing smv command line option running completion 
option forces smv find reachable state space evaluating formula 
transition consistency need distinguish kinds nondeterministic transitions intentional resulting logic original specification rare case abstraction employed section exist original specification unintentional want detect 
chan model checking large software specifications table resources analysis 
memory time bdd allocated properties result sec nodes mb building transition relation transition consistency false function consistency false step termination true descend inhibition true increase descend inhibition false output agreement false reasons want find transitions 
jaffe argue nondeterminism software requirements usually reflects inconsistency avoided 
second translation smv assumed transitions deterministic separately dealt nondeterministic transitions special cases section 
unintentional nondeterministic transitions smv program general behave differently analyses invalid 
known nondeterministic transitions early versions specification 
example tcas ii notion sensitivity level determines volume protected airspace aircraft 
nondeterministic transitions allow choice identical conditions increasing decreasing sensitivity level clearly inconsistency early versions specification 
attempt find transitions model checker 
properties checked worked draft specification inconsistencies aircraft 
nondeterministic transitions previously identified heimdahl leveson different technique 
interested checking properties show model checking match previous results 
section summarize differences model checking approach technique heimdahl leveson 
example fig 
transitions enabled simultaneously 
check model checker ctl formula ag says transitions enabled simultaneously 
check similar formula pair conflicting transitions meant simultaneously enabled 
may large number cases check guarding conditions prevent transitions enabled time transitions alt layer 
premise heimdahl leveson technique 
case state space explored bdd quickly reduces ctl formula ag true turn trivially evaluated true 
model checker search counterexample 
technique able find nondeterministic transitions version tcas ii specification verify transitions exist version 
soundness analysis subtle important issue demands additional attention mentioned translation faithful rsml machine contains unintentional nondeterministic transitions 
may circular show absence transitions rsml machine translated smv program 
prove problem 
say global state reachable appears path starting initial state set global states reachable element set reachable 
lemma 
lemma 
state transition systems identical state spaces initial states 
define 

set reachable reachable 
set lemma set bad global states may lead different behaviors 
lemma says state reachable state reachable require states 
intuitively true shortest path state appear vice versa 
proof appendix state transition systems representing rsml machine translated smv program respectively defined 
assume abstraction nondeterminism discussed section 
definition set contains precisely set global states faithfully translated 
translation handles deterministic transitions intentional nondeterministic transitions faithfully set exactly set global states contains unintentional nondeterministic transitions 
means reachable exhibits unintentional nondeterministic behavior 
lemma sufficient analyze detect nondeterminism smv addition obtain false negative results 
hand intentionally nondeterministic transitions mistakenly modeled deterministic ones analysis reveal designer smv information correct model 
false negatives principle possible abstraction set may reachable 
false negatives happened experiments 
find false negatives checking properties discussed 
function consistency value function displayed model goal shown fig 
displayed pilot event called composite ra evaluated event occurs 
identifiers rsml macros abbreviations definitions omitted due limited space 
ieee transactions software engineering vol 
july fig 

definition displayed model goal 
function represents optimal altitude rate pilot aim positive value indicates upward direction 
function definition consists cases supposed mutually exclusive 
obvious case mutual exclusion depends logic specification 
checking mutual exclusion cases call function consistency similar checking transition consistency previous subsection 
defined boolean symbol case ith case checked ctl formula ag composite ra evaluated event case case case case case case model checker counterexample showing formula false 
carefully examining counterexample decided scenario due oversimplified model aircraft considered part nondeterministic environment 
counterexample aircraft reverses increase climb ra increase descend ra step prohibited logic specification 
changed code prevent aircraft making spurious transitions counterexamples 
refinement aircraft allow successful checking property implications model checking development specifications 
essence examination scenario subsequent refinement considered way documenting intended implicit interaction aircraft aircraft state machines 
occurrence case refinement effective way allow translate check properties portion specification full specification 
done specification developed effective way understand document interactions parts specification 
step termination step rsml state machine may terminate machine contains cycle events transition relation 
precedence relation events rsml specification usually forms partial order easy see step terminate happens tcas ii specification 
alternatively framework verify termination ctl formula ag af stable means machine stable infinitely 
words stay unstable finite number microsteps 
formula true model specification expected 
inhibition resolution advisories tcas ii document claims descend ras inhibited aircraft ft ground level increase descend ras inhibited ft ground level 
logic guarantees safety properties resides aircraft aircraft 
imposed necessary constraints transitions aircraft order check chan model checking large software specifications part logic aircraft correct 
model checker property satisfied second 
formula checked second property roughly ag stable radio altimeter status valid alt radio increase descend alt radio input representing altitude aircraft ground level radio altimeter status input indicating alt radio valid increase descend expression evaluating true increase descend ra issued 
mentioned section inequality long expression relating bits alt radio 
counterexample model checker revealed typographical error guarding condition specification 
effect error increase descend ra inhibited step allowing safety property violated 
output agreement addition value displayed model goal state composite ra fig 
shown pilot composite ra evaluated event occurs 
safety critical composite ra displayed model goal agree 
checked properties 
example expect composite ra state climb displayed model goal ft min 
model checker revealed true 
fact showed stronger result ra climb displayed model goal negative 
ctl formula checked ag composite ra climb composite ra evaluated event displayed model goal counterexample model checker step scenario consisting global transitions time intruder aircraft aircraft gives descend ra 
result composite ra state descend case fig 
displayed model goal ft min 
time aircraft realizes increase descend rate necessary issues increase descend ra puts displayed model goal ft min case 
time situation changed aircraft projects climb result greater separation intruder 
reverses ra climb making composite ra enter state climb 
point case applies displayed model goal ft min resulting contradictory outputs 
best knowledge behavior version specification known 
resources shown row table analysis 
output agreement property new increase climb ra issued value displayed model 
discovered typographical error observation translation process 
goal decrease 
result similar function consistency model checker counterexample due abstracted model aircraft 
refining model counterexamples 
ctl formula checked ag composite ra evaluated event new increase climb displayed model goal prev displayed model goal miscellaneous value prev expr undefined step 
mentioned section constrain initial value smv variable representing prev expr model checker find initial value falsifies property checked 
verifying properties mentioned discovered situations prev values referenced step 
addition ag ag af formulas checked formulas form ag ef asserts possible 
example may predicate inputs formulas ag ef radio altimeter status valid ag ef radio altimeter status invalid note verifying formulas establish property rsml specification merely sanity check ensure model prevent environment changing 
common ag ef formulas specify possible shut restart machine 
notions shutdown restart applicable model aircraft check example possible system enter certain states produce certain outputs example machine locked certain ra inputs change 
nondeterminism certain details behavior possible smv program guaranteed exist rsml machine 
analysis ag ef formulas sound 
problem solved technique called module checking 
related case studies independent case studies model checking real life software requirements 
general major difference system environments abstracted set predicates variables small enumerative range inputs system include numerical values 
numerical calculation comparison abundant tcas ii specification caused significant problems model checking process 
studies differ requirements languages 
example contain features hierarchical states microsteps assume synchrony hypothesis 
smv analyze aircraft software requirements written software cost reduction scr notation 
successfully verified falsified temporal properties 
ieee transactions software engineering vol 
july formal specification power plant pugliese developed process algebra specification verified house bdd model checker 
crow di analyzed requirements software subsystem space shuttle nasa explicit model checker mur verify invariants 
symbolic representations bdds manually reduced ranges environment inputs control size state space 
gave bdd encoding statecharts 
version statecharts semantics state hierarchy encoding similar assume synchrony hypothesis flatten nested states section 
custom built bdd model checker encoded transition relation generally allow arbitrary nondeterministic transitions expense construction cost bdds 
contrast focused deterministic transitions certain nondeterministic ones easy model sufficient experiments 
scheme analyze hypothetical production cell 
compositional approach cope bdd explosion problem 
approaches fighting state explosion number widely researched approaches handling state space explosion problem 
contrast studies single data point single approach corbett compared approaches bdd model checking smv partial order state space reduction inequality necessary conditions context detecting deadlock ada tasking programs 
deadlock corbett observed technique clearly superior certain kinds programs 
model synchronization corbett considered different issues translation smv relevant 
considered translation schemes 
translation comparison techniques precluded maximum parallelism transitions simultaneously enabled nonconflicting transitions allowed taken simultaneously taken sequence optimal symbolic model checking 
translation successful allow maximum parallelism extra variables 
hand require maximum parallelism owing semantics microstep take pains avoid introducing extra variables 
simple modification translation described section class problems considered require extra variables parallel nondeterministic transitions occur states 
translation change outcome corbett comparison needed determine approaches effective checking particular properties specific classes systems 
consistency completeness exploring state space heimdahl leveson compose results local analysis deduce global proper ties tcas ii specification 
properties checked different 
concerns transition consistency completeness domain independent properties 
section discussed verified transition consistency 
completeness intuitively means response specified input principle checked framework 
general approach permits analysis arbitrary ctl formulas capable verifying domain specific properties 
consider consistency detail 
tool checks conjunction guarding conditions pair conflicting transitions trigger contradiction 
example fig 
check ctl formula ag holds system check conjunction guarding conditions contradiction 
general method accurate orthogonal reasons 
explore reachable state space states exhibit inconsistency incompleteness may reachable 
words conjunction guarding conditions satisfiable user responsible determining failure represents genuine problem case model checker help finding counterexample 
inherent limitation approach inherent advantage allows simple analysis 
second source inaccuracy stems decision consider transitions trigger 
consider fig 

conflicting transitions simultaneously enabled triggers may occur time 
tool fail detect simply considers transitions different triggers 
hand conservative assumption subset events may occur time mistakenly report may cause nondeterminism realizing triggers mutually exclusive reachable states 
source inaccuracy method way construct boolean formula checking create boolean variable predicate guarding condition 
example check mutually exclusive boolean variable alt variable alt check contradiction 
clearly results false negative 
heimdahl theorem prover pvs attack problem 
hand property boolean variables representing bit encoding alt construct bdd predicate alt alt automatically reduced contradiction 
note boolean variables bdd size scales inequalities linear arithmetic operations 
disadvantage inability deal real numbers discretized bounded integers 
bdds efficiently handle complicated nonlinear predicates tcas ii currently theorem proving approach 
chan model checking large software specifications model checking give accurate results costly 
approaches complementary system development verification 
hybrid systems verification results robust sense synchrony hypothesis assumption environment includes pilot aircraft 
verify properties depend environment aircraft collide pilots follow ras addition robustness reason having modeled environment precisely lack information specification 
principle information available incorporated model discretize inherently continuous environment 
verification hybrid systems tackles problem modeling environment set real valued variables governed constraints derivatives 
complexity model checking higher problems undecidable symbolic model checkers hybrid systems built 
currently cope tcas ii handle multiplication sizes models analyzed published case studies orders magnitude smaller tcas ii 
interesting see generation tools scale significantly larger systems 
discussion section address common concerns applying model checking software suggest model checking development tool discuss research directions 
feasibility belief model checking apply complex software systems prevalent 
related section shown concerns may serious commonly believed 
restriction finite states concern bdd model checking apply finite state systems software specified infinite states 
current research trend devise symbolic representations model checking algorithms directly verify classes infinite state systems techniques far mature bdd methods :10.1.1.41.863
infinite state systems abstracted finite state ones amenable conventional model checking analysis 
abstraction conservative sense properties hold abstraction guaranteed hold full specification 
goal analysis find errors proving correctness preservation guarantee techniques model checking find counterexamples guarantee properties 
example inputs versions tcas ii specified real numbers discretized integers model section 
counterexamples finite state model exist full specification 
regularity concern hardware circuits software systems may exhibit necessary regularity yield symbolic techniques 
contrary bdds capture complex control structures tcas ii 
regular operations multiplication appear specification handled efficiently bdds 
data paths real obstacle analyzing entire tcas ii 
say arithmetic 
scale demonstrates symbolic model checking successfully applied real life system widely recognized complex 
analyze entire specification just shows obtain useful results incomplete models 
words necessary check complete specification get significant benefits technique 
abstraction key scale 
experiment details aircraft arithmetic operations inefficient bdds manually abstracted away nondeterminism 
form abstraction automated performing dependency analysis 
approach scale automatic reduction techniques relevant bdd symmetry reduction 
technique applicable current model tcas ii lacks symmetries perfect candidate extend model include instances aircraft 
recall current model contains instance aircraft 
symmetries arise case global states equivalent obtained permuting local states instances aircraft 
model checking design tool understanding documentation shown section obtained false counterexamples abstracted model 
refined model remove spurious transitions verify properties question 
process getting incorrect counterexamples removing may counterproductive number reasons approach fact useful 
software engineer information obtained analyzing counterexamples clarify relationship parts specification particular parts fully modeled partially modeled 
complex specifications tcas ii interconnections subsystems fully described documented 
style model checking viewed way learning documenting interconnections parts specification 
ieee transactions software engineering vol 
july iterative development furthermore claim iterative approach serve development tool 
common conception verification specification process shows correctness reveals problems fixed 
view verification effective ways 
complete specification may large analyze mentioned abstraction necessary cope complexity 
second problems fixing expensive late specification stage costly problems implementation 
verification techniques early development cycle interleave design analysis tackle problems 
complexity gradually increases specification evolves verification early stages tractable 
addition analysis results give fast feedback designers improve technique 
researchers hardware verification pointed advantages early verification 
example developing tcas ii specification engineer specified aircraft left aircraft nondeterministic 
analyst analyzed aircraft model checking discovered assumptions behaviors aircraft necessary aircraft correct operations 
information develop aircraft 
development aircraft properties regression testing ensure properties continually maintained 
alternative regression checking abstracted model aircraft simulates sense milner refined model ctl formula sections holds guaranteed hold 
generally simulations preserve actl formulas intuitively include ctl formulas operator negations applied propositions 
efficient algorithms simulation exist provide attractive way hierarchical development systems experimental software specification needed 
tool integration integrated case tools today offer symbolic model checking option verification 
software engineers wish technology may follow strategy translating specifications inputs model checkers available 
automatic translation possible rules section show initially manual translation may help understand subtleties may arise translation process 
manual automatic translation experiences showed checking simple properties transition consistency completeness useful catching translation bugs 
symbolic model checking purest form conceptually simple available bdd packages incorporating model checking algorithms integrated case tool difficult principle integration difficult anticipated 
advantages doing com pared translation approach include flexibility construction bdds efficient application sensitive model checking algorithms 
example performance analysis improved orders magnitude modifying model checker 
important design tools domain experts feel comfortable 
example tables section designed replace propositional logic specifying guarding conditions rsml engineers find natural 
similarly domain experts may temporal logic understand intricacies 
finding intuitive alternatives sacrificing expressive power logic critical gaining wider acceptance 
dwyer worked line suggested specification patterns 
properties check model checking form property verification know properties check 
finding set properties coverage increase confidence correctness specification 
number approaches address complex question 
specification may state properties supposed hold 
jaffe described number properties satisfied specifications safety critical component determinism completeness believe certain domainspecific properties output agreement section applicable applications 
software analysis problems deviation analysis posed model checking problems 
properties check may arise field 
example pilots reported anomalous behavior observed versions tcas ii 
anomalies checked specification may determine problem specification implementation report 
nonlinear arithmetic serious hurdle applying bdd model checking remaining portion tcas ii specification abundance nonlinear arithmetic operations multiplication variables 
hard see model checking presence predicates integer multiplication intractable problem hard factorization number build transition guarding condition xy determine prime number model checking transition enabled finding counterexample corresponds factoring 
bryant chen observed similar connection bdds factoring :10.1.1.51.9808
note multiplication change worst case complexity model checking theoretically intractable problem 
follows symbolic technique heuristic 
chan model checking large software specifications theoretically bdds require exponential size boolean functions efficiency bdds due ability capture concisely control data patterns arise practice 
similarly may techniques representations handle nonlinear arithmetic calculations arise practice 
tempting adapt bdds handle multiplication 
word level model checking technique 
control represented bdds operations integers represented binary moment diagrams concisely represent product integers 
algorithm clarke allows multiplication temporal logic formula multiplicative predicates guarding conditions 
unclear method adapted solve problem 
proposed tightly coupling bdds decision procedure nonlinear predicates attack problem needed investigate practicality 
possible approach approximation middle ground abstracting multiplication completely representing precisely 
case studies additional experience needed applying model checking realistic state specifications 
early stages studying statecharts specification electrical distribution system avionics 
additional experiments needed determine applicability model checking state software specifications 
mentioned feel strongly effective technology come aiding development specifications fact checking 
real benefit approach shown practice developing specifications model checking 
shown translate part large system requirements specification input symbolic model checker check nontrivial properties 
approach analyzing specification iteratively modeling components nondeterministically refining proved powerful 
critical steps realizing symbolic model checking effective tool process analyzing developing software specifications 
believe investigation contributes increase optimism symbolic model checking overcome predicted impediments successful analysis realistic software specifications 
appendix translation example complete smv translation rsml example fig 
explained section smv handle program 
module main var boolean boolean boolean switch test alt prev alt alt layer high mid low alarm shutdown operating mode volume time mid define stable sys alt layer sys high alt layer alt layer high mid alt layer alt layer mid low alt layer alt layer low sys shutdown alarm alarm shutdown operating alarm alarm operating mode operating volume operating mode mode volume volume volume volume high alt mid alt alt low alt mid alt high alt low alt mid alt shutdown switch shutdown switch mid shutdown switch test low alt alt prev alt time mid assign init alt layer mid alt layer case high mid low alt layer esac init alarm shutdown alarm case operating shutdown alarm esac init mode mode case mode esac init volume volume case ieee transactions software engineering vol 
july volume esac init case stable esac case stable esac switch case stable test switch esac alt case stable alt esac prev alt case stable alt prev alt esac time mid case tt stable time mid time mid time mid esac appendix proof lemma assume reachable argue reachable 
direction symmetric 
definition reachability exists finite sequence states qn qn qi qi 
smallest qi qk 
argue reachable showing trace 
assumption need show know 
definition contradicting 
acknowledgments members winter cse mc seminar university washington 
performed authors university washington funded part national science foundation 
ccr 
william chan funded part microsoft graduate fellowship 
britton parker parnas shore software requirements aircraft technical report naval research laboratory mar 
alur courcoubetis dill model checking real time systems proc 
fifth ann 
symp 
logic computer science pp 
philadelphia ieee june 
alur courcoubetis henzinger halbwachs 
ho olivero sifakis yovine algorithmic analysis hybrid systems theoretical computer science vol 
pp 

alur henzinger eds 
computer aided verification 
proc 
eighth int conf cav lecture notes computer science 
new brunswick springer verlag july aug 
anderson beame burns chan notkin reese model checking large software specifications garlan ed proc :10.1.1.1.5124
fourth acm sigsoft symp 
foundations software eng pp 
san francisco oct 
published software engineering notes vol 
nov 
berry gonthier esterel synchronous programming language design semantics implementation science computer programming vol :10.1.1.1.5124
pp 
nov 
bharadwaj heitmeyer verifying scr requirements specifications state exploration proc 
acm sig plan workshop automatic analysis software paris france jan 
boehm software engineering economics 
prentice hall 
godefroid symbolic verification communication protocols infinite state spaces alur henzinger pp :10.1.1.41.863

bryant graph algorithms boolean function manipulation ieee trans :10.1.1.1.5124:10.1.1.41.863
computers vol 
pp 
aug 
bryant complexity vlsi implementations graph representation boolean functions applications integer multiplication ieee trans :10.1.1.20.461
computers vol 
pp 
feb 
bryant :10.1.1.51.9808
chen verification arithmetic functions binary moment diagrams technical report cmu cs school computer science carnegie mellon univ june 
bryant 
chen verification arithmetic circuits binary moment diagrams proc 
nd acm ieee design automation conf pp 
san francisco acm ieee june 
gerber pugh symbolic model checking infinite state programs presburger arithmetic grumberg pp 

burch clarke long mcmillan dill symbolic model checking sequential circuit verification ieee trans 
computer aided design integrated circuits vol 
pp 
apr 
burch clarke mcmillan dill hwang symbolic model checking states information computation vol 
pp 
june 
chan anderson beame notkin combining constraint solving symbolic model checking class systems non linear constraints grumberg pp 

chan anderson beame notkin improving efficiency symbolic model checking state system requirements young ed issta proc 
acm sigsoft int symp 
software testing analysis pp 
clearwater beach fla mar 
published software engineering notes vol 
mar 
clarke emerson sistla automatic verification finite state concurrent systems temporal logic specifications acm trans 
programming languages systems vol 
pp 
apr 
clarke jha exploiting symmetry temporal logic model checking formal methods system design vol 
nos 
pp 
aug 
clarke zhao word level model checking avoiding pentium error proc 
rd design automation conf pp 
las vegas acm ieee june 
chan model checking large software specifications cleaveland parrow steffen concurrency workbench semantics verification tool verification concurrent systems acm trans 
programming languages systems vol 
pp 
jan 
corbett evaluating deadlock detection methods concurrent software ieee trans 
software engineering vol 
pp 
mar 
crow di formalizing space shuttle software requirements proc 
acm sigsoft workshop formal methods software practice pp 
jan 
damm schl statecharts graphical specification languages symbolic model checking verification production cell lewerentz lindner eds formal development reactive systems case study production cell lecture notes computer science pp 

springer verlag 
dill mur verification system alur henzinger pp 

dwyer avrunin corbett 
property specification patterns finite state verification ed proc 
second workshop formal methods software practice pp 
clearwater beach fla mar 
federal aviation administration dept transportation tcas ii mar 
garlan allen architectural mismatch reuse hard ieee software vol 
pp 
nov 
computer aided verification proc 
ninth int conf cav lecture notes computer science grumberg ed haifa israel 
springer verlag june 
harel statecharts visual formalism complex systems science computer programming vol 
pp 
june 
harel naamad statemate semantics statecharts acm trans 
software eng 
methodology vol 
pp 
oct 
heimdahl pvs analyze hierarchical state requirements completeness consistency proc 
ieee high assurance systems eng 
workshop niagara falls canada oct 
heimdahl leveson completeness consistency hierarchical state requirements ieee trans 
software eng vol 
pp 
june 
obdd representation statecharts proc european design test conf 
european conf 
design automation 
european test conf 
european event asic design pp 
paris france ieee feb mar 
specifying software requirements complex systems new techniques applications ieee trans 
software eng vol 
pp 
jan 
henzinger henzinger computing simulations finite infinite graphs proc th ann 
symp 
foundations computer science pp 
milwaukee wisconsin ieee oct 
henzinger 
ho wong toi hytech model checker hybrid systems grumberg pp 

jackson model checking infinite specifications eds fme industrial benefit formal methods proc 
second int symp 
formal methods europe lecture notes computer science pp 
barcelona spain 
springer verlag oct 
jackson damon elements style analyzing software design feature counterexample detector ieee trans 
software eng vol 
pp 
july 
jaffe leveson heimdahl software requirements analysis real time process control systems ieee trans 
software eng vol 
pp 
mar 
kupferman vardi module checking alur henzinger pp 

leveson system safety computers 
addison wesley longman 
leveson heimdahl hildreth reese requirements specification process control systems ieee trans 
software eng vol 
sept 
mcmillan symbolic model checking 
kluwer 
mcmillan fitting formal methods design cycle proc 
st acm ieee design automation conf pp 
san diego june 
milner algebraic definition simulation programs proc 
second int joint conf 
artificial intelligence pp 
sept 
owre rajan rushby shankar srivas pvs combining specification proof checking model checking alur henzinger pp 

pnueli shalev step semantics statecharts proc 
int conf 
theoretical aspects computer software pp 

springer verlag sept 
pugliese automatic verification power plant 
gaudel woodcock eds fme industrial benefit advances formal methods proc 
third int symp 
formal methods europe lecture notes computer science pp 
oxford springer verlag mar 
reese leveson software deviation analysis technique proc 
int conf 
software eng pp 
boston may 
brief study bdd package performance srivas eds formal methods computer aided design int conf fmcad proc pp 
palo alto calif springer verlag nov 
feasibility model checking software requirements case study compass proc 
th ann 
conf 
computer assurance pp 
gaithersburg md ieee june 
limitations ordered representations functions hu vardi eds proc 
computer aided verification th int conf cav lecture notes computer science pp 
vancouver canada springer verlag june july 
wing case study model checking software systems science computer programming vol 
nos 
pp 
apr 
yang mok wang symbolic model checking event driven real time systems acm trans 
programming languages systems vol 
pp 
mar 
ieee transactions software engineering vol 
july william chan phd candidate department computer science engineering university washington 
growing hong kong went usa study received bs degree distinction department computer science cornell university 
current research interests formal methods particularly formal verification symbolic model checking software systems 
student member ieee member ieee computer society 
richard anderson received ba degree mathematics reed college phd degree computer science stanford university 
prior joining university washington postdoctoral research fellow mathematical sciences research institute berkeley 
associate professor department computer science engineering university washington 
dr anderson received national science foundation presidential young investigator award indo american fellowship award support year long visit indian institute science bangalore india 
research interests span field applied algorithms including collaborative ventures astrophysical simulation symbolic model checking web typography 
paul beame received bsc degree msc degree phd degree university toronto 
prior joining faculty university washington spent year postdoctoral research associate massachusetts institute technology 
dr beame associate professor department computer science engineering university washington joining faculty 
received national science foundation presidential young investigator award associate editor computational complexity served steering committee dimacs special year logic algorithms advisory committee fields institute special half year complexity 
research interests computational complexity particularly complexity propositional proofs application computational complexity problems formal verification 
steve burns received ba degree mathematics college ms phd degrees computer science california institute technology respectively 
dr burns member computer science engineering faculty university washington 
received national science foundation young investigator award 
engineer strategic cad technologies group intel 
received ab degree cornell university phd degree carnegie mellon university 
dr research fellow university pittsburgh 
served chair basic research symposium acm conference computer human interaction chi chair user interface software technologies uist 
prior joining university pittsburgh research focused human computer interaction software modeling 
currently research interests include molecular mechanisms cancer computational models gene environment interactions 
david notkin professor department computer science engineering university washington 
joining faculty received phd degree carnegie mellon university degree brown university 
dr notkin received national science foundation presidential young investigator award served program chair acm sigsoft symposium foundations software engineering served program chair th conference software engineering chaired steering committee international conference software engineering currently serves charter associate editor acm transactions software engineering methodology journal programming languages 
research interests software engineering general software evolution particular 
dr notkin senior member ieee 
jon reese received ba ms degrees computer science linguistics rice university respectively phd degree information computer science university california irvine 
dr reese president engineering 
member ieee ieee computer society 
