martin type theory contents nordstr petersson smith 
different formulations type theory 
implementations 
propositions sets 
semantics formal rules 
types 
hypothetical judgements 
function types 
type set 
definitions 
propositional logic 
set theory 
set boolean values 
empty set 
set natural numbers 
set functions cartesian product family sets propositional equality 
set lists 
disjoint union sets 
disjoint union family sets 
set small sets 
alf interactive editor type theory 
type theory described chapter developed martin original aim clarification constructive mathematics 
formalizations mathematics type theory predicate logic 
logical constants interpreted type chapter handbook logic computer science vol oxford university press october nordstr petersson smith theory curry howard correspondence propositions sets proposition interpreted set elements represent proofs proposition 
possible view set problem description way similar kolmogorov explanation intuitionistic propositional calculus 
particular set seen specification programming problem elements set programs satisfy specification 
advantage type theory program construction possible express specifications programs formalism 
furthermore proof rules derive correct program specification verify program certain property 
programming language type theory similar typed functional languages ml haskell major difference evaluation typed program terminates 
notion constructive proof closely related notion computer program 
prove proposition constructively means give function applied element gives element holds 
proposition expresses specification function obtained proof program satisfying specification 
constructive proof seen computer program process computing value program corresponds process normalizing proof 
computational content constructive proof type theory programming language program obtained proof specification type theory programming logic 
relevance constructive mathematics computer science pointed bishop 
implementations type theory serve logical frameworks different theories directly expressed implementations 
formulation type theory describe chapter form basis framework briefly section 
chapter structured follows 
give short overview different formulations implementations type theory 
section explain fundamental idea propositions sets heyting explanation intuitionistic meaning logical constants 
section give detailed description basic rules semantics reading material may just particular subsection hypothetical judgements 
section illustrate type theory logical framework expressing propositional logic 
section introduces number different sets final section give short description alf implementation type theory martin type theory chapter 
self contained chapter seen complement book programming type theory 
give presentation martin monomorphic type theory basic levels types sets 
book mainly concerned polymorphic formulation level types theory expressions 
major difference formulations monomorphic formulation type information terms possible implement type checker important type theory logical framework type checking proof checking 
different formulations type theory basic ideas martin type theory curry howard interpretation propositions types terminology propositions sets 
view propositions closely related heyting explanation intuitionistic logic explained detail 
source type theory proof theory 
identification propositions sets normalizing derivation corresponds computing value proof term expressing derivation 
martin original aims type theory serve framework theories interpreted 
normalization proof type theory immediately give normalization theory expressed type theory 
martin formulation type theory theories order arithmetic del second order logic simple type theory easily interpreted 
formulation contained reflection principle expressed universe including axiom shown girard inconsistent 
coquand huet calculus constructions closely related type theory having universe types prop type axiom prop type avoiding girard paradox 
martin formulations type theory predicative particular second order logic simple type theory interpreted 
strength theory considered chapter comes possibility defining sets induction 
formulation type theory constructive mathematics computer programming polymorphic extensional 
important difference earlier treatments type theory normalization obtained metamathematical reasoning direct semantics tait computability method 
consequence nordstr petersson smith semantics term element set computed normal form 
semantics theory lazy evaluation essential 
strong elimination rule set expressing propositional equality equality decidable 
theory intuitionistic type theory 
theory nuprl system group groningen 
type theory chapter put forward martin specific intention serve logical framework 
implementations major application type theory programming logic derive programs specifications 
derivations easily long tedious error prone essential formalize proofs computerized tools check 
examples computer implementations proof checkers formal logics 
early example automath system designed de bruijn check proofs mathematical theorems 
quite large proofs checked system example proofs landau book grundlagen der analysis 
system intended proof assistant edinburgh cambridge lcf system 
proofs constructed goal directed fashion starting proposition user wants prove tactics divide simpler propositions 
lcf system introduced notion metalanguage ml user implement proof strategies 
lcf system system martin type theory implemented teborg 
advanced system type theory developed constable cornell university 
years logical frameworks type theory implemented edinburgh lf coq inria lego edinburgh alf teborg 
coq lego coquand huet calculus constructions alf implementation theory describe chapter 
brief overview alf system section 
propositions sets basic idea type theory identify propositions sets goes back curry noticed axioms positive implicational calculus formulated hilbert style martin type theory correspond types basic combinators modus ponens corresponds functional application 
tait noticed analogy removing cut derivation corresponds reduction step combinator representing proof 
howard extended ideas order intuitionistic arithmetic 
way see propositions seen sets heyting explanations logical constants 
constructive explanation logic terms proofs proposition true know prove 
implication proof function method program proof gives proof notion function method primitive constructive mathematics function set set viewed program applied element gives element output 
idea propositions sets identify proposition set proofs 
case implication get identified set functions elements set form may depend heyting explanation conjunction proof pair component proof second component proof get interpretation conjunction set 
identified cartesian product elements set form disjunction constructively true prove disjuncts 
proof proof proof information proof 
nordstr petersson smith identified disjoint union elements set form inl inr negation proposition defined stands absurdity proposition proof 
denote empty set identified set interpretation implication 
order interpret propositions defined quantifiers need operations defined families sets sets depending elements set denote expression obtained substituting free occurrences heyting explanation existential quantifier 
proof consists construction element set proof 
proof pair component element set second component proof 
set corresponding disjoint union family sets denoted elements set pairs 
get interpretation existential quantifier 
identified set universal quantifier 
proof function method program element set gives proof 
set corresponding universal quantifier cartesian product family sets denoted elements set functions applied element set gives element set 
identified set martin type theory elements set form may depend note depend needed primitive cartesian products families sets 
way depend empty set introduced sets correspond atomic propositions 
set equality set expresses equal elements set recalling proposition identified set proofs see set nonempty equal 
equal elements set postulate constant id element set explaining sets interpreting propositions informal notation express elements sets 
notation differs type theory notation monomorphic sense constructors set depend set 
instance element form element form semantics formal rules section introduce notion type judgement forms explanation give rise 
explain family types introduce notions variable assumption substitution rules follow semantic explanations 
function types introduced semantic explanation formal rules explanation justifies 
rules formulated style natural deduction 
types basic notion martin type theory notion type 
type explained saying object type means objects type identical 
means judgement type formal system write type know conditions asserting object type know conditions asserting objects nordstr petersson smith type identical 
require conditions identifying objects define equivalence relation 
type know semantic explanation means type conditions object type 
type object satisfies conditions object type formally write furthermore semantics means type knowledge type know conditions objects type identical 
type objects type objects satisfies equality conditions semantic explanation write identical objects type types equal arbitrary object type object identical objects type identical objects 
types know conditions object conditions identical objects types 
investigate objects type objects type identical objects type objects type vice versa 
conditions satisfied formally write identical types requirement equality objects type equivalence relation formalized rules reflexivity objects symmetry objects transitivity objects martin type theory corresponding rules types easily justified meaning means type 
reflexivity types type symmetry types transitivity types meaning judgement forms immediately justifies rules type equality rules hypothetical judgements judgements introduced far depend assumptions 
general hypothetical judgement context form 
xn know type type context 
type context 
xn 
explanations hypothetical judgements induction length context 
meaning judgement forms empty context directly explain judgement forms context length order hide explanations heavy notation give hypothetical judgements depending assumption illustrate general case judgement type context length nordstr petersson smith type depend assumptions 
type write type means arbitrary object type type type substituted furthermore know identical objects type types 
type depending say family types type identical families types type means equal types arbitrary object type object type means know object type arbitrary object type know identical objects type identical objects type identical objects type depending means objects type arbitrary object type illustrate general case giving meaning judgement type context length hypothetical judgements explained similar way 
assume know explanations judgement forms context length 

xn context length know type type type 
xn know hypothetical judgement martin type theory type 
xn means know judgement type 
xn holds arbitrary object type empty context 
require arbitrary identical objects type judgement 
xn holds 
explanation justifies rules substitution objects types 
formulate rules different ways simultaneously substituting objects variables context 
formulating rules follow semantical explanation closely possible gives substitution types type 
xn type 
xn type 
xn 
xn explanations hypothetical judgement forms give substitution rules 
types context 
xn 
substitution equal types 
xn xj xj 
xn type context 
xn 
substitution objects 
xn 
xn type objects type context 
xn 
nordstr petersson smith substitution equal objects 
xn 
xn explanations hypothetical judgement forms justifies rule introducing assumptions 
assumption type type type 
xn type 
xn xn 
xn rule premises explicit 
order rules shorter comprehensible leave part context premise 
rules previous section assumptions justified hypothetical judgements 
function types basic ways form new type old ones form function type 
type family types want form dependent function type functions order explain means object type means objects type identical 
function type explained terms application 
know object type means know apply arbitrary object type get object get identical objects apply identical objects objects identical means apply arbitrary object type get identical objects type 
explained means object function type conditions objects function type equal justify rule forming function type 
function type type type type martin type theory obtain rule forming equal function types 
equal function types abbreviation depend write justify rules application application rules showing functions equal 
application extensionality occur free writing repeated applications simpler form 

fundamental way introduce function variable expression abstraction write repeated abstractions 
xn exclude outermost parentheses risk confusion 
know rule correct know function type semantics function types know apply type object type get object type explanation conversion nordstr petersson smith conversion know apply abstraction identical objects type get identical results type results 
see way 
conversion know 
meaning judgements type know 
symmetry transitivity get summarize object functional type means possible application looking conversion definition means apply abstracted expression object possible give meaning abstracted expression 
application primitive abstraction type level 
see set functions situation different 
rules introduced derive rules conversion rule type set occur free objects type set consist inductively defined sets 
order explain type explain means object means objects 
know set type explain set means sets know object set equivalently set know form canonical elements canonical elements equal 
canonical element element constructor form examples zero successor function natural numbers 
martin type theory sets element sets element equal elements sets equal elements 
explanation justifies rule set formation set type set may form type el objects elements set el formation set el type notice required sets built inductively know exactly ways build elements set different ways corresponding different constructors 
example ordinary definition natural numbers precisely ways building elements zero successor function 
contrast types general built inductively 
instance type set obviously defined inductively 
possible introduce new sets objects set 
concept type open possible add types language instance adding new object set gives new type el 
sequel write el clear context stands set type elements definitions generality usefulness language comes possibilities introducing new constants 
way introduce usual mathematical objects natural numbers integers functions tuples possible introduce complicated inductive sets sets proof objects way rules axioms theory represented framework 
distinction primitive defined constants 
value primitive constant constant 
constant type definition gets meaning semantics theory 
constant called constructor 
examples primitive constants succ introduced declarations set nordstr petersson smith succ defined constant defined terms objects 
apply defined constant arguments empty context instance 
en get expression expression computes step definiens typed object 
defined constant explicitly implicitly defined 
declare explicitly defined constant giving abbreviation object type instance explicit definitions succ set example monomorphic identity function applied arbitrary set yields identity function easy see explicit definition correct just check definiens object correct type 
declare implicitly defined constant showing definiens apply arguments 
done pattern matching definition may recursive 
decidable expression defined pattern matching set really defines value element set correctness implicit definition general semantical issue 
sure typed expressions form 
en unique typed definiens 
examples addition operator primitive recursion arithmetic succ succ natrec natrec natrec succ natrec propositional logic martin type theory type theory logical framework represent different theories 
general theory list typings 
cn 
cn new primitive constants list definitions 
dm em am 
dm new defined constants 
basic types martin type theory set types elements particular sets introduce 
section give number examples sets idea propositions sets express propositional logic conjunction implication connectives introduced way 
viewed type propositions semantics set seen constructive explanation propositions proposition defined laying counts direct canonical proof differently expressed proposition defined rules 
proposition object type set el type proofs semantics sets get proofs form identical parts get propositions proof propositions proof identical proofs propositions identical proofs 
primitive constant conjunction introduced declaration set set set declaration obtain repeated function application clause conjunction usual inductive definition formulas propositional calculus formation set set set infix notation written 
define counts proof conjunction done declaration primitive constant set nordstr petersson smith declaration inductive definition set elements set equal element form sets proof syntactical form called canonical proof function application obtain rule conjunction declaration set set obtain elimination rules conjunction introduce defined constants defining equations set set respectively 
notice definition constants justifies typings 
see typing correct assume sets show element know equal element form equal defining equation 
typings obtain function application elimination rules conjunction elimination elimination set set set set martin type theory defining equations correspond prawitz reduction rules natural deduction respectively 
notice role rules play 
justify correctness typings elimination rules 
elimination rules looked methods executed reduction rules defines execution elimination rules 
primitive constant implication introduced declaration set set set conjunction obtain declaration clause implication inductive definition formulas propositional calculus formation set set set canonical proof implication formed primitive constant declared set function application rule implication obtained declaration set set get canonical proof function applied proof gives proof proof obtained 
nordstr petersson smith obtain modus ponens elimination rule introduce defined constant set defined equation way conjunction definition show typed 
defining equation corresponds reduction rule function application obtain typing elimination set theory set set section introduce theory sets natural numbers lists functions specifying implementing computer programs 
show theory represented type theory framework 
defining set introduce primitive constant set give primitive constants constructors express different ways elements set constructed 
typing rule constant denoting set called formation rule set typing rules constructors called rules 
introduce selector implicitly defined constant express induction principle set selector defined pattern matching may recursive 
type rule selector called elimination rule defining equations called equality rules 
rules possible mechanically derive elimination rule equality rules set done investigated martin backhouse coquand paulin dybjer 
set boolean values martin type theory set boolean values example enumeration set 
values enumeration set exactly constructors set constructors yield different elements 
booleans means ways forming element constructors true false 
elements set equality introduce constant set type declaration bool set declare types constructor constants true bool false bool principal selector constant enumeration set function performs case analysis boolean values 
booleans introduce constant type bool set bool true false defining equations true false definitional equalities omitted types obtained immediately typing 
sequel write just type clear context 
empty set introduce empty set just define set constructors 
type declaration set set constructors immediately define selector case type declaration case set empty set corresponds absurd proposition selector corresponds natural deduction rule absurdity true prop true nordstr petersson smith set natural numbers order introduce set natural numbers give rules forming natural numbers rules forming equal natural numbers 
rules natural numbers 
ways forming natural numbers natural number natural number succ natural number 
corresponding ways forming equal natural numbers natural number equal natural number equal succ equal succ 
explained meaning natural numbers set type declaration set form rules natural numbers declaring types constructor constants succ succ general rules framework possible give rules simple form 
introduce general form selector natural numbers natrec defined constant 
expressing elements primitive recursion proving properties induction 
functional constant natrec takes arguments family sets determines set result belongs second third results zero successor case respectively fourth argument natural number principal argument selector 
formally type natrec natrec set succ defining equations natrec constant natrec natrec succ natrec selector natural numbers mentioned introducing ordinary primitive recursive functions 
addition multiplication example introduced defined constants defining equations martin type theory plus mult plus natrec succ mult natrec plus rules application type definitional equalities constant natrec easy derive type right hand side equalities equalities addition multiplication plus plus succ succ plus mult mult succ plus mult general primitive recursive function succ function introduce defined constant defining equation natrec functions type theory correspond definition type constant natrec represents usual elimination rule natural numbers set succ natrec obtained assuming arguments apply constant natrec 
note rule expression natrec contains family consequence explicit declaration natrec framework 
nordstr petersson smith set functions cartesian product family sets introduced type functions type type need corresponding set functions set set 
set family sets form cartesian product family sets denoted 
elements set functions applied element yield element 
elements set formed applying constructor sets object corresponding function type 
constant introduced type declaration constant set set set set set constant declarations correspond rules set set set set set notice elements cartesian product family sets general ordinary functions result applying element argument set may depend value argument 
important defined constant set constant application 
type theory selector takes arguments element object type sets 
constant introduced type declaration apply set set definitional equality apply cartesian product family sets viewed proposition universal quantification 
type constructor corresponds rule true true martin type theory type selector corresponds elimination rule true true cartesian product family sets generalization ordinary function set 
family sets elements cartesian product just set ordinary functions 
constant introduced explicit definition set set set functions viewed proposition implication type constructor rule implication true true true type selector elimination rule true true true empty set set function define constant negation way set set example 
see prove proposition order prove proposition find element set start making assumptions obtain element apply apply nordstr petersson smith example 
rules natural numbers booleans functions show define function eqn bool decides natural numbers equal 
want equalities hold eqn true eqn succ false eqn succ false eqn succ succ eqn impossible define eqn directly just natural numbers recursion arguments 
recursion arguments separately recursion argument compute function applied second argument gives result want 
define function bool satisfies equalities iszero succ natrec false apply iszero natrec true false recursion operator explicitly define natrec iszero natrec false apply function equal function gives true applied false define eqn follows simple exercise show eqn apply eqn bool satisfies equalities want satisfy 
propositional equality martin type theory equality judgement level definitional equality objects equal normal form 
order express example addition natural numbers commutative operation necessary introduce set propositional equality 
elements set id set 
express introducing constant id type id set set constructor elements equality sets id introduced type declaration id set id say id constructor id say id reflexive relation 
transitivity symmetry congruence proven definition 
name selector introduced type declaration equality set id set id id id intuition constant expresses substitution rule elements propositionally equal 
example 
type constructor set id corresponds reflexivity rule equality 
symmetry transitivity rules easily derived 
set elements assume id order prove symmetry construct element id 
applying id id get simple typechecking element set id 
id id id nordstr petersson smith derived rule symmetry expressed constant symm defined set id id id id transitivity proved similar way 
set elements assume id id applying id id identity function id id get element set id id 
element applied order get desired element id 
set id id id apply id id id id id id example 
see derive rule substitution set expressions 
want rule set id subst derive rule assume set elements furthermore assume id set 
type checking gives apply function obtain element 
define constant subst expresses substitution rule 
type subst subst set set id defining equation martin type theory subst apply set lists set lists list introduced similar way natural numbers parameter determines set elements list belongs 
constructors build list nil empty list cons add element list 
constants introduced far types list set set nil set list cons set list list selector listrec types constant expresses primitive recursion lists 
selector introduced type declaration listrec set list set nil list cons list defining equations listrec constant listrec nil listrec cons listrec disjoint union sets sets form disjoint union elements set form inl form inr order express framework introduce constants set set inl set inr set nordstr petersson smith selector introduced type declaration defined equations set set inl inr inl inr seen proposition disjoint union sets expresses disjunction 
constructors correspond rules true true true true selector corresponds elimination rule 
true prop true true true true true disjoint union family sets order able deal existential quantifier set ordinary pairs introduce disjoint union family sets 
set introduced type declaration set set set constructor set pair introduced type declaration pair set set selector set splits pair parts 
defined type declaration split set set set pair defining equation martin type theory split pair selector split easy define projection functions give second component pair 
fst set set fst split snd set set fst snd split fst viewed proposition disjoint union family sets corresponds existential quantifier 
types constructor pair correspond natural deduction rules existential quantifier true true true prop true true true set small sets set small sets universe set reflects part set structure object level 
course necessary introduce set wants computation sets example specify prove type checking algorithm correct necessary order prove inequalities succ 
furthermore universe defining families sets recursion example non empty lists sets introduce universe function maps element set element encodes 
universe introduce constructor set defined 
constants sets introduced type declaration set set nordstr petersson smith introduce constructors defining equations bool nu nu idu idu id list example 
see derive element set id succ words find expression set start assuming id succ id succ construct function iszero maps natural number element universe 
easy see iszero iszero natrec iszero bool iszero succ martin type theory true bool iszero subst true iszero succ element looking id succ subst true id succ shown smith universe negated equalities proved 
alf interactive editor type theory department computing science teborg developed interactive editor objects types type theory 
editor direct manipulation things built shown screen editing done pointing clicking screen 
proof object true representative proof 
process proving proposition represented process building proof object language type theory extended place holders written indexed question marks 
notation stands problem finding object object edited replacing placeholders expressions may contain placeholders 
possible delete subpart object replacing placeholder 
close connection individual steps proving steps build proof object making topdown proof proposition try reduce problem subproblems 
bn rule takes proofs 
bn proof continue proving 
bn 
instance reduce problem problems modus ponens 
way continue axioms assumptions left 
process corresponds exactly build mathematical object outside 
problem possible refine place holder ways placeholder replaced application constant variable 
case constant holds nordstr petersson smith type constant equal 
xn 
xn 
xn 
xn reduced problem subproblems 

xn refinements satisfy constraint 
xn number new placeholders computed arity constant expected arity placeholder 
example start function type apply constant type new term new placeholder type arguments type furthermore type equal equality hold kind constraints general simplified system 
editing step correct operation corresponds applying rule constructing proof 
rule reduces problem problem placeholder replaced abstraction 
holds equal function type type variable keep track fact may substituted expression may depend variable corresponds making new assumption constructing proof 
reduce general problem problem assumption assumed object construct solution may knowledge solution problem constructing solution problem placeholder replaced constant correct type equal placeholder replaced variable type equal replace placeholder variable correct type variable abstracted earlier 
martin type theory delete part proof object corresponds earlier steps proof 
notice deleted steps steps derivation moving pointer proof object possible undo preceeding steps altering effect steps 
deletion sub object non trivial operation may cause deletion parts depending 
proof engine machine representing ongoing proof process ongoing construction mathematical object parts theory list constant declarations scratch area 
objects built scratch area moved theory part completed 
basic operations manipulate scratch area 
insertion command replaces placeholder new possible incomplete object deletion command replaces sub object placeholder 
implementing type theory decide kind inductive definitions definitional equalities allow 
situation similar give syntactic restrictions guarantees meaningful definitions equalities allowed 
instance impose inductive definition strictly positive equality primitive recursive 
know restriction disallow meaningful definitions 
moment restrictions 
means correctness definition user responsibility 
examples developed alf mention proof ackermann function primitive recursive functional completeness combinatorial logic tait normalization proof del fundamental theorem arithmetic constructive version ramsey theorem semantical analysis simply typed lambda calculus explicit substitution 
augustsson coquand nordstr short description logical framework 
proceedings workshop logical frameworks antibes pages 
backhouse 
meaning construction rules martin theory types 
proceedings workshop general logic edinburgh 
laboratory foundations computer science university edinburgh february 
backhouse chisholm malcolm 
type theory 
formal aspects computing 
nordstr petersson smith bishop 
mathematics numerical language 
myhill editors intuitionism proof theory pages amsterdam 
north holland 
church 
formulation simple theory types 
journal symbolic logic 
constable implementing mathematics nuprl proof development system 
prentice hall englewood cliffs nj 
coquand 
semantics rules machine assisted analysis 
rger gurevich meinke editors csl pages 
springer verlag lncs 
coquand huet 
calculus constructions 
technical report inria centre de rocquencourt 
coquand paulin mohring 
inductively defined types 
proceedings workshop programming logic astad 
curry feys 
combinatory logic volume north holland 
de bruijn 
mathematical language automath usage extensions 
symposium automatic demonstration volume lecture notes mathematics pages versailles france 
springer verlag 
de bruijn 
survey project automath 
seldin hindley editors curry essays combinatory logic lambda calculus formalism pages new york 
academic press 
dowek felty herbelin huet murthy parent paulin mohring werner 
coq proof assistant user guide version 
technical report rapport technique inria december 
dybjer 
inductive families 
formal aspects computing pages 

ramsey theorem type theory 
licentiate thesis chalmers university technology university teborg sweden october 

formal proofs combinatorial completeness 
appear informal proceedings logical framework workshop astad june 
martin type theory smith 
machine checked normalization proofs typed combinator calculi 
proceeding logical framework workshop astad june 
del ber eine noch nicht des 
dialectica 
gordon milner wadsworth 
edinburgh lcf volume lecture notes computer science 
springer verlag 
harper honsell plotkin 
framework defining logics 
jacm 
heyting 
intuitionism 
north holland amsterdam 
howard 
formulae types notion construction 
seldin hindley editors curry essays combinatory logic lambda calculus formalism pages 
academic press london 
hudak report programming language haskell non strict purely functional language march 
version 
sigplan notices may 
van benthem jutting 
checking landau grundlagen automath system volume mathematical centre tracts 
mathematisch centrum amsterdam 
kolmogorov 
zur der logik 
zeitschrift 
luo pollack 
lego proof development system user manual 
technical report lfcs technical report ecs lfcs 
magnusson nordstr alf proof editor proof engine 
types proofs programs volume lncs pages nijmegen 
springer verlag 
martin theory types 
technical report university stockholm 
martin intuitionistic theory iterated inductive definitions 
fenstad editor proceedings second scandinavian logic symposium pages 
north holland publishing 
nordstr petersson smith martin constructive mathematics computer programming 
logic methodology philosophy science vi pages 
north holland 
martin intuitionistic type theory 
bibliopolis napoli 
milner tofte harper 
definition standard ml 
mit press 
nordstr petersson smith 
programming martin type theory 

oxford university press 
paulson 
logic computation 
cambridge university press 
petersson 
programming system type theory 
pmg report chalmers university technology teborg 
prawitz 
natural deduction 
almquist wiksell stockholm 
smith 
independence peano fourth axiom martin type theory universes 
journal symbolic logic 

machine checked proof ackermann function primitive recursive 
licentiate thesis chalmers university technology university teborg sweden june 
huet plotkin editors logical frameworks cambridge university press 
tait 
infinitely long terms transfinite type 
formal systems recursive functions pages amsterdam 
north holland 
von 
machine assisted proof fundamental theorem arithmetic 
pmg report chalmers university technology june 
