safe kernel extensions run time checking george necula peter lee school computer science carnegie mellon university pittsburgh pennsylvania cs cmu edu describes mechanism operating system kernel determine certainty safe execute binary supplied untrusted source 
kernel defines safety policy public 
policy application provide binaries special form called proof carrying code simply pcc 
pcc binary contains addition native code formal proof code obeys safety policy 
kernel easily validate proof cryptography consulting external trusted entities 
validation succeeds code guaranteed respect safety policy relying run time checks 
main practical difficulty pcc generating safety proofs 
order gain preliminary experience written network packet filters hand tuned dec alpha assembly language generated pcc binaries special prototype assembler 
pcc binaries executed run time overhead time cost milliseconds validating enclosed proofs 
net result packet filters formally guaranteed safe faster packet filters created berkeley packet filters software fault isolation safe languages modula 
research sponsored part advanced research projects agency title fox project advanced languages systems software arpa order 
issued esc ens contract 

views contained document authors interpreted representing official policies expressed implied advanced research projects agency government 
appear second symposium operating systems design implementation osdi seattle washington october 
address problem operating system kernel server determine absolute certainty safe execute code supplied application untrusted source 
propose mechanism allows kernel server referred code consumer define safety policy verify policy respected native code binaries supplied untrusted code producer 
contrast previous approaches rely usual authentication code editing mechanisms 
require code producer creates binaries special form call proof carrying code simply pcc 
pcc binary contains encoding formal proof enclosed native code respects safety policy 
proof structured way easy foolproof agent particular code consumer verify validity cryptographic techniques consulting external trusted entities need program analysis code editing compilation interpretation 
safe pcc binaries extremely fast safety check needs conducted consumer knows safely execute binary run time checking 
pcc binary proof linked native code validity guarantees code safety 
furthermore proof carrying code consumer easily detect attempts malicious agent forge proof modify code 
tampering go undetected code guaranteed respect consumer defined safety policy 
feature pcc method proof checking algorithm simple allowing fast easy trust implementations 
safety policy defined published code consumer comprises set rules set preconditions 
safety policies defined stipulate standard requirements memory safety fine grained guarantees integrity data abstraction boundaries 
take simple example consider type file descriptors 
case client said preserve abstraction boundaries exploit fact file descriptors represented integers incrementing file descriptor example 
worked theoretical underpinnings pcc theory old known principles logic type theory formal verification difficult problems remain solved 
particular know point practical way generate proofs 
set gain preliminary experience measure benefits identify practical problems 
experiments reported fact achieved fully automatic proof generation 
general problem similar program verification completely automatable 
problem somewhat easier verification option inserting extra run time checks done software fault isolation effect simplifying proving process cost reducing performance 
extra mean run time checks intrinsically part algorithm extension code 
example sfi edit code insert extra checks pcc normally 
fortunately need desire insert extra run time checks pcc examples 
automation proof generation remains serious obstacles widespread practical application pcc 
main experiment implemented network packet filters dec alpha assembly language special prototype assembler create pcc binaries 
motivated unsafe assembly language order place equal emphasis performance safety demonstrate generality pcc approach 
addition assembler implemented proof validator accepts pcc binary checks safety proof valid loads enclosed native code sets execution 
results experiments encouraging 
collection packet filters able automate completely generation pcc binaries 
time cost loading checking validity safety proofs milliseconds 
safety proof guarantees safety hand tuned packet filters executed safely kernel address space adding run time checks 
predictably faster safe packet filters produced means familiar 
believe early results show code new point design space worthy attention study 
presents overview approach 
brief overview process generating validating safety proofs 
concrete showing safety policy defined proofs created generic assembly language 
followed description main experiment involving safe network packet filters 
benchmark results provide preliminary indication pcc methodology potential surpass traditional approaches safety point view maintaining improving performance 
particular show pcc leads faster safer packet filters previous approaches code safety systems software including berkeley packet filters software fault isolation programming safe subset modula :10.1.1.142.4909
conclude discussion remaining difficulties speculate necessary approach practical scale 
cpu code process untrusted client code kernel network server safety policy pcc enable validation source program compilation code safety binary native certification proof proof overview proof carrying code 
proof carrying code depicts process generating pcc binary 
process begins code consumer defining safety policy 
policy defines formally meant safety specifies interface consumer binary provided producer 
policy account code producer compiles assembles proves safety source program process call certification 
results pcc binary delivered code consumer 
receipt consumer validates safety proof enclosed pcc binary 
proof valid code consumer safely execute native code part pcc binary 
subsections describe phases detail 
process concepts logic semantics type theory rest section necessarily somewhat technical details scope 
attempt explain basic technicalities key intuitions 
readers details underlying theory find separate technical report 
impatient reader may want skip ahead section show case network packet filters proof carrying code surpasses previous approaches safety performance 
defining safety policy order business define precisely constitutes safe code behavior 
specifying safety policy parts 
floyd style verification condition generator referred vc generator procedure computes predicate order logic code certified 
refer predicate safety predicate 

set axioms validate safety predicate 

precondition essentially calling convention defines code consumer invoke pcc binaries 
job designer code consumer operating system designer define safety policy 
practice different safety policies tailored needs specific tasks services 
obtain vc generator specifying machine called operational semantics simulates execution safe programs 
machine strictly required simplifies design safety policy provides basis proving soundness approach 
order concrete example machine specifies general form memory safety dec alpha processor show safety policy simple resource access service defined precondition 
vc generator axioms subsection 
machine memory safe dec alpha machine code experiments dec alpha assembly language machine essentially high level formal description alpha architecture 
see done consider subset alpha instruction set shown 
larger subset dec alpha assembly language experiments smaller subset suffice presentation purposes 
table denotes integer constant ri refers machine register instructions operate bit values 
simplicity allow temporary machine registers purpose presentation rename 
consequence programs write reserved callee save registers standard calling convention dec alpha architecture trivially safe respect registers 
define programs executed define machine state transition function essential core shown 
specification dec alpha program vector instructions pi current instruction pi pc pc program counter 
variable ae denotes state machine registers memory 
state transition function maps machine state ae pc new state ae pc executing current instruction pi pc 
notation ae ri abbreviated ri refers value register ri state ae expres valid register values positive integers range gamma 
constraint expressed formally equation ri mod ri applied register val op ri addq subq sll srl br beq bne blt instr ldq rd rs stq rs rd rs op rd br rs ret subset dec alpha assembly language 
sion ae rd rd phi denotes new state obtained state ae incrementing value register rd example alpha addq rs op rd instruction defined semantics ae rd rs phi op pc ae current register memory state 
specification states addq instruction updates register rd sum rs op increments program counter 
circled operation phi denote complement addition bits 
operation defined terms usual integer arithmetic operations phi mod model state memory pseudo register called rm gives content memory location 
write sel rm contents memory address upd rm rs new memory state resulted writing register rs address memory operations bits addresses involved aligned byte boundary 
definition load store instructions crucial difference dec alpha processor machine 
difference machine performs safety checks shown boxes 
example consider definition ldq rd rs instruction ae rd sel rm rs phi pc rd rs phi predicate rd true safe read word memory address dec alpha implies aligned byte boundary 
similarly predicate wr true address denotes aligned location safely read written 
essence checks define meant safety specifically example memory safety 
purpose predicates rd wr defined safety policy precondition shown subsection 
ues 
negative values represented complement representation 
mathematically machine return errors rd wr check fails 
execution blocks transition rules covering error cases 
setting program safe runs blocking machine 
course presence safety checks means machine faithful abstraction dec alpha processor 
purpose certification prove safety checks succeed 
valid safety proof program know safely execute real dec alpha get behavior machine alpha implement safety checks 
notable differences machine real dec alpha 
example simplify presentation restricted branches forward 
allowing backward branches loops introduces number complications handled conceptually straightforward manner addition explicit loop invariants 
turns packet filter examples experiments loops inconvenient eliminate 
section briefly describe experiments looping programs including safe ip header checksum routine 
interesting aspect machine level abstraction specification 
try ambitious complete specification dec alpha processor 
extremely complex probably difficult trust 
practical matter specific tasks ones considering details features alpha irrelevant 
justifies working higher level abstraction details pipeline cache timing interrupt behavior 
consider encoding kinds safety checks machine 
sake simplicity specified notion fine grained memory safety 
ingenuity machine designer define safety policies involving kinds safety control resource usage preservation data abstraction ae pc 
ae rd rs phi op pc pi pc addq rs op rd ae rd sel rm rs phi pc pi pc ldq rd rs rd rs phi ae rm upd rm rd phi rs pc pi pc stq rs rd wr rd phi ae pc pi pc beq rs rs ae pc pi pc beq rs rs machine 

rd rs phi op pi pc addq rs op rd rd rs phi rd sel rm rs phi pi pc ldq rd rs wr rd phi rm upd rm rd phi rs pi pc stq rs rd rs rs pi pc beq rs post pi pc ret verification condition generator 
boundaries 
safety policy defined application writers free create pcc binaries guarantee safety 
sample application precondition machine describes safety terms notions readable writable memory locations 
useful code consumer specify interface pcc binaries identifies readable writable memory locations 
specifying precondition predicate order logic code consumer guarantees valid pcc binary invoked 
consider simple example 
suppose operating system kernel maintains internal table data pertaining various user processes 
table entry consists consecutive memory words tag data word 
tag describes data word user writable 
kernel provides resource access service user processes permission access table entry installing native code kernel 
possible kernel invokes user installed code address table entry corresponding parent process machine register 
address guaranteed kernel valid aligned byte boundary 
example somewhat contrived imagine entries table represent capabilities file descriptors provide user installed code full access correct table entries maintaining integrity rest table parts kernel state 
informally safety policy resource access service requires user code access table entries pointed tag read data word read tag value non zero code modify reserved registers 
condition ensures kernel safely invoke user code normal function call 
formally kernel specifies precondition states safe read tag pointed safe write data offset contents tag 
formal notation written follows mod rd rd phi sel rm wr phi remains prove particular client resource access service rd wr checks succeed precondition machine 
general specify postcondition part safety policy require particular invariants valid user code terminates 
conceptually example postcondition predicate true meaning additional conditions imposed final machine state 
moving discussion proof generation process note safety policy described thought enforcing fine grained memory protection 
general imagine having involved safety requirements 
example change tag word table entry semaphore user code acquire atomically test set zero trying write data word furthermore require simple postcondition code releases semaphore returning 
purposes current presentation stick simpler memory safety requirements 
certifying safety programs create safety proofs program prove executing violate safety checks postcondition satisfied 
standard techniques exist building proofs 
technique floyd verification conditions powerful deal unstructured assembly language programs broad range safety invariants 
similar techniques verify assembly language programs 
certification programs involves steps 
compute safety predicate program 
essentially encodes semantic meaning program logical form constitutes formal statement program executed violate safety checks 

generate proof safety predicate written checkable form 
steps described subsections 
computing safety predicate compute safety predicate generate vector vc predicates instruction specified rules 
notation denotes predicate current instruction 
rules specify terms verification condition vc program computed starting program working back simple approach works branches restricted forward 
discuss happens presence loops 
rules derived straightforward manner machine specification fact imagine experienced kernel safety policy designers skip machine specification give vc generator rules 
notation rd rs phi op stands predicate obtained substituting rs phi op rd computing vector vc safety predicate computed simply plugging program pi precondition pre postcondition post formula sp pi pre post rm pre vc intuition valid safety predicate initial state satisfies precondition pre code pi starting instruction executes failure terminates final state satisfies postcondition post 
address tag addq address data ldq data ldq tag addq increment data beq skip tag stq write back ret done dec alpha assembly code resource access 
initially register holds address tag 
data offset 
concrete example client code resource access service consider small program 
effect program increment data word writable 
compute vc program rules compute safety predicate spr formula precondition postcondition true 
trivial simplifications resulting safety predicate spr rm rd phi rd phi psi sel rm phi psi true sel rm phi psi wr phi informally spr predicate says values register states memory rm satisfying precondition memory locations phi phi psi readable tag address phi psi non zero data address phi writable 
conditions true code safe respect resource access safety policy 
proving safety predicate intentionally written program slightly complicated way show lowlevel optimizations pose significant problems generating validating safety proofs 
interesting properties program instructions somewhat scheduled including speculative execution load line addition line accommodate dec alpha pipeline latency register reused line hold data word tag address precondition expressed function value register actual memory accesses done register 
general expect scheduling register allocation effect safety predicate proof 
simple exercise reader familiar assembly language programming verify code correct respect safety policy 
problem course convince suspicious kernel code absolutely safe 
prove safety predicate rules order predicate calculus extended complement integer arithmetic 
refer set proof rules sigma write sigma sp safety predicate sp proved rules set sigma rules sigma simple 
show rules classical implication elimination rule predicate calculus second rule arithmetic sigma sigma sigma sigma phi psi sigma mod second rule bit surprising gamma unconditionally true integer arithmetic 
machine implementation arithmetic statement true original value valid register value 
large fragment proof safety predicate example program shown form 
proof generated automatically pcc system incorporates simple theorem prover 
vertical dots stand extractions conjunct precondition 
read proof tree top bottom interpreting node valid inference predicate line assumptions line 
example upper right corner predicate phi psi operations speculative required branch line taken 
proved arithmetic rule discussed assumption mod extracted precondition 
wr phi proved implication elimination rule hypothesis predicate sel rm phi psi 
hypothesis introduced lower level proof tree node labeled purpose proving predicate sel rm phi psi wr phi 
guarantee safety proof safety predicate written appropriate language described section proof code obeys safety policy 
justified formally safety theorem stated theorem safety program pi precondition re postcondition ost sigma sp pi re ost initial state ae satisfies precondition machine state ae pc originating initial state ae true 
state ae pc final state pi pc ret satisfying postcondition ost 
execution stuck exists new state ae pc ae pc 
ae pc 
machine gets stuck violation rd wr safety check theorem provides absolute guarantee certified program violations long execution started state satisfies precondition 
proof safety theorem scope separate technical report 
validating safety proofs pcc binary consists assembled native code encoding proof safety predicate 
validate binary code consumer extracts native code computes safety predicate vc rules 
checks safety proof valid proof safety predicate 
method ensures safety native code proof pcc binary tampered 
code modified likelihood safety predicate changes proof correspond 
proof modified invalid correspond safety predicate 
code modified 
mod 
sel rm phi psi phi psi mod sel rm wr phi sel rm rd phi psi wr phi rd phi psi sel rm phi psi wr phi rd phi psi sel rm phi psi wr phi pre rd phi psi sel rm phi psi wr phi rm rd phi psi sel rm phi psi wr phi fragment formal safety proof sp way safety predicate unchanged example instruction scheduling register allocation typical circumstances code proof modified valid proof new safety predicate validation succeeds continue retain guarantee safety 
automate validation process choose concrete representation language predicates proofs 
available choices selected edinburgh logical framework called lf representation framework predicates proofs 
lf extension simply typed lambda calculus designed meta language high level specification languages logic computer science 
attractive property lf powerful simple typechecking algorithm check validity proofs 
represent predicates proofs lf way validity proof implied typedness proof representation 
proof validation amounts typechecking 
lf allows represent elegant way key issues logical proof correctness manipulation logical parameters assumptions 
scope discuss detail lf typechecking algorithm worth mentioning typechecking decidable described simple rules 
typechecking simple programmers trust publicly available implementation implement easily 
implementation pages code incorporates optimizations basic algorithm 
implementation takes milliseconds validate proof spr predicate 
flexibility allow easy exchange proofs system components designed binary encoding lf representations 
typical pcc binary contains section native code ready mapped memory executed followed symbol table reconstruct lf representation code consumer site binary encoding lf representation safety proof 
component safety proof 
shows sizes sections pcc binary corresponding resource access example 
section native code section relocation proof section layout pcc binary resource access example 
offsets bytes 
currently pcc binaries standard packet filters including native code safety proof relocation section bytes size proof times larger code 
size relocation section increases linearly number distinct proof rules proof 
case packet filter safety proofs relocation section third binary expect ratio smaller larger proofs 
considerable amount design latitude encodings proofs barely scratched surface done reduce size binaries time required validation 
relatively little effort achieved acceptably small binaries low validation times 
application network packet filters order gain experience pcc compare approaches code safety performed series experiments safe network packet filters 
describe section particulars pcc approach network packet filters 
section compare approaches including interpreted packet filters exemplified bsd packet filter code editing software fault isolation safe programming language approach taken spin kernel 
packet filter application provided subroutine scans incoming network packet decides user application interested receiving 
packet filters supported today workstation operating systems 
packet filters successfully network monitoring diagnosis 
pcc approach packet filter pcc binary native code component invoked kernel incoming network packet 
kernel safety ensured validating safety proof 
procedure described section establish safety policy 
allow fair comparison follow bsd packet filter model safety 
packet filter code examine packet write statically allocated scratch memory 
informally safety policy requires memory reads restricted packet scratch memory memory writes limited scratch memory branches forward reserved callee saves registers modified 
rules establish memory safety termination assuming kernel calls packet filter valid packet scratch memory addresses 
write packet filter code assuming return value aligned address length packet filter respectively address byte aligned scratch memory 
packet length positive bytes minimum length ethernet packet 
formally expressed precondition re mod mod mod rd phi wr phi phi phi conjuncts precondition restrict values input registers valid machine word values 
term precondition rules possibility memory aliasing packets scratch memory 
useful reasoning filters write scratch memory 
postcondition packet filter experiment predicate true meaning additional conditions placed final state 
implemented typical packet filters assembly language certified safety respect packet filter safety policy 
filter accepts ip packets 
done comparing bit word packet value 
filter accepts ip packets originating network 
involves checking bit value addition done filter 
filter accepts ip arp packets exchanged networks 
includes done filter addition checking destination network address 
extra complexity required different header layout ip arp packets 
filter accepts tcp packets destination port 
filter check ethernet packet ip packet tcp packet lastly destination port matches value 
offset tcp destination port computed byte ip header length ip header 
effort involved hand coding packet filters assembly language increased performance packet filters usually small frequently executed 
hand coding provides opportunity perform optimizations difficult obtain optimizing compiler 
important point optimizations impediment generation validation safety proofs 
optimizations incorporated packet filters ffl number memory operations minimized dec alpha bit load fol byte extraction 
ffl tcp port number packet offset lambda denotes byte offset 
loading bits time little endian machine formula ae lambda :10.1.1.43.7639
simplification reduce ae exactly coded filter :10.1.1.43.7639
write packet filter prototype assembler produces safety predicate verification condition method section 
safety predicate proved theorem prover 
currently theorem prover admittedly toy 
gets stuck requires intervention programmer mainly learn new axioms arithmetic example know 
process easy user provided axioms remembered sessions system works automatically practical packet filters 
state art theorem proving technology expect able prove completely automatically arithmetic facts involved certifying packet filters 
primitive theorem prover generate safety proofs packet filters seconds cases user intervention required 
performance comparisons performance measurements done dec alpha mhz processor mbyte secondary cache mbyte main memory running osf 
measurements performed line packet trace busy ethernet network carnegie mellon university 
measured average packet run time pcc packet filters functionally equivalent filters implemented alternative approaches bsd packet filter architecture software fault isolation programming safe subset modula 
experiments modula packet filters view extension pointer safe casting 
result measurements shown 
packet latency point view pcc packet filters outperform filters developed considered approach 
pcc method startup cost significantly larger approaches 
cost proof validation time pcc filter filter filter filter bpf sfi view comparison average packet run time 
table pcc binary size filters maximum heap space validation 
maximum depth stack validation kbytes 
packet filter instructions binary size bytes validation time cost space kb table proof size validation cost pcc packet filters 
despite relatively high validation cost run time benefits pcc packet filters large amortize startup cost processing reasonable number packets 
shows running time including startup cost function number packets processed filter 
particular case cost proof validation amortized packets compared bpf version filter packets compared modula version packets compared sfi packet filter 
note time collected packet trace experiments counted ethernet packets second average 
proceed describe detail considered approach focusing relates pcc safety point view set performance measurements 
standard way ensure safe execution packet filters interpret filter perform extensive run time checks 
approach best exemplified bsd packet filter architecture ms thousands packets view startup cost amortization filter 
commonly referred bpf 
bpf approach filter encoded restricted language 
bpf semantics filter attempts read outside packet scratch memory write outside scratch memory terminated packet rejected 
bpf interpreter simple static check packet filter code verify instruction codes valid branches forward code limits 
measured time overhead microseconds negligible 
bpf packet filters times slower pcc filters 
pcc approach checks moved validation stage allowing faster execution 
order collect data bpf packet filters extracted bpf interpreter implemented osf kernel compiled user library 
possible course eliminate need interpretation 
example replace packet filter interpreter compiler 
approach taken researchers 
problem startup cost complexity compilation especially serious optimizations performed 
approach safe code execution software fault isolation sfi :10.1.1.142.4909
sfi inexpensive method parsing binaries inserting run time checks memory operations 
flavors sfi depending desired level memory safety 
entire code runs single protection domain size power memory writes checked run time cost sfi relatively small 
hand untrusted code interacts frequently code consumer untrusted components residing different protection domains read operations checked overhead run time checks amount :10.1.1.142.4909
serious disadvantage sfi ensure memory safety 
believe level safety general important able check abstraction boundaries representation invariants shown resource access example section 
order accommodate sfi packet filters allowed concessions packet filter semantics 
example assumed kernel allocates packets byte boundary 
furthermore assume filter safely access entire segment bytes independently packet size 
note bpf packet filter semantics followed experiments specifies filter terminated tries access packet boundary 
means working packet filters bpf semantics behave expected sfi semantics packet filters vice versa 
common way performing sfi code producer site usually part code generation phase compiler 
case code consumer performs load time checking sfi done correctly 
load time sfi validator reportedly simple deal binaries run time checks inserted potentially dangerous memory operation :10.1.1.142.4909
hand case validator accept binaries number run time checks optimized program analysis validator redo analysis led optimization 
means complex slower validation fact sfi validator presently exist 
inserted run time checks memory operations assembly language packet filters implemented pcc experiment 
process done simple easy trust implementation sfi 
experiments pcc packet filters run faster sfi filters 
part sfi experiment produced safety proofs resulting sfi packet filter binaries safe respect packet filter safety policy 
achieve effect sfi load time validator universal typechecking algorithm application dependent proof rules 
precondition experiment says safe read aligned address byte segment packet start address 
proof sizes validation times similar plain pcc packets 
approach safe code typesafe programming language 
approach taken spin extensible operating system language modula extended pointer safe casting view 
spin allows applications install extensions kernel written safe subset modula 
extensions compiled trusted compiler resulting executable code believed safe modula model safety 
note extensions written modula intrinsically safe believes safety modula check compliance modula syntactic typing rules 
believe encoding kernel extensions pcc binaries modula source code provide important benefits 
benefit increased flexibility extension writers native code extension accepted independent original source language compiler long valid safety proof accompanies 
potential benefit overcoming limitations modula safety model pcc safety proof able express properties disciplined locks array bounds compliance need run time checks 
wrote packet filters safe subset modula compiled version dec src compiler extended view operation 
view safely cast packet filter array aligned bit words allowing fewer memory operation accessing packet fields 
contrast plain modula packet fields loaded byte time safety bounds check performed operation 
compiler tries eliminate checks statically successful packet filters 
main reason critical piece information fact packets bytes long communicated compiler modula type system 
measured improvement modula packet filter performance view 
similar performance improvements dec src modula compiler reported vortex compiler 
conducted experiments vortex compiler packet filters clear kind improvements realize practice 
alternate implementation untrusted code certification modula source code compiled trusted secure compiler signs executable 
validation means cryptographic signature checking pcc approach run time cost associated 
complete implementation cryptographic validation know exactly large startup cost digital signature approach 
implementation digital signatures achieve faster validation significantly faster generation certificates 
essential drawback cryptographic techniques pcc validation establishes trusted origin code absolute safety relative safety policy 
particular digital signature ascribed unsafe program just easily safe 
cost managing transmitting encryption keys incurred pcc 
mention approach safe code execution actual quantitative comparison 
java virtual machine proposed solution safe interaction distributed untrusted agents 
mobile code encoded java virtual machine language referred java bytecode basically safe low level imperative language 
safety achieved combination static typechecking run time checking 
java bytecode safety model relatively limited result limitations type system 
example java bytecode type information encoded instruction codes express basic types integers objects provisions expressing safety policies resource access example section 
invariants involving array bounds compliance expressed java bytecode type system checked run time 
java bytecode low level language requires substantial processing executed general purpose processor 
contrast pcc safety proof program code allowing code portion encoded variety languages including native code safety loss 
practical problems order create safety proof code producer prove predicate order logic 
general problem undecidable 
mentioned section code producer resort extra run time checks inserted strategic locations tendency simplify certification 
fortunately packet filter experiments certification process nearly automatic forced insert extra run time checks code 
fact find safety predicates packet filters fairly easy handled existing theorem proving technology 
simplifications packet filters restrict programs contain loops 
general framework easily extended accommodate loops introduces number complications 
experiment conducted involves ip header checksum routine hand coded dec alpha instructions 
core loop contains instructions optimized computing bit ip checksum bit additions followed folding operation 
resulting pcc binary routine expected quite fast beating standard version osf kernel factor 
pcc binary bytes size proof validation takes milliseconds 
experiment brought light complications 
example standard approach verifying loops floyd style verification conditions involves introducing loop invariants explicitly challenge theorem proving technology requires user intervention 
fact general assembly language programs represents important problem solved main obstacle automating generation proofs 
capabilities system forced write invariants hand 
means native code accompanied loop invariant loop 
pcc binary contains mapping loop invariant 
convention pcc binary contain table maps backward branch target loop invariant 
problem generate proofs matter size 
principle proofs exponentially large size program 
problem examples tried far 
blowup tend occur programs contain long sequences conditionals intervening loops 
seen problem serious way programs tend hard humans understand writing programs hand 
general matter size pcc binaries issue addressed carefully 
implemented optimizations representation proofs possible 
ultimately need practical experience know serious obstacle pcc practice 
programs loops loop invariants break program cycles set acyclic code fragments 
treat code fragment separate program invariants preconditions 
beneficial effect partitioning safety predicate proof smaller pieces tends reduce size proof dramatically 
reason sections programs contain loops may beneficial introduce invariants way controlling growth pcc binaries 
addition developing better certification technology see interesting directions research 
possibility intend explore application pcc dynamic properties resource usage guarantees 
example certify specific synchronization locks released prior action 
framework expressive define safety policies remains try experiments 
possibility allow consumer producer negotiate safety policy run time 
allowing producer send encoding proposed safety policy including vc generation rules proof rules preconditions consumer 
consumer determines proposed policy implies basic notion safety allow producer produce pcc binaries new policy 
useful distributed systems agent wants define language transmit agents code written language 
believe advantages starting safe programming language implementing certifying compiler produces pcc binaries target programs 
safety properties implied source language construction proofs principle matter having compiler prove correctness translation target code 
experimented toy compiler sort small type safe programming language hope expand near 
described proof carrying code mechanism allows kernel server interact safely binaries supplied untrusted source 
pcc incur run time overhead kernel 
stead code producer required generate formal proof code obeys safety policy 
kernel easily check proofs validity absolutely certain code respects safety policy 
furthermore pcc binaries completely tamper proof attempt alter native code safety proof pcc binary detected harmless 
experiments network packet filters show pcc lead significant performance advantages existing approaches safe code including code editing techniques software fault isolation 
proof carrying code potential free system designer relying run time checking sole means ensuring safety 
traditionally system designers viewed safety simply terms memory protection achieved expensive run time mechanisms hardware enforced memory protection extensive run time checking data 
limited memory protection run time checking designer impose substantial restrictions structure implementation entire system example requiring restricted interaction model fixed system call application program interface 
proof carrying code hand allows safety policy defined kernel designer certified application 
provide greater flexibility designers system applications allows safety policies finegrained memory protection 
believe potential lead great improvements robustness performance systems 
final thoughts inspiration proof carrying code comes realm static type systems especially embodied language standard ml sml 
formal definition sml formal theorem guarantees safety type correct sml program rigorously defined notion safety 
course type safe programming languages example modula java mathematical formalism sets sml apart languages practical matter rigor provides basic conceptual technical foundations need create checkable proofs 
type safe languages sml mind get intuitive idea proof carrying code works 
consider compiler sml 
agent writes sml program compiles target program 
throw away source program convince agent target program safe 
assuming agent trust agent 
way compiler prove target code correctly corresponds source code turns type theory sml proof written formally fact written typed language property typed proof guaranteed valid 
proof carrying code application ideas programming language theory case defining notions safety useful operating systems flexible accommodate high level low level languages 
growth interest highly distributed computing web computing extensible kernels clear ideas programming languages destined increasingly critical robust performing systems 
robert harper brian noble daniel jackson greg morrisett scott draves chris colby martin abadi dave detlefs reading previous versions suggesting improvements 
charles garrett brian bershad wilson hsieh suggesting improvements methodology modula performance measurements 
anonymous reviewers suggestions improving 
particular shepherd jay lepreau suggested pcc name 
bershad savage pardyak sirer becker fiuczynski chambers eggers extensibility safety performance spin operating system 
symposium operating system principles dec pp 

essentially having compiler translate types code target program types checked 
fact approach compiling taken sml til compiler 
boyer yu automated proofs object code widely microprocessor 
acm jan 
carr verification low level code 
ieee software engineering journal may 
constable allen bromley cleaveland cremer harper howe knoblock mendler panangaden sasaki smith implementing mathematics nuprl proof development system 
prentice hall 
dijkstra guarded commands formal derivation programs 
communications acm 
floyd assigning meanings programs 
mathematical aspects computer science schwartz ed 
american mathematical society pp 

harper honsell plotkin framework defining logics 
journal association computing machinery jan 
hoare axiomatic basis computer programming :10.1.1.43.7639
communications acm 
hsieh fiuczynski garrett savage becker bershad language support extensible operating systems 
workshop compiler support systems software feb pp 

lee leone optimizing ml run time code generation 
pldi conference programming language design implementation may pp 

martin theory types 
technical report department mathematics university stockholm 
mccanne berkeley packet filter man page 
bpf distribution available ftp ftp ee lbl gov may 
mccanne jacobson bsd packet filter new architecture user level packet capture 
winter usenix conference jan usenix association pp 

milner tofte harper definition standard ml 
mit press cambridge massachusetts 
mogul rashid accetta packet filter efficient mechanism user level network code 
acm symposium operating systems principles nov acm press pp 

updated version available dec wrl research report 
necula lee proof carrying code 
technical report cmu cs computer science department carnegie mellon university sept 
appeared fox memorandum cmu cs fox 
nelson systems programming modula 
prentice hall 
sirer savage pardyak defouw bershad writing operating system modula 
workshop compiler support systems software feb pp 

sites alpha architecture manual 
digital press 
sun microsystems 
java language specification 
available ftp ftp javasoft com docs ps zip 
sun microsystems 
java virtual machine specification 
available ftp ftp javasoft com docs ps zip 
tarditi morrisett cheng stone harper lee til type directed optimizing compiler ml 
pldi conference programming language design implementation may pp 

wahbe lucco anderson graham efficient software fault isolation :10.1.1.142.4909
th acm symposium operating systems principles dec acm pp 

wallach engler kaashoek applicationspecific handlers high performance messaging 
acm sigcomm oct vol 
acm 

