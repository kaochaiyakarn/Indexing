shared memory mutual exclusion ma jor research trends james anderson yong jik kim department computer science university north carolina chapel hill ted herman department computer science university iowa june revised may september january michel raynal published comprehensive survey algorithms mutual exclusion 
survey major research trends shared memory mutual exclusion 
keywords adaptive mutual exclusion fast mutual exclusion group mutual exclusion exclusion local spinning nonatomic algorithms shared memory systems time complexity timing algorithms mutual exclusion algorithms resolve conflicting accesses shared resources concurrent pro cesses 
problem designing algorithm widely regarded classic problems concurrent programming 
mutual exclusion problem process accesses resource executing critical section code 
activities involving resource occur corresponding noncritical section 
executing critical section process executes code frag ments called entry exit sections respectively 
process may halt noncritical section critical section 
furthermore variables program counters accessed entry exit section may accessed critical noncritical section 
objective minimum design entry exit sections requirements hold exclusion process executes critical section time 
livelock freedom process entry section process eventually executes section 
livelock freedom replaced stronger property 
starvation freedom process entry section process eventually executes section 
variant livelock freedom starvation freedom require process eventually enters noncritical section 
property holds trivially algorithms 
survey research mutual exclusion algorithms shared memory systems 
forthe part consider user level algorithms rely operating system services 
supported nsf ccr ccr ccr itr ccr 
authors term deadlock freedom denote progress property termed livelock freedom 
prefer term deadlock freedom inconsistently literature safety property progress property 
authors prefer lockout freedom starvation freedom 
algorithms studied years 
process algorithm published 
dijkstra algorithm earlier process algorithm dekker starvation free 
related algorithm published knuth starvation 
years publication knuth algorithms great algorithms proposed 
algorithms described survey topic michel raynal 
supplement raynal survey shared memory algorithms considering research conducted publication 
raynal book discusses message considered 
taken surveys provide readers comprehensive overview entire history date shared memory mutual exclusion algorithms 
assessing research shared memory mutual exclusion seventeen years evident 
important local spin algorithms 
early shared memory algorithms employ somewhat complicated busy waiting loops shared variables read 
fact shared memory algorithms covered raynal book designed way 
contention busy waiting loops generate excessive traffic processors memory network resulting poor performance 
local spin mutual exclusion algorithms problem avoided requiring busy waiting loops read loops variables cached accessed 
section survey local spin algorithms 
major research trend originated publication novel mutual exclusion algorithm requires memory accesses absence contention 
driven widely accepted belief contention critical section rare designed systems years algorithms process executes constant time fast path absence contention come known simply fast mutual exclusion algorithms 
section overview research algorithms 
years fast mutual exclusion algorithms evolved broader study adaptive algorithms 
fast algorithms sudden jump time complexity contention free contention cases 
adaptive algorithm rise time complexity contention gradual 
research algorithms surveyed section 
systems degree synchrony maintained reasonable assume bound time required execute statement 
number interesting timing mutual exclusion algorithms devised years bounds exploited reduce overhead 
algorithms section 
early mutual exclusion problem lamport noted circularity inherent require accesses shared memory atomic 
algorithm correct memory accesses nonatomic 
publication raynal book numberof papers published nonatomic algorithms 
section papers reviewed 
overriding theme described reducing time complexity 
spin algorithms time complexity measured counting memory accesses cause interconnection network traffic 
fast mutual exclusion algorithms time complexity absence contention isthe primary concern 
adaptive algorithms goal minimize time complexity function contention 
timing algorithms notions synchrony exploited reduce 
emphasis time surprising researchers began investigate fundamental limits time complexity lower bounds 
related interest space complexity bounds 
research lower bounds constitutes major research trend considered discussed section 
survey reflect biases authors exception 
say shared memory mutual exclusion algorithms conducted seventeen years fits categories noted incorrect 
fit briefly considered insection 
concludes section 
preliminaries presenting algorithms define execution model describe notational rest 
concurrent program consists set processes set variables 
process sequential program consisting labeled statements 
refer operations 
variable concurrent program private shared 
private variable defined scope single process shared variable defined globally accessed process 
code listings private variables shared variables capitalized 
distinguish private variables different processes notation refer private variable process concurrent program special private variable called program counter statement label process may executed value program counter equals program semantics defined set fair histories 
definition fair history isgiven formalizes requirement statement program subject weak fairness 
giving definition fair history introduce number concepts definitions concurrent program 
state assignment values variables program 
states designated states 
state reached state execution statement say state write statement enabled state say disabled history sequence 
initial state 
history may finite infinite case required statement enabled state history 
say history satisfies weak fairness simply fair finite infinite statement infinitely states history infinitely executed history 
note fairness requirement implies continuously enabled statement eventually executed 
algorithm specified concurrent program processes structure 
true section entry section critical section exit conditions imposed code sections described earlier section 
exclusion required hold history livelock freedom starvation freedom properties required hold fair histories 
specified assume solution problem required starvation free 
regard complexity assess space complexity counting words memory bits 
different time complexity measures introduced needed 
algorithms consider employ read modify write synchronization primitives 
prim execute atomically cause single state transition 
primitives consider include fetch fetch dec atomic add fetch store compare swap 
primitives de fined 
definitions var denotes shared variable val old new input output parameters 
definitions var old new assumed type consistent 
fetch var integer returns var var var return old fetch dec var integer returns var var var return old atomic add var integer val integer constant var var val fetch store var new returns typeof var old var var new return old compare swap var old new returns boolean var old var new return true return local spin algorithms local spin mutual exclusion algorithms busy waiting means read loops spin variables repeatedly tested 
spin variables locally accessible accessed causing message traffic processors memory interconnection network 
archi paradigms considered literature allow shared variables locally accessed distributed shared memory dsm machines cache coherent cc machines 
illustrated fig ure 
dsm machine processor memory module accessed accessing global interconnection network 
machine shared variable locally storing local memory module 
cc machine processor private cache hardware protocol enforce cache consistency ensure copies different local caches consistent 
machine shared variable locally accessible migrating local cache line 
consider dsm machine caches kept cc machine 
local spin algorithms consider assume unique process executing algorithm processor assume processes migrate 
local spin algorithms dsm machines process dedicated spin variables stored local memory module 
contrast algorithms cc machines processes may share spin variables process read different cached copy 
dedicated spin required dsm machines generally difficult design correct local spin algorithms dsm machines cc machines 
virtually modern multiprocessor cache coherent non cache coherent dsm systems embedded applications cheaper computing technology due cost limitations 
dsm model relevance reasons interest 
time complexity measures considered certain statement executions 
local spin algorithms usually rmr remote memory time complexity measure name suggests remote memory cause interconnect traversal measure 
assess rmr time complexity algorithm counting total number remote memory required process enter exit critical section algorithm may different rmr time complexities cc dsm models notion remote memory differs models 
cc model assume variable cached remains cached updated invalidated result modified process different processor 
effectively assuming idealized cache size cached variable may updated invalidated replaced variable associativity capacity limitations 
time complexity measures simply involve counting certain statement executions convention preceding term time complexity adjective identifies statement executions counted 
rmr time complexity measure remote memory counted 
mm interconnect interconnect 
dsm model 
cc model 
denotes processor cache module 
local spin algorithms queue lock algorithms read modify write primitives enqueue blocked processes spin queue 
algorithms process enqueues read modify write primitive update shared tail pointer process queue indicated primitive return value 
process spin queue waits necessary released predecessor 
section queue lock algorithms detail brief overview related algorithms 
algorithms covered detail vary synchronization primitives spinning local dsm systems 
constant number remote memory required critical section execution provided spinning local 
yang anderson called question necessity strong synchronization primitives pre senting algorithm comparable performance uses read write operations 
terms rmr time complexity algorithm somewhat inferior queue locks mentioned requires theta log remote memory critical section execution 
algorithm related algorithms described section 
algorithms read modify write primitives considering queue lock algorithms anderson graunke spin queue stored shared array 
algorithms rmr cc model unbounded rmr time complexity dsm model 
third algorithm consider spin queue stored shared linked list 
algorithm mellor crummey scott rmr time complexity cc dsm models 
algorithm ta 
anderson algorithm denoted algorithm ta shown 
figures statement await boolean expression shorthand waiting loop null od algorithm ta uses fetch atomic add fetch primitive takes value add input place atomic add case return value fetch ignored 
spin queue defined array slots 
indexed 
free slot tail queue indicated slot 
process enqueues spin queue simply fetch increment slot line 
addition updating slot fetch operation returns slot stored private variable place 
main complication dealt process increments slot slot 
case process slot find place line execute atomic add operation const lock wait shared variable slots array lock wait slot integer initially initially slots lock slots wait process private variable place integer true noncritical section place fetch slot place atomic add slot fi place place mod await slot place lock spin slots place wait critical section slot place mod lock od algorithm ta array queue lock fetch atomic add 
line correct value slot 
note slot may incremented processes correcting step performed 
process enqueued blocked finishes critical section 
line ensures value 

value slot ranges lock wait 
process entry section waits slot value lock line 
successor process spin queue place mod successor exist granted lock executes line successor exists line ensures lock granted process performs fetch operation line 
initial conditions ensure 
line executed slot 
rmr time complexity algorithm ta clearly determined number remote mem ory generated line 
cc model line generates constant number remote memory 
see note read slots place creates cached copy 
place wait holds slots place remain cached updated process occurs predecessor spin queue executes line establishes slots place lock 
point additional read slots place causes waiting terminate 
dsm model algorithm ta unbounded rmr time complexity different processes spin different memory locations different times locations statically allocated spins local 
theorem 
theorem anderson mutual exclusion problem solved rmr time fetch cc model 
type record pointer boolean bit boolean stored word shared variable slots array boolean initially true tail initially slots false process private variable prev pointer boolean bit temp boolean true noncritical section prev bit fetch store tail slots slots await prev bit spin toggle critical section temp slots slots temp od algorithm gt array queue lock fetch store 
algorithm gt 
graunke algorithm denoted algorithm gt shown figures notation adr denotes contents memory location address adr var denotes address variable var 
previous algorithm algorithm gt queue lock 
case enqueue operation implemented fetch store 
array slots 
recall algorithm ta association slots processes isnot fixed ordering slots comprising queue waiting processes slot queue slot slot 
association slots processes ordering slots comprising queue varies dynamically 
particular slot defined boolean value owned unique process 
process enqueues appending slot queue 
shall see waiting process uses predecessor slot spin variable process predecessor queue waits updates slot owned different algorithm ta process uses slot obtains fetch operation 
algorithm gt shared variable tail addition slots array 
tail contains pointer slot spin queue second bit records boolean value stored slot pointed process owning slot entered section see explanation 
components packed single word accessed atomically single fetch store operation 
initial configuration situation process just finished executing critical section processes noncritical sections 
slots slot owned process entry section process threads storing slot information tail fetch store operation line 
fetch store operation returns slot information predecessor exists spin queue 
critical section waits value stored predecessor slot toggle line 
easy wait predecessor 
exit section simply toggles value slot lines 
example execution shown 
initially value tail slots false 
process performs fetch store operation obtains prev slots bit false 
note process wait 
value tail slots true corresponds process information 
process executes exit section process performs fetch store operation tail slots tail tail slots entry section 
gets bit true 
process executes prev slots toggles slots process process section 
gets prev slots bit false 
wait 
initially 
exit section 
example execution algorithm gt 
changes value tail slots true corresponds process slot information 
fromthe fetch store operation process obtains prev slots bit true 
critical section process wait process toggle value slots true false 
easy see rmr time complexity algorithm gt cc model 
dsm model algorithm gt unbounded rmr time complexity 
information stored slot predecessor spin queue 
information statically allocated spins local 
algorithm gt theorem 
theorem graunke mutual exclusion problem solved rmr fetch store cc model 
algorithm mcs 
final queue lock algorithm consider detail linked list mellor crummey scott 
algorithm denoted algorithm mcs shown shorthand pointer record component 
algorithm mcs employs fetch store compare swap 
entry linked list called qnode process dedicated qnode whichis assumed stored locally algorithm implemented dsm machine 
qnode process components pointer successor spin queue boolean spin location 
shared variable tail points qnode queue 
tail nil 
type qnode record pointer qnode locked boolean stored word shared variable nodes array qnode nodes stored locally process tail pointer qnode initially nil process private constant node nodes private variable pred pointer qnode true noncritical section node nil pred fetch store tail node pred nil node locked true pred node await node locked spin granted lock predecessor fi critical section node nil compare swap tail node nil false await node nil spin field updated node locked false fi node locked false fi od algorithm mcs list queue lock fetch store compare swap 
process threads spin queue performing fetch store operation 
fetch store causes tail point qnode returns previous value 
threads nonempty spin queue previous value gives predecessor 
case initializes spin location line updates pointer predecessor line busy waits released predecessor line 
exit section release successor spin queue subsequent processes queue exist 
node nil holds executes line easily update successor location line 
node nil holds potential problem arises 
inparticular may case successor may case successor process updated field 
ambiguity resolved compare swap performed line 
successor tail point qnode compare swap returns true 
hand successor compare false executes lines 
line causes wait pointer updated successor 
mutual exclusion algorithms literature process may wait exit section 
line updates successor spin location 
depicts example execution 
initially tail nil 
process initializes qnode fetch store operation line 
point tail points process qnode 
note tail equaled nil prior process fetch store process wait entry section 
inthe third inset process initialized qnode performed fetch store tail 
note qnode qnode qnode pred tail tail tail tail process executes process executes process links qnode qnode initially 
fetch store 
fetch store 
queue 
example execution algorithm mcs 
process private variable pred points process qnode 
fourth inset process queue updating field process qnode 
point process continue wait released process 
note freeze process third inset allow process execute reaching exit section process find node nil line tail node line 
process reach line wait field updated process 
process dedicated spin location clear algorithm rmr time complexity cc dsm model 

theorem mellor crummey scott mutual exclusion problem solved complexity fetch store compare swap cc dsm model 
problem algorithm mcs relies synchronization primitives may applicability 
circumvent problem mellor crummey scott variant uses fetch store 
unfortunately variant livelock free 
authors argue practice 
may instructive briefly compare algorithm mcs algorithm ta algorithm gt algorithms array spin variables association processes spin variables varies dynamically time 
reason algorithms local spin algorithms 
algorithm spin locally cc model sufficient exiting process suitably update spin variable successor process wait exists 
algorithm ta wait slot array updated 
algorithm gt successor wait exiting process slot information updated 
algorithm mcs dedicated spin spinning local dsm model 
dedicated spin variables exiting process determine precise identity possible successor order update dedicated 
necessary enqueuing process update pointer predecessor 
related algorithms 
number researchers proposed extensions far support process priorities tolerate process 
priorities supported requiring spin queue priority ordered process exit section completely scan queue find highest priority waiting process 
case process ability scan queue insert queue record indicated priority 
priority systems multiprogrammed may multiple processes bound processor 
multiprogrammed systems may common especially problematic queue locks preempted process may delay process spin queue 
proposals dealing rely kernel deactivate queue record preempted process 
restricted form priority studied occurs algorithms reader writer synchro 
reader writer synchronization generalization mutual exclusion process classified reader writer 
readers may execute critical sections simultaneously writ ers require exclusive access 
readers writers different requirements necessary give readers priority writers vice versa 
development algorithm mcs mellor scott extensions algorithm support reader writer synchronization 
authors investigated algorithms circular waiting lists 
note algorithm mcs process finds predecessor list performing fetch store 
identify successor successor updates field 
circular list problem eliminated nodes reached traversing list reading predecessor pointers 
fu considered circular list algorithm processes arranged tree contains circular waiting list 
process entry section enqueues leaf circular list 
process head circular list node tree merging circular listof node circular list parent node 
argued tree structure eliminates hot spot contention leading better performance 
hot spot contention occurs processes shared variable variables stored memory module 
hot spot contention lead degraded performance memory accesses target hot spot 
despite potential advantages algorithms quite difficult un assert really improvement previous algorithms 
algorithm starvation free 
related extensions queue algorithms discussed timeout mechanisms incorporated 
mechanisms process abandon lock request waited long deadline passed 
noted earlier algorithms ta gt rmr time complexity cc model raises question fetch fetch store primitives sufficient constructing constant time algorithms dsm model 
huang circular list algorithm fetch store constant amortized rmr time complexity number remote memory history divided number critical section entries history constant dsm systems 
anderson kim showed constant time algorithms amortization constructed dsm systems large class primitives includes fetch store 
theorems strengthened apply systems 
algorithms reads writes algorithms ta gt mcs local spin mutual exclusion algorithms published requires read modify write primitives 
led researchers question primitives fact necessary local spin synchronization 
anderson showed case presenting theta algorithm uses read write operations 
algorithm showed local spin synchronization strong primitives possible principle rmr time complexity significantly higher algorithms ta gt mcs 
subsequent yang anderson narrowed time complexity gap presenting theta log algorithm writes 
explained section follows lower bounds rmr time complexity yang anderson algorithm factor theta log log optimality atomic reads writes theorem 
rest section overview yang anderson algorithm denoted algorithm ya 
earlier algorithm anderson happens correct reads nonatomic 
defer consideration section 
algorithm ya 
proposed implementing process mutual exclusion process solution algorithm local spin algorithm binary arbitration tree 
associated link tree entry section exit section 
entry exit links connecting node children constitute process mutual exclusion algorithm 
initially processes located leaves tree 
enter critical section required traverse path leaf root executing entry section link path 
exiting critical section process traverses path reverse time executing link 
algorithm ya arbitration tree approach 
approach adsm system busy waiting local spinning process algorithm provide mechanism allows process deduce process compete 
determines competitor node tree may writing spin variable process accessed node 
process version algorithm ya provides mechanism 
slightly simplified version process algorithm shown full process algorithm shown 
processes denoted identifiers assumed distinct nonnegative integer values 
process identifiers range 

process algorithm employs shared variables 
variable ranges process inform process intent enter critical section observe holds process lines holds 
variable similarly 
variable ranges tie breaker event attempt enter critical sections time 
algorithm ensures processes enter critical sections order update variable process needs busy wait 
variable similarly 
note statically allocated spin variables dsm machines locally 
process wants enter critical section informs process intention establishing process assigns identifier tie breaker variable initializes spin location 
process shown interest entering critical section holds process proceeds directly critical section 
reads tie breaker variable implies enter critical section algorithm prohibits critical section holds recall ties broken favor update 
holds process executed line process process executed line line 
case wait exits critical section second case able proceed critical section 
ambiguity resolved execute lines 
lines executed process release process event shared variables array initially array initially process process true true noncritical section noncritical section fi fi await spin await spin await spin await spin fi fi fi fi fi fi critical section critical section fi fi od od algorithm ya process case 
waiting update tie breaker variable busy waiting line 
lines determine process updated tie breaker variable 
note implies updated tie breaker implies finished critical section 
cases process waits updated tie breaker re examines see process updated necessary waits process critical section 
executing critical section process informs process finished establishing case process trying enter critical section process updates wait 
discussed process case solved applying process algorithm tree 
competing process instance node tree process determine competitor reading variable associated side 
slight algorithm required implement 
example lines replaced 
node side node rival node side code fragment invoking process invokes algorithm tree node height node side side side ranges processes left subtree node invoke side processes right subtree invoke side 
identity process recorded private variable rival 
notice variables indexed const simplicity assume log height arbitration tree log size arbitration tree shared variables array initially array initially array private variables node side left side right side rival process true noncritical section node hc side mod node side node rival node side rival node rival rival fi await node await fi fi od critical section downto node hc side mod node side rival node rival rival fi od od algorithm ya process case 
side assigned values ranging process identifiers 
process algorithm uses process code depicted 
assumed power sake simplicity 
nodes numbered follows root node children 
children 
process begins executing arbitration tree leaf node algorithm theorem 
theorem yang anderson mutual exclusion problem solved theta log rmr reads writes cc dsm model 
related algorithms 
order guarantee different nodes arbitration tree algorithm ya distinct spin variable process tree 
algorithm space complexity theta log 
kim simple code transformation reduces space complexity algorithm theta whichis optimal see theorem 
new algorithm process uses spin variable levels tree 
algorithm ya rmr time complexity new algorithm theta log 
aside algorithms mentioned published local spin mutual exclusion algo rithm uses reads writes know 
algorithm similar algorithm ya earlier algorithm anderson 
derives algorithm transformations peterson algorithm 
noted anderson algorithm obtained exactly way 
algorithm represents important step transformations 
zhang yan casta neda conducted extensive evaluation read write mutual exclusion algorithms 
algorithm ya algorithms tested 
evaluation basedon metrics take account effects architectures systems software implementations 
addition new algorithms including tree algorithms incorporate spin non local spin techniques 
fast mutual exclusion lamport devised novel mutual exclusion algorithm requires memory accesses inthe absence contention 
algorithms process executes constant time fast path absence contention known fast mutual exclusion algorithms 
free time complexities memory counted local remote 
write algorithms covered section clearly constant time complexity absence 
time complexity absence contention non issue suitable read modify write primitives available 
reason term fast mutual exclusion algorithm usually applied algorithms reads writes 
section overview research date algorithms 
algorithm lamport fast mutual exclusion algorithm lamport fast mutual exclusion algorithm denoted algorithm shown 
inthis algorithm fast path process reaches critical section executing lines 
lines special significance 
lines shown separately define black box element called splitter illustrated 
term splitter due lamport abstracted black box moir anderson called splitter attiya :10.1.1.55.2079
paragraphs consider properties splitter useful show properties ensure algorithm splitter element 
process invokes splitter code stops moves 
move defined value assigned private variable dir key properties splitter useful processes invoke splitter splitter 
see property holds suppose contrary processes 
process executed line 
held line xis written process execution line execution line 
executed line 
implies executed line executed line 
read false line assigned dir right contradiction 
similar applied show processes invoke splitter move right move 
properties splitter element related mechanisms proven wait free algorithms renaming 
renaming algorithms shrink name space process identifiers taken 
algorithms speed computations loops iterate process identifiers 
splitter properties possible solve renaming problem interconnecting collection splitters grid 
name associated splitter 
process stops splitter acquires name associated splitter 
grid rows columns number induction process eventually stops splitter 
original name space may larger see note processes may move second row third row 
process may enter throw name 
similar arguments show process may enter leaf node names process eventually stops 
shared variable array boolean initially false initially process private variable true noncritical section true false await busy wait goto fi false await busy wait od await busy wait goto fi fi critical section false od right part process private variable dir right dir right dir dir fi fi algorithm lamport fast mutual exclusion algorithm 
splitter element implementation 
correctness algorithm splitter properties ensure algorithm correct 
inparticular process splitter process time take fast path reading line line 
corresponds assignment dir 
process takes fast path period contention process reach lines 
shown processes update variable critical section fast path assigning line 
livelock free giving theorem 
theorem lamport mutual exclusion problem solved livelock free algorithm re quires memory absence contention 
hand starvation freedom satisfied unfortunate process may line line wait forever 
variations 
number authors proposed variants algorithm mention covered detail 
michael scott showed reads writes renaming grid depicted 
required absence contention processes ability read write full word granularities 
contrast merritt proposed modifications speed algorithm contention compared algorithm 
algorithm process reaches line check status process 
actual system number processes invoke algorithm concurrently total number processes inthe system 
merritt showed linked list simple array scan time complexity check proportional number contending processes 
fast mutual exclusion local spinning fast mutual exclusion algorithms discussed employ busy waiting loops read written 
algorithms fast absence contention unbounded rmr time complexity contention 
section consider fast mutual busy waiting local spinning 
algorithm published variant algorithm ya considered earlier insection 
unfortunately fast path variant algorithm ya rmr time complexity theta theta log 
anderson kim improved fast path mechanism results time complexity absence contention theta log rmr contention conjunction algorithm ya 
resulting algorithm denoted algorithm ak described 
algorithm ak 
basic idea algorithm ak combine fast path algorithm arbitration tree algorithm ya specifically placing extra process version algorithm ya top arbitration tree 
version algorithm ya process algorithm processes fixed 
approach illustrated 
left entry section extra process algorithm process code process tree algorithm contention 
slow path fast path basic structure algorithm ak 
executed process process detects contention 
right entry section extra algorithm process code executed process successfully acquired critical section implemented arbitration tree 
process competes arbitration tree detects 
describe fast path mechanism algorithm ak 
version mechanism uses unbounded memory 
slightly complicated bounded version described 
unbounded version shown 
describing algorithm works basic structure 
shared variables infinite shared array reset name taken array 
variables lamport algorithm additional integer indx field 
explained algorithm ak works renaming process acquires fast path new temporary process identifier 
indx field renaming processes 
variable reset reinitialize indx field period ends 
variable name taken indicate name assigned 
variable set record fast path acquired process 
entry code extra topmost process algorithm illustrated entry left invoking processes entry right invoking processes 
denoted similarly 
entry exit code process arbitration tree algorithm denoted entry exit respectively denotes invoking process 
process determines access fast path executing lines lines fast path mechanism 
note fast path open free true false process begins executing lines expression holds processes noncritical sections reach line 
process detects competing executing lines fast path invokes slow 
slow invoked updated variables reset order reopen path 
slow invoked 
detailed explanation deflection mechanism 
process successfully acquires fast path executes lines 
acquires fast path slow attempts reopen fast path executing lines respectively 
detailed explanation fast path 
critical property algorithm bears mentioning consider algorithm properties 
particular note accesses shared variables occur type record free boolean indx stored word shared variable reset initially true name taken array boolean initially false boolean initially false process private variable true noncritical section free slow false slow name taken indx true reset name taken indx false slow true entry fast path critical section reset true indx true indx exit false fi fi fi od procedure slow entry entry critical section exit exit procedure slow entry entry critical section reset reset false indx name taken indx reset true indx true indx fi exit exit algorithm ak theta log fast path algorithm unbounded memory 
code sequences execute critical sections lines 
reasoning algorithm assume code sequences interleave 
fact shall see assumption merely matter convenience algorithm correctness relies fact code sequences execute critical sections 
problems lamport fast path code difficult slow path process reopen fast path resetting know process fast path 
algorithm ak problem solved including additional field indx whichis identifier rename process acquires fast path 
value indx free true holds 
indx reset indx holds value indx identifier increase bound time worry possibility processes renamed identifier 
added field slow path process way identifying process taken fast path 
see works consider starting initial state set processes execute entry sections 
processes read true line assign false line 
lamport fast path code processes assign reach line 
process line acquire fast path reaching line slow line 
gives cases analyze processes read true line assign line slow say acquires fast path 
case processes executes slow finds name taken false line fast path executing lines establish free true indx reset see process executes lines note process consideration reads true line indx variable equals executing lines 
note taken true established line 
furthermore process slow line assigns name taken false 
processes slow taken false line 
case unique process acquired fast path argue fast fast path leaving ii slow process prematurely left fast path 
establishing straightforward 
process reopen fast executing lines establish true false reset 
note line prevents fast path effect finished executing exit 
establish ii suppose contrary slow process fast path executing lines 
slow process execute line assuming entry exit calls correct execute line lines 
enabled execute line true path closed 
remaining possibility enabled execute line 
note execute line reopen fast path invoking entry exit lines virtual process identifier 
entry exit calls obviously assumed correctly scenario happen 
assume executes line enabled execute line 
happen read name taken false line assigned name taken true line 
recall processes consideration read true line 
writes name taken element name taken 
reads name taken line process attempt reset fast path implies reads reset true line executes line executes line line executed line executed reset line slow contradiction follows explanation initial period contention ends free true indx reset false 
argument applied inductively fast path properly period contention ends 
applied inductively reasoning indx indx 
note indx holds current value indx indx increases fast path 
algorithm ak requires unbounded memory indx field renaming grow bound 
bounded version indx 
indx updated way potential problem arises 
process reach line algorithm ak indx stall 
stalled processes increment indx slow cycles back point process line indx problem may interfere taken 
bounded version algorithm ak additional mechanism introduced indx prematurely recycling way 
results section establish theorem 
theorem anderson kim mutual exclusion problem solved theta log rmr contention time complexity absence contention reads cc dsm model 
system step rmr dsm contention response time time space parameter algorithm time complexity complexity complexity min log min log theta interval cs singh theta interval ab attiya log theta log point ab attiya log theta log interval ast afek theta point ak rt anderson kim min log min log min log theta point ast rt afek min log min log theta interval table adaptive algorithms 
denotes interval point contention indicated 
denotes bound maximum number processes concurrently active system possibly algorithm ast uses bounded number variables variables unbounded 
adaptive algorithms fast mutual exclusion algorithms perform absence contention algorithms sudden rise time complexity contention 
section consider adaptive algorithms designed alleviate problem 
formally mutual exclusion algorithm time complexity measure function number contending processes 
case fast algorithms adaptivity non issue appropriate synchronization primitives available term adaptive usually applied algorithms reads writes 
notions contention considered literature interval contention 
notions defined respect history interval contention number processes active execute outside noncritical sections point contention maximum number processes active state note point contention interval contention 
section stated denote contention point interval experienced arbitrary process history process active ends inactive 
denote bound maximum number processes concurrently active system possibly algorithms considered section summarized table 
different time complexity measures applied adaptive algorithms 
meaningful time complexity measure concurrent algorithms dealing potentially unbounded loops main difficulty faced 
standard sequential algorithms counting operations busy waiting loop unbounded time complexity interesting useful statistic 
step time complexity algorithm maximum number shared memory operations required process enter exit critical section assuming await statement counted operation 
measure simply ignores repeated memory process waits 
measure proposed system response time length time critical section entries assuming active process performs onestep constant time bound termed time unit 
forcing active processes take steps waiting times precluded provided waiting condition algorithm process finite number steps 
amortized system response time algorithm measure proposed defined average system response time provided contending processes start execution simultaneously 
rmr time complexity measure interest adaptive algorithms 
part limit attention dsm model measure algorithms consider algorithms ak ast rt local spin algorithms locally spin dsm machines 
continuing examine relationship rmr time complexity step time com attiya term remote step complexity 
term appears originated earlier authors 
prefer term step time complexity term remote may cause measure confused rmr measure 
plexity 
dsm model await statements algorithm access locally statement step time complexity rmr time complexity hand await statement accesses non local variable algorithm rmr time complexity obviously unbounded 
cc model variable accessed await statement local cache line 
single await statement generate large number cache misses variables accesses keep changing satisfying await condition 
step time ignores remote caused misses 
general algorithm step time complexity rmr time complexity need 
early algorithm variants algorithm stepping stone leading earliest adaptive algorithms 
algorithm contention detected process poll process order critical section 
mentioned section merritt proposed variant algorithm linked list active processes scanned array variables 
algorithm requires external mechanism inserting active processes list removing ones longer active 
operations done order ensure correctness 
assume external mechanism solution mutual exclusion problem required 
true adaptive algorithm sense 
algorithm probably propose algorithm building block adaptive algorithm 
algorithm denoted algorithm illustrated algorithm uses ary level arbitration tree ml 
process enters designated leaf node 
associated node process slow mutual 
process tries enter fast path algorithm fails traverses tree leaf root executing slow algorithm times way 
node associated variable marks winner node 
process takes path marks winner nodes leaf node root shown 
algorithm fast path takes theta time 
process takes path wins arbitration tree may mark winner node path overwriting markings 
winning arbitration tree determines ifa fast path process case exists traversing tree recursively possibly skipping subtrees 
node winner ancestor node marked process recursively visit children 
node slow winner marking overwritten slow process process recurses children order detect subtree 
possible process checks node marked case fail detect process tries enter critical section completely detect contention enter slow path 
discussion clear recursion visits node ancestor participating process 
consider node visited process recurse subtrees 
node visited children checked 
tree levels participating processes ancestors interval contention 
visiting remote steps entire recursion takes klm remote steps 
theta non total entire recursion takes remote steps 
leaf node visited children 
follows step time complexity recursion min klm 
assuming case lm theta log algorithm min log step time complexity system response time 
assumption step time complexity measure await statement constant cost regardless number variables accesses 
clear reasonable number variables accessed function papers step time complexity await statements access constant number variables considered 
process arbitration tree ary level slow path handshaking contention 
order traversal fast path structure algorithm 
node marking acquires fast path 
slow path may partially overwrite marking 
traverses tree check fast hidden overwriting subtrees roots marked slow processes need traversed 
algorithm cs singh filter algorithm singh devised novel code fragment called filter shown 
filter exits succeeds halts fails 
filter satisfies properties 
safety processes enter filter dm processes exit 
progress processes enter filter exits 
see progress property holds process execute line 
halting processes assign false line 
eventually find line exit successfully 
consider safety property 
assume processes exit 
note exiting processes executions lines overlap 
exiting process exiting process execute line executes line exit 
process executes lines value changes false true 
halt exit exit processes shared variable turn boolean initially false process turn await true turn false halt exit fi filter element implementation 
value change true false times 
safety property follows inequality leader election filters 
leader election algorithm constructed concatenating filters sothat processes exit filter move 
algorithm shown 
concatenate dlog ne filters indexed 
filter halves number process may exit filter dlog 
process exists filter checks filter order determine process exited filter 
isthe case elects leader 
need additional filter dlog ne 
mechanism explained 
filter additional variable initially false set true process fails filter 
set true remains true 
process exits filter finds false process failed filter 
follows far false true process line 
process exited 
process subsequently exits blocked await filter 
elect leader 
filter safety property process dlog theta log filters suffice 
algorithm space complexity theta log 
algorithm cs unbounded version 
election algorithm create simple exclusion algorithm 
algorithm shown 
algorithm uses unbounded number filters 
competing processes participate election algorithm filters entry entry 
entry shared variable points 
process elected leader enters critical section 
exit section leader initiates round election algorithm updating entry 
filter properly process update entry point new filter 
algorithm system response time 
analysis complicated 
refer interested reader 
process may repeatedly lose election algorithm starvation free 
arbiter mechanism 
algorithm just described shortcomings uses unbounded memory starvation free 
singh proposed arbiter mechanism solution problems 
mechanism shared variable ensure process entry section accorded chance enter critical section 
pointer updated time critical section shared variable array dlog ne record turn boolean initially false process private variable curr dlog ne curr true curr turn await curr curr true curr turn curr true curr false halt curr curr elected curr curr fi od shared variable array record turn boolean initially false entry initially process private variable curr elected boolean true noncritical section elected false elected curr entry entry elected entry curr turn await curr entry entry curr true curr turn curr true curr false await entry curr curr elected true curr curr fi fi od od critical section entry curr od leader election algorithm filters 
unbounded version algorithm cs 
executed cycles processes round robin fashion 
process exits checks process pointed entry section 
process process immediately enter critical section 
election algorithm starts process pointed finishes critical section 
way process guaranteed enter critical section critical section executions election round uses log filters process left old election round number filters limited theta log 
election algorithm uses log filters interval contention election period filter step entire algorithm log step time complexity 
singh optimizations result system response time amortized system response time step time complexity 
adaptive tournament tree 
algorithm ab attiya improved filter algorithm attiya devised improved filter algorithm step time complexity log system response time 
algorithm consists parts non wait free long lived filters adaptive tournament tree illustrated 
long lived renaming problem extends renaming problem briefly mentioned section requiring processes ability acquire new names release previously acquired names 
unbounded version renaming algorithm shown 
note similarity election algorithm procedures 
prior wait lived renaming algorithms algorithm proposed efficient adaptive mutual exclusion algorithm done 
key insight attiya thata renaming algorithm mutual exclusion algorithm wait free 
recall algorithm ak similar insight 
algorithm ab process obtains name range size point contention name enter adaptive tournament tree mutual exclusion 
tournament tree implemented process mutual exclusion algorithm building block 
constant algorithm ya process name range size exits adaptive tournament tree step time complexity log 
fact algorithm time complexity entering exiting tournament tree log measure 
system response time log 
renaming algorithm uses array chains chain consists unbounded numberof filters numbered upper bound maximum number processes system possibly 
algorithm cover distinguishes nand addition shared array contains index current round filter election algorithm 
process executes successive chains starting chain wins election chain 
name acquired process index chain wins 
process tries win chain calling executes leader election algorithm isvery similar shown 
wins chain acquires name tournament tree 
loses chain mechanism election algorithm fails filter inside chain 
suppose fails rth filter chain case skips chains tries win chain procedure invoked execute filter 
original filter singh filter additional variable set process succeeds filter variable checked lines order ensure process promptly fails process success 
changes attiya filter ensures safety progress properties original algorithm 
constant success true fail false win true lose false type record turn boolean initially false shared variables array array process private variables indx curr result win lose procedure getname returns indx repeat indx result indx result win indx return procedure name name procedure ch returns win lose access chain ch ch curr move pointer curr start true ch curr success curr ch curr return win curr curr curr fi proceed filter return lose curr fi od procedure ch curr returns success fail access specific filter ch curr turn return fail fi ch curr turn ch curr return fail fi await ch curr ch curr turn ch curr ch curr return fail fi ch curr turn ch curr true fi ch curr turn ch curr true ch curr false return fail ch curr true return success fi renaming procedures algorithm ab unbounded version 
time complexity process succeeds filter time units process time unit constant time bound active process performs step 
original election algorithm progress safety properties ensure processes process wins chain log filters 
applying time complexity follows process acquires name log time units 
shown holds winning process 
process leaves critical section waiting process wins tournament tree enters critical section log time units 
assertions possible show algorithm system response time log 
refer reader details 
algorithm step time complexity analysis complicated omitted 
mechanism similar arbiter attiya constructed log space complexity maintaining step time complexity log system response time 
algorithm log space complexity defining interval contention 
variant listed algorithm ab table 
stands shared variables number array initially choosing array boolean initially false process private variables set processes true noncritical section join choosing true get set number maxq number choosing false get set await choosing await number 
number number od critical section number leave od algorithm ast adaptive bakery algorithm 
interval results theorem 
theorem attiya mutual exclusion problem solved log time step time complexity reads writes point contention 
algorithm ast adaptive bakery algorithm afek constructed adaptive bakery algorithm combining lamport wait free active set object 
algorithm denoted algorithm ast 
active set object manages set processes process may execute operations 
join adds active set 
leave removes active set 
get set returns current active set process execution join leave overlaps execution get set allowed contain 
afek devised wait free implementation active set object generic lived renaming algorithm 
algorithms various tradeoffs parameters size output name space step time complexity space complexity algorithm adaptive interval point contention 
renaming active set algorithm afek achieves step time complexity 
remove lines algorithm ast change lines original bakery algorithm 
due lines algorithm ast check processes concurrently active checking process system 
loop lines step time complexity 
clearly time complexity dominated active set algorithm algorithm step time complexity 
active set algorithm wait free shown algorithm ast system response time 
unfortunately original bakery algorithm number variable algorithm ast unbounded range 
total number shared theta 
local spin adaptive algorithms anderson kim local spin adaptive algorithm min log rmr time complexity algorithm ak 
afek devised local spin adaptive algorithm similar structure long lived splitter algorithm 
call adaptive algorithms algorithm ak rt algorithm ast rt respectively 
rt stands renaming tree see 
covered local spin algorithms unbounded rmr time complexity dsm model 
question algorithms truly adaptive 
algorithm shown perform poorly contention performance study conducted yang anderson compare local spin algorithms non local spin algorithms 
belief foran algorithm considered truly adaptive adaptive rmr time complexity measure 
underlying hardware distinguish remote memory generated await statements remote memory generated statements 
algorithms ak ast rt mutual exclusion algorithms reads writes known rmr time complexity measure dsm model 
sketch key ideas algorithm ak rt 
consider algorithm ast rt 
algorithm ak rt 
explained section main idea algorithm ak particular name fast path take fast path process acquire name 
algorithm ab algorithm ak exploits fact code executed acquire fast path name executed process critical section 
algorithm ak rt extends algorithm ak set names associated path critical section length path taken process determined point contention experiences 
algorithm ak rt long lived renaming algorithm grid moir anderson depicted earlier 
long lived splitter elements 
splitter elements slightly complicated implementation repeatedly acquired released process acquires splitter stops splitter process releases splitter acquired resetting variables define splitter process 
example variable splitter reset 
grid algorithm process release name releasing splitter path traversed acquiring name 
renaming mechanism correctly important splitter processes downstream sub grid rooted splitter 
moir anderson algorithm takes time determine downstream processes process checks process individually determine downstream splitter 
clearly efficient release mechanism needed adaptive mutual exclusion algorithm 
main idea algorithm ak rt arbitration tree form dynamically similar renaming grid 
tree may remain balanced height bounded constant multiple point contention 
simplify job integrating renaming aspects arbitration tree binary tree splitters grid depicted 
working tree henceforth refer directions associated left right 
note results names 
major concern really interested minimizing name space 
arbitration tree isdefined associating process mutual exclusion algorithm node renaming tree 

renaming tree 
process algorithm implemented constant rmr time complexity algorithm ya 
explain process algorithm needed process algorithm expect arbitration tree 
algorithm ak rt process performs basic steps 
step acquires new name moving root renaming tree stops 
steps follow refer node acquired node 
acquired node starting point arbitration tree 
step competes arbitration tree executing process entry sections onthe path acquired node root 
node entry section may invoked process stopped node process left right subtrees beneath node process algorithm needed 
step competing arbitration tree executes critical section 
step completing critical section releases acquired name releasing splitters acquired node root 
step releasing name executes process exit sections path acquired node 
algorithm ak rt renaming tree height defined blog results tree theta nodes 
tree height process fall tree acquiring name happen contention omega log 
handle processes fall tree called overflow tree 
overflow tree implemented algorithm ya renaming overflow trees connected placing process version algorithm ya tree illustrated 
illustrates steps taken process acquiring new name contention log 
illustrates steps process contention omega log 
discussion follows system response time step time complexity rmr algorithm ak rt min log point contention 
shown space complexity theta linear space variant algorithm ya discussed section implementing renaming overflow trees 
theorem 
log height failed tree overflow tree mutual exclusion alg process process got name process renaming tree overflow tree 
process gets name renaming tree 
process fails get name compete overflow tree 
theorem anderson kim mutual exclusion problem solved min log rmr time complexity step time complexity system response time theta space reads writes cc dsm model point contention 
interesting know better features algorithms ab ak rt 
leave open problem 
open problem mutual exclusion problem solved rmr time complexity model log system response time 
algorithm ast rt 
mentioned afek devised local spin tree structure shown figures independently anderson kim 
challenging problem renaming tree releasing splitters critical section step algorithm ak rt 
algorithm ak rt problem exploiting fact releasing done inside critical section 
algorithm ast rt solved adopting long lived adaptive splitter supports functions acquire release 
function acquire returns right splitter 
splitter invokes acquire gets return value release calling release 
processes fail acquire splitter release 
addition lived splitter satisfies properties 
process invokes acquire absence contention acquires stops splitter 
process may acquire splitter time 
processes invoke acquire splitter fail acquire splitter may move right may move 
properties steps algorithm ak rt replaced steps done algorithm ast rt 
step executes process exit sections path root acquired node 
step stopped inside renaming tree step releases single splitter acquired 
shown copies splitter element long lived adaptive splitter con structed step time complexity rmr time complexity dsm model theta space complexity interval contention 
interested readers referred details 
shared variable initially process true noncritical section repeat await delay delta critical section od algorithm simple timing algorithm 
process accesses min log splitters renaming tree algorithm ast rt min log step rmr time complexity theta space complexity 
algorithm ast rt achieves system response time 
timing algorithms preceding sections assumed asynchronous system model enabled eventually executed bounds stipulated long takes statement complete execution 
practice statement execution bounds depend manner processes scheduled course various aspects hardware processes run 
systems characteristics schedulers exploited deduce reasonably accurate execution bounds 
example scheduling quantum mutual exclusion algorithm invoked process new quantum may possible deduce process preempted process executing algorithm 
case upper bound time required complete statement fairly accurately deduced 
systems reasonable consider timing information exploited design efficient mutual exclusion algorithms 
refer algorithms exploit information timing algorithms 
timing algorithms system models considered 
known delay model known upper bound denoted delta time required access read write shared variable 
unknown delay model upper bound delta value unknown priori thevalue delta directly algorithm 
model process may delay execution dtime units executing statement delay 
earliest timing mutual exclusion algorithm unpublished algorithm fischer whichis described lamport fast mutual exclusion 
paragraphs follow describe fischer algorithm 
description overview timing algorithms published 
algorithm fischer algorithm denoted algorithm shown delay model 
algorithm quite simple 
process waits line lock available indicated 
reads writes process identifier line delta time units line 
value delay line enters critical section 
see algorithm satisfies exclusion property assume contrary processes pand execute critical sections time 
loss generality assume 
read line execution line precedes execution line read line execution line precedes execution line established sequence executions executes line executes lines shared variables initially boolean initially false process true noncritical section start await delay delta go start fi await true fi critical section false fi od algorithm fast timing algorithm 
executes line 
happen delayed delta time units contradiction 
see algorithm livelock free note processes execute line oneto read identifier line enter critical section 
unfortunately algorithm isnot starvation free unfortunate process may fail exit loop lines repeatedly processes 
drawback algorithm process delay absence contention problem addressed lamport constructed fast timing algorithm process performs shared memory accesses executes delay statements absence 
algorithm requires upper bound time required shared memory access duration critical section execution 
algorithm 
alur improved lamport algorithm constructing algorithm bound critical section execution times assumed 
algorithm denoted algorithm shown 
examining figures algorithm constructed combining features lamport splitter algorithm show algorithm satisfies exclusion property 
note exist paths enter critical section 
say process takes path enters executing lines say takes path enters critical section executing line 
note lines algorithm constitute splitter element line busy waiting 
process may move right process may splitter enter critical section path hand line ensures group processes read line process executes line process reads line 
itis straightforward see process may enter critical section path remains shown paths simultaneously 
assume process enters critical section path process tries enter critical section path consider cases 
executes line delays line delay ensures true line resumes execution 
reads false line executes line 
hand assume execute line delays 
case executed line executed line order read 
execute line delayed line reads line fails enter section 
see algorithm livelock free note number processes execute lines process reaches critical section processes write line waiting condition line time writes occur 
easy process write eventually reach line critical section isa contradiction 
unfortunately process may execute go statement line repeatedly algorithm starvation free 
theorem 
theorem alur mutual exclusion problem solved known livelock free timing algorithm algorithm requires mem ory absence contention 
careful reasoning prove 
interested readers referred 
theorem alur mutual exclusion problem solved known livelock free timing algorithm algorithm property critical section ends process enter critical section performing thirteen memory explicitly delaying invoking delay statements delta time units 
algorithm aat 
drawback algorithm bound delta known priori 
com algorithm lamport fast path algorithm algorithm alur attiya fast timing algorithm works unknown delay model 
algorithm denoted algorithm aat shown 
algorithm aat shared variable bound store current estimate delta consists parts algorithm modified value bound delta algorithm ensure correctness estimate bound wrong estimate value delta increment bound current estimate wrong 
parts distinguished roman italic boldface line numbers respectively 
shared variables algorithm variables xx yy variables respectively algorithm shown 
variable update value bound updated trying indicates process 
lines constitute algorithm 
lines ensure update false variable bound updated 
lines identical algorithm delta replaced bound additional checks update 
current estimate delta correct part ensures exclusion property holds 
estimate small multiple processes may enter lines 
order cope situation algorithm executed algorithm lines 
note correct process enters critical section fast path transiting directly line line 
process enters critical section slow path lines current estimate wrong sets update true line 
lines update bound current estimate wrong 
correct bound process waits element trying array false order ensure process concurrently uses value bound updated 
increments bound line 
discussion conclude properties algorithm aat 
shared variables xx yy initially boolean initially false trying array boolean initially false bound delay duration initially process true noncritical section start repeat update true trying false await update false fi trying true delay bound go start fi await update true true fi start update true go start fi true xx yy false await yy update true go start fi yy xx await update true od yy await yy update true go start update true fi fi critical section trying false update true await trying od bound bound fi yy false false update true update false fi od algorithm aat fast timing algorithm unknown delay model 
algorithm algorithm fast algorithm aat fast 
algorithm algorithm livelock free algorithm aat livelock free 
starvation free 
period contention begins algorithm aat warm period slow path algorithm period critical section ends process may subsequently access theta shared variables order enter exit 
correct estimate delta determined fast path algorithm algorithm timing characteristics algorithm 
particular critical winning process subsequently performs memory explicitly theta delta time units order enter exit critical section 
theorem alur mutual exclusion problem solved unknown delay model free timing algorithm algorithm att requires memory absence contention property eventually holds critical section ends process enter critical section performing memory invoking delay statements theta delta time units 
related 
combining splitter mechanism algorithm lynch shavit simple timing algorithm shared variables livelock free timing constraints met satisfies exclusion property constraints violated 
mitzenmacher experimentally evaluated variants lynch shavit algorithm process execution speeds follow certain random statistical distributions 
algorithms delta needs set toa worst case value ensure correctness 
worst case value may lead unnecessary delays time 
smaller values delta gain better performance average price occasional failures processes may detect contending processes restart entry sections 
gafni mitzenmacher studied behavior algorithms varying execution time distributions andthe number processes system 
results suggest timing algorithms exhibit statistically performance large systems order processes 
mutual exclusion nonatomic operations point assumed shared variables accessed atomically 
requiring atomic tantamount assuming mutual exclusion lower level 
mutual exclusion algorithms requiring sense circular 
lamport recognized mutual exclusion requiring operations atomic early papers wrote extensively topic part 
overview part section 
insection consider nonatomic algorithms busy waiting local spinning 
lamport nonatomic algorithms part lamport part formal model concurrent systems inwhich underlying atomicity assumed 
model operation executions duration may concurrent 
single writer nonatomic shared variables considered lamport calls variables 
write communication variable concurrent operation variable operation read 
read shared variable write variable allowed return value domain variable 
read overlap write simply returns variable current value 
roots notion semantics trace back lamport bakery algorithm standard semantics assumed papers nonatomic algorithms 
appreciate difficulties occur nonatomic operations consider permitted model variable assumed initially 
updated write operation assigns 
concurrent read may obtain domain including value different 
ii updated write operation assigns concurrent successive 
read obtains value second read obtains value 
general techniques dealing nonatomic operations quite intricate basic ideas 
observe scenario eliminated simply skipping redundant writes write variable change variable value 
second nondeterminism simply binary shared variables case read concurrent write variable return 
furthermore redundant writes avoided read concurrent witha write returns variable old value new value written 
algorithms considered section assume writers avoid redundant writes explicitly shared variable array boolean initially false process private variable set true noncritical section true elementof await od critical section false od algorithm basic nonatomic algorithm 
indicated code depictions 
simply requires adding private variable variable written process tracks variable value easily determined write redundant checking corresponding private variable 
situation scenario ii possible managed 
second part lamport part series nonatomic mutual exclusion 
simplest algorithms algorithm shown 
subsequent designations lamport algorithms stands nonatomic successive algorithm satisfies stronger properties builds previous 
cover 
algorithm 
algorithm quite simple 
process entry section verifies process entry section critical section selecting processes nondeterministically elementof 
see algorithm satisfies exclusion property consider argument 
formal proof require careful definitions notions related event orderings 
heading contradiction suppose processes critical sections suppose finished executing line 
true stable time executing line entered critical section 
implies held contradiction 
algorithm 
unfortunately algorithm livelock free 
modify algorithm livelock freedom holds violating exclusion property 
resulting algorithm denoted algorithm depicted 
algorithm scan variables replaced phase protocol 
phase lines process yields process lower index entry critical section phase lines process checks higher indexed process determine entry section yielded waits case 
note process may enter critical section establishes true finds holds argument property previously algorithm applies algorithm 
see algorithm livelock free suppose contrary set processes outside noncritical sections process executes critical section 
eventually shared variable array boolean initially false process private variable true noncritical section true false od go fi od await od critical section false od algorithm livelock free nonatomic algorithm 
state reached process remains forever entry section noncritical section 
set processes forever executing phase 
process index clearly finds variable value true line 
eventually critical section contradiction implies empty 
process permanently inthe entry section return phase phase remaining case processes entry section permanently execute phase 
suppose case process phase 
finds variable value true line leaves phase goes 
contradicts assumption permanently executing phase 
algorithm 
unfortunately algorithm starvation free unfortunate pro cess continue restart phase entry section processes lower index repeatedly execute critical sections 
algorithm starvation free lamport introduced renumbering func tion processes contending entry sections dynamically ordered process eventually highest priority 
modification parts 
bit array identities processes competing entry sections 
array needed pis unreliable indicator contender identities due yielding mechanism phase 
second modification specialized structure encoded array bits queue prop erties enabling prioritization competing processes 
shared variables bits process lamport called resulting algorithm bit algorithm 
denote algorithm seen 
iterating process indices starting zero algorithm computes index cyclically iterates process indices starting index returned bythe function low line 
defer complete explanation function property process entry section sufficiently long eventually low holds execution line process completes critical section evaluations low different processes concurrently entry sections return different written processes enter leave precondition critical section entry shared variable array boolean initially false array boolean initially false array boolean process private variable temp boolean true noncritical section true true low cyclically mod false go fi od fi go fi cyclically mod go fi od critical section temp temp false false od algorithm starvation free nonatomic algorithm 
execution lines sequence writing ensures exclusion property 
checking line safe remains true long process entry section 
argument livelock freedom similar lines algorithm 
inparticular assuming execution non empty set processes entry sections advance critical sections infer eventually state reached process section writes variable private variables processes eventually remain constant 
process satisfying low argued contradiction executes phase lines finitely times entering critical section 
proof algorithm starvation free depends precise definition low whichwe give 
start informally defining token ring node ring representing process 
tokens circulate ring suppose process requires token critical section process leaving critical section passes token process ring 
array bits implement token ring process token process token 
simple show contradiction atleast token state definition 
token holder longer needs token assignment removes token provided course process mod change concurrently 
algorithm idea token ring ensure starvation freedom 
fixed bit array subsequence array ht token ring arrays dynamic ring bits formed 
function low smallest process index dynamic ring token holder 
define low case empty ring useful fault tolerance 
having defined low show algorithm starvation free tion 
suppose exists nonempty set processes remain forever entry sections livelock freedom verified situation possible exists nonempty set processes infinitely execute critical sections 
establish starvation freedom empty 
define dab smallest natural number mod minimum choice property token ring defined token prior executing lines token line 
executes critical section infinitely eventually state token begins entry section 
consider result assigning low line token executes loop lines 
execution loop includes sin loop index range mod claim executes lines line entry section 
follows remains true forever 
note chosen regain token executes lines subsequent execution line 
assume executes critical section infinitely outside loop index range line time entry section assigned differing values low different times 
case tested execution loop lines preventing entering critical section 
holds case empty 
contradiction proves livelock freedom 
ordered critical section entry 
algorithm satisfies bounded waiting entry section partitioned components doorway generates bounded number memory local remote followed waiting part holds process executing doorway process execute critical section times 
bounded waiting strengthens starvation freedom 
case approximates intuition served fcfs ordered entry 
addition nonatomic algorithms considered lamport fcfs algorithms cover 
algorithms uses process second shared variables 
large space requirement algorithm fault tolerance properties described 
interested readers referred hadzilacos fcfs nonatomic solution uses constant number shared variables process see 
fault tolerance 
principal themes lamport nonatomic algorithms faulttolerance 
sense nonatomic operations thought faulty operations violate atomic semantics 
lamport considered failure models summarized 
shutdown safety algorithm shutdown safe remains correct face process shut downs 
process shut sets communication variables default values returns noncritical section halts 
note process may shut executing 
abortion safety algorithm abortion safe resilient process 
sets communication variables default values returns noncritical section 
variables left unchanged 
communication variables set initial values specified part algorithm description 
fail safety algorithm fail safe resilient process failures 
process fails change values communication variables time eventually shuts setting communication variables default values returns noncritical section malfunctions 
self stabilization algorithm self stabilizing resilient transient failures enters illegitimate state due transient failures failures happening algorithm eventually converges legitimate state 
state program appears failure free history program 
self stabilizing algorithm tolerate malfunctioning process arbitrarily changes values communication variables variables finite time eventually stops malfunctioning starts normal behavior albeit arbitrary state malfunctions 
technically failure models defined respect desired property 
example self stabilizing exclusion property illegitimate state algorithm eventually converges legitimate state exclusion violated 
lamport shutdown safety abortion safety reflect reasonable behaviors result premature process termination abortion imply halting 
shutdown triggered abortion represents case process deliberately withdrawing mutual exclusion 
second properties unreasonable behaviors due transient hardware errors intuitively fail safety reflects scenario transient process failure detected repaired failed process restored service 
lamport mentions problem dealing process change communication variables 
unfortunately solving problem requires synchrony real time clocks basic computation model allows 
self stabilization 
self stabilization requirement ways challenging consider detail 
depth discussion requirements 
mutual exclusion algorithm self stabilizing necessary require process noncritical section periodically reset communication variables appropriate values 
requirement process possibly remain forever noncritical section set values appear processes critical section 
convenient assume transient faults occur initially history state due correct process operations 
ultimately algorithms tolerate additional transient faults desired 
standard approach considering initial faults approach applied subsequent transient fault 
earlier remarked implementation write communication variable avoid redundantly writing checking containing value written 
self stabilization technique viable private variables may corrupt transient fault 
write implementation communication variable avoid redundantly writing optimizations private variable technique fraction write operations execution 
assumptions algorithms ln shown self stabilizing 
prove algorithm 
algorithm require process noncritical section periodically set false 
theorem lamport mutual exclusion problem solved algorithm algorithm uses nonatomic reads writes self stabilizing exclusion livelock freedom starvation freedom properties 
proof starting initial state legitimate illegitimate process eventually resets communication variables noncritical section assumption executes lines time 
processes done system state reachable legitimate initial state 
note array initialized arbitrarily 
legitimate state reached exclusion livelock freedom starvation freedom shown hold argued earlier 
related 
noted lamport burns independently discovered algorithm 
idea token ring shared memory achieve self stabilization starvation shared variable array boolean initially true process process private variable boolean private variable boolean initially initially true true noncritical section noncritical section false false false false true true await await true true await await fi fi critical section critical section true true true true od od algorithm ja process case 
freedom extended self stabilizing exclusion abraham 
exclusion problem isdefined section exclusion algorithm considered detail 
nonatomic mutual exclusion local spinning shortcoming lamport algorithms local spin algorithms 
nonatomic algorithm spins local 
mentioned previously algorithm local spin algorithm uses read write operations 
algorithm algorithm ja described 
algorithm ja 
algorithm ja obtained solving process case usingthe process solution solve process case 
process version algorithm ja 
processes denoted exception lines identical 
algorithm ja similar earlier process solutions peterson uses single reader single writer boolean variables 
shared variables tie breaker event processes enter critical sections time 
process attempts establish process establish 
process enters critical section holds process expressed interest entering critical section 
similarly process enters critical holds process expressed interest entering critical section 
inthe event tie process favored differ value process favored equal 
essentially idea algorithm 
algorithm ja process condition required enter critical section waiting single reader single writer boolean variable 
manner accomplished explained 
written process process keep track value private variable variable purpose 
order process wait holds simply tests waits appropriate value 
particular true implies true process waits false false implies false process waits true 
process waits appropriate value 
explained variables serve dual purpose signaling value signaling process noncritical section 
loosely speaking process signal process false signal true 
value determined lines process appropriate value signal known ensure process enter critical kept equal false value determined 
noncritical section may halt process blocked entry section noncritical section kept equal true 
way serve purposes mentioned previous paragraph 
variables similarly process signal value process roles reversed true signal false 
process version algorithm ja obtained applying process version 
process true noncritical section entry od critical section exit od od algorithm entry denotes entry section process solution process compete process exit defined similarly 
entry exit assumed algorithm 
straightforward see process version algorithm ja rmr time complexity process version theta rmr 
mentioned algorithm ja remains correct variable accesses nonatomic 
single reader single writer boolean variables algorithm potential problem considered case read boolean variable overlaps write variable 
case shown safe read return true false 
theorem 
theorem anderson mutual exclusion problem solved theta rmr time nonatomic reads writes cc dsm model 
related 
anderson kim showed applying simple transformations algorithm ya covered earlier section nonatomic algorithm rmr time derived 
key idea replace multi reader multi writer multi bit variables single reader single writer single bit variables overlapping operations variable adverse impact strengthen theorem follows 
theorem anderson kim mutual exclusion problem solved theta log rmr nonatomic reads writes cc dsm model 
easy see algorithm ja shutdown safe abortion safe fail safe process process algorithm fails eventually setting shared variables default values process subsequently block hand algorithm ya nonatomic variant tolerant failures 
manner spin variables updated algorithms complicated generally possible deduce appropriate reset process fails 
fact little ambiguous variables failed process reset algorithm ya variables single statically associated writer process nonatomic algorithms considered section 
currently unknown self stabilizing local spin algorithms atomic nonatomic devised 
state open problem 
open problem possible devise local spin algorithm atomic nonatomic self stabilizing 
clearly local spin algorithm dsm systems read spin loops self stabilizing algorithm placed illegitimate state process forever blocked waiting dedicated spin variables updated competing process 
time space complexity lower bounds section survey papers time space complexity lower bounds 
section briefly discussing proof techniques papers 
section summary results 
overview proof methodologies interesting lower bounds pertaining mutual exclusion problem arguments complex 
provide brief overview commonly proof techniques 
time complexity lower bounds mutual exclusion derived inductively constructing longer histories 
usually histories constructed way limits information flow competing processes 
information flow occurs process reads shared variable avalue written process 
processes entry sections information occurred perform accesses shared variables current history consideration extended multiple processes critical sections 
words information flow occurred processes processes shared variable access 
inductively appending variable accesses limiting information flow lower bound entry section execution time 
way prevent information flow erasing processes history consideration 
process erased statement executions completely removed history 
example suppose history extended appending statement execution entry section 
statement appended process read variable written process process write resulting information flow eliminated erasing course process wrote prior erasing eliminate information flow general determining processes erase continue tricky balancing act 
erasing leave processes induction step 
case roll forward strategy processes selected allowed roll forward return noncritical sections 
instance example information flow processes eliminated allowing roll forward 
way read obtains avalue written process noncritical section process competing 
course rolled forward may read shared variables written processes 
depending onthe proof strategy resulting information flow may need dealt erasing rolling forward processes 
note example previous paragraph write eliminates information concurrently competing processes 
basic proof technique certain hidden writes processes dates back space complexity mutual exclusion burns lynch 
lower bound results overview research conducted lower bounds 
bounds asynchronous systems specifically directed timing systems 
alur proved naive definition time complexity shared counted meaningful mutual exclusion 
theorem alur process mutual exclusion algorithm process enter critical section may perform unbounded number shared variable accesses 
anderson yang lower bounds establish trade offs number memory required mutual exclusion write access contention 
access contention concurrent program number processes may potentially enabled write access shared variable 
theorem anderson yang process mutual exclusion algorithm write atomic operation accesses remote variables exists history process process performs omega log vw remote memory entry critical section 
memory omega vw variables accessed 
theorem anderson yang process mutual exclusion algorithm access atomic operation accesses remote variables exists history process process accesses omega log vc distinct remote variables entry 
theorem dsm model omega remote memory required absence contention 
cc machines access remote variable cause cache counting number distinct remote variables accessed lower bound cc obtained 
theorems imply omega vw omega remote memory required cc model absence contention 
note theorem implies fast mutual exclusion algorithms require arbitrarily high write contention 
fact algorithm writer shared variables accident 
burns lynch considered space complexity mutual exclusion algorithms 
theorem burns lynch livelock free process mutual exclusion algorithm uses writes shared variables 
showed bound tight presenting livelock free algorithm boolean 
related lynch shavit investigated relationship time space complexity timing systems 
showed system shared variables space inversely related systems 
actual formula complicated reproduce 
result showed 
theorem lynch shavit timing system unknown delay livelock free process mutual exclusion algorithm uses reads writes shared variables 
notions write contention access contention contention cost defined section different concepts point interval contention defined earlier section 
note algorithm algorithm achieve space complexity known delay systems 
alur investigated limitations variable size algorithms atomic writes 
theorem alur process mutual exclusion algorithm writes shared variable bits exists history involving process process executes log log log operations entry critical sec tion 
operations log log log distinct shared variables 
established upper bound constructing simple variant algorithm theorem alur log exists livelock free process mutual exclusion algorithm reads writes shared variable bits process executes log le operations enter exit critical section contention 
operations log le different shared accessed 
theorem fast algorithm requires variables omega log bits variables hold process identifiers constant fraction process identifier 
modern multiprocessor systems bit memory words requiring variables size omega log problem practice 
exist systems algorithms exploit ability access memory different granularities 
example mentioned section michael scott variant algorithm processes access memory full half word granularities alur results show limitations approach 
dwork questioned assumption access variable equally expensive 
introduce formal complexity model takes account hardware contention caused overlapping accesses variable 
specifically model distinguishes response operation 
operation contention cost defined number response events variable occur operation invocation matching response note access contention program defined earlier simply worst case contention cost variable 
dwork applied model various classes algorithms order study trade average worst case contention cost time complexity 
regarding mutual exclusion problem proved 
theorem dwork process mutual exclusion algorithm reads writes read modify write operations access contention exists history process executes omega log operations entry critical section 
note theorems distinguish local remote memory 
cypher lower bound remote memory arbitrary access contention 
lower bound applies algorithms reads writes conditional primitives compare swap test set 
conditional primitive updates shared variable value meets condition 
theorem cypher process mutual exclusion algorithm reads writes exists history total number remote memory number participates history omega log log log log log 
cypher lower bound applies dsm cc systems 
primitives fetch fetch store implement mutual exclusion time cypher result pointed unexpected weakness compare swap widely regarded useful primitives provide hardware 
anderson kim improved cypher result asfollows 
theorem anderson kim process mutual exclusion algorithm reads writes conditional primitives exists history process performs omega log log log enter exit critical section 
lower bound applies cc dsm systems 
cypher result just single process competing processes 
opens possibility amortized number remote memory process theta log log log 
leave research 
open problem cypher lower bound improved 
lower bound theorem follows theta log rmr time complexity algorithm ya close optimal 
fact conjecture optimal 
conjecture process mutual exclusion algorithm reads writes conditional primitives exists history process performs omega log remote memory enter critical section 
note establishing conjecture show conditional primitives compare better reads writes standpoint asymptotic rmr time complexity 
kim anderson established lower bound adaptive mutual similar conditions 
theorem kim anderson exists process algorithm reads writes conditional primitives history exists involving theta process performs omega remote memory enter exit critical section 
result precludes deterministic algorithm log rmr time complexity 
shown expected log rmr time complexity possible random ization 
important point theorem establish omega lower bound 
omega rmr time complexity required provided sufficiently large 
leaves open algorithm theta rmr time complexity low levels contention complexity intermediate levels contention 
find highly 
conjecture 
conjecture adaptive process mutual exclusion algorithm reads writes ranging exists history process contention generates omega min log remote memory enter exit 
note establishing conjecture show algorithm ak rt time optimal time complexity measure cc dsm models 
final bounds mention pertain nonatomic algorithms established kim 
theorem anderson kim process mutual exclusion algorithm writes exists history involving process process performs omega log log log remote memory dsm model entry critical section memory omega distinct remote variables accessed bounds show fast adaptive algorithms impossible variable accesses nonatomic caching techniques avoid accessing processors memory interconnection network 
bound requires certain technical conditions involving semantics nonatomic writes 
see details 
research number important papers shared memory mutual exclusion related topics fit categories considered 
conclude briefly mentioning papers 
randomized mutual exclusion 
randomized mutual exclusion kushilevitz rabin pre sented algorithm uses single theta log log bit shared variable 
revision contain errors 
variable accessed fetch anda primitive 
processes scheduled adversary scheduler 
adversary scheduler examine external behavior processes process noncritical entry critical exit section history external behaviors information decide process executed 
scheduler considered kushilevitz rabin restricted examine content private variables deciding process schedule 
kushilevitz rabin considered probabilistic notion progress defined follows 
ci ith critical section started si set processes ci ci access single shared variable time interval 
linear fairness process si enter critical section ci enters section ci probability omega si 
informally linear fairness ensures round ci ci process participates round fair chance enter providing starvation freedom statistical sense 
theorem kushilevitz rabin exists mutual exclusion algorithm satisfying linear fair ness uses single theta log log bit shared variable accessed fetch primitive 
kushilevitz rabin constructed algorithm uses constant size variable price fairness algorithm probability omega si definition linear replaced omega 
worth mentioning interested deterministic algorithms strictly higher lower bound omega log bits starvation free algorithms tight 
related kushilevitz investigated relationship fairness randomized algorithms 
proof technique interesting right algorithms modeled markov chains finite automata move determined statistically lower bounds deduced properties chains 
particular proved space complexity kushilevitz rabin algorithm tight 
theorem kushilevitz mutual exclusion algorithm satisfies linear fairness shared variable omega log log bits 
exclusion 
exclusion problem posed fischer generalization problem processes may critical sections time 
freedom property modified guarantee progress face undetectable failures 
words long processes fail halting process section eventually enters critical section 
halting failure different shutdown discussed halting process sets variables default values 
anderson local spin algorithms exclusion problem 
algorithm covered 
thought may exclusion problem efficiently solved simply queue lock algorithms section process waits queue critical sections 
approach problematic 
see consider simple unrealistic queue exclusion algorithm 
shared variable counts numberof processes may safely enter critical sections 
initially process enter critical section waits queue enqueue dequeue normal element function returns true multi line atomic shared variable initially queue initially process true noncritical section hif fetch dec enqueue await element fi critical section fetch od shared variable initially process true noncritical section entry fetch dec await fi fi critical section fetch exit od exclusion atomic queue procedures 
algorithm am simple local spin exclusion algorithm cc machines 
statements enclosed angle brackets 
lines lines execute atomically trivially invariant 
aside multi line atomic statements difficulties involved implementing 
queue operations typically require atomic steps implemented simple primitives 
second queue imposes linear order waiting processes 
process queue fails processes queue blocked 
note problems disappear process queue 
insight basis algorithms 
specifically anderson moir concentrate solving exclusion processes inductively apply solution solve exclusion processes 
algorithm denoted algorithm am illustrated 
algorithm entry exit inductively assumed implement processes 
shown considering different implementations procedures different space time complexities obtained algorithms adaptive fast path 
algorithm am idea having process queue approximated variable store identifier process queue 
process perform functions dequeuing previously queued process simply assigning process identifier variable algorithm am way queue 
straightforward see busy waiting loop line algorithm constant number remote memory cc machine 
corresponding algorithms dsm machines 
algorithms strong synchronization primitives 
rise open problem 
open problem exclusion problem solved local spin algorithm uses reads 
group mutual exclusion 
group mutual exclusion problem proposed generalization mutual exclusion problem allows multiple processes execute shared variable session integer num integer initially queue initially wait array boolean need array integer process private variable integer true noncritical section session attend wait false need entry session num num session num session num wait true enqueue fi exit await wait session tii entry num num num session need head need session delete num num wait false fi od fi exit od algorithm km simple local spin group mutual exclusion algorithm 
critical sections simultaneously 
problem processes vie execute sessions multiple processes may simultaneously execute session different sessions active time 
process requests attend session eventually able 
process requested session process currently attending requesting attend session waiting processes leave session 
exclusion problem generalizes readers writers problem 
see note problem solved allowing readers request session requiring writers request 
group mutual exclusion problem defined solved 
keane moir local spin solution 
cover keane moir solution 
keane moir algorithm denoted algorithm km shown 
algorithm km local spin mutual exclusion algorithm 
entry exit sections denoted entry exit 
process dedicated spin location wait uses block session requested safely entered 
shared variable need record algorithm employs shared queue processes blocked 
accessed critical sections lines really sequential data structure 
fact sequential queue suffices main insight algorithm 
process executes lines determine wait 
requests session processes waiting may join session current session stored session number processes participating stored shared variable num 
current session differs processes participating records session lines 
remaining possibility current session differs exist process processes participating 
case block lines 
finishing session decrements num line checks see exist released lines 
case num holds line 
condition holds processes seeking join session requested process head unblocked lines 
concluding remarks mutual exclusion problem topic active research inception day 
survey prove useful supplement raynal book researchers interested problem 
hope open problems mentioned fuel continued topic 
grateful faith detailed comments earlier drafts ofthis 
abraham dolev herman koll 
self stabilizing exclusion 
theoretical 
afek attiya 
adaptive long lived renaming 
unpublished manuscript 
afek attiya 
long lived renaming adaptive 
inproceedings th annual acm symposium principles distributed computing pages 
acm may 
afek merritt 
fast wait free renaming 
proceedings th annual principles distributed computing pages 
acm may 
afek 
long lived adaptive collect applications 
proceedings th annual symposium foundations computer science pages 
ieee october 
afek 
long lived adaptive splitter applications 
distributed comput ing 
alur attiya 
time adaptive algorithms synchronization 
proceedingsof th annual acm symposium theory computing pages 
acm may 
alur 
results fast mutual exclusion 
proceedings th time systems symposium pages 
ieee 
alur 
contention free complexity shared memory algorithms 
information april 
alur 
fast timing algorithms 
distributed computing 
anderson 
fine grained solution mutual exclusion problem 
acta informatica may 
anderson jain jeffay 
efficient object sharing quantum real time systems 
inproceedings th ieee real time systems symposium pages 
ieee december 
anderson 
kim 
adaptive mutual exclusion local spinning 
proceedings symposium distributed computing pages october 
anderson 
kim 
improved lower bound time complexity mutual exclusion 
inproceedings th annual acm symposium principles distributed computing pages august 
anderson 
kim 
new fast path mechanism mutual exclusion 
distributed computing january 
anderson 
kim 
local spin mutual exclusion fetch primitives 
proceedingsof rd ieee international conference distributed computing systems may appear 
anderson 
kim 
nonatomic mutual exclusion local spinning 
proceedings acm symposium principles distributed computing pages july 
anderson moir 
local spin exclusion algorithms improve wait free object imple 
distributed computing september 
anderson 
yang 
time contention tradeoffs multiprocessor synchronization 
computation january 
anderson 
performance spin lock alternatives shared memory multiprocessors 
parallel distributed systems january 
attiya 
adaptive efficient mutual exclusion 
proceedings th symposium principles distributed computing pages 
acm july 
attiya :10.1.1.55.2079
adaptive wait free algorithms lattice agreement renaming 
pro ceedings th annual acm symposium principles distributed computing pages 
acm july 
attiya 
adaptive long lived renaming read write operations 
cs faculty computer science technion haifa 
buhrman garay moir 
long lived renaming fast 
proceedings th annual acm symposium principles distributed computing pages 
acm august 
burns 
mutual exclusion linear waiting binary shared variables 
acm sigact news pages summer 
burns fischer jackson lynch peterson 
data requirements implementation process mutual exclusion single shared variable 
journal acm january 
burns lynch 
mutual exclusion indivisible reads writes 
proceedings allerton conference communication control computing pages 
burns lynch 
bounds shared memory mutual exclusion 
information computation december 
singh 
adaptive solutions mutual exclusion problem 
distributed computing 
courtois parnas 
concurrent control readers writers 
acm 
craig 
queuing spin lock algorithms support timing predictability 
proceedings real time systems symposium pages december 
cypher 
communication requirements mutual exclusion 
proceedings seventh parallel algorithms architectures pages june 
dijkstra 
solution problem concurrent programming control 
communications acm 
dijkstra 
self stabilizing systems spite distributed control 
selected writings personal perspective pages 
springer verlag berlin 
dwork herlihy waarts 
contention shared memory algorithms 
journal acm november 
fischer lynch burns borodin 
resource allocation immunity process failure 
inproceedings th annual ieee symposium foundations computer science pages 
ieee october 
fu 

circular list mutual exclusion scheme large shared memory multi processors 
ieee transactions parallel distributed systems june 
gafni mitzenmacher 
analysis timing mutual exclusion random times 
inproceedings th annual acm symposium principles distributed computing pages 
acm 
graunke 
synchronization algorithms shared memory multiprocessors 
june 

huang 
fast fair mutual exclusion shared memory systems 
proceedings international conference distributed computing systems pages june 

huang 

comment circular list mutual exclusion scheme memory multiprocessors 
ieee transactions parallel distributed systems april 
johnson 
prioritized multiprocessor spin lock 
ieee transactions parallel systems september 


asynchronous group mutual exclusion 
distributed computing november 
keane moir 
simple local spin group mutual exclusion algorithm 
proceedings th annual acm symposium principles distributed computing pages may 

arbitration common modifiable variables 
acta informatica 

kim anderson 
time complexity bound adaptive mutual exclusion 
proceedings ofthe th international symposium distributed computing pages october 

kim anderson 
space time efficient local spin spin lock 
information september 
knuth 
additional comments problem concurrent programming control 
communications ofthe acm 
wisniewski scott 
scheduler conscious synchronization 
acm transac tions computer systems february 
kushilevitz mansour rabin zuckerman 
lower bounds randomized 
siam journal computing december 
kushilevitz rabin 
randomized mutual exclusion algorithms revisited 
proceedings th annual acm symposium principles distributed computing pages august 
lamport 
new solution dijkstra concurrent programming problem 
communications august 
lamport 
new approach proving correctness multiprocess programs 
acm programming languages systems july 
lamport 
mutual exclusion problem part theory interprocess communication 
acm 
lamport 
mutual exclusion problem part ii statement solutions 
journal acm 
lamport 
fast mutual exclusion algorithm 
acm transactions computer systems february 
lehman pnueli 
justice fairness ethics 
proceedings th icalp 
lecture notes computer science vol 
springer verlag july 
hadzilacos 
come served mutual exclusion algorithm small commu nication variables 
acm transactions programming languages systems october 
lynch shavit 
timing mutual exclusion 
proceedings th ieee real symposium pages 
ieee december 
markatos 
multiprocessor synchronization primitives priorities 
proceedings real time programming pages 
pergamon press 
mellor crummey scott 
algorithms scalable synchronization shared memory multi processors 
acm transactions computer systems february 
mellor crummey scott 
scalable reader writer synchronization shared memory cessors 
proceedings third acm symposium principles practice parallel programming pages 
acm april 
merritt 
speeding lamport fast mutual exclusion algorithm 
letters 
michael scott 
fast mutual exclusion contention 
technical report tr university rochester rochester ny 
moir anderson 
fast long lived renaming 
proceedings th international distributed algorithms pages september 
moir anderson 
wait free algorithms fast long lived renaming 
science october 
peterson 
myths mutual exclusion problem 
information processing letters june 
pfister norton 
hot spot contention combining multistage interconnection networks ieee transactions computers october 
rabin 
process mutual exclusion bounded waiting log valued shared variable 
computer system sciences august 
raynal 
algorithms mutual exclusion 
mit press cambridge massachusetts 
rhee 
lee 
efficient recovery spin lock protocol preemptive shared memory multiprocessors 
proceedings th annual acm symposium principles distributed computing pages may 
rivest pratt 
mutual exclusion problem unreliable processes preliminary report 
inproceedings th annual ieee symposium foundation computer science pages 
ieee 
scott 
non blocking timeout scalable queue spin locks 
proceedings st symposium principles distributed computing pages 
acm july 
scott scherer 
scalable queue spin locks timeout 
proceedings acm symposium principles practice parallel programming pages 
acm june 

improving fast mutual exclusion 
proceedings th annual acm symposium distributed computing pages 
acm august 
szymanski 
mutual exclusion revisited 
proceedings fifth jerusalem conference infor mation technology pages 
ieee october 


deriving scalable algorithm mutual exclusion 
proceedings th distributed computing pages 
springer verlag september 
wisniewski scott 
scalable spin locks multiprogrammed systems 
inproceedings eighth international parallel processing symposium pages april 
wisniewski scott 
high performance synchronization algorithms multiprocessors 
proceedings fifth acm symposium principles practices parallel programming pages 
acm july 

yang anderson 
fast scalable mutual exclusion algorithm 
distributed computing august 
zhang yan casta neda 
evaluating designing software mutual exclusion algorithms memory multiprocessors 
ieee parallel distributed technology pages spring issue 

