conformance testing real time systems stavros tripakis propose new framework black box conformance testing real time systems 
framework model partially observable non deterministic timed automata 
argue partial observability non determinism essential features ease modeling expressiveness implementability 
framework allows user define appropriate modeling assumptions environment system test sut interface tester sut 
consider types tests analog clock tests digital clock tests 
algorithm generate tests fly determinization specification automaton execution test turn relies reachability computations 
costly problematic tester quickly react actions system test 
provide techniques allow analog clock testers represented deterministic timed automata minimizing reaction time simple state jump 
provide algorithms static fly generation tests 
tests measure time finite precision digital clocks essential condition implementability 
propose technique location edge state coverage specification reducing problem covering symbolic reachability graph 
avoids having generate tests 
report prototype tool ttg case studies lighting device bounded retransmission protocol 
experimental results obtained applying ttg bounded retransmission protocol show tests suffice cover thousands reachable symbolic states specification 
key words conformance testing real time timed automata specification analog digital coverage tool case studies 
verimag laboratory centre equation avenue de gi res france 
web imag fr 
email imag fr verimag laboratory cadence berkeley labs university avenue suite berkeley ca usa 
web www cadence com cadence labs 
email tripakis cadence com contents timed automata inputs outputs real time sequences 
timed labeled transition systems 
timed automata 
timed automata inputs outputs 
parallel composition taio 
parallel composition 
timed input output conformance examples 
timed input output conformance relation tioco 
definition 
lazy inputs needed specifications 
making specifications input enabled 
transitivity 
undecidability 
compositionality 
decreasing number observable actions 
comparison tioco conformance relations 
comparison relativized timed conformance relation 
comparison conformance relation tioco 
modelling issues 
modeling assumptions environment 
modeling input output variables 
modeling interfacing delays 
tests analog clock tests 
analog clock tests total functions 
analog clock tests ta 
execution analog clock test 
correctness requirements 
digital clock tests 
execution digital clock test 
correctness requirements 
test generation generating analog clock tests 
soundness strictness completeness 
generating digital clock tests 
soundness completeness 
reducing size digital clock tests 
generating ta testers monitor case 
clock determinization ta 
equivalence relation 
monitor construction 
computing coarsest partition induced 
accepting rejecting states 
example monitor construction 
extrapolation techniques 
generating ta testers general case 
input output locations 
generation algorithm 
example test taio construction 
soundness completeness 
coverage observable graph 
coverage criteria 
generation algorithm 
generating location covering suite 
generating state covering suite 
generating edge covering suite 
extending path test tree 
finiteness number obtained tests complexity 
limitation generation algorithm 
tool case studies ttg 
lighting switch 
automatic test generation ttg 
comparison manually generated tests 
bounded retransmission protocol 
model brp 
automatic test generation ttg 
perspectives list figures compositional specification internal unobservable actions 
interacting taio 
examples specifications implementations 
examples specifications implementations 
transform deterministic fully observable input enabled specification equivalent input enabled specification 
comment example showing transformation incorrect non deterministic partially observable specifications 
counter example showing tioco compositional case non input enabled taio 
tioco tioco 
specification including assumptions environment generic scheme left example task scheduler right 
specification composed interface delay automata 
analog clock test represented taio function 
extending specification tester clock model possible models 
generic test generation scheme 
digital clock test top alternative representations bottom 
illustration equivalence 
non deterministic timed automaton 
clock deterministic monitor automaton 
taio produce 
times 
computing precise monitor automaton mon precise amon 
possible analog clock test taio automaton considered taio input outputs 
example extend path observable graph og test tree 
ttg tool 
lighting device 
test generated automatically ttg 
digital clock tests covering global locations specification 
brp specification interfaces 
brp transmitter receiver 
test generated ttg brp case study ensuring coverage parameter 
list algorithms fly analog clock test generation 
line digital clock test generation 
clock determinization ta 
test taio generation 
construction observable graph og 
generation location covering suite 
testing fundamental step development process 
consists applying set experiments system system test sut 
exist types testing multiple aims checking correct functionality measuring performance 
interested called conformance testing aim check conformance sut specification 
sut black box sense knowledge internals state known rely observable input output behavior 
focus attention real time systems 
systems operate environment strict timing constraints 
examples systems embedded control systems automotive aerospace domains mobile phones multimedia systems 
testing real time system sufficient check sut produces correct outputs 
checked timing outputs correct 
timing outputs depends timing inputs 
turn timing applicable inputs determined outputs 
classical testing frameworks mealy machines see finite labeled transition systems see 
formalisms suited modeling real time systems 
mealy machines inputs outputs synchronous reasonable assumption modeling synchronous hardware delays inputs outputs governed complex timing constraints 
testing methods ltss time typically abstracted away timeouts modeled special actions interpreted output observed property quiescence 
problematic timeouts need instantiated concrete values testing happens seconds output fail 
systematic way derive timeout values durations expressed specification 
rely empirical ad hoc methods 
model quite popular past decade modeling real time systems model timed automata ta :10.1.1.43.9418
number methods testing realtime systems variants model similar models timed petri nets proposed see 
methods limitations 
restricted subclasses timed automata considered limiting expressiveness specifications 
example consider ta outputs isolated urgent 
condition states state automaton output single action 
specification input received output expressed model 
worse second condition states state output possible time elapse 
essentially means outputs emitted precise points time 
specification input received output emitted time units expressed 
works consider deterministic subclasses ta 
instance event recording automata ta model restricted clock resets 
works assume specifications fully observable meaning assumed events observed tester 
restrictions limit applicability methods 
specification able leave freedom potential implementations especially choosing different outputs output times 
argue partial observability non determinism essential ease modeling expressiveness implementability 
second limitation analog clock tests considered works 
tests observe delays inputs outputs precisely 
example test emit received time units announce pass announce fail analog clock test 
analog clock tests problematic difficult impossible implement finite precision clocks 
tester implements test example able measure delay announce pass 
practice tester typically sample time periodically say time units 
distinguish interval 
case order sound tester announce pass interval accepting non conforming specifications 
modeling framework allows formally specify implementation considerations derive sound tests provided works 
propose testing framework real time systems lifts limitations 
framework expressive fully handle partially observable non deterministic timed automata 
implementable tests generate implemented digital clocks finite precision 
framework previous publications :10.1.1.132.515
unifies extends results publications 
summarize main characteristics framework 
model specifications timed automata input output unobservable actions loss generality single unobservable action 
automata non deterministic sense action time lead automaton different states 
models arise practice 
specifications usually built compositional way components 
greatly simplifies modeling 
illustrates fact shows specification solid line box communicating external world observable interface solid arrows 
specification built internally components dotted boxes 
components communicate signals unobservable external world dotted arrows 
abstractions low level details simplify modeling manage complexity 
abstractions instance hide variables behavior typically results non determinism 
general timed automata unobservable actions removed :10.1.1.43.9418
argued practice models 
checking performing determinization undecidable 
user left alternatives 
attempt fit specification deterministic fully observable ta model framework handles non determinism partial observability directly 
clearly alternative hardly feasible practice especially large specifications consisting components implies user perform determinization model manually 
order capture conformance sut specification propose formal relation called timed input output conformance tioco 
inspired untimed conformance relation ioco 
main difference ioco uses notion quiescence absence outputs observable 
tioco quiescence want timeouts explicitly specified said 
instance allow specifications stating eventually occur occur time units 
apart important difference tioco similar spirit ioco intuitively conforms observable behavior specified possible outputs behavior subset possible outputs compositional specification internal unobservable actions 
tioco time delays included set observable outputs 
permits capture fact implementation producing output early late non conforming 
consider analog clock digital clock tests 
measure time precisely count ticks digital clock occurred events 
framework digital clock modeled timed automaton 
way user full control assumptions execution platform tester execute 
provide examples show model different types digital clocks simple strictly periodic clocks complex clocks jitter skew 
note generating digital clock tests mean assume discrete time setting 
specification continuous time 
sut operates dense time 
tester digital system sampling time digital clock 
propose algorithms generate tests line fly line 
online test generation means test generated essentially execution 
large number computations choices performed resolved fly compute state tester decide wait long line test generation choices resolved generation time 
test usually represented finite tree pass fail annotations leaves 
tester test execution follow tree 
line versus line test generation essentially time versus space trade line generation saves space expense requiring time execution test reaction time 
turn limits reactivity tester actions sut 
hand line test generation requires space store generated tests 
classic test generation algorithms pre processing step consisting specification 
reasons explained impossible case timed automata 
solve problem employ different techniques 
case line generation analog clock tests fly subset construction technique 
consists specification fly sequence observed time delays discrete actions 
technique introduced monitoring fault detection purposes 
case line generation analog clock tests tricky 
question represent analog clock tests static way 
immediate thought timed automata 
tester automata deterministic determinization performed test execution back case fly generation 
generating deterministic test non deterministic specification raises undecidability issues discussed 
take pragmatic approach 
suppose user fixes number clocks tester automaton points clocks reset call reset skeleton 
user specify maximum constants clocks compared guards tester 
provide algorithm information generates test represented deterministic timed automaton 
generation digital clock tests line line idea consider tick digital clock discrete action digital clock tests ordinary untimed automata 
automata generated special constructions product input timed automata specification digital clock model 
test generation methods rely symbolic reachability algorithms similar timed automata model checking tools kronos 
test generation suffers state explosion problem model checking 
hand number tests generated specification infinite 
depth number possible tests exponentially large 
limit explosion number tests consider coverage criteria state transition coverage inspired software testing 
criteria drastically reduce number generated tests tests required cover specification small subset set possible tests depth 
provide algorithms generate digital clock tests respect location state edge coverage 
algorithms fact symbolic reachability graph timed automaton node edge associated set locations states edges specification automaton 
covering locations states edges specification reduces covering nodes edges symbolic reachability graph 
implemented real time testing framework prototype tool called ttg 
ttg implemented top environment 
experimented ttg case studies including execution software rover nasa bounded retransmission protocol 
rest document organized follows 
section introduce timed automata inputs outputs 
section define conformance relation tioco illustrate usage examples 
section provides description analog clock digital clock tests 
section show automatically generate tests line line methods 
section presents test generation coverage criteria 
section discusses tool case studies 
section plans 
timed automata inputs outputs real time sequences set non negative reals set non negative rationals 
finite set actions act set act finite length real time sequences act denoted rt act 
rt act empty sequence 
act act rt act act denotes projection act obtained erasing actions act example act act act 
time spent sequence denoted time sum delays example time time 
rest document assume set actions act partitioned disjoint sets set input actions actin set output actions actout 
actions actin actout called observable actions 
assume unobservable action act 
act act 
timed labeled transition systems timed labeled transition system act tuple act td tt set states initial state td set discrete transitions form act tt set timed transitions form timed transitions deterministic tt tt implies tt satisfy conditions tt tt implies tt tt implies tt 
act td tt said rational delay timed transition tt duration rational 
standard notation concerning 
si act ai act rt act rt act general transitions def td tt def def def sn sn def def observable transitions def def def def def sn sn def def sequence form called run sequence form observable run 
timed automata timed automata deadlines model urgency :10.1.1.43.9418:10.1.1.43.9418
timed automaton act tuple act finite set locations initial location finite set clocks finite set edges 
edge tuple source destination locations guard conjunction constraints form integer constant set clocks reset zero lazy delayable eager deadline act action 
timed automaton defines infinite denoted la states pairs clock valuation 
valuation assigning clock sa set states sa initial state 
discrete transitions form act edge satisfies obtained resetting zero clocks leaving unchanged 
timed transitions form edge delayable exist eager 
notice lazy edges impact semantics simply denote edge delayable eager 
types impact semantics 
lazy edges block time progress delayable eager edges 
allow delayable edges guards form eager edges guards form latest time guard true 
earliest time guard true 
state sa reachable exists rt act sa set reachable states denoted reach 
timed automata inputs outputs timed automaton inputs outputs taio timed automaton set actions act actin actout 
clarity explicitly include inputs outputs definition taio write actin actout act 
taio called observable edges labeled 
set inputs act actin taio called input enabled respect act accept input act state reach act 
simply said input enabled act actin 
called lazy input respect act deadlines transitions labeled input actions act lazy 
called lazy input lazy input respect actin 
note input enabled imply lazy input general 
act called deterministic act act act act act interacting taio 
reach act called non blocking reach rt actout time 
condition guarantees block time environment 
set timed traces taio defined rt act set observable timed traces defined obsttraces pact rt act 

defined taio called timed input output lts 
stated considered taio defined respect sets actin actout unobservable action 
taio denoted actin actout td tt act td tt 
parallel composition taio time easier write models modular way 
consider models product interacting components 
introduce notion parallel composition case taio 
taio act act act act act act act act 
pair taio said compatible respect pair action sets act act sets act act act act act act pairwise disjoint ai input enabled respect act 
illustrated 
incoming arrows denote input events outgoing arrows output events 
solid lines denote observability dotted lines non observability 
assume ai respect act order avoid having time blocked due internal actions awaiting input automaton 
notice assumption refers internal input actions external inputs product automaton 
taio synchronise time shared common actions act act 
connected interaction taio assumed unobservable outside 
assume compatible respect act act 
parallel composition denoted 
taio actin actout actin smallest set act actout act act act act act act act lazy lazy 
parallel composition similarly useful define parallel composition 
corresponding parallel product denoted 
li si acti act act act 
sets act act act act act act pairwise disjoint illustrated 
synchronize time delays common shared actions act act act 
parallel product actin actout td tt actin td tt smallest sets act actout act tt act act td act act td act td 
difficult see possible run possible extract unique timed traces respectively 
example act act act 
conversely traces obsttraces obsttraces respectively said synchronizable exists run traces extracted 
general run extracted may unique due different possible interleavings instance traces extracted run 
new 
sets inputs outputs li 
synchronize set actions act 
obsttraces obsttraces obsttraces obsttraces run obsttraces observable timed trace corresponding 
lemma traces extracted synchronizable obsttraces 
proof assume loss generality unobservable action 
projection run actin actout act 
obsttraces li exists li projection act exist jn km lm ai jn ain ak lm simi exist ai ain ak 
clearly ai ain ak extracted possible synchronize traces considering trace rn rp js lt act act act act 
sequence ap ais akt appears rp js ap ais appears rp lt ap akt appears 
considering way possible synchronize trace nan defined similarly rp 
done 
act act act act act act act act taio 

proposition compatible respect act act la la proof clearly equal iff initial state set transitions 
difficult see initial state la la la arbitrary transition 
abuse notation write la possible transition la prove la la la 

possible iff possible 
defined way accept time delay iff accepted 
definition la la iff possible possible 
rule la la iff 
holds 
possible 
edges labeled guard deadline set clocks reset see rule 
definition la rule holds 
possible 

act act possible iff 
act act possible iff reasoning act act holds 

act possible iff possible 
follows immediately rules 
definition la rule holds 
timed input output conformance describe testing framework 
assume specification system tested non blocking taio 
assume implementation system tested modeled non blocking input enabled taio ai 
notice assume ai known simply exists 
required implementation accept inputs tester state possibly ignoring moving error state case illegal inputs 






spec impl 
impl 
impl examples specifications implementations 



spec 


impl 
impl 



impl examples specifications implementations 
examples proceed define conformance relation give examples illustrate meaning testing framework 
examples input actions denoted output actions denoted mentioned deadlines output edges delayable deadlines input edges lazy 
order overload figures draw input enabled implementation automata 
assume implementations ignore missing inputs 
modeled adding self loop edges covering missing inputs 
note specifications assumed input enabled missing inputs different meaning correspond don cares explained 
consider specification spec shown 
spec expressed english follows received system output earlier time units 
implementations impl impl conform spec 
impl produces exactly time units reception impl produces time units 
impl impl conform spec 
impl may produce time unit early 
impl fails produce 
consider specification spec shown 
specification expressed input system output time units input system output time units failing output time units 
second branch spec typical specification timeout 
normal result appear time system recognize error output error message 
implementations conform spec react input ignore 
hand impl impl conform spec 
notice impl accepts input appear spec 
example don care input mentioned 
specification states case input provided 
imposes requirements case implementation free behave wishes 
timed input output conformance relation tioco section define conformance relation tioco state properties compare specifications set observable traces show equivalent respect tioco 
compare tioco timed trace inclusion relation 
show lazy inputs needed specifications deterministic specifications input enabled changing conformance semantics 
remaining part section prove transitivity undecidability compositionality tioco stability respect decreasing number observable actions 
definition order formally define conformance relation define number operators 
taio rt act set states reached timed sequence projection observable actions 
formally sa rt act pact 
state sa elapse set delays elapse making observable action 
formally elapse rt time 
state sa set observable events outputs passage time occur system state definition naturally extends set states formally actout elapse 
timed input output conformance relation denoted tioco defined ai tioco iff obsttraces ai 
relation states implementation ai conforms specification iff observable behavior set observable outputs ai behavior matching subset set possible observable outputs 
notice observable outputs observable output actions time delays 
expected examples impl tioco spec impl tioco spec 
hand impl tioco spec impl tioco spec impl impl spec 
proceed giving number properties tioco 
states specifications set observable timed traces equivalent respect tioco words specify requirements 
lemma taio obsttraces obsttraces ai ai tioco ai tioco proof obsttraces obsttraces 
claim 
actout implies obsttraces obsttraces contradicts hypothesis 
implementation ai ai iff ai result follows definition tioco 
lemma relates tioco observable timed trace inclusion 
lemma consider taio 
obsttraces obsttraces implies tioco 
input enabled tioco implies obsttraces obsttraces 
proof 
obsttraces 
implies obsttraces 
obsttraces obsttraces obsttraces 

result follows definition tioco 

suppose exists obsttraces obsttraces 
exist rt act act obsttraces obsttraces 
actin obsttraces contradiction obsttraces input enabled 
actout contradiction obsttraces tioco gives example second part lemma hold input enabled 
impl tioco spec obsttraces impl obsttraces spec 
lazy inputs needed specifications examples far input edges specifications annotated lazy deadlines delayable eager 
coincidence 
show section considering lazy input taio describing possible non blocking specifications 
lazy input taio edge labeled actin deadline lazy 
taio lazy taio obtained setting deadline edge labeled input lazy 
lemma non blocking taio obsttraces obsttraces lazy 
proof clear obsttraces obsttraces lazy lazy permissive transition defined transition defined lazy 
remains prove obsttraces lazy obsttraces 
suppose exists obsttraces lazy obsttraces 
sn possible run lazy corresponding trace 
obsttraces exist sk possible path sk location clock valuation respectively sk 
depending value cases possible 
lazy 
lazy 
lazy 
lazy 
lazy qdc 
lazy 
lazy 
lazy transform deterministic fully observable input enabled specification equivalent input enabled specification 
act construction location outgoing edges labeled actions deadlines clocks reset lazy 
valuation discrete transition sk sk possible lazy possible contradiction 
fact sk means delayable eager outgoing edge prevents delay 
labeled output action block time lazy 
labeled input action 
implies state sk time blocked input action received contradicts hypothesis non blocking 
lemma lemma obtain 
proposition non blocking taio ai ai tioco ai tioco lazy 
making specifications input enabled deterministic fully observable specification input enabled changing conformance semantics adding edges covering missing inputs leading don care location inputs outputs accepted 
precisely transformation done follows 
taio act build corresponding input enabled taio act 
qdc qdc don care location 
second qdc qdc true lazy act qdc lazy actin actin 
guards outgoing edges labeled example showing transformation works 
transform 
taio input output 
added edges dashed ones 
proposition spec deterministic fully observable taio spec input enabled taio corresponding spec obtained transformation 
input enabled taio impl impl tioco spec iff impl tioco spec 
proof proposition lemmata 
lemma obsttraces spec obsttraces spec 
proof spec obtained adding edges spec added edges deadline lazy 
lemma obsttraces spec 
obsttraces spec spec spec 
spec spec actout 
proof obsttraces spec qdc location reached spec behavior spec 
obsttraces spec sink location qdc reached 
spec defined respect set outputs actout spec spec actout 
spec actout spec spec 
give proof proposition 
proof proposition assume impl tioco spec prove impl tioco spec 
obsttraces spec 
obsttraces spec lemma spec spec 
impl tioco spec impl spec 
impl spec done 
obsttraces spec lemma spec actout 
clearly impl spec done 
assume impl tioco spec prove impl tioco spec 
obsttraces spec 
lemma obsttraces spec lemma spec spec 
impl spec impl tioco spec obsttraces spec 
impl spec done 
combined lemma proposition implies deterministic fully observable specifications tioco replaced timed trace inclusion modulo transformation 
notice proposed transformation correct case non deterministic partially observable specifications 
simple counter example 
specification spec input outputs implementation impl input enabled 
impl tioco spec impl tioco spec 
note determinization taio undecidable general 
reducing tioco timed trace inclusion possible specific framework checking conformance respect tioco needs established case non deterministic partially observable specifications 
omit self loops labeled order overload 


impl 
spec 

spec 
qcd 
example showing transformation incorrect nondeterministic partially observable specifications 
transitivity show tioco transitive relation usual assumption implementations input enabled 
interesting property relation tioco 
instance may helpful case specification model obtained refinements 
proposition taio input enabled tioco tioco tioco proof obsttraces 
cases possible obsttraces 
tioco tioco obtain 
obsttraces 
part lemma input enabledness tioco get obsttraces 

result follows definition tioco 
undecidability section show undecidability tioco result theoretical interest instance check directly testing known implementation conforms specification 
proposition checking tioco undecidable 
proof reduce timed trace inclusion problem timed automata known undecidable problem checking tioco :10.1.1.43.9418
ta set actions act 
timed trace inclusion problem consists checking obsttraces obsttraces 
actout act actin 
input enabled 
part lemma obsttraces obsttraces iff tioco worth noting undecidability tioco problem black box testing implementation ai unknown check conformance directly anyway 
compositionality prove tioco compositional 
succeed check conformance modules respect models product modules conforms product models 
task easier checking conformance module levels easier cheaper checking conformance product level 
taio ai sets inputs outputs shown 
suppose automata respect respective sets inputs 
furthermore suppose compatible respect act act compositionality result 
proposition tioco tioco tioco 
proof observe set inputs actin act act set outputs actout act act 
prove input enabled respect act act 
state pair si state ai 
assumption ai input enabled respect act 
act si 
act act 
reasoning input enabled respect act act 
show tioco 
lemma suffices prove obsttraces obsttraces 
act actin actout act act act obsttraces 
act internal unobservable actions exists pr act 
acti act act act observ able actions ai pr acti 
obsttraces 
part lemma input enabledness ai assumption tioco ai get obsttraces ai 
lemma synchronizable obsttraces 
note result generally hold case non input enabled taio 
counter example 
consider taio taio 
action dashed arrows shared act act act act act act 
taio input enabled respect 
input enabled respect 
guards transitions automata equal true deadline lazy 
clearly tioco 
difficult see tioco 
shows product automata receiving input 












counter example showing tioco compositional case non taio 

may generate output may generate tioco 
decreasing number observable actions section prove stability tioco respect decreasing number observable actions 
input enabledness assumption succeeds prove conformance sut considered specification respect set observable actions conformance holds respect smaller set observable actions 
example due reason observable action longer accessible longer observable affect conformance 
taio observable action act denote taio obtained replacing action appears 
result 
proposition input enabled taio observable action act tioco tioco 
proof prove input enabled 
act set inputs acta actin act actin output act actin input 
exactly set states input enabled result follows 
manner prove input enabled 
lemma suffices prove obsttraces obsttraces 
obsttraces 
exists trace obsttraces act 
input enabled tioco obsttraces lemma 
act obsttraces 
result valid non input enabled taio general 
counter example 
consider taio mentioned tioco 
easy see clearly tioco 
comparison tioco conformance relations different conformance relations literature context timed testing 
review compare tioco 
define conformance timed bisimulation tb case reduces timed trace equivalence tte determinism assumed 
define conformance may preorder mmp 
impl impl conform spec respect tb tte mmp 
believe strict 
define conformance timed trace inclusion 
stated lemma generally stricter tioco tioco allows implementation accept inputs accepted specification 
instance impl tioco spec obsttraces impl obsttraces spec 
stated lemma specification input enabled tioco equivalent 
stated proposition may replace tioco case deterministic fully observable specifications modulo input enabling transformation 
note noted issue arise outputs assumed urgent spec expressed 
transformation performed care taken instruct test generation algorithm explore added don care inputs generate useless tests 
opt tioco avoids complications simple way 
compare tioco conformance relations proposed literature 
comparison relativized timed conformance relation relativized timed conformation relation defined 
relativized sense compares implementation specification respect environment 
assumed input enabled respect actin input enabled respect actout 
non blocking 
comparing step consists making parallel composition parallel composition slightly different propose 
avoid confusion denote different hide actions synchronize condition action remains observable synchronization 
formally defined follows iff obsttraces function obsttraces extended natural way case 
follows obsttraces obsttraces obsttraces similarly obsttraces obsttraces obsttraces 
able compare tioco extend conformance relation tioco natural way case 
result 
proposition input enabled non blocking 
furthermore environment input enabled non blocking 
tioco 
proof obsttraces 
obsttraces obsttraces obsttraces obsttraces 
implies 
obsttraces 
cases possible obsttraces 
obsttraces obsttraces obsttraces implies obsttraces 
tioco implies obsttraces 
exist rt act act prefix obsttraces obsttraces 
input enabled deduce actout 
tioco obsttraces obsttraces deduce 
means obsttraces turn means obsttraces 
done 
result shows tioco capture simply modeling assumptions environment requirements system test separately composition see section 

lazy 


lazy 
tioco tioco comparison conformance relation tioco conformance relation denoted tioco introduced 
main goal propose testing framework extends notion quiescence case timed systems 
relation tioco bears lot similarity tioco 
defined respect 
considered assumed non blocking 
specification implementation step comparing consists identifying quiescent states 
state said quiescent starting discrete output generated input received 
detected quiescent state self loop added corresponding 
action models fact output generated 
new obtained denoted respectively 
relation tioco defined respect arbitrary duration duration obsttraces act state set states tb actin tb 
conformance relation tioco respect denoted tioco defined follows tioco iff 
tioco tioco different 
possible find examples conformance respect tioco respect tioco 
simple example 
simplicity taio 
example difficult see tioco possible value clearly tioco produces receiving input 
check direction 
assume duration tioco want know tioco holds 
introduce intermediary result 
lemma non blocking set states 
actout 
authors term forced inputs non blocking 
notion input enabledness introduce slightly strict 

actout proof 
point obvious 
follows immediately definitions 

assume 
quiescent clearly 
case quiescent non blocking exist actout 
need consider done 
direction obvious 
give result 
proposition non blocking input enabled duration tioco tioco proof obsttraces 
obsttraces 
definition difficult see 
similarly 

cases possible 
actout actout lemma know 
tioco lemma done 

point lemma actout tioco 
actout point lemma done 
practice clearly infeasible check implementation really produced action waited time 
alleviate problem authors extra assumption implementation quiescent 
said quiescent state state quiescent 
intuitively means upper bound reactivity react assumed react 
extensive discussion various untimed conformance relations see 
modelling issues main goal section illustrate methodological aspects framework 
show possible alleviate modeling issues regarding environment assumptions interface conditions tester sut timed automaton model framework 
requirements sut assumptions environment arrive 
finish 
arrive 
finish 
arrive 
arrive 
specification including assumptions environment generic scheme left example task scheduler right 
modeling assumptions environment sut supposed operate correctly particular environment environment 
brings issue incorporate assumptions environment building model specification 
shows done 
specification modeled compositionally parts part modeling environment assumptions part nominal behavior sut environment requirements 
case interactions components unobservable exported inputs outputs global specification 
simple example situation shown 
specification expresses schedulability aperiodic task typical real time operating system assuming minimal inter arrival time task time units task executed time units 
notice environment assumptions generally specification non input enabled 
example second arrive input accepted time units elapsed arrive 
order keep specification non blocking urgency inputs set lazy 
modeling input output variables ta model uses notion input output actions implying event interface tester sut 
practice systems communicate external world input output variables 
show model situations framework 
basically possibilities specify real time requirements related variables 
refer variable updates refer value durations 
modeled framework action update 
second corresponds amount time variable keeps value 
modeled action point time variable changes value value interest action moment variable changes different value 
example assume input variable output variable 
consider requirement updated time units updated 
notice updated environment tester updated sut 
update introduced input action update output action 
specification modeled ta similar spec replaced update replaced update case guard changed 
specification 

input output 
delay delay simple input delay 
bt 
automaton specification composed interface delay automata 
simplistic way modeling supposes updates immediately perceived sut tester occur 
obviously true 
instance sampling controller typically reads inputs periodically may write outputs soon ready 
case specification requires output produced time units input sampled controller updated environment 
situation modeled framework explicitly adding automata modeling sampling sut side tester side 
fact add automaton called tick automaton order generate digital clock tests see section 
tick automaton models sense sampling tester side 
similar automaton model sampling sut side difference tick event case input event 
elaborate interfaces event handlers buffering modeled long expressed extended timed automata 
modeling interfacing delays example modeling methodology show model interfacing delays tester sut 
amount time needed messages transmitted sut environment 
done composing specification delay automata shown 
simple input delay automaton shown right 
input action original action output command tester 
automaton models assumption tester output may experience delay time units perceived sut 
notice automaton allow new input produced previous transit 
complicated automaton necessary buffers input events 
point mentioned elaborate interfaces modeled explicitly 
user full control assumptions tester equipment affect generated tests 
tests test test case experiment performed implementation agent tester 
different types tests depending capabilities tester observe react events 
consider types tests terminology borrowed 
analog clock tests measure precisely delay observed actions emit input point time 
terms input output mean input output implementation 
write test emits input emits output 
follow convention drawing test automata 
example edge labeled 
taio corresponds tester emitting execution test 
digital clock tests count ticks digital clock occurred actions emit input immediately observing action tick 
simplicity assume tester implementation started precisely time 
practice achieved having tester issuing start command implementation 
noted consider adaptive tests terminology action tester takes depends observation history 
adaptive tests seen trees representing strategy tester game implementation 
due restrictions specification model essentially remove non determinism implementation strategy existing methods generate non adaptive test sequences 
analog clock tests analog clock tests represented total functions taio 
analog clock tests total functions analog clock test specification act total function rt act actin wait pass fail 
specifies action tester take observes 
actin tester emits input wait tester waits lets time elapse 
pass fail tester produces verdict stops 
represent valid test satisfy number conditions rt act time pass fail rt act pass fail rt act condition states test reaches verdict bounded time called completion time test 
condition suffix closure property ensuring test recall verdict 
need ensure test block time instance emitting infinite number inputs bounded amount time 
done specifying certain conditions defined states sequences rt act 
initial state 
actout transition transition provided wait 
actin transition convention states pass collapsed single sink state pass similarly fail 
require states non blocking condition pass fail reached 
analog clock tests ta analog clock tests represented taio 
example test defined right part equivalently represented taio shown test moves pass observes sequence time distance captured timed automaton bounded number clocks 
related fact timed automata test definition deterministic 

pass 

fail eager 
wait wait fail 
fail 
pass analog clock test represented taio function 
left part 
function partially defined 
remaining cases covered suffix closure property pass fail condition 
instance 
fail fail 
execution analog clock test execution test implementation ai defined parallel composition defined ai usual synchronization rules transitions carrying label 
denote product ai execution test reaches pass fail verdict bounded time 
implementation non deterministic non observable verdict need experiments runs product 
declare implementation passes test require possible experiments lead pass verdict 
implies order gain confidence pass test executed multiple times implementation known deterministic 
formally say ai passes test denoted ai passes state fail reachable product ai say implementation passes resp 
fails set tests test suite passes tests resp 
fails test correctness requirements say analog clock test suite sound respect ai ai tioco ai passes say complete respect ai ai passes ai tioco 
soundness minimal correctness requirement 
weak tests sound useless announcing pass 
completeness hand usually impossible achieve finite test suite see section 
motivated define notion 
say test strict respect ai ai passes ai tioco 
definition says strict test announce pass implementation behaved non conforming manner execution test 
untimed setting similar notion lax tests proposed 
test shown sound strict respect spec 
consider arbitrary implementation ai ai passes ta obtained test removing node fail incoming edges 
ai passes obsttraces ai obsttraces 
clearly specification actin actout tick automaton 
tick 
tick jitter tick 
eager perfectly periodic tick tick 
eager eager tick 
tick 
delayable tick skew extending specification tester clock model possible models 
obsttraces obsttraces 
obsttraces ai obsttraces 
lemma ai tioco 
changing fail state test pass yield test sound longer strict 
digital clock tests consider specification act tick new output action act digital clock test total function act tick actin wait pass fail 
digital clock test observe input output actions plus action tick assumed output tester digital clock 
assume tester digital clock modeled tick automaton special taio single output action tick 
assume clock reset ticks priority observable actions tick occur time tick observed 
assumptions action observed th st tick tester knows occurred time interval case periodic digital clock time unit period 
digital clock periodic 
possible tick automata shown 
models perfectly periodic clock period equal time units case th tick occurs precisely time 
second automaton models clock skew case th tick may occur interval 
third automaton models clock jitter case th tick may occur interval 
notice automaton contains unobservable transitions ones deadline eager 
examples show different models digital clocks 
realistic model digital clock depends digital clock application 
aimed show framework allows user decision explicitly relying implicit unrealistic assumptions encoded framework 
validity conditions similar analog clock apply digital clock 
test defines states act tick labels act tick 
state wait self loop transition labeled reason transitions missing states actin pass fail assume digital clock test emits immediately event observed 
execution digital clock test execution digital clock test defined forming parallel product ones test implementation ai tick automaton 
tick implicitly synchronizes ai time 
tick explicitly synchronizes transitions labeled tick 
parallel product built tick transitions priority observable transitions 
state product tick outgoing transition 
definition passes digital clock tests similar analog clock tests ai replaced ai tick correctness requirements set digital clock tests tick automaton said sound respect tick ai ai tioco ai passes say complete respect tick ai ai passes ai tioco 
say test strict respect tick ai ai passes ai tick tioco tick 
case relation conformance tioco ai tick tick action tick considered output 
digital clock tests strict general 
expected tester distinguish outputs produced exactly time say time tick happens 
output cases tester observe tick tick 
faulty behavior gives digital clock observation non faulty tester announce pass cases 
weaker notion strictness may introduced case digital clock testing 
weaker sense digital clock test strict due limited observation capability 
formal definition digital clock strictness untimed conformance relation tioco inclusion tick automaton definition 
providing formal definition scope 
test generation adapt untimed test generation algorithm 
roughly speaking algorithm builds test form tree 
node tree set states specification represents knowledge tester current test state 
algorithm extends test adding successors leaf node illustrated 
illegal outputs ai outputs occur state test leads fail 
legal output bi test proceeds node si set states specification emitting bi possibly performing unobservable actions 
exists input accepted specification state test may decide emit input dashed arrow 
node algorithm may decide test label node pass 
ai 

fail aj 
bi 
bj 
si sj generic test generation scheme 
features algorithm worth noting 
algorithm partially specified 
may say algorithm non deterministic 
number decisions need node test continue wait emit input possible input case possible inputs 
choices user defined parameters desired depth test 
randomly systematically book keeping order generate test suite single test 
discuss option detail section 
second feature algorithm implicitly specification automaton 
building si sj corresponds classical subset construction 
performed line test generation line test generation test execution 
test generation test execution termed fly supported tool torx 
generating analog clock tests analog clock tests directly represented finite tree apriori infinite set possible observable delays node 
remedy idea 
represent analog clock test algorithm 
essentially performs subset construction specification automaton execution test 
analog clock testing method classified fly line meaning test generated time executed 
precisely tester maintain set states specification taio 
updated time action observed time delay elapses 
time delay known priori input update function 
define operators rt time act contains states reached state performing action contains states reached state sequence contains observable actions takes exactly time units 
operators implemented standard data structures symbolic representation state space simple modifications reachability algorithms timed automata 
fact sets generally dense due continuous statespace clocks 
sets represented symbolically simple constraints clocks 
instance constraint represents fact clock value clock equal constraints implemented matrix data structure called dbm difference bound matrix :10.1.1.43.9418
computing successor nodes done symbolically bounded time reachability analysis timed automata shown 
test operates follows 
starts state 
current state output received time units entering updated 
event received say time units test update state 
set empty test announces fail 
point input test may decide emit update state accordingly 
line analog clock test generation performed algorithm 
algorithm keeps running long non conformance detected 
time tester testing declare pass 
algorithm uses notation 
nonempty set pick chooses randomly element set states valid inputs defined set valid inputs actin 
notice practical reasons assume sut rational delay clock algorithm ranges rational values 
possible consider dbm structure symbolic successor computation 
true clock measuring time await output received received endif announce fail exit endif valid inputs pick send input continue observation endif pick valid inputs endif endwhile algorithm fly analog clock test generation 
soundness strictness completeness prove algorithm sound 
proposition verdict fail observed executing algorithm ai tioco 
proof rt act trace corresponding interaction tester ai starting algorithm announcement fail 

algorithm actout 
ai 
contains 
fail declared 
ai ai tioco 
prove algorithm strict 
proposition ai possible implementation test generated algorithm ai tioco ai fail proof algorithm works online simple trace rt act 
ai tioco exists prefix ak ak ai ak 
ak 
algorithm execution ak lead verdict fail done 
algorithm parameterized time elapse tester waits time units announcing timeout occurs duration accepted specification 
furthermore algorithm complete sense non conforming implementation rational ai exists execution algorithm detects non conformance implementation 
proposition ai rational delay 
ai tioco exists execution announces fail 
proof ai tioco exists act obsttraces actout ai 
ai obsttraces ai 
induction length easy show tester ai may interact produce 
assume 
ai algorithm force pick choose duration 
ai accepted ai tester continues running algorithm announce fail 
ai actin ai accepted algorithm detect valid inputs force tester send immediately ai ai 
ai actout algorithm decides wait ai generates output 
ai accepted ai implementation output ai 
tester receives immediately announce fail ai accepted 
generating tester wait output generated implementation 
tester calculates current estimation tester 
actout calculates 
cases 
tester announces immediately fail non conformance detected 
generating digital clock tests conformance relation tioco ideal sense captures non conformance sut infinite precision time measuring level 
instance case unit periodic digital clock guard sut impl replaced impl non conforming 
fact true guard replaced 
reasonable define tioco ideal way want conformance depend implementation details tester equipment 
hand tester capabilities limited practice testers dispose finite precision digital clock counter distinguish observations elude clock precision 
framework takes limitation account 
allow user explicitly model assumptions tester digital clock 
second generate tests respect model 
set observable events finite act tick digital clock test represented finite tree 
case decide generate tests line line 
matter space time trade 
line method require space store generated tests 
hand test computed line longer reaction time test computed line takes time compute state test 
independently option choose proceed follows 
form product atick tick extended specification atick may include automata model environment assumptions interface delays shown previously 
yields new taio inputs inputs outputs outputs plus new output tick tick 
notice tick synchronize discrete transitions synchronize time time elapses rate 
define set observable discrete traces respect tick tick act tick obsttraces tick 
example time unit periodic tick automaton trace obsttraces tick tick tick atick 
trace called digitization respect tick 
define operator atick rt 
contains states reached state sequence contains observable actions 
notice construction atick duration bounded tick observable occur bounded duration 
apply generic test generation scheme 
root test tree defined atick 
successors node computed follows 
actout tick edge provided edge fail 
possible choice node said output node 
exists actin test generation algorithm may decide emit adding edge second choice said input node 
notice asymmetry ways computed 
reason tester assumed emit input immediately entering contain immediate successors line digital clock test generation performed algorithm 
notation algorithm 
worth noticing algorithm may produce test tree infinite depth 
avoid force test generator go case depth test big 
choices case case correspond possibilities considering current node output input node respectively 
atick node tree root true foreach leaf distinct pass fail valid inputs pick pick endif case pick valid inputs append edge case foreach actout tick append edge append edge fail endif case replace pass endwhile algorithm line digital clock test generation 
difficult see algorithm transformed straightforward way line digital clock test generation algorithm 
case longer need storing considered test 
tester observe outputs generated sut tick actions generated digital clock 
time time tester decide send inputs sut 
choices tester non deterministically 
soon tester reaches empty set announce fail testing 
soundness completeness prove algorithm generates sound tests 
proposition test generated algorithm 
verdict fail observed applying test case ai ai tioco 

tick tick tick tick tick tick tick tick tick fail pass 
pass 
fail tick tick 
pass 
tick 
tick fail digital clock test top alternative representations bottom 
proof act tick trace corresponding interaction tester ai starting announcement fail 

algorithm actout tick 
fail announced occurrence set possible reachable states executing non empty 
execution leads fail 
interaction tester ai instantaneous exists obsttraces ai digitization 
cases possible obsttraces execution time delay elapse observed 
ai deduce ai tioco 
tick true tick action highest priority tick occurred ai tick elapses tick 
contradiction 
actout 
trace ai 
implies 
ai tioco 
obsttraces rt act act prefix obsttraces obsttraces 
actin contradiction fact algorithm chooses valid input actions actions valid inputs 
actout done 
algorithm complete general 
due digital clocks 
example consider periodic tick automaton period time units ticks generated times 
suppose specification states output emitted time 
tester observes tick tick accept sequence conforming may emitted interval 
emitted time order tester sound announce fail 
course means non conforming implementation emits time remain undetected 
prove completeness algorithm extra assumptions 
considered assumptions mainly called digitization techniques 
reducing size digital clock tests digital clock tests grow large contain number chains ticks 
hand standard test description languages permit variables richer data structures 
features representation digital clock tests compact 
example test shown top equivalently represented automaton counter shown bottom left 
reducing size test representations non trivial problem general related compression algorithmic complexity theory called kolmogorov complexity 
context heuristic attempts eliminate tick chains possible 
purpose generalize labels digital clock test labels form tick positive integer constant 
transition labeled tick taken th tick received counting time source node entered 
naturally tick equivalent tick 
consider nodes tick act successors identical tick case remove node corresponding edges add edge tick repeat process nodes removed 
result applying heuristic test top shown bottom right 
generating ta testers monitor case motivation representing analog clock tests deterministic timed automata arises fact line testing requires time efficient reachability algorithm tester able react sut real time 
problem generating analog clock test taio trivial undecidable depending precise definition 
require test sound problem trivial test announcing pass sound 
hand require test complete test exists show problem undecidable reducing timed automata determinization problem 
take pragmatic approach 
suppose tester clock reset time tester observes action edge tester taio 
provide techniques compute locations edges tester automaton guards deadlines edges 
noted technique easily extended generate testers clock provided skeleton tester 
skeleton deterministic finite automaton transitions labeled resets clocks tester 
information necessary number clocks clock exist possible testers differ logic resetting clocks 
special case event clock tester clock observable action reset action occurs event clock automata 
clock determinization ta pedagogical reasons explain technique plain timed automata seen taio empty set input actions 
automaton technique amounts best possible may exist specification non deterministic test deterministic 
clock 
formally deterministic counterpart denoted amon accept superset 
notice may contain unobservable actions non determinism 
viewing specification amon monitor amon taio inputs outputs amon observable deterministic input enabled 
locations input locations 
amon uses single clock reset zero time action observed 
amon tries estimate state current observation including value clock 
amon urgency constraints deadlines lazy amon non blocking 
amon needs urgency acts acceptor generator traces 
hand states amon including locations values clock divided accepting rejecting 
equivalence relation act suppose new clock set states extended clock rx action act ea set edges labeled set extended states value clock define set edges ea ea 
ea contains edges labeled satisfied state equals define equivalence values clock iff ea ea 
intuition follows 
values equivalent give information enabledness edge labeled assuming holds 
captures current knowledge monitor 
particular captures relation values possible states 
illustrate meaning example shown 
assume outgoing edges labeled guards respectively 
induces equivalence classes 
assumption implies 
know hold enabled 
similarly know enabled 
may enabled 
important note states satisfy similarly 
information sure 
need include set possible enabled edges constraint 
monitor construction explain construction monitor automaton amon 
location amon associated set extended states action equivalence class coarsest partition induced amon edge lazy destination location computed follows succ shortcut 
illustration equivalence 
succ denotes set states 
notice empty non empty 
may unsatisfied note best possible estimate sense smallest set possible knowledge monitor arrives 
knowledge captured 
monitor knows state outside knows clock satisfies restricts possible states 
automaton extended clock recall ay denotes initial state initial location amon defined 
captures initial knowledge monitor 
rt say say knows initially clocks equal zero 
include states move performing unobservable sequences 
algorithm essentially subset construction addition clock infer knowledge states possibly 
construction relies repeating basic steps computing partition induced equivalences computing successor locations reachability 
show step implemented 
step standard symbolic reachability techniques coupled called extrapolation abstractions ensure number possible locations amon remains finite 
computing coarsest partition induced simple algorithm computing coarsest partition induced 
constraint clock es ea guard guard guard edge es contains edges labeled guards may satisfied state lies interval 
words es union ea values satisfying 
delayable non deterministic timed automaton 
greatest constant appearing constraint defining guard edge ea 
set intervals compute condition guard needs checked 
done symbolically standard techniques data structures dbms 
computed intervals coarsest partition obtained merging union intervals having set example 
notice correctness algorithm relies fact values interval equivalent true interval 
constraints integer constants 
accepting rejecting states remains define accepting rejecting states amon 
projection clock 
states amon accepting provided 
rest states rejecting 
different steps constructing monitor automaton algorithm 
worth noting bears similarity common reachability algorithm 
example monitor construction give example illustrating construction amon 
consider non deterministic timed automaton shown 
edges lazy location location delayable 
clock monitor automaton shown 
locations edges monitor shown order overload 
particular empty location edges leading shown 
instance edge labeled guard initial location empty location accepted arrives time units start 
apart empty location rejecting states monitor location notice 
received time units order accepted 
note rejecting states location 
monitor know ay list list node ta initial location compute rejecting states corresponding list pick list foreach actout coarsest partition induced foreach succ append edge lazy compute rejecting states corresponding list list list endif append edge fail lazy endif list list list list endwhile algorithm clock determinization ta 
reject clock deterministic monitor automaton 
original automaton location urgency location 
true 
extrapolation techniques question arises termination algorithm 
operator may lead infinite set states zones 
cases exact set reachable states representable finite unions zones 
second problem avoided restricting class timed automata considered diagonal free automata guards form 
alleviate problem called extrapolation abstractions 
abstractions result finite state space ensuring termination reachability algorithms 
extrapolation abstractions rely maximal integer constants guards timed automaton question 
case raises issue determining constant bound space monitor clock clock participate guard priori construction monitor constant 
show increasing maximal constant amounts increasing observational power monitor 
fact cases optimal monitor greater maximal constant allowed precise amon sense close language amon language example shown 
taio shown produce single output time 
seen monitor able compare constants accurate monitor able compare constants 
distinguish 
happening precisely time time strictly greater 
observation algorithm 
cases possible build precise monitor automata partitions finer induced equivalence relations algorithm 
example illustrate 
checked applying algorithm ta obtain monitor automaton amon note issue pointed fabrice chevalier patricia 
eager 
taio produce 
times 
amon mon computing precise monitor automaton mon precise amon 
deterministic clock ta amon distinct 
due fact clock ta reset transition clock supposed 
initial location amon labeled set states 
output action consider relation equivalence coarsest partition respect intervals shown second hidden leads fail location 
monitor automaton mon obtained considering finer partition intervals change bring algorithm 
steps remain unchanged 
difficult check obsttraces obsttraces amon obsttraces obsttraces mon 
amon mon monitor automata mon precise amon obsttraces mon obsttraces amon 
inclusion strict traces obsttraces amon obsttraces mon 
general forward algorithm propose determine partition sufficiently fine precision purposes rely finest possible partition region graph 
approach taken 
method opts monitors weaker observational power efficient construct store 
generating ta testers general case consider general case taio input output actions 
case monitor tester supply inputs sut 
formally tester analog clock test taio denoted defined section 
input output locations case digital clock tests analog clock test taio distinct types locations input locations output locations 
outgoing edges input location labeled output actions 
tester occupying location just waits outputs coming implementation reacts accordingly 
second type locations location exactly outgoing edge labeled input action edges labeled output actions 
output location tester input action send implementation precise timing 
tester occupies output location waits till time sending corresponding input happens 
output received time tester reacts accordingly 
send specific input action implementation precise chosen time continues execution test strategy accordingly 
generation algorithm algorithm constructing generalization algorithm building amon 
amon location set choice marking location input output algorithm non deterministically 
locations marked input outgoing edges computed shown previous section case actout 
equivalence output locations order mark location output edge labeled actin guard 
marked output edges rational value chosen guard condition exists 
edge eager added computed shown previous section 
notice deadline edge eager want output emitted urgently precise point time 
note find integer value satisfying condition pick rational value multiply construction constants automaton sufficiently large constant integer 
interval outgoing edges labeled input actions computed exactly case input locations 
difference compute partition interval set reals states defined accepting rejecting amon 
rejecting states correspond tester emitting fail verdict 
hand specific point time tester emits pass 
execution test go long tester remains accepting state 
user test tired waiting 
different steps constructing test taio algorithm 
algorithm valid inp edges denotes set edges guard labeled input actions 
ay list list location taio initial location list pick list valid inp edges pick endif pick valid inp edges rational value guard label succ append edge eager list list list endif endif foreach actout coarsest partition induced foreach succ append edge lazy list list list endif append edge fail lazy endif list list list list endwhile compute rejecting states input locations algorithm test taio generation 

eager 
possible analog clock test taio automaton considered taio input outputs 
example test taio construction example analog clock test taio test taio corresponds automaton 
purpose example considered taio input outputs write 



respect tester output inputs 
initial location output location input locations 
tester receives input action time interval fail verdict emitted test stopped 
input received interval tester produces action exactly time resets clock waits inputs 
possible behaviors accepted tester time elapse receiving input interval receiving input exactly time 
behaviors observed test may stopped time pass verdict emitted 
behavior observed test stopped fail verdict emitted 
soundness completeness discuss soundness completeness algorithm 
prove algorithm sound 
test taio generated algorithm 
proposition verdict fail observed applying ai ai tioco 
proof rt act trace corresponding interaction tester ai starting announcement fail 

algorithm actout cases possible obsttraces restriction possible assume act node reached execution set states associated clearly insert case 
fail announced duration accepted leads way rejecting state 

ai tioco 
actout element current partition induced 
fail announced succ 
way ai tioco 
obsttraces ak obsttraces ak obsttraces 
ak actin contradiction fact algorithm chooses valid input edges edges valid inp edges 
ak actout done 
algorithm complete general 
example shows depending kind partitions mistakes detect 
coverage mentioned section digital clock test generation algorithm takes input extended specification model atick generates test form tree 
nodes tree correspond sets states atick nodes marked input output 
algorithm partially specified 
completed specifying policy marking nodes input output choosing possible outputs emit choosing test 
way resolve choices randomly 
may satisfactory completeness guarantees required repetitions avoided possible 
possibility generate exhaustive test suite depth specified user 
approach suffers explosion problem number tests generally exponential remedy problems approaches proposed generating test suites respect coverage criterion 
different coverage criteria proposed software statement coverage branch coverage 
ta case existing methods attempt cover finite abstractions state space region graph time abstracting quotient graph structural elements specification edges locations 
method generating test cases coverage criteria proposed 
coverage criteria encoded observer automata 
propose new technique covering states locations edges specification 
mentioned technique relies assumption outputs specification urgent isolated 
technique relies concept observable graph 
observable graph observable graph og composed automaton tick initial node graph rt atick generated follows 

generated node act tick successor node generated edge added graph 
extrapolation abstractions ensure graph remains finite 
way constructing observable graph og algorithm 
atick list list og node graph initial node list pick list foreach actin actout tick actin endif append edge og list list list endif endif list list list list endwhile coverage criteria algorithm construction observable graph og 
node og corresponds set states tick say node covers hand static test tree essentially sub graph og 
say test covers union sets states covered nodes 
say set tests test suite achieves state coverage reachable state covered test suite 
unreachable states ignored play role regarding conformance 
similarly node og covers location contains state 
test suite achieves location coverage reachable location covered test suite 
built compositionally distinguish global local location coverage 
global location coverage require reachable global locations covered 
global location vector qn number components qi local location component local location coverage simply require reachable individual locations components covered 
clearly test suite achieving global location coverage achieves local location coverage converse generally true 
similarly test suite achieving state coverage achieves local global location coverage converse true 
edge og associated set edges 
particular edge associated edges visited reachability algorithm computes formally unobservable sequence edges path covered edge say test suite achieves edge coverage reachable edge edge enabled reachable state covered test suite 
test suite achieving edge coverage achieves local location coverage 
may achieve global location state coverage 
define action coverage follows 
edge reachable corresponding observable action said reachable 
action coverage achieved reachable observable actions covered considered test suite 
clearly action coverage weaker edge coverage 
note coverage criteria way defined interpreted merely way guide test generation algorithm 
claim test suite achieving say global location coverage guarantees coverage execution 
guaranteed simply execution partly controlled system test 
decides outputs emit tester implicitly decides parts nodes test tree covered 
course define notion execution coverage book keeping locations specification covered execution tests 
case guaranteed locations covered implementation may simply allow reach parts specification state space said 
generation algorithm give algorithm generate test suite achieving coverage respect criterion 
step build observation graph atick tests extracted statically og coverage achieved 
consider location coverage 
tests extracted follows 
generating location covering suite reachable locations covered algorithm picks location say picks node og associated node exists reachable finds path og initial node extends path explained section 
new test added set tests generated algorithm repeats choosing new uncovered location locations covered 
different steps generating location covering suite algorithm 
notice algorithm essentially search finite graph nodes input nodes nodes output nodes 
generating state covering suite state covering suite extracted similar way 
state covered find node og covering extract test including 
notice test cover set states containing cover region belongs 
guarantees algorithm terminates finite test suite set states infinite 
list set reachable locations list pick list node og associated path og initial node extension test tree list list set locations covered endwhile algorithm generation location covering suite generating edge covering suite algorithm similar edge coverage difference finding path reaching target node og algorithm finds path reaching target edge far uncovered edge 
extending path test tree done completing path missing edges labeled tester inputs 
edge considered path actout tick 
ai actout tick ai vi edge observable graph edge ai pass added path 
edge fail added 
general idea continue extending test tree way 
policy single test cover locations possible 
example extend path test tree 
observable graph og path 
shows test tree path extended 
example considered system inputs outputs input action omit outgoing edges initial node path 
edges appear second location outgoing edge labeled output action 
location output actions appear actions tick lead pass appear og fail appear og expected output specification 
finiteness number obtained tests complexity difficult see reachable state exists node og covering state similarly locations edges 
covering nodes edges og suffices achieve coverage criteria 
og finite finite number tests suffices achieve coverage algorithm terminates 
worst case complexity algorithm polynomial size og 
finding node edge og associated location edge linear 
finding path og extending path test tree linear 
steps performed times nodes og 
tick 

og 


tick 
pass 
pass pass fail example extend path observable graph og test tree limitation generation algorithm drawback algorithm generate minimal test suites 
test suite minimal sense test removed suite coverage longer achieved 
clearly non minimal suite contains redundant tests remove tests 
hand suite minimal suite tests possible 
notice minimal imply minimal number sort local optimum second global optimum 
general minimal minimal number suites unique 
adding new test suite may result making previously generated tests redundant 
studying efficient methods generating minimal minimal number test suites scope 
tool case studies ttg built prototype test generation tool called ttg top environment 
modeling language allows specify systems consisting processes communicating message passing shared variables includes features hierarchy priorities dynamic creation complex data types 
tool suite includes simulator model checker connection untimed test generator tgv 
ttg implemented independently tgv 
ttg written uses basic libraries parsing symbolic reachability timed automata deadlines 
digital clock tests generated ttg point 
shown ttg takes inputs specification tick automata written language set user options specifying test generation mode 
modes interactive user guides test generation algorithm resolving non deterministic points issue output wait input output possible generating test 
random non deterministic points resolved randomly 
touch button specification file tick automaton file eager single 
touch 
eager touch 
double 
touch 
actions file ttg test generator user options ttg tool 
single double lamp single 
bright 
bright 
double 
dim 
bright 
double 
lighting device 

single 
test cases files single 
double 
exhaustive possible tests generated user defined depth 
dim 
delayable dim dim bright coverage set tests achieves user defined coverage criterion generated 
criteria implemented currently state location action partial state coverage variables appearing model 
fact ttg generate tests 
generates executable program test generator depicted 
program generates tests tests depending chosen mode 
test generator additional options instance exhaustive test generation user specifies desired test depth running test generator running ttg 
tests output language 
rest section small case studies treated ttg 
lighting switch case study modification 
modified specification shown 
models lighting device consisting modules button module handles user interface touch sensitive pad lamp module lights lamp intensity levels dim bright turns light 
user interface logic follows single touch means level higher double touch quick consecutive touches means level lower 
assumed higher lower modulo single touch light bright turns 
device communicates external world input touch outputs depth time coverage criteria sec tests config 
local loc 
global loc 
actions table exhaustive test generation results lighting device case study 
dim bright 
events single double internal communication modules synchronous rendez vous unobservable external user 
button module uses timing parameter specifies maximum delay consecutive touches considered double touch 
lamp module uses timing parameters specify minimum maximum delay lamp change intensity warm halogen bulb 
order overload omit guards resets deadlines lamp module 
placed similarly ones shown resets inputs guards deadlines outputs 
automatic test generation ttg ttg generate digital clock tests specification parameter set respect perfectly time unit periodic ticker 
results exhaustive generation various depth levels shown table 
depth levels ranging 
column depth shows depth generated tests length longest path root leaf 
column time shows time seconds taken ttg generate test suite respect corresponding coverage criterion 
column tests shows number tests suite 
remaining columns show coverage percentage different considered criteria 
notice sets possible tests specified depth test selection performed 
worth noticing order perform complete coverage considered criteria need consider exhaustive test suite depth test cases 
ttg perform test selection case study respect considered criteria 
obtained results shown table 
column size shows number elements covered 
ttg succeeds achieve coverage criteria action coverage criterion 
succeeds generate test suite test cases depth ranging form coverage rate 
tests generated ttg shown 
drawing produced automatically eps tool written marius dot graphviz utility www graphviz org 
input tick input dim loc loc informal accept pass input tick loc input tick loc input input bright input dim input input dim input bright input tick input input bright main loc output touch input test generated automatically ttg :10.1.1.43.9418
loc input bright fail input dim criterion size time depth coverage criteria sec tests config 
local loc 
global loc 
actions config 
local loc 
global loc 
actions table test generation results lighting device case study 
comparison manually generated tests section show possible reduce number tests generated ttg achieving coverage respect considered criteria 
manually generated tests bigger size 
consider instance tests shown 
order overload node tests labeled set corresponding global locations states omitted 
output nodes draw outgoing edges lead fail 
example node leftmost test outgoing edges labeled dim bright 
leading fail 
save space draw tree dag directed acyclic graph 
seen tests cover local locations 
difficult check tests cover edges 
fact see tests walk trough observable edges specification 
remains check unobservable edges covered 
true visited pairs successive ticks tests nodes tests successive ticks labeled pairs global locations single global locations nodes 
tests achieve global location consequently state coverage 
example location covered 
global locations covered 
covering rest possible generate tests extend tests 
instance append rightmost test leftmost 
order cover location say consider node leftmost test output node input node issuing possible output touch 
keep remaining part test unchanged 
doing obtain single test depth achieves global location coverage 
alternatively suite tests lengths smaller suffices achieve global location coverage 
suite generated algorithm section 
notice depth leftmost test 
generating exhaustive test suite depth infeasible due explosion 
bounded retransmission protocol bounded retransmission protocol brp protocol transmitting files unreliable lossy medium 
architecture protocol shown 
protocol implemented transmitter receiver 
users protocol sending receiving clients 
medium modeled forward backward channels 
receiving file sending client action put transmitter fragments file packets sends packet receiver action send awaiting acknowledgment packet sent action ack 
timeout occurs receiving acknowledgment transmitter resends packet maximum number touch 
touch 
tick 
tick 
tick 
bright 
bright 
bright touch 
bright touch 
bright tick 
bright tick 
tick 
dim 
dim 
dim touch 
dim touch 
dim tick 
dim tick 
tick 


pass touch 
tick 
tick 
dim 
dim 
dim touch 
dim tick 
dim tick 
tick 
bright 
bright 
bright touch 
bright tick 
bright tick 
tick 


pass digital clock tests covering global locations specification 
sending client put dk abort transmitter send forward channel send ack backward channel ack receiving client get abort receiver brp specification interfaces 
file transmitted successfully transmitter output sending client 
transmitter responds abort action abort packet failed middle don know action dk packet case file may may received 
case success receiving client receives file action get 
case receiver hear transmitter time outputs abort receiving client 
model brp brp model developed 
model initially developed sdl automatically translated 
model shown 
states red labeled decision transient states meaning time elapse automaton moves states interrupted concurrent automata 
transmitter clocks repeat abort receiver clock abort 
keyword clock guard provided precedes guard discrete variables 
keyword task assignments 
model parameterized parameters number packets file max retry maximum number retries sending packet timeout dt repeat timeout delay dt abort time transmitter waits outputting abort dr abort time receiver waits outputting abort 
values case study max retry dt repeat dt abort dr abort 
testing view components enclosed dashed square brp specification 
sending receiving clients play role environment explicitly modeled assumptions environment 
interface sut environment captured actions put input get dk abort abort outputs 
automatic test generation ttg ttg generate tests perfectly periodic tick automaton clock period equal respect various coverage criteria 
results shown table 
model brp web page www verimag imag fr async examples 
clocks reset negative value count upwards 
essential difference ta model earlier 
send input ack void provided max retry true task decision provided middle true output abort set abort dt abort provided false task task decision provided true task task deadline lazy input put task task task output sdt tr set repeat dt repeat wait ack repeat reset repeat decision provided max retry false provided middle false output dk set abort dt abort abort output abort reset abort wait abort input ack void provided false output ack rt provided task main start task idle provided task task middle task input sdt decision input ack decision provided false main start task false idle input ack void provided true task reset repeat decision provided middle provided abort reset abort provided true output ack rt set abort dr abort task decision provided middle task provided output get reset abort brp transmitter receiver :10.1.1.43.9418
criterion size time depth coverage criteria sec tests config 
locations actions config 
locations actions table test generation results brp case study 
criteria state locations actions values discrete variables model case study term configuration state measuring coverage 
configuration corresponds entire symbolic state includes vector locations values variables automaton plus dbm representing symbolically set clock states 
configuration set ta states 
count configurations count ta states 
reachable configurations total global locations count transient locations actions input output actions plus tick 
variables booleans encode alternating bit transmitter receiver respectively 
variable takes possible values middle file 
variable takes possible values max retry 
variable takes possible values notice configuration criterion requires tests criteria covered just test 
configuration criterion depth varies 
rest columns show percentage coverage criteria test suite generated criterion 
example test covering global locations covers configurations amounts approximately total number configurations 
interesting finding experiments relatively small number tests suffices cover reachable configurations specification fact cover states product automaton atick 
worth comparing number number tests generated exhaustive depth option 
shown table size exhaustive test suite grows large relatively small depths 
table shows percentage criteria covered exhaustive test suite 
seen number tests large small percentage coverage achieved instance configuration coverage tests depth 
number tests size important 
looking test generation algorithm test obtained completing path say size test essentially depth 
see table largest test depth 
explained follows 
implementation heuristic choose configuration cover pick configuration far initial large depth 
expectation cover configurations possible new test 
heuristic tends favor generation fewer longer tests 
obviously different approach favor shorter forward backward channels modeled lossy fifo buffers 
buffers remain bounded reception messages eager 
depth time coverage criteria sec tests config 
locations actions table exhaustive test suites brp case study 
tests 
done changing heuristic pick configurations close initial 
test generated ttg configuration coverage option shown 
perspectives proposed testing framework real time systems partially observable non deterministic timed automata formal conformance relation called tioco 
provided algorithms generate analog clock digital clock tests line line fashion 
shown number generated tests reduced coverage criteria 
reported prototype test generation tool 
believe opens number interesting perspectives 
touched problem test execution 
building actual test harness particularly challenging real time context timing accuracies critical 
digital clock tests crucial respect allow formally define assumptions accuracy tester clocks take account test generation 
topic coverage deserves studied depth real time context 
notions coverage mainly extend known notions developed software 
imagine alternative notions exploit knowledge domain particular respect timing constraints topology 
notice applying coverage specification level usually software applied system test white box 
methods generate minimal test suites redundant tests examined 
combining coverage line test execution issue little explored 
problem related choosing online tester outputs output times 
heuristics applied resolve choices additional problem manage choices execution entire test suite appropriate book keeping techniques 
perspective study testing problems real real setting conformance testing problem 
classic testing problems include state identification problems 
preliminary done direction problems remain open 
direction techniques developed testing contexts instance controller synthesis 
acknowledgments fabrice chevalier patricia comments monitor generation 
grateful marius help input get input get input tick input tick loc input tick loc input abort input get input tick input abort input dk input tick input get loc loc input get input abort input dk input abort input abort input tick input tick pass fail loc input dk input abort input dk input get input tick input abort input abort input dk loc input get input abort input abort input get loc output put input dk loc input abort input abort input abort main loc output put loc input abort input abort input abort input dk input dk test generated ttg brp case study ensuring coverage parameter :10.1.1.43.9418
implementation ttg top 
express gratitude mohamed contributions implementation ttg 
alur dill :10.1.1.43.9418
theory timed automata 
theoretical computer science 
alur fix henzinger 
class timed automata 
cav volume lncs 
springer 
de vries tretmans 
formal test automation simple experiment 
th int 
workshop testing communicating systems 
kluwer 
bengtsson yi 
clock difference constraints termination reachability analysis timed automata 
volume lncs 
springer 
bensalem tripakis 
testing conformance realtime applications automatic generation observers 
th international workshop runtime verification rv volume entcs pages 
elsevier 
petit 
characterization expressive power silent transitions timed automata 
fundamenta informaticae 

enumerative approach analyzing time petri nets 
ifip congress series 
blom jonsson pettersson 
specifying generating test cases observer automata 
proc 
formal approaches software testing pages 
sifakis tripakis 
modeling urgency timed systems 
compositionality volume lncs 
springer 

forward analysis updatable timed automata 
formal methods system design 
chevalier souza 
fault diagnosis timed automata 
fossacs volume lncs pages 
springer 
fernandez graf 
validation environment timed asynchronous systems 
proc 
cav volume lncs 
springer 
graf vincent 
sdl real time missing 
proceedings sam nd workshop sdl msc grenoble france pages 
imag june 

testing timing behavior real time software 
international software quality week 
brat giannakopoulou goldberg havelund lowry pasareanu visser 
experimental evaluation tools martian rover software 
sei software model checking workshop 
brinksma tretmans 
testing transition systems annotated bibliography 
volume lncs 
springer 
brinksma 
test generation framework quiescent real time systems 
fates volume lncs 
springer 
oliver 
conformance test experiments distributed real time systems 
issta 
acm press 
chow 
testing software design modeled finite state machines 
ieee transactions software engineering 
clarke ron 
stg symbolic test generation tool 
tacas volume lncs 
springer 
clarke lee 
automatic generation tests timing constraints requirements 
rd workshop object oriented real time dependable systems words 
olivero tripakis yovine 
tool kronos 
hybrid systems iii verification control volume lncs pages 
springer verlag 
tripakis 
model checking real time reachability properties abstractions 
tools algorithms construction analysis systems lisbon portugal volume lncs 
springer verlag 
dill 
timing assumptions verification finite state concurrent systems 
sifakis editor automatic verification methods finite state systems volume lncs pages 
springer verlag 
en 
timed test cases generation state characterization technique 
rtss 
ieee 
fernandez ron 
fly verification techniques generation test suites 
cav volume lncs 
springer 
jan groote jaco van de pol 
bounded retransmission protocol large data packets 
algebraic methodology software technology pages 
henzinger manna pnueli 
digital clocks 
icalp lncs 
larsen nielsen pettersson skou 
time optimal real time test case generation uppaal 
fates 
nakata taniguchi 
generating test cases timed automaton model 
ifip int 
test 

syst 
kluwer 
iso iec 
open systems interconnection conformance testing methodology framework part general concept part test suite specification part tree tabular combined notation 
technical report international organization standardization information processing systems open systems interconnection gen 
ron morel 
verification test suites 

ron marchand 
test cases generation nondeterministic real time systems 
fates 
tripakis 
black box conformance testing real time systems 
th international spin workshop model checking software spin volume lncs 
springer 
tripakis 
real time testing timed automata testers coverage criteria 
formal techniques modelling analysis timed fault tolerant systems formats volume lncs 
springer 
tripakis 
expressive implementable formal framework testing real time systems 
th ifip intl 
conf 
testing communicating systems volume lncs 
springer 
tripakis 
state identification problems timed automata 
th ifip intl 
conf 
testing communicating systems volume lncs 
springer 
larsen nielsen 
online testing real time systems uppaal 
fates volume lncs 
springer 
lee yannakakis 
principles methods testing finite state machines survey 
proceedings ieee 
myers 
art software testing 
wiley 
nielsen skou 
automated test generation timed automata 
tacas 
lncs springer 

formal methods test automation hard real time testing controllers airbus aircraft family 

sifakis yovine 
compositional specification timed systems 
th annual symposium theoretical aspects computer science stacs volume lncs 
spinger verlag 
vaandrager argenio 
testing timed automata 
theoretical computer science 
tretmans 
testing concurrent systems formal approach 
concur volume lncs 
springer 
tretmans 
testing techniques 
lecture notes university twente netherlands 
tripakis 
fault diagnosis timed automata 
formal techniques real time fault tolerant systems volume lncs 
springer 
tripakis 
folk theorems determinization minimization timed automata 
formal modeling analysis timed systems formats volume lncs 
springer 

