technical report number reconstructing cl tr issn computer laboratory fraser steven hand rolf neugebauer ian pratt andrew warfield mark williamson august jj thomson avenue cambridge cb fd united kingdom phone www cl cam ac uk fraser steven hand rolf neugebauer ian pratt andrew warfield mark williamson technical reports published university cambridge computer laboratory freely available internet www cl cam ac uk techreports issn generation architecture addresses problems dependability maintainability manageability devices software drivers pc platform 
architecture resolves hardware software issues exploiting emerging hardware features improve device safety 
high performance implementation xen virtual machine monitor provides immediate transition opportunity today systems 
device drivers troublesome aspects commodity operating systems weakness received scant attention pc platform evolved driven overriding goal affordable performance 
longer sufficient merely provide data speeds systems increasingly business critical applications essential review management dependability driver code written runs specific os 
purposes execution inseparable modern systems 
entanglement leads directly problems urgently need addressing growing stake pcs hold today enterprise server environments 
dependability lack isolation execution driver os code sacrifices dependability 
driver errors cause catastrophic system crashes 

maintainability device drivers rewritten os driver code difficult expensive develop maintain 

manageability troubleshooting resolution driver related problems difficult time consuming ongoing administration system 
concerns reflect roots pc architecture desktop platform 
inconvenient system crashes tedious diagnosis hardware problems accepted reconstructing part pc experience workstation users administrators 
years pc mainframes special purpose operating systems enterprise 
second downtime impacts revenue traditional limitations architecture longer tolerated 
presents set changes intended transition dependable maintainable manageable systems 
new system architecture addresses fundamentally unsafe issues current model unrestricted device dma 
architecture built key ideas 
mitigate risks device enforcing isolation device granularity protection domains 
second introduce set simple unified interfaces os driver software 
interfaces provide required separation concerns hitherto conflated aspects systems software 
unify control configuration devices single os agnostic system interface 
approach merely academic proposal 
taken advantage experience high performance virtualization techniques construct complete implementation proposal existing hardware 
prototype solves problems constrained existing hardware provides transition path new system architecture immediate benefit day systems 
subsections discuss fundamental concerns specifically 
dependability drivers pc architecture frequently blamed leading cause system instability 
fact driver code runs privilege address space operating system means simple pointer errors may compromise system stability 
driver confined just pointer errors application process device driver system call interface networking file system cpu scheduler memory mgmt 
traditional interface chipset device application process device driver device application process device driver device traditional architecture devices drivers operating system monolithic domain application process device driver system call interface networking file system cpu scheduler memory mgmt 
device application process device driver safe hardware interface device application process device driver device safe device architecture devices drivers isolated os isolation traditional os lhs versus safe device approach rhs isolates device drivers kernel uses safe hardware interface extend isolation device level 
drivers may leak memory deadlock fail correctly manage interrupts wedge system inside infinite loop 
broad spectrum failure possibilities means making systems dependable requires complete isolation driver execution os applications drivers 
importantly crucial mechanisms provided ensure ongoing device availability recognising reacting driver failures 
approach enforce complete vertical isolation resources including device hardware driver code operating system 
difference new approach traditional os structure shown device drivers executed protection domain restricts access host memory instructions device registers interrupt lines 
section discusses spaces mechanism achieve vertically isolated slices system 
section set techniques address difficult problem recognising driver failure go identify problems simply solved current hardware 
maintainability hardly simple undertaking isolating driver code safety addresses symptom considerably broader architectural problem 
today development driver code tightly coupled individual target operating system 
device vendors maintain separate source trees os hope support 
individual driver os interfaces incredibly complex swift identify interface points linux kernel driver code 
combined fact os interfaces differ syntactically semantically providing different threading models communication primitives means driver requires developers os specific expertise 
coupling benefits inertial force established operating systems 
windows victim interface problem microsoft announced move bit os require new version device driver 
lack common driver os interface inhibitor new oss 
approach unify driver os interface isolation techniques discussed execute driver code completely separate execution context os 
os idealized interface describes class hardware instance storage devices network interfaces 
approach allows single driver number operating systems os specific driver serves entire class devices typically comprises just lines code 
manageability unified access drivers just needed data access perspective administration 
presently tasks diagnosing configuring hardware specific driver os instance 
led instance specific device functionality exposed windows linux vice versa 
ad hoc means devices currently administered equates wasted administrator time costs entails 
unifying control devices addition access hope address administrative concerns 
related current architecture presents multifaceted set challenging problems 
section attempts summarize great breadth previous attempted tackle individual aspects problem 
drawn efforts research 
broad classes related 
large set efforts systems software hardware development safe isolation 
second attempts better structure interfaces devices software oss applications interact 
safe isolation researchers long concerned inclusion extension code operating systems 
extensible operating systems explored broad range approaches support incorporation foreign possibly untrusted code existing os 
swift leverage experiences extensibility interposition improve reliability linux device drivers 
claims improvement system reliability demonstrates risk narrow focus approach sacrifices performance drastically attempt add dependability modifying existing os 
addressing larger architectural problem fixating single os instance provide higher performance solve broader set issues remaining compatible existing systems 
implementation section uses virtualization layer achieve isolation drivers os oss 
providing low level systems layer responsible managing devices initially explored nemesis exokernel 
refines approaches applying existing systems 
additionally whitaker speculate potential uses virtualized approach system composition drawing strongly early microkernel efforts mach 
represents realization ideas demonstrating isolation provided surprisingly low performance overhead 
commercial offerings virtualization vmware esx server allow separate oss share devices 
previously demonstrated approach virtualization provides higher performance moves focus specifically additional concerns driver dependability implementation faster accommodates strictly higher level driver dependability 
research efforts investigated approaches providing isolation pc platform 
recovery oriented computing project goals similar hardware system diagnostics defer standard mechanisms isolation 
intel development environment operating systems supporting ia instruction set uses pci cards proxy requests 
concern mapping device interrupts dma simulated bit environment approach provide device isolation 
intel announced new architecture protect memory device dma 
better interfaces goal providing rigid os device interfaces hardly new 
notably corporate efforts udi attempted just 
key limitations udi directly address 
firstly enforce isolation udi compliant drivers execute protection domain operating system device channels safe efficient interdomain messaging unified interfaces single driver source drivers may shared spaces provide strong vertical isolation driver device instances operating system windows xp device driver device driver safe hardware interface operating system linux device driver device device device space space space device manager software hardware har legacy interfaces original os driver isolated safety driver sharing restart example generation architecture 
mitigation risks posed erroneous drivers 
secondly external perspective avoids trap vendor udi fall victim interface 
providing aggregate interface existing drivers settle narrower idealized interface 
provide mechanisms directly safely expose hardware interface problem experiences large number network storage devices oss 
novel os architectures long struggled lack device driver support 
vast number available devices compounded problem making adoption existing driver interface attractive systems 
microkernel systems fluke investigated wrapping linux device drivers customized interfaces 
structure architecture entirely dissimilar microkernel intent solve driver interface issue operating systems pc architecture set existing drivers single developmental os 
project replaces proprietary bios systems specialized linux image 
approach allows fast startup eases management especially cluster environments console access available 
closely related device control interface intend directly integrated bios 
architecture section outline new architecture addresses dependability maintainability manageability devices control software 
note incorporate hardware modifications necessary desirable deferring section pragmatic design allows limitations existing systems 
requirement driver isolation memory execute logical fault domain cpu schedule prevent excessive consumption privilege limit access instruction set requirement driver device isolation registers restrict access permitted ranges interrupts allow mask receive device interrupt requirement device isolation memory prevent dma arbitrary host memory devices prevent access arbitrary devices table requirements safe hardware illustrated architecture comprises parts correspond directly problems identified 
firstly introduce spaces arrange devices perform isolation rest system 
increases reliability restricting possible harm inflicted device faults 
secondly define set unified interfaces implemented devices particular type 
provides driver portability avoiding need reimplement identical functionality range different os interfaces 
device manager provides consistent control management interface devices simplifying system configuration diagnosis treatment device problems 
isolation reason catastrophic effect driver failure system stability total lack isolation pervades device interactions commodity systems 
issues addressed achieve full isolation outlined table 
concerns divided requirements isolating execution driver code software components ensuring drivers may access device manage enforcing safe device behaviour 
previous attempts driver isolation placed driver code separate logical fault domain essentially providing virtual memory protection driver rest system 
partial solution primarily protects memory logical isolation layer provide isolation scheduling access privileged instructions 
implementation section uses virtual machine monitor vmm achieve required logical isolation driver os code 
tracking retaining full control driver cpu memory vmm provides isolation guarantees analogous os application processes 
example faulty driver attempts access memory location outside heap disallowed vmm signalled device manager described section takes appropriate remedial action 
space isolation layer protects driver domain net logical isolation layer device nic driver domain disk chipset device scsi os pci bus memory access cpu time execution privilege device software hardware chipset protect dma memory inter device access smart devices protect fine grained access space labels achieving safe hardware 
outlined region denotes space vertical slice system providing isolation device driver 
importantly approach addresses problem isolating physical device access 
currently drivers may write arbitrary device registers mask inappropriate interrupts devices may dma invalid memory 
introduce spaces extend notion logical protection domains incorporate resources specific devices driver code 
space vertical slice system providing isolated context device driver 
controller chipset maintains tables access permissions space identifying accessible ranges memory addresses device registers interrupt lines 
space represented numeric identifier attached transaction device driver operating space 
controller uses identifier validate requested operation appropriate permission table 
advantages gained allocating range spaces device 
incorporating notion client identity space enable features client scheduling device safe dma application buffers 
small step predicate bus arbitration requesting spaces allowing differentiated service provided different clients 
implementation section uses virtualization able address physical isolation problems host device access implementing vmm space functionality chipset 
believe isolation achieved strongest possible hardware modifications 
current implementation protect unsafe device dma describe minor modifications necessary take advantage safe dma controller 
emerging hardware research indicates hardware improvements may soon incorporated pc platform 
unified interfaces pc standardized hardware interfaces accepted standard interface system software despite industry efforts 
solution define set idealized high level interfaces tailored class device 
os vendors need implement single small driver device class communicates unified interface developed house developers intimate knowledge os subjected appropriate quality control checks 
implementing unified interface hardware vendors automatically support pc system 
furthermore may arbitrarily choose implementation divided hardware software incorporating functionality higher cost products include advanced features processors 
unified device interfaces provided xen vmm previously demonstrated provides low overhead access common device classes 
essential features required efficient data path communication avoid data copies provide back pressure data source flexible asynchronous notification primitive 
architecture incorporate principles device channels linking unified interfaces exported device drivers operating systems 
provide details software implementation device channels section 
careful design exclude possibility hardware implementation 
concerns regarding feasibility adopting standardized device interfaces relevant acceptance political problem technical 
efforts date great deal success allowing variety networking storage devices function common interface linux netbsd windows xp 
focused classes device believe network disk crucial device interfaces server environment 
presume interfaces identified complete expect evolve time 
experience far shown model valid groups independently ported new devices architecture minimal effort 
argument invoked efforts past particularly motivation expose hardware interfaces 
believe unified interfaces provide considerable benefit acknowledge impossible effectively model devices emerging devices specialpurpose applications considered 
situations allow device access exposed directly mechanism address video sound devices current implementation 
note unified virtualized device interface architecture provides isolation safety 
transitional approach allows architectural benefits realized short term move focus challenging problems sound video interfaces 
additionally worth observing organisations continue move os virtualization means making better server hardware 
unified interfaces particularly advantageous virtualized environment enable device sharing 
example unified interfaces legacy support device sharing shown operating systems device drivers run single machine 
leftmost device drivers unified interface wraps existing driver code 
interface means device drivers may individually scheduled shared operating systems restarted case error 
rightmost operating system contains legacy driver prevents separate scheduling sharing safe hardware interface limit driver privileges 
control management final concern addressed architecture device control configuration area particularly neglected pc evolution 
lack standardized platform wide control interfaces led implementation unique proprietary configuration interfaces os device significant disadvantage ad hoc approach system administrators require additional training os environment machine setup support simply understand multiple different configuration interfaces ultimately provide identical functionality 
transition pc platform server room means manageability important 
current configuration tools inappropriate configuring managing large scale clusters common enterprise environments 
console interfaces suitable configuring small numbers desktop machines major hindrance configuration changes applied hundreds machines time 
growing problem remote management primary motivation project 
final aspect architecture handled device manager essentially extension system bios provides common set management interfaces devices 
device manager responsible boot common device classes enjoy consistent control interface consistency carried different oss 
strapping isolated device drivers announcing device availability oss exporting configuration control interfaces local os remote manager 
design implementation implemented generation architecture current pc hardware xen virtual machine monitor 
described xen divides resources pc system set secure domains runs separate guest operating system applications 
xen implements isolation mechanisms management tasks domain creation resource allocation performed system controller running special domain access privileged control interface 
section describing extended xen virtual machine control interfaces allow safe access hardware 
placing device drivers domain separate os application code configured suitably restrictive hardware access privileges xen provides isolation processor hardware contexts identified requirements section 
incorporate necessary control management services provided device manager architectural outline device management subsystem system controller 
proceed describe guest oss connect drivers domains 
introduce efficient method inter domain communication shared memory asynchronous notifications outline protocol setting device channels core interface links domain system controller 
device channels provide unified abstraction high performance data transfer describe abstraction safely implemented device drivers guest oss 
safe hardware interface safe hardware interface enforces isolation device drivers restricting hardware resources access 
restrict access privileges device registers memory mapped accessed explicit ports interrupt lines 
furthermore possible constraints existing hardware protect device isolating host interactions 
virtualize pc hardware configuration space allowing system controller access determine device resources restricting driver view system see resources access 
registers xen ensures memory isolation domains checking validity address space updates 
access memory mapped hardware device permitted extending checks allow access non ram page frames contain memory mapped registers belonging device 
page level protection sufficient provide isolation register blocks belonging different devices usually aligned page boundary 
addition memory mapped processor families provide explicit access primitive 
example architecture provides bit port space access may restricted port basis specified access bitmap interpreted processor port access attempt 
xen uses hardware protection rewriting port access bitmap domains 
bitmap large sparse domain xen tracks rewrites active words bitmap 
interrupts device interrupt line asserted triggers execution stub routine xen causing immediate entry domain managing device 
way xen retains tight control system scheduling execution domain interrupt service routine isr 
interrupt xen allows timely response interrupt controller managed xen allows necessary address space switch different domain currently executing 
correct domain scheduled delivered asynchronous event notification causes execution appropriate isr 
xen notifies domain asynchronous events including hardware interrupts general purpose mechanism called event channels 
domain allocated event channels comprises pair bit flags memory page shared domain xen 
flag xen signal event pending 
event pending xen schedules asynchronous upcall domain domain blocked moved run queue 
unnecessary upcalls avoided triggering notification event pending settings flag ignored cleared domain 
second event channel flag domain mask event 
notification triggered masked event pending asynchronous upcall occurs blocked domain woken 
setting mask clearing pending flag domain able prevent unnecessary upcalls partially handled event sources 
mask eventually cleared domain reread pending flag see batch arrived event source 
domain specifies single upcall handler notifications 
avoid expense linearly scanning pending flags selector word indicates aligned groups channels pending 
level hierarchy permits fast scanning common situation channels pending 
avoid unbounded level triggered interrupt line masked interrupt controller relevant devices serviced 
handling event relating level triggered interrupt domain call xen interrupt line 
interrupt line shared multiple devices xen usually safely reconfigure 
obviates need required edge triggered interrupt lines 
interrupt line shared multiple hardware devices xen delay interrupt received domain managing devices 
xen guarantee perfect isolation domain allocated shared interrupt domain interrupt domains prevented receiving device notifications 
shared interrupts rare server class systems typically contain irq steering interrupt controller components pins device 
problem sharing set disappear completely message interrupts part pci express 
device host interactions preventing device driver circumventing isolated environment protect possible hardware due inherent design flaws misconfiguration driver software 
general types device host interaction consider assertion interrupt lines accesses host memory space 
protecting arbitrary interrupt assertion significant issue shared interrupt lines hardware device separately wired connection interrupt controller 
physically impossible device assert interrupt line assigned 
furthermore xen retains full control configuration interrupt controller guard problems irq storms caused repeated cycling device interrupt line 
main protection gap devices may attempt access arbitrary ranges host memory 
example device driver prevented cpu write particular page system memory page belong driver may program hardware device perform dma page 
unfortunately method protecting problem current hardware infeasible xen validate programming dma related device registers 
require intimate knowledge device dma engine protect bugs hardware buggy hardware able access arbitrary system memory 
full implementation aspect design requires integration pc chipset 
similar processor mmu translates addresses requested device valid host addresses 
inappropriate host addresses accessible device mapping configured 
design xen responsible configuring response requests domains 
required validation checks identical required processor mmu example ensure requesting domain owns page frame safe permit arbitrary modification contents 
entirely reasonable expect functionality included commodity near bit systems include allows bit devices access full range host memory 
intended perform translation devices prevented bypassing memory window small step require memory transactions pass enforce protection 
hardware configuration pci standard defines generic configuration space pc hardware devices detected configured 
xen restricts domain access space read write registers belonging device owns 
serves dual purpose prevent cross configuration domains devices restricts domain view hardware probe detects devices permitted access 
method access configuration space common methods potentially unsafe protected mode bios calls small window shared device spaces 
domains permitted direct access configuration space forced virtualized interface provided xen 
advantage xen perform arbitrary validation translation access requests 
example xen disallows attempt change base address register block new location may conflict devices 
guest requests dma 
page placed device channel 
idd removes gr 
sends pin request xen guest os gr gr table device channel xen active table device device isolated device driver idd gr 
xen looks gr active table 
gr validated guest necessary 
pinning acknowledged idd 
idd sends dma request device device device channel request data transfer 
system controller permitted access entire configuration space 
eases configuration safe hardware interface configuration space comprehensively describes hardware resources belong device 
controller automatically configure correct access permissions new device driver domain assistance system administrator 
device channels safe hardware interface configured allow guest os run device drivers misses potential improvements reliability maintainability manageability running device drivers isolation 
expected device driver run isolated driver domain idd limits impact driver faults 
guest oss access device device channel link idd 
channel point point communication link send messages asynchronously 
device channel established system controller introduce idd guest os vice versa 
possible system controller automatically establishes initial control channel domain creates 
shows guest os requesting data transfer device channel 
individual steps involved request discussed section 
treating ipc fundamental primitive systems xen concrete notion control device channel 
messages communicated shared memory pages allocated guest os simultaneously mapped address space idd system controller 
purpose xen permits restricted sharing memory pages domains 
sharing memory sharing mechanism provided xen differs traditional application level shared memory key respects shared mappings asymmetric transitory 
page memory owned domain time assistance xen system controller owner may force reclamation mappings misbehaving domains 
add foreign mapping address space domain valid xen lieu page number 
comprises identity domain granting mapping permission index domain table 
domain owns private table shares xen entry tuple permitting domain map page address space asserting boolean flag restricts read mappings 
flag written xen indicate currently maps tuple 
xen domain searches index domain active table agt private table accessible xen 
match xen reads appropriate tuple guest table checks false requesting writeable mapping 
validation checks successful xen copy tuple agt mark tuple 
xen tracks uses associating usage count agt entry 
foreign mapping created existing agt entry xen increments entry count 
reallocated reused granting domain foreign domain destroys mappings created 
clear mechanism allows strict checking foreign mappings created obvious mappings revoked 
example faulty idd stops responding service requests guest oss owning unusable memory pages 
handle possibility driver failure deadline approach guest observes table entry marked determines ought relinquished requested device channel destroyed signals potential domain failure system controller 
system controller checks specified exists notifying domain agt sets deadline suspect domain relinquish stale mappings 
registered deadline passes stale mappings exist xen notifies system controller 
point system controller may choose destroy restart driver forcibly reclaiming foreign mappings 
descriptor rings descriptor rings asynchronous transfers guest os idd 
ring updates pairs producer consumer indexes guest os places service requests ring advancing request producer index idd removes requests handling advancing associated index 
responses queued ring requests albeit idd producer guest os consumer 
requirement requests processed order guest os associates unique identifier request reproduced associated response 
allows idd unambiguously reorder operations due scheduling priority considerations 
guest os idd shared inter domain event channel send asynchronous notifications queued descriptors 
inter domain event channel similar interrupt attached channels described section 
main differences notifications triggered domain attached opposite channel xen channel bidirectional may independently notify mask incoming notifications 
decouple production requests responses descriptor ring notification party 
example case requests guest may enqueue multiple entries notifying idd case responses guest defer delivery notification event specifying threshold number responses 
allows domain independently balance latency throughput requirements 
data transfer storing data directly ring descriptors suitable approach low bandwidth devices scale high performance devices dma capabilities 
communicating class device includes fast network interfaces disc arrays data buffers allocated band guest os indirectly referenced descriptors 
programming dma transfer directly hardware device idd pin data buffer 
described section enforce driver isolation requiring guest os pass lieu buffer address requesting device transfer idd specifies pinning buffer 
xen applies validation rules pin requests address space mappings 
include ensuring memory page belongs correct domain isn attempting circumvent memory management checks example requesting device transfer directly page tables 
returning example guest request includes gr buffer page 
request dequeued idd sends pin request incorporating gr xen 
xen reads appropriate tuple guest table checks belongs guest copies tuple agt 
idd receives address pin response programs device dma engine 
systems protection support chipset section pinning trigger allocation entry 
modification required enforce safe dma requirement table 
modification affects xen unaware presence case pin requests return bus address device directly access guest buffer 
addition pinning guest buffer dma idd may map buffer address space 
allows support legacy devices support dma idd uses main cpu transfer data device 
buffer mapping useful network driver domains may choose copy packet header guest inaccessible buffer applying filtering rules 
case driver usually map pin packet buffer modern network interfaces support scatter gather dma transfer packet payload directly guest buffer 
device sharing xen simultaneously host guest oss essential consider issues arising device sharing 
control mechanisms creating destroying device channels naturally support multiple channels idd 
section describe block device network support multiplexing service requests different clients 
block device driver service batches requests competing guests simple round robin fashion passed standard elevator scheduler reaching disc controller 
low level scheduling provided elevator disc controllers gives throughput request batching provides reasonably fair access 
take similar approach network transmission implement scheduler allowing device channel allocated bandwidth share form bytes microseconds 
choosing packet queue transmission round robin schedule channels sufficient credit 
sharing high performance network receive path requires careful design apart smart network interfaces perform packet demultiplexing hardware possible dma directly buffer 
copying packet guest buffer performing demultiplexing exchange ownership page containing packet unused page provided guest os 
avoids copying overheads requires idd queue buffers network interface 
packet received idd immediately checks demultiplexing rules determine destination device channel 
unused pages queued guest network receive ring packet dropped 
safety xen permit exchange ownership arbitrary memory pages 
extend table section include exchange tuples exchange permitting domain acquire ownership page exchange relinquishing ownership page 
unused exchange tuples denoted table entry xen rewrites address page relinquished idd 
exchanging page ownerships idd sends request exchange xen page frame belonging idd exchange passed idd guest os network receive descriptor 
control management embed device manager system controller small privileged management kernel loaded firmware system boots 
bootstrap device manager probes device hardware creates idd loaded appropriate driver detected device 
device manager ongoing responsibilities include guest device configuration managing setup device channels providing interfaces hardware configuration reacting driver failure 
guest configuration bootstrap device manager extends domain management functions system controller allowing configuration restricted idd access guest os 
example network device channel may prevented sending packets spoofed source address channel may limited isolated regions shared disc 
guest os boots manager informs devices granted access 
guest os initiates device channel creation allocating memory page communications ring passing idd device manager 
manager allocates inter domain event channel linking guest os idd passes endpoint channel idd 
idd acknowledges setup device channel response forwarded guest os event channel endpoint 
driver failure design device manager responsible detecting driver failure coordinating recovery 
ways manager may determine driver failed example may receive notification xen idd crashed unresponsive idd may fail guest buffers specified time period 
subsequent recovery phase greatly simplified design architecture firstly shared state associated device channel small defined secondly idd internal state soft may simply reinitialized restarts 
recovery phase comprises stages 
device manager destroys offending idd replaces freshly initialized instance 
manager signals connected guest oss idd restarted guest responsible connecting new device channel normal signalling mechanisms provided device manager 
point guest may opt reissue requests may affected failure outstanding requests response received idd failed 
implemented os specific network drivers able recover idd restart 
recovery drivers retain small amount state reestablish channel connections reissue incomplete requests 
state held shared device channel memory may corrupted failed idd discarded increasing tolerance potential driver faults 
evaluation section evaluation prototype implementation 
evaluating impact isolation mechanisms realistic application workloads industry standard benchmarks postmark relative score linux io idd linux build time io pm trans idd io idd oltp tup io idd httperf reqs io idd specweb score application level benchmarks 
smp io io space idd idd smp spec web proceed investigate overheads individual device subsystems series network disk micro benchmarks determine overhead implementing space protected hardware interface additional overhead isolation device channel interface 
provoke series device driver failures measure system availability recovering 
experiments performed dell dual processor ghz intel xeon server gb ram gigabit ethernet network cards aic ultra scsi controller fujitsu map nc gb rpm scsi disks 
linux version redhat linux installed ext file system 
identical device driver source code linux experiments allowing measure performance variations caused varying system configuration 
current implementation isolated driver domains xen virtual machine monitor 
xen interface results low virtualization overhead cpu memory intensive applications 
running benchmarks spec cpu xen measured overhead 
experiments attribute slow relative native linux modifications 
believe establishes upper bound additional costs note overhead may reduce processors provide hardware assistance reduce cost virtualization client aware devices reduce load host processor 
compare performance idd prototype number configurations vanilla linux smp kernel baseline smp 
www spec org osg web sourceforge net overhead implementing protected hardware access measure version xen linux containing disk network drivers access hardware protected interface provides virtualization interrupts segregation hardware access 
label results io space 
evaluate performance full blown architecture network disk devices communicating instance xen linux device channel interfaces 
idd xen linux instance runs isolated xen domain cpu domain bound depends test configuration 
include results xen linux instance executes cpu idd xen linux instance runs different physical cpu idd smp xen linux instance bound different hyper thread physical cpu idd ht 
application level benchmarks subjected test systems battery applicationlevel benchmarks results displayed 
benchmark measures elapsed time complete build default configuration linux kernel tree stored local ext file system 
kernel compile performs moderate amount disk spending time os kernel process memory management typically introduces additional overhead performed inside virtual machine 
results show space virtualized hardware interface incurs penalty full idd architecture exhibits overhead 
postmark file system benchmark developed network appliance emulates workload mail server 
initially creates set files varying sizes files sizes ranging mb performs number transactions configuration 
transaction comprises variety operations including file creation deletion appending write 
run gb data transferred disk 
postmark reports figures configuration number transactions second aggregate read write throughputs 
relative results metrics similar transaction rates 
additional overhead incurred spaces full idd architecture just respectively 
open source database benchmark conjunction postgresql 
benchmark creates populates database multiuser mode exercises types workload information retrieval ir performs read operations entire database line transaction processing oltp queries updates tuples database 
default dataset mb fits entirely buffer cache created dataset containing tuples relation resulting mb database 
results oltp workload ir generate significant disk activity 
investigate surprisingly high result achieved idd disk microbenchmark section 
httperf generate requests apache server retrieve single kb static html document 
benchmark configured maintain single outstanding request effectively measuring response time server 
resulting network bandwidth generated server mb space result exposes overhead virtualizing interrupts latency sensitive scenario opportunity overhead pipelining requests 
communicating idd device channel interface compounds effect requiring significant number inter domain notifications 
despite response time achieved native smp 
spec web complex application level benchmark evaluating web servers systems host 
workload complex mix page requests require dynamic content generation post operations execute cgi script 
server runs generates access post logs disk workload solely read 
measurement period mb tcp network traffic considerable disk read write activity gb dataset 
number client machines generate load server test machine simulating collection users concurrently accessing web site 
benchmark run repeatedly different numbers simulated users determine maximum number supported 
spec web defines minimum quality service simulated users receive order conformant count score initial warm phase users receive aggregate bandwidth excess kb series requests 
experimental setup apache server version plug perform dynamic content generation spec rules require requests full cgi forking separate process 
demanding workload find overhead spaces full device driver isolation minimal just respectively 
network performance evaluated network performance test configurations ttcp measure tcp throughput gigabit ethernet second host running smp 
hosts configured socket buffer size kb recommended practice gigabit networks 
repeated experiment different mtu sizes default ethernet mtu bytes smaller mtu bytes 
picked commonly dial ppp clients puts significantly higher stress system due higher packet rates generated packets second mb 
byte mtu configurations achieve percent maximum throughput gigabit ethernet card system bottleneck table 
byte mtu provides far demanding test exposing different packet cpu overheads configurations 
virtualized interrupt dispatch model provided spaces incurs overhead transmit receive 
shows extreme load retaining safe control interrupt dispatch device achieved reasonable cost 
figures idd implementation reflect extra cpu cost full driver isolation 
single cpu result represents close worst case scenario recording performance slow downs relative smp 
reflects cost rapid switching protection domains deleterious effect cache tlb 
enabling hyper threading idd ht single cpu configuration provides relief avoiding context switching allowing better data flow processor cache 
adding second cpu idd smp provides benefits reducing relative deficit transmit receive 
disk performance networking disk typically impose significant strain cpu data typically transferred larger units operation overhead 
performed experiments dd repeatedly write read gb file ext file system table 
read performance nearly identical tcp mtu tcp mtu tx rx tx rx smp space idd idd ht idd smp table ttcp bandwidth mb read write smp space idd smp table dd bandwidth mb cases attempts measure write performance hampered due oscillatory behaviour linux memory system doing bulk writes 
leads idd configurations outperforming standard linux extra stage queueing provided device channel interface leads stable throughput 
device driver recovery tests provoked network driver perform illegal memory access measured effect system performance 
scenario detection device driver failure immediate internal deadlock infinite looping detection delay dependent system timeouts 
test driver recovery caused external machine send equally spaced ping requests test system rate packets second 
shows interarrival latencies packets guest os inject failure network driver domain second intervals 
recovery period failure recorded network outages ms 
closer examination revealed period spent executing device driver media detection routines determining link status 
driver restart packets received network interface lost 
ms average recovery time interact tcp congestion control mechanism cause longer effective interruption service 
performed experiments running full rate tcp connections hosts restarting network driver 
scenario observed tcp connection retransmissions outage effectively adding additional time complete system recovery 
repeated experiments hot standby driver domain resets network interface device channels signalled system con packet inter arrival latency ms time effect driver restart packet arrivals 

approximately halves network outage 
driver domain requires just mb memory solution may attractive scenarios 
conducted similar experiments restarting block device drivers 
driver downtime experiments largely determined time scan scsi bus devices 
situations known advance driver restarted specific list devices avoiding scan time 
generation architecture solves existing problems dependability maintainability manageability 
key achieving separation device drivers operating systems running device driver separately protected scheduled environment increase robustness systems bugs hardware software 
unified device driver interfaces share devices number existing operating system instances dynamically restart device drivers case error upgrade 
unified interfaces increase portability allowing different kinds operating systems code operating system need provide simple generic driver entire class devices 
generic interfaces inappropriate non shareable devices isolation offer increase reliability aid management 
hardware required fully support architecture available implemented prototype virtual machine monitor provide requisite functionality 
prototype supports nearly features architecture notable exception protection erroneous dma gives surprisingly performance overhead generally percent achieved milliseconds 
furthermore believe implementation naturally incorporate benefit emerging hardware support protection 
chou yang chelf hallem engler 
empirical study operating system errors 
proceedings th acm symposium operating systems principles pages october 
swift bershad levy 
improving reliability commodity operating systems 
proceedings th acm symposium operating systems principles pages october 
microsoft calls bit driver support 
infoworld magazine online may 
seltzer endo small smith 
dealing disaster surviving misbehaved kernel extensions 
proceedings nd symposium operating systems design implementation pages october 
bershad savage pardyak sirer fiuczynski becker eggers chambers 
extensibility safety performance spin operating system 
proceedings th acm symposium operating systems principles pages december 
leslie mcauley black roscoe barham 
design implementation operating system support distributed multimedia applications 
ieee journal selected areas communications september 
engler kaashoek toole jr exokernel operating system architecture application level resource management 
proceedings th acm symposium operating systems principles december 
whitaker cox shaw gribble 
constructing services virtual hardware 
proceedings st symposium networked systems design implementation pages march 
baron rashid siegel tevanian young 
mach operating environment large scale multiprocessor applications 
ieee software 

architectural overview qnx 
proceedings workshop micro kernels kernel architectures pages 
usenix assoc 
armand 
give process drivers 
proceedings autumn conference budapest 
waldspurger 
memory resource management vmware esx server 
proceedings th symposium operating systems design implementation pages december 
barham fraser hand harris ho neugebauer pratt warfield 
xen art virtualization 
proceedings th acm symposium operating systems principles pages october 
brown patterson 
embracing failure case recovery oriented computing roc 
proceedings high performance transaction processing symposium asilomar ca october 
oppenheimer brown beck patterson yelick 
roc hardware support recovery oriented computing 
ieee transactions computers vol 
february 
uhlig gershon hirsh wang 
pre silicon software development environment ia architecture 
intel technology journal november 
intel technology architectural overview september 
order number www intel com technology security downloads lt arch overview pdf 
udi version 
project udi 
technical white www org 
ford hibler lepreau back 
microkernels meet recursive virtual machines 
proceedings nd usenix symposium operating systems design implementation pages october 
liedtke 
micro kernel construction 
proceedings th acm symposium operating systems principles pages december 
van 
fluke device driver framework 
master thesis university utah december 

von linux auf die drops july 
diploma thesis technical university dresden 
hendricks webster 
linux bios 
proceedings th annual linux showcase conference october 
pratt fraser 
arsenic user accessible gigabit ethernet interface 
proceedings twentieth annual joint conference ieee computer communications societies infocom pages april 
intelligent architecture specification revision 
special interest group 
clark dow finlayson matthews 
xen art repeated research 
proceedings usenix annual technical conference freenix track july 
saltzer reed clark 
arguments system design 
acm transactions computer systems november 
pci express base specification 
pci sig 
katcher 
postmark new file system benchmark 
technical report network appliance october 
