esp language programmable devices sanjeev kumar dissertation faculty princeton university degree doctor philosophy recommended acceptance department computer science june copyright sanjeev kumar 
rights reserved thesis presents design implementation event driven state machines pro gramming esp language programmable devices 
traditional languages event driven state machines forces tradeoff requires giving ease programming reliability achieve high performance 
esp designed provide properties simultaneously 
esp provides comprehensive set features support development compact modular programs 
esp compiler compiles programs targets file generate efficient firmware device model model checking verifier spin extensively test firmware 
case study reimplemented vmmc firmware runs myrinet network interface cards esp esp simplifies task programming event driven state machines 
required order magnitude fewer lines code earlier implementation 
model checking verifiers spin effectively debug firmware 
measurements show performance impact applications esp small 
iii acknowledgments members committee kai ed andrew randy larry 
extremely fortunate kai advisor 
gave lot freedom choose research agenda 
time guide research stalled 
busy away sure available needed advice 
faculty members department keep doors open graduate students 
jp andrew larry doug ed randy answered numerous technical questions provided invaluable advice years 
efficient administrative technical staff 
melissa particular patient ensured kept 
stay princeton enormously enriched friends 
dirk steve patrick 
arrived princeton time survived stressful times 
fond memories see tv survivor followed go sessions 
graduate students department including george angelos engaged lively discussions technical 
undergraduate buddies numerous list large extended family 
family love encouragement support education 
dad perfect role model mother emphasized importance education 
grandparents provided additional growing 
brother praveen friend confidant 
lucky nearby day left iv home college 
sister baby family 
wife biggest gain princeton 
supported part national science foundation cda eia ani eia department energy de fc er california institute technology pc pc sandia national lab ao lawrence livermore laboratory intel research council intel technology equipment 
vi memory mother singh contents 
iii programmable devices 
programming programmable devices 
programming programmable devices 
programming example 
problems 
case study vmmc firmware 
event driven state machines programming esp 
goals 
approach 
compiler architecture 
case study vmmc firmware 
related 
thesis outline 
esp language background 
related 
vii contents viii language design 
processes 
channels 
data types control constructs 
dispatch channels 
memory management 
external interface 
case study vmmc firmware 

summary 
developing testing model checker background 
related 
model extraction approaches 
debugging system software 
symbolic model checking 
extracting spin models 
spin model checking verifier 
compilation stages 
extracting detailed models spin 
extracting memory safety models spin 
extracting models spin 
case study vmmc firmware 
implementing retransmission protocol 
verifying memory safety 
contents ix checking absence deadlocks 
discussion 

summary 
generating efficient code background 
related 
generating optimized code 
compilation stages 
scheduling 
memory management 
case study vmmc firmware 
microbenchmark performance 
application performance 
discussion 

fast paths 
compiler optimizations 
summary 
directions language support ease programming 
extensive testing model checker 
generating efficient code 
contents esp language lexical issues 
notation 
program 
data types 
channels 
processes 
expressions 
statements 
memory management 
external interface 
vmmc firmware esp list figures machine programmable devices 
example part initialization 
example part ii event handlers 
example corresponds code shown figures 
vmmc software architecture 
esp approach 
esp compiler architecture 
esp example implements state machine section 
esp code implement page table 
esp program 
spin model detailed generated esp code shown code fragment assigning immutable objects 
spin code corresponding esp code fragment 
code fragment ii assigning mutable objects 
spin code corresponding esp code fragment 
esp program 
abstraction 
spin model part 
xi list figures xii spin model part ii 
abstraction 
setup debug retransmission protocol 
example illustrate problems copying semantics pre serves pointer sharing 
example shows traditional counting scheme sufficient esp 
latency microbenchmark 
way bandwidth microbenchmark 
bidirectional bandwidth microbenchmark 
experimental setup 
splash application performance 
fast paths 
vmmc firmware esp 
list tables typical event driven state machines library interface 
file sizes 
checking memory safety spin 
checking absence deadlocks spin 
splash applications 
description processes 
description channels 
xiii chapter thesis shows domain specific language greatly ease task program ming devices network interface cards hard disks 
devices getting faster overhead main processor low level device management significant 
overhead stems cost interrupt processing having cross multiple buses reach device 
address devices equipped programmable processor memory 
allows functionality run main processor offloaded processor device 
task writing firmware programmable devices challenging sev eral reasons 
programmable devices tend limited processing power memory resources required deliver high performance 
second constantly process external events keep track progress multiple events time 
firmware trusted operating system directly write main memory 
bug firmware corrupt operating system crash entire machine 
firmware reliable 
devices usually programmed event driven state machines concur effective way structuring firmware programmable devices 
low chapter 
overhead event driven state machines choice expressing concurrency firmware 
ability handle low level details popular choice writing system software 
event driven state machines implement firmware diffi cult task writing reliable concurrent programs challenging 
low overhead achieved supporting bare minimum functionality needed write programs 
performance achieved resulting pro grams hard maintain hard debug 
example virtual memory mapped communication vmmc firmware myrinet network interface implemented event driven state machines vmmc architecture delivers high performance communication applications running user level 
allows bypass operating system programmable network interface cards 
experience vmmc firmware performance achieved approach source code hard maintain debug 
implementation involved lines code 
years debugging race conditions cause machine crash occasionally 
thesis presents design implementation event driven state machines programming esp language programmable devices 
forces tradeoff requires giving ease programming reliability achieve high perfor mance esp designed provide properties simultaneously 
case study reimplemented vmmc firmware esp compared new implementation earlier implementation evaluate esp language 
esp simplifies task programming event driven state machines 
required order magnitude fewer lines code previous implementation 
model checking verifiers spin effectively debug chapter 
firmware 
measurements show performance impact applications esp small 
published results 
rest chapter organized follows 
section provides brief description programmable devices 
section explains choices available program devices 
section describes problems traditional approaches program ming devices section presents goals approach overview esp section describes related 
section presents outline rest thesis 
programmable devices traditionally devices implement simple functionality usually implemented hard ware 
complexity implemented device drivers running main processor 
devices get faster increasingly harder software running main cpu keep devices 
main cpu go memory buses reach device incurs hundreds cycles access 
situations better performance achieved implementing functionality device main cpu 
implement increasingly sophisticated functionality devices devices equipped programmable processor memory 
processor resides directly card incurs smaller overhead access device resources dma engines device registers 
code running device fast 
processing power memory device tends order magnitude main cpu main memory 
migrating code main cpu device involves tradeoff chapter 
memory bus bus cpu mem main cpu dma dma network card network main memory cpu mem dma disk machine programmable devices running code faster processor incurs higher overhead access device running slower processor faster access device 
slower code runs device smaller benefit migrating code devices 
devices equipped general purpose processors differ great deal amount processing power memory possess 
small processing core implement simple functionality pro assembly intel ixp 
devices general purpose processors powerful implement complex tasks require code running fast 
thesis addresses task writing firmware class devices 
programming programmable devices firmware programmable devices programmed concurrency 
concur rent programs multiple threads control coordinate perform chapter 
single task 
multiple threads control provide convenient way keeping track multiple contexts firmware 
instance network interface cards required continuously respond variety events requests main cpu messages arriving network timer interrupt 
better performance processing multiple events overlapped dma transferring data main memory response event time message sent network response different event 
situations concurrency exploit parallelism effective way structure program runs single processor 
concurrent programs written variety constructs threads event driven state machines 
differ amount functionality provided perfor mance overhead involved 
threads coroutines 
concurrent program composed set threads 
thread represents sequential flow control program 
difference tween threads coroutines coroutines preempted 
context switch coroutines occurs defined synchronization points program 
threads coroutines thread stack context switch thread nested function call 
frees programmer having structure program worrying blocking 
convenience comes cost 
thread context switch slower involves saving restoring registers including stack pointer program counter 
requires memory separate stack allocated thread 
event driven state machines 
concurrent program composed set state ma chines 
state machine represents sequential flow control program 
state machines communicate sending events 
basic differ chapter 
ence threads event driven state machines state machines program share single stack 
context switch fast context needs saved restored context switch program counter 
addition memory requirements lower stack needed entire program 
writing event driven state machines programs difficult 
having share stack various state machines imposes restrictions state machine block transfer control different state machine 
top level functions points program stack store useful data different state machine having save data state machines allowed block top level functions 
programmer burden structuring program block nested function call 
languages provide support event driven state machines need share single stack places additional burden programmer 
require state machines specified explicitly 
sequential flow control state machine broken functions handlers 
flow control functions specified function pointers detailed description section 
event driven state machines programs difficult write understand debug 
high performance essential device firmware low overhead event driven state machines compelling choice 
chapter 
function description sm sets function handler event state machine sm state setstate sm moves state machine sm state sm checks state machine sm state sm deliver event state machine sm table typical event driven state machines library interface 
programming programmable devices libraries support event driven state machines provide bare minimum function ality necessary write concurrent programs ability block particular state woken particular event occurs 
typical library interface table 
program consists multiple state machines 
state machine specified ing set handlers 
state state machine handler specified event expected state 
event oc corresponding handler invoked library 
handler processes event transitions different state setstate blocks returning handler 
way state machine block returning handler 
state machine communicates state machines generating events 
state machines share single stack 
rest section example illustrate problems program ming event driven state machines chapter 
enum sm sm 
enum statet 
enum sm ready sm ready 
enum 
int paddr main 
initialize state machine sm sm sm sm sm ready setstate sm initial state 
example part initialization chapter 
void request arrived switch type case paddr vaddr setstate sm return block state machine case vaddr paddr void dma available paddr size sm setstate sm void sm ready request data dest dest sm sm ready setstate sm wait request example part ii event handlers chapter 
initial state event execute event execute event sm ready execute example corresponds code shown figures 
programming example code fragment figures illustrated uses event driven state machines programming interface table 
implements functionality 
state responsible handling requests applications 
receiving request send data dmas data user memory network card hands state machine sm responsible sending network 
sm waits request 
processing send request sm need block dma busy ready accept request 
initialization handlers different events set state machine initially 
request user arrives event corresponding handler triggered 
user specifies virtual address data translated physical address calling function performs table lookup 
checks dma available 
calls directly 
handler function takes arguments returns void 
initialization set state machines 
chapter 
sets state state machine sm blocks 
case called dma available handler 
invoked dmas data application memory network card calling 
checks see state machine sm ready accept data 
calls directly 
sets state state machine sm blocks 
case called sm ready accept data 
invoked request handed updating global variable 
event sm ready delivered sm 
eventually cause corresponding handler invoked 
sets state waits request 
problems problems approach 
code difficult programmer understand code gets fragmented handlers 
addition function pointers handlers specify state machine difficult compiler determine control flow state machines prevents effectively optimizing code 
forces programmer hand optimize code better performance 
second stack shared values needed saved explicitly global variables handler blocks 
data passed handlers global variables paddr 
addition state machines communicate global variables 
hard get right synchronization keep data 
chapter 
third dynamically allocated data structures managed explicitly 
con current setting hard implement correctly state machines data structure eventually freed 
depending timing different state machine data responsible freeing 
necessary explicit counts maintained 
easy overlook need adding counts data structures introduce tricky allocation bugs hard find 
fourth functions inappropriate abstraction mechanism programming state machines 
state machine block returning handler 
firmware evolves need block function handler 
instance original implementation function implemented simple table lookup 
firmware evolved table cache translations entire table moved host memory 
meant translation cache translation host memory 
dma available need block 
required extensive rewrite code addition states state machine 
general amount rewrite proportional nesting depth function wants block 
fifth union datatypes extensively systems encode different possible requests 
lot handlers switch statement deal different requests 
instance application request message sent update virtual physical translation 
requests handled handler code collocated sense implemented separate modules 
dispatch mechanism supported language simplify implementation 
hand optimized fast paths built system speed certain requests 
fast paths rely global information state various state chapter 
machines data structures violate abstraction boundary 
instance vmmc firmware particular fast path taken network dma free request currently processed requires looking state multiple state machines 
addition fast path code updates global variables retransmission update state state machines 
fast paths complicate complex state machine code 
summary performance achieved programming programs hard write maintain debug 
case study vmmc firmware virtual memory mapped communication vmmc firmware implemented event driven state machines case study thesis 
virtual memory mapped communication vmmc architecture delivers high performance gigabit networks sophisticated network cards 
allows data directly sent application memory avoiding memory copies involving operating system avoiding system call overhead 
operating system usually involved connection setup disconnect 
current vmmc implementation uses myrinet network interface cards 
myrinet packet switched gigabit network 
myrinet network card con nected network unidirectional links mbytes peak bandwidth 
actual node network bandwidth usually constrained pci bus mbytes network card sits 
network card programmable mhz lanai processor mbyte sram memory dma engines transfer data transfer data host memory send data network chapter 
main processor network interface card library application device driver firmware network vmmc software architecture 
shaded regions vmmc components 
receive data network 
card number control registers including status register checks data arrival watchdog timers dma status 
vmmc software components library links application device driver mainly connection setup disconnect firmware runs network card 
software complexity concentrated firmware code implemented event driven state machines software development involved man years 
bugs encountered located firmware 
consequently wanted reimplement firmware esp language 
vmmc software extensively number research projects 
standard high level communication libraries including remote procedure call rpc shared virtual memory svm sockets nx message passing implemented top low level api provided vmmc 
distributed applications run cluster vmmc communication mechanism 
significant effort spent implementing maintaining performance tuning extending functionality vmmc 
experience program chapter 
ming vmmc firmware event driven state machines ideal candidate case study thesis 
event driven state machines programming esp esp domain specific language designed support event driven state machines pro gramming programmable devices 
rest section organized follows 
section describes design goals esp section outlines approach taken esp meet design goals 
section presents overview esp compiler 
section presents summary evaluation esp vmmc firmware case study 
goals design esp driven goals ease programming 
language simplify event driven state machines pro gramming addressing problems described section 
allow concurrency expressed concise modular fashion 
provide support dispatch dynamic memory management flexible interface extensive testing 
concurrent programs suffer hard find race conditions deadlock 
device firmware needs reliable trusted operating system 
bug device firmware crash entire machine 
esp support model checking verifiers programs tested extensively 
low performance overhead 
performance crucial firmware running programmable devices 
esp minimize overhead language chapter 
pgm esp esp compiler pgm spin spin test spin spin pgm help verify property spin verify property spin generate firmware compiler esp approach 
esp compiler takes program written esp pgm esp generates types files models pgm spin model checker extensively test program optimized code pgm generate firmware 
shaded regions represent code provided programmer 
features provided 
permit aggressive optimizations compile concurrent programs run efficiently single processor 
traditional languages event driven state machines forces tradeoff requires giving ease programming reliability achieve high performance 
esp designed provide properties simultaneously 
approach meet design goals section esp takes approach 
esp provides number features simplify task programming firmware pgm esp 
esp compiler generates models pgm spin model checker debug extensively test firmware 
esp compiler generates optimized code pgm compiled firmware runs device 
chapter 
domain specific languages model checkers testing focused expressing control portion program :10.1.1.17.5606
leave data handling performed externally contrast esp designed express control structure modular fashion simplify data handling 
helps esp meeting goals 
programmer burdened having separate data manipulation control portion program 
second resource constraints prevent model checker exhaustively checking entire program esp compiler extract detailed models 
detailed models test local properties small subsystems detailed models test global properties entire system 
having program expressed esp allows esp compiler perform optimizations effectively 
esp language section uses processes implicitly express state machines 
processes channels communicate 
addition esp number language features simplify task writing device firmware 
esp compiler automatically extract models model checker extensively test program section 
currently esp uses spin model checker 
spin flexible powerful verification system designed verify correctness soft ware systems section 
systematically explores state space system checks violations specified property 
spin models pgm spin generated esp compiler programmer supplied spin code test spin verify different properties system 
programmer supplied spin code generates external events network message arrival specifies properties verified 
esp compiler uses back language generates optimized code section 
generated code pgm compiled code provided programmer help generate executable 
programmer chapter 
supplied code implements simple system specific functionality accessing device reg check network message arrivals 
device manufacturers usually provide compiler write firmware devices back language esp programs portable 
compiler architecture presents architecture esp compiler 
compiler imple mented standard ml new jersey sml nj required lines code 
compiler main components front lines code model extractor lines code optimizing code generator lines code 
front responsible scanning parsing type checking generates typed syntax tree details section 
model extractor uses typed syntax tree generate models details section 
optimizing code generator translates typed syntax tree suitable optimizations optimizes generates code details section 
case study vmmc firmware vmmc firmware section case study evaluate esp new imple mentation uses esp compared earlier implementation event driven state machines show esp meets design goals section 
detailed evaluation sections 
brief summary 
ease programming 
esp allows vmmc firmware expressed modular concurrent program 
concurrent programs expressed concisely processes channels 
addition pattern matching channels allows object chapter 
pgm esp scanner parser abstraction preprocessor front optimizing code generator convert ir model extractor esp compiler front type checker model generator optimizers model extractor optimizing code generator code generator esp compiler architecture pgm spin pgm spin spin pgm chapter 
dispatched transparently multiple processes 
flexible external interface allows esp code interact seamlessly code 
novel memory management scheme allows efficient verifiably safe management dynamic data 
new implementation vmmc firmware esp requires significantly fewer lines code earlier implementation 
new implementation lines esp code lines code 
code performs simple operations packet marshalling handling device registers complexity localized esp code 
significant improvement earlier implementation complex interactions scattered entire code lines 
extensive testing 
esp compiler generates spin models section develop extensively test vmmc firmware spin model checker 
properties checked model checker specified model checker checks automatically 
firmware evolves properties minimal programmer effort 
developing code network card slow painstaking parts firmware developed debugged entirely spin ported network card 
instance retransmission protocol implemented approach 
greatly speeds program development 
implementation protocol esp took days earlier implementation took days 
spin exhaustively check memory safety firmware 
esp provides explicit dynamic memory management interface efficient unsafe 
spin verify safety esp provides benefits safety paying runtime cost implementing safety garbage collection 
chapter 
spin able identify bugs cause firmware deadlock 
bugs triggered certain rare circumstances fairly difficult find conventional testing methods 
low performance overhead 
esp compiler performs aggressive optimizations generate efficient vmmc firmware 
performance new imple mentation esp compared earlier implementation microbenchmarks applications 
microbenchmark measurements show performance difference firmware implementation esp earlier implementation usu ally small 
cases difference significant 
instance esp im plementation involves twice latency implementation sending byte messages 
case entire difference result fast paths implementation currently supported esp obtain fairer comparison version implementation include fast paths 
measurements show esp implementation performs worse latency microbenchmark worse bandwidth microbenchmark 
performance impact esp applications small 
measure performance splash applications firmware implementations 
measurements show applications run slower average worst case esp version relative version 
show fast paths implementation little impact applications performance 
chapter 
related devices usually programmed event driven state machines languages assembly 
aware high level language designed programming devices 
number research projects addressed problems esp albeit different context 
section presents brief survey related 
discussed detail sections 
number domain specific languages taken approach similar esp compiler generates models debugging model checker executable code 
designed support event driven state machines programming different domains 
esterel designed model control reactive systems 
teapot designed writing coherence protocols 
promela designed implement layered network protocols 
main differences esp languages languages focus control portion program data structures handled externally contrast esp designed simplify control portion data handling 
thompson format simple extension ansi support event driven state machines 
allows models extracted 
provides minimal support aid programming 
vast amount research focused theory practice concurrency 
lan guages csp squeak designed explore concurrency structure programs 
languages address debugging efficient code generation 
number programming languages java cml sr provide support concurrency 
languages designed expressive incur higher runtime overheads 
chapter 
thesis outline rest thesis organized goals esp set achieve 
chapter presents design esp language shows simplifies task writing event driven state machines programs devices 
chapter describes esp programs tested extensively model checker 
chapter describes techniques generate efficient executable esp programs presents performance measure ments show impact esp applications fairly small 
chapter presents 
appendix presents esp language 
appendix describes structure vmmc firmware implemented esp chapter esp language firmware programmable devices usually written event driven state ma chines section 
event driven state machines support low overhead concurrency 
concurrency allows firmware keep track various events simultaneously processed device 
low overhead concur primitives allows firmware running relatively slow processors keep high performance devices 
general purpose languages include powerful language features class functions gotos program event driven state machines 
languages designed simplify event driven state machines program ming 
result event driven state machines programs written difficult implement debug maintain 
drawbacks discussed detail section 
chapter presents design esp language 
esp domain specific lan guage writing firmware programmable devices event driven state machines 
vmmc firmware case study demonstrate esp greatly simplifies task programming devices 
chapter 
esp language rest chapter organized follows 
section discusses background 
section describes related 
section presents design esp language 
section presents experience esp write vmmc firmware 
section suggests directions research 
section presents summary 
background approaches writing event driven state machines programs explicit 
explicit event driven state machines programs state machine specified explicitly specifying various components states blocked events responds handlers specify code invoked response events transition state machine new state blocking 
languages designed event driven state machines programming support explicit interface 
typical interface section 
explicit event driven state machines programming match domains memory coherence protocols hardware controllers programming task specified event driven state machines 
explicit approach results fragmented code section readable 
language features continuations buffered channels alleviate tation problem 
implicit 
implicit event driven state machines programs state machines specified implicitly processes channels 
process implicitly encodes state machine represents sequential flow control concurrent program 
process communicates processes exchanging messages channels 
chapter 
esp language operations channels block process suspend waiting channel operation complete 
setup location process block represents separate state state machine 
events channels message arrival cause blocked process resume execution location process blocks state transition 
different state machines event driven state machines program share single stack section processes obey restriction process block top level nested function call 
ensures state machine useful data stack blocked allows stack reused state machine scheduled run 
example implicit event driven state machines program section 
implicit approach simplifies programmers task making event driven state machines programming similar message passing style concurrent programs 
provides high level abstraction avoids code fragmentation problem 
related section describes number research projects related esp language influenced design 
code generation verification 
number languages de signed support event driven state machines programming domains :10.1.1.17.5606
taken similar approach generating efficient executables models model checker 
differ esp significantly 
main differences languages designed address control portion program 
complex data structures manipulated externally chapter 
esp language language 
design choice motivated fact control portion program sufficient check properties absence deadlocks livelocks 
esterel designed model control reactive systems 
adopts synchronous hypothesis reaction external event instantaneous ensures reaction unique deterministic reaction 
programs easier analyze debug 
esterel programs compiled generate software hardware implementations 
efficiently implement subset tcp protocol 
esterel implement device firmware drawbacks 
reactions instantaneous practice 
instance dma available event processed process current event 
dma available event registered clock tick available 
results inefficient dma 
second language provides powerful constructs parallelism level 
satisfy synchronous hypothesis forces constraints valid programs 
instance iteration loop time consuming operation signal emission 
addition constraint verifiable compiler 
disallows simple loops initialize array 
third language naturally suited implementing synchronous hardware software 
notion global clock ticks periodically 
processes communicate emitting broadcast signals 
clock cycle scheduling scenario allows writers write signal readers signal read 
language designed encode control portion program 
data handling performed externally interface 
forces complex tasks including memory management implemented teapot language writing coherence protocols generate efficient protocols verify correctness 
uses single state machine group chapter 
esp language communicating state machines keep track state coherence unit cache line page 
state machine specified explicitly set handlers similar interface described table 
continuations reduce number states programmer deal 
approach works applied coherence protocol suffers problems described section implement device firmware 
difficult write modular code state essentially global state program specify response events occur state 
teapot provide support complex datatypes dynamic memory management 
specification languages promela spin murphi ioa specify event driven state machines 
languages designed precisely specify formally reason programs 
designed effective programming languages lack standard language features 
instance promela support pointers dynamic memory management necessary efficient implementation 
promela language designed implement layered network protocols 
nonstrict extension promela language supports restrictive form pointers 
network protocol implemented sequence layers 
adjacent layers communicate fifo queues 
layer specifies handlers process message arriving queues 
queues unbounded buffering 
allows output operations queues nonblocking 
layered framework works writing network protocols restrictive writing firmware code different modules complex interactions 
provide support dynamic memory management 
thompson format simple extension ansi support event driven state machines programming 
program written goto label chapter 
esp language statements 
extensions provided identified prefix simplify task specifying dispatch tables states 
preprocessor replaces extensions corresponding code 
model checker check software written format 
approach simplifies event driven state machines programming address number issues including dynamic memory management com munication state machines 
concurrency theory 
concurrent programs difficult understand se ones 
number languages designed explore concurrency structure programs 
process algebras proposed better understand nature concurrency formally reason concurrent programs 
csp proposes communicating sequential processes csp funda mental program structuring method 
shows csp programs implement variety constructs including subroutines datatypes bounded buffers semaphores 
csp program consists set processes communicate sending synchronous messages rendezvous communication 
processes completely sequential 
csp address practical issues including complex data types dynamic memory management external interface debugging efficient compilation 
squeak concurrent language implementing graphical user interfaces 
semantics formally specified 
squeak program consists fixed number pro cesses communicating synchronous channels 
channels known statically 
allows programs compiled efficiently 
squeak address number features including complex data types dynamic memory management debugging 
chapter 
esp language number process algebras calculi ccs csp calculus identify small set primitive operators sufficient express concurrent programs algebraic laws formally reason 
focus concurrent programs processes communicate sending message shared variables 
algebras serve foundation programming languages 
concurrent languages 
number programming languages provide support concurrency 
languages expressive threads event driven state machines express concurrency 
allow dynamic process channel creations 
support message passing style communication shared memory communication 
due expressiveness runtime head incurred prohibitively high allow program devices 
java general purpose programming languages provides user level threads express concurrency 
cml concurrent extension ml supports class synchronous operations 
operations powerful express wide variety communi cation abstraction including buffered channels multicast channels ada style rendezvous futures 
sr language parallel distributed processing 
supports virtual machines communicate message passing 
virtual machine uses separate address space run multiple processes communicate shared memory message passing 
allows sr program run single parallel machine distributed machines 
successor squeak includes type system dynamic process channel creation blocking functions 
csp process algebra distinct csp programming language chapter 
esp language occam descendant csp designed implement concurrent programs run parallel machine 
concurrency operator level program 
encourages program express concurrency nodes parallel machine kept busy 
occam processes communicate synchronous channels 
support complex data types arrays records copied assignment avoiding pointer aliasing 
neuron extension ansi designed distributed environment 
neuron program consists state machines running different nodes distributed system communicating channels 
language extensions 
esp uses handle low level details accessing special device registers dealing volatile memory marshalling packets sent network 
studies proposed language extensions simplify low level handling 
features orthogonal current design esp language incorporated language 
devil designed easier write device drivers 
interface description language specifies communication devices device registers memory 
compiler automatically checks consistency specification generates efficient low level code 
format packets protocols described type system languages including esp packet format includes variable length fields depend fields 
marshalling code written translates data structures packet formats sent network 
doing manually tedious error prone researchers proposed extending type system express packet formats 
universal stub compiler usc allows precise description layout data structures 
chapter 
esp language support variable length fields 
packet types provides expressive type system supports layering protocols encapsulation variable length fields optional fields 
allows unmarshalling packets data structures 
support marshalling data structures packets 
automatic memory management 
automatic memory management safe program ming languages provided garbage collection allowing ex plicit memory management regions 
garbage collection involves runtime overhead terms processor overheads additional memory requirement unacceptable programmable devices 
region memory management tech niques free memory exiting dynamic contexts procedures 
unsuitable language esp dynamic context 
language design event driven state machines programming esp language adopts structures csp style syntax 
esp supports event driven state machines pro gramming 
designed allow programs easy write understand model checkers simplify debugging chapter generate fast chapter 
result design language strikes balance conflicting goals provide powerful flexible language features support compact readable event driven state machines programs 
allow compiler extract tractable models model checker 
specification language specifying models support limited features 
instance usually support pointers 
chapter 
esp language type array int type record dest int vaddr int size int type record vaddr int paddr int type union send update 
channel record ret int vaddr int channel record ret int paddr int channel record ret int paddr int size int channel record ret int data channel sm record dest int data channel external writer process sm true send dest vaddr size vaddr paddr paddr size sm dest free esp example implements state machine section 
allow compiler generate fast executables 
section discusses design esp language 
complete description language appendix shows esp code implements example section 
presents additional code implements page table 
section code fragments figures illustrate various language features 
chapter 
esp language process virtual physical address mapping table array int table size 
true alt case ret vaddr request look mapping ret table vaddr case update vaddr paddr request update mapping table vaddr paddr processes esp code implement page table 
concurrency esp expressed processes channels 
esp program consists set processes communicating channels 
processes esp implicitly encode state machines location process block implicitly represents state state machine section 
instance process add true chan chan process represents state machine states 
state initial state start process 
second state blocked waiting operation channel chan 
third state blocked operation 
chapter 
esp language degree concurrency supported esp language determines concurrency overhead incurred runtime 
minimize concurrency overhead esp supports concurrency top level process totally sequential 
reduce head processes esp static 
dynamically started run time 
allows compiler optimize programs effectively 
channels processes communicate channels 
messages sent channel operation received operation 
operations block 
instance process trying read channel block till process writes channel 
alt statement allows process wait operations different channels till ready complete 
alt statement esp traces origin guarded commands allows nondeterministic choice sequential programs 
alternation statement includes list guarded commands 
guarded command consists statement protected guard boolean expression 
execution alternation statement nondeterministically chooses statements guard evaluates true executes 
csp extends guarded commands allow input operation channel specified guard addition boolean expression 
languages amber allow input output operations guard 
introduces complications parallel implementation 
esp targeted run uniprocessor 
presence nondeterminism raises issue fairness 
multiple guards true alternation statement implementation chooses particular guarded command guarded commands starved 
referred unfairness 
types fairness guarantees provided weak fairness strong chapter 
esp language fairness 
weak fairness guarantees guarded command chosen guard remains continuously enabled 
strong fairness guarantees guarded command chosen guard enabled infinitely 
esp provides strong fairness 
noted fairness imply enabled guarded statements chosen equal probability 
esp communication channels synchronous unbuffered process attempting perform operation channel concurrently process attempting perform operation channel message successfully transferred channel 
consequently blocking operations 
synchronous channels benefits asynchronous buffered chan nels 
simplify reasoning message ordering channels 
especially true esp impose structure processes process communicate process 
instance process sends message process message process synchronous channels guarantee process receives message process second implemented efficiently buffered channels 
buffering required implemented explicitly programmer appendix 
third bounded unbounded buffering prob 
bounded buffering programmer handle eventuality send operation block 
unbounded buffering memory overflow result 
asynchronous buffered channels increase size state space explored model checking 
esp channels static class objects created dynamically stored variables sent channels 
design allows compiler perform optimizations effectively 
instance eliminates unnecessary allocation associated pattern matching section 
chapter 
esp language esp supports pure message passing communication channels 
allowing pro cesses communicate shared memory shared mutable data structures require esp provide additional mechanism locks avoid race conditions 
aspects esp prevent sharing data structures 
esp disallows global variables 
variable local single process 
second objects sent channels passed value 
support efficiently esp allows immutable objects sent channels 
applies object specified operation objects recursively pointed object 
esp supports immutable mutable data structures 
immutable object arriving channel mutated applying cast operation obtain mutable version object 
semantically cast operation causes new object allocated corresponding values copied new object 
compiler avoid creating new object number cases 
instance compiler determine object cast longer reuse object avoid allocation 
data types control constructs addition basic types esp supports complex data types union array 
distinguishes related domain specific languages :10.1.1.17.5606
languages designed express just control portion concurrent programs 
complex data structures managed externally language control portion program sufficient check number properties model checker burdens programmers requiring separate control data portions program 
contrast esp designed express control portion manipulation data structures 
requires esp address chapter 
esp language number additional issues dynamic memory management section mutable shared data structures section flexible external interface section 
esp support recursive data types reasons 
specification lan guages model checkers support recursive data types 
second sending recursive data types value channels involves additional run time overhead 
process esp completely sequential 
esp provides standard control constructs conditional statements loops traditional imperative languages 
esp support functions 
uses processes support abstraction 
example consider code fragment process implements page table maps virtual addresses physical addresses 
mapping maintained array table 
receives request translate virtual address physical address uses virtual address look mapping sends reply back requesting process 
variable ret identifies process making request reply directed back 
second case accepts requests update mapping updates table 
alt case ret vaddr request look mapping ret table vaddr case update vaddr paddr request update mapping table vaddr paddr pair operations mimic behavior functions calls expect return values 
instance constant represents process id process appendix 
chapter 
esp language vaddr paddr hand functions expect return value modeled single operation follows update vaddr paddr esp processes appropriate abstraction mechanism functions event driven state machines programs reasons 
process block channel nested function block section 
avoids problems arise function needs block channel section 
second process abstraction allows flexibility scheduling computation 
example return values expected response request update table code update table postponed performed 
dispatch channels features esp language pattern matching support dispatch efficiently 
pattern matching languages sml support expressive switch statements 
languages pattern matching support dispatch 
efficiency concern languages 
esp uses pattern matching support dispatch 
channel esp multiple processes receiving messages 
receiver specifies pattern operation objects match pattern accepted receiver 
object sent channel dispatched waiting receiver pattern matches object 
example process performs send dest vaddr size chapter 
esp language accept send requests process performs update vaddr paddr accept update requests 
process performs req object delivered process depending patterns matches 
pattern matching support dispatch advantages 
frees process sending message having examine determine receiver 
simplifies sender process program modular 
details objects process willing receive specified relevant receiver 
addition requires patterns specified various receivers channel having replicate dispatch code sender channel 
support pattern matching efficiently esp requires patterns receive objects channel disjoint object match exactly pattern 
addition distinct pattern process possibly times 
allows channel decomposed set ports section 
channel multiple readers multiple writers port multiple writers single reader 
esp channel pattern specifies port 
esp require patterns specified channel exhaustive ensure object sent channel unique tion reasons 
complex data types useless patterns usually fields nil get matched running program 
programmer write error process received objects chapter 
esp language types 
second ensuring object sent channel unique destination guarantee send channel succeed 
process statement receive objects execute statement 
memory management design memory management scheme esp driven goals 
programs safe 
bugs stemming difficult find 
problem compounded fact programs concurrent run devices minimal debugging support 
second memory management overhead small 
memory management schemes fall categories automatic explicit memory management 
hand automatic memory management garbage collection tech niques provides safety usually involves high overhead terms amount memory processing time 
hand explicit memory management involves lower overhead hard program correctly 
esp provides novel memory management scheme provides safety low overheads 
manage dynamically allocated memory provides free style interface incurs low overheads 
ensures safety model checker 
unsafe aspect esp explicit memory management scheme 
memory allocation bugs eliminated model checker resulting safe esp program 
key observation allocation bugs difficult find memory allo cation correctness global property program property inferred looking single module program 
programmer examine entire program sure allocated objects eventually freed accessed freed 
chapter 
esp language rectify esp memory allocation correctness local property process 
section describes design choices ensure processes share data structure 
noted support pure message passing style communication sufficient ensure processes share mutable data structures 
memory allocation correctness local property esp disallows sharing immutable data structures 
making memory allocation correctness local property allows model checker verify memory safety process separately section 
addition promotes modular programming 
objects sent channels passed value 
deep copy object delivered receiving process objects received channel treated newly allocated objects freed process 
possible complication occurs object contains multiple links object 
instance sender sends array entries point object 
deep copy preserved pointer sharing receiver careful free object stored object 
process sends different array entries point different objects receiving process free entries 
avoid deep copy esp preserve pointer sharing objects sent channels 
receiving process perform recursive free objects arriving channels 
addition implementation incur additional runtime overhead preserve pointer sharing 
esp provides malloc free style interface manage dynamically allocated mem ory 
allocation syntax various types objects section 
performs free recursively allow processes free allocated objects 
true semantically 
esp runtime copy object section chapter 
esp language esp allows dangling pointers pointers objects freed program execution 
dangling pointers allowed program delete pointers object object freed 
require additional bookkeeping place unnecessary burden programmer 
esp allows dangling pointers disallows pointers access memory 
ensures memory safety 
contrast usual approach ensure memory safety reclaim object pointers point 
avoids dangling pointer 
approach aware provides safety allowing dangling pointers region memory management 
uses type system guarantee dangling pointers run time 
memory allocation esp nonblocking operation 
concurrent program making memory allocation blocking advantages 
allows memory allocation request process find memory available block till process frees memory 
lead better memory utilization introduces additional synchronization processes 
forces programmer treat allocation potentially blocking sure cause program deadlock 
external interface esp support interface code testing code written specification language model checkers section 
esp relies implement low level details accessing special device registers dealing volatile memory marshalling packets sent network 
addition esp programs interact code written specification language model checkers currently spin debugging testing 
chapter 
esp language esp uses channels interface spin code 
regular channels different processes reading writing 
external channels processes reading writing channel spin code writing reading channel 
external channels regular channels synchronous 
different traditional approaches provide asynchronous interface 
languages allow code directly embedded program allow functions implemented externally invoked 
squeak uses primitive channels external interaction channels user definable built compiler 
channels provide external interfaces number advantages 
esp processes block external events arrival user request network pack ets 
channels allows process existing constructs block external events 
second external code dispatch mechanism built channels pattern matching 
promotes modularity 
instance retransmission longer required appendix retransmission processes dropped regular channels interact converted external channels 
processes channels affected tell difference external channel regular channel 
external interfaces follows interface 
interface illustrated example 
type record dest int vaddr int size int type record vaddr int paddr int type union send update channel interface writer send send dest vaddr size update update new chapter 
esp language declares external specifies external writer chan 
specifies list function suffix pattern pairs 
support synchronous interface channel esp requires types functions provided sync transfer functions 
sync function suffix returns code ready send data channel 
transfer functions called transfer data channel corresponding function indicated readiness 
channel requires single sync function provided 
requires separate transfer function pattern 
data transfer external channel involves call sync function fol call transfer functions 
second call performed immediately 
valid implementation check readiness different channels call transfer functions channels ready 
invoking transfer functions may cause external channels ready longer ready 
patterns external channels serves purposes 
supports dispatch external channels 
second minimizes amount allocation manipulation esp data structures done instance speci fying entire pattern need function allocate esp data structure 
hand allocate correctly initialize return esp record 
introduce allocation bugs system move allocation reach esp compiler preventing allocation optimized away 
chapter 
esp language spin interface 
generated spin model interface testing spin code provided programmer section 
spin supports synchronous channels esp channels simply translated synchronous spin channels 
external spin code interact directly generated spin model reading writing appropriate channels 
case study vmmc firmware vmmc firmware case study evaluate esp section 
vmmc firmware reimplemented esp compared earlier implementation event driven state machines esp resulted firmware significantly easier write understand maintain 
earlier implementation includes lines code lines implement fast paths 
contrast new im plementation esp required lines esp code lines code 
code implements simple tasks initialization initiating dma packet marshalling unmarshalling shared data structures code running host processor vmmc library vmmc driver 
complex state machine interactions restricted esp code uses processes channels appendix 
significant improvement earlier implementation complex interactions spread lines hard read code 
esp addresses problems programmers face programming event driven state machines section 
observed comparing code implementation supports vmmc functionality redirection feature currently supported 
fair comparison counted lines earlier implementation correspond functionality implemented new vmmc implementation esp currently esp support fast paths 
chapter 
esp language fragment figures equivalent esp code fragment 
esp addresses problems follows esp programs represent state machines implicitly processes 
avoids code fragmentation results having specify state machines explicitly addition esp uses processes implement functions 
avoids problem arises state machine needs block nested function call 
esp processes communicate sending messages chan nels 
channels provide defined interfaces different processes 
promotes modular programming process modular unit esp state machines communicated shared data structures 
esp supports dynamic memory managed modular fashion 
process independently manages memory explicit malloc free style interface 
instance process sm free longer needs worrying process 
explicit interface introduces model checker ensure safety chapter 
esp uses pattern matching support dispatch channels efficiently code processes read channel collocated 
placed relevant modules 
instance code handle requests located different processes 
esp uses channels interact external code implement low level device handling channels provides simple powerful interface code leveraging features built esp channels 
include ability wait events dispatch multiple processes 
chapter 
esp language esp currently support fast paths 
subject research section 
esp designed write firmware broad class devices 
contain features specific vmmc firmware myrinet network card 
far esp implement vmmc firmware myrinet network card 
useful validate design esp implement firmware devices 
current design esp left language features recursive data types essential 
experience writing firmware devices case adding support features esp addition low level device handling capability added esp reduce esp programs 
summary programming esp significantly easier programming event driven state ma chines addresses goal esp designed meet 
esp allows programs written concise modular fashion 
esp programs consist processes communicating synchronous channels 
process encodes state machine implicitly comprises modular unit esp program 
chan nels provide defined interfaces processes 
second dynamic memory managed explicitly esp programs 
novel scheme allows process independently manage memory 
promotes modular programming chapter 
esp language allows model checker verify safety esp programs 
third pattern matching support dispatch channels efficiently 
channels provide flexible powerful interface code 
low level device handling currently implemented vmmc firmware case study evaluate esp reimplemented esp compared earlier implementation event driven state ma chines esp greatly simplifies task writing firmware 
required times lines code earlier implementation 
earlier implementation required lines hard read code 
new implementation esp required lines esp code lines code 
complex interactions contained esp code portion written implement simple low level device handling 
chapter developing testing model checker device firmware reliable trusted operating system 
ability write location physical memory 
stray memory write resulting bug corrupt critical data structures operating system crash entire machine 
writing reliable firmware devices event driven state machines chal problem reasons 
concurrent programs inherently hard write correctly 
unforeseen interactions different sequential flows control resulting race conditions 
second problem compounded languages designed support event driven state machines programming 
event driven state machines programs written languages explicit interface sec tion requires state machines specified explicitly function pointers 
resulting programs difficult programmer understand compiler compile efficiently 
get performance programmer forced perform optimizations manually 
introduces subtle bugs program 
third limited debugging support available devices 
chapter 
developing testing model checker earlier implementation vmmc firmware implemented event driven state machines experience event driven state machines error prone difficult debug 
man years spent debugging vmmc firmware continue encounter bugs frequently 
bugs due race conditions occur infrequently hard find 
model checking promising approach building reliable concurrent software 
model checkers take model system explore possible interleaved executions concurrent system 
number possible executions grows exponentially size model models hide details original system necessary 
addition fraction model explored 
spite limitations systematic search performed model checker results extensive testing traditional methods 
model checkers require model program provided 
model checking effective model reasonably small 
general purpose languages include features unsafe pointers recursive data types difficult extract tractable models automatically 
esp language carefully designed esp compiler extract models model checking 
vmmc firmware case study demonstrate effectiveness approach 
rest chapter organized follows 
section discusses background 
section describes related 
section presents model extraction process esp compiler 
section presents experience spin model checker debug vmmc firmware 
section suggests directions research 
section presents summary 
chapter 
developing testing model checker background model checking technique verifying system composed concurrent finite state machines 
concurrent finite state system model checker explores possible interleaved executions state machines checks property verified holds 
global state system snapshot entire system particular point execution 
state space system set global states reachable initial global state 
state space systems finite model checkers principle exhaustively explore entire state space 
model checking verifiers check variety properties 
properties traditionally divided safety liveness properties 
safety properties properties satisfied specific global states system 
assertion checking deadlock safety properties 
assertions predicates hold specified point state machines 
corresponds set global states state machine specified point predicate holds 
deadlock situation corresponds set global states valid state 
liveness properties ones refer sequence states 
absence livelocks liveness property corresponds sequence global states useful gets done 
liveness properties usually specified temporal logics linear temporal logic ltl computation tree logic ctl 
advantage model checking automatic 
model system property verified model checkers automatically explore state space 
violation property discovered produce execution sequence causes violation helps finding bug 
problems model checkers 
state space explored exponential number processes amount memory 
chapter 
developing testing model checker resources required cpu memory resources model checker explore entire state space quickly grow capacity modern machines 
second specification language supported model checkers provides limited functionality 
straightforward translate concurrent programs written traditional programming languages specification language model checkers 
abstraction key addressing problems 
depending property verified model captures relevant details extracted 
prop erties involving small subsystems detailed models 
properties involving large subsystems models 
models usually extracted hand 
process time consuming 
addition hard sure model accurately captures actual system 
worse system evolves model independently updated reflect changes 
model checking verifiers greatly simplified models extracted automatically 
related model extraction approaches model extraction hand 
researchers verified various aspects ing systems model checkers 
efforts involved extracting model system hand 
spin verify interprocess communication subsystem harmony real time operating system rubis microkernel 
study significant effort needed extracting model 
spin develop verify synchronization protocol plan 
spin chapter 
developing testing model checker verify ipc system fluke os 
studies model checking verifier able find hard find race conditions 
automatic model extraction 
avoid problems model extraction hand researchers extracted models automatically source code 
teapot domain specific language implementing software cache coherence 
extracts model murphi model checker 
promela language implementing layered protocols 
compiler generates model spin model checker 
esterel language specifying synchronous reactive systems primarily hardware design 
esterel programming environment includes verification tools model checkers test programs 
esterel implement subset tcp protocol 
showed esterel generate efficient code 
report experience verification tools 
cases domain specific language encode control structure program 
rest program data handling handled different language typically 
compiler languages extracts single model reflects control structure program 
java pathfinder translates java programs spin models 
handles significant subset java including dynamic object allocation object exception processing inheritance 
handle features method overriding overload ing 
provide way details tractable model extracted 
verisoft uses different approach perform model checking concurrent system 
trying extract model explores state space system replacing scheduler concurrent system 
controlling scheduler force chapter 
developing testing model checker concurrent program execute possible interleavings 
allows apply model checking actual programs written traditional languages model 
problem explore smaller state spaces optimization techniques model checkers spin 
automatic model extraction support abstraction 
efforts focused extracting models verify different properties system 
extracts spin models programs written dialect simple extensions support event driven state machines 
system allows programmer specify pairs spin code patterns 
pattern encountered trans lation corresponding spin code generated 
approach automates extraction models 
translator semantic information check validity translation 
system debug call processing software lucent access server 
lie approach similar extract murphi models programs 
requires programmer specify things set patterns identify code captured extracted model transformations translate identified code murphi code 
uses program slicing extract additional code affects identified code 
standard slicing algorithms problems constructs pointers unions unstructured control flow 
check validity generated model 
bandera allows automatic extraction finite state models java programs 
uses techniques program slicing data abstraction allow tractable models extracted 
verify properties fairly simple program 
slam project extracts predicate abstraction check assertions sequential programs written predicate abstraction model boolean chapter 
developing testing model checker variables correspond conditions original program 
assertion checked predicate abstraction model checker 
checker may generate false positives symbolic execution verify counterexamples generated model checker 
counterexample invalid predicate abstraction refined eliminate counterexample 
approach extended handle concurrent pro grams 
debugging system software vast amount research focused problem debugging system software 
techniques span language design model checking compiler analysis runtime methods 
section discuss related area 
described section model checkers debug system soft ware 
focused debugging programs written general purpose languages java 
proposed domain specific languages designed model checking mind allow model checking effective 
meta level compilation provides framework extending compiler application specific code statically check certain properties application 
look bugs systems including cache coherence protocols flash multiprocessor linux kernel 
technique requires little change source code able find bugs systems 
compiler extensions look violations properties proper buffer allocation deallocation absence deadlocks 
extensions perform intra procedural analysis 
instances separate global pass combine data gathered intra procedural analysis different functions check global chapter 
developing testing model checker property 
static analysis inexact generate false positives 
bugs reported double checked programmer 
addition limited scope intraprocedural analysis generate false negatives 
eraser detects data races multithreaded programs 
instruments program binary check runtime lock protects shared variable access 
impose constraints programs works existing programs little modifications 
tool detect data races occur debugging runs programmer responsibility ensure program run different inputs tested thoroughly 
addition instrumentation results factor slowdown program execution 
prevent data races program occurring debugging 
programming language features prevent entire class bugs 
instance safe programming languages prevent program accessing dynamically allocated object freed 
vault language uses expressive type system enforce high level protocols system software 
type system allows module writer specify properties read system call read file called file opened open system call 
memory allocation bugs notoriously difficult find usually result memory corruption leads faulty behavior location program different site bug 
number tools help detecting memory allocation unsafe languages instance purify tool inserts code executable check number bugs invalid indices array accesses memory leaks 
allows detect error happens run time 
programmer responsibility run executable different inputs exercise possible program path 
different approach find limited class bugs buffer overruns formulate buffer overrun problem integer constraints problem chapter 
developing testing model checker statically check constraint satisfaction 
limitation approach flag false positives false negatives 
alternate approach dealing memory allocation bugs memory leaks avoid safe programming language section 
symbolic model checking alternative approach explicitly exploring entire state space symbolic model checking 
basic idea symbolic model checking compactly represent state space binary decision diagram bdd 
allows model checker check larger models 
symbolic model checking effective certain domains hardware circuits perform better explicit model checkers software systems 
extracting spin models esp supports model checkers develop test esp programs 
models extracted automatically esp program esp compiler 
check different properties program 
esp approach differs previous efforts follows domain specific language 
esp designed simplify task program ming devices easier extract models 
general purpose languages java language features complex pointer manipulation exceptions difficult translate specification language model check ers 
chapter 
developing testing model checker support abstraction 
domain specific languages extract single model program model checking 
avoid state space explosion associated detailed models languages designed encode control structure program 
contrast esp language provides support control structure data manipulation 
esp compiler uses abstraction discard unnecessary details generate tractable models 
esp compiler generates types models 
detailed models contain details esp program 
usually models check properties small subsystems 
memory safety models check program memory allocation bugs 
models contain details esp program relevant property verified 
models check system wide properties absence deadlocks 
class bugs usually involve different processes 
bugs especially hard find 
models find bugs vmmc firmware resulted deadlocks section 
esp compiler currently generates models spin model checker 
design esp tied spin 
esp compiler easily retargeted generate models model checkers murphi 
rest section organized follows 
section presents brief description spin describes chosen checking esp programs 
section describes esp compiler stages involved model extraction 
sections describes procedure extract detailed memory safety models respectively 
chapter 
developing testing model checker spin model checking verifier spin flexible powerful model checker designed software systems 
spin supports high level features processes rendezvous channels arrays records 
verifiers target hardware systems provide fairly different specification language 
esp translated languages additional state introduced implement features rendezvous channels primitives provided specification language 
state space explosion problem worse 
addition semantic information lost translation harder verifiers optimize state space search 
spin allows verification safety liveness properties 
liveness properties spin specified linear temporal logic ltl 
spin fly model checker build global state machine start checking property verified 
cases state space big explored completely partial searches 
provides different modes state space exploration 
entire state space explored exhaustive mode 
systems larger state spaces bit state hashing mode performs partial search significantly memory 
uses fact state spaces fairly sparse uses hash function obtain compact representation state 
hash function map states hash part state space may explored 
technique allows high coverage order magnitude memory 
simulation mode explores single execution sequence state space 
random choice possible states stage 
keep track states visited explore states multiple times exploring states 
simulation mode spin usually discovers bugs system 
simulators designed accurately chapter 
developing testing model checker mimic system simulated 
hard find bugs occur infrequently real system occur infrequently simulators 
spin simulator different random choice stage effective discovering bugs 
compilation stages esp compiler section compiles esp program optimized code stages section 
model extraction implemented intermediate stages 
esp compiler early right type checking reasons 
spin specification language support pointers 
translation difficult stage require compiler carry type information transformations intermediate representations 
second addition temporary variables compilation increases size state space explored 
disadvantage approach model checker catch bugs introduced compiler 
model extraction takes syntax tree generated type checker generates spin models stages abstraction preprocessor 
stage extracting models bypassed extraction detailed memory safety models 
drops details syntax tree programmer specified abstractions section 
model generator 
generates spin models syntax tree 
chapter 
developing testing model checker extracting detailed models spin detailed models extracted esp compiler contain details original esp program 
detailed models tend state able perform exhaustive exploration 
models useful developing debugging system simulation mode spin 
check properties small subsystems 
translation esp programs spin models fairly straightforward exceptions 
problems translation arise lack support pointers dynamic memory allocation spin 
processes channels 
esp processes channels directly translated spin processes rendezvous channels 
shows simple esp process implements mutual exclusion lock presents spin model generated esp compiler 
entire body esp process wrapped atomic statement generated model 
allows spin scheduling decisions blocking operations channels 
valid esp processes communicate updating shared variables 
absence atomic statement spin scheduling decision statement 
add new intermediate states increasing amount state space explored 
pointers dynamic allocation 
variables esp store pointers data objects 
instance variables point array object 
spin support pointers esp code fragment gets translated spin code shown 
spin code variable point different array objects 
causes entire object copied 
chapter 
developing testing model checker channel lock int channel unlock int process mutex owner owner true alt case owner lock owner case unlock assert owner owner esp program works immutable objects insufficient mutable objects 
instance update visible happen automatically andb point different array objects translated spin code 
address object assigned objectid allocation time 
objectid stored additional field object 
object gets copied due assignment operation objectid field gets copied 
ensures objects translated spin code share objectid represent single object original esp code 
mutable object gets updated esp code translated spin code includes code check update objects objectid 
esp code fragment gets translated spin code shown 
alternate approach dealing lack support pointers dynamic memory allocation spin maintain arrays heaps data objects type esp program 
pointers esp code translated indices array corresponding type 
object allocation allocate unused index chapter 
developing testing model checker mtype ok dont send dont recv chan lock num processes mtype int chan unlock num processes mtype int proctype mutex int pid int owner int atomic owner true nondeterministic conditional lock pid eval owner ok dont recv owner skip unlock pid ok assert owner owner fi break executed od spin model detailed generated esp code shown array int allocate copy pointer code fragment assigning immutable objects chapter 
developing testing model checker typedef int length int contents max array variable declaration int index array int contents contents length length length index index max contents index contents index index break od spin code corresponding esp code fragment array int allocate array int allocate copy pointer update code fragment ii assigning mutable objects chapter 
developing testing model checker typedef int length int objectid int contents max array int index array int contents contents length objectid new id array int contents contents length objectid new id length length objectid objectid index index max contents index contents index index break od contents objectid objectid contents skip fi objectid objectid contents skip fi spin code corresponding esp code fragment chapter 
developing testing model checker array free release index reuse 
assignment simply copy index variable variable object update index stored inb update corresponding object 
approach yield simpler translation taken esp compiler 
addition yield compact representation state 
multiple pointers esp program point object number different objects needed number pointers program 
approach result increase amount state space searched spin 
state stored spin state vector data objects laid particular order 
state equivalence determined comparing state vectors equality 
object gets assigned different indices different points run program appear different states spin represent state esp program 
approach taken esp compiler suffer problem 
approach taken esp compiler take longer execute state transition memory store state search smaller amount state space 
involves linear factors involves exponential factors 
arrays 
esp allows size arrays determined run time spin requires specified compile time 
problem addressed arrays fixed maximum size size determined compile time 
actual length array stored separate field object 
unions 
spin support union types 
esp unions translated record fields valid 
additional field added specifies record fields valid 
invalid fields union zeroed 
chapter 
developing testing model checker ensures extra memory store union object amount state space searched remains unchanged 
multiple instantiations 
ability run multiple instantiations generated spin model useful debugging 
instance setup vmmc firmware running cluster machines communicating modeled running multiple instances spin model extracted vmmc firmware connecting spin code mimics network 
cluster wide properties absence deadlocks verified approach 
support esp compiler generates spin models instantiated multi ple times 
spin process generated model provided started 
channel esp program translated array spin channels accessed indexing 
extracting memory safety models spin memory safety models generated esp compiler check mem ory allocation bugs program 
models essentially detailed models sec tion additional spin code inserted check validity memory ac cesses 
contain state detailed models 
spite models usually exhaustively explore state space allocation bugs 
memory safety individual process checked separately verifier section 
memory safety model includes additional code checks validity object accessed 
new object allocated unused objectid section assigned object 
object access code inserted model check object live 
array accesses include additional code check array index chapter 
developing testing model checker bounds 
union include code check field accessed valid 
object freed objects model objectid marked invalid changing objectid field 
memory safety model checks bugs accessing object freed double freeing object invalid array index 
addition find memory leaks process 
process generated model bounded number objects compiler determine bound 
arrays source unbounded allocation esp process esp support recursive data types 
esp compiler imposes bound maximum lengths arrays model extraction section bounding number objects model 
constraining model pick bound steady memory leak detected 
steady leak cause model run model checking 
extracting models spin models generated esp compiler omit details irrelevant particular property verified 
models significantly smaller state detailed models find bugs larger systems 
esp compiler conservative approximations generating mod els 
abstraction values model 
instance value variable model depended variable original program discarded abstraction 
compiler keeps track values sure model broadens scope model checking 
instance value condition conditional statement determined replaced nondeterministic chapter 
developing testing model checker choice model 
model checking branches conditional statement explored 
introduce new deadlocks model exist program false positives deadlocks program model allowing identified model checking 
esp program illustrate extraction process 
program implements functionality process translates virtual addresses physical addresses 
maintains table maps virtual page numbers physical page numbers 
accepts transla tion requests channel sends replies channel 
region contiguous virtual memory map set noncontiguous physical pages request sent yield multiple replies 
reply identified field reply 
process transfer computes pair vaddr size identifies region virtual memory 
sends request translate physical addresses 
receives physical addresses uses transfer data 
processes sending requests channel caller field channels match replies request 
transfer constant represents process id 
rest section describes models extracted esp starts description types abstractions supported compiler 
discusses techniques esp compiler extract models 
uses example show property absence deadlocks verified model 
chapter 
developing testing model checker define table size define page size define page page size define offset page size define addr page size type reqt record caller int addr int size int type record caller int bool addr int size int channel reqt channel process table array int table size 
omitted code initialize table true caller vaddr size assert offset vaddr assumes vaddr page aligned done bool false done paddr int addr table page vaddr look physical address chunk int page size size page size chunk size calculate size size size chunk done size caller done paddr size send reply process transfer true omitted code generates values variables vaddr size transfer vaddr size bool false transfer paddr chunk omitted code transfer chunk bytes address paddr esp program 
chapter 
developing testing model checker abstractions performed compiler specified pro grammer 
esp currently allows programmer specify types abstractions 
replacing types 
allows complex type replaced simpler type 
done specifying alternative type variables individually specifying alternative type type declaration 
instance original program contained type declaration type record caller int bool addr int size int programmer specify abstraction replace type record caller int bool currently esp requires replacement type supertype original type 
essentially allows fields records unions dropped 
replacing complex type simpler type significantly reduce amount state model 
instance code implement retransmission protocol accepts packets implemented union different types packets sent 
content packet little difference correctness retransmission code complex datatype representing packet replaced simpler type model 
amount state reduced size arrays model reduced 
size arrays affects performance correctness 
dropping variables 
variables affect validity property checked dropped altogether 
instance table keeps track chapter 
developing testing model checker mapping virtual physical addresses main memory relevant checking firmware deadlocks 
variable table process dropped specifying abstraction drop table abstractions specified programmer esp compiler uses generate models 
compiler performs type checking phase determines type expression original program abstractions account 
model generator phase apply abstractions statements fully typed program independently 
abstractions specified cause expressions statement value 
situations esp compiler uses nondeterminism conservative approximations strictly generalizes scope model checking 
various expressions statement classified classes left exp right exp handled follows left exp left exp expression determine memory location value stored 
expressions appear left side assignment statements operations channels 
consider statements type type tablet array record int int chapter 
developing testing model checker simplest cases left exp statement simply discarded model extraction 
instance variable dropped abstraction statement irrelevant discarded 
side effect statement variable similarly field dropped second statement discarded model extraction 
objects type longer field 
result statement remaining side effect generated model 
general case handled occurs second statement dropped 
case object pointed bya mutated change visible pointer pointing object 
handle case compiler determine list pointers aliased 
pointers generated model include nondeterministic statement updates object points update object 
nondeterministically updating large set objects dramatically increase amount state space explored 
result false positive bugs introduced model 
number techniques narrow list pointers aliased 
pointers type asa considered 
second pointers process aliased toa processes esp share objects 
third case dropped objects pointed entry array needs considered 
alias analysis reduce list pointers 
compile time analysis determine pointer aliased chapter 
developing testing model checker pointer situation reduces simple case statement simply discarded 
right exp expressions left exp expressions right exp expressions 
generate values various points programs 
appear right side assignment statements conditionals statements inout operations channels 
abstraction value right exp expression 
ideally expression replaced nondeterministically re turns valid value type expression 
cause model checker try possible valid values state space exploration 
boolean expressions values possible nondeterministic choice 
boolean expression conditional statement statement value longer computed replaced nondeterministic statement 
model checking branches conditional statement explored 
expressions trying possible valid values computation ally expensive model checking 
usually unnecessary small set values effectively explore entire space 
general way esp compiler determine set values sufficient cover entire state space 
esp compiler relies programmer supply set values 
type program boolean model needs nondeterministic value channel generated model 
value needed model performs read operation channel 
programmer responsible supplying values channel 
chapter 
developing testing model checker replace type reqt record caller int replace type record caller int bool drop table vaddr size paddr chunk drop transfer vaddr size paddr chunk abstraction illustrate models check property esp program 
check absence deadlocks program 
abstraction check program absence dead locks 
abstraction esp compiler generates model figures 
abstraction drops variables caller done process process transfer 
replaces types channels 
abstraction value boolean indeterminate value depends value variable size dropped 
compiler translates statement done size spin code nondeterministically assigns values true false fol lows skip done skip done fi spin model checker exhaustively explore entire state space states 
determine deadlocks 
contrast detailed model model checker potentially explore large number states trying possible values determine deadlocks 
chapter 
developing testing model checker mtype ok dont send dont recv typedef reqt int nil int caller typedef int nil int caller bool chan num processes mtype reqt chan num processes mtype proctype int pid int caller bool done atomic pid ok caller done done nondeterministically assign value done skip done skip done fi pid ok caller done break od od spin model part 
generated esp program abstraction chapter 
developing testing model checker proctype transfer int pid bool atomic pid ok pid ok break od od spin model part ii 
generated esp program abstraction replace type reqt record caller int replace type record caller int drop table vaddr size paddr chunk done drop transfer vaddr size paddr chunk abstraction chapter 
developing testing model checker compiler conservative approximations generating mod els model checker deadlock programmer error specifying abstraction 
programmer error cause spurious deadlock flagged 
instance abstraction results spurious deadlock programmer dropped variable done mistake 
consequently bugs detected model checker double checked programmer 
introduce deadlock program replacing line line done bool false done bool size cause deadlock size specified channel 
model checker find bug abstractions 
case study vmmc firmware earlier implementation vmmc firmware contains bugs man years spent developing debugging 
vmmc firmware reimplemented esp section 
spin model checker extensively develop test new vmmc firmware 
model checker development process 
traditionally model checking find hard find bugs working systems 
developing firmware network interface card involves slow painstaking process spin simulator implement debug 
debugged firmware ported network interface card little effort 
chapter 
developing testing model checker description esp abstraction generated type test program specification model model code retransmission protocol detailed safety safety safety safety safety safety safety safety safety safety absence deadlocks table sizes lines various files debug vmmc firmware 
second column shows size portion program relevant particular model 
third column shows number lines required specify abstraction 
fourth column shows size model generated esp compiler 
fifth column shows type model generated 
column shows number lines spin test code required 
described earlier spin test code test spin written check different properties 
code specifies property verified simulates external events network message arrival 
size test code usually fairly small 
models simplify task writing test code require smaller data structures sent channels 
table presents sizes test code abstraction specifications written debug vmmc firmware 
shows size models generated esp compiler 
test code written repeatedly system software evolves 
models extracted automatically software requires little programmer effort 
spin model checker useful developing testing vmmc firmware 
rest section describes situations model checker effectively summarizes experience model checker 
chapter 
developing testing model checker packet generator retransmission protocol model packet sink lossy network packet sink retransmission protocol model packet generator setup debug retransmission protocol 
shaded regions represent spin code provided programmer 
implementing retransmission protocol vmmc firmware implements simple known retransmission protocol reliably deliver packets packets dropped networking hardware 
protocol implemented sliding window protocol piggyback 
code implemented retransmission protocol developed debugged entirely spin model checker ported run network interface card 
retransmission subsystem involved processes developed sepa 
esp compiler extracted detailed model debugging 
setup shown 
instances model mimic machines communicating network 
programmer provided test code drive model 
instance model process packet generator constantly generates packets reliably sent network 
separate process packet sink accepts network packets 
packet generator process includes sequence number packet 
packet sink process checks see messages sent received exactly correct order examining sequence numbers 
second pair processes implements lossy network 
simulate lost packet network process nondeterministically drops packet 
chapter 
developing testing model checker process name 
states time memory stored matched sec mbytes table checking memory safety vmmc firmware spin 
case entire state space explored exhaustive mode spin 
stored column shows number unique states encountered matched column shows number states encountered visited 
spin simulator debug retransmission protocol 
explained earlier section simulator fairly effective finding bugs 
new implementation took days written debugged ported run successfully card 
earlier implementation taken days develop debug 
demonstrates esp greatly simplifies task programming firmware compared comparison effort required implementations fair protocol implemented standard described textbooks 
different graduate students performed implementations 
discounts possibility second implementation faster experience gained implementation 
verifying memory safety esp takes novel approach providing memory safety section 
sup porting safety garbage collection esp supports explicit malloc free style interface support dynamic memory management 
interface unsafe model checking verify memory safety 
allow esp designed chapter 
developing testing model checker memory safety local property process 
allows memory safety process verified separately running state space explosion 
esp compiler generates memory safety models include code check validity memory accesses 
models verify memory safety processes vmmc firmware 
process checked separately models small exhaustively explored spin model checker 
esp model generated catches bugs due invalid memory accesses memory leaks 
table presents amount state explored check memory safety esp processes vmmc firmware 
process entire state space explored exhaustive search mode spin 
biggest process required seconds processor time mbytes memory 
memory safety bugs vmmc firmware eliminated time esp compiler modified support memory safety models 
spin check earlier version firmware allocation bug 
verifier easily identified bug 
check effectiveness memory safety models variety memory allocation bugs inserted manually program 
bugs access objects freed invalid array index introduce memory leaks 
spin able quickly find bug case 
checking absence deadlocks system wide deadlocks result complex interactions program difficult programmers find 
model checking find bugs important 
model section check deadlocks firmware processes listed table involve dynamic allocation 
chapter 
developing testing model checker state space explosion difficult detailed models 
model exhaustive search possible partial searches performed 
partial search spin bugs firmware 
bug due circular dependency involving processes resulted deadlock 
identified deadlock avoided eliminating cycle 
second bug involved situation sliding window retransmission protocol full accepting new messages sent net 
eventually led new data packets accepted network 
incoming messages delivered fifo order explicit message unlock system trapped data packet resulting deadlock 
fix problem packets dropped occasionally allow explicit get 
bugs uncovered similar bug discussed example section 
result deadlocks application requested zero byte data transfer 
model checking allows bugs uncovered early debugging process 
highlighted fact bugs spin discovered conventional testing long vmmc implementation machines network 
bugs triggered firmware communicate vmmc implementations malicious buggy 
vmmc architecture requires firmware machines untrusted bugs fixed 
remaining bugs discovered involved receiving unexpected messages re expected messages 
bug involved receiving acknowledgments valid numbers 
fixed checking validity chapter 
developing testing model checker spin search limiting 
states time memory mode resource stored matched hr min sec mbytes exhaustive memory bit state hashing cpu time table checking absence deadlocks vmmc firmware spin 
cases state space exploration completed resource constraints 
stored column shows number unique states encountered matched column shows number states encountered visited 
numbers 
second bug involved receiving unexpected import reply message 
messages usually received response import request 
unexpected reply deadlock system 
problem fixed adding code discarded unexpected messages 
final bug involved receiving reply import request 
aware bug fixed 
including timeout eliminate bug 
state space exploration spin uncover bugs 
stated earlier section resource constraints prevented spin exploring entire state space 
table presents amount state space explored resources available 
exhaustive mode spin abort search seconds ran memory 
bit state hashing mode spin ran hours minutes search terminated user 
discussion partial searches fairly effective finding bugs concurrent programs 
state machine explored usually larger necessary state minimal state machine represented multiple times 
techniques abstraction optimizations partial order reduction try eliminate redundancy 
chapter 
developing testing model checker significant redundancy remains size state space exponential size model 
instance variable value ranges bearing property result state minimal state machine explored times 
partial search explores small fraction state space cover significant fraction minimal state machine 
source unnecessary increase state space explored models generated esp compiler 
problem stems fact object program get assigned different depending scheduling decisions prior allocation 
result single state manifests different states state space 
problem easily solved adding new feature spin model checker 
spin allow variables model marked store 
variables part stored state comparing states equality 
marked store 
absence store feature spin optimizations alleviate problem 
necessary objects memory safety models 
detailed models necessary mutable objects 
models esp compiler choose assign immutable objects 
second separate objectid table type process pointers point object type belong process 
reduce number different object get assigned 
model checker effective catching subtle bugs race conditions 
implementation vmmc firmware esp designed avoid bugs encountered earlier implementation addition esp language allowed complex interactions system implemented concisely lines 
surprising model checker uncovered bugs deadlock system 
chapter 
developing testing model checker highlights limitations careful code inspection programmer bene fits tools model checker explore various possible scheduling scenarios systematically 
model checker catches bugs early debugging process 
earlier vmmc firmware implementation encountered new bugs time tried different class applications ran bigger cluster 
spin model checker caught bugs vmmc firmware implementation detected traditional debugging methods section 
bugs encountered new version vmmc firmware running applications 
contrast applications run completion earlier version vmmc firmware implemented interesting direction research explore tradeoff radically different model checker verisoft section 
verisoft require model provided 
takes concurrent program explores state space manipulating scheduler 
model check programs written language including treats concurrent program black box perform certain optimizations performed model checker spin 
result size state space explore smaller 
verisoft allow freedom language designer 
model longer necessary design language longer constrained specification language model checker 
model needed compiler aid model checker number ways 
addition generating executable optimized efficient execution generate executables chapter 
developing testing model checker allow model checker effectively explore state space 
techniques described chapter generate executables check memory safety abstraction 
different way verisoft currently executable model checking regular execution 
summary spin model checker develop extensively test esp programs 
satisfies second goal esp designed meet 
model checker greatly simplified models automatically extracted esp programs esp compiler 
automatic model extraction increases confidence model accurately reflects program allows program little effort changes 
esp uses model checker development process 
traditionally model checkers find hard find bugs debugged system 
esp programs developed debugged entirely model checker 
debugged run devices 
approach avoids slow painstaking process debugging firmware running device 
vmmc firmware case study evaluate effectiveness model checker develop extensively test device firmware 
new implementation vmmc firmware esp spin model checker 
experience summarized 
esp compiler extracts types models 
detailed 
detailed model retains details original esp program 
early debugging stages simulator mode spin model checker 
exhaustively check small subsystems bugs 
chapter 
developing testing model checker detailed model develop debug retransmission protocol vmmc firmware spin simulator 
developed entirely spin ported run network card 
entire development process took days 
significantly better earlier implementation took days 
memory safety 
memory safety model allows spin model checker verify memory allocation correctness esp program 
novel design esp allows model checker check process independently ensure memory safety entire program 
checking various processes time model vulnerable state space explosion 
spin model checker able perform exhaustive exploration state space processes vmmc firmware 
identified bug earlier version firmware 
memory allocation bugs double freeing accessing object freed memory leaks deliberately inserted firmware 

models generated compact tractable omit details esp program irrelevant property ver ified 
compiler uses programmer annotations generate conservative models 
models conservative retain bugs original esp programs 
generate false positives 
abstraction essential obtaining models identifying bugs result violation system wide properties 
state space explosion pre detailed models check system wide properties absence deadlocks vmmc firmware 
models successfully identify bugs firmware cause deadlock 
chapter 
developing testing model checker state space explosion constant problem model checkers 
partial state space exploration possible due resource constraints 
cases impossible sure bugs system identified 
partial systematic search model checker results extensive testing traditional testing methods invaluable debugging concurrent systems 
chapter generating efficient code performance crucial device firmware performance device firmware determines fraction hardware performance delivered applica tions 
device firmware achieve performance event driven state machines requires significant programming effort section 
usually function pointers encode state machines difficult compilers effectively optimize programs 
result programmer forced manually perform optimizations 
requires significant programmer effort introduces bugs programs 
esp compiler compile esp programs generate efficient code 
esp provides number language features simplify event driven state machines programming chap ter 
features designed compiler effectively compile 
frees programmer having manually optimize programs 
vmmc firmware case study measure performance impact esp microbenchmarks applications compare performance chapter 
generating efficient code implementations firmware new implementation uses esp earlier implementation rest chapter organized follows 
section presents existing techniques compile concurrent program run efficiently single processor 
section discusses related 
section describes techniques esp compiler generate efficient code 
section measures performance impact esp implement vmmc firmware 
section discusses compiler optimiza tions intend explore improve performance esp programs 
section summarizes chapter 
background main approaches compiling concurrent program run efficiently single processor automata process approach 
automata approach essentially treats process concurrent program state machine combines state machines program generate single global state machine 
global state machine contain concurrency translated directly sequential machine code 
advantage approach concurrency compiled away program incurs runtime overhead support concurrency 
code generated extremely fast 
global state machine generated worst case exponential size individual state machines 
optimization techniques alleviate code blowup problem identifying eliminating duplicated code 
code blowup remains exponential worst case 
process approach generates code different processes separately dynamically context switches 
processes chapter 
generating efficient code essentially state machines small amount state just program counter register needs saved restored context switch 
stack registers temporarily useful state needs saved context switch 
process approach runtime overhead overhead fairly low 
related number concurrent languages compilers compile concurrent program run efficiently single processor 
esterel synchronous language designed model control concurrent systems section 
earlier esterel compilers automata approach generate code 
gate compilers implemented 
avoid code blowup occurs automata compiler incur runtime overhead 
gate compilers translate esterel program synchronous circuit generate code circuit 
translation efficient synchronous hardware circuit efficient software nontrivial involves runtime overheads 
process compilers implemented esterel 
handle subset valid esterel programs valid schedule concurrent esterel program determined statically 
edwards evaluates tradeoff approaches automata approach gate approach process approach ing esterel programs 
expected automata compiler generates fastest code size executable orders magnitude larger gate compilation technique applies synchronous languages esterel applicable esp chapter 
generating efficient code approaches 
gate compiler generates fairly compact code times slower automata compiler 
process approach generates code twice slow automata approach yields smallest executables 
section supports processes synchronous channels uses process approach generate sequential code 
techniques implementation similar esp context switches rendezvous expensive operations 
squeak section uses automata approach generate sequential code 
considers possible interleavings concurrent program 
stage unblocked processes executed step 
random number generator select process multiple processes ready execution 
filter fusion uses automata approach fuse filters 
concurrent program expressed sequence filters adjacent filters communicate 
sequential program obtained successively fusing pairs adjacent filters single filter technique similar esterel compilers 
integrated layer processing ilp implementation technique improving performance layered network protocols 
protocol implemented sequence layers layer manipulates data packet hands layer 
ilp reduces number data accesses combining packet manipulation loops different layers integrated processing loops 
ilp appropriate layers manipulate data portion large packets checksum computation encryption 
performing operations need examine entire packets computationally expensive performed slow processor devices 
contrast esterel programs deterministic possible schedules yield result 
require random selection stage 
chapter 
generating efficient code operations usually performed host processor special purpose hardware engines devices 
generating optimized code esp compiler compiles esp program optimized code 
uses process approach generate sequential code concurrent program 
perform program analysis compiler requires entire program available compilation 
esp compiler uses back language 
compiles esp program large function looks assembly program 
statement function performs simple operations operand arithmetic operation transfer control different part function statement 
back language advantages 
esp compiler portable different devices little effort device vendors provide compiler device 
second esp compiler rely compiler register allocation benefit optimizations performed 
compilation stages esp compiler implemented sml nj 
different modules involved code generation follows scanner parser 
module reads esp program builds syntax tree ast 
chapter 
generating efficient code type checker 
type checker traverses ast checks type correctness program 
esp allows types unspecified inferred type checker performs simple type inferencing statement basis 
convert ir 
high level ast converted low level intermediate represen tation ir suitable performing optimizations 
channels ast translated ports ir 
channel multiple readers multiple writers port multiple writers single reader 
esp reader channel separate disjoint pattern read section 
channel represents group ports port identified pattern reader 
patterns eliminated translation channels ports 
sender channel matches data sent possible patterns sends values appropriate port 
eliminates unnecessary allocation associated pattern matching 
instance sender allocated record fields send channel receiver uses pattern receive fields esp compiler avoids allocation sending unboxed values channel 
operation channel broken operations ir 
operation synchronizes sender receiver 
operation transfers data sender receiver 
data sent computed operation 
avoids unnecessary computation process waiting multiple channels alt statement 
instance object allocated sent channel allocation postponed allocation happen alternatives succeeds 
high level control constructs loops translated low level control constructs goto 
high level data constructs record array translated chapter 
generating efficient code uniform low level object representation 
processes esp program kept separate ir consists set processes 
process simplified control data constructs communicates processes sending data ports 
optimizers 
optimizers perform standard optimizations constant folding copy propagation dead code elimination process basis 
optimizer expects ir input generates optimized ir various optimizers applied number times sequence 
compilers perform optimizations esp compiler rely compiler effectively perform optimizations generated code 
processes combined single function code generation 
semantic information lost code generation hard compiler perform optimizations effectively 
code generation 
esp compiler uses process approach section combine processes single function 
uses process approach avoid exponential code blowup associated automata compilers section 
addition esterel legal esp programs compiled process approach 
scheduling run time system performs nonpreemptive scheduling context switches performed blocking operations reading writing channels 
runtime system maintains ready list processes ready execute 
ready processes executes idle loop 
idle loop polls messages external channels chapter 
generating efficient code processes blocked 
message available unblocks corresponding process restarts jumping location blocked 
process executes till reaches channel operation 
point synchronize process complete channel operation continue 
choice available scheduler picks processes randomly performs channel operation 
point synchronizing processes ready execute 
scheduling policy picks processes continue execution inserts ready list 
executing process blocks process ready list chosen execute 
repeated till processes left ready queue 
execution returns idle loop 
avoid starvation esp uses simple fifo scheduling policy 
distinguishing feature synchronization operation chooses process receiving channel continue 
sending process inserted ready list 
glance appear introduce starvation 
instance processes repeatedly send messages messages starve processes 
happen synchronization operation sending process queued ready processes 
external channels require additional care avoid introducing starvation 
internal channels runtime system maintains invariant port reader writers blocked 
writer arrives synchronization point finds reader waiting port writer deduce writers waiting port 
writer check writers synchronizing reader 
difficult maintain invariant external channels external event cause external port ready synchronization instant 
additional check performed ensure fairness external channels 
chapter 
generating efficient code second message external channel get ignored long periods time 
new external messages detected locations 
running process checks availability new messages channels available blocks channel 
subsequently control reaches idle loop idle loop checks new messages external channels 
problem processes continuously receiving external messages control return idle loop 
result processes blocked external channels get restarted new messages available 
avoid problem esp scheduler periodically returns control idle loop ready queue empty 
memory management programmer perspective process set objects managed separately process section 
process allocates objects frees free 
objects sent channels deep copied handed receiving processes 
objects arriving channel treated newly allocated objects freed process 
implementation uses counting scheme manage objects 
semantically processes share objects implementation shares objects processes efficiency copying objects computationally expensive 
runtime sys tem maintains counts keep track number processes sharing object 
recursive increment decrement operations cyclic data structures require additional bookkeeping avoid infinite loops 
esp allow cyclic data structures allows operations implemented efficiently 
normal allocation causes objects allocated count initialized 
object sent channel count object recursively chapter 
generating efficient code incremented avoiding expensive deep copy operation giving receiving process 
process frees object count decremented 
object deallocated processes freed count zero 
deep copy performed data structure sent channel preserve pointer sharing section 
benefits 
allows copying semantics implemented efficiently simple recursive increment count suffices 
object pointed multiple times data structure count incremented multiple times 
second allows correctness memory allocation local property process 
pointer sharing preserved receiving process need know sharing check data structure correctly freed 
determine sharing pointer comparisons allowed esp example illustrates problem copying semantics preserves pointer sharing 
cast immutable object mutable object require copying object 
program detect object sharing mutating location observing change location 
cast operation fairly uncommon esp programs 
addition copying necessary 
copy avoided cast necessary program written carefully allow compiler optimize 
instance count immutable object process holding object object freed immediately cast compiler avoid copy object 
design choices esp language allow implementation share objects providing illusion disjoint set objects 
immutable objects sent channels 
program detect object shared mutating process observing change process 
second objects chapter 
generating efficient code type record int channel array process process assert length free process process process process example illustrate problems copying semantics preserves pointer sharing 
expects array elements channel 
receives process frees entries proceeds entry 
process process sends array channel process execute correctly entries point different objects 
process process sends array channel process try access record freed resulting error 
chapter 
generating efficient code type record int channel array process process free example shows traditional counting scheme sufficient esp compared pointer equality 
prevents program comparing pointer different objects detecting implementing object represent 
esp support recursive data types program cyclic data structures 
means recursive count increments deal infinite loops due cyclic data structures implemented cheaply 
traditional counting schemes maintain counts objects differently esp traditional scheme counts incremented root decremented recursively count object zero 
earlier suggested sufficient esp 
turns sufficient 
consider example 
till point objects sent channel schemes kept chapter 
generating efficient code counts objects objects pointed variables count 
performing send operation traditional scheme increment count array object esp scheme increment count objects 
scheduler chooses schedule free statement executed 
traditional scheme cause count object pointed go zero freeing object 
generate error process scheduled run tries access 
esp scheme count object pointed byp decremented object freed 
allows process access 
case study vmmc firmware section compare performance earlier vmmc implementation vmm performance new implementation esp 
esp currently support fast paths performance earlier implementation fast paths commented 
allows separate actual cost esp difference vmm benefit fast paths difference 
microbenchmarks applications measure implementa tions vmmc 
hand microbenchmarks measure specific aspects communication latency band width stressing 
allows isolate understand cost esp section examines problem supporting fast paths esp chapter 
generating efficient code represent worst case scenario 
hand actual performance impact observed application 
applications usually exhibit complex communication patterns microbenchmarks 
sensitive firmware performance 
microbenchmark performance microbenchmarks 
microbenchmarks measure performance performance implementations esp microbenchmark involves running different machines communicate vmmc 
latency microbenchmark measures latency sending message particular size machines 
measured simple pingpong program sends message back forth machines 
latency computed bandwidth microbenchmark measures bandwidth achieved machines sending messages particular size 
measured program machine continuously send messages size program second machine repeatedly receiving messages 
bandwidth computed chapter 
generating efficient code latency message size bytes latency microbenchmark bidirectional bandwidth microbenchmark measures total bandwidth machines machines sending messages particular size 
bidirectional bandwidth computed platform 
microbenchmarks measurements pair pcs 
pc mhz pentium processor mb memory myrinet network interface card lanai mhz processor mb board sram memory 
nodes directly connected myrinet cable 
pcs run windows nt 
performance 
figures microbenchmark performance 
case axis shows message size 
latency microbenchmark shows twice slow byte messages slower kbyte messages 
graphs discontinuities byte boundary kbyte boundary 
small messages bytes handled separately special case 
page size kbytes 
chapter 
generating efficient code bandwidth mb bandwidth mb message size bytes way bandwidth microbenchmark message size bytes bidirectional bandwidth microbenchmark slower worst case byte messages comparable performance byte kbyte messages 
bandwidth microbenchmark shows delivers bandwidth kbyte messages kbyte messages 
slower kbyte messages kbyte messages 
bidirectional bandwidth microbenchmark shows de bandwidth kbyte messages similar performance kbyte messages 
slower kbyte messages similar performance kbyte messages 
chapter 
generating efficient code main processors network card splash application vmmc library svm library device driver vmmc firmware network experimental setup splash application vmmc library svm library device driver vmmc firmware uniprocessor application problem size execution time base speedups seconds fft points matrix molecules molecules particles volrend head table splash applications microbenchmark performance shows performs significantly worse certain cases latency small messages 
perfor mance difference due fast paths 
fast paths effective communication pattern simpler 
performance difference significantly bidirectional bandwidth microbenchmark firmware deal messages arriving network host time 
marks firmware deal type message instant 
chapter 
generating efficient code application performance applications 
shows experimental setup run applications 
splash applications run cluster smp nodes vmmc software communicate 
applications run top shared virtual memory svm library turn runs top vmmc library 
vmmc software architecture discussed section 
applications splash suite parallel applications shared address space communicate 
versions applications study restructured perform cluster loosely connected nodes 
restructuring involved simple changes decrease amount com munication padding aligning reordering fields data structures synchro algorithmic changes reduce amount locking 
splash applications corresponding problem sizes listed table 
shared virtual memory svm library provides shared address space ab software cluster nodes access physical memory directly 
vmmc implementation esp currently imple ments vmmc interface described version svm library uses vmmc interface 
platform 
applications measurements cluster smp pcs 
pc mhz pentium processors gb memory myrinet network interface card lanai mhz processor mb board sram memory 
nodes connected myrinet crossbar switch 
pcs run windows nt 
extensions vmmc proposed improve performance svm currently supported 
chapter 
generating efficient code speedup fft volrend splash application splash application performance speedup processors way smp nodes 
number top bar shows relative speedup compared 
chapter 
generating efficient code performance 
performance splash applications 
axis shows application speedup running processors 
performance applications shown versions vmmc 
performance hit esp difference performance applications versions 
shows average performance difference versions 
applications incur performance hit fft volrend 
performance benefit applications fast paths dif ference performance applications versions 
shows fast paths little impact applications 
largest benefit observed 
discussion applications incur smaller performance hit compared microbenchmarks rea sons 
microbenchmarks represent applications spend time communicating real applications spend fraction time communi sensitive vmmc performance 
second applications fairly insensitive certain communication parameters latency bandwidth sensitive parameters host overhead interrupt costs 
vmmc firmware affect parameters determined code os vmmc device driver library running host cpu 
fft performance version shown bug implementation prevents application running completion fft conservatively approximate performance 
chapter 
generating efficient code applications run significantly faster adding right function ality network interface card 
instance similar set splash applications observed increase performance additional network support added vmmc avoid asynchronous protocol processing svm library 
respect esp help improve applications performance making easier experiment add new functionality firmware 
fast paths implemented small impact application formance significant benefit microbenchmarks reasons 
reasons previous paragraph apply case 
addition fast paths fairly brittle 
designed provide better performance simple situations expected occur frequently 
communication intensive applications cause high contention network card com plex communication patterns 
result fast paths get taken applications 
indicated measurements reported earlier study actual message latency measured running different applications varied times times slower microbenchmarks measurements small messages 
section presents general discussion fast paths robust fast paths built supported esp fast paths fast paths provide better performance commonly executing paths program fig ure 
modular programs reusable readable maintainable 
chapter 
generating efficient code modular program predicate specialized code fast path bypasses modular program 
blocks representing fast path components shaded 
usually incur additional overhead program execution crosses module boundary 
fast paths avoid overhead common cases 
fast path consists components predicate identifies common case specialized code optimized efficiently handle common case 
specialized code corresponds execution path modular program taken absence fast path 
composed code fragments extracted different modules 
allows fast paths avoid module crossing overheads 
amenable compiler optimizations 
languages provide support fast paths 
allow fast paths implemented manually programmer programmer insert predicate program check common case transfer control specialized code 
programmer responsible providing specialized code equivalent chapter 
generating efficient code corresponding path program 
violates modularity fast paths error prone 
esp currently support fast paths 
esp enforces modularity prevents fast paths implementing manually programmer 
support fast paths esp questions need answered 
select fast paths 
fast paths effective fast paths executed significant percentage time fast paths common 
main approaches selecting fast paths 
commonly executed paths identified profiling running program 
past research path profiling focused sequential programs need extended concurrent programs 
advantage approach fast paths identified actual running program 
disadvantage scheduling choices order external events processed influence paths common 
especially true language esp additional scheduling decisions schedule various processes concurrent program 
right scheduling policy help fast path executed 
second programmer intuition program behaves programmer annotate program specify fast paths provide hints right scheduling policy 
provide programmer control program execution 
languages provide limited annotation capability allow conditional statements tagged indicate usually evaluates true false 
problem program annotations places additional burden programmer 
addition programmer intuition wrong 
approach best esp probably combination approaches 
programmer specify fast paths provide hints right chapter 
generating efficient code scheduling policy program profiling check annotations useful 
generate fast paths 
fast path identified pair predicate path program esp compiler extract path 
challenging problem reasons 
hard statically determine predicate specified corresponds path specified 
option insert checks code verify run time paying runtime cost 
alternative trust specification risk introducing bugs program 
model checker check specification case 
second fast path involves code extracted different processes scheduling decisions 
esp compiler ensure intro duce starvation program 
number research projects investigate fast paths sequential programs 
project manually generated fast paths hp ux operating sys tem 
show file system calls read speeded generating specialized code invariants quasi invariants available file opened 
scout operating system paths explicit abstraction mechanism improve resource allocation scheduling decisions 
uses compiler optimizations outlining cloning path inlining improve performance fast paths 
paths dynamically created compiler optimize paths 
address compiler generates optimized code paths 
path chapter 
generating efficient code created runtime runtime system determine optimized code available path uses optimized code 
formal methods build optimized fast paths ensemble net architecture 
protocol stack consists sequence protocol layers 
nuprl system semiautomatically extract fast path protocol stack 
ensures fast path generated provably semantically equal protocol stack fast path predicate holds 
support robust fast paths 
experience fast paths vmmc firmware shows difficult build robust fast paths 
ends fast paths help simple applications microbenchmarks little impact applications 
specific fast path predicate specialized efficient fast path 
means predicate satisfied 
difficult identify right point tradeoff 
possible solution problem build number fast paths increasing degrees specialization 
mean program benefit aggressive fast paths predicate holds benefit sive fast paths 
programming building number fast paths esp require small amount programmer effort compiler support fast paths 
compiler optimizations number compiler optimizations improve performance generated code 
data flow analysis extended perform interprocess analysis currently analyzes process separately 
optimizations fairly effective chapter 
generating efficient code esp programs reasons channels esp static section processes communicate channels 
second automata approach section adapted perform process inlining selectively 
automata approach combines processes single process avoiding process context switching overheads 
results significant increase code size 
contrast process inlining combine processes 
instance process implement function section process inlining inline process calling processes 
summary esp compiler compiles esp programs code incurs low performance overhead runtime 
meets third goal esp designed meet 
esp compiler compiles concurrent esp program run efficiently single processor 
uses process approach compile concurrent program run single processor 
context switch fairly lightweight involves saving restoring program counter 
language design allows compiler aggressively optimize programs 
language fairly static processes channels know compile time 
allows compiler implement pattern matching channels efficiently 
messages sent channels passed value runtime system uses counting allocator avoid copying messages 
creating copy messages message send operation inefficient 
vmmc firmware case study measure performance impact esp write device firmware 
performance new implementation uses esp compared earlier implementation performance measured microbenchmarks applications 
chapter 
generating efficient code microbenchmarks measurements show performance difference firmware implementation esp earlier implementation usually small 
cases difference significantly high 
instance esp im plementation involves twice latency implementation sending byte messages 
case entire difference result fast paths implementation currently supported esp obtain fairer comparison version implementation include fast paths 
measurements show esp implementation performs worse latency microbenchmark worse bandwidth microbenchmark 
performance impact esp applications small 
measure formance splash applications firmware implementations 
mea show applications run slower average worst case esp version relative version 
show fast paths implementation little impact applications performance 
chapter directions thesis presents design implementation esp domain specific language programmable devices 
esp designed meet goals ease programming 
esp easier write device firmware event driven state machines 
allow firmware expressed concisely modular fashion 
minimize allowing bulk program written esp support dispatch dynamic memory management flexible external interface extensive testing 
device firmware trusted operating system write address physical memory 
bug firmware compromise integrity entire machine 
result firmware needs extensively tested ensure reliability 
challenging reasons 
concurrency difficult find bugs resulting race conditions 
second limited debugging support available devices 
low performance overhead 
effectiveness device firmware depends speed respond events occurring devices 
esp chapter 
directions minimize overhead incurred language features provides 
ad dition allow aggressive compiler optimization generate fast executables 
event driven state machines meets goals listed 
traditionally event driven state machines develop firmware devices 
instance earlier implementation vmmc firmware programmed event driven state machines experience vmmc firmware showed event driven state machines meets performance goal 
programs hard write maintain debug 
forces state machines specified explicitly 
addition compiler optimize programs effectively programmer forced perform optimizations manually 
degrades readability code 
introduces subtle bugs program 
man years spent debugging vmmc firmware continue encounter bugs frequently 
esp meets goals 
number language features allow development compact modular programs 
spin model checker develop extensively test programs 
uses models generated automatically esp compiler 
debugged esp programs compiled efficient device firmware esp compiler 
vmmc firmware case study evaluate esp vmmc firmware reimplemented esp compared earlier implementation rest chapter discuss directions research 
chapter 
directions language support ease programming esp designed simplify event driven state machines programming 
state machines specified implicitly processes 
processes communicate sending messages channels 
esp provides number novel language features 
provides explicit malloc free style interface dynamically allocate memory 
easier perform allocation correctly esp allows process manage allocation independently 
allows model checker spin exhaustively check allocation bugs program 
second pattern matching support dispatch channels efficiently 
third channels provide flexible powerful interface esp compiler implemented standard ml new jersey sml nj required lines code 
vmmc firmware reimplemented esp required lines esp code lines code 
portion program written implement simple low level operations accessing device registers volatile memory 
contrast earlier implementation required lines code 
esp implementation significantly easier implementation 
required factor fewer lines code 
addition complex interactions esp implementation confined lines esp code 
earlier implementation complex interactions scattered entire program 
number things remain done 
esp extended support low level operations 
currently uses perform operations 
second esp far write firmware single device myrinet network interface card 
experience writing firmware devices necessary validate effectiveness esp chapter 
directions extensive testing model checker model checking verifiers spin develop extensively test esp pro grams 
esp compiler automatically extracts spin models model checker 
greatly reduces effort required model checker 
allowed model checker just find subtle deadlocks late development process initial development 
allows programmer avoid slow painstaking process developing firmware device 
deal state space explosion problem esp compiler generates different models different purposes detailed models usually simulation mode initial development memory safety models check allocation bugs models check system wide properties absence deadlocks 
spin model checker develop debug new implementation vmmc firmware esp spin implement retransmission protocol 
new implementation esp took days compared earlier implementation took days 
spin exhaustively check firmware memory allocation bugs 
allocation bug early implementation firmware 
allocation bugs manually inserted verify effectiveness 
spin identify bugs firmware models 
bugs cause firmware deadlock 
interesting direction research explore tradeoff cally different model checker verisoft 
verisoft require separate model provided uses concurrent program model explores state space controlling scheduler runtime 
allow freedom language design 
chapter 
directions generating efficient code esp compiler compiles esp programs generate efficient firmware 
context switch fairly lightweight context needs saved restored program counter 
design language facilitates aggressive optimizations 
allows counting allocator implement sending messages channel value semantics creating copy message 
addition processes channels known compile time pattern matching channels implemented efficiently 
measurements vmmc firmware case study indicate performance impact esp write device firmware small 
esp currently support fast paths performance difference implementations broken components impact supporting fast paths esp impact esp microbenchmark measurements show esp version performs worse latency microbenchmark worse bandwidth microbenchmark 
splash applications esp results performance hit average 
measurements indicate fast paths implementation little impact application performance significant impact microbenchmarks latency byte messages improved factor due fast paths 
number compiler optimizations added esp compiler improve performance generated code 
data flow analysis extended perform inter process optimizations 
addition optimizations process inlining avoid process context switch overheads cases 
esp compiler provide support fast paths 
require research answer challenging problems 
compiler identify fast paths chapter 
directions concurrent program 
second compiler extract fast path optimize 
third fast paths robust benefit microbenchmarks simple communication patterns applications 
appendix esp language appendix describes event driven state machines programming esp language programmable devices 
esp designed simplify task implementing reliable high performance firmware devices 
lexical issues identifier identifier sequence letters digits underscores starting letter 
identifiers esp case sensitive 
appendix represents identifier 
keywords keyword reserved identifier special meaning esp appendix keyword shown bold 
comments esp supports style comments 
comments enclosed line 
appendix esp language notation appendix presents grammar esp notation program 
separated program dec dec program consists sequence type channel process declarations 
concurrent program specifies set processes communicate channels 
data types syntax types type declarations esp type id ty appendix esp language ty int bool id 
record 
union 
array ty id ty named types built types int bool predefined 
named types defined previously defined built types 
type declaration creates new type type incompatible types 
esp support recursive types esp programs circular data structures 
records unions record union types specify sequence named fields 
fields record valid 
exactly field union valid 
order fields records unions significant 
valid field union read 
writing different field mutable union invalidates fields 
arrays array indexed list objects particular type 
length array specified type determined array allocation run time 
mutable types esp supports mutable immutable version records arrays unions 
indicate type mutable 
examples code immutable record types immutable union type mutable array type 
type record dest int vaddr int size int type record vaddr int paddr int type union send update type tablet array int appendix esp language channels channels esp declared follows channel id ty channels provide way processes communicate 
channels synchronous buffering channels 
immutable types specified channel 
processes processes esp specified follows process id process represents sequential flow control specified 
processes need stack implicitly encode state machine 
process dynamically created 
expressions expr constant lvalue lvalue allocation expr ty expr ty expr bop expr expr appendix esp language constant id 
true false nil allocation 
expr 
id expr 
expr expr 

expr bop length expression expression side effect free allocation piece code evaluates value 
constant integer constants 
sm integer constant uniquely identifies process sm 
optional process name left defaults current process 
true false boolean constants 
nil constant valid arrays records unions 
allocation record allocated specifying values fields order 
union allocated specifying valid fields value fields separated 
array allocated ways identified expression 
size value obtained computing specified expression provided initialize entries 
second entries specified 
mutable version data structure allocated prefix 
note data structure allocated dereferenced expres sion 
instance invalid 
appendix esp language types type expression specified separator 
type cast object cast different type cast operation specified 
casts valid 
esp allows mutable object cast immutable object vice versa 
cast operation causes allocation returns semantic deep copy object cast described section 
programmer responsible freeing objects allocated cast 
operators operators esp precedence associativity 
esp disallows pointer comparisons 
lvalue id lvalue id lvalue expr lvalue ty id pattern lvalue pattern ty constant pattern id pattern value value expression specifies memory location may read written 
access fields records unions access array entry 
prefix specifies new variable declaration current scope 
pattern pattern provides convenient way access components data structure 
pattern matches data structure values pattern assigned corresponding values data structure 
rest pattern appendix esp language pattern matching 
components correspond pattern ignored 
pattern value 
ml patterns allocations similar syntax 
distinguished position statement 
considered pattern occur value position cause allocation occur value position 
instance sr ur send sr ur send send dest vaddr size ur code line newly allocated record 
second line initializes ur newly allocated union valid send field points record 
third line newly allocated union valid send field points newly allocated record 
fourth line pattern left hand side pattern matching causes vaddr initialized respectively 
esp patterns support dispatch channels section 
new variables declares new variable current scope 
variables initialized variable declaration 
statements stmt pattern expr assert expr lvalue expr stmt stmt expr stmt exactly field union valid appendix esp language break alt case expr stmt stmt id pattern id expr free standard statement esp supports standard statements assignment statements supported imperative languages 
simple type inferencing esp allows type expression unspecified inferred context statement 
instance types specified variable declarations 
int array int statements need specify type 
array int nil record count int init bool false operations channels processes write channel statement read channel statement 
process specifies pattern reading channel 
objects match pattern delivered process 
channel multiple writers multiple readers 
processes reading particular channel satisfy properties 
set patterns specified channel disjoint 
means object appendix esp language sent channel match pattern 
second distinct pattern process possibly times 
alt statement allows process wait operations different channels 
execution alt statement actions associated single channel performed 
case multiple channels ready single channel selected 
channel selection algorithm need fair may favor performance critical channels prevent starvation 
code fragment process implements fifo queue 
macros full empty incr expected functionality 
alternative accepts new messages inserts tail queue 
second alternative sends message head queue removes queue 
note alternative disabled buffer full second disabled buffer empty 
channel chan int channel chan int process buffer size 
tl hd true alt case full chan tl incr tl case empty chan hd incr hd namespaces separate namespaces esp types channels processes variables 
appendix esp language scope rules types channels processes defined top level scope 
variables defined nested scopes 
variable redefined nested scope scope 
identifiers accessed deeper nested scope 
esp support global variables variables defined top level 
esp programs lexically scoped 
new nested scopes introduced compound statements 
body loop 
branch statement 
case alt statement introduces pair nested scopes 
nested scope includes 
second nested scope nested inside introduced body 
example scope 
channel bool process true code illustrates nested scopes introduced statement 
channel bool channel int process true true defining alt case case redefining nested scope 
appendix esp language accessible 
redefining nested scope 
error 
accessible 
memory management object allocation objects allocated syntax described section 
objects channels receiving process receives deep copy object sent channel 
deep copy performed preserve pointer sharing sent object 
objects received channel similar newly allocated object freed receiving process 
casting objects deep copy object objects channels returned cast operation 
freeing objects set objects accessible process disjoint 
process responsible freeing objects free operations 
object freed exactly 
free operation frees just object specified 
operation recursively frees object specified 
noted check see object freed 
array allocated entries point single record free record multiple times 
error cause program crash runtime 
anonymous allocation anonymous allocation programmer ac quired pointer 
place occur object allocated statement sent channel 
process responsible freeing anonymous allocation 
appendix esp language interface functions implementing operation channels passed esp objects 
similarly functions operation channel need allocate return new object 
continue access objects function returned function invoke library function provided esp library 
prevent esp runtime freeing objects code 
addition unlink library functions allow code relinquish linked objects allocate new objects respectively 
functions allowed mutate esp objects 
external interface interface id id pattern external channels provide synchronous interface external code written spin 
external channel esp processes reading writing code writes reads values channel 
external channel specifies exactly interface 
example type record dest int vaddr int size int type record vaddr int paddr int type union send update channel interface writer send send dest vaddr size update update new defines channel external writer 
appendix esp language interface specify interface code 
includes list id pattern pairs 
prefix pattern indicates parameter passed function 
patterns fully general patterns section permitted patterns 
external channel esp requires types functions provided 
type suffix returns channel data send receive 
second type function called indicated ready communicate 
previous example functions provided programmer int void void int dest int vaddr int size void int new return send 
send returns integer specifies patterns ready 
depending return value functions invoked 
channels differ channel ways 
function just returns channel willing accept data 
writer channel write 
addition need pass pointers parameters modified 
parameters fewer level indirection 
interface spin 
spin code interacts esp code directly reading writing channel 
appendix vmmc firmware esp chapter provides overview implementation vmmc firmware esp implementation vmmc firmware required lines esp code lines code 
esp code uses processes channels 
presents schematic representation code 
table table provide brief description processes channels respectively 
details functionality implemented firmware discussed 
example illustrates interactions various processes channels 
consider request application machine remote fetch data machine cause data machine read transferred back machine involve steps 
machine process receives application request gen remote fetch request packet sent machine packet sent channel 
details necessary process reply packet sent channel 
appendix vmmc firmware esp timer utlb process channel vmmc firmware esp channels readers writers external channels interface process external channels omitted simplicity 
process description handles requests application send receive data 
handles requests arriving network send receive data 
handles replies arriving network response request sent 
utlb translates virtual addresses physical addresses 
translates virtual addresses physical addresses exported regions 
component retransmission protocol accepts packets sent network 
component retransmission protocol accepts packets arriving network 
timer generates timeouts retransmission protocol 
table description processes appendix vmmc firmware esp channel description requests application send receive data 
requests utlb 
replies utlb 
request dma read write data 
data read dma request 
relevant state pertaining request sent requires reply 
packet sent network reliably 
packet received network reliably 
send receive timeouts 
details packet received acknowledged 
packet sent network 
packet received network 
request lookup export table 
result export table lookup 
periodically generates clock tick timer 
returns node identifier network card 
request update import table 
requests 
replies 
table description channels appendix vmmc firmware esp 
reads details request waits reply 

reads packet sends network writing channel 
waits 
processes implement simple sliding window pro tocol piggyback 

timeout occurs sends timeout message 

timeout message arrives channel received resends packet 

machine process receives packet checks see valid sequence number sends 
packet includes piggyback send 

process reads remote fetch request channel 
looks export table andc validate request determine physical address requested data 
uses channels access dma engine transfer data host memory network card 
composes reply packet includes data sends 

reads packet sends network 

machine receives reply packet checks see valid sequence number sends 

process receives reply packet channel 
uses channels communicate process utlb translate virtual addresses appendix vmmc firmware esp physical addresses 
uses channels access dma engine write data received applications memory 
notifies application remote fetch operation successfully completed 
bibliography abbott peterson 
increasing network throughput integrating protocol layers 
ieee acm transactions networking oct 
acharya amd joel saltz 
active disks programming model algorithms evaluation 
proceedings international conference architectural support programming languages operating systems san jose california october 

raid controller 
alpert felten li 
design implementation nx message passing shrimp virtual memory mapped communication 
proceedings international parallel processing symposium honolulu hawaii april 
andrews 
concurrent programming 
benjamin cummings publishing 
andrews olsson 
sr programming language concurrency practice 
benjamin cummings 
andrews schneider 
concepts notations concurrent programming 
acm computing surveys 
arnold gosling holmes 
java programming language third edition 
addison wesley publications 
ball larus 
efficient path profiling 
ieee micro paris france december 
ball majumdar millstein rajamani 
automatic predicate abstraction programs 
proceedings conference programming languages design implementation snowbird utah june 
ball rajamani 
bebop symbolic model checker boolean programs 
proceedings international spin workshop stanford university august 
bibliography basu von eicken morrisett 
promela language correct efficient protocol construction 
proceedings ieee infocom san francisco california march 
berry 
constructive semantics pure esterel 
draft 
berry gonthier 
esterel synchronous programming language design semantics implementation 
science computer programming 
hl bal 
user level network interface protocols 
ieee computer 

improving performance shared virtual memory system area networks thesis 
technical report tr princeton university department computer science department 
felten 
fast rpc shrimp virtual memory mapped network interface 
journal parallel distributed computing 
special issue workstation cluster network computing 
liao singh 
network interface support avoid asynchronous protocol processing shared virtual memory systems 
proceedings international symposium computer architecture atlanta georgia may 
singh 
effects communication parameters performance shared virtual memory clusters 
proceedings supercomputing conference san jose california november 
li alpert felten sandberg 
virtual memory mapped network interface shrimp multicomputer 
proceedings international symposium computer architecture chicago illinois april 
boden cohen seitz 
su 
myrinet gigabit second local area network 
ieee micro 
braun diot 
protocol implementation integrated layer processing 
proceedings sigcomm conference applications technologies architectures protocols computer communication cambridge massachusetts september 
cardelli 
amber 
combinators functional programming languages lecture notes computer science 
bibliography cardelli pike 
squeak language communicating mice 
computer graphics july 
malley 
generating efficient protocol code specification 
proceedings sigcomm conference applications technologies architectures protocols computer communication stanford california august 

modeling verification multiprocessor realtime os kernel 
proceedings conference formal description techniques forte berne switzerland october 
chandra mccann 
packet types specifications network protocol messages 
proceedings sigcomm conference applications technologies architectures protocols computer communication stockholm sweden august 
chandra richards larus 
teapot language support writing memory coherence protocols 
proceedings conference programming languages design implementation philadelphia pennsylvania may 
chen li 
utlb mechanism address translation network interfaces 
proceedings international conference architectural support programming languages operating systems san jose california october 
chen kumar yu li 
porting user level communication architecture nt experiences performance 
proceedings usenix windows nt symposium seattle washington july 
lavagno hsieh suzuki sangiovanni vincentelli 
synthesis software programs embedded control applications 
proceedings conference design automation san francisco california june 
chou chelf engler heinrich 
meta level compilation check flash protocol code 
proceedings international conference architectural support programming languages operating systems cambridge massachusetts november 
clark tennenhouse 
architectural considerations new generation protocols 
proceedings sigcomm conference applications technologies architectures protocols computer communication pennsylvania september 
bibliography constable allen bromley cleaveland cremer harper howe knoblock mendler panangaden sasaki smith 
implementing mathematics nuprl development system 
prentice hall 
corbett dwyer hatcliff pasareanu shawn hongjun 
bandera extracting finite state models java source code 
proceedings international conference software engineering limerick ireland june 
cyclone microsystems 
intelligent controllers 

efficient connection oriented communication high performance networks thesis 
technical report tr princeton university department computer science department apr 
deline fahndrich 
enforcing high level protocols low level software 
proceedings conference programming languages design implementation snowbird utah june 
dijkstra 
guarded commands formal derivation programs 
communications acm 
dill drexler hu yang 
protocol verification hardware design aid 
ieee international conference computer design vlsi computers processors washington 
chen li 
vmmc efficient support reliable connection oriented communication 
proceedings hot interconnects symposium stanford california august 
li philbin 
design implementation virtual memory mapped communication myrinet 
proceedings international parallel processing symposium geneva switzerland april 
duval 
modeling verification rubis kernel spin 
proceedings international spin workshop montreal quebec october 
echelon 
neuron guide 
edwards 
compiling esterel sequential code 
proceedings conference design automation los angeles california june 
engler chelf chou hallem 
checking system rules system specific programmer written compiler extensions 
proceedings symposium operating systems design implementation san diego california october 
bibliography garland lynch 
ioa language specifying programming validating distributed systems 
laboratory computer science mit 
godefroid 
model checking programming languages verisoft 
proceedings symposium principles programming languages paris france january 
hastings joyce 
purify fast detection memory leaks access errors 
proceedings usenix winter technical conference san francisco california january 
havelund 
model checking java programs java pathfinder 
international journal software tools technology transfer 
hayden 
ensemble system 
technical report tr computer science department cornell university 
hoare 
communicating sequential processes 
communications acm aug 
hoare 
communicating sequential processes 
prentice hall 
holzmann peled 
improvement formal verification 
proceedings conference formal description techniques forte berne switzerland october 
holzmann 
spin model checker 
ieee transaction software engineering may 
holzmann 
promela online 
cm bell labs com cm cs spin man intro html 
holzmann smith 
practical method verifying event driven software 
proceedings international conference software engineering los angeles california may 
intel 
ixp network processor data sheet 
jiang kelly yu kumar singh 
application scaling shared virtual memory clusters smps 
proceedings international conference supercomputer rhodes greece june 
bibliography jiang shan singh 
application restructuring performance portability shared virtual memory hardware coherent multiprocessors 
proceedings symposium principles practice parallel programming las vegas nevada june 
kernighan ritchie 
programming language second edition 
prentice hall 
kieburtz silberschatz 
comments communicating sequential processes 
acm transactions programming languages systems 
kumar li 
performance impact esp implement vmmc firmware 
proceedings workshop novel uses system area networks san cambridge massachusetts february 
kumar yu li 
esp language programmable devices 
proceedings conference programming languages design implementation snowbird utah june 
larus 
program paths 
proceedings conference programming languages design implementation atlanta georgia may 
li chen chen clark cook finkelstein funkhouser klein liu praun singh tzanetakis zheng 
early experiences challenges building scalable display wall system 
ieee computer graphics applications 
lie chou engler dill 
simple method extracting models protocol code 
proceedings international symposium computer architecture goteborg sweden june 
liu kreitz van renesse hickey hayden birman constable 
building reliable high performance communication systems components 
proceedings symposium operating systems principles kiawah island resort south carolina december 
martin vahdat culler anderson 
effects communication latency overhead bandwidth cluster architecture 
proceedings international symposium computer architecture denver colorado june 
mcmillan 
symbolic model checking approach state explosion problem thesis 
technical report cmu cs school computer science carnegie mellon university 
bibliography consel marlet muller 
devil idl hardware programming 
proceedings symposium operating systems design implementation san diego california october 
milner 
calculus communicating systems 
lecture notes computer science 
milner parrow walker 
calculus mobile processes parts ii 
information computation 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
mosberger peterson 
making paths explicit scout operating system 
proceedings symposium operating systems design implementation seattle washington october 
mosberger peterson bridges malley 
analysis techniques improve protocol processing latency 
proceedings sigcomm conference applications technologies architectures protocols computer communication stanford california august 
nortel networks 
alteon network adapter 
malley 
usc universal stub compiler 
proceedings sigcomm conference applications technologies architectures protocols computer communication london august 
chien 
high performance messaging workstations illinois fast messages fm myrinet 
proceedings supercomputing conference san diego california december 
peterson davie 
computer networks systems approach 
morgan kaufmann publishers 
pike 
language communicating mice 
technical report tr bell laboratories computing science dept 
pike 
implementation 
software practice experience 
pike thompson holzmann 
process sleep wakeup shared memory multiprocessors 
proceedings conference norway may 
bibliography proebsting 
filter fusion 
proceedings symposium principles programming languages st petersburg beach florida january 
pu black consel cowan inouye walpole zhang 
optimistic incremental specialization streamlining commercial operating system 
proceedings symposium operating systems principles copper mountain resort colorado december 
ethernet controllers 
reppy 
concurrent programming ml 
cambridge university press 
reppy 
higher order concurrency 
technical report tr computer science department cornell university 
roscoe 
theory practice concurrency 
prentice hall 
savage burrows nelson sobalvarro anderson 
eraser dynamic data race detector multithreaded programs 
acm transactions computer systems 
sgs thomson microelectronics bristol 
occam manual 
tip 
survey program slicing techniques 
journal programming languages 
tofte 
talpin 
implementation typed call value lambda calculus stack regions 
proceedings symposium principles programming languages portland oregon january 
turner lepreau back 
formal methods practical tool os implementors 
proceedings workshop hot topics operating systems cape cod massachusetts may 
von eicken basu vogels 
net user level network interface parallel distributed computing 
proceedings symposium operating systems principles copper mountain resort colorado december 
von eicken culler goldstein schauser 
active messages mechanism integrated communication computation 
proceedings international symposium computer architecture gold coast australia may 
bibliography von eicken vogels 
evolution virtual interface architecture 
ieee computer 
wagner foster brewer aiken 
step automated detection buffer overrun vulnerabilities proceedings network distributed system security symposium san diego california february 
walton hutton touch 
high speed data paths host routers 
ieee computer 
wang anderson patterson 
virtual log file systems programmable disk 
proceedings symposium operating systems design implementation new orleans louisiana february 
weiser 
program slicing 
ieee transaction software engineering 
wilson 
uniprocessor garbage collection techniques 
proceedings international workshop memory management st malo france september 
woo singh gupta 
splash programs characterization methodological considerations 
proceedings international symposium computer architecture santa margherita ligure italy june 
zorn 
debugging tools dynamic storage allocation memory management 
www cs colorado edu homes zorn public html html 
