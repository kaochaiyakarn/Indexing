reflection analysis java benjamin livshits john whaley monica lam computer science department stanford university stanford ca usa livshits lam cs stanford edu 
reflection thorn side java static analysis tools 
full treatment reflection static analysis tools incomplete parts program may included application call graph unsound static analysis take account reflective features java allow writes object fields method invocations 
accurately analyzing reflection difficult leading static analysis tools treating reflection unsound manner just ignoring entirely 
unsatisfactory modern java applications significant reflection 
propose static analysis algorithm uses pointsto information approximate targets reflective calls part call graph construction 
reflective calls may rely input application addition performing reflection resolution algorithm discovers places program user provided specifications necessary fully resolve reflective targets 
alternative specifications propose reflection resolution approach type cast information reduces need user input typically results precise call graph 
implemented reflection resolution algorithms described applied set large widely benchmark applications consisting lines code combined 
experiments show technique effective resolving reflective calls user input 
certain reflective calls resolved compile time precisely 
relying user provided specification obtain conservative call graph results graphs contain times methods original 
case conservative call graph methods call graph interpret reflective calls 
contrast ignoring reflection leads missing substantial portions application call graph 
program static analysis requires knowing targets function method calls 
task computing program call graph complicated language java virtual method invocations reflection 
past research addressed analysis function pointers virtual method calls java 
reflection neglected 
supported nsf intel graduate fellowship 
benjamin livshits john whaley monica lam fig 
architecture static analysis framework 
reflection java allows developer perform runtime actions descriptions objects involved create objects class names call methods name access object fields name 
names methods invoked supplied user especially presence dynamic class loading precise static construction call graph generally undecidable 
assume classes may available analysis placing restrictions targets reflective calls sound conservative call graph prohibitively large 
projects static analysis optimization error detection purposes ignore reflection static analysis tools incomplete parts program may included call graph potentially unsound operations invoking method setting object field ignored 
research motivated practical need improve coverage static error detection tools 
success tools java predicated having call graph available error detection tool 
reflective calls interpreted tools run danger analyzing small portion available code giving developer false sense security bugs reported 
static results reduce runtime instrumentation parts application runtime statically analyzed 
diwan hind proposes dynamic instrumentation collect reflection targets discovered run time 
information extend andersen context insensitive inclusion pointer analysis java online algorithm :10.1.1.109.6502
reflective calls generally offer choice application control flow dynamic application run typically includes possibilities 
analyses static error detection optimization require full call graph program order achieve complete coverage 
static analysis algorithm uses points information determine targets reflective calls 
targets reflective calls determined precisely analyzing flow strings represent class names program 
allows precisely resolve reflective calls add call graph 
cases reflective call targets may depend user input require user provided specifications call graph determined 
algorithm determines specification points places program user provided specification needed determine reflective targets 
user option provide specification call graph complete respect specifications provided 
providing reflection specifications time consuming errorprone provide conservative albeit imprecise approximation targets reflective calls analyzing type casts reflection analysis java program 
common coding idiom consists casting result call class newinstance create new objects specific type returned object 
relying cast information allows produce conservative call graph approximation requiring user provided reflection specifications cases 
flow diagram summarizing stages analysis shown 
reflection resolution approach hinges assumptions reflection class files may accessed runtime available analysis behavior class forname consistent api definition returns class name specified parameter cast operations operate results class newinstance calls correct 
rare cases cast information available aid reflection resolution report back user situation requiring specification 
contributions contributions formulate set natural assumptions hold java applications reflection amenable static analysis 
propose call graph construction algorithm uses points information strings reflective calls statically find potential call targets 
reflective calls fully resolved compile time algorithms determines set specification points places program require user provided specification resolve reflective calls 
alternative having provide reflection specification propose algorithm uses information type casts program statically approximate potential targets reflective calls 
provide extensive experimental evaluation analysis approach points results applying suite large open source java applications consisting lines code combined 
evaluate points cast analyses reflective calls compare local intra method approach 
analyses find constant target class forname call sites moderately increase call graph size 
conservative call graph obtained help user provided specification results call graph times big original 
assess amount effort required come specification cast information significantly reduce specification burden placed user 
organization rest organized follows 
section provide background information reflection java 
section lay simplifying assumptions static analysis 
sections describe analysis approach 
section provides comprehensive experimental evaluation 
sections describe related conclude 
benjamin livshits john whaley monica lam overview reflection java section informally introduce reflection apis java 
typical reflection far creating new objects object class name 
common usage idiom creating object shown 
reflective apis java object creation method invocation field access described 
space limitations section briefly outline relevant reflective apis 
interested readers encouraged refer technical report complete treatment case study reflection uses benchmarks applications 
object creation object creation apis java provide way programmatically create objects class name provided runtime parameters object constructor passed necessary 
obtaining class name typically done call static functions class forname string 
passing class name parameter 
point class forname common way obtain class name may method doing 
application may define native method implements functionality 
observation applies standard reflective api methods 
commonly java idiom class class translated compiler call class forname getname 
reflection resolution algorithm works byte code level class constructs require special treatment 
creating object empty constructor achieved call newinstance appropriate java lang class object provides runtime representation class 
method invocation methods obtained class object supplying method signature iterating array methods returned class functions 
methods subsequently invoked calling method invoke 
accessing fields fields java runtime objects read written runtime 
calls field get field set get set fields containing objects 
additional methods provided fields primitive types 
assumptions reflection section presents assumptions static analysis resolving reflection java programs 
believe assumptions quite reasonable hold real life java applications 
problem precisely determining classes application may access undecidable 
furthermore applications access network 
string classname 
class class forname classname 
object newinstance 
fig 
typical reflection create new objects 
reflection analysis java set classes may accessed unbounded possibly hope analyze classes application may conceivably download net load runtime 
programs dynamically generate classes subsequently loaded 
analysis assumes closed world defined 
assumption 
closed world 
assume classes reachable class path analysis time application runtime 
presence user defined class loaders impossible statically determine behavior function class forname 
custom class loaders behavior class forname change possible malicious class loader return completely unrelated classes response class forname call 
assumption allows interpret calls class forname 
assumption 
behaved class loaders 
name class returned call class forname classname equals classname 
check validity assumption instrumented large applications observe behavior class forname encountered violation assumption 
introduce assumption allows leverage type cast information contained program constrain targets reflective calls 
assumption 
correct casts 
type cast operations operate result call newinstance correct succeed throwing 
believe valid practical assumption possible casts fail causing exception caught instantiated object afterward seen cases practice 
typical catch blocks casts lead program terminating error message 
analysis reflection section techniques resolving reflective calls program 
analysis consists steps 
sound points analysis determine possible sources strings class names 
sources constant strings derived external sources 
pointer analysis approach fully resolves targets reflective call constant strings account possible sources 
say call partially resolved sources constants inputs unresolved sources inputs 
knowing external sources may class names useful users potentially specify possible values typical examples return results file read operations 
refer program points input strings defined specification points 
benjamin livshits john whaley monica lam 
unfortunately number specification points program large 
asking users specify values possible input string second technique takes advantage casts available determine conservative approximation targets reflective calls fully resolved 
example shown call class newinstance returns object followed cast appropriate type newly created object 
assuming exception raised conclude new object subtype type cast restricting set objects may instantiated 

rely user provided specification remaining set calls calls source strings constants order obtain conservative approximation call graph 
start describing call graph discovery algorithm section reflection resolution fits call graph discovery 
section presents reflection resolution algorithm pointer analysis results 
section describes algorithm leverages type cast information conservative call graph construction relying user provided specifications 
call graph discovery static techniques discover reflective targets integrated contextinsensitive points analysis discovers call graph fly :10.1.1.4.5048
points analysis finds variables type information resolve targets virtual method invocations increasing size call graph turn find 
analysis reflective calls expands call graph analysis generate points relations leading bigger call graphs 
discovery algorithm terminates fixpoint reached call targets points relations 
points analysis discover call graph obtain accurate call graph precise technique class hierarchy analysis cha rapid type analysis rta 
context insensitive version analysis context sensitivity substantially improve accuracy call graph :10.1.1.4.5048
pointer analysis reflection section describes leverage pointer analysis results resolve calls class forname track class objects 
discover types objects created calls class newinstance resolving reflective method invocations field access operations 
pointer analysis find specification points external sources propagate string values argument class forname 
reflection points information programming idiom motivated points analysis resolving reflection 
idiom consists steps reflection analysis java 
obtain name class object needs created 

create class object calling static method class forname 

create new object call class newinstance 

cast result call class newinstance necessary type order newly created object 
interpreting idiom statically resolve call class newinstance step call default constructor 
analyzing relatively simple idiom nontrivial 
steps shown widely separated code reside different methods classes jar libraries 
class object obtained step may passed levels function calls step 
furthermore class object deposited collection retrieved step 
true name class created step step 
determine variables classname defined steps may related need know runtime objects may referring problem addressed points analysis 
point analysis computes objects program variable may refer 
resolution class newinstance class forname calls thing possible points results points analysis track method field constructor objects 
allows correctly resolve reflective method invocations field accesses 
reflection commonly invoke class constructor class calling class forname class name argument 
points information determine potential targets class forname calls add calls class constructors appropriate classes call graph 
bddbddb program database remainder section describe pointer information reflection resolution 
start describing input program represented set relations bddbddb bdd program database :10.1.1.4.5048
program database associated constraint resolution tool allows program analyses expressed succinct natural fashion set rules datalog logic programming language 
points information compactly represented bddbddb binary decision diagrams bdds accessed manipulated efficiently datalog queries 
program representation pointer analysis results stored relations bddbddb database 
domains database include invocation sites variables methods heap objects named allocation site types integers source program represented number input relations 
instance relations actual ret represent parameter passing method returns respectively 
say predicate 
xn true tuple 
xn relation show definitions datalog relations represent input program actual actual means variable zth argument method call ret ret means variable return result method call benjamin livshits john whaley monica lam assign assign means implicit explicit assignment statement program 
load load means load statement program 
store store means store statement program 
string class string class means string constant string representation name type calls invocation relation 
calls means invocation site may invoke method points results represented relation vp vp variable points relation 
vp means variable may point heap object datalog query consists set rules written prolog style notation predicate defined conjunction predicates 
example datalog rule 
says true true reflection resolution algorithm algorithm computing targets reflective calls naturally expressed terms datalog queries 
define datalog rules resolve targets class newinstance class forname calls 
handling constructors methods fields proceed similarly 
compute reflective targets calls class newinstance define datalog relations 
relation contains pairs invocations sites calling class forname types may returned call 
define datalog rule calls class forname actual vp string class 
datalog rule reads follows 
invocation site returns object type call graph relation calls contains edge class forname parameter points string represents name type relation contains pairs invocation sites calling class newinstance classes may invoked call 
datalog rule compute calls class newinstance actual vp vp vc ret ic vc ic 
rule reads follows 
invocation site returns new object type call graph relation calls contains edge class newinstance parameter aliased variable vc return value invocation site ic ic returns type targets class forname calls resolved calls appropriate class constructors added invocation relation calls calls 

reflection analysis java java java net inet java java net inet lookup java sun nio cs iso lookup java sun nio cs ms java java io inputstream 
fig 
fragment specification file accepted system 
string identifying call site class forname mapped class name call may resolve 
sign indicates string concatenation 
similarly having computed relation add reflective call targets invoking appropriate type constructor call graph relation calls rule calls 
init 
handling constructor objects technique reflective object creation class get constructor object calling newinstance 
define relation contains pairs invocations sites calling class types type constructor calls class actual vp 
computed compute follows calls class newinstance actual vp vp vc ret ic vc ic 
rule says invocation site calling class newinstance returns object type parameter aliased return value invocation ic calls class call ic type similar manner add support class support reflective field method accesses 
specification straightforward describe 
actual implementation completely models methods java reflection api 
refer reader technical report details 
specification points user provided specifications pointsto analysis allows determine non constant string passed call class forname provenance string 
provenance string essence backward data slice showing flow data string 
provenance allows compute specification points places program external sources read program configuration file system properties specification point user provide values may passed application 
benjamin livshits john whaley monica lam compute provenance propagating assignment relation assign aliased loads stores string operations 
specification points close external sources possible perform simple analysis strings backward propagation string concatenation operations 
brevity list stringbuffer append method java compiler expand string concatenation operations string operations similar manner 
rules relation detail provenance propagation calls class forname actual 
assign 
load vp vp store 
ret calls stringbuffer append actual 
ret calls stringbuffer append actual 
actual calls stringbuffer append actual 
compute specification points necessary resolve class forname calls find endpoints propagation chains string constants represent class names 
terminate return result call system case reading system property case reading file 
specifying possible values point appropriate application analyzed user construct complete call graph 
implementation accepts specification files contain simple textual map specification point constant strings generate 
specification point represented method name bytecode offset relevant line number 
example specification file shown 
reflection resolution casts applications task providing reflection specifications may heavy burden 
fortunately leverage type cast information program automatically determine conservative approximation possible reflective targets 
consider instance typical code snippet 
object newinstance 
string string cast statement post dominates call class newinstance statement 
implies execution paths pass call class newinstance go cast statement 
statement produce runtime exception subclass string 
subtypes string created result call newinstance 
reflection analysis java generally result newinstance call cast type say subtypes instantiated call newinstance 
relying cast operations possibly unsound cast may fail case code throw 
order cast technique relies assumption correctness cast operations 
preparing subtype information rely closed world assumption described section find set classes possibly application 
classes available analysis time generally distributed application 
occasionally classes generated application compiled deployed typically help ant script 
generate set possible classes deploying application 
pre process resulting classes compute subtyping relation subtype determines subtype 
preprocessing smallest applications involved looking thousands classes consider default java runtime system access 
run preprocessing step line store results easy access 
cast information integrate information cast operations directly system constraints expressed datalog 
datalog relation subtype described relation cast holds cast operations relation unresolved holds unresolved calls class forname 
datalog rule uses cast operations applied return result call class newinstance constrain possible types tc class objects returned calls sites ic class forname ic calls class newinstance actual vp ret cast tc subtype tc unresolved ic vp vc ret ic vc 
information propagates forward backward example casting result call class newinstance constrains class object called 
class object part program type constraint derived cast obeyed 
problems casts casts inadequate resolving calls class newinstance reasons 
cast approach inherently imprecise programs cast result class newinstance wide type java io serializable 
produces lot potential subclasses relevant practice 
second experiments show calls class newinstance casts illustrated example 
example 
shown benchmark applications places object returned class newinstance vector line 
despite fact objects subsequently cast type line intraprocedural post dominance powerful take cast account 
cast information significantly reduces need user provided specification practice 
version analysis cast benjamin livshits john whaley monica lam 
new 
int size 
class class forname string get 
true classloader 
add newinstance 

return new 
size fig 
case analysis unable determine type objects instantiated line casts 
information fully sound user specification chose provide specification cast version 
experimental results section comprehensive experimental evaluation static analysis approaches section 
section describe experimental setup 
section presents overview experimental results 
section presents baseline local reflection analysis 
sections discuss effectiveness points cast reflection resolution approaches respectively 
section describes specifications needed obtain sound call graph approximation 
section compares sizes call graph different analysis versions section 
experimental setup performed experiments suite large widely open source java benchmark applications 
applications selected popular java projects available sourceforge 
believe real life applications representative programmers reflection synthetically created test suites spec jvm benchmarks avoid reflection altogether 
line file available benchmark description count count classes genetic algorithms package speech synthesis system graphical cvs client jedit graphical text editor graphical email client chart drawing library total fig 
summary information benchmarks 
applications sorted number lines code column 
reflection analysis java local points casts sound benchmark fr ur fr pr ur fr pr ur fr ur jedit fig 
results resolving class forname calls different analysis versions 
summary information applications provided 
notice traditional lines code size metric somewhat misleading case applications rely large libraries 
benchmarks depend massive libraries application code may small full size application executed runtime quite large 
column table lists number classes available time application deployed including jdk 
ran experiments opteron machine equipped gb memory running linux 
jdk version 
running times preliminary implementation tens minutes little high acceptable programs size 
creating subtype information cast analysis took minute 
evaluation approach implemented different variations algorithms local points casts sound applied benchmarks described 
base version performs reflection resolution local performs simple local analysis described section 
points casts described sections respectively 
sound version augmented user provided specification answer conservative 
point sound version provides results fully sound essentially assumes reflective calls targets 
local handles reflective calls fully resolved single method 
points casts provide targets reflective calls string cast information constraining possible targets available assumes rest calls targets 
summarizes results resolving class forname analysis versions 
class forname calls represent far common kind reflective operations focus experimental evaluation 
reiterate definitions section distinguish fully resolved calls class forname potential targets class name constants partially resolved calls class name string constant propagating unresolved calls class name string constants propagating non constant external sources requiring specification 
columns subdivide total number calls fully resolved calls fr partially resolved pr unresolved ur calls 
case benjamin livshits john whaley monica lam 
private static object newinstance string classname 
classloader classloader throws 
try 
class 
classloader null 
class forname classname 


return newinstance 
catch 


fig 
reflection resolution points results xml transform jdk 
local analysis partially resolved calls calls fully resolved constant strings unresolved 
similarly case sound analysis calls fully resolved unresolved explained section 
local analysis reflection resolution local provide baseline comparison implemented local intra method analysis identifies string constants passed class forname 
analysis catches reflective calls resolved completely single method 
technique interprocedural points results identification specification points 
furthermore method invocations field accesses names method field typically locally defined constants perform resolution method calls field accesses local 
significant percentage class forname calls fully resolved local analysis demonstrated numbers column 
partly due fact fact quite common call class forname constant string parameter side effects call doing invokes class constructor 
common idiom contributing number calls resolved local analysis class converted call class forname statically resolved 
points information reflection resolution points points information find targets reflective calls class forname class newinstance method invoke seen benchmarks points information results resolved class forname calls fewer unresolved ones compared local 
specification points quite frequently sort specification required reflective calls fully resolved 
points information allows provide user list specification points inputs needs specified conservative answer obtained 
specification points encountered experiments calls system retrieve system reflection analysis java variable calls read line file quite common 
provide typical example providing specification 
example 
example describes resolving reflective targets call class newinstance xml transform jdk order illustrate power limitation points information 
class method class newinstance shown 
call class newinstance occurs line 
exact class instantiated runtime depends classname parameter passed function 
function invoked variety places classname parameter read initialization properties files console case class newinstance called function find located file classname parameter string constant 
example power points information apparent class newinstance target corresponding string constant difficult find just looking code 
relevant string constant passed levels method calls located different file took minutes exploration powerful code browsing tool find case source 
resolving class newinstance call requires user provide input specification points constant class name analysis identifies specification points correspond file reads access system properties read hash table 
cases majority calls class forname fully resolved 
small number unresolved calls potentially responsible large number specification points user provide 
points average number specification points invocation site ranges 
jedit average number specification points 
specification points computed pointer analysis approach thought hints user provide specification 
cases user provide specification program input points knows input strings may 
reflective call may difficult tell constant class names flow may illustrated example 
generally user choice 
problematic reflective calls jedit produce high number specification points better strategy user may provide reflective specifications class forname calls laboriously going specification points 
casts reflection resolution casts type casts provide static approximation objects created reflective creation site 
pretty significant increase number class forname calls reported cases including newly discovered class forname calls appear due bigger call graph reflective calls resolved 
cases majority class forname calls targets partially resolved 
fact calls resolved case jedit 
experience java reflection apis suggest class newinstance calls post dominated cast operation located benjamin livshits john whaley monica lam lines code class newinstance call 
experiments identified number class newinstance call sites dominated cast sort return result class newinstance constrained way 
turns unconstrained class newinstance call sites located jdk sun sources apache libraries application code 
high number unresolved calls jdk due fact reflection libraries tends highly generic common class newinstance wrappers methods accept class name string return object class cast appropriate type caller method 
rely intraprocedural post dominance resolving calls scope 
wrapper methods typically called multiple invocation sites different sites resolve different types precise approximation object type returned class newinstance possible cases 
precision cast information reflective object creation sites located jdk applications analyzed 
example method lookup package sun nio cs creates subclass charset different character sets defined system 
case answer precise conceivably depending application execution environment 
cases cast approach able uniquely pinpoint target class newinstance calls cast information 
example subclass class sun awt shell available order cast succeed instantiated 
general cast approach provides imprecise upper bound call graph needs analyzed 
results class newinstance occasionally cast wide types java lang potential subclasses instantiated class newinstance call site 
cast approach yield precise results applications java generics applications tend narrow types performing type casts 
achieving sound call graph approximation sound providing specification unresolved reflective calls allows achieve sound approximation call graph 
order estimate amount effort required come specification unresolved reflective calls decided start points add reflection specification result sound 
providing specification allows discover call graph rounds specification required practice new portions program available 
practice start specification examine unresolved calls specification points corresponding 
come specification feed back call graph construction algorithm process converges 
coming specification difficult error prone task requires looking large amount source code 
took fifteen hours incrementally devise appropriate specification ensure completeness reflection analysis java starting strings starting casts benchmark specs sites app types site specs sites app types site jedit fig 
user provided specification statistics 
rerunning call graph construction algorithm 
providing reflection specification points estimate specification avoided rely type casts 
specification statistics part summarizes effort needed provide specifications call graph sound 
second column shows number specifications form reflective call site type exemplified 
columns show number reflection calls sites covered specification breaking sites located library vs application code 
seen table number invocation sites specifications necessary part application 
case calls requiring specification part library code 
specification points located jdk library code specification shared different applications 
unique invocation sites requiring specification benchmarks 
column shows average number types specified reflective call site 
number quite high due fact reflective calls jdk refer multitude implementation classes 
second part estimates specification effort required start cast call graph construction approach 
seen columns number class forname calls constrained cast operation quite small 
fact unique invocation sites third invocation sites required points 
suggests effort required provide specification casts sound considerably smaller original effort starts points 
specification difficulties cases determining meaningful values specify class forname results quite difficult shown example 
example 
benchmark applications jedit contains embedded bean shell java source interpreter write editor macros 
calls class forname jedit takes parameters extracted bean shell macros 
order come conservative superset classes may invoked bean shell interpreter installation jedit parse scripts supplied jedit determine imported java classes access 
note specification sound default configuration jedit new classes may need added specification new macros available 
took little hour benjamin livshits john whaley monica lam classes benchmark local points casts sound jedit methods benchmark local points casts sound jedit fig 
number classes methods call graph different analysis versions 
develop appropriate perl scripts parsing macros supplied jedit 
class forname call instantiate total different types 
emphasize conservativeness call graph depends conservativeness user provided specification 
specification missed potential relations omitted call graph 
furthermore specification typically conservative configuration application initialization files different different program installation user provided specification may longer conservative 
remaining unresolved calls somewhat surprisingly class forname calls fully resolved user provided specification seen column 
fact specification flaw valid specification possible cases explained 
example 
audio api jdk includes method sound sampled called java version 
class forname call method resolves constant com sun media sound class absent post 
method represents dead code answer sound 
similarly unresolved calls class forname located code executed particular application configuration analyzing refer classes specific macos unavailable linux platform performed analysis 
cases classes unavailable jdk version version ran analysis 
effect reflection resolution call graph size compares number classes methods different analysis versions 
local analysis significant effect number methods classes call graph calls reflection analysis java class forname resolved local analysis 
due fact vast majority calls due class idiom typically refer classes call graph 
trivial calls easy resolve analysis hard calls lot potential targets leads substantial increase call graph size 
points increases number classes methods call graph moderately 
biggest increase number methods occurs jedit methods 
casts leads significantly bigger call graphs especially increase number methods compared fold 
noticeable increase call graph size observed version sound 
compared average increase number classes times original average increase number methods times original 
biggest increase number methods occurs extra methods added graph 
demonstrate lines code metric indicative size final call graph programs listed increasing order line counts jedit clearly biggest benchmarks consider method count 
attributed large libraries ship application binary form considering larger portion jdk version sound compared version 
related general treatments reflection java forman forman gu 
rest related falls broad categories projects explicitly deal reflection java languages approaches call graph construction java static dynamic analysis algorithms address issue dynamic class loading 
reflection metadata research metadata reflection community long line research originating languages scheme 
mention relevant projects 
closest static analysis project aware noy applying partial evaluation reflection resolution purpose optimization 
describes extensions standard partial evaluator offer reflection support 
idea compile away reflective calls java programs turning regular operations objects methods constraints concrete types object involved 
type constraints performing specialization provided hand 
static analysis thought tool inferring constraints experimental results show cases targets reflective calls uniquely determined benefits specialization optimize program execution may limited 
noy description specialization approach may examples extracted jdk lacks comprehensive experimental evaluation 
related languages benjamin livshits john whaley monica lam java ruf explores partial evaluation optimization technique context clos 
specifying reflective targets explicitly addressed jax 
jax concerned reducing size java applications order reduce download time reads class files constitute java application performs program analysis determine components application retained order preserve program behavior 
clearly information true call graph necessary ensure relevant parts application pruned away 
jax approach reflection employ user provided specifications reflective calls 
assist user writing complete specification files jax relies dynamic instrumentation discover missing targets reflective calls 
analysis points information thought tool determining insert reflection specifications 
call graph construction lot effort spent analyzing function pointers virtual method calls java 
briefly mention highlights call graph construction algorithms java 
grove parameterized algorithmic framework call graph construction :10.1.1.18.621
empirically assess multitude call graph construction algorithms applying suite medium sized programs written cecil java 
experience java programs suggests effect context sensitivity task call graph construction java yields moderate improvements 
tip palsberg propose propagation algorithm call graph construction investigate design space existing algorithms call graph construction cfa rta including ra cha new ones 
sundaresan go traditional rta cha approaches java type propagation purpose obtaining precise call graph 
approach variable type analysis able uniquely determine targets potentially polymorphic call sites cases 
agrawal propose demand driven algorithm call graph construction 
motivated need just time dynamic compilation program analysis part software development environments 
demonstrate demand driven technique accuracy corresponding exhaustive technique 
reduction graph construction time depends ratio cardinality set influencing nodes set nodes 
dynamic analysis approaches motivated large extend need error detection tool static approximation true conservative call graph application 
largely precludes dynamic analysis benefits optimizations method inlining connectivity garbage collection 
diwan hind addresses issues dynamic class loading native methods reflection order deal full complexity java implementation common pointer analysis 
reflection analysis java approach involves converting pointer analysis online algorithm add constraints analysis nodes discovered runtime :10.1.1.109.6502
newly generated constraints cause re computation results propagated analysis clients method inliner garbage collector runtime 
approach leverages class hierarchy analysis cha update call graph 
technique uses precise pointer analysis approach call graph construction 
presents static analysis call graph construction java addresses reflective calls 
algorithm uses results points analysis determine potential reflective call targets 
calls fully resolved user provided specification requested 
alternative providing specification type cast information provide conservative approximation reflective call targets 
applied static analysis techniques task constructing call graphs large java applications consisting lines code 
evaluation showed reflective class forname partially resolved statically determined targets help points results cast information providing specification 
reflective calls relatively easy resolve statically precisely interpreting reflective calls requires user provided specification 
pointer analysis approach identified specification points places program corresponding file system property read operations user input needed order obtain full call graph 
evaluation showed construction specification call graph conservative time consuming error prone task 
fortunately cast approach drastically reduce specification burden placed user providing conservative albeit potentially imprecise approximation reflective targets 
experiments confirmed ignoring reflection results missing significant portions call graph effective static analysis tools afford 
local points analysis techniques resulted moderate increase call graph size cast approach resulted call graphs times methods original call graph 
furthermore providing specification resulted larger conservative call graphs times bigger original 
instance benchmark additional methods discovered conservative call graph version original 

forman forman java reflection action 
manning publications 
access rights analysis java 
proceedings acm conference object oriented programming systems languages applications 
benjamin livshits john whaley monica lam 
reimer schonberg srinivas srinivasan alpern johnson smart analysis error reduction 
proceedings international symposium software testing analysis 

weimer necula finding preventing run time error handling mistakes 
proceedings acm conference object oriented programming systems languages applications 

diwan hind pointer analysis presence dynamic class loading 
proceedings european conference object oriented programming systems languages applications 

andersen program analysis specialization programming language 
phd thesis university copenhagen 
tip palsberg scalable propagation call graph construction algorithms 
acm sigplan notices 
livshits whaley lam reflection analysis java suif stanford edu livshits papers tr reflection tr pdf 
technical report stanford university 
whaley lam cloning context sensitive pointer alias analysis binary decision diagrams 
proceedings acm conference programming language design implementation 

dean grove chambers optimization object oriented programs static class hierarchy analysis 
lecture notes computer science 
bacon fast effective optimization statically typed object oriented languages 
phd thesis university california berkeley 
grove chambers framework call graph construction algorithms 
acm trans 
program 
lang 
syst 

lam whaley livshits martin context sensitive program analysis database queries 
proceedings acm symposium principles database systems 

aho sethi ullman compilers principles techniques tools 
addison wesley 
gu cointe java reflection exercises correction faqs 
www yann net teaching documents practical re doc pdf 
thiemann partial evaluation full scheme 
reflection 

noy partially evaluating reflection java 
proceedings acm workshop partial evaluation semantics program manipulation 

ruf partial evaluation reflective system implementations 
workshop reflection metalevel architecture 

tip sweeney streeter practical experience application extractor java 
acm sigplan notices 
grove defouw dean chambers call graph construction objectoriented languages 
proceedings acm conference object oriented programming systems languages applications 

sundaresan hendren vall rai lam gagnon godin practical virtual method call resolution java 
acm sigplan notices 
agrawal li su evaluating demand driven technique call graph construction 
computational complexity 

