building intermediate language sensor networks ryan newton arvind computer science artificial intelligence laboratory massachusetts institute technology cambridge ma emails newton arvind mit edu widespread agreement higher level programming model sensor networks needed 
variety models developed community far consensus 
propose intermediate language speed exploration design space 
language called token machine language tml targeted compilers higher level systems 
tml provides layer abstraction lower level runtime environment tinyos 
tml intended capture coordinated activity sensor network 
notable features tml atomic action model concurrency unification communication control storage concept token 
tokens small objects typically bytes disseminated network 
token causes computation arrival site invoking token handler 
effect computation atomically change token state state shared variables site 
breakthrough programming technology ad hoc sensor networks may help achieve widespread acceptance commercial scientific spheres 
number ongoing projects developing better programming tools sensor networks 
include virtual machines high level programming abstractions query engines 
approach call allow application designers write code high level language captures operation sensor network 
global program compiled form executes individual nodes 
order develop high level languages compile programs extremely valuable define common intermediate language 
forced build monolithic implementations language nesc 
need intermediate representation away details concurrency communication capturing detail permit extensive optimizations compiler 
propose intermediate language sensor networks called token machine language tml 
tml simple machine model call distributed token machines 
distributed token machines provide execution communication model tokens 
communication happens token messages typed messages containing small payload 
tokens associated token handlers executed reception token message locally radio message 
tokens akin active messages provide additional facilities structuring execution concurrency state management communication model attractive compilation target sensor network applications 
matt welsh electrical engineering computer science harvard university cambridge ma email eecs harvard edu goal define intermediate language sensor network programming provides simple versatile abstractions communication data dissemination remote execution 
constitutes framework network coordination implement sophisticated algorithms leader election group maintenance network aggregation 
explicit goal turns tml usable humans code generators evident example programs section tml meant lightweight respect 
map efficiently event driven semantics existing sensor network operating systems tinyos 
tml versatile construct wide range higher level systems simultaneously masking complexities underlying os runtime environment 
goals differentiate tml traditional intermediate languages java virtual machine cli designed portability safety 
draw lineage systems threaded machine tam aims provide appropriate level granularity achieve abstraction sacrificing performance versatility 
tml provides unified abstraction communication execution network state management tokens 
specifically communication tml accomplished dissemination tokens 
receiving token node atomically executes associated token handler uses modifies stored form token schedules new tokens kills existing tokens 
approach allows application refer tokens set nodes holding particular token semantically meaningful units 
example tokens straightforward implement network abstractions gradients involve flooding token part network constructing spanning tree pointing back origin gradient 
gradients common routing model sensor networks implemented tml manner meshes token abstraction 
section iii semantics distributed token machine model 
dtm machine complete executable language 
section iv concrete language tml realization dtm model 
section demonstrate tml writing simple applications including distributed event detector decentralized leader election algorithm 
discuss prototype implementation tml top tinyos showing tml abstraction introduces little overhead terms code sizes modest overhead terms ram usage execution speed 
ii 
related variety attempts raise bar sensor network programming including middleware services communication abstractions programming models 
mat system similar tml 
provides platform higher level languages virtual machine compiled intermediate language 
project focuses application specific vm extensions safety guarantees energy efficient dynamic reprogramming 
overhead bytecode interpretation intensive computation prohibitive 
tml approach efficient compiled code cost larger binaries 
safety guaranteed compiler run time system intermediate language tml type safe example 
mat hosts high level programming systems application specific vm extensions 
example query processing system built specialized mat vm 
specialized vm incorporates regions communication model welsh 
mat differs tml provides lowlevel radio communication directly mat uses applicationspecific opcodes essentially foreign function interface tinyos components expose new communication primitives regions 
contrast tml provides coordinated communication execution architecture tokens build new communication abstractions 
impala middleware system enables application modularity network reprogramming aims provide automated assignment java components parts ad hoc network scaled resource constrained sensor networks 
middleware systems share goals tml focus providing rich array run time services 
tml hand requires little way run time support core implementation lines nesc code 
tml focused defining appropriate semantics useful compilation 
number projects proposed novel communication abstractions sensor networks 
example spatial programming uses smart messages provide content spatial embedded resources 
system programmer may refer available camera predefined spatial region 
alternatively blum describes entity abstraction exposes tracked targets class language objects serve communication endpoints 
related communication abstractions include regions difs dimensions 
communication models particular influence tml 
general purpose gradient aggregation interface tml section similar directed diffusion spin paradigms source sink communications named data 
amorphous computing explores depth applications gradients 
tml heavily inspired active messages am originally conceived mechanism efficient message passing parallel architectures 
original am focused integrating communication execution constructing parallel applications 
am new home tinyos primarily radio message format introducing specific semantics execution message handlers 
example tinyos variant am specify messages interact link network layers protocol stack 
additionally high level languages proposed programming sensor network applications including tinyscript variants sql cougar tinydb 
goal tml define appropriate intermediate language systems compile 
common abstraction sharing functionality difficult complexity 
example tinydb system monolithic includes wide range functionality spanning tree formation query dissemination query optimization network aggregation 
prior defines alternative language functional reactive programming 
represents sensor nodes streams data grouped regions purpose network aggregation detecting events 
high level nature semantic gap node level language nesc large making task compilation daunting 
course implementing compiler created tml intermediate language 
return discussion compilation tml section iii 
distributed token machines distributed token machine dtm model computation dynamic asynchronous ad hoc network stopping failures message losses 
dtm model structures concurrency communication storage architecture pictured 
assumptions scheduling algorithm base language describe actions performed token handler 
token machine language introduced section realization dtm model concrete handler language similar basic subset execution model dtm execution model node network holds number tokens single fixed size shared memory 
token associated token handler executed receipt token message 
token handler takes arguments receives payload message carrying token 
token private memory fixed size piece state may accessed associated token handler 
stored token private memory referred token object 
oop terms token object thought object private fields method 
handler executes atomically bounded amount time simplifies memory consistency issues precise scheduling possible 
model restrictive simplicity boon compilers analysis tools working architecture 
dtm model selling point combination expressiveness simplicity 
core ingredients necessary build higher level programming features 
example straightforward map multiple token methods supported handler action 
similarly issues memory scope protection compiler controlled 
importantly compiler break long sequence coordinated actions set token handlers interact predictable ways inside nodes network 
depicts structure sensor node executing dtm model 
node network consists heap storing local token objects token store scheduler processes incoming token fig 

structure node dtm model 
token messages transmitted network channels 
received morph persistent form token objects 
messages collection handler actions computable node 
just dtm model fix base language handlers scheduling algorithm remains implementation specific 
token messages form tokens take traveling network channels 
token name paired associated payload 
active messages token name start message 
dtm model allow token names encoded data transfered messages stored memories 
message comes scheduler token name directs corresponding handler 
corresponding token object token store memory allocated initialized zero handler begins running 
handler consumes message payload executes atomically possibly reading modifying token object private memory node shared memory process 
handlers communication interface executing token handlers post new messages 
interact scheduler 
wish specify exactly language describing handlers care example concrete syntax data types wish specify interface handler interact rest system 
token handlers operations access modify token store scheduling queue 
schedule ti priority data 
timed schedule ti time data 
schedule operation inserts token message nodes local scheduling queue 
data 
payload token message 
schedule non blocking returns immediately 
timed schedule version schedule causes message execute local node precise time number milliseconds 
time requirement overrides strategy scheduler uses order messages 
general scheduler may implementation specific algorithm scheduling incoming messages 
acceptable values priority argument implementation specific relevant insofar affect particular scheduler 
scheduler permission drop remotely received messages legal dtm model defined terms lossy channels 
scheduler expected follow certain rules 
respect relative order token messages produced execution single atomic token handler 
consecutive schedule commands handler order preserved 
bcast ti data 
bcast version schedule handing token message local scheduler broadcasts radio neighbors node running executing handler 
message may subsequently received neighbor neighbors dtm model assume acks communication protocol 
message loss dealt executing token machine 
core provide simple single hop broadcast 
complex communication primitives built see section 
scheduled ti ti scheduled allow query removal token messages waiting scheduler 
scheduled reports presence absence token number timing token messages affiliated token 
similarly removes messages token name 
ti evict ti dtm specify handlers interact private memories expected appropriate load store operations specify interface nodes token store 
queries local node token store presence token name 
evict removes token 
token name ti evicted corresponding token object frees private memory record token presence kept 
token handler evicts executing eviction occurs handler completion 
iv 
token machine language section describe realization dtm model token machine language tml 
dtm model provides execution model tml fills set basic operators concrete syntax describing handlers 
language tml bodies handlers subset extended dtm interface described schedule evict 
subset disallows data pointers allows fixed length loops uses scheduling tokens procedure call mechanism 
conditionals permitted execution time handler undecidable bounded 
named fields int int replace undifferentiated blocks bits described dtm model handler arguments token message payload token object memories shared memory 
data token object private memory statically allocated declarations form stored int initialized zero 
data shared tokens declared shared int 
tml allows trailing arguments handlers omitted understanding take zero value 
scheduling broadcasts token message efficient 
sample nonsense code showing token declaration looks 
shared int token red int int stored int green timed schedule red current prototype tml implementation targets nesc tinyos environment 
dtm interface bcast schedule tinyos module dtm bcast dtm schedule 
handlers compiled individual nesc commands 
tml compiler provides certain guarantees generated nesc code conform dtm execution semantics handlers terminate programs crash motes invalid memory impossible due lack pointers tml 
user bypassing tml compiler manually writing code dtm library 
responsible respecting constraints dtm model breaking controlled ways 
token namespace tml token store place dynamic memory allocation system call stack 
order programs best token store need way create arbitrary number token names just occur program text 
allow unique 
program consists token declarations tokens red green blue user may red green 
red handler token object store keep private memories 
handlers need way refer number currently executing 
reason allow syntax similar component parameterization nesc 
declaring token handler write token blue id 
variable id refers numeric index currently invoked 
calling scheduling token index index 
constructing multiple instances token class 
indices form pointer tml uses consistent virtual address space nodes network 
allocate variable amounts storage see section keep gradients overlapping 
returning subroutines example systematically building abstractions top tml add subroutine calls return values 
normal procedural programming 
dtm equivalent schedule operations carry return value 
exclude dtm model keep atomic actions small fast 
model dynamically allocated structure token store call stack constitute 
user token handler able invoke handler get back return value 
enable feature building returning handler calls top core tml continuation passing style cps transformation 
answer issue split phase vs blocking operations 
circumvent issue having implicitly split phase calls 
user simply uses cps transformation splits handler point producing pre post handler 
programmer understand facility may break atomicity handler really syntactic sugar multiple handlers 
require freezing live variables point storing continuation token object restoring context post handler continuation token handler poses efficiency concerns 
example consider simple code snippet 
token int red int stored int schedule blue green bcast red return token handler red transformed stops green see resulting tml code 
stopping point red allocates continuation object token store 
continuation unique name associated new compiler generated token declaration containing code truncated red handler 
continuation invoked cps transformation requires handler called take extra argument naming continuation invoke return value 
green called passed sub token name continuation equivalent pointer continuation 
generated code unpleasant invoke continuation handler different modes allocate continuation object token store second invoke continuation 
invoke call takes advantage fact token message payload really just fixed size buffer omits unused trailing arguments zero 
code acceptable automatically generated intended human consumption 
token int red id int stored int schedule blue schedule alloc schedule green id token id int mode int freevars stored int mode alloc freevars captured freevars captured mode invoke freevars bcast yellow token green int schedule invoke performing cps transformation tml straightforward tml simplicity clear semantics 
doing general nesc code quite difficult 
nesc multiple execution contexts tasks events 
second convenient mechanism dynamically allocating invoking continuation objects 
cps studied literature 
number optimizations efficient especially case tml perform program analysis 
techniques minimize number continuations created circumstances allocate memory 
case tml optimize abstraction layer breaking core dtm semantics way 
permit implementation choose direct calls nesc call non recursive subroutines going scheduler 
similar procedure inlining 
case execution time token handler bounded statically known quantity compute upper bound time cost non recursive subroutine call 
choose inline constraints scheduling algorithm 
example may simply set maximum desirable atomic action duration inline maximum action duration 
invoking split phase tinyos operations operations tinyos split phase 
expose split phase operations tml blocking operations cps transformation described 
example consider reading data sensor tinyos 
interface consists getdata command event 
tml expose simple sense operation treat 
handler split code sense getdata portion code portion 
unfortunately event invoked continuations may occur time 
scheduler depends complete control timing handlers 
scheduler promise meet deadlines tokens scheduled timed schedule processor busy unanticipated action 
problem involves pushing continuation code tinyos event handler proper token handler 
tinyos event handler schedules continuation token highest priority 
small predictable amount time lost tinyos event handler 
tml operating system runs top tinyos suffer time leaks event firings tinyos subsystem 
reality current implementation performs approximate timing 
hand tuned estimate running time token handlers tml code generous time 
underestimate running time atomic action possibility timed schedule land slightly 
believe approximate timing sensor networks applications 
may attempt improve timing enabling abortion atomic actions run time 
example applications tml section explain example usages tml 
adding gradient interface tml simple program transformation just implementation keyword 
built small gradient language top core tml provides collection gradient network coordination operations mesh naturally high level language gradients tml dtm tinyos extensions fig 

ingredients tml system 
token machines implementation process bidirectional 
build tml enriching features gradients compiling higher level language 
dtm underlying model implemented tml tinyos provides run time environment 
token oriented semantics tml 
sort lightweight language building intended represent typical usage tml 
building gradient layer demonstrate ease writing simple applications 
discuss briefly tml target language compiler 
gradients gradients general purpose mechanism breadth exploration source node 
simplest form gradient establishes spanning tree tells nodes gradient route source hop count 
see directed diffusion example utility gradients overview design tradeoffs gradient implementation 
facility adding gradients involves simple program transformation adds code implicitly appends extra arguments token handlers 
extra arguments carry gradient information hop count version number 
interface consisting operations 
ti data 
version bcast begins gradient propogation current node 
gradient equality determined token name 
node joins gradient fire ti token handler 
achieve overlapping noninterfering gradients token handler 
ti data 
version bcast continues propogation gradient current node 
fails silently named gradient received 
data 
allows data propagated gradients roots optional aggregation way 
call sends data gradient fires call token handler data reaches source 
aggr argument null indicating aggregation name token handler arguments aggregate return values way source 
dist ti version ti expose parent pointers gradient interface applications depend details gradient implementation single vs multiple parents 
user code dist aware distance source particular gradient 
gradient re emitted source node case user code able differentiate different generations gradient 
allow user query version gradient received 
useful performing initialization time gradient received 
dist version return named gradient received local node 
interface commit particular spanning tree selection maintenance algorithm 
developer want choose gradient implementation appropriate application 
ideally gradient augmented tml compiler expose set choices gradient implementation covers design space outlined current prototype compiler provides simple single parent link quality unaware gradients 
timed data gathering rudimentary example shows gradient interface sample node light sensor uses couple simple keywords mentioned 
startup declaration indicates gather tokens scheduled node turned 
base startup keyword similar applies base station node network 
predefined token handler supported base station return results outside world 
startup gather base startup token timed schedule token token gather null sense light timed schedule gather program emits gradient base station relays reaches edge network refreshes seconds 
second node fires gather token uses globally gradient route data back base station 
distributed event detection consider problem local event detection unreliable sensors 
trust reading single sensor sensors area detect event alarm raised 
solve problem spreading small hop gradient node detects event 
gradients overlap sufficiently alarm raised 
program assumes declarations establishing 
shared int total activation token emit myid schedule myid token sub int dist self relay total activation total activation threshold null alarm timed call sub token sub int total activation total activation evict sub evict sub keep individual gradients colliding indexed id node emitting gradient 
overlap seen shared variable total activation 
demonstrates utility lightweight gradients spawned destroyed arbitrary points network 
leader election build reusable leader election component tml 
nodes invoke ti participate leader election token ti 
node eventually decided leader receive ti token 
multiple leader elections proceed concurrently network ti uses indexed ti computation 
problem garbage collecting dead tokens ignored purpose example 
shared int winner token elect leader int current winner current current myid winner myid timed schedule confirm fire emit compete myid token compete int id winner winner myid timed schedule confirm fire version compete id winner winner id relay compete id token confirm fire sub myid winner schedule compiling final application example discuss compiler targets tml 
language high level program manipulates regions sensor data values language 
individual nodes network appear data streams regions groupings streams designated programmer number different criteria 
program operates streams regions performing fig 

simple component structure tinyos tml implementation 
actions translated node level actions local data 
resulting node behavior complex difficult reason directly 
tml helps bridge semantic gap virtue token holders forming natural groups 
expression program evaluates region value gets assigned formation token membership token 
node holds membership token particular time member region time 
formation tokens hand initiate constructing discovering region 
formation tokens constraints need fire 
clear high level semantics reason events need take place 
done tml straight forward translate region logic token logic 
vi 
structure tml run time examine component structure token machine run time 
complete tml program compiles produce single module conforming interface 
component provides single method process token takes token runs appropriate handler 
token handler single command generated code 
process token message just looks type token dispatches appropriately 
rest system uses handles transporting tokens needs process tokens 
simple component assembly shown 
described section gradient communication extensions built top core tml 
gradients integral part tml choose implement gradient api directly tinyos 
see commands emit relay home listed interface 
methods appear exactly discussion tml api 
current tml implementation cuts corner 
token handler having arbitrarily structured private memory current implementation token handler stores exactly cached copy corresponding token message arguments 
get cached set cached access token handler stored memory 
example user code needs information parent pointers hop counts version numbers acquires get cached method extracting information cached token 
stored fields shared memory hand allocated inside component need appear interface components 
component provide interface current tml implementation called 
component contains scheduler implements communication interface 
scheduler maintains queue incoming tokens ordered way respects timed tokens 
message reception events trigger event handlers unpack token message currently token message place queue 
separate task consumes messages queue invokes process token sets timers schedule consumptions 
contains logic necessary implement gradients 
leaks 
emission simply broadcast plus book keeping counters versions 
returning values gradients requires route messages spanning trees 
intercepting message receives calling process token return message reached root spanning tree 
vii 
evaluation discussion tml currently implemented high level simulator compiler targeting nesc tinyos environment 
mapping token machines nesc discussed section iv 
took relatively little effort map tml tinyos tml mechanism discipline 
current compiler shortcomings respect features laid 
current implementation implements direct described iv circumvents necessity cps transformation 
result manually insure handlers complete relatively short time 
part implementation corrected near 
code size compiled tml code 
small constant factor size increase added tml source translated nesc 
run time support dtm component relatively lean 
compiled mica mote consumes bytes rom 
ram usage worse bytes including token store bytes 
ram cpu usage suffer compared equivalent native tinyos code 
overhead running scheduler component unnecessary copying buffers 
believe optimizations exploited reduce memory redundancy 
move direction 
learned far tml important qualities atomic action model concurrency fact communication bound persistent storage tokens 
precludes deadlocks reasoning timing extremely simple 
essentially gives way refer communications happened token leave 
tokens give benefits viral agent type models ad hoc distributed computing seen overhead 
seen lightweight version agentoriented model 
explore dynamic alternatives tml including dynamic network 
tml programs modular conducive division code capsules similar employed mat 
ultimately concur position espoused separate representations enduser programming model code transport layer execution engine 
ideally user program compiled concise bytecode supported pre installed virtual machine 
look targetting virtual machine native code mat 
intend keep focus program compilation 
numerous optimizations described currently development depend program optimization 
determine call sites token handler great benefit 
example unused arguments token handlers eliminated including automatically generated ones continuation gradient arguments 
lack pointers tml results lot unnecessary copying eliminated compiler access program 
working incorporating token routing scheme allowing operations route green token holders red token 
eventually look incorporating larger array established distributed algorithms tml 
example incorporate quorums consensus algorithms token oriented manner 
harold abelson don allen daniel chris hanson george jr thomas knight erik rauch gerald jay sussman ron weiss 
amorphous computing 
commun 
acm 
barr du kim zhou sirer 
need system level support ad hoc sensor networks 
blum wood abdelzaher son stankovic 
entity maintenance connection service sensor networks 
cristian chalermek intanagonwiwat kang ulrich kremer iftode 
spatial programming smart messages design implementation 
th international conference distributed computing systems icdcs march 

programming computer 
phd thesis mit 
david culler anurag sah klaus schauser thorsten von eicken john wawrzynek 
fine grain parallelism minimal hardware support compiler controlled threaded machine 
proceedings fourth international conference architectural support programming languages operating systems pages 
acm press 
cormac flanagan amr sabry bruce duba matthias felleisen 
essence compiling continuations 
sigplan 
deepak ganesan ben greenstein denis deborah estrin john heidemann 
evaluation multi resolution search storage resource constrained sensor networks 
proc 
acm conference embedded networked sensor systems sensys november 
ben greenstein eddie kohler deborah estrin 
sensor network application construction kit 
proceedings nd international conference embedded networked sensor systems pages 
acm press 
benjamin greenstein deborah estrin ramesh govindan sylvia ratnasamy scott shenker 
difs distributed index features sensor networks 
proc 
ieee international workshop sensor network protocols applications may 
john hatcliff olivier danvy 
generic account continuationpassing styles 
proceedings st acm sigplan sigact symposium principles programming languages pages 
acm press 
heinzelman joanna kulik hari balakrishnan 
adaptive protocols information dissemination wireless sensor networks 
proc 
th acm ieee mobicom conference august 
jason hill robert szewczyk alec woo seth hollar david culler pister 
system architecture directions networked sensors 
proceedings ninth international conference architectural support programming languages operating systems pages 
acm press 
chalermek intanagonwiwat ramesh govindan deborah estrin 
directed diffusion scalable robust communication paradigm sensor networks 
proc 
international conference mobile computing networking august 
philip levis david culler 
mate tiny virtual machine sensor networks 
proceedings th international conference architectural support programming languages operating systems pages 
acm press 
samuel madden michael franklin joseph hellerstein wei hong 
tag tiny aggregation service ad hoc sensor networks 
proc 
th osdi december 
ryan newton matt welsh 
region streams functional sensor networks 
proceedings international workshop data management sensor networks august 
amr sabry matthias felleisen 
reasoning programs continuation passing style 
proceedings acm conf 
lisp functional programming san francisco ca usa june pages 
acm press new york 
thorsten von eicken david culler seth copen goldstein klaus erik schauser 
active messages mechanism integrating communication computation 
years international symposia computer architecture selected papers pages 
acm press 
matt welsh geoff 
programming sensor networks regions 
proc 
usenix acm symposium networked systems design implementation nsdi march 
kamin cory sharp eric brewer david culler 
hood neighborhood abstraction sensor networks 
proc 
international conference mobile systems applications services mobisys june 
bridging gap programming sensor networks application specific virtual machines 
submission osdi 
yong yao gehrke 
cougar approach network query processing sensor networks 
acm sigmod record september 
