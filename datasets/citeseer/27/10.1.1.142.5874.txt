reducing braking distance sql query engine michael carey ibm almaden research center san jose ca carey almaden ibm com donald kossmann university passau passau germany kossmann db fmi uni passau de proposed adding clause sql permit cardinality query result explicitly limited query writers query tools 
demonstrated usefulness having clause showed extend traditional cost query optimizer accommodate demonstrated db simulations large performance gains possible queries explicitly supported database engine 
new strategies efficiently processing queries 
strategies largely range partitioning techniques offer significant additional savings handling queries yield sizeable result sets 
describe classes queries savings arise experimental measurements show benefits tradeoffs associated new processing strategies 
decision support applications uncommon wish pose query examine process number result tuples 
database systems applications cursor submitting entire query fetching results 
obviously inefficient leading significant amount wasted query processing 
ck proposed adding clause sql enable query writers limit size query result set specified number tuples related sql extensions proposed ks cg 
clause essentially provides declarative way user say context sql query enabling system avoid computing unwanted results cases 
previous showed usefulness new permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings th vldb conference new york usa clause discussed cost query optimizer extended exploit db simulations demonstrate large performance gains possible query support explicitly added database engine 
build previous presenting new strategies efficiently processing queries 
discussed query processing general ck major focus initial attention optimizing queries relatively small top queries 
example typical query previously proposed processing schemes handle select name salary emp age order salary desc query asks names salaries highly paid older employees 
previous schemes primary key foreign key join queries select name salary name emp dept age works dno order salary desc query asks employees department names names salaries 
queries possible query processor manage sorted cardinality reduced intermediate results main memory heap structure avoiding large volumes wasted sorting compared processing query clause discarding unwanted employee information 
cases stopping cardinality large original approaches sorting discarding significant amount data albeit early join example leads significant savings compared naive approach 
strategies seek avoid wasted effort 
new strategies borrowing ideas existing query processing techniques range partitioning commonly parallel sorting parallel join computations rid list processing commonly text processing set query processing semi joins commonly distributed environments reduce join processing costs 
show adapting techniques query processing provide significant additional savings certain important classes queries 
implemented techniques context experimental query processing system university passau demonstrate efficacy techniques presenting measurements query plans running 
proceeding worth noting proprietary sql extensions closely related proposed clause current products number major database system vendors 
addition include degree optimizer support getting query results back quickly heuristically favoring pipelined query plans cheaper blocking non pipelined plans 
example informix includes rows optimizer hint clause truncating sql query result set 
similarly microsoft sql server provides option fast clause session level set statement purposes 
ibm db udb system allows users include optimize rows fetch rows clauses entering sql query 
oracle rdb originally dec product added limit rows clause sql oracle server virtual attribute part query results support cardinality limits including predicate clause sql query tells oracle server returning result rows rows produced 
supports set command sql extension called rank col imposes result order allows processing stopped early adding clause rank col query tells return result rows rank column values respect indicated column 
event tie permits multiple result rows rank value 
systems apparently pass stopping information operations sort optimize desired number results merging sorted runs 
unfortunately best knowledge published information available describes systems sql extensions implemented 
remainder organized follows background material section briefly summarize query operators kinds query plans introduced previous review basic idea range partitioning query processing step provide overview experimental environment produce performance results sections 
section introduce new techniques processing queries experimental results demonstrate benefits highlight associated performance issues tradeoffs 
focus basic top selection queries section section explain range techniques utilized processing queries top percentage selections selections involving subqueries joins 
section show rid list semi join techniques applied queries 
plans section 
background general structure proposed queries subqueries ck follows select 


group 
having 
order sort specification list value expression clause value expression evaluates scalar integer value indicate number result tuples desired may constant arithmetic expression uncorrelated scalar subquery 
semantics clause straightforward explain integer stopping cardinality value expression evaluates 
computing rest query system return tuples result specified order order requesting user application program 
note produces results cursor approach application programs today presence clause provides query optimizer runtime query processing system cardinality information exploited reduce eliminate cases wasted 
query processing process queries proposed extending database system collection algebraic query operators new logical query operator operator 
operator produces top bottom tuples input stream specified order discards remainder stream 
logical query operators join alternative physical operators implement context query plans 
defined physical operators ck scan operator stream input tuples ordered appropriately sort operator input stream 
scan extremely simple pipelined operator simply requests passes tuples input stream consumer operator query plan 
contrast sort operator handles case input stream sorted consume input stream order produce top bottom output tuples 
relatively small sort operate main memory priority heap knu 
sort tbscan emp age scan sort salary tbscan emp age scan age emp salary classic sort conventional sort trad 
index scan traditional plans query tuples input inserted heap remaining tuple incrementally tested heap current membership bound determine warrants insertion heap top bottom tuples 
larger values external sorting required compute desired sort results simply ordinary external sort operator followed scan operator cases ck 
illustration purposes consider slightly general version example query call query query select emp age order salary desc depicts possible execution plans constructed query combining physical operators pre existing query operators 
plan classic sort plan uses table scan tbscan operator find employees appropriate age range followed heap sort operator limit results highest paid older employees 
plan viable long small heap main memory structure 
second plan conventional sort uses external sort salary followed scan obtain desired result 
preferred plan large absence salary index 
course plans similar emp age index scan produce inputs related operators possible 
third plan traditional index scan plan viable presence index emp salary 
plan performs index scan descending order salary index uses resulting record ids rids fetch employees applies age predicate uses scan operator select top results index scan produces output desired salary order 
third plan salary index clustered index small 
large index unclustered random os cost effective especially age predicate highly selective case high employees index subsequently eliminated 
introduced policies govern placement operators query plans ck 
conservative policy inserts operators early possible query plan subject constraint tuple participating final tuple query result discarded operation 
proposed aggressive policy seeks introduce operators query plan earlier placing operator provide beneficial cardinality reduction 
aggressive policy uses result size estimation choose stopping cardinality operator runtime stopping cardinality estimate turns low query restarted order get missing tuples 
accomplished placing restart operator query plan operator job ensure point plan tuples generated 
input stream runs tuples received restart query subplan beneath obtain missing results 
range partitioning range partitioning known technique applied success numerous problems parallel database algorithm area dg 
successful example parallel sorting dns load balanced parallel join computation example computation called band joins dns 
basic idea range partitioning extremely simple data divided separately processable buckets placing tuples attribute values range bucket tuples attribute values range bucket 
case parallel sorting node node database machine partitions data buckets parallel sorting attribute streaming bucket contents bucket designated receiver node data partitioned 
process individual buckets sorted parallel inter node interaction 
illustrates process 
successful partitioning manner produces virtually linear sorting speedup sampling histogram techniques aid determination set partition boundary values dns relatively low cost 
section propose analyze possible partitioning approaches improving efficiency query processing 
cover details basic idea simple relevant data range partitioned query order attribute number buckets 
buckets processed time results output buckets accessed process need sorted 
provides way implement operation scales main memory sizes requiring full sorting input stream 
addition see certain contexts additional significant savings possible cases involving uses clause subquery 
experimental environment way presentation proposed new approaches executing 


sort sort sort partitioning base table sorting range partitioning queries presenting results performance experiments demonstrate tradeoffs related approaches quantitatively explore extent able reduce costs queries 
query test queries queries simple employee database self explanatory schema emp eno works age salary address dept dno budget description instance employee database fairly small mb emp table mb dept table 
kept database small order achieve acceptable running times somewhat limited disk space available performing experiments 
emp table tuples generated follows eno set counting tuples works age salary set randomly uniform distribution particular domains address simply pads tuples garbage characters ensure emp tuple bytes long 
domain works course dept dno described domain age integers range emps older domain salary integers range 
test database correlations example relevant experiments young emp just high salary old emp dept table tuples generated follows dno set counting dept tuples budget set depts description pads dept tuples bytes 
terms indexes test database clustered tree indexes primary key attributes tables eno dno clustered indexes primary keys relatively common 
study plans traditional index scan plan emp salary tree naturally index unclustered 
experiments performed experimental database system called 
essentially textbook relational database system uses standard implementations sorting various kinds joins group operations 
extended implementations scan sort trees organize heap ahu restart operators described added support forms range partitioning described section 
ran sun workstation mhz sparc processor mb main memory gb disk drive store code database temporary results queries 
operating system solaris solaris direct feature disables operating system caching manner similar raw disk devices 
database small limited size database buffer pool proportionally mb cases explicitly say 
mb gave kb operator reads writes data disk order enable large block operations avoid excessive disk seeks 
range braking algorithms turn attention development new techniques processing queries effort techniques reducing stopping distance sql query engine 
primary tool range partitioning 
section algorithms tool help engine limit wasted finishing sooner queries refer range braking algorithms 
start describing query plan components realize algorithms illustrating typical example query 
study performance close section explaining choose appropriate number partitions effective set partition sizes 
range braking mentioned earlier problem extracting top bottom elements large data set large dealt range partitioning data number buckets query ranking attribute processing resulting buckets time elements output 
example consider query section selects names salaries highest paid employees years old 
suppose older employees test database 
instance partition old employees buckets salaries year earn annually earn 
suppose find highest salary partition ends tuples second tuples third tuples 
case need sort tuples partition employees answer set clearly lie partitions 
basic idea range braking simple possible variations theme costs benefits depend nature query processed data accessed 
important option partitions handled materialized stored temporary tables recomputed demand input data 
addition options combined produce hybrid approach materializes partitions accessed partitions recomputes rest demand ones accessed 
provide different options propose adding new query operators execution engine 
part mat operator takes partitioning vector parameter uses scan input data write disk specified number partitions splitting values partitioning vector 
second part scan operator scan resulting partitions 
third new operator part reread operator takes set predicates describe membership criteria partition salary salary salary materializes partition tuples reading re reading input stream 
final new query operator part hybrid operator materializes specified number highest lowest ranked partitions computes contents partitions demand 
illustrate operators works discuss performance tradeoffs example plans subsection 
range top query plans demonstrate different variations range braking turn query favorite query example 
shows possible partitioning plans processing query absence useful indexes 
discuss query processing indexes section plan labeled materialize takes approach materializing employee partitions sorting needed yield results 
execution plan demand driven best explained looking happens result tuples requested scan operator top plan 
result tuple requested scan operator attempts obtain produce result asks restart operator tuple turn asks sort operator underneath tuple 
sort operator responds consuming sorting tuples get getting input indication part scan operator beneath 
part scan operator obtains tuples scanning partition produced child part mat operator materializes full set partitions old employees partitioning result input coming employee table scan allowing part scan proceed 
part scan finishes scanning partition returns input signal sort sorts scan restart sort salary part scan part mat tbscan emp age scan restart sort salary part reread tbscan emp age scan restart sort salary part scan part hybrid tbscan emp age materialize reread hybrid range partitioning plans query partition incrementally passes results partition scan operator restart operator 
restart operator receives input sends restart signal back tuple pipeline signal received part scan operator responds moving partition 
result partitions created part mat operator sorted scan top produced results 
partitions needed achieve goal remain unsorted saving sorting cost compared conventional sort plan 
second partitioning plan shown labeled reread materialize partitions temporary files 
computes sorts partitions demand feeding sort operator partition time part reread operator 
plan controlled top scan restart operator 
case time partition computed sorted employee table scan repeated happens part reread operator responds restart signal re initializing input operator table scan example input operator tree complex query plans starts 
execution query plan similar described hopefully control data flow details clear 
advantage reread plan favorite query saves cost writing re reading materialized partitions note include partitions large third partition earlier example needed obtain tuple result set 
hand re scan employee table partition read cost associated write read savings approach involves 
final partitioning plan shown labeled hybrid attempts combine advantages plans avoiding disadvantages 
particular structured way materializes partitions recomputes remaining ones 
top select queries point collection query plans process favorite query absence indexes classic sort conventional sort approaches ck shown response time secs conv sort part mat part reread part hybrid response time secs conv sort part mat part reread part hybrid response time secs conv sort part mat part reread part hybrid number partitions cut point resp 
time secs query mb buffer perf 
part 
partition materialize reread hybrid approaches just introduced shown 
investigate quantitative tradeoffs approaches constructed query plans conducted series experiments test employee database system described section 
shows query response time results obtained experimenting stopping cardinality values ranging old employees 
conventional sort plan worst performance sorts data able identify top results 
performance figures plan include cost phase sort mb takes approximately minutes test environment 
cost increase larger values due dependence final merge phase sort page run read pages runs read merged 
classic sort plan provides better performance conventional sort plan long applicable curve stops sorted heap structure longer fits buffer pool point 
relative performance seen approaches essentially just predicted ck 
turn partition approaches 
experiment assume optimizer selectivity estimator access accurate distribution data means assume partitions ideally sized notion examine closely subsection 
result partition plans just tuples partition 
looking performance results query see materialize plan ends worst performer partitioning plans materializes mb temporary partition data subsequently needed 
despite cost outperforms conventional sort plan values performance essen tially 
partitioning approaches providing best performance query query vary part 
kb buffer perf 
cut query vary cut point kb buffer perf 
part 
sort required amount data materializes excess data case excess scans occur 
partitioning plans outperform classic sort plan small quicksort sort partition slightly costly classic sort uses heap order results 
increases differences different approaches diminishes sorting amount data reaches 
partitioning safety padding preceding experiment provides quite bit insight relative performance old new sort processing schemes basic top query assumed perfect partitioning 
accept results need explore sensitivity partitioned plans number sizes partitions 
need reasons 
need understand choose partitioning parameters type plan 
second need find costly partitioning errors know pad partition sizes safety practice values selected combination database statistics optimizer estimates imperfectly chosen 
shows results series experiments differ ways ones just looked 
fixed decreased buffer pool size factor kb pages kb 
smaller buffer pool stress need partitioning similar scaling size employee table keeps cost experiments reason 
axis number partitions utilized axis query response time 
graph number partitions varied perfect cut meaning partitions query stopping cardinality setting winner partitions tuples plus loser partition leftover tuples 
comparison baseline setting purposes addition showing performance plans graph shows timing results conventional sort plan vary fixed classic sort applicable heap fit available buffer memory 
results shown provide clear insights partition plans dealt respect choosing number partitions 
reread approach obviously expect sensitive number partitions avoid costly re reads partitions winner loser optimal choice 
materialize approach performs best winner tuples partitioned memory sized pieces partition sorted memory single pass case partitions 
hybrid approach similar optimal point reason outperforms materialize seconds worth response time materialize loser tuples 
shows results series experiments explores question happens different partitioning plans winner loser cut point axis incorrectly estimated call cut point 
goal experiment obtain insights guide sizing partitions know direction better err 
query experiments query buffer pool size pages learning results reread winner loser partition experiment materialize hybrid partition winner tuples memory sized pieces 
set low shows algorithms get fairly big trouble 
winner tuples belong query result placed large loser partition 
case reread hybrid re scan entire mb employee table get tuples materialize sort large loser partition 
circumstances conventional sort plan able beat partitioning plans 
materialize performs worst great deal expensive reading writing ends costly second sequential scan employee table 
set high shows partitioning algorithms manage quite query 
materialize roughly constant cost region materializes old employees independent 
hybrid grows slowly expensive increases materializes old tuples 
reread grows costly faster increasing cutpoint estimate 
see need look amount sorting carried plans reread winner partition tuples sort winner partition order find top tuples 
hand materialize hybrid partition winner tuples small winner partitions need sort winner partitions cases set high 
case bottom line experiment partition algorithms suffer quite strongly number tuples placed winner partitions ends small suffer tuples classified winners 
better err high side placing tuples loser partition winner partitions avoid potential performance instabilities 
choosing partitioning vector moving queries worth discussing issue partitioning vector splitting values control attribute value ranges associated partitions chosen plans 
preceding subsection showed choose partition cardinalities remaining open problem successfully mapping desired cardinalities back attribute ranges order attribute query 
essentially dual selectivity estimation problem takes query attribute value ranges attempts estimate cardinalities ranges amenable techniques 
essentially potential answers 
histograms thoroughly studied available database systems today 
particular equi depth histograms provide accuracy presence skewed data understood koo psc md case correlated attributes multi dimensional histograms help pi 
histograms available determine partition vectors query compilation time 
histograms available known available histograms provide insufficient accuracy complex queries unpredictable joins grouping operations sampling run time 
sampling thoroughly studied database context lns hs shown quite cheap dns 
conclude point rely existing technology new partition approaches propose directly take advantage improvements field 
examples far seen experimental results involving favorite query demonstrated basic tradeoffs related alternative range partitioning techniques showed advantages range partitioning queries 
section additional examples experimental results highlight advantages range partitioning 
example queries include percent query nested query join query 
tradeoffs alternative partitioning approaches similar queries focus hybrid plans preferred partitioning method section 
response time secs conv sort part hybrid response time secs conv sort part hybrid response time secs part hybrid resp 
time secs query mb buffer perfect partitioning percent queries additional example query called percent query 
query asks highest paid emps years old 
query select emp age order salary desc percent queries interesting additional counting step required order find tuples returned 
need count number emps start stopping speak 
looking back plans studied previous section see directly apply conventional sort plan percent query counting step carried part tbscan emp age operator result counting step times propagated scan operator scan operator starts produce tuples possible sort pipeline breaking operator 
likewise partitioning plans applied percent query counting carried part tbscan emp age operators propagated scan operators exists pipeline breaking operator sort part mat part hybrid 
classic sort plan directly applied case 
sort operator read emp table twice carry counting step find top read emp table carrying counting step materializing emps age temporary table read temporary table order find top 
plans better depends selectivity age predicate particular example second plan better emps older test database 
case adjusted classic sort plans expensive inapplicable classic sort plan 
resp 
time secs query mb buffer perfect partitioning query vary mb buffer shows running times conventional sort adjusted classic sort materialization step partition hybrid plans percent query 
described conventional sort hybrid plans running times query section classic sort plan higher cost due writing reading temporary results disk 
result hybrid plan clear winner percent query 
note classic sort plan applied bac memory requirements exceed mb 
find proper partitioning vector hybrid plan query observations section essentially apply 
partition data memory sized portions play safe materializing emp tuples part hybrid operator 
subquery second example section query consider query subquery 
example query asks average salary best paid emps age 
query select avg salary select salary emp age order salary desc conventional sort classic sort plan applied query simply need aggregate operator top order compute average 
traditional plans perform great deal wasted produce output salary order ordering needed compute average 
partition plan sorting avoided partitioning emps partitions partition containing top emps slightly smaller partition containing emps small gf eha partition loser emps 
case emps second partition need sorted order find highest paid emps partition 
shows running times alternative plans query 
see conventional sort plan highest cost sorts emps age independent previous experiments cost classic sort plan increases hybrid conventional sort plans 
query experiment special cost hybrid plan constant hybrid sorts emps independent large cost hybrid plan slightly increase due materializing emp tuples 
result differences cost classic sort hybrid plans increase sharply hybrid plan outperforms conventional sort plan noted cost conventional sort plan lower query previous experiments query evaluated salary column emps columns projected tbscan permitting sort carried pass memory 
similarly classic sort plan query exhausting buffer space 
somewhat trickier find perfect partitioning vector query queries 
set cut point winners losers section need sure mk addition oai small possi ii ble 
words need find left cutting point addition right cutting point needed find right cutting point queries 
shows sensitivity cost hybrid plan cases set imperfectly pi obviously hybrid plan performs best close shows penalty poor setting severe due fact additional proportional number misclassified tuples errors don cause entire additional partitions involved query plan case hybrid plan outperforms traditional plans 
shows cost classic sort plan better traditional plans baseline 
join queries example query section involves join example shows partitioning attractive complex queries 
query asks highest paid emps age dept budget 
query select emp dept age budget works dno order salary desc shows traditional plans query 
plan conventionally sorting emp table salary order probing top emps order find dept high budget uses index nested loop join 
second plan carries join order find emps dept high budget join best purpose test database finds highest paid emps sort operator 
alternative traditional plans shows partitioning plans query 
idea partition emp table join join emp partition time dept table emps survive join 
just partitioning previous examples avoid unnecessary sorting partitioning utilized join plans avoid unnecessary sorting join 
difference plans uses index nested loops join second uses hashing 
note small hash join part hj plan carried pass part hybrid operator partitions data memory sized portions 
shows running times plans varying test database depts budget 
see immediately partitioning plans clearly outperform traditional plans 
sort plan highest cost independent sorts mb emps age 
tru extremely high costs addition expensive sort costly emp tuples generate probes resulting excessive amount random disk ghj sort plan low sorting costs small poor performance performs full fledged grace hash join 
ghj sort plan inapplicable buffer requirements sort operator exceed limit mb 
replacing sort operator conventional sort scan operator yield execution time secs 
partitioning variants avoid unnecessary sorting joining emp tuples 
part plan performs best small performance deteriorates due high cost just sort plan 
part hj plan shows better performance cases hash joins better index nested loop joins input tables large 
terms sensitivity points mentioned queries basically apply sure partition contains emp tuples needed answer query 
keep mind part hj plan penalty setting cutpoint low higher partitioning plans simple sort queries restart involves re scanning emp table re scanning dept table part hj plan 
part plan scans dept table part plan pay additional penalty restarts 
response time secs sort ghj part part hj resp 
time secs query mb buffer perfect partitioning index nested loop join sort salary tbscan emp age part scan part hybrid scan sort tbscan emp age dept dno tbscan emp age sort grace hash join ghj sort traditional plans query scan sort salary restart index nested loop join part dept dno scan sort salary restart classic hash join tbscan dept tbscan dept part scan part hybrid tbscan emp age part hj range partitioning plans query techniques seen range partitioning helpful improve response time different types queries 
section show techniques applied evaluate queries 
technique partitioning ordered indexes trees partition data 
second technique semi joins reduce size temporary results 
partitioning indexes return query asks emps highest salary age see happens tree emp salary 
traditional index scan plan executes query emp salary index shown discussed section reads rids emps time salary order index fetches age address fields applies age predicate top old emps 
section noted plan emp salary index clustered small high cost large age predicate filters high paid emps case operator lead great deal random page faults pages emp table buffer small hold relevant pages emp table 
large unclustered indexes better course partitioning 
idea read rids top zy emps index sort zy rids page id order predicate re sort salary order cut top tuples repeat zy top emps age 
similar rid sorting ideas known rid list processing commonly exploited text databases bcc set query processing yao applied context combined partitioning 
beauty part index approach operator quite cheap reads emp pages sequentially reads emp page disk 
negative side approach involves sorting steps 
small sorts fairly cheap carried pass memory 
shows running times traditional index scan plan part index plan query varying baselines shows running times hybrid plan emp salary index ideal running time query generated running traditional index scan plan special version test database emp salary index clustered 
see part index plan clearly outperforms traditional index scan plan large range traditional index scan plan attractive part index plan shows ideal performance 
sorts expensive 
traditional index scan plan slightly perform part index plan secs vs sec 
right setting course depends selectivity age predicate 
example set fifth emp older test database values salary age columns correlated 
noted penalty restarts part index plan low re scanning entire emp table restart simply involves continuing emp salary index scan fetching zy emp tuples 
response time secs trad index part index part hybrid ideal resp 
time secs query mb buffer unclustered emp salary index semi join technique idea semi joins reduce cost intensive operations sorts joins group operations projecting columns needed operation doing reduces size temporary results need read written disk shipped network 
disadvantage semi joins columns projected re fetched operator operation order carry subsequent operations part query result 
semi join techniques extensively early distributed database systems bgw widely centralized database systems 
reason potentially prohibitively high unpredictable costs cost re fetches reduced rid sorting trick described previous subsection 
semi join techniques attractive queries costs limited predicted accurately query optimization re fetches carried query execution query asks top tuples re fetches required 
studied different semi join plans query 
plans sorting emp tuples carried pass main memory rids salary fields emp tuples kept 
difference plans plan call standard sj plan apply rid sorting trick described previous subsection order improve re fetches second plan sj plan apply trick 
ran plans varying shows results experiments 
shows results conventional sort hybrid plans section baselines 
see impact rid sorting trick pronounced previous experiments part index plan 
reason semi join plans emp table read old emps filtered gets hits buffer pool applied fewer tuples 
second observe small semi response time secs conv sort part hybrid standard sj sj resp 
time secs query mb buffer semi join plans join plans outperform conventional sort plan performance semi join plans deteriorates due high re fetching costs 
see semi join plans clearly outperformed partition hybrid plan semi join plans hybrid plan section carries sort salary pass hybrid plan additional advantage sorting slightly emps age 
note difficult find example queries semi join plan outperform partitioning plan large highly selective joins small best plan execute query may combination partitioning semi joins 
new strategies efficiently processing queries 
strategies largely range partitioning techniques shown provide significant savings handling important classes queries 
examples including basic top queries percent queries subqueries joins saw benefits new partitioning techniques case due reduction wasted sorting joining effort offer 
showed range partitioning useful indexed non indexed plans showed semi join techniques provide additional savings cases 
areas appear fruitful 
area interest query processing parallel database systems 
techniques immediately applicable may offer greater benefits reducing amount data communication required process queries 
avenue investigation experimentation effectiveness histogram sampling techniques determining partitioning vector entries queries real data sets 
acknowledgments paul brown informix jim gray microsoft anil oracle dec previous job donovan schneider systems informing support top query processing respective companies current database products 
ahu aho hopcroft ullman 
data structures algorithms 
addison wesley reading ma usa 
bcc brown callan croft 
fast incremental indexing full text information retrieval 
proc 
conf 
large data bases vldb pages santiago chile september 
cg ck dg bernstein goodman wong reeve 
query processing system distributed databases sdd 
acm trans 
database systems december 
chaudhuri gravano 
optimizing queries repositories 
proc 
acm sigmod conf 
management data pages montreal canada june 
carey kossmann 
saying sql 
proc 
acm sig mod conf 
management data pages tucson az usa may 
dewitt gray 
parallel database systems high performance database systems 
communications acm june 
dns dewitt naughton schneider 
evaluation non equijoin algorithms 
proc 
conf 
large data bases vldb pages barcelona spain september 
dns hs dewitt naughton schneider 
parallel sorting shared architecture probabilistic splitting 
proc 
intl 
ieee conf 
parallel distributed information systems pages miami fl usa december 
dewitt naughton schneider seshadri 
practical skew handling parallel joins 
proc 
conf 
large data bases vldb pages vancouver canada august 
haas swami 
sequential sampling procedures query size estimation 
proc 
acm sigmod conf 
management data pages june 
knu knuth 
art computer programming sorting searching volume 
addison wesley reading ma usa 
koo 
optimization queries relational databases 
phd thesis case western reserve university september 
ks kimball 
decision support fails fix 
acm sigmod record september 
lns lipton naughton schneider 
practical selectivity estimation adaptive sampling 
proc 
acm sigmod conf 
management data pages atlantic city usa april 
md pi psc dewitt 
equi depth histograms estimating selectivity factors multidimensional queries 
proc 
acm sig mod conf 
management data pages chicago il usa may 
poosala ioannidis 
selectivity estimation attribute value independence assumption 
proc 
conf 
large data bases vldb pages athens greece august 
poosala ioannidis haas shekita 
improved histograms selectivity estimation range predicates 
proc 
acm sigmod conf 
management data pages montreal canada june 
piatetsky shapiro connell 
accurate estimation number tuples satisfying condition 
proc 
acm sigmod conf 
management data pages boston usa june 
kossmann moerkotte 
implementation performance compressed databases 

submitted publication 
yao yao 
optimization query evaluation algorithms 
acm trans 
database systems 
