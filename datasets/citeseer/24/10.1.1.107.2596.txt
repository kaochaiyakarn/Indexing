improving reliability commodity operating systems michael swift brian bershad henry levy university washington despite decades research extensible operating system technology extensions device drivers remain significant cause system failures 
windows xp example drivers account reported failures 
article describes nooks reliability subsystem seeks greatly enhance operating system os reliability isolating os driver failures 
nooks approach practical guaranteeing complete fault tolerance new incompatible os driver architecture goal prevent vast majority driver caused crashes little change existing driver system code 
nooks isolates drivers lightweight protection domains inside kernel address space hardware software prevent corrupting kernel 
nooks tracks driver kernel resources facilitate automatic cleanup recovery 
prove viability approach implemented nooks linux operating system fault isolate device drivers 
results show nooks offers substantial increase reliability operating systems catching quickly recovering faults crash system 
wide range number fault conditions show nooks recovers automatically faults cause linux crash 
nooks designed drivers techniques generalize kernel extensions 
demonstrate isolating kernel mode file system kernel internet service 
nooks supports existing language extensions runs commodity operating system hardware enables automated recovery represents substantial step specialized architectures type safe languages required previous efforts directed safe extensibility 
categories subject descriptors operating systems reliability fault tolerance general terms reliability management additional key words phrases recovery device drivers virtual memory protection 
article describes architecture implementation performance nooks new operating system subsystem allows existing operating system supported part national science foundation itr ccr itr 
authors address department computer science engineering university washington box seattle wa email bershad levy cs washington edu 
permission digital hard copies part personal classroom granted fee provided copies distributed profit direct commercial advantage copies show notice page initial screen display full citation 
copyrights components owned acm honored 
abstracting credit permitted 
copy republish post servers redistribute lists component works requires prior specific permission fee 
permissions may requested publications dept acm broadway new york ny usa fax permissions acm org 
acm acm transactions computer systems vol 
february pages 
swift 
os extensions device drivers loadable file systems execute safely commodity kernels 
contemporary systems fault kernel extension corrupt vital kernel data causing system crash 
reduce threat extension failures nooks executes extension lightweight kernel protection domain privileged kernel mode environment restricted write access kernel memory 
nooks interposition services track validate modifications kernel data structures performed kernel mode extension trapping bugs occur facilitating subsequent automatic recovery 
factors motivated research 
computer system reliability remains crucial unsolved problem patterson 
cost high performance computing continues drop cost failures downtime stock exchange commerce server manpower required service help desk request office environment continues rise 
addition growing sector unmanaged systems digital appliances consumer devices commodity hardware software hewlett packard amplifies need reliability 
second os extensions increasingly prevalent commodity systems linux called modules windows called drivers custer 
extensions optional components reside kernel address space typically communicate kernel published interfaces 
addition device drivers extensions include file systems virus detectors network protocols 
extensions account linux kernel code chou different drivers versions exist windows xp desktops short 
extensions written programmers significantly experienced kernel organization programming built operating system 
third extensions leading cause operating system failure 
windows xp example drivers cause reported failures short 
linux frequency coding errors times higher device drivers rest kernel chou 
core operating system kernel reaches high levels reliability due longevity repeated testing extended operating system tested completely 
tens thousands extensions operating system vendors identify test possible combinations marketplace 
improving os reliability require systems highly tolerant failures drivers extensions 
furthermore hundreds millions existing systems executing tens thousands extensions demand reliability solution backward compatible efficient common extensions 
backward compatibility improves reliability deployed systems 
efficiency avoids classic tradeoff robustness performance 
focus extensibility reliability new 
years produced substantial amount research improving extensibility acm transactions computer systems vol 
february 
improving reliability commodity operating systems reliability new kernel architectures engler new driver architectures project udi user level extensions forin liedtke young new hardware fabry witchel type safe languages bershad 
underlying techniques nooks previous systems nooks differs earlier efforts key ways 
target existing extensions commodity operating systems propose new extension architecture 
want today extensions execute today platforms change possible 
second conventional programming language 
ask developers change languages development environments importantly perspective 
focus single serious problem reducing huge number crashes due drivers extensions 
implemented prototype nooks linux operating system experimented variety kernel extension types including device drivers file system kernel web server 
automatic fault injection show injecting synthetic bugs extensions nooks gracefully recover restart extension cases cause linux crash 
addition nooks recovered common causes kernel crashes manually inserted 
extension recovery occurs quickly compared full system reboot leaving applications running 
drivers common extension type impact performance low moderate 
kernel extensions isolated nooks required code changes lines changed eighth 
prototype linux expect architecture implementation features port readily commodity operating systems 
rest article describes design implementation performance nooks 
section describes system guiding principles high level architecture 
section discusses system implementation linux 
experiments evaluate reliability nooks section performance section 
summarize related os extensibility reliability section 
section summarizes draws 

architecture nooks architecture core principles design fault resistance fault tolerance 
system prevent recover necessarily extension failures 
design mistakes abuse 
extensions generally behaved may fail due errors design implementation 
principle seeking complete solution possible extension errors 
extensions cause vast majority system failures eliminating extension errors substantially improve system reliability 
second principle chosen occupy design acm transactions computer systems vol 
february 
swift space unprotected safe extension architecture conventional operating systems linux windows unprotected nearly bug extension corrupt crash rest system 
contrast safe systems spin bershad java virtual machine gosling strictly limit extension behavior distinction buggy malicious code 
trust kernel extensions malicious trust buggy 
practical impact principles substantial positively negatively 
positive side allows define architecture directly supports existing driver code moderate performance costs 
negative side solution detect recover possible failures easily circumvented malicious code acting kernel 
examples consider malfunctioning driver continues run corrupt kernel data returns packet byte short malicious driver explicitly corrupts system page table 
attempt detect correct failures 
failures crash system spectrum possible defensive approaches exist 
range windows approach preemptively crash avoid data corruption full virtual machine approach virtualize entire architecture provide total isolation 
approach lies middle 
possible approaches reflects tradeoffs performance compatibility complexity completeness 
section describes current limitations 
limitations architectural induced current hardware software implementation 
despite limitations tens thousands existing drivers millions failures cause fault resistant solution propose practical implications value 
goals preceding principles nooks architecture seeks achieve major goals isolation 
architecture isolate kernel extension failures 
consequently detect failures extension infect parts kernel 
recovery 
architecture support automatic recovery permit applications depend failing extension continue 
backward compatibility 
architecture apply existing systems existing extensions minimal changes 
achieving goals existing operating system challenging 
particular need backward compatibility rules certain appealing technologies type safety capability hardware 
furthermore backward compatibility implies performance system nooks significantly worse system 
acm transactions computer systems vol 
february 
improving reliability commodity operating systems fig 

nooks isolation manager transparent os layer inserted kernel kernel extensions 
functions achieve preceding goals creating new operating system reliability layer inserted extensions os kernel 
reliability layer intercepts interactions extensions kernel facilitate isolation recovery 
crucial property layer transparency meet backward compatibility goals largely invisible existing components 
shows new layer call nooks isolation manager nim 
nim operating system kernel 
nim function lines jutting kernel represent kernel dependent modifications os kernel programmer insert nooks particular os 
modifications need 
underneath nim set isolated extensions 
function lines jutting nim represent changes extension writer interface specific extension extension class nooks 
general modifications required level transparency existing extensions major objective 
nim provides major architectural functions shown isolation interposition object tracking recovery 
describe function 
isolation 
nooks isolation mechanisms prevent extension errors damaging kernel isolated extensions 
extension nooks executes lightweight kernel protection domain 
domain execution context processor privilege kernel write access limited portion kernel address space 
major task isolation mechanism protection domain management 
involves creation manipulation maintenance lightweight protection domains 
secondary task interdomain control transfer 
isolation services support control flow directions extension domains kernel domain 
system calls initiated application kernel frequently calls extensions 
calls may generate callbacks kernel may generate call extension 
complex communication style handled new kernel service called extension procedure call xpc control transfer mechanism specifically acm transactions computer systems vol 
february 
swift tailored isolating extensions kernel 
mechanism resembles lightweight remote procedure call lrpc bershad protected procedure call ppc capability systems dennis horn 
lrpc ppc handle control data transfer mutually peers 
xpc occurs trusted domains asymmetric kernel rights extension domain vice versa 
interposition 
nooks interposition mechanisms transparently integrate existing extensions nooks environment 
interposition code ensures extension kernel kernel extension control flow occurs xpc mechanism data transfer kernel extension viewed managed nooks object tracking code described 
interface extension nim kernel provided set wrapper stubs part interposition mechanism 
wrappers resemble stubs rpc system birrell nelson provide transparent control data transfer address space machine boundaries 
nooks stubs provide transparent control data transfer kernel domain extension domains 
extension viewpoint stubs appear kernel extension api 
kernel point view stubs appear extension function entry points 
object tracking 
nim object tracking functions oversee kernel resources extensions 
particular object tracking code maintains list kernel data structures manipulated extension controls modifications structures provides object information cleanup extension fails 
extension protection domain modify kernel data structures directly 
object tracking code copy kernel objects extension domain modified copy back changes applied 
possible object tracking code verifies type accessibility parameter passes extension kernel 
recovery 
nooks recovery functions detect recover variety extension faults 
nooks detects software fault extension invokes kernel service improperly invalid arguments extension consumes resources 
case recovery policy determines nooks triggers recovery returns error code extension handle failure kernel function 
triggering recovery prevents corruption may degrade performance recovering frequently 
nooks detects hardware fault processor raises exception extension execution example extension attempts read unmapped memory write memory outside protection domain 
unmodified extensions course position handle hardware faults cases nooks triggers higher level recovery 
faulty behavior may detected outside nooks user program 
user program trigger nooks recovery explicitly 
acm transactions computer systems vol 
february 
improving reliability commodity operating systems extensions executing nooks domain access domain local memory directly 
extension access kernel resources managed tracked wrappers 
nooks successfully release extension held kernel structures memory objects locks recovery process 

implementation implemented nooks inside linux kernel intel architecture 
chose linux platform popularity wide support kernel extensions form loadable modules 
developed nooks linux expect architecture design ported operating systems windows xp solaris 
linux kernel provides functions callable extensions extension entry functions callable kernel 
data types abstracted extensions directly access fields kernel data structures 
despite challenges developer brought system concept function months 
linux kernel supports standard interfaces extension classes 
example generic interface block character devices file systems 
interfaces implemented language structures containing set function pointers 
interactions kernel extensions take place function calls kernel extensions extensions exported kernel routines 
global data structures current task structure directly accessed extensions 
fortunately extensions modify structures frequently preprocessor macros inline functions 
result nooks interpose extension kernel interactions intercepting function calls extensions kernel 
shows nooks layer inside linux 
nooks isolation manager isolated kernel extensions single device driver stacked drivers kernel service 
extensions wrapped nooks wrapper stubs indicated shaded boxes surrounding 
wrapped box containing extensions represents single nooks protection domain 
shows unwrapped kernel extensions continue interface directly linux kernel 
nim exists linux layer implements functions described previous section 
facilitate portability intel protection rings memory segmentation mechanisms 
extensions execute privilege level ring rest kernel 
memory protection provided conventional page table architecture implemented hardware software filled translation lookaside buffers tlbs 
table shows size nooks implementation 
nooks composed lines code 
contrast kernel lines linux distribution including user mode utilities wheeler 
commodity systems similar size 
acm transactions computer systems vol 
february 
swift fig 

nooks layer shaded inside linux os showing wrapped linux extensions executing isolated protection domains 
necessary wrap extensions indicated unshaded extensions right 
table number lines source code nooks source components lines memory management object tracking extension procedure call wrappers recovery linux kernel changes miscellaneous total number lines code example various reports related microsoft windows server operating system contains lines code 
clearly relative base kernel extensions nooks reliability layer introduces modest amount additional system complexity 
subsections discuss implementation nooks major components isolation interposition wrappers object tracking recovery 
describe wrappers separately bulk nooks code complexity 
describe limitations nooks implementation 
isolation isolation components nooks consist parts memory management lightweight protection domains virtual memory acm transactions computer systems vol 
february 
improving reliability commodity operating systems fig 

protection kernel address space 
protection extension procedure call xpc transfer control safely extensions kernel 
shows linux kernel lightweight kernel protection domains containing single extension 
components exist kernel address space 
memory access rights differ component example kernel read write access entire address space extension restricted read kernel access read write access local domain 
similar management address space single address space operating systems chase 
provide extensions read access kernel nooks memory management code maintains synchronized copy kernel page table domain 
lightweight protection domain private structures including domain local heap pool stacks extension memory mapped physical input output regions kernel memory buffers socket buffers blocks currently extension 
noted previously nooks protects bugs malicious code 
lightweight protection domains reflect design 
example nooks prevents extension writing kernel memory prevent malicious extension explicitly replacing domain local page table reloading hardware page table base register 
changing protection domains requires change page tables 
intel architecture flushes tlb change substantial cost entering lightweight protection domain flush subsequent tlb misses 
cost mitigated architecture tagged tlb mips alpha space protection support ia pa risc 
nooks lightweight protection domains kernel tasks share kernel address space minimize costs scheduling data copying domain change compared normal cross address space kernel user remote procedure calls rpcs 
acm transactions computer systems vol 
february 
swift nooks currently protect kernel direct memory access dma device kernel address space 
preventing rogue dma requires hardware generally computers 
nooks tracks set pages writable driver information restrict dma machine appropriate hardware support 
nooks uses xpc mechanism transfer control extension kernel domains 
xpc transparent kernel extensions continue interact original procedural interfaces 
transparency provided means wrapper mechanism described section 
control transfer xpc managed functions internal nooks nooks driver call transfers kernel extension nooks kernel call transfers extensions kernel 
functions take function pointer argument list protection domain 
execute function arguments specified domain 
transfer routines save caller context stack find stack calling domain may newly allocated reused calls nested change page tables target domain call function 
reverse operations performed call returns 
performance cost xpc relatively high requires changing page tables potentially flushing tlb 
ameliorate cost xpc supports deferred calls batches calls single 
wrappers queue deferred function calls execution entry exit xpc 
example changed packet delivery routine network driver batch transfer message packets driver kernel 
packet arrives extension calls wrapper pass packet kernel 
wrapper queues packet batches packets arrive 
function calls deferred visible side effects call 
queues exist domain extension domain queue holds delayed kernel calls kernel domain queue holds delayed extension calls 
addition deferring calls performance reasons nooks uses deferred xpc synchronize extension modifications objects explicitly passed kernel extensions 
linux kernel returns kernel structure pointer extension structure modification explicit synchronization update 
kernel assumes modification atomic extension update time cases wrapper queues deferred function call copy modified object back kernel extension xpc return kernel 
time changes linux kernel support isolation 
maintain coherency kernel extension page tables inserted code linux kernel modifies kernel page table 
second modified kernel exception handlers detect exceptions occur nooks protection domains 
new code swaps kernel stack pointer page directory pointer task 
return exception code restores stack pointer page table extension 
linux task structure kernel stack changes result isolation change mechanism locating current acm transactions computer systems vol 
february 
improving reliability commodity operating systems task structure 
currently global variable hold task pointer sufficient uniprocessor systems 
multiprocessor unused segment register done windows 
interposition interposition allows nooks intercept control communication extensions kernel 
nooks interposes extension kernel control transfers wrapper stubs 
wrappers provide transparency preserving existing kernel driver procedure call interfaces enabling protection control data transfers directions 
control interposition required changes linux kernel code 
modified standard module loader bind extensions wrappers kernel functions extensions loaded 
second modified kernel module initialization code explicitly interpose initialization call extension enabling extension execute lightweight protection domain 
initialization function pointers passed extension kernel replaced wrapper pointers 
causes kernel call wrappers extension procedures directly 
addition interposing control transfers nooks interpose data 
linux kernel exports objects read extensions current time 
objects linked directly extension freely read 
kernel objects directly written extensions 
changed macros inline functions directly modify kernel objects wrapped function calls 
object modifications performance critical nooks converts access xpc kernel 
performance critical data structures create shadow copy kernel object extension domain 
contents kernel object shadow object synchronized extension 
technique example data structure contains queue packets sent received network device 
wrappers noted nooks inserts wrapper stubs kernel extension functions 
types wrappers kernel wrappers called extensions execute kernel supplied functions extension wrappers called kernel execute extension supplied functions 
case wrapper functions xpc stub appears caller target procedure called domain 
wrapper types perform body kernel protection domain 
domain change occurs different point depending direction transfer shown 
extension calls kernel wrapper wrapper performs xpc entry body wrapper object checking copying execute kernel domain 
wrapper done calls target kernel function directly local procedure call 
opposite direction kernel calls extension wrapper wrapper executes kernel domain 
acm transactions computer systems vol 
february 
swift fig 

control flow extension kernel wrappers 
done wrapper performs xpc transfer target function extension 
wrappers perform basic tasks 
check parameters validity verifying object tracker memory manager pointers valid 
second object tracker code wrappers implements call semantics xpc creating copy kernel objects local heap stack extension protection domain 
marshalling unmarshalling necessary extension kernel share kernel address space 
simple objects synchronization code placed directly wrappers 
complex objects file system inodes directory entries pointers structures wrote explicit synchronization routines copy objects kernel extension 
third wrappers perform xpc kernel extension execute desired function shown 
wrappers relatively straightforward write integrate kernel 
developed tool automatically generates wrapper entry code skeleton wrapper bodies linux kernel header files 
create wrappers exported kernel functions tool takes list kernel function names generates wrappers implement function interposition xpc 
similarly kernel extension interface tool takes list interfaces structures containing function pointers generates wrappers kernel call 
wrote main wrapper body functions hand 
time task required support kernel extension interface specific os 
code verifies parameters correct moves parameters protection domains 
written wrappers automatically usable extensions kernel interface 
writing wrapper requires knowing parameters parameters alive calls passed threads parameters fields parameters modified 
performed task hand engler determine characteristics extensions analyzing set existing drivers 
wrapper code sharing 
section describes extensions isolated nooks experiments sound card drivers sb es acm transactions computer systems vol 
february 
improving reliability commodity operating systems fig 

code sharing wrappers different extensions 
ethernet drivers file system vfat kernel web server 
previously table showed nooks implementation includes lines wrapper code half nooks code base 
implemented wrappers isolate imported exported functions 
wrapper code shared multiple drivers class classes 
shows total number wrappers kernel extension wrappers extensions 
bar gives breakdown number wrappers unique extension number wrappers shared various ways 
sharing reduces cost adding fault resistance extension 
example wrappers ethernet driver kernel wrappers extension wrappers shared network drivers 
similarly wrappers shared sound card drivers 
wrappers shared kind extensions vfat 
object tracking object tracker recovery kernel objects extension failure 
nooks object tracker performs independent tasks 
records addresses objects extension 
objects duration single xpc call recorded table attached current task structure 
objects long lifetimes recorded acm transactions computer systems vol 
february 
swift protection domain hash table 
second objects may written extension object tracker records association kernel extension versions object 
association wrappers pass parameters extension protection domain kernel protection domain 
object tracker know lifetimes objects perform garbage collection necessary prevent extensions dangling 
currently code written examining interface 
common paradigms 
example objects accessible extension lifetime single xpc call kernel 
case add object tracker database call begins remove return 
objects explicitly allocated deallocated extension case know lifetimes exactly 
cases go semantics object 
example extensions allocate timer data structure suspend task 
add object object tracker extension calls add timer remove timer fires point know longer 
cases may necessary modify kernel notify nooks object deleted 
complex objects may handled different ways 
cases nooks copies objects extension protection domain embedded pointers appropriate 
cases nooks avoids copying example mapping network packets disk blocks extension 
page tracker mechanism object tracker remembers state mapped pages revokes extension access pages 
nooks implementation currently supports kernel object types pci devices inodes memory pages 
determine set objects track inspected interfaces kernel supported extensions noted object passed interfaces 
wrote object tracking procedures object types saw 
object type unique type identifier code release instances type recovery 
recovery recovery nooks consists parts 
fault occurs recovery manager releases resources extension 
user mode agent coordinates recovery determines course action take 
nooks triggers recovery detects failure software checks parameter validation livelock detection processor exceptions explicit external signals 
failure nooks suspends running extension notifies recovery manager 
nooks recovery manager tasked returning system including extension clean state continue 
recovery manager executes phases ensure resources released 
phase recovery specific device drivers nooks disables interrupt processing device controlled extension preventing livelock acm transactions computer systems vol 
february 
improving reliability commodity operating systems occur device interrupts properly dismissed 
starts user mode recovery agent controls subsequent recovery 
user mode recovery agent relies configuration database define recovery policy specific extensions classes extensions 
agent perform extension specific recovery actions notify system managers fault 
change configuration parameters replace extension disable recovery extension fails frequently 
agent requires kernel components file system disk driver function properly 
designing recovery mechanism assume drivers fail due transient faults gray reproduce 
evidenced fact drivers typically function correctly rebooting 
take advantage non reproducing nature driver faults simplify recovery process 
trying roll back driver previous safe state completely restart driver 
default recovery agent initiates full recovery faulting extensions unloading extension releasing kernel physical resources reloading restarting extension 
agent calls recovery manager release resources may safely reused kernel 
recovery manager signals tasks currently executing extension called extension unwind 
task non interruptible state kernel extension complete recovery may impossible sleeping task wakes 
case partial recovery may possible processes continue execute 
sleeps infrequent linux kernel believe significant limitation 
nooks releases kernel resources extension accessed external device 
example network device may continue write packet buffers memory buffers released device reinitialized 
recovery manager walks list objects known object tracker releases frees objects accessed external devices 
nooks associates object type tracker recovery function 
function releases object kernel removes kernel extension 
new kernel extension interfaces added nooks kernel developers need add functions recover new object types interfaces 
nooks ensures correctness kernel data structures recovery object tracker xpc 
call value result ensures kernel data structures updated atomically 
object tracker records extension kernel data structures remove extension 
releasing kernel resources agent extension 
consults policy may choose automatically reload extension new lightweight protection domain 
agent initializes extension startup scripts accompany extension 
device drivers driver reloaded nooks release physical resources acm transactions computer systems vol 
february 
swift accessed device interrupt request levels physical memory regions 
implementation limitations section described nooks philosophy designing mistakes fault resistance 
nooks implementation involves trade offs 
provide complete isolation fault tolerance possible extension errors 
nooks runs extensions kernel mode simplify backward compatibility prevent extensions deliberately executing privileged instructions corrupt system state 
prevent infinite loops inside extension detect livelock extension kernel timeouts 
check parameters passed operating system complete job linux semantics lack thereof 
current implementation recovery limited extensions killed restarted safely 
true device drivers dynamically loaded hardware devices attached system 
may true extensions 
limitations insignificant crashes may occur 
believe implementation allow kernel resist crashes caused extensions 
enormous number crashes solution large impact reliability 
achieving transparency previously mentioned nooks code isolates extension rest kernel tracks resources uses 
isolation allows nooks catch errant behavior 
resource tracking allows nooks clean extension state behavior 
isolation resource tracking rely able interpose communication kernel extensions 
part communication linux takes place means procedure call inlined macro replace compile time procedure call 
implementation oriented interface types extensions allowing incorporate nooks infrastructure completely transparent way kernel extension requires modification 
unfortunately extensions store directly kernel data structures making impossible transparently interpose 
types extensions necessary manually modify code replace stores procedure calls 
extensions isolated extensions required code modifications required modify lines code directly wrote kernel data structures 

evaluating reliability thesis nooks significantly improve system reliability isolating kernel extension failures 
section uses automated experiments demonstrate nooks detect automatically recover acm transactions computer systems vol 
february 
improving reliability commodity operating systems table ii 
types faults injected extensions code transformations emulate faults fault type code transformation source fault change source register destination fault change destination register pointer fault change address calculation memory instruction interface fault existing value register passed parameter branch fault delete branch instruction loop fault invert termination condition loop instruction text fault flip bit instruction nop fault elide instruction faults extensions 
tests nooks recovered extension faults crash linux 
test methodology tested nooks variety existing kernel extensions introduced bugs induce faults 
fault injection 
experiments synthetic fault injection insert faults linux kernel extensions 
adapted fault injector developed rio file cache ng chen ported linux 
injector automatically changes single instructions extension code emulate variety common programming errors uninitialized local variables bad parameters inverted test conditions 
injected different types faults system 
injected faults emulate specific programming errors common kernel code earlier studies sullivan chillarege chillarege 
source destination faults emulate assignment errors changing operand destination instruction 
pointer faults emulate incorrect pointer calculations cause memory corruption 
interface faults emulate bad parameters 
emulated bugs control flow branch faults remove branch instruction loop faults change termination condition loop 
second expanded range testing injecting random changes model specific programming errors 
category text faults flipped random bit random instruction nop faults deleted random instruction 
table ii shows types faults injected injector simulates programming errors see ng chen complete description fault injector 
tests injected equal number fault type 
types extensions isolated 
experiments reported nooks isolate types extensions device drivers kernel subsystem vfat application specific kernel extension 
device drivers chose common network sound card drivers representative largest class linux drivers linux sound acm transactions computer systems vol 
february 
swift table iii 
extensions isolated function performs measurements reported extensions shown bold 
extension purpose sb driver es sound driver intel pro gigabit ethernet driver amd ethernet driver com series ethernet driver com series ethernet driver vfat win compatible file system kernel web server card drivers network drivers 
device driver interaction kernel matched nooks isolation model reasons 
drivers invoke kernel invoked kernel narrow welldefined interfaces straightforward design implement wrappers 
second drivers frequently deal blocks opaque data network packets disk blocks require validation 
third drivers batch processing amortize interrupt overheads 
run nooks batching reduces isolation overhead 
addition device drivers isolated loadable kernel subsystem 
subsystem chose optional vfat file system compatible windows fat file system microsoft 
drivers tend small number interfaces relatively functions vfat interface larger complex device drivers 
vfat distinct interfaces export calls comparison sound network devices interface functions respectively 
addition driver interfaces tend pass relatively simple data structures network packets device objects file system interfaces pass complex heavily linked data structures inodes 
isolated application specific kernel extension web server van de ven 
resides kernel access kernel network file system data structures directly avoiding expensive system calls 
experience demonstrates nooks isolate ad hoc unanticipated kernel extensions 
isolated extensions nooks shown table iii 
reliability performance results extensions representing extension types sb vfat 
results remaining drivers consistent 
test environment 
application level workload consists programs stress sound card driver network driver vfat 
program plays short mp file 
second performs series icmp ping tcp streaming tests third compiles number files 
fourth program runs web load generator kernel level web server 
acm transactions computer systems vol 
february 
improving reliability commodity operating systems ran reliability experiments context vmware virtual machine 
virtual machine allows perform thousands tests remotely quickly easily returning system clean state 
spot checked number vmware trials base hardware configuration virtual machine discovered anomalies 
addition tests run directly raw hardware vmware support intel pro gigabit ethernet card 
measure reliability conducted series trials injected faults extensions running different linux configurations 
called native nooks isolation services unused 
second called nooks isolation services enabled extension test 
extension ran trials fault type native configuration 
trial injected random errors extension exercised system observing results 
ran trials errors nooks 
important note native nooks configurations identical binaries allowing automatic fault injector introduce identical errors 
kernel module binaries tests 
describe results experiments 
test results described ran fault injection trials measured extensions native nooks configurations 
fault injection trials cause faulty behavior example bugs inserted rarely executed path rarely produce error 
trials cause failures 
examine different types failures occurred 
system crashes 
system crash extreme easiest problem detect operating system unresponsive simply reboots 
ideal world system crash caused fault injection trial native linux result recovery nooks 
practice previously discussed nooks may detect recover certain failures caused bad programmers bad luck 
shows number system crashes caused fault injection experiments extensions running native linux nooks 
crashes observed native linux nooks eliminated 
remaining crashes system deadlocked nooks handle 
illustrates substantial difference number system crashes occur vfat sb extensions linux compared 
difference reflects way linux responds kernel failures 
extensions interrupt oriented kernel mode extension code run result interrupt 
vfat sb extensions process oriented kernel mode extension code run result system call user process 
manipulates corrupt interrupt level data structures 
linux treats exceptions interrupt oriented code fatal crashes acm transactions computer systems vol 
february 
swift fig 

reduction system crashes fault injection trials extension observed nooks 
total system crashes native configuration system crashes nooks 
system large number crashes 
linux treats exceptions process oriented code continuing run kernel terminating offending process exception occurred kernel 
behavior unique linux 
operating systems microsoft windows xp deal kernel processor exceptions aggressively halting operating system 
systems vfat sb cause system crashes 
extension failures 
nooks designed protect os misbehaving extensions designed detect erroneous extension behavior 
example network disappear device driver corrupts device registers mounted file system simply due bug 
failures fatal system right nooks generally detect problems intended 
nooks simple failure detectors detect problems recovery services safely restart faulty extensions 
fault injection trials cause number extension failures allowing examine nooks effectiveness dealing cases 
shows extent nooks reduces extension failures occurred native linux 
reality results simply reflection linux handling process interrupt oriented extension code previously described 
nooks trap exceptions process oriented acm transactions computer systems vol 
february 
improving reliability commodity operating systems fig 

reduction extension failures observed nooks 
total failures native configuration nooks 
extensions recover extensions bring clean state cases 
interrupt oriented ethernet drivers nooks eliminated system crashes resulting extension exceptions 
remaining failures leave device nonfunctional state example unable send receive packets 
nooks remove failures detect 
extension failures eliminated occurred device manipulated process oriented code 
sb sound card driver nooks reduced number extension failures 
failures caused kernel exceptions code caused linux terminate calling process leave extension ill defined state 
nooks detected processor exceptions performed extension recovery allowing application continue 
remaining extension failures occurred native linux nooks serious leave extension state serious generate processor exception trapped nooks 
extension similar interrupt oriented drivers causes corruption leads interrupt level faults 
small number injected faults caused exceptions process oriented code 
caught nooks extension failure avoided 
acm transactions computer systems vol 
february 
swift general remaining extension failures nooks result deadlock data structure corruption extension 
fortunately failures localized extension usually recovered discovered 
straightforward develop service probes disabled extensions invokes nooks recovery procedures appropriate 
alternatively failure detected user invoke nooks initiate manual recovery 
recovery errors 
nooks recovery procedure straightforward faulting extension unloaded reloaded restarted 
network sb extensions process improves reliability directly 
vfat deals persistent state stored disk chance extension damage critical disk structures nooks detects error condition 
practice cases vfat recovery resulted disk corruption lost corrupt files directories 
fault injection occurs files directories created abrupt shutdown restart file system leaves corrupted state 
experiment caused nooks synchronize disks memory disk cache releasing resources vfat recovery 
reduced number corruption cases 
expect nooks automatically suggests may extensions nooks improve recovery application specific recovery services 
manually injected errors 
addition automatic fault injection experiments inserted bugs hand 
common fixes faults reported linux kernel mailing list article chou broke extensions removing checks null pointers failing properly initialize stack heap variables dereferencing user level pointer freeing resource multiple times 
nooks automatically detected recovered failures 
latent bugs 
nooks revealed latent bugs existing kernel extensions 
example discovered bug com ethernet driver occurs initialization 
driver fails detect card system immediately frees large buffer 
driver unloaded zeroes buffer 
nooks caught bug write protected memory freed 
nooks discovered bug extension van de ven freed object referenced 
general nooks useful kernel development tool provides fast restart extension development fails 
summary synthetic reliability experiments nooks eliminated system crashes occurred native linux 
remaining failures directly reflect best efforts principle cost terms reliability approach imposes reliability legacy acm transactions computer systems vol 
february 
improving reliability commodity operating systems table iv 
relative performance nooks compared native linux benchmark tests cpu utilization accurate percent 
relative performance determined comparing latency play mp compile local throughput send stream receive stream serve simple web page serve complex web page 
data reflects average trials standard deviation 
xpc nooks native nooks rate relative cpu cpu benchmark extension second perf 
util 
util 
play mp sb receive stream receiver send stream sender compile local vfat serve simple web page server serve complex web page server extension operating systems code 
addition crashes nooks recover extension failures 
nooks detect kinds erroneous behavior trap extension exceptions initiate recovery cases 
nooks eliminated extension failures caused fault injection trials 
nooks detected recovered commonly occurring faults injected hand 

performance section presents benchmark results evaluate performance cost nooks isolation services 
experiments existing benchmarks tools compare performance system nooks 
test machine dell ghz pentium pc running linux 
machine includes mb ram sound card intel pro gigabit ethernet adapter single rpm gb ide hard disk drive 
network tests similarly equipped machines report performance information slower network adapters avoid unfairly biasing results favor nooks 
reliability tests described previously performance tests run bare machine vmware virtualization system 
table iv summarizes benchmarks evaluate system performance 
benchmark nooks isolate single extension indicated second column table 
ran benchmark native linux nooks version linux nooks enabled 
table shows relative change performance nooks wall clock time throughput depending benchmark 
show cpu utilization measured benchmark execution rate second incurred test 
table shows nooks achieves performance native linux tests 
isolation services primarily imposed point xpc rate offers telling performance indicator 
benchmarks fall broad categories characterized rate low frequency acm transactions computer systems vol 
february 
swift 
second moderate frequency second high frequency tens thousands second 
look benchmark turn 
sound benchmark play mp benchmark plays mp file kb system sound card generating second 
low rate additional xpc overhead nooks imperceptible terms execution time cpu overhead 
low bandwidth devices system keyboards mice bluetooth devices modems sound cards nooks offers clear benefit improving driver reliability performance cost 
network benchmarks receive stream benchmark example moderate xpc frequency test 
receive stream measured netperf jones performance tool receiving node isolated ethernet driver receive stream kb tcp messages kb buffer 
ethernet driver intel pro card batches incoming packets reduce interrupt xpc frequency 
receiver performs interrupt handling code critical path packet delivery 
results throughput reduction cpu utilization increase percentage points 
contrast send stream measured netperf high test isolates sending node ethernet driver 
receive stream test benefits batching received packets os batch outgoing packets sends 
total amount data transmitted send stream executes nearly order magnitude second receive stream 
cpu utilization sender increases native linux nooks 
receive stream benchmark throughput drops 
despite higher xpc rate xpc processing sender overlapped actual sending packets mitigating nooks overhead 
slower processors faster networks may worthwhile batch outgoing streaming packets done example network terminal protocols gettys 
compile benchmark isolated file system offers opportunity explore deeply performance implications nooks architecture implementation 
table iv shows time compile linux kernel local vfat file system greater nooks native linux 
cpu equally utilized execution cases conclude slowdown possible causes 
code run nooks code common implementations runs slowly nooks 
acm transactions computer systems vol 
february 
improving reliability commodity operating systems fig 

comparative times spent kernel mode compile local vfat benchmark 
run nooks system performed kernel extension 
time user mode shown identical configurations 
understand causes better profiled measured benchmark running native linux linux nooks 
results shown 
time spent running application code shown identical configurations 
contrast shows time spent executing kernel code significantly different configurations native nooks 
upper bars show code worth executed nooks 
xpc functionality accounted half additional overhead 
xpc graph shows object tracking incurred significant cost 
remaining components wrappers page table synchronization data copying incurred minor overhead 
high level illustrates cost isolation recovery protected system 
isolation costs manifest terms xpc overhead page table synchronization data copying 
recovery costs reflected terms object tracking occurs time pointer passed xpc 
recall object tracking allows nooks correctly recover kernel resources event extension failure 
measurements demonstrate enabling recovery substantial cost 
conversely demonstrate fast interprocess communication ipc part performance equation environment recovery important isolation bershad 
addition showing code run nooks lower bars show code common systems runs slowly nooks 
native linux spent vfat code spent rest kernel 
contrast nooks spent vfat rest kernel 
code vfat rest kernel identical difference due increased memory pressure caused nooks 
example domain change occurs part xpc requires complete flush processor tlb pentium 
pentium performance counters allowed measure number kernel data tlb kernel data cache misses instruction workload 
nooks kernel tlb misses instruction increased threefold 
acm transactions computer systems vol 
february 
swift contrast data cache misses instruction changed relatively little 
consequently tlb cache kernel code run slowly nooks 
confirm built special version nooks require tlb flush xpc extensions kernel run single domain 
version allows directly observe impact tlb course provides protection useful evaluating performance 
eliminating flush surprisingly decreased time spent nooks code furthermore xpc time dropped number data tlb misses instruction greater native linux 
suggests optimizations reduce number tlb misses superpages may important versions system 
furthermore processor support tagging tlb entries remove need flush eliminating misses 
web server benchmarks final benchmarks illustrate impact server performance transactional workloads 
serve simple web page uses high xpc frequency extension server deliver static content cached memory 
httperf mosberger jin generate workload repeatedly requested single kilobyte sized web page 
native linux serve pages second 
nooks serve representing decrease throughput 
elements benchmark behavior conspire produce poor performance 
server processor system bottleneck 
example run natively server cpu utilization nearly 
consequently high xpc rate slows server substantially 
second workload transactional client request rate drops function server slowdown 
comparison send stream benchmark exhibits roughly rate saturating cpu degrades 
addition send stream transactional network buffering helps mask server side slowdown 
clear represents poor application nooks bottleneck performs 
service cast extension access kernel resources directly indirectly standard system call interface 
nooks isolation facilities impose penalty accesses performance suffers 
believe types extensions virus intrusion detectors placed kernel access protect resources unavailable user level better candidates represent system bottlenecks 
contrast second web server test serve complex web page reflects moderate xpc frequency 
ran specweb workload standard performance evaluation user mode apache web server apache project nooks isolation ethernet driver 
workload includes mix static dynamic web pages 
test configuration throughput limited due single ide disk drive 
running nooks web server handled peak requests acm transactions computer systems vol 
february 
improving reliability commodity operating systems second 
nooks installed ethernet driver isolated server peak throughput dropped requests second 
summary section small set benchmarks quantify performance cost nooks 
sound ethernet drivers tested nooks imposed performance penalty 
ad hoc application extension penalty nearly 
key factor performance impact number required impose burden particularly tlb current implementation 
performance costs nooks isolation services depend cpu utilization imposed workload 
cpu saturated additional cost significant 
nooks provides substantial reliability improvement cost depends extension isolated 
reliability performance tradeoff case case basis 
computing environments performance modern systems believe benefits nooks isolation recovery services worth costs 

related differs substantial body research extensibility reliability dimensions 
nooks relies conventional processor architecture conventional programming language conventional operating system architecture existing extensions 
designed transparent extensions support recoverability impose modest performance penalty 
hardware support modularity major hardware approaches improve reliability include capability architectures organick levy ring segment architectures intel saltzer witchel similar approach newer context 
systems support finegrained protection enabling construction isolation privileged subsystems 
os extended adding new privileged subsystems exist new domains segments 
recovery specifically addressed architecture 
particular capabilities support fine grained sharing data 
sharing component fails recovery may difficult sharing resource 
segmented architectures difficult program plagued poor performance 
contrast nooks isolates existing code commodity processors standard virtual memory runtime techniques supports recovery garbage collection extension allocated data 
operating system support isolation recovery projects isolated kernel components new operating system structures 
microkernels wulf liedtke young derivatives engler ford hand promise path reliability 
systems isolate extensions separate address acm transactions computer systems vol 
february 
swift spaces interact os kernel communication service messages remote procedure call bershad 
failure extension address space necessarily crash system 
capability systems recovery received little attention microkernel systems 
mach example user level system service fail crashing kernel rebooting way service 
despite research fast interprocess communication ipc bershad liedtke reliance separate address spaces raises performance concerns prevented adoption commodity systems 
microkernel monolithic hybrids linux provide isolation support needed reliability difficult integrate existing code bases 
past virtual memory techniques isolate specific components data corruption example database sullivan stonebraker file system cache ng chen 
nooks uses similar techniques protect operating system erroneous extension behavior 
virtual machine technologies chapin chen noble whitaker proposed solution reliability problem 
reduce amount code crash machine 
virtualization techniques typically run entire operating systems top virtual machine faulty extensions operating system cause applications fail 
extension executes virtual machine monitor device drivers physical devices fault causes virtual machines applications fail 
applications partitioned virtual machines limit scope failure doing removes benefits sharing operating system fast ipc intelligent scheduling 
challenge reliable extensibility virtualizing underlying hardware lies virtualizing interface kernel extension 
fact major feature nooks architecture 
number transaction systems schmuck wylie seltzer applied recoverable database techniques os improve reliability 
cases file system approach worked proved awkward slow schmuck wylie 
language approaches strategies limited applicability 
contrast nooks integrates transparently existing hardware operating systems 
compiler language support reliability alternative operating system isolation type safe programming languages run time systems bershad prevent faults occurring 
systems provide performance advantages compile time checking enables lightweight run time structures local procedure calls cross domain calls 
date os suppliers unwilling implement system code type safe high level acm transactions computer systems vol 
february 
improving reliability commodity operating systems languages 
type safe language approach impossible leverage enormous existing code base 
contrast nooks requires specialized programming language 
years seen development software techniques enforce code correctness properties example software fault isolation wahbe self verifying assembly code necula lee 
technologies attractive replace augment nooks isolation techniques 
proposed form deal isolation problem leaving unsolved problems transparent integration recovery 
techniques verifying integrity extensions existing operating systems proven effective revealing programming errors engler deline hndrich ball rajamani condit 
static approach obviously complements dynamic 
devil project takes different approach ensuring drivers interact devices correctly 
devil device vendor specifies device software interface domain specific language 
devil compiler uses specification generate api language stubs device 
driver writers call functions access device 
devil removes bugs associated drivers abstracting away complexities communicating ports memory mapped device registers 
approach complementary nooks removes bugs drivers requires writing new drivers generated interface 
recovery researchers begun focus recovery general technique dealing failure complex systems patterson 
example candea candea fox proposes model recursive recovery inthe model complex software system decomposed multilevel implementation layer fail recover independently 
nooks complementary focus date limited restarting portions operating system kernels 
systems focused recovery faults existing code discount checking lowell chen lowell 
discount checking recovers faults user level programs automatically state periodically reverting back previous snapshot failure 
nooks contrast complete restarts failed kernel extensions 
wrappers reliability recovery systems 
fabre project fetzer xiao wrappers similar nooks existing code tolerate recover faults automatically 
wrappers verify pre postconditions catch exceptions retry function calls failure 
nooks systems incorporate memory isolation prevent accidental memory corruption 
table shows changes hardware architecture operating system architecture extension architecture required previous approaches reliability 
nooks virtual machines static analysis techniques need architectural changes 
acm transactions computer systems vol 
february 
swift table components require architectural changes various approaches reliability cell indicates reliability mechanism row requires architectural change component listed top column 
required modifications approach hardware os extension capabilities microkernels languages new driver architectures transactions virtual machines static analysis nooks summary nooks brings commodity operating systems known requirements fault operating systems denning isolation resource control decision verification checking error recovery 
nooks provides features extensions way compatible transparent existing code 

kernel extensions major source failure modern operating systems 
nooks new reliability layer intended significantly reduce failures 
nooks uses hardware software techniques isolate kernel extensions trapping common faults permitting extension recovery 
nooks system focuses achieving backward compatibility sacrifices complete isolation fault tolerance compatibility transparency existing kernels extensions 
nooks demonstrates possible realize extremely high level operating system reliability performance loss ranging zero just 
fault injection experiments reveal nooks recovered faults caused native linux crash 
experience shows implementation nooks layer achievable modest engineering effort monolithic operating system linux extensions device drivers isolated little change extension code isolation recovery dramatically improve system ability survive extension faults 
experiments demonstrate nooks defines new point reliability performance space simple kernel mode user mode 
today world nearly extensions run kernel potential threats reliability 
nooks offers kernel developers substantial degree reliability cost ranging negligible significant 
decision isolate kernel extension light extension native reliance kernel services bottleneck potential environment 
clearly device drivers low xpc frequency extensions decision easy 
question requirements 
performance acm transactions computer systems vol 
february 
improving reliability commodity operating systems matters reliability isolation may appropriate 
impressive performance current processors enormous rate performance increasing devices easy decision category today join category passing year 
acknowledgments appreciate efforts steve martin doug buxton help developing wrapper generating tool testing nooks leo shum adding sound card support christophe recovery agent reliability testing 
intel microsoft information respective products 
frans kaashoek anonymous referees suggestions improved content presentation article 
apache project 

apache server version 
available online httpd 
apache org 
ball rajamani 
automatically validating temporal safety properties interfaces 
spin workshop model checking software 
lecturer notes computer science vol 

springer verlag berlin germany 
bershad 
increasing irrelevance ipc performance microkernel operating systems 
proceedings workshop micro kernels kernel architectures seattle wa 

bershad anderson lazowska levy 
lightweight remote procedure call 
acm trans 
comput 
syst 
feb 
bershad savage pardyak sirer fiuczynski becker chambers eggers 
extensibility safety performance spin operating system 
proceedings th acm symposium operating systems principles copper mountain 

birrell nelson 
implementing remote procedure calls 

comput 
syst 
feb 

understanding linux kernel 
reilly ca 
candea fox 
recursive turning reboot scalpel 
proceedings eighth ieee hotos 

chapin rosenblum devine lahiri gupta 
hive fault containment shared memory multiprocessors 
proceedings th acm symposium operating systems principles copper mountain resort 

chase levy feeley lazowska 
sharing protection single address space operating system 
acm trans 
comput 
syst 
nov 
chen noble 
virtual better real 
proceedings eighth ieee hotos 

chou yang chelf hallem engler 
empirical study operating system errors 
proceedings th acm symposium operating systems principles lake louise alta canada 

chillarege 
generation error set emulates software faults field data 
proceedings ieee symposium fault tolerant computing ftcs sendai japan 

condit harren necula weimer 
ccured real world 
proceedings acm sigplan acm conference programming language design implementation san diego ca 

custer 
inside windows nt 
microsoft press redmond wa 
acm transactions computer systems vol 
february 
swift deline hndrich 
enforcing high level protocols low level software 
proceedings acm sigplan acm conference programming language design implementation snowbird ut 

denning 
fault tolerant operating systems 
acm comput 
surv 
dec 
dennis horn 
programming semantics multiprogramming systems 
commun 
acm mar 
engler chelf chou hallem 
checking system rules programmer written compiler extensions 
proceedings th usenix symposium operating systems design implementation san diego ca 

engler kaashoek jr 
exokernel operating system architecture application level resource management 
proceedings th acm symposium operating systems principles copper mountain resort 

fabre rodr 

building dependable cots microkernel systems 
proceedings pacific rim international symposium dependable computing los angeles ca 

fabry 
capability addressing 
commun 
acm july 
fetzer xiao 
toolkit enhancing robustness security existing applications 
proceedings international conference dependable systems networks dsn san francisco ca 

ford back benson lepreau lin shivers 
flux oskit substrate os language research 
proceedings th acm symposium operating systems principles 

forin golub bershad 
system mach 
proceedings usenix mach symposium 

gettys carlton mcgregor 
window system version 
softw prac 
exp oct 

role linux reducing cost enterprise computing 
idc white 
international data framingham ma 
gosling joy steele 
java language specification 
addison wesley reading ma 
gray 
computers done 
proceedings fifth ieee symposium reliability distributed software database systems los angeles ca 


bluetooth radio system 
ieee personal commun 
mag 
feb 
hand 
self paging nemesis operating system 
proceedings rd usenix symposium operating systems design implementation new orleans la 

liedtke sch berg wolter 
performance kernel systems 
proceedings th acm symposium operating systems principles saint malo france 

hewlett packard 

hewlett packard digital entertainment center 
go online www hp com press oct htm 
hoffman 
ibm system support addressing 
proceedings th acm ieee international symposium computer architecture 

tsai iyer 
fault injection techniques tools 
ieee comput 
apr 
intel 

ia architecture software developer manual volume basic architecture 
intel santa clara ca 
available online www intel com design pentium manuals pdf 
jones 
netperf network performance benchmark version 
available online www netperf org 
chase eggers 
architectural support single address space operating systems 
proceedings fifth international conference architectural support programming languages operating systems 

acm transactions computer systems vol 
february 
improving reliability commodity operating systems levy 
capability computer systems 
digital press burlington ma 
available online www cs washington edu homes levy 
liedtke 
kernel construction 
proceedings th acm symposium operating systems principles copper mountain resort 

lowell chandra chen 
exploring failure transparency limits generic recovery 
proceedings th usenix symposium operating systems design implementation san diego ca 

lowell chen 
discount checking transparent low overhead recovery general applications 
tech 
rep cse tr 
university michigan arbor mi 
re consel marlet muller 
devil idl hardware programming 
proceedings th usenix symposium operating systems design implementation san diego ca 

microsoft 

fat general overview disk format version 
microsoft redmond wa 
mosberger jin 
httperf tool measuring web server performance 
acm workshop internet server performance madison wi 

necula lee 
safe kernel extensions run time checking 
proceedings nd usenix symposium operating systems design implementation seattle wa 

ng chen 
systematic improvement fault tolerance rio file cache 
proceedings ieee symposium fault tolerant computing ftcs 

organick 
programmer view intel system 
mcgraw hill new york ny 
patterson brown candea chen cutler fox yc oppenheimer sastry tetzlaff 
recovery oriented computing roc motivation definition techniques case studies 
tech 
rep csd 
uc berkeley computer science 
ca 
project udi 

udi version 
tech 
rep project udi 
visit website www org 
saltzer 
protection control information sharing multics 
commun 
acm july 
schmuck wylie 
experience transactions quicksilver 
proceedings th acm symposium operating systems principles pacific grove ca 

seltzer endo small smith 
dealing disaster surviving misbehaved kernel extensions 
proceedings nd usenix symposium operating systems design implementation seattle wa 

short 
vice president windows core technology microsoft private communication 
standard performance evaluation 

specweb benchmark 
standard performance evaluation va visit web site www org 
lim 
virtualizing devices vmware workstation hosted virtual machine monitor 
proceedings usenix annual technical conference boston ma 
sullivan chillarege 
software defects impact system availability study field failures operating systems 
proceedings ieee symposium fault tolerant computing ftcs 
montreal canada 

sullivan stonebraker 
write protected data structures improve software fault tolerance highly available database management systems 
proceedings th international conference large data bases 
morgan kaufman publishing san francisco ca 

windows server road gold part developing windows 
paul windows 


digital video recorder 
go www com 
van de ven 
linux accelerator 
available online athttp www 
demon nl 
acm transactions computer systems vol 
february 
swift wahbe lucco anderson graham 
efficient software fault isolation 
proceedings th acm symposium operating systems principles asheville nc 

wheeler 
estimating gnu linux size 
available online www com sloc redhat redhat sloc html 
whitaker shaw gribble 
denali lightweight virtual machines distributed networked applications 
proceedings th usenix symposium operating systems design implementation boston ma 

witchel cates 
mondrian memory protection 
proceedings tenth international conference architectural support programming languages operating systems 

wulf 
hardware software architecture 
proceedings international conference reliable software los angeles ca 

young accetta baron bolosky golub rashid tevanian 
mach new kernel foundation unix development 
proceedings summer usenix conference atlanta ga 

received october revised may september accepted june acm transactions computer systems vol 
february 
