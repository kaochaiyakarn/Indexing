understanding consistency maintenance service discovery architectures communication failure christopher kevin mills jesse elder national institute standards technology gaithersburg maryland usa 
current trends suggest software systems comprise collections components combine recombine dynamically reaction changing conditions 
service discovery protocols enable software components locate available software services adapt changing system topology provide foundation dynamic behavior 
emerging discovery protocols specify alternative architectures behaviors motivate rigorous investigation properties underlying designs 
assess ability selected designs service discovery protocols maintain consistency distributed system catastrophic communication failure 
architectural description language called rapide model different architectures party party different consistency maintenance mechanisms polling notification 
models investigate performance differences combinations architecture mechanism interface failure rate increases 
measure system performance dimensions update responsiveness latency required propagate changes update effectiveness probability node receives change update efficiency messages sent propagate change topology 
rapide understand failure recovery strategies contribute differences performance 
recommend improvements architectural description languages 
keywords service discovery protocols software performance software architecture architectural description languages mills nist wosp submission 
growing deployment wireless communications implying greater user mobility coupled proliferation personal digital assistants information appliances software components quite sure network connectivity available software services components nearby state network neighborhood minutes 
extreme situations example military applications software components composing distributed system may find cooperating components disappear due physical cyber attacks due jamming communication channels movement nodes communications range 
environments demand new analysis approaches tools design test software 
considers rigorously assess robustness distributed software systems response faults process node link failures 
particularly seek techniques test measure behavior resilience dynamic distributed systems evaluate alternative approaches design systems 
compare contrast models alternative service discovery architectures commonly publicly available natural language specifications 
architectural description language adl transform specifications executable models precisely represent system structure behavior 
provide models realistic behaviors incorporate mechanisms adapted specifications jini networking technology universal plug play upnp :10.1.1.101.7093
combine various architectures mechanisms measure performance overhead attempting propagate changes communication failures 
show appropriate architecture modeling tool helps explain causes underlying measured performance 
method builds earlier derived benefits creating dynamic models specifications service discovery protocols 
dynamic models enable understand collective behavior distributed components detect ambiguities inconsistencies omissions specifications 
apply method construct architectural model discovery protocol identify specify relevant consistency conditions model satisfy define appropriate metrics comparing behavior model construct relevant scenarios exercise models probe violations consistency conditions compare results executing similar scenarios model 
carry method rely rapide adl developed stanford university 
rapide represents behavior form suitable investigate distributed systems comes accompanying suite analysis tools execute specification record visualize system behavior 
remainder organized sections 
section introducing service discovery protocols architectures including description procedures maintain consistency replicated information 
section discusses various failures interfere consistency maintenance 
section outline techniques included models recover failures 
section defines experiment related metrics compare performance overhead exhibited selected pairings architecture consistency maintenance mechanism attempting propagate changes interface failures 
section results experiment discuss causes underlying results 
section outline evaluate service discovery architectures protocols message loss node failure 
conclude section 
mills nist wosp submission 
service discovery protocols architectures service discovery protocols enable software components network discover determine discovered components meet specific requirements 
discovery protocols include consistency maintenance mechanisms applications detect changes component availability status maintain time bounds consistent view components network 
diverse industry activities explore different approaches meet requirements leading variety proposed designs service discovery protocols 
industry groups approach problem vertically integrated perspective coupled narrow application focus 
industry groups propose widely applicable solutions 
example team researchers engineers sun microsystems designed jini networking technology general service discovery mechanism atop java tm provides base portable software technology 
example group engineers microsoft intel conceived universal plug play attempt extend plug play automatic intra computer device discovery configuration protocol distributed systems 
proliferation service discovery protocols motivates deeper analyses designs 
table 
mapping concepts various service discovery systems 
generic model service user service manager service provider service description identity type attributes user interface program interface service cache manger jini client service device proxy service service item service id service type attribute set service applet service proxy lookup service upnp control point root device device service device service description universal unique id device service type device service schema presentation url control event url applicable slp user agent service agent service service registration service url service type service attributes template url template url directory service agent optional help compare designs developed general structural model documented uml unified modeling language 
general model provides basis comparative analysis various discovery systems representing major architectural components consistent neutral terminology see column table 
main components general model include service user su service manager sm service cache manager scm scm optional element supported discovery protocols 
components participate discovery information propagation consistency maintenance processes comprise discovery protocols 
sm maintains database service descriptions sds sd encodes essential characteristics particular service device service provider sp 
sd contains identity type attributes characterize sp 
sd provides interfaces application programming interface graphic user interface access service 
su seeks sds maintained sms satisfy specific requirements 
employed scm operates intermediary matching advertised sds sms sd requirements provided sus 
table shows general concepts map specific concepts jini upnp service location protocol slp 
behaviors sus discover maintain consistency desired sds depend partly architecture employed 
alternative architectures service discovery 
broadly speaking system architecture comprises set components connections relationships interactions components 
application represent architecture discovery system architectural model expresses structure components connections relations interfaces messages received components behavior mills nist wosp submission actions taken response messages received including generation new messages consistency conditions boolean relations state variables maintained different components 
initial analysis distinct discovery systems revealed designs underlying architectures party party 
party architectures 
party architecture consists major components sms sus 
service user upnp multicast group unicast links tcp udp service manager fig 
party service discovery architecture deployed topology service users sus service manager sm 
study party architecture arranged simple topology consisting sm sus depicted 
animate architecture chose behaviors discovery information propagation consistency maintenance described specification upnp 
startup su sm engages discovery process locate relevant components network neighborhood 
lazy discovery process sm periodically announces existence sds upnp multicast group send messages source group receivers 
receiving announcements sus matching requirements tcp hypertext transfer protocol transmission control protocol unicast link message exchanges specific parties request directly sm copies sds associated relevant sps 
su stores sd copies local cache 
alternatively su may engage aggressive discovery process su transmits sd requirements queries upnp multicast group 
sm holding sd matching requirements may udp user datagram protocol unicast link respond jitter delay directly su 
upnp sm responds query announces train messages number distinct devices number unique service types managed sm 
appropriate response su uses tcp unicast link request copy relevant sds caching locally 
maintain sd local cache su expects receive periodic announcements relevant sm 
upnp sm announces existence sds specified interval known time live ttl 
announcement specifies ttl value 
su receive announcement sm ttl periodic su succeed time su may discard discovered sd 
selected minimum ttl recommended upnp specification 
see tables summary relevant parameter values 
party architectures 
party architecture consists sms sus scms number scms represents key variable 
study model party architecture sm sus shown 
anticipate failure conditions increasing number scms increase chance successful rendezvous components leading better propagation information updates sms sus 
investigate vary number scms party architectural model 
animate party model chose behaviors described jini specification 
mills nist wosp submission aggressive discovery multicast group service manager service user remote method invocation unicast links optional nd optional scm nd scm lazy discovery multicast group service cache manager fig 
party service discovery architecture deployed node topology service users sus service manager sm service cache manager scm optional nd scm 
jini discovery process focuses discovery sms sus intermediary scms exist network neighborhood 
describe procedures detail simply summarize 
initiation jini component enters aggressive discovery transmits probes aggressive discovery multicast group fixed interval recommended specified period times recommended discovered sufficient number scms 
cessation aggressive discovery component enters lazy discovery listens lazy discovery multicast group announcements sent intervals recommended scms 
party model implements aggressive lazy forms jini multicast discovery 
discovery occurs sm deposits copy sd services discovered scm 
scm caches deposited state specified length time ttl 
maintain sd scm ttl sm refresh sd 
way sm fails scm purge sds deposited sm 
behavior consistent possible models party party architectures selected ttl sd cached scm 
techniques sus sps rendezvous sds registered sms particular scms scms discovery process 
scms match sds provided sms su requirements forward matches sus access appropriate sps 
consistency maintenance service discovery architectures 
initial discovery information propagation sds service discovery protocols provide mechanisms applications ensure changes critical information propagate system 
critical information may concern service availability capacity updates descriptive information regarding service capabilities may necessary su effectively discovered service 
study consider basic consistency maintenance mechanisms polling notification accompanying mechanisms propagate new information 
polling 
polling su periodically sends queries obtain date information sd previously discovered retrieved cached locally 
party architecture su issues query directly sm sd obtained 
study upnp get request mechanism poll sm retrieve sd associated specific url uniform resource locator 
response sm provides sd containing list supported services including relevant attributes 
polling party architecture consists independent processes 
process sm sends request propagate updated sd scm sd originally cached 
second process su polls relevant scms periodically issuing mills nist wosp submission request effectively query set desired sd requirements 
scm replies contains relevant information matching sds 
study adopt second interval polling architectures 
notification 
notification immediately update occurs sm sends events announce sd changed 
receive events sd interest su register purpose 
party architecture su registers directly sm 
model procedure upnp event subscription mechanism su sends subscribe request sm responds accepting subscription denying request 
subscription accepted retained ttl may refreshed subsequent subscribe requests su 
experiment chose ttl event subscriptions architectures 
party architecture su registers scm receive events procedure analogous sm propagate sd 
sd propagation scm event registrations ttl may refreshed 
sd update occurs sm issues request scms originally propagated sd 
scm issues propagate event sus registered receive events sd 
nature import failures 
foregoing discussion oversimplified highlights complexity inherent discovery protocols 
additional complexity arises uncertainty nodes processes links appear disappear warning 
discovery protocols include behavior cope changes 
section address nature various failures arise consider import failures behavior discovery protocols application software depends 
classifying failures 
research focus particularly failures exist hostile environment encountered military emergency response operations 
classify failures general categories communication failures process failures 
communication failures arise due enemy jamming interference due congestion due physical severing cables due improperly configured routing tables due multi path fading node moves terrain 
subdivide communication failures classes interface failures message loss path failures 
communication interface node may fail fully transmit receive partially transmit receive 
outbound messages interface lost transmitter fails inbound messages lost receiver fails 
message loss severe failure implies individual messages may lost sporadically bursts 
path loss appears blocked communication route nodes areas network 
path blocked directions 
process failures caused enemy cyber attacks programming errors hardware failures 
subdivide process failures node thread failures 
catastrophic failure processing node ceases node reinitialize processing resumes 
information maintained node may persist failure information may lost 
nature condition persistent information prove crucial node behavior processing resumes 
course node reappear 
thread failures catastrophic troublesome node failures 
node rely certain long running threads react events nodes 
failure selected threads interfere operation node nodes mills nist wosp submission distributed system 
cases node appear effectively 
failure responses service discovery systems 
service discovery systems responsibilities divided parties lower layer protocols discovery protocols applications 
discovery protocols applications services classes lower layer protocols unreliable unicast protocols unreliable multicast protocols reliable unicast protocols 
unreliable protocols unicast multicast recover signal lost messages source destination learn loss 
multicast protocols exchange messages tree receivers 
reason multicast message received nodes 
failure near multicast source prevents messages received node multicast tree failure near receiver prevents messages received single node multicast tree 
course failures intermediate points multicast tree result messages lost subsets receivers 
unreliable protocols provide guarantees recovery provided mechanisms higher layer 
reliable unicast protocols include mechanisms attempt ensure delivery messages detecting retransmitting lost messages 
course reliability schemes may eventually give retransmissions needed indicate node path failure 
cases reliable unicast protocol signal higher layer message delivered 
ambiguity exist reliable unicast protocols send request response message pairs case discovery systems 
submitting request reliable unicast protocol requesting process wait corresponding response remote process 
example jini remote method invocation rmi tcp invoke method remote object receive response 
similarly upnp uses tcp submit requests receive responses 
cases rmi layer tcp layer signal remote exception rex 
requesting process determine rex caused failure transmit request failure receive response remote process 
responding process information receive rex inbound request fails receive rex outbound response fails 
essence reliable unicast protocols attempt deliver messages face various communication failures ultimately reliability mechanisms prove insufficient causing higher layer process notified failure 
cases higher layer process free determine appropriate failure recovery strategy 

modeling failure recovery strategies service discovery architectures architectural models incorporate classes failure recovery strategies recovery lower layer protocols recovery discovery protocols recovery application software 
class outline strategies see table included models 
recovery lower layer protocols 
models operate types channels unreliable simulating udp multicast unicast forms reliable simulating tcp 
udp simulation discard messages lost due transmission errors discard messages lost due path interface failures 
path failure messages discarded directions 
interface failure discard messages sent node failed transmitter discard messages inbound node failed receiver 
sender receiver learns fate lost messages 
tcp simulation model proves complex 
messages lost transmission errors schedule retransmission roughly round trip time rtt 
increase mills nist wosp submission rtt successive retransmission 
successive retransmissions exceed threshold current study discard message issue rex 
messages lost interface path failure model tcp connection establishment procedures discarding message waiting period uniformly distributed upper lower bound current study signal rex 
discarding request signal rex requester discarding response signal rex parties 
table 
provides summary division recovery responsibilities strategies lower layer protocols discovery protocols application software implemented models party architectures 
responsible party lower layer protocols discovery protocols application software recovery mechanism udp tcp lazy discovery aggressive discovery ignore rex retry rex discard knowledge recovery party architecture upnp issue rex sm announces messages su issues purging sd su get poll sm notification su get discovery retry retries subscribe requests retry su purge sd failure receive sm announcement recovery party architecture jini issue rex scm announces su sm issue probes intervals startup su poll scm notification sm depositing refreshing sd copy scm retry su registering refreshing notification requests scm retry su sm purge scm continuous rex recovery discovery protocols 
discovery protocols include built robustness measures deal possibilities udp message loss node failure 
discovery protocols specify periodic transmission key messages 
example jini requires node engage aggressive discovery startup enter lazy discovery scms periodically announce presence 
similar lazy discovery upnp requires sms periodically announce presence 
specifying aggressive discovery upnp permits sus issue queries time 
compensate different announcement intervals recommended jini upnp chose upnp sus issue queries su sd local cache 
su desired sd related queries cease 
upnp sm announces responds query sends copies message retransmission factor current study recommended upnp compensate possible udp message loss 
jini upnp announcement includes ttl 
receiving nodes cache information announcement ttl expires information purged cache 
way node system eliminates residual information failed unreachable nodes 
models incorporate behaviors 
recovery application software 
discovery nodes communicate reliable channel rex may occur 
response rex left application 
models depending situation implement different strategies ignore rex retry operation period discard knowledge 
retry strategy attempts recover transient failures 
discard strategy occurs repeated failure retry strategy relies discovery mechanisms recover persistent failures 
ignore rex 
cases simply ignore rex 
general models ignore rex received attempting respond request 
su ignore rex received response poll get poll recurs interval 
scm party model sm party model ignores rex received attempting issue notification 
behavior described jini upnp mills nist wosp submission specifications depends reliable lower layer protocols provide robustness notifications 
notifications include sequence numbers allow receiving node determine previous notifications missed 
retry operation 
models retry selected operations face rex 
upnp specification separates operation discovering resource obtaining description resource jini combines operations 
description resource 
reason party model su issue get obtain description 
description arrives model retries get 
unsuccessful attempts su ceases retries sets flag reminding reissue get resource announced 
party model jini contains retry strategy associated attempts register change sd scm 
cases sm retries receiving rex 
similarly su receives rex sm scm response request register notification su retries registration retries occur time bounds sm discards knowledge scm 
discard knowledge 
party party models include possibility application discard knowledge previously discovered nodes 
upnp failure receive announcements sm ttl su discards sm related sds 
implement behavior party model 
jini specification states discovering entity may discard scm communicate 
party model sm su deletes scm receives attempting communicate scm interval 
discarding knowledge sm upnp scm jini operations involving node cease rediscovered lazy discovery jini upnp announcements aggressive discovery upnp queries 

experiment definition metrics focus service discovery architectures protocols propagate changes distributed system 
specifically investigate question alternative service discovery architectures topologies consistency maintenance mechanisms perform deadline interface failure 
address question deploy party party architecture recall figures topology includes sm sus 
party case topologies scm scms 
establish initial conditions exercise topology discovery completes initial information sd propagates sus 
experiment introduce change sd sm establish deadline change propagate sus 
measure number messages exchanged latency required propagate new information different consistency maintenance mechanisms polling notification 
repeat experiment varying percentage interface failure time node increments 
provide details 
combining architectures consistency maintenance mechanisms 
compare change propagation party architectures models combine architectures including relevant behaviors upnp jini protocols different consistency maintenance mechanisms 
party architecture adopt polling notification mechanisms discussed earlier upnp protocol basis 
party architectures scm scm polling notification mechanisms mills nist wosp submission form consistent behaviors defined jini specification 
table depicts combinations 
experiment runs combination time zero introducing particular interface failure rate node 
experiment aims restore consistency changed sd held sm cached copies sd held sus 
tracking consistency 
track consistency models employ property analysis introduced previous 
posit single consistency condition service attributes sd discovered su values attributes sd maintained sm manages sd 
formally sm su sd sd attributes sm managed services sm sd attributes su discovered services implies attributes attributes 
incorporate consistency condition directly models check rapide procedural code 
checks form basis measurements 
table 
experiments compare combinations architecture topology protocol consistency maintenance mechanism 
architectural variant party party party single scm party single scm party dual scm party dual scm protocol basis upnp upnp jini jini jini jini consistency maintenance mechanism polling notification notification registration sm polling service registration scm notification service registration notification registration scm polling service registration scm notification service registration notification registration scm generating interface failures 
set aside interval time complete initial discovery information propagation 
experiments choose time randomly distributed uniform interval introduce change sd sm 
choose time randomly distributed uniform interval node suffer interface failure 
interface failure rate 
activating interface failure choose equal likelihood transmitter receiver fail 
activated failure remains effect duration failure remedied 
table summarizes relevant parameters values experiments 
sample run 
shows partial results sample run party architecture scms notification consistency maintenance mechanism 
run failure occurred lasted 
shows time interface failed recovered 
performance section lists times node loss consistency restoration consistency inconsistency remains 
lists message counts node messages sent restore consistency total messages sent 
sm scm message count includes messages sent su remains inconsistent 
sample run sus scms consistent quickly represents time necessary propagate change sm scm match changed sd registration su notification requests registered scm forward matches 
su receiver failed time heard notification continued inconsistent state remainder run 
run illustrates lack robustness notification mechanism lead prolonged inconsistent states 
mills nist wosp submission table 
values relevant parameters experiments 
behavior architectures upnp specific behavior architecture jini specific behavior architecture interface failure parameters transmission processing delays rate run number parameter polling interval registration ttl time retry rex applicable announce interval query interval su sd probe interval announce interval sm su scm failure incidence failure scope failure duration udp transmission delay tcp transmission delay item processing delay sm interface scm interface scm interface su interface su interface su interface su interface su interface performance sm scm scm su su su su su value ttl expiration times rex run node transmitter receiver equal likelihood increments constant uniform cache items items fig 

console output sample experiment run party architecture scms notification maintain consistency metrics 
data collected experiment runs compute metrics update responsiveness update effectiveness update efficiency 
define 
update responsiveness 
assuming information created particular time propagated deadline difference deadline creation time represents available time propagate information 
update responsiveness measures proportion available time remaining information propagated 
formally deadline wish propagate information service discovery topology 
tc creation time information wish propagate tc tu time information propagated su total number sus service discovery topology 
define change propagation latency su ln tu tc max tu tc 
effectively proportion available time propagate change su numerator represents time su achieved consistency satisfied consistency condition update occurred 
denominator represents time available propagate change 
term max tu accounts cases tu define su rn ln 
rn proportion available time remaining propagating change su update effectiveness 
update effectiveness measures probability change propagate successfully su tu formally assuming definitions related hold represent number runs particular mills nist wosp submission topology observed identical conditions 
recalling total number sus topology define number sus observed identical conditions define probability tu count ri define conditions 
update efficiency 
specific service discovery topology examination available architectures party party consistency maintenance mechanisms polling notification reveals minimum number messages sent propagate change sus 
topology occurs notification propagate information party architecture scm 
update efficiency defined ratio actual number messages observed 
formally number messages sent attempting propagate change sm sus run topology 
define average sum sk 
results discussion section showing results experiments consider relative performance models 
propose reasons performance differences subject analysis verification going research 
rapide examine selected saw tooth behaviors outline suggestions improving adls experiences rapide 
results 
series graphs identical interface failure rate increasing increments ordinates metric ranging plot selected measurements generated models 
graph compares configurations table metrics update responsiveness median update effectiveness update efficiency average 
chose median measure update responsiveness measured data tend clump distinct concentrations 
computed averages proved representative data 
compares update responsiveness party model single scm party model polling notification 
provides similar comparison substitutes results dual scm party model place results scm party model 
figures compare update effectiveness combinations 
figures combinations compare update efficiency 
graphs reporting measures responsiveness effectiveness depict system undergoing phase transition peak performance changes propagate quickly changes fail propagate 
regarding efficiency graphs show system begins best efficiency interfering failures asymptotically approaches zero efficiency failure rate increases 
graphs particularly showing update effectiveness depict form saw tooth behaviors 
analysis visualization tools provided rapide able investigate causes underlying see 
graphs difficult interpret compute summary statistics see table combinations 
summary statistic reflects mean particular metric averaged interface failure rates specified configuration 
indicate uncertainty associated measurements give see table upper lower bounds computed appropriate standard error formula metric associated selected interface failure rates curves 
mills nist wosp submission median update responsiveness update effectiveness average update efficiency party notification party polling party single scm notification party single scm polling interface failure rate party notification party polling party single scm notification party single scm polling interface failure rate median update responsiveness party vs party single scm update effectiveness party vs party single scm party notification party polling party single scm notification scm polling interface failure rate update efficiency party vs party single scm median update responsiveness update effectiveness average update efficiency party notification party polling party dual scm notification party dual scm polling interface failure rate median update responsiveness party vs party dual scm party notification party polling party dual scm notification party dual scm polling interface failure rate update effectiveness party vs party dual scm party notification party polling party dual scm notification party dual scm polling interface failure rate update efficiency party vs party dual scm fig 

graphs comparing combinations architecture topology consistency maintenance mechanism 
mills nist wosp submission table 
summary statistics mean interface failure rates computed curve graphs shown figures 
party notification party polling party notification single scm party polling single scm party notification dual scm party polling dual scm mean interface failure rates median responsiveness effectiveness average efficiency understanding relative performance 
discuss performance results metrics 
reader recognize engineering trade offs exist metrics responsiveness effectiveness efficiency 
responsiveness 
results column table show various combinations architecture behavior exhibit similar responsiveness mean median ranges 
table reports uncertainty results confirms similarity responsiveness 
similarity arises interface failures interfere polling notification requiring nodes rely recovery mechanisms underlying discovery protocols restore consistency 
absence failures notification proves responsive change notices issued interested parties immediately change occurs polling incurs lag time 
presence interface failures complicates situation 
required interface operating notification issued update lost 
second polls fail extended period high interface failure rates polling ceases updates missed 
polling notification mechanisms restoring consistency depends recovery mechanisms discovery protocol 
table 
depicts upper lower bounds computed appropriate statistical techniques metric experiment combinations selected interface failure rates 
party notification party polling party notification single scm party polling single scm party notification dual scm party polling dual scm responsiveness effectiveness 
efficiency recovery mechanisms implemented models exhibit similar responsiveness rediscovery lost nodes occur restoration failed interface 
party case periodic announcements scm lazy discovery procedures ensure rediscovery 
similarly party model periodic queries su aggressive discovery procedures ensure rediscovery 
way restoration failed interface leads rediscovery lost nodes process restoration consistency cached copies sds 
interface failure rate increases rediscovery machinery tends dominate responsiveness results see discussion recovery mechanisms 
effectiveness 
results second column table show certain combinations lead better update effectiveness table suggests differences significant 
differences effectiveness may partly attributed architecture topology 
example sd copy propagate link party case links party case 
reason party architecture single scm prove vulnerable interface failures links operational 
suggests party mills nist wosp submission architecture effective severe interface failures results support 
hand party architecture allows replication scms provides greater number paths information propagate 
suggests results agree party architecture dual scm provide superior effectiveness single scm party architecture 
results indicate dual scm architecture yields effectiveness close party architecture 
imagine adding scms improve effectiveness party architecture increasing path redundancy topology 
lacking flexibility party architecture appears unable improve effectiveness interface failure 
differences effectiveness may attributed part consistency maintenance mechanism 
general polling mechanism lead better effectiveness notification mechanism 
polling built robustness associated periodic issuing poll requests 
contrary party architectures notification issued action sender response rex recall table 
results support analysis party architecture party architecture single scm 
example effectiveness party notification suffers situations notice lost sm lost announcements occur interface failure restored announcement 
situations rediscovery occur change propagated see 
counter general trend results suggest notification effective polling party architecture dual scm 
suspect combination factors 
dual scm topology increased number paths information propagate 
factor improve effectiveness polling notification mechanisms 
slight edge accrues notification mechanism scm su link needs functioning change propagate case polling su scm link operational 
model somewhat misleading notification real system uses tcp requires path operational directions connection established 
efficiency 
combination architecture topology expect notification efficient polling 
expect party architecture efficient party architecture single scm topology efficient dual scm topology 
general results table support expectations twists 
party single scm architecture notification mechanism proves efficient party architectures jini sd arrives notification upnp notifications indicate change occurred requiring su exchange request response message pair obtain updated sd 
twist arises notification mechanisms need recover associated refreshing remote resources 
architectures notification su periodically refresh notification requests deposited sm party case scm case 
interface failures lead refresh attempts 
rex invokes retry procedures continuous rex party case sm purged party case 
investigating saw tooth phenomena 
number curves shown figures exhibit saw tooth phenomena pronounced update effectiveness particularly party architecture notification 
uncertainty calculations suggest failure rates spikes may attributed random variations mills nist wosp submission reduced increasing number runs failure rate currently corresponding number data points currently sus runs 
hand spikes lower failure rates appear due causal behavior models 
example party architecture notification exhibits significant dip rate 
visualization analysis tools included rapide examined partially ordered sets events posets contain complete causal behavior model 
posets revealed interface failure rate large number notifications lost sm transmitter causing notifications sus lost su receivers causing lost notifications individual sus 
recovery notification loss depends su discarding sm rediscovering sm retrieving related sds 
su discards sm fails receive announcement sm specified time 
unfortunately cases failed interface led notification losses repaired prior sm announcement announcements come 
cases su purge sm rediscovery 
rediscovery mechanism restore consistency 
cases lost notifications led inconsistencies persisted deadline 
behavior appear notification party architecture 
party architecture requires sm propagate change scm 
scm propagates change sus requested notification 
notification scm su unprotected failure sm retries change propagation scm 
scm transmitter leads failure propagate notifications sus failure confirm change propagated sm 
absent confirmation sm retries change time scm transmitter restored 
repeated change propagates scm causes notifications sent relevant sus 
scm transmitter failures conclude robustness change propagation sm scm compensates lack robustness notifications scm su 
equivalent serendipity occurs party architecture 
cases suggest relationships timing scope failures role recovery mechanisms different architectures 
role recovery mechanisms 
hostile conditions experiments recovery mechanisms play key role consistency maintenance 
example detailed analysis results party architectural model show failure rate interface failures tend restored frequently rex retry period associated get requests application recovery contributes substantially update effectiveness 
failure rate application recovery tends exhaust allotted time leading su discard knowledge sm 
cases update effectiveness depends primarily robustness mechanisms built discovery protocol 
observations led design additional experiments assess trade update effectiveness efficiency various recovery mechanisms 
report findings 
recommendations improving adls 
rapide adl provided useful abstractions represent analyze structure behavior service discovery protocols failure recommend improvements apply generally adls 
study reinforces previous recommendations component states selectively allow data extraction recording analysis 
export mechanism assist implementing techniques evaluate consistency conditions involve state components consider time important considerations analyzing mills nist wosp submission component interactions 
note adls include constraint analysis engines consider time 
second adls especially tools provide representations behavior evaluated efficiently 
example bound poset size study forced substitute procedure calls place rapide constraint evaluation 
third find convenient adl tools supported statistical techniques available commercial simulation systems 
example adl tools include mechanisms track summarize statistics selected state variables 
adls include machinery apply statistical tests selected variables experiment runs order automate halting decisions 
expect develop additional recommendations proceeds 

envision general directions 
intend complete characterization performance various combinations architecture topology behavior failures 
model effects message loss appear differ significantly described study assess ramification node failure discovery recovery mechanisms various architectures topologies 
second plan propose model evaluate selected changes improve performance discovery architectures protocols response failure 
goal increase fault tolerance systems 
intend implement evaluate promising suggested changes publicly available service discovery software 
third expand generic structural model service discovery architectures include message exchanges consistency conditions 
intend publish model 
different dimension hope improve methodologies available design engineer distributed software systems 
part goal provide valuable recommendations improve adls associated tools 
see need opportunity develop adl analysis tools especially designed understanding collective behavior multi party distributed systems 
publicly available specifications come implementations 
hope demonstrate architectural models help better understand properties distributed systems 

emerging service discovery protocols provide foundation software components discover organize system adapt changes system topology 
suitable small scale commercial applications questions remain regarding performance protocols large scale periods high volatility exist military emergency response applications 
architectural models characterize performance selected combinations system topology consistency maintenance mechanism catastrophic communication failure 
behavioral analysis investigate causes underlying observed performance 
initial investigations show significant differences update effectiveness obtained varying aspects design architecture topology consistency maintenance mechanism recovery strategies 
results suggest relationships interface failure rate failure timing recovery strategies 
plan additional experiments investigate trade offs effectiveness efficiency various recovery strategies party party architecture 
mills nist wosp submission 
bieber carpenter service oriented component architecture self forming self healing network centric systems www org web site 
salutation architecture specification version salutation consortium june 
universal plug play device architecture version microsoft june 
ken arnold jini specification addison wesley 
latest version available sun 
specification home audio video interoperability havi havi may 
service location protocol version internet engineering task force ietf rfc june 
specification bluetooth system core volume version bluetooth sig february 
miller pascoe mapping salutation architecture apis bluetooth service discovery layer version bluetooth sig white july 
bettstetter comparison service discovery protocols implementation service location protocol proceedings sixth open european summer school innovative internet applications twente netherlands september 
richard service advertisement discovery enabling universal device cooperation ieee internet computing september october pp 

pascoe salutation architectures newly defined service discovery protocols microsoft sun salutation architecture stack salutation consortium whitepaper june 
upnp jini salutation look popular coordination framework network devices technical report california software lab 
available online www com tech upnp html 
luckham rapide language toolset simulation distributed systems partial ordering events anna stanford edu rapide august 
mills analyzing properties behavior service discovery protocols architecture approach proceedings working conference complex dynamic systems architecture brisbane australia december 

