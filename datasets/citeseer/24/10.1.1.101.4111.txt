distributed programming erlang computer science laboratory telecommunications systems laboratory box sweden construction computer systems consisting computer common 
complexity systems higher single computer systems 
addresses question simplify construction large concurrent distributed systems 
augmented functional concurrent programming language erlang constructs distributed programming 
distributed programs written erlang typically combine techniques symbolic functional programming techniques distributed programming 
contrast traditional imperative languages erlang need interface description languages specify format interprocessor messages heterogeneous network 
considerably simpli es distributed programming 
distributed erlang currently employed number large software projects ericsson group 
keywords distributed programming concurrency symbolic programming programming languages fault tolerance real time systems erlang functional concurrent programming language designed construction large concurrent programs 
erlang typeless sense traditional logic languages uses pattern matching variable binding function selection explicit mechanisms create concurrent processes advanced facilities error detection recovery 
non distributed erlang described 
cient implementation non distributed erlang described 
construction large distributed fault tolerant concurrent real time system extremely complex task 
programs control telephony network typically consist millions lines source email ericsson se jointly owned ericsson ab code 
systems consists cooperating cpus 
claim languages program systems support concurrency support distributed processing 
describes mechanisms supporting distributed programming added erlang language 
small set operations variety implement di erent known distributed programming mechanisms 
include measurements speed system indicates quality implementation 
distributed erlang experimental system 
currently number product projects ericsson 
interesting prototype project reported implementation intelligent networks development system 
distributed international symposium parallel symbolic computation erlang implemented loosely coupled system computers communicating tcp ip connections 
shared resources completely autonomous 
number languages support distributed programming 
distributed imperative languages orca concurrent inter process communication interfaces compile time 
show advantage having specify interfaces compile time 
considerably easier implement distributed applications erlang languages due high level abstraction erlang code 
extensions concurrent logic languages support programming loosely coupled systems 
system similarities distributed erlang 
distributed programming perspective main di erence unit concurrency concurrent logic languages goal clause 
loosely coupled system appropriate goals clause evaluated parallel di erent nodes due overhead associated network 
circumvent language de nes additional unit concurrency called grain grain set predicates 
erlang unit concurrency unit distribution process 
process identi ed name providing homogeneous view programmer 
non distributed erlang give brief non distributed erlang 
object constant atom oat process identi er integer compound term variable 
variables upper case letter denotes anonymous variable 
erlang allow destructive assignment variables bound pattern matching operator explicit pattern matching example function clause head 
erlang terms ground 
erlang logical variables 
compound terms tuples lists 
tuple size having atoms elements 
list empty list pair 
construction syntactic sugar pair 
function consist clauses clause selection done means pattern matching 
example compute length list len len len 
erlang syntax conditional expressions described 
functions de ned module le compiled module item loaded system 
function len de ned module foo syntax foo len call function outside module 
erlang explicit mechanisms create new processes 
built function bif spawn mod fun arg arg arg create new process 
process initially run function fun de ned module mod arguments supplied 
bif returns process identi er pid builtin data type 
pid send message process syntax pid message message erlang term 
recipient receive messages syntax receive pattern guard action pattern guard action 
time action process executes receive expression process suspended message arrives matches patterns pattern pattern time milliseconds elapsed 
message accepted optional guard evaluate true 
guards described 
message arrives match patterns receive expression message bu ered mailbox 
messages asynchronous 
processes name bif register name pid 
process registered name processes may send messages process international symposium parallel symbolic computation syntax name message 
name atom 
obtain pid registered process bif name 
bif self acquire pid 
bif typically server 
message server usually contains pid server knows send reply 
bif exit reason terminate current process 
termination abnormal reason bound atom normal 
applications require error recovery event unplanned failure erlang provides explicit error detection capabilities 
erlang processes linked means bif link pid 
links bi directional 
abnormal termination process run time error exit signal sent processes currently linked terminating process 
default action process receives exit signal terminate continue propagate exit signal 
process choose trap exit signal transformed normal messages bif process flag flag value 
function creates new process monitors process restarts process terminates 
keep alive mod fun args process flag trap exit true pid spawn mod fun args link pid receive exit pid keep alive mod fun args 
function returns 
error detection mechanisms provided primitive catch 
expression catch expression returns normally expression contains illegal statements 
example expression foo terminates process evaluating expression expression catch foo evaluates normally tuple exit 
erlang provide higher order functions bif apply mod fun available meta programming 
bif evaluates function fun dened module mod supplies arguments function 
distributed erlang augmented erlang language constructs distributed programming 
basically done small set new 
number typical models distributed computing implemented aid new erlang standard libraries 
includes example remote procedure call rpc di erent broadcast algorithms global name server asynchronous rpc isis named process groups multicasting multi node dictionaries load distribution package parallel evaluator shared data structures section give shortened implementations 
new follows spawn node mod fun 
creates new process executing remote node node node running erlang system 
node link node 
sets unidirectional link node node 
non existent exit signal sent process executing bif 
node unlink node 
removes link node node 
name node mess 
sends asynchronously message mess process registered name node 
node 
returns node identi er globally unique atom 
nodes 
returns list nodes currently connected 
disconnect node node 
removes connection node 
alive name port setup 
non distributed system networked node 
involves starting right network drivers announcing name system network 
number example link take pids arguments 
modi ed transparently pid local remote 
international symposium parallel symbolic computation erlang system networked node evaluating bif alive 
done system communicate erlang nodes 
connection node setup rst time name node distribution bif 
connection set remains active explicitly removed call bif disconnect node remote node fails 
distributed erlang loosely coupled system nodes may come go dynamically 
node completely autonomous entity nodes interact creating new processes sending messages 
generic concurrent rpc known programming techniques distributed systems rpc 
technique evaluate function remote node 
code implement generic rpc service erlang consists server process run nodes client function send rpc request right server evaluation module rpc 
export start loop reply call 
call node node link node rpc node self apply receive rpc node unlink node exit node reason exit reason 
server code perform actual rpc 
server creates new process request 
start register rpc spawn rpc loop 
loop receive cli apply spawn rpc reply cli loop 
reply client client rpc catch apply 
code fragment appends lists node node 
ee rr tt rpc call node lists append example may wish nd pid registered process init node rpc call node erlang init de ned reside module erlang way call bif rpc 
note server rpc spawns new process request 
means rpc server concurrently execute rpcs 
type server referred concurrent server opposed iterative server processes requests time order arrive 
major advantage concurrent server individual request hangs server continues operate correctly 
note node link 
encapsulated matching pair node link node unlink 
guaranteed call rpc call terminates normally returning computed result exit reason computational error occurred 
exits process call remote node fails 
promises rpcs synchronous 
means caller suspended computation terminates 
main disadvantage rpcs wait answer mayhave better wait 
promises suggested 
promises asynchronous variant remote procedure calls promise place holder return value rpc 
overcomes international symposium parallel symbolic computation disadvantages stem synchronous nature rpc 
caller perform rpc time try claim computed value ready 
implemented follows module promise 
export call yield nb yield call 
call node spawn promise call self node 
call rpc call self promise reply 
yield key receive key promise reply 
call handled local process performs rpc 
process identi er process returned key subsequent blocking yield operation 
example nicely demonstrates power selective receive 
non blocking version yield written nb yield key receive key promise reply value timed 
function merely checks message mailbox matching expression key promise reply returns atom timed 
parallel evaluation su cient tools write parallel evaluator 
function evaluates list module fun args tuples parallel nodes parallel eval nodes nodes keys map nodes nodes nodes lists map promise yield keys 
map nodes map nodes orig round map nodes orig orig map nodes tail node orig promise call node map nodes tail orig 
asynchronous variant rpc module promise generate list promises acting place holder desired value traverse list yielding values standard map function 
second clause map nodes entered run nodes goals available nodes 
interesting note behavior list keys 
list keys try yield elements 
calls yield suspends ect evaluation remaining elements list 
continue evaluate results collected suspended call yield returns 
algorithm places jobs di erent nodes prede ned order 
algorithm take account di erent functions expensive 
nodes may get lot nodes get 
known static load distribution 
want implement dynamic load distribution bif statistics run queue returns number processes scheduled run 
showed ective way predicting load node 
pseudo server give implementation server 
standard way speci service erlang system hide service server server register name service clients access server name 
example standard erlang libraries windows 
implemented server registered name 
processes wish graphics calling functions international symposium parallel symbolic computation send messages server 
run erlang host windows example telephone switching system want graphics applications host function start node name id spawn pseudo relay node name register name id 
relay node name rpc call node erlang name link loop 
loop receive loop 
know node node supports graphics programming server expression pseudo start node bring service node support 
pseudo server relays messages real server resides node 
allows server execute remote node clients aware 
advantage code written single node system access server running remotely locally 
standard erlang le system accessed single registered server technique provide service les nodes disc 
implementation erlang code executed machines representing particular implementation language 
machine described 
section describe implementation distribution aspects language 
unix erlang node executes unix process internally containing erlang processes 
implementation distribution split parts part runtime system part network dependent 
network dependent part called linked driver driver easily replaceable want run distributed erlang top di erent network media 
driver responsible setting connections remote nodes monitoring connections reading writing bu ers bytes channels currently driver tcp ip implemented 

depicts architecture 
tcp ip tcp ip tcp ip driver driver erlang node unix process erlang node unix process architecture external representation key implementation observation erlang symbolic programming systems data objects identi able runtime 
erlang data objects internally tagged type 
example integer erlang represented bit word bits set special value reserved integers remaining bits holding actual integer value tuple represented tagged tag integer value integer representation pointer word holding value element tuple 
possible de ne generic format external data representation term encoded term decoded 
de ned concept linked drivers erlang way link type software kernel runtime system 
device driver unix allows di erent con gurations systems di erent hardware 
driver communicates runtime system structure function pointers 
special driver designated distribution driver 
international symposium parallel symbolic computation mapping erlang term external representation send message runtime system discovers recipient resides remote node applies function message order pack message bu er sends 
runtime system receiving side applies function reconstruct original term 
alternative usage machine independent external representation terms send terms internally represented memory 
may slightly faster 
external representation achieve interoperability di erent implementations erlang di erent hardware platforms 
write distributed applications run heterogeneous environments 
simple idea applicable programming systems ability identify type data object runtime 
atom cache real life applications large fraction data inside messages atoms 
typical distributed applications measured objects inter node messages atoms 
atoms internally represented tag index atom table 
encode atom just send index textual representation atom 
done identical atom tables nodes 
requires nodes statically rooted master node employ complex protocol maintain atom tables identical 
solutions unattractive 
implementation distributed erlang node maintains cache connection remote node 
cache slots 
atom encoded sent away cache associated node recipient consulted 
atom cache index cache sent atom atom inserted cache possibly overwriting old value atom entirety newly acquired cache index sent 
receiving node insert atom cache 
measurements cache hit ratio distributed telephony systems applications indicate hit ratio 
means atoms sent remote node externally represented single byte index cache 
means receiving side need calculate hash value atom order insert atom system atom table 
idea applicable programming systems 
code management able easily load code runtime system network 
implemented builtin datatype called binary language 
binary data object merely represents piece untyped memory 
order load module rst obtain object code module binary object bin 
call code loading bif bin parameter 
wish load object code remote node simply rpc load object code remotely 
separating obtaining object code loading implement dynamic code management systems erlang 
distributed applications distributed system typically want produced go back tothe node original call 
want produced application connected node application started 
solved erlang process groups 
process process group leader produced sent leader 
new processes created new process group leader spawning process organizing processes tree 
er lang system entirely implemented erlang system rewritten accommodate process groups 
security matter addressed security user authentication 
node assigned secret string international symposium parallel symbolic computation magic cookie 
order node say communicate node know magic cookie 
message sends patched atom atom believes cookie 
message arrives node wrong magic cookie runtime system ensures message process responsible unauthorized messages 
matter obtaining nodes cookies local issue 
case unix implementation reads string le home erlang cookie sets cookie string le 
nodes running unix user id communicate aware authentication schema 
authentication schema easily adapted conjunction authentication schema local operating system 
magic cookie atom probably atom cache authentication costs virtually 
miscellaneous common constructs logic functional programming languages missing erlang example logical variables higher order functions 
implementation distribution simpler 
node autonomous logical variables network messages copied nodes 
means local garbage collection 
algorithms distributed garbage collection proposed example 
proposed algorithms appropriate type fault tolerant soft real time systems erlang intended 
distributed erlang implemented number di erent computer systems including versions unix vxworks qnx windows nt allowing transparent communication applications running systems 
discussion processes erlang primarily intended act abstraction aid system designer map real world problem software architecture 
similar argument applied nodes erlang 
concern provide abstractions aid design systems inherently distributed 
networking expensive loosely coupled lan system distributed algorithms try minimize network tra system design complex 
example takes considerably longer time spawn process remote node local node 
process spawns remote process suspended time takes spawn request traverse network time new process identi er travel back 
time signi cant depends speed quality load network 
number nodes attached ethernet lan signi cant di erence time creation local process remote process 
goes local versus remote server calls 
table indicating cpu time realtime create local remote processes shows local spawn remote spawn cpu time real time table process creation times takes times longer real time create remote process local process 
spend times local cpu time create 
bear mind designing distributed application goals distributed computing application reliable faster 
examine rpc facility section 
worth noting specify interface rpc server 
traditional rpc systems usually interface description language involved 
example language sun microsystems rpc language 
languages primarily exist wishes rpc server separate document code interface speci cation generate stub routines times milli seconds test run sun sparc workstations 
times include time run terminate process 
international symposium parallel symbolic computation marshal arguments function 
erlang need description generate stub routines erlang data structures self identifying 
example pseudo server possible implement interface server de ned compile time 
example inconvenient specify interfaces wish move large data structure node 
example assume wish bring node 
want transfer entire data base standby node 
erlang just send data base entirety single send operation 
leads dynamic systems interfaces services available remote nodes changed running system 
erlang programmer concentrate specifying important logical interfaces system having concerned physical interfaces lower level protocols computers 
performance distributed erlang industrial applications performance paramount importance 
tradeo reliability speed 
message passing completely reliable tcp transport medium opposed udp 
wehave measured speed rpc application compared rpc facility sunos 
measured time single rpc 
function call function simply returns argument argument structure tuple containing integer short strings 
structure de ned struct int char corresponding erlang data structure int atom atom atom get gures running sun 
gures milli seconds line table erlang server call time call function sends message server integer tuple sun rpc erlang rpc erlang server call table rpc execution times server call function return message sender 
functionality close sunos rpc 
functionality erlang rpc higher sunos rpc completely generic 
see rpc erlang slower sunos rpc merely send integer send structure argument rpc faster sunos rpc turn atom cache mechanism gures table see atom cache integer tuple erlang rpc erlang server call table rpc execution times atom cache gives considerable speedup 
worth mention additional time get atom cache turned wasted execution time cpu opposed idle time waiting response messages test single ethernet frame 
currently experimenting di erent models process migration 
plan ability multiple network drivers 
possible node act router example telephony network lan 
aim provide industrial programming environment construction distributed actual code perform test consists lines code lines interface speci cation code erlang code run test consists lines code 
international symposium parallel symbolic computation systems easier 
believe distributed erlang precisely 
small number concepts including creation new processes asynchronous message passing links provide easy understand semantics 
especially constructing large systems paramount importance de ned easy understand bottom level mechanisms 
unit distribution process unit concurrency 
important construct transparent distributed systems 
showed construct completely generic rpc 
interface description language necessary 
possible implement dynamic systems need interface descriptions 
claim increased level abstraction distributed erlang programs considerably easier design construct large cient distributed systems 
acknowledgments wewould rstly original creators erlang joe armstrong robert virding mike williams 
goes invaluable advice comments tcp ip part implementation 
armstrong williams virding concurrent programming erlang prentice hall bal programming distributed systems prentice hall 
implementing remote procedure calls acm trans 
comp 
syst 
vol 

birman cooper marzullo kane schmuck wood isis system manual cornell university diaz rubio implementation issues distributed real time logic language international conference logic programming workshop integration deductive paradigms 
foster parallel implementation parlog proc 
int 
conf 
parallel processing vol 
ii pp st charles il 
gehani concurrent programming language prentice hall 
hausman turbo erlang approaching speed implementations logic programming systems ed 
tick 
kluwer 
kunz uence di erent workload descriptions heuristic load balancing scheme 
ieee trans 
software eng vol 
july pp 
meer prototype demonstrating user mobility flexible service pro les 
ericsson review 

ladin liskov garbage collection distributed heap th international conference distributed system yokohama japan 
liskov linguistic support cient asynchronous calls distributed systems proceedings sigplan 
sunos manual vol 
sun microsystems 
