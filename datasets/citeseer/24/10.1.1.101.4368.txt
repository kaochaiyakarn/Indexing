computing informatics vol 
sep logic tla stephan merz inria lorraine loria nancy mail stephan merz loria fr 
tla language intended high level specification reactive distributed particular asynchronous systems 
combining linear time temporal logic tla classical set theory provides expressive specification formalism supports assertional verification 
taste tla specification language tla introduced leslie lamport description reactive distributed especially asynchronous systems 
describe semantical base tla combines lineartime temporal logic tla zermelo fr set theory 
intention define new extended formalism explain tla practice 
lamport original covers material 
particular book includes tutorial writing specifications tla formally defines language tla describes tools support 
contrast presentation tla emphasizes mathematical machinery underlying tla explaining lamport choices logical perspective 
hope find purposes comparing specification formalisms constructing new tools support system development tla exploring semantics tla look simple example introduces typical structure tla specification 
tla module shown describes unbounded fifo queue illustrated 
external interface consists input channel output channel 
internally fifo maintains queue values received sent 
module consists sections separated horizontal bars better readability contain declarations definitions assertions 
structure module conventional mandatory formally module simply list merz pictorial representation 
module extends sequences constant message variables init enq deq vars choose message append head tail message enq deq init vars deq theorem seq message deq vars message tla specification internal behavior exposed 
module constant message variables internal fifo instance internal tla interface specification 
fig 

fifo queue synchronous communication 
logic tla statements 
identifier declared defined exactly possibly imported module 
section declares standard tla module sequences defines finite sequences associated operations 
find declaration module parameters 
constant parameter message intuitively represents set messages sent fifo queue 
variable parameters represent current state queue shown values change messages received forwarded 
second section contains list definitions constitute main body specification 
constant defined equal value element set message section explains definition sensible 
state predicate init identifies legal initial states specification value empty sequence equal value 
value formula enq characterizes state transitions correspond enqueue action require different current value queue recognize input channel changed 
condition essential introduced mainly expository purposes 
implementation example instantiate parameter message set pairs consisting underlying data extra bit serves distinguish successive enqueue actions data 
value variable state transition denoted new value obtained appending value contains transition 
stipulate output channel change enqueue action definition dequeue action deq similar 
action defined disjunction enqueue actions enq message dequeue action deq 
main definition module temporal formula representing internal specification fifo queue 
written conjunction conjunct init asserts state behavior satisfying respect initial condition 
second conjunct specifies state relation queue 
precisely asserts transition allowed respect formula leave expression vars unchanged defined tuple containing state variables interest 
value tuple unchanged components unchanged formula admits stuttering steps affect variables interest 
larger system contains fifo queue component steps may represent actions different components 
final conjunct formula asserts condition weak fairness concerning action deq 
rules behaviors state onward deq action enabled occurs 
section explores detail temporal formula standard tla notation displays multi line conjunctions disjunctions list connective 
layout long formulas easier read reduces number parentheses 
merz logic tla underlies tla discusses fundamental concept stuttering invariance 
third section module asserts theorem claims formula shown follows definitions 
general module may state assumptions constants theorems follow definitions stated imported assumptions 
loose reading assertion theorem module regarded merely comment highlights specifier intuitions 
formally theorem represents proof obligation discharged module correct turn proof rules verification section 
theorem asserted module states behavior satisfies formula properties state value variable finite sequence elements contained message deq step changes value output channel message appears input channel eventually output 
current version tla described contain language writing proofs lamport advocates hierarchical proof notation 
hol logical specification languages tla declarative names formulas init formally irrelevant practice meaningful 
meaning formula uniquely compositionally determined meaning subformulas main subject 
logic logically equivalent ways express specification 
example replaced definitions enq enq message append enq deq changing meaning formula tla hide complexity system built data types see section value just set 
similarly presuppose fixed system model shared variable message passing concurrency synchronous asynchronous communication expressiveness comes set theory mechanism definitional extension 
example chosen internal variable change time interface variables representing synchronous style communication 
specification fifo queue asynchronous communication channels lamport book ch 

specifications module describe behavior fifo queue terms variables important principle writing specifications information hiding requires component logic tla specification reveal internal structure implementation details component 
example variable implementation detail illustrated box behavior externally visible variables constrained queue specification 
module shown contains interface specification fifo queue previous specification 
fact declares variable parameters 
line instantiates previously discussed module operator op defined module referenced internal op module 
general form instantiation tla allows substitution expressions module parameters remaining parameters implicitly instantiated identifier name valid point instantiation error identifier declared defined 
case parameters message module instantiated corresponding parameters module parameter instantiated local parameter operator internal 
module defines formula fifo representing interface specification fifo queue formula obtained internal existential quantification formula satisfied behavior take values described internal specification may take arbitrary values 
precise semantics defined section respect existential quantification represents hiding internal state components formula fifo specifies interface fifo queue 
tla temporal logic actions tla combines tla temporal logic actions mathematical set theory 
semantics tla sections explore verification temporal formulas specification data structures set theory 
emphasize exposition aimed precise definition tla logical language attempt explain tla specify algorithms systems 
rationale logic time origins philosophy linguistics intended formalize temporal natural language 
pnueli recognized logics useful basis semantics computer programs 
particular traditional formalisms pre post conditions ill suited description reactive systems continuously interacting environment necessarily intended terminate 
temporal logic came called computer science offered elegant framework describe safety liveness properties reactive systems 
different dialects temporal logic merz distinguished properties assumed underlying model time discrete dense connectives offered refer different moments time vs past 
computer science applications controversial distinction linear time branching time logics 
linear time view system identified set executions modeled infinite sequences states branching time view considers branching structure system 
linear time temporal logics including tla suffice formulate correctness properties hold runs system branching time temporal logics express possibility properties existence path reachable state reset state 
discussion relative merits deficiencies kinds temporal logics scope see vardi contribution subject earlier papers 
despite initial enthusiasm usefulness temporal logic language describe individual system properties attempts write complete system specifications temporal logic revealed component simple fifo queue unambiguously specified 
observation led researchers propose reactive systems modeled variant state machines temporal logic retained high level language describe correctness properties 
major breakthrough came insight temporal logic properties decidable finite state models model checking techniques nowadays routine debugging hardware circuits communication protocols 
weakness standard temporal logic apparent attempts compare specifications system written different levels abstraction 
specifically atomic system actions usually described nextstate operator grain atomicity typically changes refinement complicating comparisons specifications 
example want refine specification fifo queue operation appending element queue described sequence elementary assignments 
tla designed formalism system specifications properties expressed language refinement reduced elementary logic 
problems mentioned addressed ways internal specifications written defining initial conditions state relations resembling description state machines augmented liveness fairness conditions 
abstractness sense information hiding ensured quantification state variables 
refinement problem solved systematically allowing stuttering steps change values state variables interest implementation allowed refine high level stuttering lower level state changes 
similar ideas back refinement calculus versions abrial method 
order prevent infinite stuttering formalisms require side conditions expressed terms founded orderings 
temporal logic logic tla state requirements abstractly terms high level fairness conditions preserved refinement combination fairness conditions arguments founded orderings 
concepts tla provides unified logical language express system specifications properties 
single set logical rules system verification proving refinement 
transition formulas language tla tiered base tier contains formulas describe states state transitions top tier consists temporal formulas evaluated infinite sequences states 
section define syntax semantics transition formulas sections consider temporal formulas 
transition formulas just ordinary untyped firstorder predicate logic section quite brief 
assume signature order predicate logic consisting denumerable sets lf lp function predicate symbols symbol equipped arity denumerable set variables partitioned denumerable sets vf vr flexible rigid variables 
sets disjoint variable form vf denote set vf primed flexible variables union vf primed unprimed variable symbols 
transition functions transition predicates called actions terms formulas built symbols lf lp variables 
example ternary function symbol unary predicate symbol vr vf term defined transition function formula defined action 
omit formal inductive definition syntax transition functions formulas 
collectively term transition formula refer transition functions predicates 
semantics transition formulas unsurprising 
firstorder interpretation defines universe values interprets symbol lf function symbol lp relation appropriate arities 
preparation semantics temporal formulas distinguish valuations flexible rigid variables 
state mapping flexible variables vf values universe 
states valuation rigid variables vr define valuation variables mapping vr vf vf 
semantics transition function transition formula written simply standard predicate logic semantics respect extended valuation 
merz say transition predicate valid interpretation iff true states valuations 
satisfiable iff true 
similarly valid satisfiable class interpretations iff valid satisfiable interpretations notions free bound variables transition formula defined usual notion substitution transition function variable written 
assume capture free variables substitution avoided implicit renaming bound variables 
example set free variables transition function shown bound variable action emphasize level transition formulas consider distinct unrelated variables 
state formulas transition formulas contain free primed flexible variables 
example action state predicate 
semantics state formulas depends single state simply write state formula 
subclass constant formulas restrictive free occurrences rigid variables allowed consequently semantics depends valuation 
arguably rigid formulas appropriate name class tla literature consistently uses designation constant formulas 
tla introduces specific abbreviations level transition formulas 
state formula transition formula obtained replacing free occurrence flexible variable primed counterpart bound variables renamed necessary 
example state formula may build formula substituting bound results formula renaming bound variable 
action state formula enabled obtained existential quantification primed flexible variables occur free enabled holds holds state action may occur state actions action defined list flexible variables occurs free occurs free corresponding list fresh variables 
follows holds iff hold state abbreviations defined terms quantification substitution interplay quite delicate 
example enabled definition just state predicate enabled equals hand enabled constant formula contain rigid variables enabled valid iff satisfiable 
action state function write denote 
requires hold changes value transition dual formula strengthens requiring changes value holds true 
logic tla temporal formulas turn temporal tier tla 
familiar order predicate logic wish give precise definitions devote space presentation 
temporal formulas writes tla specifications usually follow standard idiom typical specification consist definitions transition level 
temporal formulas tla inductively defined follows state formula formula 
boolean combinations connectives including formulas formulas 
formula 
action state function square sub formula 
formula rigid variable formula 
formula flexible variable formula 
particular action temporal formula form actions occur subformulas determine free bound variables temporal level distinguish primed unprimed occurrences flexible variables quantifier binds kinds occurrences 
formally set free variables temporal formula subset vf vr 
free occurrences variables state formula considered temporal formula precisely free occurrences considered transition formula 
variable vf free occurrence iff free occurence similarly substitution state function flexible variable substitutes action subformulas renaming bound variables necessary 
example substitution state function lf vf temporal formula results formula renaming bound variable state formulas contain free occurrences primed flexible variables definitions substitutions transition formulas temporal formulas agree state formulas 
substitution proper transition function variable allowed result expression formed tla formula 
merz semantics temporal formulas defined terms behaviors infinite sequences states valuations rigid variables 
behavior write refer state si denote suffix 
inductive definition assigns truth value formula state formulas evaluated initial state behavior 
semantics boolean operators usual 
iff usual clause linear time temporal logic 
iff formula holds iff state transition leave unchanged satisfies iff valuation vr usual definition predicate logic 
semantics formulas defined section 
abbreviations temporal formulas include universal quantifiers rigid flexible variables 
formula eventually defined asserts holds suffix behavior similarly eventually angle sub defined asserts transition satisfies changes value write leads formula asserts occurrence eventually followed occurrence combinations eventually operators express infinitely 
observe formula infinitely true infinitely false strictly stronger infinitely 
combinations especially important building blocks formulate fairness conditions 
particular weak strong fairness action defined wft enabled enabled enabled enabled weak fairness stipulates action occurs infinitely behavior enabled strong fairness requires action happen infinitely infinitely necessarily persistently enabled 
stuttering invariance quantification formulas allow stuttering state transitions satisfy admit transitions change state function particular duplications states observed formulas form 
stuttering invariance important connection refinement composition 
logic tla formalize notion set flexible variables define states equivalent written iff define equivalence written smallest equivalence relation behaviors contains finite sequence states infinite sequence states equivalent states intuitively stuttering equivalence allows duplication deletion finite repetitions equivalent states 
particular relation vf write identifies behaviors differ duplications deletions identical states 
fundamental theorem asserting tla expressive distinguish stuttering equivalent behaviors formally stated follows theorem stuttering invariance 
assume tla formula free flexible variables stuttering equivalent behaviors valuation 

tla formulas quantification flexible variables hard prove theorem semantic clauses section induction structure formulas 
hand quantification flexible variables requires attention obvious semantic clause formulas read iff behavior states agree corresponding states variables definition preserve stuttering invariance 
example consider formula requires variables initially equal constant eventually different different changes value 
behavior satisfies contain distinct transitions changes value preserving value second transition changes indicated picture 
particular equal definition quantification implies equal behavior satisfying formula behavior obtained removing second state equals equals stuttering equivalent 
free flexible variable theorem asserts satisfy different words definition quantification flexible variables allow removal transitions modify bound variables 
observation motivates semantic clause quantified formulas flexible variable say behaviors equal iff agree variables vf say similar written iff exist behaviors stuttering equivalent merz equal stuttering equivalent 
define iff holds behavior similar definition explicitly allows stuttering theorem preserved tla formulas 
properties refinement composition seen example fifo queue tla uses formalism temporal logic represent system specifications properties 
system specifications usually written form init list relevant state variables list internal hidden variables init state predicate representing initial condition action describes state relation usually written disjunction elementary actions conjunction formulas asserting fairness assumptions individual disjuncts 
forms specifications possible occasionally useful 
asserting property holds specification amounts saying behavior satisfies satisfy words asserts validity implication example theorem asserted module states essential properties fifo queue 
temporal logics tla intended support stepwise system development refinement specifications 
basic idea refinement consists successively adding implementation detail preserving properties required level 
refinement approach system development proceeds writing successive models introduces additional detail preserving essential properties preceding model 
fundamental properties system established high levels abstraction errors detected early phases complexity formal assurance spread entire development process 
refinement preserves tla properties specification formula valid condition turn equivalent requiring validity contain extra variables represent lower level detail variables change transitions counterpart level stuttering invariance tla formulas essential validity implication reasonable definition refinement 
stuttering invariance essential composition representable conjunction 
fact tla specifications components describes behaviors satisfy components initial conditions allow actions process occur synchronizing common variables logic tla represent interfaces components satisfy relevant liveness properties 
particular stuttering invariance ensures component may perform local actions interfering specification component 
test ideas try prove fifo queues row implement fifo queue 
assume queues connected channel mid principles imply formula fifo mid fifo mid fifo valid 
unfortunately true reason formula fifo implies channels change simultaneously conjunction left hand side allows changes left hand queue performs enq action right hand queue performs deq 
technical problem attributed design decision taken specification fifo queue disallow simultaneous changes input output interfaces specification style known interleaving specifications 
fact argument merely shows composition interleaving queues implement interleaving queue 
choosing interleaving non interleaving style artifact model represents actual system interleaving specifications usually easier write understand 
problem disappears explicitly add interleaving assumption composition implication fifo mid fifo mid fifo valid proof considered section 
variations extensions discuss choices presentation tla possible extensions 
transition formulas priming 
presentation tla standard order logic extent possible 
particular defined transition formulas formulas ordinary predicate logic large set variables unrelated 
alternative presentation consider operator resembling time modality temporal logic 
fact appears presentation preferred lamport 
semantics temporal formulas unaffected choice presentation style adopted corresponds verification rules tla explored section 
tla introduces concrete syntax module instantiation writing fifo mid 
merz compositional verification 
argued section composition represented tla conjunction 
components rarely expected operate correctly arbitrary environments specifications usually include assumptions environment 
open system specification constrain environment asserts component function correctly provided environment behaves expected 
way write specifications form implications describes environment assumptions component specification 
turns stronger form specifications desirable requires component adhere description long environment broken obligation particular systems built open component specifications form written allows strong composition rule discharge mutual assumptions components :10.1.1.33.1637
shown operator definable tla resulting composition rule justified terms logic specifications supplemented principles specific tla 
tla tla defines distinct tiers transition formulas temporal formulas transition formulas guarded brackets ensure stuttering invariance 
separation tiers natural writing system specifications prerequisite obtaining stuttering invariance 
defined logic tla syntax distinguishes classes pure impure formulas 
pure formulas tla contain impure formulas way temporal formulas tla contain transition formulas impure formulas generalize transition formulas admit boolean combinations pure formulas time modality temporal logic 
example tla formula requires action eventually followed 
assuming appropriate syntactic conventions tla generalization tla tla formula tla formula semantics 
hand shown tla formula expressed tla additional quantifiers 
example tla formula equivalent tla formula constant fresh flexible variable 
tla offers richer syntax increasing expressiveness allowing high level requirement spec strictly equivalence true universes contain distinct values element universes interesting 
logic tla expressed directly 
hand propositional fragment tla admits straightforward axiomatization 
proof system known propositional tla abadi proposed involved axiomatization early version tla invariant stuttering 
example temporal formula tuple containing flexible variables free occurrences tla formulation usual induction axiom temporal logic tla formula fact state formula 
binary temporal operators 
standard linear time temporal logics tla include binary operators necessary writing system specifications confusing especially nested 
operators definable tla quantification flexible variables 
example suppose state predicates free variables flexible variable appear constant 
defined formula idea auxiliary variable remember true 
long false required hold 
arbitrary tla formulas formula defined lines technique shown translation tla formulas 
tla proof rules tla formulas describe systems properties deductive system verification logical axioms rules tla 
precisely system described formula spec property prop behavior satisfies spec satisfies prop iff implication spec prop valid class interpretations function predicate symbols intended meaning 
system verification principle requires reasoning sets behaviors 
tla proof rules designed reduce temporal reasoning far possible proof verification conditions expressed underlying predicate logic strategy commonly referred assertional reasoning 
section state typical rules illustrate information 
merz invariants invariants characterize set states reached system execution constitute basic safety properties interest starting point verification attempt 
tla invariant expressed formula form state formula 
basic rule proving invariants inv rule asserts interpretation antecedent valid transition formula consequent valid temporal formula 
antecedent states possible transition stuttering preserves holds initially guaranteed hold forever 
formally correctness rule inv easily established induction behaviors 
antecedent transition formula proof relies standard axioms proof rules predicate logic augmented data axioms characterize intended interpretations 
example inv prove invariant seq message fifo queue specified module 
prove seq message rule inv definition formula propositional logic reduced proving init seq message seq message vars seq message empty sequence certainly finite sequence messages follows definition init appropriate data axioms 
similarly proof reduces proving preservation invariant stuttering deq enq actions message straightforward 
step simulation rule prove action invariants relies previously proven state invariant tla logic tla particular follows tla state relation strengthened invariant note converse implication valid right hand side holds behavior changes independently value may tla prove fifo queue dequeues value twice row deq vars proof requires invariant particular asserts consecutive elements internal queue identical inv oq oq len oq len oq oq oq tla syntax formulating inv local abbreviation oq denotes sequence obtained prefixing current value output channel internal queue tla represents sequence function elements accessed 
len 
formula inv asserts current value input channel equals element sequence oq consecutive elements oq identical 
proof inv follows pattern proving invariant rule inv 
proof rule tla requires show validity inv inv vars deq vars proof reduces cases stuttering transition enq action deq action 
case non trivial 
proof relies definition deq implies non empty head 
particular sequence oq contains elements inv implies oq just different oq head 
suffices prove 
liveness properties liveness properties intuitively assert eventually happen 
formulas satisfied stuttering behavior require progress proof liveness properties ultimately rely fairness properties assumed specification 
tla provides rules deduce elementary liveness properties fairness properties assumed specification complex properties inferred help founded orderings 
merz rule prove leads formula weak fairness assumption similar rule exists strong fairness 
enabled wft wf rule state predicates invariant represents state relation helpful action weak fairness assumed 
premises wf transition formulas 
see rule correct assume behavior satisfying wft holds state show holds premise successor state satisfying satisfy hold long true 
third premise ensures states action enabled assumption weak fairness ensures eventually occurs true case done 
second premise successor assumption fact successor state satisfying satisfy proves claim 
running example rule wf prove message stored queue eventually move closer head queue output channel 
formally state predicate defined len wf prove rigid variables 
proof outline illustrates application rule wf lower level steps relying data axioms omitted 

vars 
message enq 
deq 
deq 
vars vars 
steps definitions 

deq vars follows steps 

enabled deq vars implies enabledness condition 
logic tla rule wf prove stronger property input queue eventually dequeued message single helpful action number deq actions necessary produce input element output channel depends length queue 
intuitively argument establish property iterated 
rule formalizes idea induction founded relation binary relation exist infinite descending chain 
elements 
founded lattice rule rigid variables occur occur convenience stated rule lattice language set theory particular abbreviates formula premises rules considered far second hypothesis rule lattice temporal formula requires occurrence value followed occurrence smaller value hypothesis ensures infinite descending chain values eventually true 
principle hypothesis foundedness expressed tla asserting validity formula false conjunct expresses second conjunct asserts sequence values change decreasing respect eventually stationary 
fact formula valid interpretation interpreted founded relation 
system verification foundedness usually considered data axiom 
choosing nat set natural numbers standard greater relation founded domain proof property follows property invariant inv defined section rule lattice 
lamport lists derived rules liveness properties including rules proving formulas wft 
simple temporal logic proof rules considered far support derivation typical correctness properties systems 
addition tla satisfies standard axioms rules linear time merz stl stl stl stl stl stl fig 

simple temporal logic 
temporal logic useful preparing application verification rules 
contains axioms rules simple temporal logic adapted lamport 
shown just non standard presentation modal logic implying laws characterize modal accessibility relation reflexive transitive locally convex confluent 
condition asserts state states accessible state accessible quantifier rules seen section semantics quantification flexible variables non standard elementary proof rules quantifiers familiar order logic rules rigid flexible variable 
elimination rules require usual proviso bound variable free formula rules state function constant function 
observe allowed arbitrary state function rule prove state variable premise provable stl 
formula asserts remains constant behavior obviously valid 
existential quantification flexible variables corresponds hiding state components rules play fundamental role proofs refinement reactive systems 
context witness called refinement mapping 
example concatenation low level logic tla queues provides suitable refinement mapping prove validity formula claimed fifo queues row implement fifo queue assuming interleaving changes input output channels 
quantifier rules standard recall section care taken substitutions applied formulas defined terms quantification 
particular formulas wft contain subformula enabled wft need equivalent formula wft 
thorough discussion possible pitfall system verification see lamport original tla 
unfortunately refinement mappings need exist 
example prove valid tla formula excluding element universes true asserts existence flexible variable value changes infinitely 
variable oscillator triggering system transitions 
fact attempt prove rule require exhibit state function value certain change infinitely behavior 
easy show induction syntax state functions exists behavior value remains constant forever 
approach solving problem advocated consists adding auxiliary variables history variables 
formally approach consists adding special rules auxiliary variables 
proof reduced proving formula form aux rule auxiliary variables rules prove aux formalized mathematics added value tla definitions syntax semantics tla section generic terms underlying language predicate logic interpretation 
tla instantiates generic definition tla specific order language zermelo fr set theory choice 
adoption standard interpretation enables precise unambiguous specifications data structures specifications seen example proofs section reasoning data accounts steps need proved system verification 
tla provides facilities structuring specification hierarchy modules declaring parameters importantly defining operators 
facilities essential writing actual specifications mastered user tla foundational point view adopted just syntactic sugar 
concentrate set theoretic foundations referring reader lamport book detailed presentation language tla 
merz elementary data structures basic set theory signature predicate logic underlying tla contains single binary predicate symbol function symbols 
terms formulas transition level defined indicated section extra term formation rule defines choose transition function variable action 
occurrences term choose bound 
order language corresponds set theoretic interpretation tla value set 
interpreted set membership interpretation equipped unspecified choice function mapping non empty collection values element mapping empty collection arbitrary value 
interpretation term choose defined choose definition employs choice function return value satisfying provided value universe set theory 
semantic clause choice function applied collection need set element universe set theoretic terminology applies classes just sets 
function produces value applied equal arguments 
follows choice satisfies laws choose choose choose tla avoids undefinedness underspecification choose denotes value value satisfies ensure term involving choice denotes expected value existence set satisfying characteristic predicate proven 
value expression underspecified user prepared accept 
particular properties established possible values 
observe interpretation choice deterministic monotone relationship established choose choose valid equivalent 
specification spec contains underspecified application choice refinement ref bound choices order prove ref spec situation quite different non determinism implementations may narrow set allowed values 
freely abbreviations defined tla example abbreviates similar presentation deviates somewhat lamport prefers treat subsequent constructs equal footing distinguishing basic derived operators 
temporal formulas defined indicated section particular choose applied temporal formula 
logic tla notation applies choose 
local declarations written conditional expressions 
union union binary union union subset powerset subset choose choose comprehension choose comprehension choose table 
basic set theoretic operators 
membership choice build conventional language mathematics foundation expressiveness tla table lists basic set theoretic constructs tla write 
en choose 
en denote set enumeration assume additional bound variables defining expressions table chosen variable clashes occur 
comprehension schemes act binders variable free occurrences existence sets defined terms choice justified axioms zermelo fr set theory provide deductive counterpart semantics underlying tla known proper care set theory prone paradoxes 
example expression choose formed constant formula tla existence set containing precisely sets contain lead contradiction iff course russell paradox 
intuitively big set 
precisely universe set theory contain collections bijection collection sets 
evaluating tla expression choice function applied empty collection result depends underlying interpretation 
unexpectedly infer choose choose similarly generalized intersection operator dual union operator table sensibly defined intersection empty set produce set sets know exist 
positive side exploited fact set contain values definition choose message merz appears guaranteed denote value contained message 
refinement wanted fix specific null message value null message restricting class admissible interpretations assumption form assume choose message null properties established original specification hold possible choices continue hold restricted choice 
data structures sets conveniently interpreted functions 
traditional approach followed construct functions products relations 
tla prescribe concrete construction functions 
set functions domain equals codomain subset denoted domain function denoted domain application function expression written 
expression denotes function domain maps variable occur bound function constructor 
function obeys law domain equation fact serve characteristic predicate functional values 
tla introduces notation overriding function certain argument position similar concept underlies gurevich asm notation 
formally domain fresh variable 
combining choice sets function notation obtains expressive language defining mathematical structures 
example standard tla module introducing natural numbers defines arbitrary set constant zero successor function satisfying usual peano axioms lamport goes similarly define integers real numbers ensuring basic arithmetic operations agree having overload operation symbols 
recursive definitions introduced terms choice factorial choose nat tla syntactic sugar allows write concisely factorial nat factorial logic tla course construction choice definition justified proving existence function satisfies recursive equation 
standard semantics programming languages tla commit fixed point recursively defined function cases solutions 
tuples represented tla functions 

denotes set nat fresh variable selection th element just function application 
strings defined tuples characters records represented functions domains finite sets strings 
update operation functions applied tuples records 
record selection update concrete syntax allows write example acct balance acct balance 
seq len head tail append union nat choose nat domain len len len len len fig 

finite sequences 
standard tla module sequences imported specification fifo queue represents finite sequences tuples 
definitions standard operations shown quite simple 
simplicity deceptive 
example definitions reveal head tail operations partial 
validated proving expected properties seq len head tail design software systems requires combination ingenuity careful engineering 
substitute intuition correctness proposed solution checked precise reasoning suitable model realm logics formalized mathematics 
le formalism help user difficult important activity writing analysing formal models 
tla builds experience classical mathematics adds just thin layer merz temporal logic order describe executions sets traces 
distinctive feature tla attention refinement composition reflected concept stuttering invariance 
expressiveness tla undoubtedly helps writing concise highlevel models systems may wonder lends analysis models 
example pointed times need prove conditions definedness related choice operator 
hand zermelo fr set theory choice probably widely foundation classical mathematics known idioms primitive recursive definitions ensure definedness 
specification reactive systems tla adds proper idioms control delicate interplay temporal operators order ensure specification machine closed 
deductive verification tla specifications supported proof assistants fact encodings tla logical frameworks different theorem provers proposed prover designed support full tla surprisingly activity developing toolset tlc model checker simulator aid validating debugging tla models toolset applied industrial development projects 
obviously model checking possible sublanguage tla interestingly real world specifications written sublanguage translated minor transformations 
modeling language tlc expressive model checkers helps users write concise system specifications 

am grateful leslie lamport providing subject article encouragement detailed comments draft version 
parts adapted earlier tla written mart abadi 
helpful comments lia anonymous referees gratefully acknowledged 
mart abadi 
axiomatization lamport temporal logic actions 
jos baeten jan klop editors concur theories concurrency unification extension volume lecture notes computer science pages berlin 
springer verlag 
mart abadi leslie lamport 
existence refinement mappings 
theoretical computer science may 
mart abadi leslie lamport 
old fashioned recipe real time 
acm transactions programming languages systems september 
logic tla mart abadi leslie lamport 
conjoining specifications 
acm transactions programming languages systems may 
mart abadi stephan merz 
account composition 
ji petr hajek editors mathematical foundations computer science volume lecture notes computer science pages prague czech republic 
springer verlag 
mart abadi stephan merz 
tla logic 
manfred broy editor deductive program design nato asi series pages 
springer verlag 
mart abadi gordon plotkin 
logical view composition 
theoretical computer science june 

abrial 
book assigning programs meanings 
cambridge university press 

abrial 
extending changing developing distributed systems 
editor st conference method pages 
institut de recherche en informatique de nantes 
bowen alpern fred schneider 
defining liveness 
information processing letters october 
back von wright 
refinement calculus systematic 
springer verlag 
egon rger robert st rk 
state machines method high level system design analysis 
springer verlag 
edmund clarke orna grumberg doron peled 
model checking 
mit press cambridge mass 

de roever langmaack pnueli editors 
compositionality significant difference volume lecture notes computer science 
springer verlag 
urban engberg peter leslie lamport 
mechanical verification concurrent systems tla 
fourth intl 
conf 
computer aided verification cav volume lecture notes computer science pages 
springer verlag 
gordon 
mechanizing programming logics higher order logic 
birtwistle subrahmanyam editors current trends hardware verification automated theorem proving 
springer verlag 
david gries fred schneider 
avoiding undefined underspecification 
jan van leeuwen editor computer science today trends developments volume lecture notes computer science pages 
springer verlag new york 
hoare 
theory conjunction concurrency 
parallel architectures pages 
ieee computer security press 
hughes cresswell 
new modal logic 
routledge london 
sara 
formulation tla isabelle 
available ftp ftp dcs 
warwick ac uk people sara tla dvi march 
merz kamp 
tense logic theory linear order 
phd thesis univ california los angeles 
leslie lamport 
tla home page 
www research microsoft com users lamport tla tla html 
leslie lamport 
proving correctness multiprocess programs 
ieee transactions software engineering se march 
leslie lamport 
temporal logic 
mason editor information processing proceedings ifip th world congress pages paris september 
ifip north holland 
leslie lamport 
temporal logic actions 
acm transactions programming languages systems may 
leslie lamport 
write proof 
american mathematical monthly 
leslie lamport 
specifying systems 
addison wesley boston mass 

mathematical logic hilbert symbol 
university mathematical series 
macdonald london 
zohar manna amir pnueli 
verification concurrent programs temporal framework 
boyer moore editors correctness problem computer science pages 
academic press london 
zohar manna amir pnueli 
temporal logic reactive concurrent systems specification 
springer verlag new york 
stephan merz 
isabelle tla 
available www isabelle tum 
de library hol tla 
revised 
stephan merz 
complete tla 
wing woodcock davies editors fm world congress formal methods volume lecture notes computer science pages toulouse france 
springer verlag 
amir pnueli 
temporal logic programs 
proceedings th annual symposium foundations computer science pages 
ieee 
arthur prior 
past 
clarendon press oxford 
sistla clarke francez gurevich 
message buffers characterized linear temporal logic 
information control 
spivey 
notation manual 
prentice hall 
patrick suppes 
axiomatic set theory 
dover publications 
moshe vardi 
branching vs linear time final showdown 
margaria yi editors tools algorithms construction analysis systems tacas volume lecture notes computer science pages genova italy 
springer verlag 
see www cs rice edu vardi papers versions 
yuan yu panagiotis leslie lamport 
model checking tla specifications 
pierre editors correct hardware design verification methods volume lecture notes computer science pages bad germany 
springer verlag 
