effective dynamic voltage scaling cpu boundedness detection chung hsu wu chun feng los alamos national laboratory los alamos feng lanl gov 
dynamic voltage scaling dvs allows program execute non peak cpu frequency order reduce cpu power energy consumption oftentimes done expense performance degradation 
program execution time bounded peripherals performance cpu speed applying dvs program result negligible performance penalty 
unfortunately existing dvs power management algorithms conservative sense overly exaggerate impact cpu speed execution time 
propose new dvs algorithm detects cpu boundedness program fly regression method past mips rate adjusts cpu frequency accordingly 
illustrate effectiveness compare algorithm dvs algorithms real systems physical measurements 
dynamic voltage frequency scaling dvs mechanism software dynamically adjust cpu voltage frequency 
mechanism allows systems address problem increasing cpu power dissipation energy consumption quadratically proportional cpu voltage 
reducing cpu voltage may require cpu frequency reduced results degraded cpu performance respect execution time 
words dvs trades performance power energy reduction 
performance loss due running lower cpu frequency raises issues 
user pays upgrade computer system want experience performance degradation 
second running programs low cpu frequency may increasing total system energy usage 
order control constrain performance loss effectively model relates performance cpu frequency essential dvs algorithm shortened dvs algorithm 
typical model dvs algorithms predicts execution time double cpu speed cut half 
unfortunately model supported doe asc program los alamos national laboratory contract eng 
overly impact cpu speed execution time 
worst case execution time doubles cpu speed halved general actual execution time double 
example programs high cache ratio performance limited memory bandwidth cpu speed 
memory performance affected change cpu speed increasing decreasing cpu frequency little effect performance programs 
call phenomenon sublinear performance slowdown 
consequently researchers trying exploit program behavior order achieve better power energy reduction 
common technique exploit sublinear performance slowdown decomposes program workload regions cpu boundedness 
decomposition done statically profiling information dynamically auxiliary circuit built performance monitoring unit pmu :10.1.1.60.8609
propose new pmu assisted line dvs algorithm called adaptation provides fine grained tight control performance loss takes advantage sublinear performance slowdown 
new adaptation algorithm extension theoretical developed yao 
physical measurements demonstrate effectiveness adaptation algorithm compared existing dvs algorithms number applications 
rest organized follows 
section characterizes current dvs algorithms relate performance cpu frequency 
characterization backdrop new dvs algorithm section theoretical foundation section 
section describes experimental set implemented dvs algorithms experimental results 
section concludes presents directions 
related attempts exploit sublinear performance slowdown increasing decreasing cpu frequency little effect performance program achieve power energy reduction 
example li propose set cpu low speed cache occurs hsu kremer line profiling identify memory bound program regions 
approach requires auxiliary circuit approach needs source code compiler support 
requirements approaches difficult implement practice 
approach built performance monitoring unit pmu assist line detection sublinear performance slowdown 
choi belong category :10.1.1.60.8609
regression method pmu support perform line construction simple performance prediction model capture degree cpu boundedness 
general design pmu assisted line dvs algorithms easy task 
pmu notorious incomplete set event counting inconsistency generations cpu 
second correlation event counts power performance clear 
line dvs algorithm ought minimize dependency event counts rely possible event counts consistent cpu generations 
differs choi definition cpu boundedness detection mechanism 
choi ratio chip computation time chip access time 
contrast algorithm defines cpu boundedness fraction program workload cpu bound 
different definitions set events monitored pmu algorithm different 
section argue dvs algorithm equally effective simpler implementation 
provide theoretical foundation dvs algorithm effective achieving energy optimality 
believe theoretical result applied 
adaptation new dvs algorithm describe new interval pmu assisted dvs algorithm provides fine grained tight control performance loss exploits sublinear performance scaling memory bound bound programs 
theoretically heuristic algorithm extension theoretical developed details section cpu power draw convex function cpu frequency program performance affine function cpu frequency running constant cpu speed meeting deadline just time minimize energy usage executing program 
desired cpu frequency directly supported cpu frequencies emulate desired cpu frequency result energy optimal dvs schedule 
account sublinear performance slowdown model relates performance cpu frequency total execution time frequency decomposed parts :10.1.1.60.8609
part models chip workload terms cpu cycles 
value affected cpu speed change 
second part models time due chip accesses invariant changes cpu speed 
note breakdown total execution time inexact target processor supports order execution chip execution may overlap chip accesses 
practice error tends quite small :10.1.1.60.8609
model treats program performance affine function cpu frequency allows apply aforementioned theoretical result 
simply execute program cpu frequency deadline program 
challenges theorem way 
cases consensus assign deadline program scientific computation 
second need know values coefficients 
coefficients oftentimes determined hardware platform program source code data input 
calculating coefficients statically difficult 
address challenges defining deadline relative performance slowdown estimating model coefficients fly offline profiling compiler support 
relative performance slowdown fmax fmax peak cpu frequency previous 
widely accepted programs difficult assign deadlines terms absolute execution time 
carries timing requirement information cpu utilization ipc rate 
providing user tunable parameter dvs algorithm allows fine grained tight control performance loss 
estimate coefficients efficiently re formulate original coefficient model equation single coefficient model fmax fmax fmax coefficient definition value 
introduced authors quantify program performance impact cpu speed change 
metric represents fraction program workload scales linearly cpu frequency 
program means execution time program double cpu speed halved 
contrast program execution time remained running slowest cpu speed 
coefficient computed run time regression method past mips rates reported pmu 
specifically dvs algorithm keeps track average mips rate executed cpu frequency applies square fitting interval dynamically re compute new value fmax fi mips fmax mips fi fmax fi mips average mips rate cpu frequency note mechanism assumes constant number total instructions program regardless running cpu frequency 
assumption verified seconds 
equation compute 

compute frequency max fmin fmax 
fj fj 
fj fj 
compute ratio fj fj fj 
run seconds fj 

run seconds fj 
update mips fj mips fj 
fig 
algorithm adaptation 
parameter relative performance slowdown parameter length interval seconds 
extensive experiments 
practice value converges quickly benchmarks tested 
rest algorithm simply applies theoretical result compute desired cpu frequency interval coefficient updated plus bookkeeping mips 
derivation comes equating equation equation 
outlines entire algorithm 
theoretical foundation previous section claim theoretical result energy optimal dvs scheduling extends yao 
section provide evidence support claim 
energy optimal dvs scheduling problem considered taken 
previous provides problem formulation 
provide theorem characterizes energy optimal dvs schedule problem 
theorem closely related previous critical power slope 
dvs system assumed export settings fi pi pi cpu power dissipation watts cpu frequency fi 
loss generality assume fmin fn fmax 
denote total execution time program running setting ti 
facilitate discussion define ei pi ti ei energy consumption joules running ti seconds cpu frequency fi 
dvs scheduling problem formulated follows program deadline seconds find dvs schedule program executed seconds setting total energy usage minimized deadline met required completed 
mathematically speaking argmin pi ti ti ti ti ti simplify discussion theorem handle corner cases 
condition mini ti satisfied problem feasible 
second condition maxi ti satisfied problem classical fractional knapsack problem 
case energy optimal dvs schedule execute entire program setting arg min ei 
case tn dvs schedule energy optimal 
left case mini ti maxi ti assume true theorem 
theorem 
ti proof 
see appendix 
fi pn pn fn fn fj tj fj fj fj fj theorem says program execution time affine function cpu frequency dvs settings cpu assigned explained run program cpu frequency finishes execution right deadline results energy optimal schedule 
desired cpu frequency directly supported emulated immediately neighboring cpu frequencies 
dvs enabled processor power draw modeled convex function frequency processor dvs settings 
realistic processors assigned dvs settings default 
processors lowest frequency emulated combination frequency cpu sleep mode second lowest frequency lower power dissipation result completing task deadline putting cpu sleep mode energy efficient completing task deadline 
phenomenon observed motivated devise technique called critical power slope 
phenomenon eliminated making adjustments dvs settings assigned 
theorem extends yao 
works assume 
second assumes fixed relationship dvs setting vt vt positive constants 
unfortunately today dvs processors may able support assumption 
processors provide discrete set cpu frequencies voltages equation requires continuous range cpu frequencies supported discrete set voltages 
theorem assumptions facilitate dvs algorithms realistic processors 
experiments section describe experimental environment evaluate compare algorithm adaptation dvs algorithms 
depth discussion experimental results 
experimental setup order acquire high fidelity experimental data set experiments physical measurements shown 
experimental results collected wt digital power meter 
power meter continuously samples instantaneous 
profiling tested computer run linux kernel 
benchmarks compiled gnu compilers optimization level 
benchmarks run completion run took minute 
profiling computer digital power meter wall power outlet power strip ac adapter tested computer mhz fig 
experimental setup 
benchmarks taken spec cpu benchmark suites 
spec benchmarks emphasize performance cpu memory computer components disk drives networking graphics 
chose spec benchmarks demonstrate range performance sensitivity cpu frequency change wide range values 
experimental data collected running spec benchmarks data input 
hardware platform experiments hp nx notebook computer 
computer includes mobile amd athlon xp processor mb ddr sdram mhz front side bus gb hard disk inch tft lcd display 
mobile amd athlon xp processor sun fire blade servers 
total kb cache space 
processor exports registers software write target frequency voltage values 
experiments restrict processor settings shown 
transition time setting microseconds 
measurements battery removed monitor turned 
presenting experimental results associate application value 
recall metric represents fraction program workload sensitive cpu speed change 
higher program cpu bound performance 
value benchmark derived profiling total execution times settings applying squares fit equation 
implemented dvs algorithms evaluate effectiveness dvs algorithm adaptation implemented number dvs algorithms 
claim implemented dvs algorithms represent comprehensive comparison existing approaches feel range wide evaluate effectiveness algorithm gain new insights experimental results 
brief description algorithm implemented 
step algorithm assumes dual cpu speeds processor monitors cpu utilization percentage periodically 
percentage higher pre defined threshold algorithm set cpu fast speed lower pre defined threshold algorithm set cpu low speed 
dvs algorithm considered best algorithm grunwald empirical study interval algorithms cpu utilization 
implementation thresholds speeds maximum minimum cpu speeds processor 
algorithm proposed varma refinement step algorithm 
recognizing similarity dvs scheduling classical control systems problem authors took equation describing pid controller proportional integral derivative modified suit dvs scheduling problem 
algorithm significantly improved control performance loss step algorithm lacks 
addition authors algorithm effectiveness depend careful tuning parameters nice feature step effectiveness critically dependent choice application specific threshold values 
freq algorithm similar strategies reclaim slack time actual processing time worst case execution time 
specifically algorithm keeps track amount remaining cpu amount remaining time deadline 
desired cpu frequency fnew interval simply fnew algorithm assumes total amount cpu cycles known priori practice unpredictable constant frequencies 
mips algorithm taken represents dvs strategy guided externally specified performance metric 
specifically new frequency fnew interval computed fnew frequency previous interval externally specified performance requirement real mips rate observed previous interval 
experiments benchmark derived measuring mips rate entire application dividing 
experimental results table presents experimental results interval dvs algorithms 
program memory bound bound close zero substantial opportunity reduce cpu energy consumption negligible performance loss 
contrast program cpu bound little opportunity reduce cpu power energy tight bound 
dvs algorithms produce dvs schedule exact performance degradation actual performance loss varied benchmark 
interval dvs algorithms adaptation algorithm outperforms 
sense verifies mechanism computing cpu boundedness fly low overhead algorithm effective providing tight control performance loss due dvs table 
effectiveness different dvs algorithms 
table entry format relative time relative energy respect total execution time system energy usage running application highest setting entire execution 
program step freq mips adapt 
swim tomcatv su cor compress mgrid vortex turb go exploiting sublinear performance slowdown significantly cpu power energy savings 
algorithms mips arguably rank second 
algorithm mips delivers better control performance loss benchmarks tested algorithm performs better respect power energy reduction expense substantial performance loss 
especially obvious cpu bound benchmarks 
algorithms freq step clearly rank 
learned experiment 
number instructions better metric specifying cpu requirement number cpu cycles 
benchmarks tested number instructions tends remain constant settings 
contrast number cpu cycles varies significantly depending executed dvs schedule 
example swim benchmark running lowest setting cpu execution cycles running highest setting 
typically algorithm freq uses worst case execution cycles case number cpu cycles highest setting 
approach amount cpu done results effective energy reduction 
explains algorithm mips performs better algorithm freq 
second large window size past pmu reports better small window size past pmu reports 
experiments mips rate varies significantly interval interval especially cpu intensive applications 
accumulated mips rate converges quickly 
mips rate global manner effective rate local manner 
partially explains effectiveness algorithm adaptation compared algorithm mips 
concern large window size dvs algorithm may responsive programs expose multiple execution phases varying degrees cpu boundedness 
benchmarks known aforementioned behavior problem 
details section 
confirmed cpu utilization provide information system timing requirements 
result control performance loss unsatisfactory 
seen experimental results algorithm step algorithm 
algorithm step perform dvs scheduling 
cpu spec benchmarks active time cpu utilization full 
case exists optimal threshold values step effective 
algorithm refines algorithm step removing threshold mechanism user 
effective algorithm step terms cpu power energy reduction lack information deadlines impossible provide tight control performance loss 
impact multiple phase execution behavior better address impact multiple phase programs dvs algorithm adaptation compare profile line dvs algorithm called hsu 
algorithm hsu uses pmu assisted line profiling source code analysis identify energy profitable region program slow causing performance loss surpass pre defined level 
line profiling performed section section basis dvs scheduling decisions global manner competitively comparing different sections 
global view impact dvs different code sections allows effective dvs scheduling especially multiple phase programs spec benchmarks 
algorithm hsu uses relative performance slowdown specify control performance loss 
allows compare algorithms fair basis 
experiments executed profile algorithm hsu different training inputs denoted hsu train hsu ref respectively 
sets training inputs provided spec benchmark codes 
table shows experimental results algorithms cfp benchmark suite 
conclude effectiveness algorithm adaptation comparable algorithm hsu 
algorithms achieve significant amount cpu power energy reduction tight control performance loss 
interesting note algorithms complement 
algorithm adaptation performs better cpu bound benchmarks mgrid fpppp algorithm hsu performs better memory bound benchmarks swim hydro 
process investigating causes phenomenon 
mentioned section effectiveness profile dvs algorithms highly determined training data input 
experiments algorithm hsu chose different program regions slow benchmarks 
running data input training input necessarily yield better result example apsi 
suspect instrumented program profiling somewhat altered instruction access pattern considerably different original code 
hsu table 
comparison new line dvs algorithm adaptation line dvs algorithm hsu 
table entry format relative time respect total execution time system energy usage running application highest setting entire execution 
program hsu train hsu ref adapt 
swim tomcatv hydro su cor applu apsi mgrid wave turb fpppp dissertation suif compiler infrastructure algorithm hsu built major impact experimental results 
comparison choi section compare contrast choi :10.1.1.60.8609
recall works equation 
difference calculation equation coefficients 
calculates defined equation choi calculates defined follows analytically metrics equivalent fmax major differences terms implementation 
metric invariant cpu frequency change metric defined respect particular cpu frequency number coefficients calculated choi dvs algorithm number coefficients calculated algorithm adaptation 
second formula calculating complex 
due coefficient model contrast coefficient model 
number pmu event counts needed calculating smaller calculating cpu simultaneously count finite number events counting events may introduce larger time overhead 
new dvs algorithm simpler implementation choi 
empirical comparison current setting 
choi implemented dvs algorithms intel processors provide counting number retired instructions 
hand hardware platform athlon xp processor provide counting number executed instructions 
fact big issues pmu assist dvs scheduling cpu events may compatible consistent different hardware platforms 
choi platform dependent implementations dvs algorithm :10.1.1.60.8609
sensitivity analysis algorithm parameters section sensitivity analysis parameters algorithm adaptation relative performance slowdown length interval shown 
spec cpu benchmarks average execution time increases pace increase average energy consumption stays passes 
increases algorithm slows cpu bound programs lower performance power ratios 
setting small value recommended 
terms interval size average execution time shape curve 
setting large value seconds program run converged sufficiently long time setting small value milliseconds introduced significant amount time overhead recommend setting value milliseconds second 
proposed new pmu assisted interval dvs algorithm detects cpu boundedness program fly adjusts cpu speed accordingly 
algorithm arbitrary heuristic 
extension previous theoretical energy optimal dvs scheduling problem 
algorithm proven effective comparison number dvs algorithms physical measurements 
new algorithm provides fine grained tight control performance loss exploits sublinear performance slowdown 
algorithm simple implement 
new dvs algorithm refined various ways 
particular direction compiler hints additional scheduling support 
idea new type hint compiler provide dvs algorithm effective research topic general purpose systems 
relieve compiler difficulty giving exact timing information line compiler simply identify distinguish execution phases program terms cpu boundedness approximate manner 
algorithm adaptation refined compute value phases improve effectiveness memory bound programs 

lorch smith 
improving dynamic voltage algorithms pace 
international conference measurement modeling computer systems june 

rajkumar 
critical power slope understanding runtime effects frequency scaling 
international conference supercomputing june 

kim kim min 
preemption aware dynamic voltage scaling hard real time systems 
international symposium low power electronics design august 


hsu kremer 
design implementation evaluation compiler algorithm cpu energy reduction 
acm sigplan conference programming languages design implementation june 

li 
cher roy 
vsv driven variable supply voltage scaling low power 
international symposium microarchitecture december 

choi soma pedram 
fine grained dynamic voltage frequency scaling precise energy performance trade ration access chip computation time 
design automation test europe conference february 

choi soma pedram 
dynamic voltage frequency scaling workload decomposition 
international symposium low power electronics design august 

yao demers shenker 
scheduling model reduced cpu energy 
ieee annual symposium foundations computer science october 


voltage scheduling problem dynamically variable voltage processors 
international symposium low power electronics design august 

seth mueller rotenberg 
fast frequency aware static timing analysis 
international real time systems symposium december 


hsu kremer hsiao 
compiler directed dynamic frequency voltage scheduling 
workshop power aware computer systems november 

cormen leiserson rivest 
algorithms 
mit press cambridge ma 


wt wt digital power meters 
technical report 

standard performance evaluation 
www spec org 

sun fire blade server 
www sun com servers entry 

grunwald levis farkas iii neufeld 
policies dynamic clock scheduling 
symposium operating system design implementation october 

varma ganesh sen choudhary srinivasan jacob 
control theoretic approach dynamic voltage scaling 
international conference compilers architectures synthesis embedded systems october 

moss melhem 
placement power management points real time applications 
workshop compilers operating systems low power september 

azevedo cornea gupta dutt nicolau 
profile dynamic voltage scheduling program checkpoints copper framework 
design automation test europe conference march 

tang melhem 
adapting processor supply voltage instruction level parallelism 
chips workshop december 


hsu 
compiler directed dynamic voltage frequency scaling cpu power energy reduction 
phd thesis department computer science rutgers university new brunswick new jersey june 

moss melhem craven 
collaborative operating system compiler power management real time applications 
real time embedded technology applications symposium may 
appendix prove theorem show chain inequalities true 
en en tn tn difficult prove ei ei ti ti ei ei pi pi fi ti ti fi fi pi pi fi fi fi pi pi fi fi fi pi pi fi fi fi ei ei ti ti pi fi fi fi pi fi pi pi 
define ri ti ti introduce new function emin follows 
emin min ri ei ri ti ri ri sequence ei ei ti ti non increasing function emin equivalent piecewise linear function connects points ti ei 
slopes chords piecewise linear function non positive emin non increasing 
seek solution emin emin min emin 
tj tj emin function value chord connecting points tj ej tj ej 
proof completed solving linear system tj tj 

