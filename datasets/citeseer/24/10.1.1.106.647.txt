lightweight bytecode verification eva rose eva rose name informatique university paris place jussieu paris france 

provide theoretical foundation improvements existing bytecode verification technology critical component java security model mobile code java micro edition intended embedded computing devices 
java remotely loaded bytecode class files required bytecode verified execution undergo static type analysis protects platform java run time system called type confusion attacks pointer manipulation 
data flow analysis performs verification capacity embedded devices memory requirements typical algorithm need 
propose take proof carrying code pcc approach data flow analysis defining alternative technique called lightweight analysis uses notion certificate previously analyzed data flow problem poorly platforms 
formally prove technique provides guarantees standard bytecode safety verification analysis particular tamper proof sense guarantees provided analysis broken crafting false certificate altering analyzed code 
show java bytecode verifier fits framework important subset java virtual machine show resulting lightweight bytecode verification technique generalizes simulates verifier expected sun virtual machine verifier directly early version leroy card bytecode verifier specifically targeted java cards 

section context lightweight bytecode verification 
specifically advocate approach bytecode type safety verification 
give overview 

mobile code small devices years increasing demand generalizing programming capability small independent devices smart cards point sale terminals personal digital assistants set top boxes types pervasive devices feature device microprocessor 
funded gie joint inria bull alliance 
kluwer academic publishers 
printed netherlands 
rose jar pcc tex specifically consider ensure type safety code downloaded untrusted network small device 
java platform ideally suited task java predecessor oak originally developed type deployment mind sun connell 
original oak prototype fact include bytecode verifier locally ensured typedness transmitted code 
various reasons prototype failed performance idea survived terms java virtual machine jvm 
virtual machine level possible address safety security issues independently underlying execution platform untrusted code provider 
initial success java associated ability send mobile code applets untrusted network executed web browser secure manner 
technique allows called sandboxing sun 
cornerstone sandboxing security model type safety basically guarantees object truly refer objects compatible type 
crucial socalled type confusion attacks may seriously alter system security measures updating object address manufactured integer 
survey java security attacks see mcgraw felten 
show bytecode verification normally java class file transfer untrusted network 
java program javac verified jvm bytecode network untrusted jvm bytecode 
standard bytecode verification 
verifier trusted jvm bytecode execution rose jar pcc tex today java standard organized variety different platforms 
java micro edition specifically targeted small devices featuring device microprocessor sun 
smallest devices described connected limited device configuration specification taivalsaari 
give idea available memory device consider java card sun platform implements chen scratch memory general name part ram highest flexibility permits full speed read write operations individual bytes 
contents lost power removed 
quite expensive 
kind memory typically available range bytes smart card 
flash memory persistent memory read written blocks continuous bytes typically process slow typically times slower scratch memory 
relatively inexpensive 
type memory typically comes range bytes smart card 
rom read memory part fixed circuit manufactured 
earlier smart card editions typically contained sixteen bytes rom completely constant system programs data 
rom increasingly obsolete decreasing costs flash memory system data updated 
study began obvious provide bytecode type safety sparsely execution platforms 
sun original bytecode verifier specified data flow algorithm space requirement proportional number backward jumps bytecode 
specific data flow algorithm implemented space requirement number backward jump targets maximal stack size number local variables lindholm yellin 
small devices capacity 
traditional way overcome sign bytecode digital signature check authenticity device sun 
began study different approach prevent safety violations code transmitted untrusted network just rose jar pcc tex published carrying code necula necula lee :10.1.1.40.2507
long time unclear approach specifically applied java need bytecode secured attacks means digital signatures 

signatures code signing done symmetric shared key public key signatures 
smart card standards global platform support types key signatures java card applets 
techniques implements concept works storing key trusted party code signature eventually checked execution platform 
listed issues concerning cryptographic signatures 
technology exists smart card standards sun guarantees code literally identical code sent trusted party code consumer obliged trust external party key provider number keys store tendency grow may problematic sparsely devices anderson trust relation code consumer code provider creates single point failure system 
device receives code widely distributed unfortunate situation device producer code provider necessarily trust sources 
banking frequent case credit cards issued bank code produced encrypted competing bank anderson 
systems devices storing high sensitive data credit cards banking cards personal identification devices listed arguments problematic overcome constrained systems devastating perspective safety security leak 
rose jar pcc tex 
proof carrying code pcc concept launched necula lee 
allows untrusted code statically verified safe execute case safe code behavior logically specified type properties automatically verified 
pcc works definition security policy expressed logical system decidable program safety properties 
correct program additional proof respect defined logical system constructed code transfer time mechanically decided program adheres adopted policy code receiving platform 
refer section discussion definition pcc 
listed issues concerning pcc 
code consumer trust internal security policy management 
checker component implements decidable proof check code receiving platform 
application pcc security policy proof generator mechanical proof checker different kinds compiler schemas real assembler code successfully implemented colby necula lee 
number transfered bytes increase size certificate 
pcc methods ensure code doesn alter code consumer security policy 
ensure received code emitted code 
crucial proof producer code consumer integrated safety policy order correct program accepted 
code emitter sends accompanying proof different non compatible safety policy code get accepted cases program safe execute 
systems devices storing high sensitive data credit cards banking cards personal identification devices particular listed arguments credits pcc highly attractive 
term safe program behavior understand behavior allow access private files data overwrite important files data access unauthorized resources rose jar pcc tex fact code receiver trust internal safety policy system robust attacks 
main disadvantage overcome deal increased size transmitted bytes proof type checker size memory consumption code receiving platform 
important consider critical received code proven safe execute may altered network safe manner 

application pcc java earlier dating year successfully addressed issue compiler java source code intel assembly code colby colby 
certifying java compiler case produces native target code annotations proof respect set axioms rules specifies java type safety requirements intel architecture 
study concerned description platform independent application pcc object oriented languages general java particular order solution scale large network 
began rose rose rose notion pcc defined restricted manner today necula :10.1.1.40.2507
time pcc specifically defined proof systems respect founded logic curry howard isomorphism transmitted language formal type system 
definition time direct application pcc java impossible founded formal logic specified object systems subtyping 
altered definition pcc original approach lightweight bytecode verification rose rose java bytecode safety decided axiomatic system java virtual machine static operational semantics comes definition pcc 
notice listing issues pcc section valid original specification pcc 
curry howard correspondence guarantees existence isomorphism formal type system formal logic 
rose jar pcc tex java program untrusted javac certifier certificate certificate verified jvm bytecode network jvm bytecode 
lightweight bytecode verification 

approach checker trusted jvm bytecode execution proof carrying code approach bytecode verification untrusted network assume type safety process performed steps code transmitter platform assume large host certifying bytecode verifier code receiver platform assume constrained memory space 
result approach type safety verification divided stages illustrated 
intend formalize lightweight bytecode verification steps specify lightweight bytecode verification general data flow problem specifically apply problem java virtual machine 
cases shall formalize technique inference system 

overview section formally specify lightweight bytecode verification data flow framework 
specifically constraint data flow problem converted lightweight data flow problem show technique tamper proof 
section apply lightweight verification java bytecode important java virtual machine subset 
section specifically relate lightweight rose jar pcc tex verification java sun bytecode verifier leroy java card verifier 
section conclude 

lightweight data flow concept section shall theory lightweight verification way solve data flow problem 
way data flow analysis nielson 


data flow analysis shall take constraint approach data flow analysis represent programs directed graphs nodes terms labelled elementary blocks connected control flow edges 
traditional flow graph organized basic blocks example graph simplest way obtain labelling basic blocks entry address blocks flow graph label set 
class int dummy return class extends class void new dummy new 
sample java source program 
example java source 
consider java source program method shown 
flow analysis determine type assignment 
consistent declared type declared type local variables maintained runtime significance verification 
subsequently method call dummy safe just requires subtype true type assignments 
definition data flow problems solutions 
lab non empty set node labels flow graph state associated domain program analysis states partial order defined state 
rose jar pcc tex data flow problem represented flow graph exits map blocks program state constraints terms edges elementary blocks 
data flow solution represented entry map node labels program analysis states program constraint set satisfied 
formally correspond specifications 
flow edge specified exits exits lab edge entry entries lab state edge state state lab say entry solves solution data flow problem exits iff exits entry entry similarly say exits solvable respect state exists entry solves data flow problem exits 
entry exits naturally defined total functions lab 
particular elementary block exit edges exits 
notice state transformer map total map 
defined solved data flow problem solution expected 
data flow constraints particular elementary block defined flow edges directed block 
rest may simply refer exits program flow graph constraint set 
example java bytecode 
listed virtual machine bytecode sequence basic blocks separated blanks annotated relative bytecode address 
clarifying simplifications code generated standard java compiler applied program example 
lab set consists relative entry addresses basic blocks 
purpose java bytecode verification analyse type data method process 
state description static type description java method frame static type description operand stack local variable table method analyzed 
rose jar pcc tex new astore goto new astore aload invokevirtual msig dummy return 
sample java bytecode 
state set method consequently consists type descriptions stack element local variable table elements jvm element contains instance methods 
state represented type triples tstack tx type stack tstack stack types stack ll need empty stack stacks single type example 
local variables tx denotes value initialized 
example initial parameter constraint constraints edges directed basic block address written entry entry entry entry entry tx entry entry tx entry tx denotes state obtained entry overriding type local variable defined approximation relation frame type states solve constraints 
java turns details section derived java assignment compatibility type rules pointwise extension frame type constituents stack elements variable types 
constraint system solved setting entry entry entry rose jar pcc tex 
lightweight data flow analysis general determination entry solution requires generic data flow analysis kildall 
lightweight analysis suggest flow graph re analyzed single traversal nodes ascending order appropriate label annotations certificate collected prior proper analysis 
assuming order nodes possible separate constraints forward directed incorporated directly reconstruction solution backward directed constraints reconstructed need checked candidate 
order formalize idea assumption graph nodes totally ordered states comparable 
definition lightweight hypothesis 
assume properties program data flow analysis 
lab finite total order state complete lattice usual denote meet join operators state respectively note complete lattice total commutative associative 

pointed klein nipkow lightweight bytecode verification java proven weaker hypothesis java type domains construct founded semilattice 
consistent general data flow analysis kildall lightweight verification specified general case founded semilattice 
order simplify formalization proofs shall insist completeness lattice sufficient condition application 
idea lightweight bytecode verification perform single pass flow graph ascending node order node check constraints imposed flow edges directions satisfied respect candidate solution 
respect forward edges graph need maintain structure pending constraint checks checked reach target edge similarly backward edges need maintain structure solution candidate states saved checked 
problems approach rose jar pcc tex linear pass know label target backwards jump block processed 
suggest backward labels provided externally notify algorithm save program state 
determine solution candidate value data flow analysis iteration resulting pass flow graph inevitable 
suggest correct entry program state information provided externally iteration nodes program states satisfy program constraint set 
external provision formalized terms certificate definition lightweight certificate 
exits lab state define data flow problem 
certificate pair label set state map 
ce cert sc lc sc lab state lc lab order facilitate lightweight formalization define sc total map convention sc backwards constraints imposed flow graph 
sc sc sc 
lightweight analysis data structures 
exits exits illustrated semi formal way changes pending saved data structures possible flow situations node involved 
tacitly assume mentioned convention pending constraints registered saved constraints registered 
flow edges arrows annotated formal name 
nodes labeled annotated kind rose jar pcc tex action lightweight analysis requires ascending node traversal 
write denote map obtained overriding map yield value explain situations lightweight algorithm handle accordance 
forward directed edge discovered node labeled contribution edge pending constraint formally specified sc 
point updated previously accumulated pending constraints specified contribution edge node point current solution consists previously accumulated pending constraints specified constraint imposed certificate sc 
notice current solution satisfies forward directed flow constraints 
node target backward directed flow constraint 
point current state saved constraint check 
backward directed edge discovered 
point saved constraint constraint imposed node sc checked type safety 
saved pending constraints formalized simple maps 
definition saved pending 
saved pending total maps defined save lab state pend lab state example java lightweight bytecode verification 
reconsider java bytecode example 
code organized basic blocks forward jumps block address block address backward jump block address 
illustrate lightweight verifier updates description lightweight certificate follows ce exit maps defined labeled frame type transformers defined basic block java instruction semantics lindholm yellin 
arguments rose jar pcc tex entry states blocks 
indicate requirements type write 
listed sequence basic block labels order blocks visited 
initial constraint forward jump 
backward jump target forward jump 
forward jump target 
typecheck successfully enforced 
initial constraint enforces updated proceed formalization general lightweight certification inference system notations introduced informally 
initial analysis rule initializes current label considered graph auxiliary pending saved maps 
tacitly assumed graphs contain node lightweight analysis sense 
definition lightweight bytecode verification 
lightweight bytecode verification judgment non empty flow graph signature exits cert defined inference rule exits ce exits ce min dom exits dom exits dom exits exits ce reads follows lightweight certificate ce lightweight verifies data flow problem exits 
ce cert exits ce holds say exits lightweight verifiable 
rose jar pcc tex lightweight analysis rules subgraph just tail recursive rule set 
definition 
lightweight analysis judgment subgraph signature exits cert lab pend save exits ce reads follows subgraph node labels greater equal lightweight analyzes flow graph context constraints exits certificate ce forward constraint set backward constraint set judgement specified inference rules node preceding nodes 
exits ce exits ce max dom exits exits ce exits ce exits ce max dom exits min dom exits node judgment definition 
lightweight analysis node reflects scenarios node node involved forward backward directed constraints 
definition 
lightweight bytecode verification judgment node signature exits cert lab pend save pend save exits ce reads follows node lightweight analyzes flow graph context constraints exits certificate ce modifying accumulated forward constraints backward constraints defined single axiom 
exits sc lc rose jar pcc tex sc exits exits lab lc lab exits notice cases modified ensure old pending values kept pending entry subsequent label encodes constraint edges label 
order prove equivalence lightweight analysis standard analysis shall stating important invariant property lightweight analysis 
invariant ensures lightweight verified node constraints previously imposed node met respect traversal order 
lemma lightweight invariant 
exits denote graph lc dom exits label subset sc dom exits state map labels states 
equivalence dom exits dom exits exits sc lc exits sc sc state sc called current solution 
proof 
invariant proven induction respect formal lightweight specifications definition definition 
case assume 
proof obtained induction height proof tree 
case assume 
proof obtained induction label 
invariant property formulate main result follows 
rose jar pcc tex theorem lightweight bytecode verification equivalence 
data flow problem exits lab edge statements equivalent 
exits solvable cf 
definition 

exits lightweight verifiable cf 
definition 
proof 
theorem proven way lemma 
case proof 
assume problem specified exits solvable 
show exists certificate ce exits ce proven lightweight verification inference system definition definition 
proof conducted induction proof size graph lc 
notice base case give definition certificate ce form sc lc notice condition ensures side conditions definition holds choice sc 
induction lc follows sc lc valid certificate 
case assume graph denoted exits certificate ce sc lc entry ce provable 
lightweight invariance condition implies dom exits associate state sc satisfies analysis condition 
words solution analysis entry defined entry sc 
investigate space complexity type check algorithm suggested proof explained current certification strategy 

memory analysis program lightweight certificate placed sort slow write memory target platform flash eeprom need written 
simply denoted flash 
maximal scratch space require perform lightweight bytecode verification connected graph traversal nodes decided maximal byte size program state rose jar pcc tex number backward forward edges graph 
number backward labels indicates states stored saved structure pending specifies maximal number simultaneously active overlapping forward edges flow graph 
reason specifically consider overlapping forward edges nodes forward edge clearly scanned node target scanned 
means pending constraint structure may garbage collected lightweight bytecode verification 
summarize discussion equation 
state descriptors max state lc state size state lc number backward labels greatest number simultaneously overlapping forward edges flow graph traversal 
table listed interesting memory trade offs flow graph certificate sc lc table memory tradeoffs 
scratch flash comment ce defined sc lc state reuse ce state reuse ce notice graphs connected 
depending number jumps amount certificate reuse corollary scratch memory requirements 
number states needed lightweight verify program lc 

certificate backward edge structures order perform lightweight bytecode verification data flow graph single traversal node include flow graph backward directed label set lc certificate 
furthermore predict backward directed label targeted analysis consequently garbage collect constraint structure verification ended 
kinds changes certificate overcome problem certificate constructed counter label rose jar pcc tex allow additional pass flow graph verification order record label set lc number 
suggestion cases increase certificate depending number backward edges nodes 
second suggestion forces labels stored flash ram 
reason cases mean insignificant increase space 
counts replace lc 
optimization certificate previous paragraph discussed effect changing adding information certificate 
original lightweight certificate design originally java bytecode author rose proposes certificate embeds program state component sc contain solution entry function program data flow constraint set exits 
certification approach totally eliminates need build scratch memory requires single program state allocation 
certificate placed slow memory flash eeprom design significantly increases size certificate proportional number backward edges flow graph 
section shall comment case java bytecode 

java lightweight bytecode verification purpose section specify lightweight verification concept applies java bytecode important jvm subset 

bytecode states java bytecode verification concerned type data flow analysis 
research support type set closely related javacard set java value types sun primitive types int 
types class types typename dimensional arrays class types typename int 
rose jar pcc tex java type safety type confusion closely related correspondance java subtype concept class inheritance principle referred inheritance subtyping property 
correspondance formalized subtype relation abadi cardelli meaning direct indirect subclass resulting class hierarchy outcome subtle interaction class resolution class loading bytecode verification lindholm yellin 
class resolver constructs class hierarchy allocating necessary space object heap method execution class loader takes care fetching referenced class files 
bytecode verification performs java runtime system requires method verified run 
class resolution class loading happen method bytecode verification encompassed verifier jensen 
assume subclass type context change method verified 
order lightweight bytecode analysis added type values null set java value types 
definition java types 
java type sort type inductively specified 
type tob int tob tob int tob cid null int cid cid set defined java classes order type set specified assignment compatibility relation java types lindholm yellin 
relation describes safe assign value type variable type 
words type guarantee method call prevented failing execution time 
assignment compatibility rules defines ordering type set 
definition assignment compatibility ordering 
type compatibility ordering defined type set type statements 
type type rose jar pcc tex non array types type implies 
classes cid cid cid cid implies cid cid contains reverse pointwise extension 
class cid cid null 
int null ch object 
java type compatibility ordering 
int ch object illustrated assignment compatibility ordering ch represents reversed class hierarchy 
specifically defined meaning signify value signify values 
notice interpretation somewhat opposite mainstream conventions 
chosen meanings observation subtypes correspond subclasses subclass richer structure methods fields may defined superclass vice versa 
recall content ordering class hierarchy fixed verification 
definition reality specifying family type orderings type ch indexed fixed class hierarchies ch 
simplify presentation omit index clear context 
class hierarchy obtain property corresponding type set type 
observation 
ordered set type finite lattice 
proceed shall briefly comment omitted types 
omitted types 
primitive types float types long float types long integers added compatibility lattice manner int 
rose jar pcc tex multi dimensional arrays added compatibility lattice manner dimensional arrays violating finiteness lattice array dimension java limited jvm level bytes 
ensure method may defined invoked execution time statically verify states associated java frames 
operand stack local variable table may contain java program values shall omit type description frame elements operand stack local variable table 
type description pair constitute set lightweight bytecode verification states set 
definition frame types 
frame type specified type description operand stack maximal lenght ms local variable table maximal lenght ml 
ft st ms type lt type ml ms ml define pointwise extension type 
added meaning frame type values meaning frame type value 
shall briefly comment formalization 
frame types overly general describe states possible uninitialized values stack 
frame types included sake 
notice permit frame types comparable different stack lengths 
decision follows official java specification guidelines lindholm yellin 
argued rose decision may glance unnecessary sense perspective introduce potential violation ms keep track stack lengths compared frame types 
rose jar pcc tex things fixed bytecode verification verified method class file specified class subtype context ch 
maximal stack size ms local variable table size ml method fixed 
consequence frame type ordering family type descriptions ms ml ch indexed maximal frame dimensions fixed class hierarchy 
simplify presentation omit index clear context 
observe frame type set defined finite composition types type 
type finite fixed class hierarchy finite set 
observations leads statement 
proposition 
ordered set finite lattice 

bytecode label set elementary blocks formalization shall elementary block virtual machine instruction lindholm yellin 
label set lab represented bytecode program points 
definition bytecode label set blocks 
code code ins pp 

set program points naturally limited maximal number stored byte field class file 
number added formalize initial frame type constraint 
consider instruction set sufficiently detailed facilitate compilation non trivial subset java 
non trivial features include ability create manipulate objects perform object instance method calls allow access object instance fields furthermore want able program loops control flow branching recursion exceptions 
subset fact close java card subset sun significant omission jump subroutines 
rose jar pcc tex jump subroutines mechanically unfolded separate code transformation pass prior code 
code unfolding may harder verify subroutines directly original code compared strain introducing polymorphic types formal frame described stata abadi 
specifically take consideration subroutines shown practical reality freund 
jsr primarily compile final statements exception handlers 
reasons unfolding subroutines fact common commercial practice sun pre verifier described sun 
instruction set specified follows 
definition instructions 
auxiliary sorts ins dup pop iconst null iop istore astore iload aload newarray int cid checkcast tob new cid rt void op operation add sub putfield cid id getfield cid id invokevirtual cid id rt goto pp pp ifnull pp pp return pp ireturn pp areturn pp cmp comparison eq ne lt le gt ge id identifier variable field method names 
bytecode exits function table ii specified exit function instructions instruction set 
function specified frame type transformer instruction defined java instruction semantics lindholm yellin 
columns specified follows listed left right code pp specifies instruction program point pp method code rose jar pcc tex rose jar pcc tex code pp ft code pp ft exits code pp dup st lt st ms st lt code pp pp pp pop st lt st lt code pp pp pp iop st int int lt st int lt code pp pp pp iconst st lt st ms st int lt code pp pp pp null st lt st ms st null lt code pp pp pp istore st int lt st lt int code pp pp pp astore st tob lt st lt tob code pp pp pp iload st lt st ms lt int st int lt code pp pp pp aload st lt st ms lt tob st tob lt code pp pp pp st int int int lt st lt code pp pp pp st cid int cid lt st lt code pp pp pp st int int lt st int lt code pp pp pp st cid int lt st int lt code pp pp pp newarray int st int lt st int lt code pp pp pp cid st int lt st cid lt code pp pp pp st lt st int lt code pp pp pp checkcast tob st tob lt st lt code pp pp pp new cid st lt st ms st cid lt code pp pp pp putfield cid id st cid lt cid cid st lt code pp pp pp getfield cid id st cid lt cid cid st lt code pp pp pp invokevirtual cid id 
void st cid 
lt vti cid cid st lt code pp pp pp invokevirtual cid id 
st cid 
lt vti cid cid st lt code pp pp pp goto pp ft ft code pp pp pp pp st int lt st lt code pp pp code pp pp ifnull pp pp st lt st lt code pp pp code pp pp pp pp st cid lt throwable cid cid lt pp return pp st lt rt void pp ireturn pp st int lt rt int pp areturn pp st tob lt rt tob pp table ii 
exit constraints 
ft specifies frame type expected instruction semantics 
words input frame type match ft equality instantiation free variables ft lists additional verification requirements code pp ft specifies resulting frame type application code pp ft code pp ft defined ft form exits pp specifies set data flow edges instruction pp pp specifies flow edges created exception set thrown pp 
specify initial frame type constraint program point virtual edge exits 
recall initial constraint specified empty stack self type local variable location list actual method parameter types local variable location 
definition initial flow constraint 
cid type method self ml constraint local variable table size 

tk denote static types method parameters 
exits pp cid 
tk 
ml ml constant function 
notice formalized instruction state virtual edge return instruction semantically defined resulting state 
chosen restrict definition state transformer return similar non fall instructions 

exception verification formalized exception verification manner exception thrown program point pp exception handler try range flow edge created handler 
definition exception handling 
pp pp pp pp pp pp pp pp rose jar pcc tex formalized approach exception verification conservative includes exceptions detailed analysis excluded processed associated handler 
rose formalized precise analysis type safety verified exceptions 
specify constraint set function exits method code 
definition exits function 
pp exits pp exits code pp pp dom code specified definition exits table ii 
main result states standard bytecode verification lightweight bytecode verification equivalent provide type safety guarantees 
theorem lightweight bytecode verification equivalent standard bytecode verification 
java method specified code static type context flow constraints specified exits statements equivalent 
exists solution fta dom code frame type approximation solves flow constraints exits 

exists certificate ce exits ce provable 
proof 
proposition definition lightweight hypothesis definition satisfied method code label set dom code type context 
proof follows theorem changes entry replaced fta sc lc replaced ls replaced pp 
notice false certificate transmitted altered untrusted network transfer code changed doesn match certificate longer code rejected bytecode verifier code type safe 
rose jar pcc tex corollary tamper proof 
lightweight bytecode verification technique tamper proof 
shall comment way memory algorithm 
section described memory requirements general lightweight bytecode verification case 
specific case java bytecode previous considerations hold changes lc ls number state descriptors number java type descriptors max state dimension ms ml 
number stored java types follows 
type descriptors ms ml ls ls number backward labels maximal number simultaneously active forward edges code traversal 
detailed explanation refer section 
related section report directly related verification 
section explain sun lightweight bytecode verification variant implemented kvm simulated framework 
section show lightweight bytecode verification generalization leroy proposed card bytecode verifier java cards 
section relate automated series proofs lightweight bytecode verification technique implemented klein nipkow 
general rich literature general formalizations jvm bytecode verifier barthe drossopoulou freund mitchell hartel moreau st rk 

virtual machine sun principal implementation virtual machine machine kvm sun 
kvm verifier implements original lightweight approach type safety liang rose rose jar pcc tex rose initially proposed author rose 
uses called attribute implement naive certificate contains frame type component jump target trivial instruction ones 
violates restriction certificate specified pp pp pp turn ls obsolete saved type descriptor available certificate reduces contain edges instruction immediately instruction active time 
kvm optimized single frame type descriptor variable run time cost certificate containing full frame type descriptor jump target 
kvm certificates consequently large leroy reports certificate method half size method code certifies 

card bytecode verifier leroy card bytecode verifier leroy targeted java cards works imposing series pre conditions code obtained code transformation introduce special type invariants prior type verification analysis local variables initialized modified virtual machine method entry operand stack empty jump targets type local variable constant 
consequently comparisons frame types equality tests constant jump target frame type tn constant defined need test pp ls frame type pp equal jump target frame type 
constant check pp frame type pp jump target frame type 
code subroutines jsr reproduce leroy result way rose jar pcc tex 
leroy code transformation 

add code start setting non parameter local variables null leroy case jvm known 

certificate presence certificate avoids leroy fixed point iteration compute types local variables executing lightweight algorithm uses space leroy pending saved structures maintained 
modifications avoided resulting equivalent space algorithms 
algorithm extend pp ft equivalent testing pp ft tn 
pp algorithm extend pp ft pp backwards jump test pp ft pending forward jump cases equivalent testing ft tn lack certificate card verifier approach imposes running time penalty fixed point iteration obtain local variable types card verifier safely certificate avoid 
interesting question code frame size cost card algorithm allowing reuse variable locations nested local variables compares code size cost incurred lightweight bytecode verification code size growth due unfolding jsr instructions done sun 

klein nipkow mechanically verified proofs klein nipkow formalized lightweight bytecode verification isabelle hol theorem prover klein nipkow 
certificate operate complete entry solution respect basic blocks accordance initial lightweight bytecode verification proposal rose implemented kvm cf section 
address exceptions 
certificate specifies frame types jump targets space bound collapses constant kvm authors find analyzing algorithm high level functional language 
rose jar pcc tex main goal klein nipkow mechanically prove type safety result verified isabelle hol similar theorem 
furthermore isabelle hol formalization executable achieved executable lightweight bytecode verifier 
klein documented exceptions object initialization mechanically proven type safe 

formally defined lightweight bytecode verification pcc approach constraint data flow analysis 
approach exploited stage java bytecode verification perform safely untrusted network small platform straight code pass important java subset 
lightweight bytecode verification resulted important industrial applications device pre verifier device verifier certificate specification implemented sun kvm smart cards 
technique formally proven tamper proof sense clever conversion certificate program unsolvable constraint set appear solvable 
java bytecode notion tamper proof translated formal proof states conversion lightweight bytecode certificate result type unsafe bytecode pass lightweight verifier 
obtained unified description kvm leroy java card verifier general lightweight bytecode verification described 
particular naive certificate frame types jump target type safety verification cases requires exactly frame type scratch ram 
directions run mobile code elaborate java platforms cost bytecode verification noticeable standard systems bracha proposed develop kvm verifier standard java platform 
plan java community happen 
interesting projects relation bytecode safety investigate replace existing runtime checks static checks enrichment java type system 
attempt investigation represent field protection rose jar pcc tex information type system rose rose options investigated 
ph thesis supervisor jean goubault xavier leroy interest comments earlier stages java lightweight bytecode verification thesis subject 
rose earlier collaboration accounted rose rose particular valuable comments final draft 
appreciate valuable input content style anonymous referees 
gie inria rocquencourt france having initiated hosted project 
abadi cardelli theory objects monographs computer science 
springer verlag 
anderson cryptosystems fail 
comm 
acm 
barthe sousa yu formalization coq java card virtual machine 
drossopoulou eisenbach jacobs leavens ller poetzsch heffter eds formal techniques java programs ecoop workshop 
sophia antipolis france 
bracha java class file specification update 
jcp org en jsr detail id 
chen java card technology smart cards java series 
addison wesley 
colby lee necula blau cline certifying compiler java 
acm sigplan notices 
proceedings acm sigplan conference programming language design implementation pldi 
colby necula lee proof carrying code architecture java 
proceedings th international conference computer aided verification cav 
chicago usa 
drossopoulou eisenbach khurshid java type system sound 
theory practice object systems 
freund costs benefits java bytecode subroutines 
eisenbach ed formal underpinnings java oopsla workshop 
vancouver bc canada 
freund mitchell formal framework java bytecode language verifier 
acm conference object oriented programming systems languages applications 
hartel moreau formalizing safety java java virtual machine java card 
acm computing surveys 
rose jar pcc tex jensen le tayer thorn formalisation visibility dynamic loading java 
iccl 
published irisa technical report october 
kildall unified approach global program optimization 
conference record acm symposium principles programming languages 
boston massachusetts pp 

klein verified java bytecode verification 
ph thesis institut informatik technische universit nchen 
klein nipkow verified lightweight bytecode verification 
concurrency computation practice experience 
invited contribution special issue papers formal techniques java programs ecoop workshop 
klein nipkow verified bytecode verifiers 
theoretical computer science 
appear 
leroy java bytecode verification overview 
computer aided verification cav vol 
lecture notes computer science 
pp 
springer verlag 
leroy bytecode verification java smart card 
software practice experience 
liang sun new verifier 
personal communication mail 
explains kvm verifier implements verification 
lindholm yellin java virtual machine specification java series 
addison wesley 
lindholm yellin java virtual machine specification java series 
addison wesley second edition 
mcgraw felten java security hostile applets holes 
john wiley sons 
necula proof carrying code 
popl th annual acm symposium principles programming languages 
sigplan notices 
necula lee safe kernel extensions run time checking 
osdi second symposium operating systems design implementation 
seattle washington 
nielson nielson hankin principles program analysis 
springer verlag 
connell java inside story 

sunsite sk java html 
rose bytecode verification java card 
abadi ed workshop security languages 
palo alto california 
rose de code octet de la machine java 
formalisation implantation 
ph thesis se 
paris vii place de jussieu paris cedex france 
available www 
net thesis submitted pdf 
rose rose lightweight bytecode verification 
eisenbach ed formal underpinnings java oopsla workshop 
vancouver bc canada 
rose rose java access protection typing 
concurrency computation practice experience 
ecoop workshop formal techniques java programs 
st rk schmid rger java java virtual machine definition verification validation 
springer verlag 
rose jar pcc tex stata abadi type system java bytecode subroutines 
cardelli ed proceedings fifth annual acm symposium principles programming languages 
san diego california acm 
sun java frequently asked question java come 
www ibiblio org html 
sun java platform micro edition 
java sun com 
sun java card platform 
java sun com products javacard javacard html 
sun java platform micro edition technology creating mobile devices 
java sun com products wp pdf 
sun secure computing java 
java sun com marketing collateral security html 
white 
taivalsaari connected limited device configuration 
jcp org en jsr detail id 
rose jar pcc tex 
