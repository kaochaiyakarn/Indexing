operations records luca cardelli john mitchell digital equipment department computer science systems research center stanford university define simple collection operations creating manipulating record structures records intended finite associations values labels 
second order type system operations supports subtyping polymorphism 
provide typechecking algorithms limited semantic models 
approach unifies extends previous notions records bounded quantification record extension parametrization row variables 
general aim provide foundations concepts object oriented languages framework typed lambda calculus 
appears theoretical aspects object programming gunter mitchell eds 
mit press 
appears mathematical structures computer science vol pp 
src research report august 
revised october 
digital equipment 
may copied reproduced part commercial purpose 
permission copy part payment fee granted nonprofit educational research purposes provided partial copies include notice copying permission systems research center digital equipment palo alto california acknowledgment authors individuals contributors applicable portions copyright notice 
copying reproducing republishing purpose shall require license payment fee systems research center 
rights reserved 

object oriented programming record structures called objects intended named collections values attributes functions methods 
page collections objects form classes 
subclass relation defined classes intention methods appropriately members belonging subclasses class 
property important software engineering permits fact extensions systems subclasses requiring modifications systems 
object oriented language simula ones see typed simple extensions type rules pascal languages 
extensions mainly involve notion subtyping 
addition subtyping interested powerful type systems smoothly incorporate parametric polymorphism 
type systems record structures received attention 
provide foundations typing object oriented languages data base languages extensions 
cardelli basic notions record types intended defined context order type system fixed size records 
wand wand introduced concept row variables trying solve type inference problem records led system extensible records limited second order typing 
system refined shown principal types jategaonkar mitchell wand 
resulting system provides flexible integration record types milner style type inference milner 
cardelli wegner defined full second order extension system fixed size records techniques mitchell 
system program polymorphically subtypes record type preserve unknown fields ones record parameters input output 
natural functions expressible 
example nature fixed size records way add field record preserve unknown fields 
obviously function updates record field purely applicative sense making modified copy forced remove unknown fields result 
imperative update requires careful typing analysis 
describe second order type system incorporates extensible records solves problem expressing natural functions mentioned 
believe second order approach presentation record types natural 
general idea extend standard second order higher order type system notion subtyping types 
record types introduced specialized type constructions specialized subtyping rules 
new constructions interact rest system 
example row variables fall naturally second order type variables contravariance function spaces universal quantifiers mixes record subtyping 
moving second order typing give principal type property weaker type systems exchange additional expressiveness 
importantly gain perspective space possible operations records record types unencumbered temporarily questions type page inference 
clear bounds expressiveness may lie perspective prove useful comparisons understanding 
part informal introduces main concepts problems means examples 
formalize intuitions collection type rules 
give normalization procedure record types show soundness rules respect simple semantics pure calculus records 
discuss applications extensions basic calculus 

informal development looking formal system describe informally desired operations records justify rules expected hold 
final formal system subtle explanations useful understanding 
give simple examples records operations context object oriented languages 
record values record value intended represent intuitive semantic sense finite map labels values values may belong different types 
syntactically record value collection fields field labeled value 
capture notion map labels record distinct 
labels identify fields fields taken unordered 
notation empty record 
true record fields labeled equivalent true 
basic operations record values 
extension adds field label value record provided field label 
condition enforced statically 
write 
restriction removes field label record write xy extraction extracts value corresponding label record provided field having label 
condition enforced statically 
chosen operations fundamental constituents complex operations 
alternative considered wand replace extension restriction single operation modifies adds field label depending field label 
system extension operation required check new field record absence guaranteed statically 
restriction page operation task removing unwanted fields fulfilling guarantee 
separation tasks advantages efficiency static error detection fields overwritten unintentionally extension 
comparison systems wand jategaonkar mitchell possible reasonable fragment language practical type inference algorithm 
simple examples 
symbol value equivalence means expressions denote value 
page extension true true true restriction cancelling true true effect true extraction invalid extension invalid extraction useful derived operators defined terms ones 
renaming def changes name record field 
overriding def overriding replaces value possibly unrelated type extends compare wand 
adequate type restrictions seen updating operator method overriding operator 
write 
obviously records constructed empty record extension operations 
fact formal presentation calculus regard syntax record fields abbreviation iterated extensions empty record def true def true definition allows express fundamental properties records terms combinations simple operators fixed arity opposed ary operators 
schemas ellipses formal treatment 
lacks field label formulate definition expressions true true true forms match better similar definition record types section 
record types describing operations record values positive assumptions form field label occur record negative assumptions form field label occur record 
constraints verified statically embedding type system record types convey positive negative information 
positive information describes fields members record type 
members may additional fields 
negative information describes fields members type 
members may lack additional fields 
note positive negative information expresses constraints increasing kind information lead smaller sets values 
smallest amount information expressed record type fields denotes collection records records fields lack fields 
type called total record type 
type records 
contains 
type records lack fields label true 
int bool type records fields labels values types int bool 
true true str 
int type records field label type int field label str true 
record type characterized finite collection positive type fields labeled types negative type fields labels simply say fields type fields 
positive fields distinct labels unordered 
negative fields unordered 
assumed far types normalized positive negative labels distinct positive negative fields may cancel described shortly 
record values basic operations record types 
extension type denotes collection obtained adding fields values possible ways provided elements fields 
precisely collection records provided positive type field 
condition enforced statically 
write 
section consider ground record types containing record type variables 
page restriction type denotes collection obtained removing field elements 
precisely collection records write xy extraction type denotes type associated label provided positive field 
condition enforced statically 
derived operators defined terms ones 
renaming def changes name record type field 
overriding def type field overriding replaces field type extends adequate type restrictions override method type class signature record type specialized produce subclass signature 
crucial formal difference operators types similar ones values type restrictions cancel easily example smaller set 
consequence type restriction making type extension seen examples extension operator needs proof extension label missing 
symbol type equivalence means type expressions denote type 
page int int extension int bool int bool int bool int restriction cancelling int bool int bool effect int bool int extraction int invalid extension int int invalid extension int invalid extraction helps read examples terms collections represent 
example example restriction says take collection records possibly fields remove field elements collection obtain collection records field possibly fields field 
particular obtain collection records possibly fields include way positive negative information formally manipulated easier understand regard record types abbreviations record values int def int int bool def int bool considering bool expansion bool allow outside positive negative labels cancel left words inner restriction reminds fields eliminated 

deceptive think record fields record type fields necessarily contained example collections incomparable 
example think type fields true 
general fails example collections incomparable causes collections fields 
deceptive think fewer type fields general contained containment true false opposite true collections incomparable 
observations appear conflict previous assertion positive negative information things smaller 
assertion true normalized record types arbitrary applications operators may cancel 
shall study normalization process section 
record value variables understanding record types introduce record value variables declared record type 
example means field means field type formed record expressions formulated precisely record value variables write function abstractions 
function increments field record adds field int int int function requires argument field field type int int int follows int int true true int int page application uses non trivial fact int matched parameter type precisely course equivalent 
second application noticeable reasons 
uses non trivial fact true int second extra field preserved result value way defined 
third extra field preserved result type fixed result type shall come back problem 
page 
alternative syntactic notation lines jategaonkar mitchell pattern matching record parameters rr rx int int rr rx actual parameter match shape record field collection remaining components lack variables rr rx bound appropriate components body rr acquires assumption contain fields 
non trivial details pattern matching presence subtyping 
main objective illustrate fundamental ideas choose simpler syntax 
record type variables previous section introduced record value variables record types impose restrictions values bound variables 
want introduce record type variables order write programs polymorphic collection record types 
similarly need express restrictions admissible types variables bound restrictions written subtype specifications 
write subtype specifications predicate meaning subtype words value value typing rule condition called subsumption play central role formal system 
subtype assumptions better formulate restrictions record type operators may write polymorphic version function previous section int int function expects type parameter subtype int actual value parameter type example application int bool true true int int bool note bound int bool subtype int required 
second true type int bool required 
third result type obtained instantiating int bool int int int bool definition 
note extra field forgotten result type time extra fields carried input output type type variable advantage writing polymorphic style 
type 
write type simple function arrows free variable bind 
want mark precise location binding occurs permits types expressed 
explicit bounded universal quantifier int int reads naturally types subtypes int function int 
scope quantifier extends right possible 

notice freedom typing polymorphic function example chosen typing int int int bool true int int bool typing turns incomparable previous general best way typing expression 
studied aspect system carefully 
subtype hierarchies operations record types record values easy define new types values reusing previously defined types values 
example want express subtype hierarchy shown diagram various entities combination coordinates radius color define type independently point real real colorpoint real real color disc real real real page page real real real color explicit definitions scale easily large hierarchies convenient define type terms previous ones point real real colorpoint point color disc point real colorpoint real note point color formed members point may label 
section shall examine way defining hierarchy example deriving point colorpoint retracting field 
colorpoint point disc similarly record values defined reusing available values point cp colorpoint green cd cp disc cd notice subtyping relation depends structure types types named constructed 
similarly record values belong record types uniquely structure independently declared constructed 
observation context point point point contain point incomparable point point requires int point forbids 
update problem type system records described previous sections initially motivated single example involves typing update function 
updating intended functional sense creating copy record modified field discussion relevant imperative updating 
problem define function updates field record returns new record type function argument function subtype expected input type result related subtype 
type information regarding additional fields lost updating 
seen bounded quantification useful respect 
pretty clear body function look example input boolean field negated write abbreviation overriding operator preserves additional fields expect typing preserve subtype information desired update bool words expect update function subtype bool 
typing derivable rules worse semantically unsound 
see assume type true bool unique element true follows true true bool bool bool alternatively bool bool update true true false true update produces obviously incorrect result type 
general function result type fixed range restrict output arbitrary subtype subtype parameter 
avoid problem update result type result 
correct typing comes naturally typechecking body update rules construct involved note shape result type matches shape body function update bool bool update true true false true bool bool outcome overriding operator types involves manipulation negative information necessary express type update functions 
bounded quantification sufficient 
type turns contain identity function natural semantic models bruce longo 
example take int subranges subtypes int 
function type int singleton type true may artificial argument reformulated proper inclusion types 
page instantiated identity identity int 
complication manifests updating acts deep structure preserve type information subtyping occurring multiple levels 
body function negates field record type bool page correct typing lose information subtypes simpler typings 
need introduce additional type parameter order type variables result type avoid possible ways losing type information bool bool course clumsy need additional type parameter additional depth level updating 
fortunately avoid extra type parameters extraction types typing comes naturally typechecking body rules construct bool bool output type complex inferred input natural 
function true true false bool provided argument type subtype bool possible ways 
complexity update problem manifests functional case simpler solutions available imperative case 
simpler type systems records cardelli wegner may adequate imperative languages properly extended imperative constructs sketched 
imperative updating operator additional constraint new record type old record intuitively updating done place 
requirement produces similar typing initially shown unsound 
assignable fields identified var update var bool soundness recovered requiring assignable fields covariant contravariant 
true bool imply var true var bool blocking counterexamples soundness 
imperative update natural requirement changing type record leads simpler typing 
approach completely solve problem discussed section 
imperative update provide functionality polymorphically extending existing records added problems discussed functional update 

formal development acquired intuitions discuss formal type inference rules detail 
define judgment forms environment structures 
look inference rules individually analyze properties 
provide set theoretical semantics pure calculus records 
judgments inferences judgment inductively defined predicate environments value terms type terms 
judgments formalizing system env environment type type subtype type equivalent types equivalent values type formal system set inference rules expressed finite set antecedent judgments side conditions horizontal line single judgment line 
inference rules rule schemas meta variables instantiated obtain concrete inferences 
typographical reasons write side conditions schemas part antecedent 
environments environment finite sequence unconstrained type variables type variables constrained subtypes type value variables associated type 
dom set type value variables defined environment 
env env env env dom type dom type dom apple env env env env page legal environment obtained starting empty environment apple extending finite set assumptions type value variables 
note assumptions involve distinct variables allow multiple assumptions apple push general discipline conjunctive types 
assumptions variables extracted formed environments var var var var env env env env type type legal inferences take place formed environments 
judgments recursively defined terms judgments 
example typing judgment type constructing environments vice versa formed environments involved constructing types 
consider remaining judgments turn 
record type formation collection rules determines record types formed 
interdependence section ones equivalence rules assumptions involve subtyping discussed 
fortunately assumptions fairly simple full understanding subtype relation required point 
env type type type type type shown discussed informally legal record types type records record type variable var previous section extension record type provided restriction record type extracting component record type label produces legal type 
general subtype type records explains hypothesis rule 
rule guarantee record field 
record type equivalence record types equivalent 
discuss formal rules answering question 
type equivalence relation reflexive wellformed expressions symmetric transitive denoted symbol 
substituting equivalent types third type produce equivalent result called congruence property requires number rules fully page formalized listed section 
consider cases equivalence extended restricted extracted record types 
extended record types equivalent reorder fields identical recursively equivalent 
simple fact expressed rule 
number applications rule congruence property may necessary adequately reorder fields record type 
te xy type similarly reorder restrictions 
double restriction xx reduces fact expressed slightly general form assumption sufficient deduce te te xy yx interesting rules concern distribution restriction extension 
outside restriction inner extension variable cancel 
restriction pushed inside outside extension different variable 
te te type type note situation cancellation swap occur 
inner restriction may needed guarantee extension sensible redundant 
record extraction equivalent extracted type te te type type te equivalence rules direction interpreted rewrite rules producing normal form record types normalization investigated section 
page record subtyping seen subtyping central notion abstracting record type variables intuitively justified valid subtype assertions 
section take rigorous look subtype relation 
subtyping pre order reflexive transitive relation 
substitutive type equivalence relation discussed previous section require page reflexivity special case 
natural require subtyping anti symmetric obtaining partial order 
reasonable semantics subtyping fact construct partial order 
strong require anti symmetry type rule 
systems anti symmetry may introduce obscure ways proving type equivalence systems may provable rules 
anti symmetry useful typechecking include 
basic intuition subtyping behaves subset relation expressed subsumption rule claims element element 
feel strongly subsumption included type system rule gives object oriented programming flavor 
satisfied programming purposes emulating subsumption explicit coercions 
technique interesting adequate providing semantics language subsumption breazu tannen curien ghelli satisfactory exhibit model satisfies subsumption directly 
combining obtain standard type rule rule normally taken primitive derived 
ready talk subtyping record types 
helps break problem pieces ask subtypes total record type extended record type restricted record type record type extraction case 
record type subtype total record type 
subcases total record type course subtype simply consequence formed extended record type subtype formed restricted record type subtype 
rules corresponding respectively type case 
subtype extended record type extended record type provided respective components subtype relation condition says produce subtype weakening type field 
condition tells produce subtype weakening fields inductively requiring presence additional components requiring absence additional components example able derive yx case 
subtype rule restricted types semantically straightforward occurs occurs 
rule looks innocent hides interesting subtlety assumption 
analyze cases 
cases restrictions variable straightforward 
similarly simple cases matching extensions containing containing field 
suppose positive field example case erroneously conclude false 
fortunately flaw argument assumption requires false 
note leads similar contradiction page page legal instance assumption conclude correct 
case 
consider subtypes record type extractions situations form generally assumption 
converted form extraction simplifies special rule required deduce type variable example rule necessary says field type subtype possibly equal 
subtyping rule consider 
record field described type described field described inclusion inverse inclusion necessarily valid natural require shall see 
rule derivation provides symmetrical version derived rule absence derived rule taken primitive replacing 
record typing equivalence seen rules type equivalence subtyping rules record values follow naturally 
subtle point empty record 
able assign type lacks set labels 
obtained repeatedly applying rules env remaining constructions record values typed corresponding constructions record types appropriate assumptions previous section rule derive symmetrical version examine rules record value equivalence 
rules formally similar ones discussed record type equivalence record extensions permuted record components extracted restrictions permuted pushed inside extensions cancelling 
main formal difference rules types equate 
restriction completely eliminated variable free records 
formal similarity omit detailed discussion complete set rules type system follows section 
type rules summarize complete rules record types values selected auxiliary rules 
rules designed immersed secondorder calculus bounded quantification see cardelli wegner possibly recursive values types 
list names rules discussed 
environments env env var var general properties page formation subtyping page elimination type congruence tc tc tc env type tc tc type equivalence te te value congruence vc vc vc env vc vc value equivalence xy env xy yx xy special rules sections discuss rules vc te valid respect particular semantic interpretations 
vc te presence te rule redundant rules tc vc implied simpler tc vc 
properties tc vc lemma type env 
env 
proof simple simultaneous induction derivations base case 
lemma type type 
type type 
proof show simultaneously induction derivations 
hardest case te 
hardest te 
substantially simpler 
prove te leave remaining cases reader 
prove te assume xy type 
may derive xy transitivity type 
goal show subtype transitivity te type congruence rules give 
te transitivity original hypotheses easy show allows derive may obtain type 
page page proof type similar 
sample derivations show main steps derivations carried system assuming rules typing basic constants 
example simply builds record fields natural type 
const int int int const true bool true int bool def true int bool derive non trivial type inclusion 
construct record types different lengths sides start basic asymmetry build symmetrically direct way 
int int bool bool int bool bool def int bool bool show record lacks label 
time key rule 
type equivalence rules rearrange type standard form 
const int int te tc int te int def int show removing label obtain subtype 
basic asymmetry provided 
int int int int te tc int int te int int def int int semantics pure calculus records stated intent define second order type system record structures 
models system complex outside scope 
section provide simple set theoretical model pure calculus records additional functional polymorphic structure 
intent show plausibility inference rules records proving soundness respect natural model 
model natural embodies strong set theoretical intuitions subtyping seen subset relation records seen finite tuples 
model extend complex language features exhibits kind simple minded usually sound reasoning guides design implementation object oriented languages 
syntax start language implied type rules section 
basic non record values expressible calculus arbitrary choices get started 
consider extension pure calculus collection basic ground type symbols arbitrary collection subtype relations 
incorporate new symbols calculus add rules preserve lemmas env env type appropriate simplicity introduce value constants environments containing assumptions form construct model extended calculus 
semantic domains rely largely context distinguish syntactic expressions semantic expressions identify terms denotations 
start choosing fixed set labels collection sets corresponding type symbols subtyping axiom 
page simplicity assume element finite partial function record shall see shortly 
assumption useful define subtype relations sections 
serves type records need value space closed record formation 
property may accomplished regarding records finite functions values ranked values rank 
fin set partial functions finite domain indicate partial function undefined indicate defined define set records rank set values rank follows page fin fin set records set values essential properties construction summarized relationship fin clear construction see fin show fin fin dom finite range converse follows fact fin fin summarize notation describe semantic interpretation syntactic constants operators apple def provided def provided dom 
defined provided dom 
lemma empty record apple element 

defined 
defined proof empty function finite function 
remains finite partial function 
suppose dom defined function belongs fin defined types type operations types interpreted subsets global value set type values type records 
subtyping interpreted set inclusion 
introduce notation operations record types def def undefined def lemma conditions stated sets subsets sets subsets proof 
set functions fin dom 

interpretation judgments assignment partial map type variables subsets ordinary variables elements say assignment satisfies environment conditions satisfied type defined assignment 
similarly indicate value term assignment free variables 
judgments system interpreted follows 
env initial segment satisfies type satisfying satisfying satisfying satisfying page page satisfying type value expressions interpreted apple soundness show semantics satisfies type rules 
precisely consider system consisting rules listed section special rules vc te 
theorem soundness inference rules system sound respect interpretation judgments section 
proof see appendix 
construction giving type equivalence rule natural semantically 
simplifies types associated override operation application extensional models studied section 
te simple model described section easy see required reason record component remaining components 
necessarily true combination rx occur single record example set records true false clearly subset int 
records false true appear category theoretic terms equation says product section variant construction section rule te sound 
ultimately interested polymorphism bounded quantification construct model semantic type defined 
construction uses collection values allows certain subsets types 
way eliminate sets records violate te 
value space satisfying fin constructed section 
natural number define collection subsets wish consider types stage stage may select subsets provided include ground types 
definiteness take 
define record types preceding types 
stage take record types defined finite set labeled component types finite set absent labels 
component type belong preceding stage 
construction may clarified auxiliary definition 
suppose fin finite partial function labels types stage fin finite set labels disjoint domain set records components components absent defined 
define set record types stage set suitable function absent set fin fin dom apple note apple apple belongs collection types defined defined set values type 
possible include desired 
natural consider set records fin fin record type define rt collection record types rt def fin fin dom apple page note apple apple rt rt maximal element 
may show precisely union record types rt 
page lemma fin fin dom apple rt proof suppose fin fin domain finite fin model interpret judgments type variables type expressions denote elements consider elements types define relation semantic subtype iff simplifying assumption section ground type contains records know subtype element rt 
assumption subtype accidentally cause te fail 
may show non empty rt function set determined uniquely 
lemma rt non empty 
dom dom proof suppose rt non empty know 
construction dom dom 
dom dom implies 
consider function defined function belongs dom dom 
dom dom 
construction def 
implies appropriately chosen 
choose def apple define function belongs 
assume dom 
allows write non empty record type rt ambiguity 
lemma demonstrates defined type 
straightforward show record types closed restriction extension lemma record type 
proof straightforward 
lemma proof definition 
easy check belongs conversely 
semantic subtyping relation record types determined absent information 
lemma iff dom 
proof assume easy check definition similarly 
definition types 
converse straightforward 
point model construction give record type prove equation 
preceding lemmas proof immediate 
page page lemma rt record type 
proof know finite function finite set preceding lemmas 
follows 
soundness theorem 
system system theorem plus rule te 
theorem soundness inference rules system sound respect interpretation judgments 
proof see appendix 
extensional model construction inference rule gives extensional equality records vc intuitive reason adopting rule belong indistinguishable 
fact assume differ label distinguish typed simply remove difference 
addition giving equations records type rule vc implies extensionality property 

iff straightforward proof uses value congruence rules 
recall previous models record type simply set records equality records independent type 
distinct records unequal elements causing vc fail 
section construct model pure record calculus satisfying te vc 
clear construction te essential know construct extensional model satisfying vc requiring record types satisfy 
main te lies showing record type extensional equality defined extensional record types 
value space satisfying fin constructed section define types certain partial equivalence relations abbreviated see longo moggi 
binary relation symmetric transitive necessarily reflexive 
element type defined equivalence class values 
subtyping set containment partial equivalence relations bruce longo consider certain types 
type records interpreted type element single equivalence class contains records records equivalent vc holds 
operations record types defined follows record rrr relation iff writing imply 
define relation def rrs rrr define relation def rrs easy show hypotheses partial equivalence relation necessarily transitive 
cause problems turns restricting class record types collection satisfying te guaranteed types 
types defined stages 
collection 
partial equivalence relations relate records 
typical choice identity relations ground types 
finite partial map set fin disjoint domain define page page iff 
note similarity subsets represent subset definitions coincide 
easy see earlier definition record types stages define fin fin dom apple construction character previous non extensional added complication establishing defined easily seen showing easy prove lemma model showing need consider stages construction arguments 
lemma fin fin dom apple define collection record types rt 
subtyping interpreted iff functions absent sets show rt rrr 
lemma rt rt rrr proof lemma trivial apple assume apple 
rp rp 
see suppose records rs 
follows rp show converse assume rp note apple easy see 
assume rrr 
rp remains show 
exist rrs 
definition rp follows converse assume apple exist lemma rt rrr proof lemma trivial apple 
show 
straightforward 
easy matter show analogs lemma lemma 
conclude basic properties construction 
system system theorem plus rules te vc 
theorem soundness inference rules system sound model construction 
proof see appendix 
update operator extensional models useful characterize natural form record update denoted functional update 
discussion relevant typing imperative update models directly capture sideeffects 
functional update operator introduced simple definition 
want def provided exists modify type field 
sufficient assumptions derive typing def quite satisfactory expect result type meaning type record modified updating fields value correct type 
fortunately te derive expected type rule page page upd compelling reason adopting te impact important operator updating 
note upd rule strong applies variable 
derive natural general rule upd 
tempted weaken assumption strengthen 
valid undesirable unable update field original contents 
strong upd rule expressible types apparently natural variation unsound example take bool true true bool false bool derive false true 
normalization decidability basic ideas record calculus relatively simple formal system quite rules 
consequence easy see inspection determine supposed type formed record expression type section show basic properties calculus decidable relatively natural algorithms 
process show type expression unique normal form modulo permuting order fields typable record expression principal type suitable environment 
properties consider deciding supposed environment formed formed type expression quick glance formation rules shows order determine type wellformed able decide apparently simple properties assuming type derivable want know exist 
consider 
develop simple method easy check type environment formed 
derivable type define labeled tree tree type edges labeled field names vertices labeled finite sets field names vertex tree type call finite set field names absent set intuitively path root tree type absent set vertex designated path 
type 
convenient notational shorthand write 
path empty path may write edge leading root tree root subtree call root edge 
define tree type induction length length type constant 
case define tree apple type single node empty absent set 
context induction form type expressions tree type tree type tree type tree type tree type obtained tree type tree type making subtree root root edge labelled removing absent set root 
tree type obtained tree type deleting subtree root edge labeled adding absent set root 
tree type subtree tree type located root edge labeled context definition tree type case tree type empty tree 
context tree type tree type concludes definition 
page clauses defining tree type tree type assumed certain properties tree type 
justified lemma 
page lemma suppose type tree type 
path type 
absent set position proof induction derivation case apple type 
trivial 
cases type type induction hypothesis property judgment env case type 
induction hypothesis type follows repeated transitivity case type 
vacuous 
cases type type 
case 
trivial 
induction hypothesis absent set 
case yp 
te induction hypothesis type 

te induction hypothesis type 
case type type 
case 
subcases case type follow 
result follows 
case absent set tree type xy know xy case 
path tree type follows induction hypothesis symbol te lemma follows congruence rules 
cases type type 
straightforward induction hypothesis 
case type 
induction hypothesis 
preceding lemma shows path absent information provided tree type sound respect proof rules calculus 
proof rules sound respect semantics follows assertions form determined tree type semantically sound 
may show assertions semantically complete 
follows preceding lemma proof rules semantically complete deducing assertions form exists assignment satisfying 
lemma suppose type tree type 
semantic model assignment sequence labels path record undefined 
path absent record absent set vertex located proof may model constructed section single ground type example 
environment define assignment type iff path tree type 
straightforward 
easy verify vertex tree type absent set child edge labeled imply part lemma 
constructing trees absent sets relatively easy decide purported environment type expression formed 
basic idea simply check env type reading environment formation rules backwards 
gives mutually recursive procedures rely tree type checking hypotheses 
theorem environment expression mutually recursive procedures decide env type 
problems consider formed types type type type equality may prove subtyping assertions depend choice type equality rules 
definiteness assume te 
similar results hold te checked details 
type evident directing type equality rules may rewrite normal forms type variable 
type variable 
page page considering tree type type variable exactly labels root edges absent set root 
normal form 
semantics section meaning type expression form record type dom meaning may construct models type empty assignments type variable denotes different type may show type expressions provably semantically equal iff normal forms modulo differences order field names component types 
lemma may see semantically iff property allows decide semantic subtyping normalizing type expressions comparing outer forms recursively examining corresponding component types 
steps algorithm correspond derivations proof system completeness proof rules type equality subtyping assertions follows 
theorem type type straightforward algorithms determine proof rules semantically complete deducing type equality subtype assertions 
final algorithmic problem type expression determine decide type subtype suffices compute minimal type check record expressions minimal type 
stems fact sequence labels obtain smaller type adding labels 
get problem type schemas contain sequence variables 
show typable record expression scheme type supertype instance allows test record expression type 
sequence variables schemas 
scheme sequence variable say type type obtained replacing sequence labels including empty sequence 
type useful algorithm attempts compute substitution instance possibly containing sequence variables instance exists returns smallest 
instance exists algorithm fails 
algorithm uses extension tree type schemas details omitted 
may compute principal type schema pts formed environment expression follows pts fresh sequence variable pts pts pts defined fail pts pts pts pts pts theorem env expression pts succeeds producing instance pts fails 
furthermore pts type easy compute smallest instance instance subtype concludes investigation decidability properties 
leave extensions properties functions polymorphism 

applications extensions ask go trouble defining subtle extension restriction operators adopting override operator primitive wand 
particular explicit handling negative information introduce complexity 
answer negative information necessary proper understanding override operator 
example notion absent fields critical account overriding 
worthwhile investigate negative information formalized separate operator 
pragmatic answer overriding really performs different actions different situations extends record updates 
methodological point view single override operator undesirable may silently destroy information 
separate extension operator preferable type error occurs attempt destroy existing field 
separate update operator preferable normally want update field value totally different type 
programming language probably want replace override operator separate operators extension updating discussed section 
restriction operator really intend delete field 
page admittedly restriction ambiguous may may remove field depending field 
possible define safe restriction operator produces type error restricted field 
unfortunately find way completely eliminating need general restriction types operator necessary express crucial formedness conditions 
said ready investigate useful derived operators 
override operator override operator def certainly natural fact exclusively examples 
derived type rules operator described simple especially consider subsystem overriding extraction 
rules mixing overriding restriction interesting 
recall definition override operator page def def rules simply derivable rules basic operators assume te extension need primitive 
formation subtyping type type type type elimination type congruence type equivalence type type type type type value congruence value equivalence rename operator may consider rename operator shows interesting types 
def def rules operator easily derived 
interesting questions renaming identical variable produces equivalent value type equivalences derivable arbitrary te recall satisfied models te holds 
similar surjective pairing rules calculus 
alternative involving surjective pairing axiomatize renaming operators independently 
page retraction operator forgetting information seen negative information considered additional information 
ask way retract information positive negative 
convenience necessity avoid introducing information place retracting 
interesting investigate possibilities 
able formulate operators independently retract positive negative information describe operator retracts information label type 
operator works purely type information corresponding operator values 
retraction operator means forget record type rules enforce cancellation information formation subtyping page type type equivalence env xx xy yx type type main consequences values involve rule subsumption rule allowed forget information conclude interesting inferences say restriction values seen retraction operator restriction operator 
going back previous example section see usefulness retraction operator defining hierarchies inverse order real real real color colorpoint disc point colorpoint note restriction operator produce desired results 
concatenation operator concatenation prime candidate primitive operator calculus records 
unfortunately operator difficult handle difficult chosen extension restriction primitive notions 
discuss main problems 
type hierarchies naturally expressed concatenation operator types example define colorpoint disc corresponding operator values type guarantee derive succesful unambiguous way execute run time 
conditions see concatenation fundamental conflict subsumption rule 
consider function int bool int int bool bool true explicit conflict definition typecheck 
decide field produce result type result value 
popular choice perform left right left overriding common fields similarly run time 
run time overriding run difficulties int bool int bool true false assume definition give satisfies equation int bool int bool typed 
run time overriding invocation 
result type left override right right override left overriding 
option give run time error defeat purpose typechecking option compile special code types pick field field page overriding additional fields deal polymorphic case 
idea runs difficulties page int int int bool bool bool true false true computed overriding get wrong result 
making compatible behavior require violating basic rules beta conversion rules type parameters 
difficulties feel compelled define disjoint field element absent element vice versa 
unfortunately way axiomatize notion drastically changing type system record types non empty intersection element intersection exhibited subsumption rule 

investigated theory record operations presence type variables subtyping 
intent embed record calculus polymorphic calculus providing full second order theory record structures types 
investigated type inference problem calculus provided typechecking subtyping algorithms 
models basic record calculus full second order model left 
result flexible system typing programs manipulate records 
particular polymorphism subtyping incorporated full generality 
expect theory useful analyzing fundamental aspects objectoriented programming 
acknowledge longo moggi clarifying discussions 
appendix appendix contains soundness proofs semantic interpretations 
semantics pure calculus records system consists rules listed section special rules vc te 
theorem soundness inference rules systems sound respect interpretation judgments section 
proof induction length derivation judgments 
environments env 
vacuously true 
env 
vacuously true 
env 
hypothesis type satisfying formed lemma formed 
env 
similar env 
variables var 
satisfies definition 
var 
env satisfying satisfying yield 
var 
similar var 
var 
env satisfying satisfying yield general 
satisfying 

transitivity subset 

satisfying 

symmetry equality 

transitivity equality 

satisfying 

satisfying 
formation 

satisfying lemma 

lemma 

lemma 
page page subtyping 
satisfying set finite functions fin dom 
fin 



suppose 
means 



suppose 
follows 

suppose 


suppose 

follows 

apple 

satisfying empty function apple apple apple 

dom defined lemma belongs lemma 
elimination 
satisfying dom 
lemma 

record 
type congruence tc 

tc 
satisfying 
tc 
suppose 
tc 
suppose 
tc 
suppose sets functions dom 
type equivalence te 
suppose satisfying dom 

te 
set dom 

te 

te 
suppose dom 

te 
suppose 

te 
suppose 
te 
suppose 

te 
suppose value congruence tc 
apple apple tc 
satisfying 
tc 
suppose dom dom 
case 
tc 
suppose case 
tc 
suppose case 
case value equivalence 
suppose satisfying dom 

apple apple 

suppose 
dom 

suppose 


suppose dom 

suppose dom 

suppose page page dom 

suppose dom 

suppose dom dom 

suppose 
formed member 
construction giving system system theorem plus rule te 
theorem soundness inference rules system sound respect interpretation judgments section 
proof proof follows general pattern theorem 
main new properties needed proved lemmas section 
particular te follows lemma 
formation rules come lemmas 
extensional model construction system system theorem plus rules te vc 
theorem soundness inference rules system sound model construction section 
proof proof follows general pattern theorem lemmas proved section breazu tannen breazu tannen coquand gunter scedrov 
inheritance explicit coercion 
proc 
th annual ieee symposium logic computer science 
bruce longo bruce longo modest model records inheritance bounded quantification information computation 
information computation 
bruce meyer mitchell bruce meyer mitchell semantics second order lambda calculus 
information computation 
cardelli cardelli semantics multiple inheritance 
information computation 
cardelli cardelli donahue glassman jordan kalsow nelson 
modula report revised 
research report 
dec systems research center 
cardelli wegner cardelli wegner understanding types data abstraction polymorphism 
computing surveys 
curien ghelli 
curien ghelli coherence subsumption minimum typing type checking mathematical structures computer science 
dahl nygaard dahl nygaard simula algol simulation language 
communications acm 
girard 
girard 
une extension de interpr tation de del analyse son application des coupures dans analyse la th orie des types 
proc 
second scandinavian logic symposium 
north holland 
girard 
girard 
interpr tation fonctionelle des coupures dans arithm ordre sup 
th se de doctorat tat university paris 
jategaonkar mitchell jategaonkar mitchell 
ml extended pattern matching subtypes 
acm conference lisp functional programming 
longo moggi longo moggi constructive natural deduction set interpretation 
mathematical structures computer science 
meyer meyer object oriented software construction 
prentice hall 
milner milner theory type polymorphism programming 
journal computer system sciences 
mitchell mitchell 
coercion type inference 
proc 
th annual acm symposium principles programming languages 
mitchell mitchell 
type inference approach reduction properties semantics polymorphic expressions summary 
proc 
symposium lisp functional programming 
mitchell mitchell type systems programming languages 
handbook theoretical computer science van leeuwen ed 
north holland 

ohori buneman ohori buneman 
type inference database programming language 
proc 
acm conference lisp functional programming 
ohori buneman breazu tannen ohori buneman breazu tannen 
database programming machiavelli polymorphic static type inference 
report ms cis 
university pennsylvania computer information science dept page 
typechecking records variants natural extension ml 
proc 
th annual acm symposium principles programming languages 
reynolds reynolds 
theory type structure 
proc 
colloquium sur la programmation 
lecture notes computer science 
springer verlag 
schaffert schaffert cooper kilian 
trellis owl 
proc 
acm conference object oriented programming systems languages applications 
stroustrup stroustrup programming language 
addison wesley 
wand wand 
complete type inference simple objects 
proc 
nd annual ieee symposium logic computer science 
wand wand 
type inference record concatenation multiple inheritance 
proc 
th annual ieee symposium logic computer science 
page 
