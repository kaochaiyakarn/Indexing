efficient implementation lattice operations hassan kaci robert boyer patrick lincoln roger nasr mcc aca program lattice operations greatest lower bound glb upper bound lub relative complementation important programming languages supporting object inheritance 
general technique efficient implementation operations encoding method 
effect encoding plunge ordering boolean lattice binary words leading constant time complexity lattice operations 
method described transitive closure approach 
space efficient method minimizing code word length described 
powerful grouping tech nique called modulation drastically reduces code space keeping lattice operations highly efficient 
technique takes account idiosyncrasies topology poset encoded quite occur practice 
methods formally justified 
see original contribution semantic vz case taxonomic information engineering pragmatics storage retrieval vz partially quasi ordered information 
categories subject descriptors programming languages language classifications high level languages logics meanings programs studies program con structs type structure information storage retrieval information search retrieval clustering artificial intelligence knowledge representation formalisms methods frames scripts semantic networks general terms algorithms languages performance additional key words phrases inheritance lattice operations partially ordered objects greatest cardinal type cardinal number type surpassed cardinal number type cardinal number type type cantor shown greater substantially revised extended version 
authors addresses ait kaci dec paris research laboratory avenue victor hugo cedex france lincoln computer science department stanford univer sity stanford ca nasr mcc aca program west center drive austin tx boyer department computer sciences university texas austin tx 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm transactions programming languages systems vol 
january pages 
hassan kaci 
object inheritance semantically pragmatically useful 
novel programming languages designed allow user specify type hierarchies 
examples class inheritance common loops smalltalk flavor inheritance subsorts theorem proving type checking amber lo galileo object oriented programming formulated order sorted algebraic data typing ll david mcallester boolean class expressions 
general objects instances classes organized partial order manipulated constraint expressions specifying conjunction disjunction exclusion certain class properties 
languages support multiple inheritance class may superclass smalltalk ad hoc solution combining class properties depend temporal total order classes defined appear expression 
clearly semantically pragmatically hazardous 
proposals formalized concept class inheritance lattice theoretic terms 
captures essential properties useful practice object oriented languages allows better handling class expressions efficient implementation taxonomy objects subsumption partial ordering expensive compute greatest common lower bounds objects 
method static compilation time procedure idea carrying order theoretic information object taxonomy homomorphic image glb computation efficient 
method general far codes study focuses code space unbounded binary words canonical boolean lattice cartesian extension ordering 
computation greatest lower bounds example reduced binary 
developed technique implementing particular mechanism object inheritance login extended life 
promising prospect relevance techniques describe fast implementation constraint programming models strongly related 
section states problem general terms 
focus glb operation commonly operation 
arbitrary posets operation necessarily defined section recalls simple semilattice embedding construction 
method transitive closure section 
method altered yield space efficient encoding algorithm section 
section lattice operations considered method may extended support object disjunction complementation 
section elaborates sophisticated tech nique called modulation 
idea practice related elements come blobs call modules possible encode elements locally module partially ordered encoded 
comparative study methods large posets illustrates gains space time incurred 
acm transactions programming languages systems vol 
january 

problem efficient implementation lattice operations student fl ip person erson employee fig 

poset multiple inheritance 
consider object taxonomy henceforth referred object poset 
suppose object determined type student type employee inherits types 
object inheritance type coercion operation finding greatest type respect subsumption ordering subtype student employee case 
glb elements exists unique poset lower semi lattice lsl need algorithm compute 
general albeit naive algorithm compute glb elements finite lsl 
glb elements greatest element set common lower bounds 
algorithm probably efficient find 
undoubtedly correct 
suppose exists lsl zc know compute glbs efficiently 
lsl suppose exists function elements lsl homomorphism 
assume function invertible exists function acm transactions programming languages systems vol 
january 
hassan ait kaci function glb element returns element ix ix clb lbs return max clb fig 

brute force glb algorithm 
way computing glb elements semilattice combine equations precisely eq 
efficient way compute glbs function inverse efficiently computable 
assumption may realistically 
need really equation literally 
function may relatively expensive long compute statically 
compile time computation compute images elements run time glb computations carried pay price computing inverse image ultimate result 
idea invaluable language login run time computation consists essentially high number glb operations decoding needed print result obviously small price pay 
gist technique propose 
suggest viewing function code compilation object inheritance operation encoding process 
naturally need explicate wild assumptions lsl structure decoding function 
dismiss recalling semilattice embedding 
simple decoding follows lsl embedding interpretation 

semilattice construction foregoing simple analysis relies assumption poset lower semilattice unique glb exists object symbols operation 
practice quite reasonable assumption 
order maintain assumption valid size poset grows exponential number pairwise glbs specified clearly inappropriate demand programmer 
simpler embed partially ordered object set jz lsl structure contains isomorph ism 
embedding preserve order structure particular acm transactions programming languages systems vol 
january 
efficient implementation lattice operations fig 

poset semilattice 
existing glbs 
embedding semantically sound operational logic implements consistent case consistent restrictions propositional logic implemented boolean codes operations 
idea simple intuitive sense 
consider example poset 
objects wl 
wk students employees 
common object symbol designate set students employees 
glb student employee poset defined unique element poset 
sense say glb student employee ought set wl 
wk 
precisely effect construction achieves 
knowledge construction conventional 
related known completion ideals detailed particular form 
follows assumption poset finite need definitions 
restricted powerset poset set nonempty finite subsets pairwise incomparable elements subsets called crowns partially ordered relation defined iff vx poset canonical injection written function takes element singleton 
simple fact shown construction performed infinite poset noetherian contain infinite ascending chains 
acm transactions programming languages systems vol 
january 
hassan ait kaci function nice property vx vy iff order homomorphism 
subset define maximal restriction tx set maximal elements clearly tx defined subsets finite poset element note subset lower bounds 
iy 
elements rl set common lower bounds binary operation defined pair subsets operation glb operation 
result lower semilattice 
furthermore observe elements unique glb follows construction structure embedding preserves ordering glbs exist justified take freedom writing simply lx single element object poset extend poset glb preserving lower semilattice extension possible structure lower semilattice isomorphic canonical injection 
construction formal justification fact need deal posets 
addition universal embedding restricted powerset construction permits manipulation disjunctive objects 
brings problem decoding function 
convenient consequence poset restricted powerset inverse encoding function may extracted follows 
may seen restriction function rbl xf cj words set maximal elements codes ys inverse 
shall see additional property distributive lattice may extended ys invertible 

transitive closure object poset lsl brute force algorithm remains correct 
yields set maximal common lower bounds input elements maximal simultaneously subsumed objects 
approaches described previous section obviously correct 
stand impractical 
brute force method acm transactions programming languages systems vol 
january 
efficient implementation lattice operations fig 

hasse diagram pod 
clearly lead exponential computations obvious find appropriate code function coding approach 
ideas may combined observations redundant computing sets lower bounds poset elements performed statically saved run time 
simple code poset element representation set lower bounds 
problems solved computing reflexive transitive closure immediately greater relation 
second known representation sets bit vectors 
trick bit vectors imple ment realizing isomorphism sets 
yields simple encoding method explained 
example consider element poset 
immediately greater relation covered ordering represented array shown 
row contains columns headed elements immediately element heading row contains 
row headed element viewed characteristic boolean vector representation set immediate strict lower bounds acm transactions programming languages systems vol 
january 
hassan ait kaci fig 

bit array hasse diagram 
reflexive transitive closure array obtain array 
obvious element row array characteristic representation set lower bounds 
referring back brute force glb algorithm intersection operation com puting common lower bounds reduced binary operation bit vectors 
come code function associates element bit vector element poset row boolean array representation reflexive transitive closure immediately greater relation 
compute glb say take obtaining precisely code glb happens try compute glb 
yields code poset elements 
decoding function described equation obtain set wished set maximal common lower bounds looking note column headed contains bottom element poset element greater 
slightly compact binary code word obtained dropping bit bottom element loss 
shall systematically coding element 
method boolean array reflexive transitive closure mi power operation computed matrix multiplication boolean ring bit matrices 
yields straightforward fixed point algorithm converges iterations operationally transitive closure known computation 
shall particular way doing 
reasons achieved computing sequence nk ni nk 
iteration involves matrix multiplication 
gives possible time complexity log known vicinity rumors keeps way 
method techniques developed warshall strassen 
acm transactions programming languages systems vol 
january 
efficient implementation lattice operations fig 

reflexive transitive closure 
clear shall propose slight modification idiosyncratic algorithm immediate ways implementing transitive closure 
describe algorithm section shall formally justify transitive closure computation 
concerned finding compilation time procedure time efficiency coding method prime worry 
may mind paying price slightly efficient procedure leads better run time behavior 
way computing transitive closure directly graph structure base relation 
starting bottom element upwards layer layer assigning binary code words element layer set incomparable elements cochain computed previous layer set immediate parents reached 
manner entire poset swept 
simple way encode node graph compute code binary codes children ored number nodes visited 
illustrate procedure poset 
assigning code layer obtain second layer 
code computed 
code obtained 
layer obtained 
reason taken reached 
simple test elements immediate children coded 
code assigned code assigned 
layer code 
immediately note codes exactly reversed versions reflexive transitive array element column dropped 
code algorithm encoding procedure figures 
uses global variable counting number codes assigned 
assumes function children resp parents returns set elements immediately resp greater predicate coded true encoded element 
loss generality shall assume element exists 
unique bottom exists add 
acm transactions programming languages systems vol 
january 
hassan ait kaci procedure fig 

procedure 
encode layer procedure cochain zp fig 

procedure 
section elaborates correctness algorithm transitive closure algorithm 
correctness simplify proof shall reinstate element column computation codes 
shall prove correctness encoding procedure initialized 
clear performs iterations elements visited 
ai 
element indices 
correspond traversal order procedure 
note sequence topological ordering respect partial order 
indices acm transactions programming languages systems vol 
january 
efficient implementation lattice operations function cochain returns cochain parents return children oded fig 
instruction 
codes computed procedure ui means immediately establish codes computed procedure ith bit position code word counting right left starting position ai shall clearly proved codes boolean vector representations set lower bounds computes reflexive transitive closure 
precisely theorem states 
theorem 
vx vi iff ai proof proceed induction index ah 
clearly true 
question reduced showing vi ui 
obvious 
assume true index aj zk binary terms 
possible cases consider 
case 
ui fortiori ai hand considering second term notice ai indices cj elements acm transactions programming languages systems vol 
january 
hassan kaci entails induction hypothesis fact ai ak conclude zi 

ak earlier clear elements index smaller equal satisfy induction hypothesis 
qx ak ui entails ui uk showed direction proposition prove zi ak ui ak reverse direction follows directly observing cases possible ui uk ui uk reduced reasoning case backward direction works conclude 
case ui ak consider elements ak ai case oi related case 
follows 
cl 
encoding encoding method exposed employed uses unnecessary amount space code words 
code word length exactly number elements poset 
cases code words need long 
situations maximum code word length cut half size 
consider example element poset counting omitted 
tree shaped poset encoded transitive closure method yield bit long codes shown 
shown easily seen bit long words 
suffice case see section 
compaction evident large posets result code modulation seen see section 
general may clearly necessary bits 
trivial example consists flat semilattice 
practice tree inheritance taxon frequent parts posets 
saving space turns substantial practice 
see small example 
assigning code layer obtain second layer lb cl unique predecessor code computed 
recording maximum word length far asp acm transactions programming languages systems vol 
january 
efficient implementation lattice operations fig 

tree shaped poset 
done code obtained 
layer obtained 
just predecessor 
assign code code guarantees far strictly greater predecessors incomparable codes attributed far elements incomparable continuing code assigned 
layer predecessors 
time violates invariant condition comparable code element related possible reinstate invariant revising code disjunction order maintain greater lower bounds guarantee remain incomparable code far unrelated elements 
final code 
method idea encoding procedure generous ically incrementing word length time assigns new code 
cases code computed disjunction children codes suffice 
time necessary augment word length element unique predecessor case distinguishable disjunctive code computed comparable code acm transactions programming languages systems vol 
january 
hassan ifi ii fig 

encodings tree poset transitive closure compact encoding modulated encoding 
procedure compact cochain 
children ifn vl fig 

procedure 
attributed element known incomparable element 
justification informally ensured code greater codes lower bounds incomparable codes incomparable elements procedure correct encoding 
acm transactions programming languages systems vol 
january 
efficient implementation lattice operations procedure element coded case fig 

procedure 
function element returns binary return fig 

instruction 
new encoding procedure obtained procedure replacing call call new procedure name described figures 
conflicts procedure effect ensure invariant condition imposing code attributed element subsumes codes attributed element lower bounds satisfied case violation 
clearly part ensured sticks left previously assigned code 
part enforced recursive propagation new codes conflicting node parents happened encoded 
procedure making sure elements known incomparable stay 
acm transactions programming languages systems vol 
january 
hassan ait kaci procedure element parents coded fig 

procedure 
function set elements element precomputed efficiently classical fast transitive reflexive closure algorithm mentioned log version warshall strassen method relation 
ai row vector bits obtained complement reflexive transitive closure comparable relation selecting ith row 
ai ii 


addition information may disposed garbage collected run time 

variations closed world sensible choices regarding boolean lattice encoding techniques 
obvious closed world assumption 
assumption new information added run time common logic programming shorter binary words encoding 
encoding algorithm compact encoding algorithm new bit created minimal types 
new bits added types unique predecessors procedure 
encoding corresponds set representation minimal elements poset 
element thing set minimal elements subsumes 
closed world encoding obviously preserve information obtainable transitive closure encoding cases information unnecessary 
disjunctive objects shall take freedom overloading symbol mean equal context depending set elements 
applies symbols glb lub 
remarked earlier reflexive transitive closure code element boolean vector characteristic representation set acm transactions programming languages systems vol 
january 
efficient implementation lattice operations lower bounds characteristic precise sense boolean lattice isomorphism powerset set bit arrays length equal cardinality reconsidering semilattice construction section notice fact lattice construction 
define lub elements sd set maximal elements union 
difficult prove assumption finiteness lattice complete distributive lattice 
coding function may extended function ys particular note function restricted invertible shown combining equations 
implemented coding interesting effect reducing set time inheritance unification clearly exponential operation equation virtually constant time operation 
addition provides mild practical generalization facility allows induction lub symbols exist explicitly poset 
example happens lub clearly rs jal 
complemented objects consider simple albeit quite interesting extension tion partial ordering defined pairs elements 
idea see object pair consisting positive object negative object 
general object may seen set examples counterexamples 
object type type tl tl 
course object denotation tl 
subsumption ordering extended complemented objects tz iff tz glb operation complemented objects tl rl ll encoding function extended complemented objects rs decoding complemented codes may done equation pragmatic consideration need explicitly synthesize negated part complemented object 
set counterexamples acm transactions programming languages systems vol 
january 
hassan kaci needed reason sweep entire poset keep maximal set elements codes subsumed code decoded 

code modulation extremely efficient time reasonably sized object posets encoding techniques far cumbersome space 
obvious notices object carry bit object poset transitive closure minimal closed world encoding 
encoding posets hundreds thousands real computers problematic 
practice object taxonomy completely connected 
applications consist tree shaped posets experience object posets consist densely connected groups nodes inheritance links dense groups 
natural realizes groups correspond semantic groupings object called piston may inheritance links car parts may links musical instruments 
possible take advantage common property posets shorten length bit encodings 
benefit small price run time paid elements incomparable groups participate disjunctions negation 
pathological cases optimization performs qualitatively better transitive closure algorithm time space large posets 
intuitive notion grouping easily grasped thinking tree objects 
leaves minimal poset assigned unique bit 
algorithm far leaf node tree bit leaf total space just remember codes 
split tree root encode half tree separately bits node leaves half tree bits half append special group code front encoding append front code half front code just right thing unification disjunction negation great space improvement result 
exhibits small improvement small tree poset 
significant improvement gained technique large trees 
number elements times length local code group plus group code bits required encode entire tree split tree smaller subtrees encoding adding grouping bits reducing number nodes group 
process repeated eventually counterproductive subtrees small 
extension need restricted trees long links middle group objects 
splitting tree easily visualized splitting graph complex 
extension seen simply dividing original poset vertically horizontally tree splitting divides posets horizontally 
draw picture poset draw circles groups nodes circle acm transactions programming languages systems vol 
january 
efficient implementation lattice operations unique highest element unique lowest element arcs elements outside circle lower elements inside circle highest element circle arcs elements inside circle lower elements outside circle come lowest element circle 
call group elements inside circle module 
encode module elements separately bits encode set modules circles diagram poset collapsed points encoded form poset 
module code appended locally determined code elements 
total space encode poset bounded number objects times number groups plus number local elements number groups times average number local elements equal total number objects poset 
possible abstraction groups elements create groups groups 
takes described diagram collapsed modules encodes modulation transitive closure result modules modules 
obviously process repeated module 
optimistic case log bits needed encode entire poset full transitive closure uses 
real posets impossible close approximation lead similarly compact codes 
theorem 
space modulated encoding log 
proof 
poset elements modulated times modulation requires nz 
nk bits encode number elements xth level nz 
nk example nk number elements group bottommost level words nk number elements circle contained time drew circles 
number circles reduced points drew circles xth time drew circles show level equal numbers elements group level optimal 
show 
nk optimal breakdown poset 
find optimal log elements groups number elements show moving number elements group increases total required bits 
configuration group elements group optimal 
number bits required encode element 

total number bits required encode poset 
change way change seen combination pairwise changes terms adding number elements term subtracting acm transactions programming languages systems vol 
january 
hassan kaci amount 
ls trying show greater equal sum 
subtracting away unchanged sums leaves 

subtracting instances leaves 

rearranging produces 

completely modules best 
show group contain amount subgroups group level 
order 
nk constraint met total bits 
remember total number times drew circles 
show decide 
modulation degree level 
bits optimal 
kx 
kx total number bits required encode poset modulation performed degree level 
assume module level size previous lemma demonstrated idea 
change encoding way change seen combination pairwise changes terms dividing term positive number multiplying term 
acm transactions programming languages systems vol 
january 
kx kx efficient implementation lattice operations solution 
need show sum greater equal sum 
subtract unmodified terms kx ov multiply sides divide 
lsd 
change beneficial 
fi optimal 
need find lets take derivative set equal sure minimum solve 
pin log iv dividing sides kxy multiply log log turns minimum log gn simplifies log claim minimum total number bits needed encode perfectly poset elements modulation 
cl large posets large improvement encoded space expected unreasonably large posets realistically coded system 
instance ooo ooo 
far discussing space performance encoding techniques time complexity interest 
glb operation acm transactions programming languages systems vol 
january 
hassan kaci transitive closure bit vector machine glb modulated codes log 
nice result means cake eat space time 
theoretical results somewhat misleading 
small posets real computers behave bit vector machines closure modulation behave approximately 
larger posets real computers behave bit vector machines modulation interest large posets 
example space optimal modulation requires bits uses levels modulation 
broken modules elements modules elements requiring bits level modulation 
level modulation adds potential time cost overhead extra nesting levels may offset space compactness optimal groupings 
far assumed poset perfectly 
trees perfectly sparsely connected posets 
messy object posets dealt allowing modules different sizes extreme single element modules 
slight generalization allows modulation possible real posets resulting code sizes won optimal smaller transitive closure 
operations modulated codes sounds fine phrase right thing unification disjunction negation examine right thing moment consider object poset encoded level modulation code consists group code local code 
generalization operations modules modules straightforward 
define function codes xg group code xl local code yg group code yl local code needs find bitwise xg yg call ag bitwise xl yl call group shorthand topmost element code shorthand bottommost element code 
iff xg yg xl yl xg yg ag definition says greater group xl yl previously defined codes different groups group subsumed glb xg xl yg yl ag xg yg xl yl xg yg ag xa xg ag yg yg ag xg ag 
acm transactions programming languages systems vol 
january 
efficient implementation lattice operations possibility group result group code appended local codes 
second possibility group subsumed result simply original code 
third possibility group subsumed result simply original code 
possibility group subsumes result topmost element group greatest lower bound groups 
define disjunction objects define lub compute bitwise codes call ed components og 
binary constructor represents modulated disjunction 
lub xg yg og xv xg og yg yg og xg vw 
possibility group result group code appended local codes 
second possibility group subsumes result simply original code 
third possibility group subsumes result simply original code 
possibility explicit necessary cases elements incomparable groups ored 
arguments explicit original disjuncts 
needs know take glb lub explicit 
define explicit disjunctions 
vk iff wc iff define negation objects similar section 
define complemented objects pairs codes describing examples describing counterexamples 
object type type tz tl 
define operator computing bitwise ed components ag xg xg yg ag xg ag yg 
possibility group 
simply xl yl common group 
second possibility group subsumed case result bottom 
result explicit complement original arguments 
acm transactions programming languages systems vol 
january 
hassan kaci obvious generalization rule modulated encodings function decode encoded types mrm words set maximal elements codes implementation modulation implementation modulation requires things method generate codes efficient implementation glb lub operations resulting codes 
generating modules order take advantage benefits mod ulation necessary discover group boundaries draw circles groups elements 
sketch algorithm find modules arbitrary poset 
algorithm may find module possible find vast majority able modulate posets hundreds elements seconds 
wishes create modules modules simply need invoke top level function modulated poset 
basic idea algorithm group elements time group grows group size bound case group expanded set remaining objects groups elements threshold case entire process modulation complete 
simplicity code module named element 
assumed entire poset recorded set related pairs accessible previously seen functions parents children 
assumes operations relate asserts asserts recall means immediately 
procedures defined obvious context 
algorithm simply looks element attempting group parents 
fails tries group sibling exactly set parents 
types grouping possible extra elements children newly added elements need added group order satisfy module requirements 
trying add necessary extra children group grow encompass entire poset 
checks exceeding group size bound added procedures 
bound fact bound depend factors machine word length really constant parameter 
function modulate main loop algorithm 
begins putting element poset queue 
examines thing queue 
able grow element larger module new module recorded pushed queue order grow 
simply updates relatedness elements modules 
function immediately adds parents element element grouped subset parents 
acm transactions programming languages systems vol 
january 
efficient implementation lattice operations function modulate set elements returns set set elements queue modules queue iq modules elt pop queue elt elt modules modules queue queue return modules fig 

main loop modulation algorithm 
procedure mod set elements base children mod crown parents mod base mod relate mod crown mod relate mod fig 

procedure 
tries adding extra elements upward homogeneous layer 
homogeneous returns true argument singleton set false 
grow sideways similar begins finding siblings cochain finding siblings exactly acm transactions programming languages systems vol 
january 
hassan ait kaci function element returns set elements crown parents done homogeneous crown size crown done crown done homogeneous crown size crown size crown return return crown fig 

function 
function element returns set elements family crown parents siblings crown lj siblings parents crown done brother pop family brother family family done return fig 

function 
parents element 
full siblings added time bound reached 
new sibling added children may added order form group 
begins adding children new elements group formed module size limit reached 
fact acm transactions programming languages systems vol 
january 
efficient implementation lattice operations function added old set elements returns set elements new added old group new old children new parents size group return new return old group return return group fig 

function 
case adding new parents new children group formed 
complicates algorithm 
simplification function new children parents termed function returns failure preventing growth 
glb lub formulation glb extremely efficient operation 
lub efficient 
uses lub operation elements different modules incur performance penalties cases due need explicit disjunctions 
similarly elements incomparable groups produces explicit negations 
applications disjunction negation infrequent nonexistent 
cases advantageous modulate encoding possible 
decision modulate modulate dependent details system implementation including hardware archi tecture machine word size multiword bit vector opera tions particular advantageous modulate posets fewer elements underlying machine word bits 
due fact bitwise bit vectors shorter word size machine tends fastest operation possible 
personal workstations posets elements encoded transitive closure algorithm larger posets broken 
proof variants algorithms implemented common lisp benchmarked symbolics 
benchmarks collected acm transactions programming languages systems vol 
january 
hassan ait kaci fjj average time compute modulated closure glb number elements poset fig 

average time compute modulated transitive closure glb 
building series trees perfectly adding number randomly generated links 
links cause loops redundant transitivity ignored 
trees exponential nature branching factor depth generally corresponds posets encountered practice 
timings collected fixed arity trees posets actual practice correlated timings set timings represents time second glb takes compute transitive closure star shaped data points modulation circular data points 
times gathered posets successfully modulated algorithm see set benchmarks randomly selecting pairs elements finding minimum time necessary compute glb pair dividing 
selection minimum time average go seo babel library database smaller sample posets helped drive development technique 
acm transactions programming languages systems vol 
january 
llo loo lo efficient implementation lattice operations posets modulated glb faster transitive closure glb 








number elements poset fig 

posets modulated glb faster transitive closure glb 
justified multitasking nature symbolics machine 
proce dure timing modulated glb transitive closure glb 
fewer elements poset glb operations exactly instruction takes seconds 
elements seen diagram modulated glb faster transitive closure glb factor 
size poset increases modulation outperforms transitive closure larger larger margins 
performance advantage exists certain posets 
fact posets fall shaded area expected exhibit performance gains 
dashed vertical line located element mark modulation transitive closure algorithms diverge 
open circles mark maximum number links percent randomly generated posets successfully modulated 
success defined breaking poset modules 
curved solid line performance expected 
line right dashed vertical line shaded area expect factor performance gain modulation transitive closure 
line acm transactions programming languages systems vol 
january 
hassan kaci possible modulation succeed possible modulation fails outperform transitive closure 
possibilities 
slanted dotted line represents effect tree splitting easy implement restriction modulation discussed earlier 
diagram shows tree splitting accounts large part expected gain lation 
curved broken line left dashed vertical line represent maximum possible number links number elements links elements poset redundant inconsistent 
benchmarks reflect quality implementation glb operations transitive closure modulated quality modulate routine finds modules 
believe implementations high quality may able better 
noted benchmarks compare encoding techniques 
encoding techniques qualitatively outperform standard methods implementing inherit ance easily exponential size poset linear better 
modulated variations generalizations modulation theme possible 
fact possible relax requirements modules allow multiple topmost elements multiple bottommost elements module 
upper surface defined elements group immediate descendants elements group upward homogeneous defined mean elements exactly set parents lower surface downward homogeneous defined similarly group module 
described earlier modules singleton upper lower surfaces trivially homogeneous 
fact algorithm able find modules large surfaces definition homogeneous changed simple singleton test tests elements exactly set parents 
better test 
assumed transitive closure encoding determine local code group code modules 
possible variations closed world encoding 
alternate local encoding schemes subtle effects 
closed world encoding tree splitting dominant operation difficult divide closed world poset vertically modules 
mundane encoding schemes depth search levels modulated poset 
emphasis certain aspects performance alternate encoding schemes level 
mix match approach especially useful large posets 
dynamic poset changes costly modulated codes tha transitive closure generated codes 
transitive closure encoding ing changes poset encoded extremely expensive 
fact change poset element element subsumes recoded 
modulated codes elements subsume module recoded change acm transactions programming languages systems vol 
january 
efficient implementation lattice operations causes link modules case recoded 
overhead changing small number codes run time prevents advantage feature modulated codes applications dynamic changes poset facilitated modules 

arbitrary poset may boolean lattice greatest lower bounds may computed efficiently 
suggest basis compilation object inheritance applications 
demonstrated construction general accommodate fully disjunctive complemented inheritance efficient formally justified 
addition simplest encoding method known transitive closure encoding demonstrated methods accomplishing encodings reduce space overhead acceptable levels advantage topology poset 
thoroughly study grouping technique call code modulation 
largest consequence modulating encoding poset reduce space required store codes log 
pointed theoretical complexity glb operation encoded lattice log 
addition dynamic poset changes costly modulated codes transitive closure generated codes 
summary realistic techniques facilitate certain frequent computations posets computations traditionally linear exponential time reduced nearly constant time operations 
techniques bound useful partially ordered entities abound novel programming languages notably supporting inheritance 

hopcroft ullman design analysis computer algorithms 
addison wesley reading mass 

ait kaci lattice theoretic approach computation calculus partially ordered type structures 
ph dissertation computer information science university pennsylvania philadelphia penn 

ant kaci algebraic semantic approach effective resolution type equations 
theor 
comput 
sci 


ah kaci boyer lincoln nasr efficient implementation object inheritance 
tech 
rep ai microelectronics computer technology austin tex 

ait kaci nasr login logic programming language built inheritance 
logic program 


kaci lincoln life natural language natural language 
tech 
rep aca st microelectronics computer technology austin tex feb 

albano orsini pedreschi type system galileo 
atkinson buneman morrison ed 
data types persistence 
springer verlag berlin germany pp 


birkhoff lattice 
volume colloquium publications american mathematical society providence third edition 

bobrow merging lisp object oriented programming 
proceedings object oriented programming systems languages applications conference port land ore pp 


nov 
acm transactions programming languages systems vol 
january 
hassan kit kaci 
cardelli amber 
tech 
memo 
bell labs murray hill 

goguen meseguer extensions foundations object oriented programming 
acm sigplan 
lo oct 

goldberg robson smalltalk language implementation 
addison wesley reading mass 

jaffar lassez 
constraint logic programming 
proceedings th acm popl symposium munich jan acm new york pp 


mcallester boolean class expressions 
acm 
ll nov 

tuples prolog 
workshop organized minker foundations deductive databases logic programming washington aug 

parker partial order programming 
tech 
rep csd computer science de ucla los angeles cal dec 

smolka nutt goguen meseguer order sorted equational computation 
kaci nivat eds 
resolution equations algebraic structures 
academic press cambridge mass 
forthcoming 

stickel automatic deduction theory resolution 
proceedings international joint conference artificial intelligence los angeles cal 
morgan kauffman pp 


walther mechanical solution schubert sorted resolution 
artif 
intell 


weinreb moon lisp machine manual 
massachusetts institute technology cambridge mass 
received september revised july accepted september acm transactions programming languages systems vol 
january 
