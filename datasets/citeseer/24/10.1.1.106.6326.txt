specification analysis real time hybrid systems rewriting logic dr 
thesis department computer science university bergen peter december dedicated parents contents preliminaries rewriting logic maude full maude rewriting logic 
maude 
reflective features maude module meta level 
full maude 
specification real time hybrid systems rewriting logic time models real time rewrite theories 
time models 
real time rewrite theories 
category real time rewrite theories 
real time theories internalized rewriting logic 
discussion 
specifying models real time hybrid systems rewriting logic 
timed automata 
hybrid automata 
timed transition systems 
phase transition systems 
object oriented real time systems 
timed petri nets 
relationship timed rewriting logic 
timed rewriting logic 
timed rewriting logic rewriting logic 
differences trl rewriting logic translation 
aging trl 
concluding remarks 
real time maude language tool simulating analyzing real time hybrid systems real time maude specifications 
specifying real time rewrite theories real time maude 
processing specifications real time rewrite theories 
executing analyzing real time maude specifications 
rewrite modes 
basic timed rewrite strategies 
search strategies 
extending tool strategy library 
real time maude command language 
sample real time maude specification execution 
known problems 
scheduling case study 
scheduling problem 
specifying mutual exclusion 
analyzing mutual exclusion specification 
finding schedules 
case studies 
maude specification real time maude overview real time maude specification 
real time maude strategy library 
variables strategy library 
standard data types operations 
finding possible time increase values tick rule applications 
functions timed meta apply timed meta rewrite 
patterns search preliminaries 
model checking search functions 
real time maude extension full maude 
changes full maude 
adding strategy language 
defining syntax real time maude modules commands 
preprocessing 
executing timed commands 
database handling 
predefined modules 
handling input output defining persistent loop state 
specifying analyzing aer nca active network protocol real time maude overview protocol 
motivation 
repair servers 
real time aspects 
informal description protocol 
specifying analyzing aer nca protocol real time maude 
time domain 
declarations object oriented real time systems 
modeling communication communication topology 
class hierarchy 
frequently classes 
rtt protocol 
nom protocol 
rate control protocol 
repair service protocol 
application layer 
combined protocol 
methodology experience 
formal methodology 
specification formalism 
experience benefits gained real time maude real time network protocol specification analysis 
time domains machine natural numbers 
positive machine rationals 
fixed point numbers 
original specification aer nca protocol aer rs protocol 
aer rtt protocol 
nca nom protocol 
nca rc protocol 
thesis part long term research program explores application rewriting logic mes executable formal modeling computing systems 
general conceptual advantage logic specific model different models specified logic terms means possibly awkward translations fixed model 
rewriting executable supported implementations rewriting logic languages maude cde elan bkk cafeobj fd models formally analyzed flexible range formal analysis techniques including rapid prototyping model checking symbolic simulation 
advantages rewriting logic semantic framework concurrent systems wide range concurrent system models naturally represented amply demonstrated see surveys mes mes 
pragmatic level rewriting logic due fairly natural known formalism integration static dynamic system aspects modeling communication concurrency support concurrent objectoriented programming possibilities allowing user defined execution strategies logic shown appealing formalism specify analyze variety applications communication security protocols complex warrant prototyping formal analysis operational nature fits rewriting logic 
thesis investigates rewriting logic similarly suited model analyze realtime hybrid systems 
important research contribution exploring application rewriting logic real time specification wirsing timed rewriting logic trl kw extension rewriting logic rewrite relation labeled time stamps 
trl shown adequate specifying variety complex real time systems kw sk suffers having rigid synchrony requirements changing logic trl specifications directly executed rewriting logic language implementation 
indicates rewriting logic suited model analyze real time hybrid system having change inference rules logic 
show wide range models real time hybrid systems including timed automata ad hybrid automata ach timed phase transition systems mp timed extensions petri nets aal mpt object oriented real time systems expressed rewriting logic quite naturally directly real time rewrite theories 
theories rewrite theories real time aspects highlighted 
real time rewrite theories easily reducible ordinary rewrite theories 
rewriting logic specify different formal models systems unified logic 
rewriting logic executable models executed formally analyzed variety ways 
contrast known formal methods tools real time hybrid systems kronos step sta ms uppaal 
model checking tools require user specify system formal properties system satisfy 
tools try check system satisfies property 
having somewhat restrictive specification languages purposes remaining possible decidable fragments tools suited directly executing system 
said hytech takes hybrid system description parameters unspecified returns concrete values parameters system satisfy property 
course different tools different important strengths 
point executable specification methods tools complement strengths new ways 
see rewriting logic complements specification formalisms temporal logic concrete automaton ones think covering intermediate operational level substantially help bridging gap specifications actual implementations providing precise mathematical model system initial model mes specifications proved correct means inductive theorem proving model checking techniques support useful techniques automated semi automated formal reasoning analysis rewriting logic equational logic levels coherence vir confluence strategy formal analysis support executable specification symbolic simulation wide range formal analyses possibility generating correct implementations specifications theory transformations code generation techniques 
showing rewriting logic suitable semantic framework real time hybrid systems investigate specification analysis methods rewriting logic known concurrent distributed systems see example mes specialize real time hybrid systems 
purpose defined implemented real time maude specification language analysis tool 
real time maude language extends full maude language support specification real time rewrite theories timed modules object oriented timed modules 
real time maude tool supports wide range techniques formally analyzing timed modules 
supporting maude default execution strategy provides special purpose strategies symbolic simulation timed modules additional rewrite strategies search commands model checking timed modules respect properties stated subset real time temporal logic 
furthermore tool strategy library easily extended define new application specific analysis strategies 
building real time maude tool maude formal meta tool cde tools case real time maude tool represented executed 
specifically specification real time maude extends specification full maude extensive maude reflective features 
accruing great saving implementation effort reflective design tool extension full maude means real time maude specification language inherits extends rich module algebra full maude including parameterized modules theories views module expressions object oriented modules supported real time specifications 
usefulness specification language formal methodology measured different examples applications expressed effectively formal analysis methods uncover flaws indicate absence errors informal specifications 
tested real time maude specification language analysis tool variety realtime systems including method solving scheduling problems thesis 
important case study undertaken specification analysis sophisticated protocol suite reliable efficient multicast active networks aer nca suite active network protocols kbk aer developed bhattacharyya kurose towsley combines adaptability faulttolerance real time performance composability protocol aspects presents challenging specification analysis problem kind typically included formal methods treatments protocols 
tool specify protocols aer nca suite composition object oriented style naturally supported real time maude 
real time maude tool formally analyze protocols composition executing tool standard interpreter extending strategy library model check specification respect relevant temporal logic properties 
process uncovered missing assumptions ambiguities flaws original informal specification 
thesis organized follows chapter introduces rewriting logic languages maude full maude 
chapter defines notion real time rewrite theories theories mapped ordinary rewrite theories way preserves expected properties known models real time hybrid systems naturally represented real time rewrite theories 
chapter describes real time maude specification language execution search commands real time maude 
chapter presents maude specification real time maude extensible strategy library execute real time maude commands shows maude specification full maude extended specification real time maude 
chapter presents real time maude specification aer nca protocol suite describes real time maude formally analyze specification 
chapter summarizes thesis outline directions 
appendix gives real time maude specification time domains thesis natural numbers rational numbers fixed point real numbers aer nca protocol suite 
appendix presents informal specification aer nca protocol suite real time maude specification protocol suite chapter 
acknowledgments thesis done computer science laboratory sri international dr jos meseguer thesis advisor 
express deeply felt gratitude jos 
different kind student ones usually advises guided friendly competent patient way 
thesis truly joint partly joint publications 
scientific guidance important jos true friend taught words actions le social necessarily contexts 
consider thesis advisor true dear friend 
unfortunately year relationship inevitably moment disappointment just finishing thesis lost time prestigious weekly tennis encounter 
am greatly indebted professor martin wirsing ludwig maximilians universit nchen stayed learnt lot short nice months doctoral studies 
stay introduced rewriting logic real time systems 
professor inviting bergen sending stanford university sri international guidance initial phase studies michal friendly mentor bergen brief time didn prepare teaching 
master thesis advisor professor oslo introducing term rewriting harry hartmann excellent teacher motivated learn 
thesis dedicated parents completely wonderful human beings love best parent probably hardest kind 
dear family completed great little brother host cambridge mass trip east coast mark parts thesis 
grandmother special relationship 
am particularly grateful happy stayed possible ball community aunt uncle peter cousins zs fi ifi san francisco 
welcomed generosity abundance lack chocolate morning beer evening provided home away home son brother cousin 
symptomatic generosity possible years day san francisco 
imagine doctoral students feel frustrated studies 
suddenly change advisor commute atlantic fulfill teaching obligations addition hard consistent 
remember studies best years life able closely follow challenging research done advisor sri great friends years 
scope thesis truly great friends individually 
feel need mention individuals shoulders frequently hope remain dear friends 
include sonia tsui mark oliver stehr wonderful time including classic trip forgotten braga sa di particular support times peter fellow sports nut california generous host paris francisco dur manuel el functor garcia clavel 
friends 
enjoyed tremendously living extended periods time generous denise west george talbot intelligently funny man met 
nchen favorite city received introduced city bernhard reus robert rolf stephan merz 
owe lot enjoying months nchen 
bergen truly enjoyed michal pleasant disagreements teaching material talk beer jokes movies office mate close friend jan arne 
oslo feel deep friendship ahmad month spent california visit tor family managed visit times california oslo marktoberdorf nchen friend henrik 
am especially grateful support received ingrid years 
support presence invaluable early years doctoral studies 
visits nchen trip various natural wonders arizona utah memories 
regret seeing list wonderful friends family wish california oslo hungary cambridge bergen nchen time time 
benefitted enormously remarkable computer science laboratory sri international 
lab director friend pat lincoln letting people hesitation happy help time sri 
abused particular kindness stehr dur steven eker pat lincoln denker natarajan shankar 
narciso mart oliet encouraging friend colleague hesitate help demanded help 
papers improved significantly comments 
dry run talk asilomar remembered long time cleverly disguised help narciso manuel pat 
enjoyed 
really liked working mark steve reading week benefitted discussions carolyn talcott joseph sifakis 
lee iverson took seemingly impossible task teaching play basketball effort clearly vain 
head department teaching boss department computer science university bergen flexible possible teaching responsibilities allowing spend time necessary sri 
michal helped lot bergen bergen stanford 
friend piotr nchen kw 
dr garth george st george dr jamie miami professor dr wilke essen help difficult finish thesis 
feel truly seen friendship love years 
partial support research contracts gratefully acknowledged support norwegian research council support darpa rome laboratories contract darpa nasa contract nas office naval research contracts national science foundation ccr ccr 
chapter preliminaries rewriting logic maude full maude section gives background material rewriting logic see mes mes mes rewriting logic applications rewriting logic language maude cde cde full maude language tool cde dur dm 
assume familiarity basic concepts algebraic specification see wir term rewriting see dj 
sections adapted mes 
rewriting logic rewriting logic logic change dynamic parts system specified labelled conditional rewrite rules static structural parts specified equations 
signature rewriting logic equational theory equational signature set equations 
rewriting operate equivalence classes terms modulo signature sentences rewriting logic sequents form terms possibly involving variables denotes equivalence class term modulo equations rewrite theory tuple ranked alphabet function symbols set equations set labels set pairs component label second component pair equivalence classes terms 
xn 
countably infinite set variables 
elements called rewrite rules 
understand rule labeled rewriting logic parameterized choice underlying equational logic unsorted order sorted membership equational logic 
ease exposition give unsorted presentation 
simplify exposition rules logic case unconditional rewrite rules 
ideas extended conditional rules mes general rules form 
uk vk 
increases considerably expressive power rewrite theories 
generally consider rewrite rules include equations membership equational logic memberships conditions 
maude supports specification general rewrite rules 
sequent notation 
indicate 
xn set variables occurring write 
xn 
xn abbreviated notation 
rewrite theory say entails sentence concurrent rewrite write obtained finite application rules deduction assume terms formed denotes simultaneous substitution wi xi 
reflexivity 

congruence 

tn 
tn 


replacement 
rule 
xn 
xn 
transitivity 
wn sentence called step rewrite iff derived finite number applications rules application rule 
rule applied exactly say sentence step sequential rewrite 
rewriting logic logic reasoning correctly concurrent systems having states evolving means transitions 
signature rewrite theory describes particular structure states system multiset binary tree states distributed structure 
rewrite rules theory describe elementary local transitions possible distributed state concurrent local transformations 
rules rewriting logic allow reason correctly general concurrent transitions possible system satisfying description 
computationally rewriting step parallel local transition concurrent system 
alternatively adopt logical viewpoint regard rules rewriting logic metarules correct deduction logical system 
logically rewriting step logical entailment formal system 
initial model rewrite theory category tr objects equivalence classes ground terms modulo equations arrows proofs rewriting logic concurrent computations system described 
proofs generated decorating deduction rules rewriting logic follows 
identities 

structure 

tn 

tn 


replacement 
rewrite rule 
composition 
wn 
proofs equated modulo notion proof equivalence computationally corresponds true concurrency computation 
category associativity 

identities 


functoriality algebraic structure 
preservation composition 






preservation identities 

tn 
tn 

axioms 
xn 
xn axiom 




exchange 

xn 
xn 
wn result mes proof factorized proof corresponding sequence step sequential rewrites 
identity proof sequence step sequential rewrites tn 
equivalent modulo equivalence proof terms described 
specifications thesis equational theory assumed gm set sorts comes equipped partial order relation interpreted subset inclusion model furthermore operation symbols subsort overloaded example addition symbol naturals integers rationals 
overloaded operators required yield result arguments regardless overloaded operator applied 
addition order sorted signature assumed coherent gm 
ensures terms sort poset sorts properties 
section give rewriting logic specification uses expressive equational logic membership equational logic mes 
initial model tr understood order sorted sense sort associated category tr arrows equivalence classes proofs ground terms sort maude maude cde cde language system developed sri international modules theories rewriting logic 
general maude modules called system modules 
syntax mod endm rewrite theory question expressed syntax quite close corresponding mathematical notation equations equational theory underlying rewrite theory union set equational axioms introduced attributes certain operators signature example operator declared associative commutative keywords assoc comm set equations assumed church rosser terminating modulo axioms furthermore assumed weakly ground coherent vir 
maude supports rewriting modulo different combinations equational attributes operators declared combination associative commutative left right sided identity attributes 
view equational theory rewrite theory set labels rules empty maude contains sublanguage functional modules form fmod endfm church rosser terminating modulo equational logic functional modules equational part system modules membership equational logic mes expressive logic atomic formulas equations membership predicates sort 
membership equational logic quite expressive 
supports sorts subsorts operator overloading equational partiality 
expressiveness achieved efficiently executable rewriting having suitable techniques completion equational theorem proving 
maude third class modules object oriented modules specify concurrent objectoriented systems syntax sugared form rewrite theory 
object oriented modules internally translated ordinary system modules maude provides convenient syntax supporting concepts objects messages object classes multiple class inheritance 
modules maude initial semantics 
system module mod endm specifies initial model tr rewrite theory similarly functional module fmod endfm specifies initial algebra equational theory 
addition maude supports module algebra parameterized modules parameter theories loose semantics views theory interpretations module expressions 
maude module algebra called full maude defined inside language reflection easily see cde detailed description maude syntax 
extensible new module composition operations dm dur 
module algebra important concrete application general metaprogramming capabilities possible maude support reflection meta level module 
important application reflection capacity defining internal strategy languages guide execution rewrite theories means rewrite rules metalevel 
reflective features maude module meta level clavel meseguer shown rewriting logic reflective cm cm cla cde 
finitely rewrite theory universal sense represent finitely rewrite theory including terms terms equivalence theory seen universal interpreter rewriting logic simulate rewrites rewrite theory may quite costly simulate rewrites na implementation simulation single step may involve steps 
universal theory extended descent functions cde simulate operations say rewrite step parameters efficient way going level reflection rewrite engine compute result applying rewrite resulting term transformed representation extension universal theory descent functions conservative certain conditions universal theory cde 
maude language predefined module meta level intended model universal theory module meta level terms reified elements data type term having signature subsort qid term subsort term termlist op qid qid term op qid termlist term op termlist termlist termlist assoc op error term declaration making quoted identifiers subsort represent variables term corresponding quoted identifiers 
variable represented operator representing constants pairs argument constant quoted form second argument sort constant quoted form 
example constant zero sort time represented zero time 
operator corresponds recursive construction terms subterms list concatenation denoted example term constants sort represented meta level term infix operator represented 
maude functional system modules represented syntax similar original syntax sorts module subsort module op fmod endfm qid op mod qid ruleset module maude system manual cde provides details representation modules 
example set rules module represented syntax sorts rule ruleset subsort rule ruleset op rl qid term term rule op crl qid term term term term rule op ruleset op ruleset ruleset ruleset assoc comm id module meta level provides key functionality efficient descent functions 
example process reducing term normal form reified function op meta reduce module term term special 
meta reduce returns meta representation normal form term module process applying rule reified descent function op meta apply module term qid substitution machineint special 
apply gives result applying rule partially instantiated normal form term th successful match 
result returned term normal form resulting term match rule application 
result error returned fewer successful matches 
observe rule applied top normal form term process rewriting term system maude default interpreter reified descent function meta rewrite 
parsing reified function op meta parse module term special 
parses list quoted identifiers module 
maude contains module loop mode provides built facilities keeping persistent state performing input output 
input maude command line writing pair parentheses list identifiers 
input read maude application extending loop mode corresponding list quoted identifiers manipulated stored persistent state 
maude application output text placing list quoted identifiers output buffer 
full maude maude modules class data objects maude relatively easy define maude modules extending meta level different operations modules 
taken advantage full maude system maude specification developed dur meseguer dur dm defines language tool specification execution maude modules extended rich module algebra module hierarchies parameterization views theories module expressions 
addition full maude supports specification object oriented modules convenient syntax 
full maude uses loop mode facilities read modules full maude system commands store persistent state database modules read far output result commands placing appropriate list quoted identifiers output buffer 
precisely input parsed stages parse function 
stage say parsing module specification input parsed respect top level grammar defining syntax full maude commands modules 
parts input representing terms module defined parsed respect top level grammar protected parsed enclosed bubbles cde 
second stage signature part module defined determined bubbles parsed meta parse grammar signature module parsed 
module completely parsed entered full maude module database persistent loop state 
flattened flattened meta representation core maude module executed meta rewrite 
treatment similar system commands rewrite commands full maude retrieve database module rewrite flatten module parse input representing term rewrite 
rewrite command executed calling descent function meta rewrite result rewrite transformed meta pretty print list quoted identifiers placed output buffer 
chapter specification real time hybrid systems rewriting logic chapter joint show rewriting logic specify real time systems natural way 
essentially need include specification time data type satisfying appropriate equational properties 
useful highlight real time aspect making explicit duration information rewrite rules 
formalize idea section means real time rewrite theories show adding explicit clock reducible ordinary rewrite theories way preserves expected properties 
naturalness specification method smooth integration rewriting logic support object oriented specification explored illustrated examples section address question generally naturally rewriting logic express variety real time hybrid system models 
show detail objectoriented real time systems wide range models including timed automata ad hybrid automata ach timed phase transition systems mp timed extensions petri nets aal mpt expressed rewriting logic quite naturally directly 
mentioned important research contribution exploring application rewriting logic real time specification wirsing timed rewriting logic trl kw extension rewriting logic rewrite relation labeled time stamps 
trl shown suited giving object oriented specifications complex hybrid systems steam boiler kw applied give semantics sdl telecommunications specification language sk 
fact rewriting logic object oriented specifications maude language cde natural extension trl object oriented specifications timed maude kw kw 
approach taken different 
argue real time systems specified ordinary rewriting logic reasoning behavior require special inference system proposed trl 
special notation highlighting realtime aspects provided real time rewrite theories show essentially regarded syntactic sugar 
conceptual advantage remaining simpler theoretical framework practical advantage able existing language implementations rewriting logic execute specifications 
conceptually practically useful study relationships approach trl 
section show map logics trl sending trl specification corresponding rewrite theory way logical entailment preserved 
translated theory general prove additional sentences 
due intrinsic conceptual differences formalisms analysis reveals 
text chapter maude notation cde specific rewrite theories 
part notation self explanatory 
example conditional rewrite rules notation time models real time rewrite theories specifying equationally general requirements models time consider section propose general notion real time rewrite theory consisting ordinary rewrite theory rewrite rules affecting system associated time duration expressions section 
show real time rewrite theories form category section reduced ordinary rewrite theories adding explicit clock global state way preserves expected properties section 
finish section discussion issues specification techniques real time rewrite theories section 
time models time modeled abstractly commutative monoid time additional operators 
monus satisfying maude theory 
fth time protecting bool sort time op time op time time time assoc comm id ops time time bool op time time time vars xr yr zr wr time ceq yr zr xr yr xr zr eq xr xr false ceq xr zr true xr yr yr zr eq xr yr xr yr xr yr eq xr true ceq xr yr zr wr true xr zr yr wr eq xr xr yr yr true ceq xr yr yr xr yr xr ceq xr zr yr zr true xr yr note conditional equations ceq having condition boolean term shorthand notation equations condition true 
particular boolean expressions contain boolean valued equality predicate denoted 
theory example proved relation partial order element xr yr time yr xr exists unique zr xr yr xr yr zr 
simulation executable specification purposes interested computable models theory time 
means operations computable 
bergstra tucker theorem bt computable algebra finitely specifiable initial algebra set church rosser terminating equations 
example nonnegative rational numbers specified model time adding subsort rat specification rationals gm extending order monus operations obvious way 
similarly real algebraic numbers standard order computable rab finite algebraic specification church rosser terminating equations 
note just constructive version real numbers yield computable data type equality order predicates constructive reals computable bee 
examples thesis need extend time domain new value require time domain linear 
theory gives specification time domain extended value 
fth time including time sort time time op time op time time bool op time time time op time time time assoc comm id var xr time var yr time eq yr true eq xr false eq xr true eq yr false eq xr eq yr linear time specified theory fth ltime including time op min time time time comm vars xr yr time ceq xr yr xr yr yr xr ceq min xr yr yr yr xr theory extended time value follows fth ltime including ltime time op min time time time comm var xr time eq min xr xr notation symbols denote time values xr yr denote variables sort time domain 
real time rewrite theories define section real time rewrite theories specify real time systems rewriting logic contain duration information rules 
rules divided tick rules model elapse time system instantaneous rules model instantaneous change assumed take zero time 
having tick rule tick lead rewrites rewrites time elapses part system consideration 
ensure time advances uniformly parts state introduce new sort system subsorts free constructor state system intended meaning denotes system state uniform time elapse ensured global state form tick rule form tick 
defining real time rewrite theories recall notion theory morphism equational theories show time domain interpreted real time rewrite theory 
definition equational theory morphism consists monotone map sorts sorts mapping sending function symbol sn term fs sn sort set variables contained set 
xn sn sn subsort overloaded operators si term fs sn obtained term replacing variable xi corresponding variable xi si 
furthermore axiom 
yk sk 
yk sk holds homomorphic extension terms equations condition real time rewrite theory defined rewrite theory interpretation time domain assignment duration rules involving terms sort system definition real time rewrite theory tuple rewrite theory variables 
xn ordered assignment 
sn fs sn alternatively understood assignment 
xn sn fs sn 
give definition loose semantics rewrite theories 
real time rewrite theories defined similar way initial semantics setting 
equational theory morphism time time theory defined section time domain functional rewrite proof term sort time equivalent identity proof contains designated sort usually call state specific sort system subsorts operator state system satisfies non trivial equations furthermore sn sort system appear 
sn assignment term 
xn sort time rewrite rule form 
xn 
xn 
xn terms sort system 
notation write 
xn xn 
xn 
xn rule sort system duration term 
xn equals rule written 
xn 
xn 
xn 
write time respectively time 
rest thesis simplify notation write time time 
write time time time extension 
call rules form global rules 
global rule tick rule duration 
xn different instance variables instantaneous rule 
rules form called local rules act system system components 
local rules viewed instantaneous rules take zero time 
total time elapse rewrite sort system defined sum time elapsed tick rule application easily extracted proof definition real time rewrite theory time denote time domain time viewed monoid category single object time values arrows usual way 
time extraction functor tr system time gives total time elapse proof ground terms sort system defined follows term seen identity arrow tr system proof term top operator constructor 

tn system rule form 
proofs tn proofs 
definition depend choice representative proof terms 
equivalent proofs terms sort system real time rewrite theory 
real time rewrite theory computation non extensible sequence tn tn rewritten infinite sequence step rewrites ti ti ti ti ground terms starting initial term sort system 
noted model time elapse explicitly rewrite rules usual requirement total time elapse computation infinite needed 
time elapse totally specifier allow terminating computations infinite computations finite total time elapse zeno computations 
category real time rewrite theories notion theory morphism called theory interpretation real time rewrite theories plays important role 
give definition theory morphism real time rewrite theories loose semantics preservation durations rewrites 
morphisms properties initial models theories morphisms having restrictive requirements relationships durations rewrites defined similar way 
defining theory morphisms ordinary rewrite theories 
definition rewrite theory morphism rewrite theory rewrite theory consists equational theory morphism map labels rule rule renaming variables 
rewrite theory morphisms compose expected way define category rwth rewrite theories 
definition real time rewrite theory morphism real time rewrite theory real time rewrite theory rewrite theory morphism maps designated sort states designated state sort maps sort system leaves constructor unchanged preserves duration tick rules sense rule sort system 
xn sn 
xn sn 
easy check usual composition rewrite theory morphisms defines category real time rewrite theories objects real time rewrite theory morphisms arrows 
real time theories internalized rewriting logic adding clock state real time rewrite theory transformed ordinary rewrite theory losing timing information 
state clocked system form global state sort system value sort time intuitively supposed denote total time elapsed computation initial state clock value 
definition internalizing functor category real time rewrite theo ries category rwth rewrite theories takes real time rewrite theory rewrite theory rc ec lc rc follows sorts operations axioms new sort clockedsystem new free constructor system time clockedsystem unchanged contains local rules sorts system rule rule 
xn xr 
xn xr 
xn xr 
xn 
xn 
xn 
xn 
xn 
xn sort system xr variable sort time list 
xn 
internalizing functor defined expected arrows arrow mapped coincides leaves new sort operator unchanged takes label rule sort clockedsystem label case condition rule contains conjunct sort system conjunct replaced conjunct yr condition yr fresh variable sort time 
sake simpler exposition rest thesis assume condition rewrite rule real time theory contains rewrite conjunct sort system 
assume loss generality variable sort system introduced condition rule 
proposition mapping defines functor rwth 
proposition forgetful functor category real time rewrite theories category rwth rewrite theories defined map rewrite theories mapping sort operator defined clockedsystem identically mapping clockedsystem system mapping operator term system mapping label label defines natural transformation rewrite theory morphism induces forgetful functor uh sys sys opposite direction corresponding categories models natural rewrite theory sys 
particular morphism rc induces forgetful functor sys rc initial model tr sent rc system tr initiality trc unique homomorphism tr takes objects arrows sort clockedsystem object clockedsystem 


map expresses essential semantic equivalence initial model real time theory clocked representation rc precise sense shall see 
arrow tr system value sort time unique arrow clockedsystem 
arrow clockedsystem 
properties immediate consequences theorem real time rewrite theory arrow tr system ground terms sort system 
value time domain unique arrow clockedsystem addition 
theorem proved induction structure proof terms proving theorem step rewrites proving proofs terms sort system facts proof factorizes sequence step rewrites distributes step rewrite proofs 
theorem implies arrow arrow satisfies implies viewed functor clockedsystem tr system full faithful bw 
discussion discuss system specification issues techniques including tick rules eager lazy rules time action system 
specifying tick rules simulation system having continuous time domain tick rules form tick xr xr xr mte exact form replacing xr mte xr mte xr variable occurring denotes time advanced tick mte computes maximum time elapse permissible ensure timeliness time critical actions condition xr mte resp 
xr mte ensures time elapse may halt temporarily possible application non time critical rule rule modeling action occur somewhat arbitrarily time 
variable xr righthand side requires additional execution strategies instantiations surprising models behavior nondeterministic time 
allowing real nondeterminism timed behavior way may lead zeno behavior system execution strategy instantiate righthand side variable avoid possible 
eager lazy rules general sufficient ensure time elapse stops necessary 
ensured time advance necessary instantaneous actions performed 
particular application rule enables number instantaneous rules taken immediately ensured actions performed time elapses 
rule may example produce message consumed time advances 
cases possible add conditions tick rules time elapse time critical rule enabled may considerably complicate specification 
computing enabledness condition time critical rule explicitly convenient rewriting logic notion internal rewrite strategy cde cla cm execution supported maude reflective features cde cm deal enabledness priority aspects simple strategy 
idea divide rules real time rewrite theory eager lazy rules admissible rewrites rewrites application eager rules takes precedence application lazy rules 
definition real time theory set rewrite rules partitioned disjoint sets 
set admissible rewrites rewrites lazy rules applied sequentially furthermore applied eager rule enabled 
rewrite admissible identity proof equivalent factorization 
proof terms corresponding step sequential rewrites tj tj proof application rule step sequential rewrite tj applying rule 
tick rules non time critical instantaneous rules lazy implies time advance eager rule enabled 
treatment timed petri nets section gives example convenience strategy 
notation eager strategy eager lazy rules preceded keywords eager lazy respectively 
time action system state system rich structure may natural necessary explicit function denoting effect time elapse state 
function denoting action time system form state time state involving designated sorts state time 
action monoid action natural require satisfies axioms tick rules form yr zr yr zr 
tick action describe effect passage time dynamic evolution system possible pitfalls 
done may allow going back time perform rewrite 
suppose example holds term rewrites aged rewrite illustrated example 
example specification intended specify discrete time clock time sort nat natural numbers reset reached value 
sorts state system op clock nat state op state nat state op state system vars xr yr nat var state eq clock xr yr clock xr yr rl reset clock clock rl tick xr xr starting clock rewrite sequence tick 
clock clock clock clock clock clock reset rule applied time 
problem equation reset rule coherent explained 
executable specification purposes important require set equations rewrite theory divided set simplifying equations set ax structural axioms way equations define church rosser terminating set equations modulo set ax set rules coherent cde vir ax 
rewrite theory coherent step sequential rewrite modulo structural axioms ax rewrite modulo ax normal form modulo ax equivalent 
coherent system ground terms form reduce equations terms form allow going back time sense rewrite inducing rewrite equivalent rewrite ax 
commonly occurring state structure want action time distribute different state components multiset distributed structure 
example object oriented systems petri nets structure 
multiset distributed systems give general treatment time actions avoids lack coherence problems 
simple solution avoid lack coherence problems rule rewrite terms sort system solve coherence problem symbol rewrite occur top 
concurrency lost solution 
solution special tokens form extended state term supersort designated sort state consisting multiset union original state multiset tokens 
system operator takes arguments sort left unchanged function state time state 
multiset union denoted juxtaposition tick rules take form tick variable subsort tokens denoting multisets tokens term sort state 
local rule form token appears lefthand side local rule global state contain tokens local rewrites fire concurrently 
object oriented systems number tokens configuration suitably equal number objects configuration number rewrites firing concurrently bounded number objects global state assumption object appears lefthand side rule 
coherence symbol trivially unproblematic instance lefthand side local rule sort argument 
general approach deal time action multiset distributed states specialized object oriented systems section illustrated multi thermostat system example section 
summarize monoid action denoting effect time elapse state may useful specifying real time systems state system rich distributed structure require coherence ensures cause counterintuitive rewrites resulting going back time specifying models real time hybrid systems rewriting logic show known models real time hybrid systems naturally regarded specializations real time rewriting logic framework 
interested executable specifications place computability restrictions models 
exhaustive discussion real time models think models chosen significantly varied known suggest rewriting logic semantic framework real time hybrid systems 
timed automata show timed automaton see ad specified rewriting logic 
timed automaton reads timed words infinite words symbol word time stamp equipped set clocks 
transition may reset clocks applied values clocks satisfy clock constraint transition 
example timed automaton fig 
accepts timed words alternating occurrences input symbols starting occurrence followed occurrence earlier time time occurrence occurrence followed time 
furthermore occurrence followed occurrence time 
time model timed automata set nonnegative real numbers 
get computable data type replace set nonnegative elements computable ensure maximal possible concurrency rewrite steps tokens may added righthand side rule rule increases size state 
timed automaton 
subfield rationals algebraic real numbers 
omitting details initial states acceptance conditions timed automaton tuple finite alphabet finite set states finite set clocks defining set clock constraints inductively clock constant set nonnegative rationals set transitions 
tuple represents transition state state input symbol set gives clocks reset transition clock constraint timed word infinite sequence tuples ai ri ai input symbol ri time occurs ri ri automaton starts time clocks initialized 
time advances values clocks change reflecting elapsed time state automaton change transitions passage time clocks increased elapsed time 
time ri automaton changes state transition form ai reading input ai current values clocks satisfy 
transition clocks reset start counting time 
run timed automaton infinite sequence states valuations transition si si ai clock valuation vi def satisfies clock constraint vi clock vi vi 
set runs timed automaton denoted runs 
assume remainder section set clocks ordered sequence 
cn 
timed automaton naturally represented real time rewrite theory ta ea la ra follows runs infinite timed words automaton proceed reading symbol timestamp accepted automaton 
ea contains equational axiomatization time domain 
furthermore signature contains sort constant sort state ary operator 
time 
time state operator state system 
set la labels tick 
set rules ra associated duration assignment contains instantaneous rule 
xn 
tn 
xn transition xi variables sort time term ti ci ti xi 
xn obtained substituting clock ci xi substituting boolean operators 
addition rule tick 
xn yr yr 
xn yr yr 
xn variables added model time elapse 
timed automaton fig 
represented real time rewrite theory containing rules tick yr yr yr yr variables sort time variable sort 
ta step ta simulates step run timed automaton ground rewrite ta proof corresponding possibly empty sequence tick applications 
passage time modeled arbitrary sequence tick applications total time elapse consider ta steps equivalent hold 
conditions imply ta step uniquely determined written ta computation rewriting logic representation ta timed automaton infinite sequence 


ta steps ta 
set ta computations ta modulo ta step equivalence denoted ta ta 
theorem timed automaton ta rewriting logic translation 
exists bijective function runs ta ta assigning run form defined ta computation form si ti ri ai bi rij vi cj 

proof sketch theorem follows fact si vi ai si vi transition step si si vi vi ta step si ri 
rin ai ta vj ck 
si ri 
ri equational axioms defining equivalence rewrite proofs rewriting logic mes prove proposition non identity ground rewrite proof ta decomposed sequence 
ta steps 
tick applications 
infinite computation ta see section starting term form 
involving infinite number instantaneous rule applications rearranged form ta computation appropriate composition arrows 
ways modifying specification simulate behavior automaton timed words satisfying acceptance condition 
possible define computable predicate computation computation 
rn holds exists accepted timed word starting state rational numbered values 
rn clocks 
cn predicate computable finitely specifiable church rosser terminating equations bt defining predicate reduces emptiness problem timed automata decidable ad 
way obtain rewrite theory computations simulate behavior automaton accepted timed words adding condition computation 
tn rule form 
xn 
tn including tick rule 
modular alternative way restricting rewrites simulate automata behavior accepted words encode accepting states sets states muller automata predicates rewrite theory internal strategies metalevel rewriting logic restrict application rules accepted timed words executed 
hybrid automata hybrid automaton ach called hybrid system finite automaton equipped variables evolve continuously time dynamical laws location labeled invariant condition hold control resides location 
hybrid automaton fig 
describes simple thermostat keeps temperature room turning heater 
simplified model temperature room increases degrees time unit heater turned decreases degree time unit 
turn turn hybrid automaton model thermostat 
time model hybrid automata set nonnegative real numbers replace set nonnegative elements computable subfield timed automata 
hybrid automaton tuple vd loc lab act inv edg vd finite set data variables ranging data sort defining data space set sort consistent valuations vd 
loc finite set locations corresponding states untimed automata 
state space hybrid automaton loc lab set synchronization labels including label 
act labeling function assigns location loc set actl activities 
activity function activity actl time value activity actl defined 
inv labeling function assigns location loc invariant inv edg finite set transitions 
transition consists source location target location transition relation synchronization label location stutter transition id id 
hybrid automaton fig 
locations valued data variable denoting temperature room non stutter transitions turn turn 
location inv set functions fr defined fr 
invariant activities location entirely similar 
state hybrid automaton change ways instantaneous transition changes entire state transition relation elapse time changes values data variables continuous manner activities current location state evolves time activity location 
system may stay location invariant location remains true 
invariants hybrid automaton enforce progress underlying discrete transition system 
transition taken invariant location false 
run hybrid automaton finite infinite sequence denote locations denote valuations variables vd denote synchronization labels denote time values fi constant id activity location li conditions hold vi inv li furthermore fi id ri vi inv li vi vi li li ai edg fi activity fi vi fi inv li ri fi ri vi li li ai edg 
set runs hybrid automaton denoted runs denotes subset runs inv 
definition run slight modification appearing ach exhibits transition step uses special symbol id allow transition taken zero time state vj satisfying inv lj time advancing activity acting state adds requirement vi inv li ensure final state run satisfies invariant location 
remainder section assume set vd data variables ordered sequence 
xn 
definition hybrid automata general restrict treatment subclass hybrid automata satisfying natural requirements 
require set activities actl location generated finite set nl computable functions called activity generators fi satisfies property thermostat example functions defined 
set actl activities location generated follows actl xr 
xr furthermore require location activity generator computable function max stay max stay denotes amount time system state stay location performing activity function violating invariant location require computable predicate inv loc bool inv holds state violate invariant location necessary find natural assume transitions identity transitions edg implies id furthermore require data type computable 
stating requirement transition hybrid automaton explain necessary details associated rewrite theory ha 
hybrid automaton vd loc lab act inv edg variables ordered 
xn satisfying requirements represented real time rewrite theory ha ea la ra follows 
signature contains sort location constant location loc sort si data sort si variable xi sort valuation ary operator 
sn valuation operator location valuation state operator state system 
furthermore ea contains finitary axiomatizations data types sorts 
sn time domain time specifies extension ltime ea sets functions valuation time valuation max valuation time function inv location valuation bool 
functions data types finitary equational axiomatizations assumed computable bt 
set la labels lab tick loc tick loc lab tick tick assumption hybrid automaton transitions specified rewrite rules 
require transition edg expressed finite set rewrite rules form 
tn 

xn un 
xn 

un 
ground step rewrite rules 
set ra rewrite rules ha associated duration assignment function contains corresponding rule 
tn 
inv 
true transition edg conjunct condition added translation underlying untimed transition ensure resulting state satisfies invariant location tick rules system associate rewrite rule form location activity generator xr xr xr max variable sort valuation 
rewriting logic translation thermostat fig 
may instantiate translation schema way 
domains interpreted sorts time temp necessary functions rest theory declarations sorts location valuation state system ops location op temp valuation op location valuation state op state system ops valuation time valuation op inv location valuation bool ops max max valuation time var temp var yr time var valuation eq inv eq inv eq max eq max eq yr yr eq yr yr crl turn inv crl turn inv crl yr yr yr max crl yr yr yr max ha step ha intended model step forms ground rewrite form lab models step ground rewrite form 
models step id ground rewrite form models step identity rewrite ground term sort system models step id activity may generated different activity generators identify ha steps tick tick furthermore transition modeled rule ha choice rule apply different rewrites different steps 
identify ha steps form identifications ha steps extend composite ha steps making ha steps tick tick equivalent ha steps ha computation ha finite infinite sequence 


ha steps li ti 
tin li ti 
ti ha inv 
true 
set ha computations ha modulo ha step equivalence denoted ha ha 
theorem 
xn loc lab act inv edg hybrid automaton satisfying additional requirements 
exists bijective function ha ha takes run form ha computation form appropriate 
tij vi xj ri tick ti 
tin ri ai ai fi id li satisfying li vi fi ai ai fi id tick ti 
tin ri li ai fi id identity step ai fi id furthermore computation ha starting state satisfying invariant location prefix computation corresponds ha computation ha ha 
proof sketch easy see induces bijection set initial states set initial states ha computations 
theorem definition indicate step run correspondence ha step 
say mapped unique ha step modulo equivalence ha steps follows key property actl implies activity generator conversely application image step key property condition tick rule implies state rewritten definition relationships activities activity generators activity actl defined uniqueness follows directly definitions 
computation see section prefix thereof ha starts initial state sort system initial valuation satisfies invariant state location trivially ha computation step rewrite ha step 
timed transition systems timed transition system tts mp transition system transition equipped lower bound denoting shortest time transition continuously enabled taken upper bound denoting longest time transition continuously enabled taken 
formally tts tuple finite set 
xn data variables xi ranging data sort si defining state space sort consistent valuations variables finite set transitions functions assign transition lower bound la upper bound ua la ua 
transitions assumed self disabling implies example system variable ranges changes time changing changes back time modeled tts tab transitions having lower bound upper bound having lower bound upper bound 
ignore tts equipped set initial states 
computation tts infinite sequence pairs valuations vi time values ri vi vi ri ri ri ri vi vi holds transition enabled time la ri rj la enabled states vj vj 
vi 
furthermore transition enabled state vi disabled state vi ri ri ub 
required rj grows bound increases 
set computations tts denoted comps 
time domain computable subfield nonnegative reals assume underlying untimed transition system finitely specified rewriting logic way data types computable transition specified finite set rewrite rules way precise giving necessary information translation 
assume transition possible define computable predicate true transition enabled state 
model tts rewriting logic representing system state term 
tn 
cm term 
tn represents valuation 
xn tn transition system variables ci clock value nil transition ai enabled state ri transition ai enabled continuously time ri 
precisely timed transition system 
xn satisfying requirements set timed transitions ordered sequence 
am 
rewriting logic translation tts lt rt real time rewrite theory contains specification sorts 
sn variables time domain equational theory morphism time extended equational theory morphism time 
addition contains sorts valuation state system time subsort declaration time time constant nil time ary operator 
sn valuation ary operator 
valuation time 
time 
state operator state system declarations time 
time bool time 
time time 
add axioms nil xr nil xr time nil yr true yr time 
predicate valuation bool transition set lt labels choose set trans tick computations tts independent choice transitions taken 
giving rules rt precise assumption able represent transitions rewrite rules assuming untimed transition ai modeled finite set rewrite rules form 
tn 

xn ai 
xn wn holds 
wn 
step ground rewrite rules 
set rt rules duration assignment follows 
transition ai modeled timed system tts corresponding instantaneous rewrite rule trans 
tn 
cm 

lai ci 
cm set distinct variables sort time 
occurring ti abbreviation expression 
nil cj nil cj fi fi 
addition rt contains tick rule ensures transition ai time elapse past moment ai enabled time uai tick 
cm xr xr 
cm xr xr ci xr uai variable sort valuation xr variable sort time 
real time rewrite theory tts tab example system tab consists rules simplified enabled predicate explicitly transition transition ordering construction tts tab trans nil trans nil tick xr xr xr xr xr xr variables sort time sort valuation xr sort time 
tts computation tts infinite sequence 



step ground rewrites tts sum grows bound increases transition ai enabled valuation 
xn nil 
set tts computations tts denoted tts tts 
theorem 
xn 
am timed transition system satisfying additional requirements section 
bijective function comps tts tts computation form defined tts computation form ri ri proof term tij vi xj 

proof sketch clearly induces bijection initial states comps initial states tts tts 
prove gives correspondence prefixes computations tts computations having steps correspondence steps observe cij nil aj enabled vi computation cij nil rl cij ri aj enabled vl vl 
vi aj enabled vl 
phase transition systems phase transition systems ptss mp generalize timed transition systems model suitable specifying hybrid systems give brief overview representation ptss rewriting logic 
gives details translation 
intuitively pts model extends tts model letting time act valuation function denotes state pts time acted system state time furthermore time elapse past moment enabling condition transition changes 
special case tts characterized ptss projection function time acts trivially states 
action time change enabling transitions assume computable function enabling change takes state argument gives maximum time system proceed changing enabling transition 
global state instantaneous transitions pts modeled rewriting logic tts case 
functions enabling change defined terms sort valuation 
tick rule ensures addition tts requirement time elapse latest moment transition taken state components updated continuous behavior corresponding clocks updated enabling condition changes tick 
cm xr xr 
ci xr uai xr enabling change 
cn xr distinct variables appropriate sorts abbreviates xr nil cj nil cj xr fi fi 
object oriented real time systems section specialize real time systems representation concurrent objects rewriting logic proposed mes 
concurrent object oriented system concurrent state usually called configuration typically structure multiset objects messages 
view configurations built binary multiset union operator represent empty syntax configuration configuration configuration assoc comm id note expression phase transition system hybrid systems extension clocked transition system mp model 
discuss clocked transition systems thesis 
multiset union operator declared satisfy structural laws associativity commutativity identity 
subsort declaration object msg configuration states objects messages singleton multiset configurations complex configurations generated multiset union 
sort denoting configurations messages obtained adding subsort declaration operator declaration object configuration assoc comm id 
objects terms sort object form att val 
attn valn denoting object named belongs sort oid object identifiers class state having values val 
valn attributes att 
attn respectively 
dynamic behavior concurrent object systems axiomatized specifying concurrent transition patterns rewrite rule 
example rule att att att att att att defines family transition message having arguments consumed object class effect altering attribute att object generating new message 
convention attributes att example values change affect state attributes need mentioned rule 
attributes att values influence state attributes values messages unchanged may omitted righthand sides rules 
rule written att att att 
real time object oriented systems specified means real time rewrite theories extending setting sort system operator configuration system 
tick rules global transitions simultaneously advance time objects configuration 
system may exhibit concurrency local transitions may occur tick applications 
illustrate style specification real time object oriented systems simple example 
example single thermostat system single thermostat system consists thermostat object zero user objects 
user may request new desired temperature time sending message thermostat provide temperature degrees user desire possible 
thermostat works modeled fig 
temperature increases degrees time unit heater turned decreases degree time unit heater turned 
assume specification includes specification time satisfies theory time sort temp denoting possible temperature values necessary operations 
sort contains constants describing state heater associated thermostat 
thermostat object attributes curr temp desired temp sort temp denoting current desired temperatures attribute heater denoting state heater 
user object object empty set attributes 
ts variables sort oid object names xr variable sort time variables sort temp oc variable sort message configurations 
time user may request new desired temperature new temp user user set temp 
thermostat object treat message recording new desired temperature followed changing heater state necessary treat request set temp ts thermostat desired temp ts thermostat desired temp thermostat turn heater time acted system current temperature exactly desired temperature plus minus degrees system change due adjustment desired temperature case current temperature may degrees desired temperature ts thermostat curr temp desired temp heater ts thermostat heater ts thermostat curr temp desired temp heater ts thermostat heater 
tick rules model effect time elapse system ensure 
time elapse moment reflecting fact rule new temp applied time 
time elapse past moments heater state changed 
time elapse messages system requested temperature recorded time requested user accomplished variable oc sort 
ts thermostat curr temp desired temp heater oc xr ts thermostat curr temp xr xr oc xr xr ts thermostat curr temp desired temp heater oc xr ts thermostat curr temp xr oc xr 
specification expected provided initial state contains exactly thermostat object 
specification thermostat system section 
object oriented systems elapse time affects functional attribute single thermostat system described 
tick rules specifying directly effect time attribute 
general object oriented systems unbounded number objects configuration affected elapse time case finite number tick rules specify elapse time directly functional attributes 
simple solution function denoting action time configuration 
important class realtime object oriented systems objects functional attributes provides instance multiset distributed systems 
techniques described section circumvent lack coherence problems sacrificing concurrency 
declarations added general framework specifying object oriented real time systems redefined stated 
sorts tokens configuration subsorts tokens configuration configuration op tokens op tokens tokens tokens assoc comm id op configuration configuration configuration assoc comm id op configuration system op configuration time configuration 
tick rules form section sort state specialized configuration 
instantaneous rule form terms sort configuration number tokens righthand side equal plus number objects created rule minus number objects deleted rule 
initial state system form number tokens equals number objects term sort configuration 
systems number objects created rule application depends state condition form rules relaxed term sort tokens computing number tokens function state 
distribution configurations 
operator acting configurations provides just seen natural way expressing action time object systems number objects configuration time effect unbounded 
cases typically distribute elements configuration modeled axioms xr xr xr xr variables sort configuration definition specific effect time single objects messages added completely specify 
condition different ensures equations define terminating rewrite system modulo associativity commutativity identity configuration union operator oriented left right 
systems parameterized ltime theories function mte giving maximum time elapse objects messages extended configurations axioms mte mte min mte mte andc 
example multi thermostat system multi thermostat system arbitrary number rooms equipped thermostat works single thermostat system 
user object extended contain list access 
specification parameterized theory ltime 
furthermore ts variables sort oid variable sort sets oids set union denoted juxtaposition variable sort configuration variable sort tokens xr variable sort time variables sort temp 
function configuration time configuration denoting action time function mte configuration time computing maximum time elapse tick distribute configurations equations described defined singleton configurations follows set temp xr set temp user xr user ts thermostat curr temp heater xr ts thermostat curr temp xr xr heater ts thermostat curr temp heater xr ts thermostat curr temp xr heater mte set temp mte user mte ts thermostat curr temp desired temp heater mte ts thermostat curr temp desired temp heater 

rules system follows new temp user ts user set temp ts set temp set temp ts ts thermostat desired temp ts thermostat desired temp turn ts thermostat curr temp desired temp heater ts thermostat heater turn ts thermostat curr temp desired temp heater ts thermostat heater tick xr xr xr mte 
timed petri nets petri net rei usually set places place representing certain kind resource disjoint set transitions relation causality associates transition set resources consumed produced firing 
meseguer montanari recast idea algebraic framework mm viewing distributed states net called markings multisets places viewing transitions arrows ordinary graph nodes markings 
mes shown petri net computations expressed rewriting markings 
petri nets extended model real time systems different ways see aal mpt han 
frequently ways adding time petri nets mpt timed versions petri nets obtained special cases combining extensions 
transition associated time interval lt ut 
transition fires soon resulting tokens delayed transition fires resulting tokens visible system time lt ut 

place duration dp 
token place participate transition time dp 

transition associated time interval lt ut transition fire continuously enabled time lt transition enabled continuously time ut taken 
cover cases special cases interval timed colored petri net itcpn model proposed van der aalst aal 
third case treatment similar timed phase transition systems sections 
appear context colored petri nets having atomic places structured data 
exposition away colors tokens concentrate real time features see treatment colored nets rewriting logic 
interval timed petri nets interval timed petri net 
give definition interval timed petri nets similar interval timed colored petri nets aal 
differences models ignore coloring tokens notion concurrent firing multisets transitions 
itpn model itcpn model attach timestamp token 
timestamp indicates time token available 
enabling time transition maximum timestamp tokens consumed 
transitions eager fire fire soon possible 
transition smallest enabling time fire 
firing atomic action producing tokens timestamp equal firing time plus firing delay specified lower upper bound possible values token produced transition 
itpn fig 
models setting process performs transition followed performing transition time followed performing transition time 
furthermore process forks performing transition modeled having arcs created process behavior parent process 
finite multiset set function set natural numbers support finite 
denote set finite multisets empty multiset define membership inclusion multiset union subtraction max time domain set nonnegative real numbers executability purposes assume time domain itpn nonnegative part computable subfield reals 
set ti time intervals set ti 
definition interval timed petri net itpn tuple finite sets places transitions ti functions denoting respectively tokens consumed produced transition delay intervals produced tokens itpn 
set markings mrk set finite multisets pairs representing presence token place timestamp function places mrk removes timestamps marking defined places 
function max mrk finds maximal timestamp non empty marking max max 
earliest enabling time transition marking function eet mrk defined eet min max mrk places min 
function ti ti adds second argument intervals tokens defined relate multisets tokens timestamps multisets tokens time intervals define specialization relation mrk ti holds token corresponds token place timestamp token interval corresponding token ti 
itpn computational progress applying transitions consuming producing multisets timestamped tokens 
finite number transition firings occurring time composed parallel form step nonempty finite multiset transitions 
itpn denote step marking marking concurrent firing transitions define step relation mrk mrk triples generated rules places max eet eet mrk eet eet eet eet eet step sequence finite infinite sequence steps mi ei mi step represents simultaneous firing transitions ei time eet mi 
set step sequences itpn denoted timed petri nets type transitions durations tokens produced transition firing delay seen special case follows 
transition time interval lt ut consumes tokens produces tokens simulated itpn adding new place pt having transition consumes tokens produces token place pt time interval lt ut transition consumes token pt produces tokens zero time 
timed petri nets type place duration seen special case token produced place firing delay dp 
specifying real time rewrite theories 
translation rewriting logic timed petri nets rewriting logic representation untimed petri nets mes state petri net represented multiset places called marking place multiplicity interpret presence tokens place transitions correspond rewrite rules corresponding multisets pre post places 
sake simplicity rewriting logic representation choose carry timestamps tokens times 
term sort represents visible occurrence token place token visible place time represented term dly sort 
token delay visible dly 
marking multiset forms tokens multiset union represented juxtaposition 
sort marking denotes set markings 
function mte takes term sort returns time pass delayed token available 
function models effect passage time delayed tokens decreasing delays time elapsed 
rewriting logic translation itpn 
pn real time rewrite theory itpn en ln rn time axiomatization time domain extended ltime en declarations axioms sorts place marking system subsorts marking ops pn place op dly place time marking op empty op marking marking marking assoc comm id empty op assoc comm id empty op assoc comm id empty op assoc comm id empty op marking system op time marking op mte time vars dm dm var vm var place vars xr yr time cmb dly xr xr eq dly eq empty xr empty eq dly xr yr dly xr yr ceq dm dm xr dm xr dm xr see interesting information time lost simplification time firing transition occurs extracted proof term 
dm empty dm empty eq mte empty ceq mte dly xr xr xr ceq mte dm dm min mte dm mte dm dm empty dm empty set rn rules itpn consists lazy tick rule modeling time elapse transition corresponding eager rule 
transition modeled instantaneous rule eager dly dly pn xn ln xn un marking consisting occurrences term dly dly pn xn 
xn set distinct variables sort time domain occurrence distinct 
pi li ui tick rule advances time delayed token visible lazy tick vm dm mte dm vm dm mte dm mte dm 
example translation itpn fig 
contains tick rule instantaneous rules eager dly xr dly yr xr yr eager dly xr xr transitions supposed fire soon possible timed petri nets 
accomplished strategy described section triggers eager transition rules applied followed application tick rule 
eager lazy rules allows simple condition tick rule take account enabledness transition system mte part tick rule 
tick rule needs compute time delayed token visible advance time amount 
tick tick rule enabled due lazy applied new token enables eager transition turn trigger transitions zero time 
itpn markings multisets necessary apply techniques described section specify rewriting logic 
terms sort rewritten implies aged rewrites function mte time lead undesired nontrivial rewrites time domain 
step itpn depend firing delays individual transitions taken step step rewrites considered equal sense add equivalence equality identifying rewrite proofs multisets rule labels 
equivalent iff 
rn 
recursively equivalent 
itpn computation itpn finite infinite sequence possibility stopping moment time domain non deterministic time advance xr mte dm desired 
admissible rewrite proofs ui ui itpn ui ui itpn modulo equivalence proof terms corresponds identity proof sequence tick applications corresponds step concurrent rewrite instantaneous rules term term sort marking 
set itpn denoted itpn itpn 
proposition follows factorization property proofs rewriting logic mes 
proposition non identity admissible ground rewrite itpn equivalent rewrite rearranged finite itpn computation corresponds identity proof sequence tick applications 
infinite computation itpn consisting admissible rewrites involving ground terms sort system contains infinite number applications instantaneous rules rearranged itpn computation appropriate composition arrows 
fact faithfully represented rewriting logic translation precise theorem 
theorem itpn 
bijective function itpn itpn step sequence form itpn computation form ui term equivalent term form wi consists mi occurrences term dly 
recall dly equivalent 
transitions fire time 
eet mi 
transitions taken concurrently step 
equivalent proof term form wi wi term multiset consisting exactly ei occurrences proof terms form 
rn 
proof sketch step sequence inductively define unique itpn computation having desired properties follows 
term obtained ei letting consist terms form dly 
mi mi step 
induction unique prefix steps 
particular assume ui mi term form wi wi consists mi occurrences term dly ri mi ri eet mi 
furthermore state mrk denote containing pairs elements consumed firings place time multiset places wi corresponds ri transition enabled state mi time eet mi eager rule enabled ui time elapsed eet mi tick rule exhibits deterministic behavior time unique sequence tick applications eet mi ri applied ui giving term term contains mi occurrences term dly eet mi mi 
visible marking places eet mi 
associate ei unique modulo equivalence proofs described rewrite ui proof term form vi term vi form nonempty multiset proofs consisting occurrence transition ei 
term ui term wi wi contains mi occurrences term dly eet mi mi 
conversely itpn computation form inductively define uniquely associated step sequence satisfying desired properties follows 
equals number occurrences term dly dly 
ui ui ith step ui induction state mi corresponding ui consists occurrence ri occurrence term ui occurrence ri occurrence term dly ui 
shown ri eet mi instantaneous rule enabled ui time reaches eet mi due eagerness instantaneous transitions tick rule applied instantaneous rule enabled ri eet mi 
multiset visible tokens equivalent places eet mi maps unique ei contains occurrence transition occurrence proof term 

new token dly created corresponds presence new pair eet mi mi ensuring resulting states satisfy desired relationship ui mi 
relationship timed rewriting logic section investigate relationship wirsing timed rewriting logic trl kw framework specifying real time systems directly rewriting logic 
briefly introducing trl section propose section translation trl rewriting logic translation trl sequent derivable trl theory derivable corresponding rewriting logic theory 
converse general true due conceptual differences trl method specifying real time systems rewriting logic explained section 
timed rewriting logic rewriting logic extended wirsing handle real time systems timed rewriting logic trl kw 
trl shown suited giving object oriented specifications complex hybrid systems steam boiler kw illustrated number specifications simpler real time systems 
translation ordinary rewriting logic illuminate conceptual relationships formalisms 
trl theory tr consists equational specification satisfying theory time set labels set tr timed rewrite rules form ground term sort time denoting duration rewrite 
trl sequent form intuitive meaning evolves time specifically set sequents derivable trl theory consists rules theory sequents impose cases requirements time monoid 
course easily accommodated 
timed transitivity synchronous replacement ti 
tn xn xi 
xik 
compatibility equality renaming variables ik 
xn 
tik renaming variables 
deduction rules timed rewriting logic 
derived equational reasoning deduction rules denotes set variables deduction system extends modifies rules deduction rewriting logic time stamps follows reflexivity dropped general axiom allow parts system stay idle arbitrarily long periods time 
transitivity yields addition time stamps 
evolves time evolves time evolves time 
synchronous replacement rule enforces uniform time elapse components system system rewrites time iff components 
timed rewriting logic rewriting logic section define mapping takes timed rewriting logic theory real time rewrite theory implies ground terms designated sort state 
idea introduce sort operator time corresponding effect time elapse 
trl sequent evolves time mapped rewriting logic sequent time acted time rewrites ground terms rewrite rules define effect time trl state necessarily functional 
sort information separate terms containing symbol terms original signature tick rule added rules defining ground terms sort state holds turn holds holds 
resulting real time rewrite theory easily executable tick rule introduces variables righthand side 
reflects fact trl general undecidable term rewrites time known rewrites time general undecidable rewrites term time assume time domain functional rewrites form terms sort time inferred trl theory restrict treatment trl theories extra variables introduced righthand side rule 
reason restriction rules system appears result second rule evolved time units system 
transitivity rules sequent derivable means system replace including systems evolved time units 
mapping trl real time rewrite theories mapping sends order sorted trl theory tr real time rewrite theory tr sends sequent sequent 
defined follows signature morphism takes time sort time denoting time domain takes functions time corresponding functions set sorts consists sorts plus new sort sort new sort system 
sort 
contains function declarations sn function sn constructor state system designated sort state function time sort 
contains axiom axiom variable replaced set define monoid action contains axioms yr zr yr zr sort variable sort variables yr zr sort time 
mapping trl sequents rewriting logic sequents 
xn sn 
xn sn 
xn 
xn xn free variables 
xn contain set rules tr consists rule tr tick rule tick yr yr variables sort state yr sort time 
timed rule theorem shows naturally understood map logics 
specifically map trl entailment system mes trl rewriting logic 
theorem trl specification defined 
terms implies 
corollary theorem easily proved induction size proof obtain implies ground terms turn gives rewrite sort state applying tick rule 
easy see implies ground terms sort state 
differences trl rewriting logic translation implies ground terms converse necessarily true 
section discuss differences deduction trl translation rewriting logic 
zero time idling rewriting logic translation trl sequent translates 
xn xn due axiom equal deducible rewriting logic 
trl necessarily valid 
obviously indicates difference systems notion zero time idling available approach trl 
non right linear rules trl theory term rewrites time rewrite 
rewriting logic translation tick xr xr variables designated state sort range free terms rewrite rewrite 
difference depends fork process modeled 
rule understood fork sub process system 
trl setting actual fork point time instances process behave independently place time period length rule 
rewriting logic setting forking took place time period duration problems related synchrony trl aspect trl rewriting logic translation different illustrated trl specification 
due strong synchrony requirements trl rewritten place rewritten time 
cases natural assume system represented rewrites time 
rewriting logic translation rewrites 
aging trl overcome strong requirements synchrony trl caused differences sections special symbol age introduced kw 
aims making term rewrites time accessible synchronous rewrites time making visible age 
formally aging deduction rules added trl deduction rules 
deduction rules assumed timed rewrite rule specification 
age age age age note rewriting logic setting adding rule system gives fork took place early 
behavior avoided requiring variable rule non sort 
age operator satisfies axiom age age age terms time values aging fork differences disappear assuming age age system example section strong synchrony illustrated fact example section derivable age age age age derivable 
unfortunately deduction rules aging lead counterintuitive results illustrated example example trl theory expect derivable 
sequents age age derivable age age 
sequents age give age synchronous replace ment turn rewrites age 
transitivity gives undesired sequent 
summarize situation follows 
seen rewriting translation trl theory looser cases pleasant consequences 
attempt tighten correspondence systems adding aging rules trl get closer unfortunately encounter paradoxical examples reformulation trl 
concluding remarks general method specifying real time hybrid systems rewriting logic executable way shown wide range real time hybrid system models naturally expressed rewriting logic illustrated ideas examples 
extended directions 
systems considered distributed exhibit concurrent computations components state change simultaneously independently 
time sense global time acts global state effects local distributed example advancing local clocks different distributed objects 
situation entirely similar real time models distributed systems lynch general timed automata lyn time acts uniformly distributed components 
fact discussed general timed automata chapter specified general framework 
current framework specifying reasoning range distributed time systems worth investigating assumption global time action relaxed local distributed time actions 
explored think representative range real time hybrid system models 
general timed automata model mentioned real time dataflow models lustre variety models including timed process algebra models specified detail rewriting logic 
interest merely conceptual formal meta tool maude cde turn rewriting logic specification model tool executing analyzing formal specifications model fact done real time maude language tool thesis 
formalisms lack execution analysis environments offers way developing new formal tools considerably effort required conventional implementations 
chapter real time maude language tool simulating analyzing real time hybrid systems previous chapter showed real time hybrid systems naturally specified realtime rewrite theories 
chapter describes real time maude language tool specify analyze theories 
real time maude capitalizes executability property rewriting logic maude engine underlying execution mechanism 
specification language tool directly supports real time aspects special syntactic features timed modules timed object oriented modules 
theoretical level syntactic features support specification real time rewrite theories transformed ordinary rewrite theories executed maude 
transformation performed internally real time maude tool 
executability formal analysis real time specifications poses new problems tool address 
time advances nondeterministic 
reflected tick rewrite rules new variables righthand side condition 
second commonly occurring situation time critical rules eager executed instantaneously delay rules lazy executed eager rules enabled 
real time maude tool supports execution analysis real time specifications providing user library execution strategies different forms default execution formal analysis directly address nondeterminism eagerness laziness requirements just mentioned support model checking temporal logic properties 
furthermore ease new strategies defined maude reflection tool easily extensible user define new application specific strategies perform forms analysis 
illustrated section scheduling case study application specific strategy finds solutions scheduling problem 
rest chapter organized follows 
section explains real time maude specification language theory transformation process maude section describes real time maude tool execution search commands section gives example tool specify analyze class scheduling problems 
symbolic simulation formal analysis real time maude maude tool strategies real time systems application specific strategies real time rewrite theory annotated rewriting logic theory architecture real time maude tool 
real time maude specifications execution results traces execution results traces bugs analysis results bugs analysis results real time maude language tool extend full maude support specification execution formal analysis real time rewrite theories 
real time rewrite theories specified timed modules object oriented timed modules 
tool transforms timed modules pair consisting untimed maude module set labels lazy rules module 
shown tool execute analyze real time rewrite theories different ways executing specifications underlying maude interpreter ii library tool specific strategies iii application specific user defined strategies 
maude default interpreter unsatisfactory real time specifications maude general default execution strategy take account time aspects 
real time maude provides library rewriting strategies specially designed execution analysis real time specifications 
strategies library executed reflective way extensions maude meta level module include default execution strategies search strategies 
addition users real time maude tool write applicationspecific strategies modules extending meta level timed meta level extends meta level useful functions real time specifications input strategies tool library reusable components 
specifying real time rewrite theories real time maude tool real time rewrite theory specified timed module user level enclosing module body keywords timed system modules object oriented timed modules 
state non executable properties real time maude allows user specify real time extensions full maude theories object oriented theories respectively keywords tth timed theories toth object oriented timed theories 
timed rule terms sort system written syntax crl time similar syntax case unconditional rules 
specify instantaneous tick rules lazy placing keyword lazy front rl crl 
equational theory morphism theory time explicitly specification level 
default timed module automatically imports functional module timed prelude includes declarations sort time op zero time op plus time time time assoc comm prec gather op monus time time time prec gather ops le lt ge gt time time bool prec vars time eq zero eq le lt eq ge le eq gt lt morphism implicitly maps time time zero plus le real time maude assumes fixed syntax time operations tool build fixed model time 
fact user complete freedom specify data type time values discrete dense 
importing specific data type time values satisfying time theory sort say values 
declaring subsort inclusion time 
giving appropriate equations interpreting operators plus monus lt 
example want discrete time domain sort chosen positive machine integers declarations subsort time vars eq zero eq plus eq lt eq monus fi applications developed far data types time positive machine integers positive rational numbers fractions machine integers positive reals fixed point arithmetic 
real time maude specifications appendix acceptable experimental purposes data types unsatisfactory due machine overflow axioms theory time strictly speaking satisfied 
situation course remedied defining functional module peano arithmetic defining rationals terms inefficient maude built data type nat naturals unbounded size allowing easy definition module rat rationals efficient models discrete dense time strictly satisfying time theory available 
timed modules contain default sorts state state component system operator state system 
sort state declared subsort sort state 
module operations real time maude extends full maude cde usual module composition operations provided full maude supported real time maude constraints module importing timed module theory having timed theory parameter declared timed module theory 
module contain eager lazy rules having label 
database modules may contain eager lazy rules having label belonging different modules 
actual parameter introduce lazy rules mentioned corresponding formal parameter theory 
timed object oriented modules timed object oriented modules extend object oriented timed modules provide support object oriented real time systems 
particular explained section object oriented timed modules include specification sorts tokens 
furthermore contrast untimed object oriented systems functions mte tick rules involve global configuration useful richer sort structure configurations 
timed object oriented modules include sorts exception module inclusion meta level timed meta level parameters may timed modules 
restriction may omitted versions tool 
denoting respectively multisets messages non empty multisets messages multisets objects non empty multisets objects non empty configurations 
subsort declaration state automatically added object oriented specifications 
extensions time domain module library real time maude includes functional modules time inf ltime ltime inf extend time domain respectively infinity time value inf supersort timeinf time operations max min combination extensions 
processing specifications real time rewrite theories current executable specification real time maude written entirely maude extends full maude specification described chapter introduce new data type representing timed modules full maude database 
tool reads timed system module term transforms term mod endm evaluated represented untimed module full maude database existing full maude functions 
kinds timed modules theories treated way 
keep important execution information stated timed modules full maude module database object extended contains additional attribute lazylabels maps declaration real time rewrite theory set labels lazy rules declared module parameters included modules 
early preprocessing declarations timed modules allowed extend full maude real time maude changes full maude code 
particular changes full maude easily extended real time maude just adding current real time addition easy modify extend syntax timed modules experience gained real time rewrite theories 
module full maude database table lazy labels easy determine originally declared timed module corresponding timed module easily recovered 
transformation term representing timed module term representing full maude module processed full maude consists steps 
lazy rule declarations substituted ordinary rule declarations labels lazy rules declared timed module parameters submodules stored database 

declaration importing module timed prelude added 
addition declaration time operations mentioned module contains declarations sort clockedsystem subsort system clockedsystem op time clockedsystem time clockedsystem vars time var cs clockedsystem eq cs time time cs time plus translation leaves rules unchanged course time syntax original rule interpreted time action sort system 
translation proved equivalent chapter sense time rewrites time rewrites original translation 
find current translation convenient simpler fact identity 
furthermore way need introduce fresh variables translation timed rules 

module timed meta level extends module meta level library strategies real time specifications described section including timed versions meta apply meta rewrite functions search strategies 
full maude importing meta level 
mn module names 
mn results full maude adding meta level constants 
mn defined equal meta representations flattened versions modules 
mn 
way module may import timed meta level 
mn real time maude imports module timed meta level equates meta representations modules 
mn constants 
mn 
completely define timed module need access set labels lazy rules module 
module name occurs parameter timed meta level real time maude introduces constant lazylabels base name parameter list case parameters defines value set labels lazy rules summarize declaration including timed meta level 
mn expanded including meta level mn including timed meta level ops lazylabels lazylabels mn qidset eq lazylabels lazy labels module eq lazylabels mn lazy labels module mn transformation steps performed timed modules modules 
executing analyzing real time maude specifications tool transforms real time specifications ordinary full maude modules executed maude default execution strategy 
transformed modules maude default execution strategy may useful reasons simulating system having continuous time domain tick rules form crl tick xr time xr xr le variables included variable xr occur intuitively computes maximum time elapse permissible ensure timeliness actions condition xr le ensures time elapse may halt temporarily possible application non time critical rule rule modeling action occur somewhat arbitrarily time 
current maude default interpreter execute tick rules nondeterminism introduced extra variable xr time advance default maude execution 
default interpreter fails take account eager lazy rules 
measuring controlling execution number rewrites performed useful control total time elapsed rewrite proof initial term 
address issues tool executes tick rules different basic modes determine apply tick rule duration term variable occurring lefthand side rule 
additional modes optimize application rules described section 
standard execution strategies search strategies modes sections 
strategies section described tick rules may introduce new variable righthand side condition 
rewrite modes mode step rewrite indicate instantiate time increase case represented new variable rule 
tool currently supports different basic modes determining time increase tick rule application default maximal possible time increase match lefthand side tick rule maximal possible time increase matches rule 
modes qualified time limit user default time increase value 
optimization purposes describe optimization modes concern time increase nondeterministic tick rules 
tool tick rule application increases time considered equivalent able perform rewrite 
basic modes describe strategies applying tick rule duration term new variable default time increase mode new time variable xr instantiated user default time increase value ground term different 
maximal possible time increase match mode tool finds match representation set possible values new variable condition hold 
possible unique maximal time value time domain assumed linear satisfies time theory ltime section 
set values xr represented set intervals finite length op xr op infinite length op xr op le lt greatest intervals right closed form op xr le chosen maximal time value instantiate new variable default time increase value 
tool handles conditions new variable xr condition boolean combination xr free terms equalities inequalities form le lt gt ge contain new variable xr contains xr occurrence xr addition embedded function symbols plus monus finding maximal possible time increase match number maximal time increase matches mode instantiates new variable greatest maximal time increases 
successful matches rule lefthand side similar previous mode 
basic strategies modified different ways 
example model checking real time temporal properties useful time advance certain time basic strategies allow time advance past time stopping time basic rewrite modes may qualified time limit modifies application tick rule time possible way difference time limit total time elapse rewrite proof leading current state smaller time increase applying basic mode time duration variable instantiated 
application value fails instantiating time variable satisfy condition tick rule duration variable instantiated timed rewrite modes may generalized allow user definable functions time intervals total time elapse possibly number times nondeterministic tick rule applied versions tool 
application tick rules deterministic duration affected modes rewrite performed time increase 
optimization modes influence time increase global mode allows user specify lefthand sides rules module terms sort system 
adding mode substantially speeds search procedures tool need search rewrites subterms state rewritten 
mode concerns object oriented systems tokens tick rules form tok cf tok cf tok cf variables sort tokens configuration lead inefficient specifications 
sort information injected early associative commutative matching process matching algorithm generates possibly exponential number potential matches sorted 
overcome problem mode variable sort tokens tick rules form instantiated number tokens outer level state application tick rule mode 
basic timed rewrite strategies basic timed rewrite strategies real time maude commands mode mode dti time limit mode mode dti time limit maximal number step rewrites bound number rewrites term sort system rewritten mode rewrite mode ma gd gm gma denotes basic default time increase mode maximal time increase match ma maximal time increase matches front indicates global mode rules rewrite terms sort system token front basic modes indicates mode instantiates tokens variable rules form default time increase value limit denotes limit total time elapse rewrite proof performed strategy may le lt time limit ground term name module rewrite take place 
commands apply rules fair top way 
limit form le mode qualified time limit 
application rewrites ends application bring total time elapse rewrite proof case limit form lt time limit case limit le 
search strategies tool provides commands analyze real time specifications exploring just possible behaviors initial state 
dense time domains practice may impossible explore individually possible behaviors presence tick rules nondeterministic time increase existence infinite number possible matches time variable 
tool provides strategies explore possible behaviors certain depth rewrite sequence duration satisfaction conditions new variable tick rule instantiated rewrite modes described earlier 
search strategies mentioned chapter implicitly understood analyze possible rewrite paths allowed chosen restrictions application tick rules 
search expressions nested set rewrite paths path represented state timestamp resulting search serves input searches 
cases time limits apply total time elapse initial state just duration computation previous search 
contrast search bounded number step sequential rewrites performed new starts depth 
search commands form strat se se nested search expression described 
basic search expressions basic search expressions include simplest search expression form term ground term sort system denoting initial state nested search 
command strat term returns reduced form term search expression find maximal terms reachable se mode dti time limit number denoting maximal number step sequential rewrites performed path current sub search means limit upper bound number solutions returned means unlimited se search expression modes ma gd gm gma described section ground term sort time denoting default time increase value limit le lt time limit ground term sort time returns terms reachable states returned se rewritten time depth limits 
precisely initial term search solution sub search se represented term time 
result search rewrite proof composed admissible step sequential rewrites mode default time increase case limit le time limit non trivial rewrite modes time limit proof consists step sequential rewrites 
resulting rewrite represented multiset solutions time 
number limits size multiset solutions returned may set time stamped terms time may represent different rewrite paths leading time search expression form find deadlocks se mode dti time limit returns deadlocks reachable time depth starting results search expression se 
search expression keep se returns distinct time stamped terms results search expression se 
patterns advanced search strategies defined terms state possibly total time elapse path leading state matches pattern 
pattern constant matched term constant matched term form 
term term sort system term form time allowing state properties total time elapse 
furthermore efficiently able check matching property term required ground irreducible equations theory 
substitution variables term simplified equation xi xi state reached rewrite matches pattern sort system match pattern satisfies condition pattern contains matches pattern form time iff match condition holds pattern contains 
patterns may negated state matches negated pattern match example state matches negation exist match satisfies 
matching expression form matching pattern time form matching time square brackets denote optional parts negates pattern matching matching expected meaning 
search expression remove se removes se solutions satisfy matching expression temporal logic properties search strategies described motivated desire model check real time specifications properties stated logic suitable linear time timed temporal logic see ah 
set timed computations starting initial term sort system consists infinite sequences non extensible finite sequences length admissible step sequential ground rewrite ti ti ri ri 
suffix ti ri denotes timed path written tool currently supports model checking kinds temporal properties properties timed path satisfies property iff exists rj tj rj satisfies matching expression tk rk satisfies matching expression temporal operators time limit defined similarly 
stable properties timed path satisfies stable property iff satisfies addition tj rj satisfies matching expression tk rk rk operators defined similar way 
pair satisfies temporal property iff timed path starting satisfies 
set pairs satisfies pair set 
useful properties special cases temporal properties commands section real time maude invariance properties terms reachable depth time limits satisfy state property 
invariance matching expression written defined formula matching operators defined similarly 
liveness properties path state satisfying matching expression depth time limits 
liveness property written formula similar definitions 
search expression form matching find satisfying se mode dti time limit previous search strategies limit le lt time limit searches timed paths satisfying property respectively starting pairs returned search expression se 
search strategy returns pair non satisfaction property established timed paths satisfy property 
case time limit form le rewrite mode contains time limit possible time visited 
dense time models explore rewrites presence tick rules new variable result search may partially correct counterexample search invalidates property absence counterexample guarantee property holds 
positive version search form find satisfying se mode dti time limit returns term satisfying matching expression timed paths satisfying property 
existence positive path prove satisfaction formula initial terms paths may fail satisfy property 
search expression form find satisfying se mode dti time limit returns paths satisfying property represented pair non satisfaction established 
search functions execute search expressions implemented depth functions breadth search functions optimized 
currently depth search functions interpret real time maude search commands 
extending tool strategy library data types functions implement various real time maude commands accessible user real time maude module timed meta level described chapter 
user extend strategy library real time maude importing module timed meta level real time maude module defining new strategies illustrated sections 
logics 
positive path prove existentially quantified version formula branching time temporal real time maude command language real time maude commands described summarized giving commands full maude commands extended bnf grammar optional parts enclosed pair square brackets symbols meta parentheses denote respectively zero repetitions preceding unit 
tomod tth toth lazy rl term term time term lazy crl term term time term condition rl term term time term crl term term time term condition nat term mode mode dti term time timelimit nat term mode mode dti term time timelimit show lazy show labels lazy rules show lazy strat term term initial term 
keep nat keep nat distinct terms remove find nat nat maximal terms reachable mode mode dti term time timelimit find nat nat deadlocks mode mode dti term time timelimit deadlocks find nat nat satisfying mode mode dti term time timelimit invariance find nat nat satisfying mode mode dti term time timelimit positive liveness find nat nat satisfying mode mode dti term time timelimit negative liveness find nat nat satisfying mode mode dti term time timelimit find nat nat satisfying mode mode dti term time timelimit matching pattern term matching term term matching matching timelimit time limit le term lt term mode ma gd gm gma sample real time maude specification execution section illustrates real time maude tool simple example 
interesting examples case studies section chapter 
object oriented timed module includes module naturals appendix defining natural numbers defines class counter attributes clock attribute 
time domain specified nonnegative machine integers techniques described section tomod test including qid including naturals subsort nat time subsort qid oid class nat nat clock time op system vars nat eq zero eq lt eq plus eq clock satisfy conditions real time rewrite theories def 
contains operator sort system constant 
convenience real time maude supports definitions initial terms allow function symbols sn system si system ground term sort system reduces equations theory term form term reduces term form 
module adds rules lazy tick rule timed module test tomod test including test var oid vars nat crl lazy crl lazy crl tick clock clock time le note operation monus defined module naturals 
due presence lazy eager rules nondeterministic time elapse tick rule maude default interpreter execute specification 
real time maude default timed rewrite strategy maximal time increase mode execute run maude mode dti time le rewrites ms cpu ms real rewrites second 
result clock time maude mode dti time time limit rewrites ms cpu ms real rewrites second 
result clock time execution returns terms duration rewrites leading reachable rewritten paths length equal duration equal maude strat find maximal terms reachable term mode dti time le rewrites ms cpu ms real rewrites second 
result clock clock time clock time clock time clock time state clock reachable time appears times occurrence representing distinct rewrite initial state 
similarly find deadlocked terms terms rewritten strategies applying tick rules reachable time maude strat find deadlocks term mode dti time le rewrites ms cpu ms real rewrites second 
result terms 
execution search commands trivial rules eager maude tomod test including test var oid write 
real time maude echo command 
vars nat crl crl crl tick clock clock time le search searches states reachable step sequential rewrites duration counters value maude strat find satisfying matching pattern clock term mode dti time lt rewrites ms cpu ms real rewrites second 
result clock clock time clock time clock time clock time nested search expression finds states counters starting terms respective duration finds term additional rewrite steps duration greater equal counter value maude strat find satisfying matching clock ge find satisfying matching pattern clock term mode dti time time limit mode dti time lt rewrites ms cpu ms real rewrites second 
result clock time may need variables search patterns current module 
cases new module appropriate variables defined maude tomod including test var atts rewrites ms cpu ms real rewrites second introduced timed module maude strat find satisfying matching pattern atts term mode dti time lt rewrites ms cpu ms real rewrites second 
result clock clock clock clock clock time find lazy rules current module test module test follows maude show lazy rewrites ms cpu ms real rewrites second lazy rules module test including imported rules maude show lazy test rewrites ms cpu ms real rewrites second lazy rules module test including imported rules tick illustrate transformation declarations importing timed meta level parameter maude mod meta test protecting timed meta level test endm rewrites ms cpu ms real rewrites second introduced module meta test maude show module rewrites ms cpu ms real rewrites second mod meta test including meta level test including timed meta level including bool including op lazylabels test qidset eq lazylabels test tick endm known problems parser problems parsing terms timed modules strategy expressions 
terms representing initial states patterns searches time limits dti values may need enclosed parentheses 
tool handle multiple parameters module timed meta level tool transforms importation corresponding importation level version full maude handle multiple parameters level 
scheduling case study show section real time maude specify analyze scheduling problems 
consider scheduling problems periods execution times fixed rational numbers preemption allowed 
specification method allows analyze scheduling problems arbitrary number processes processors requiring changes specification 
scheduling problem number identical processors set pi periodic processes pi period pi execution time pi schedule allocation processors processes function time 
processor serves process simultaneously 

process pi served continuously processor exactly time pi completed period 

process served unbounded number periods 
scheduling problem usually addressed specifying behaviors system satisfy requirements mutual exclusion specification finding behaviors satisfy requirement 
specifying mutual exclusion state system seen object oriented system consisting multi set objects representing processes number special objects occurrence denotes availability processor 
want restrict initial state certain number processes done flexible formalisms automata petri nets specification changed done composing automata nets combination processes processors 
time acts process object maximum time elapse depends process object specification techniques described section object oriented systems mte distributing objects configuration 
process represented object class process attributes state denotes state process sleep indicates done current period just waits period time goes state wait waiting served processor state served processor period denotes length period process denotes length execution time process denotes amount time spent current period denotes amount processor time current execution 
note initial state arbitrary number processes processors mutex specification deal general class scheduling problems 
important clarify system evolve process served periods 
execution continue misunderstood meaning gone 
contrast models real time systems time elapse modeled explicitly time divergence required order time advance specification formalism require time divergence 
time advance process served system just 
avoids need treat cases error states specification mutual exclusion uses function mte compute maximum possible time elapse configuration 
time elapse period process state sleep new period 
process stay wait mode longer process state change state execution time 
specification uses defines effect time elapse configuration updating clocks measure current time period current time execution complete real time maude specification mutual exclusion rules execute release tick 
rule updates necessary attributes new round started time current period equals length period 
rule execute grabs available processor time left period execute task 
rule release releases processor exactly required amount time tick rule described section 
think relatively easy compared mutual exclusion specification formalisms see prove invariance reasoning specification satisfies mutual exclusion property 
module declares initial states processor processes periods execution times processors processes 
specification imports module positive rationals defines data type positive machine rational numbers extending machine integers contains definitions functions plus monus lt positive rationals 
tomod mutex including qid including positive rationals include rationals including ltime inf include inf min max subsort qid oid nonnegative rationals time domain subsort time eq zero op delta configuration time configuration op mte configuration timeinf class process state period time time time time op configuration special object denoting available processor sort states process ops sleep wait var tokens tokens vars configuration var qid vars time eq mte process state sleep period monus eq mte process state wait period monus monus eq mte process state monus eq mte inf eq mte inf ceq mte min mte mte eq delta eq delta ceq delta delta delta eq delta process state sleep process state sleep plus eq delta process state wait process state wait plus eq delta process state process state plus plus rl process state sleep period process state wait crl execute process state wait period process state le monus rl release process state process state sleep crl tick tokens tokens delta time le mte initial states ops system eq process state wait period process state wait period eq process state wait period process state wait period process state wait period analyzing mutual exclusion specification having rationals time domain combined need able time elapse time model possible behaviors implies time elapse tick rule nondeterministic 
maude default interpreter 
shows results executing specification maximal time increase default time increase strategies starting state processor processes periods execution times 
executing term default timed rewrite strategy case maximal time increase mode default time increase depth time limits gives result maude mode dti time time limit 
result process period state process period state wait time analyzing result shows deadlock time advances grabs processor time advance advance time 
deciding schedule exists deciding scheduling problem finding schedules need observations properties mutual exclusion specification scheduling 
starting initial state processes periods state wait schedule time process period 
property depends lengths periods rational numbers value mpi pi mp natural numbers npi npi mpi 
specification mutual exclusion system reaches time greater time processes served rounds time conversely rewrite intial state duration time way serving processes way time schedule 
reachability state time decides schedule 
schedule initial state rewrites initial state time greater equivalently time elapse time 
sufficient search schedules real time maude time advance tick rule nondeterministic 
need additional property 
assume schedule process served starting time process ready perform task time processor serving process serving process parts time interval 
schedule task performed starting time time schedule 
property implies schedule schedule equivalent time padding sense processes execute earliest possible times order process execution 
specification means schedule equivalent schedule time padding applications tick rule advance time maximum possible amount 
schedule exists rewrite total time elapse maximal time elapse rewrite mode applying tick rule 
note implies far obvious schedule exists 
check reachable state time elapse ascertaining pattern sys time sys variable sort system reached 
need introduce variable sys maude tomod including mutex var sys system check liveness property looking term matches pattern time limit limit depth derivations maude strat find satisfying matching pattern sys time term mode dti time le 
result process period state sleep process period state sleep time similarly find schedule computing product numerators periods liveness query previously introduced variable sort time maude strat find satisfying matching sys time sys term mode dti time le 
result process period state wait process period state wait process period state wait time finding schedules exemplify real time maude strategy library section extended exhibit schedules time padding scheduling problems 
module function returns executions sequences step sequential rewrites initial state reached 
executions sequences form tn 
tn meta representations terms initial state tj tn reached duration different 
constant returned schedule exists 
function implemented non optimized breadth search strategy real time maude metalevel 
uses timed meta level function finds terms reachable step rewrite mode find potential states execution 
ensure function terminating returning schedules uses timed meta level function returns states reached time equal time cut executions total time elapse greater total time elapse iteration schedule 
fmod find schedules including timed meta level mutex datatypes executions 
sort execution subsort term execution op execution term execution sort subsort execution op op assoc comm id vars execution execution execution vars vars term vars qid vars ts ts termset var tl termlist var dt op term usage eq meta reduce mutex meta reduce mutex op term usage round eq execution dt execution execution dt execution dt fi eq dt compute reachable terms round eq execution dt execution mutex dt mutex execution maxtime time dt extract executions ends initial state time op term eq ceq eq execution execution execution fi op execution term eq eq execution op execution termset eq execution emptytermset ceq execution termset ts ts execution ts execution ts ts emptytermset ts emptytermset eq execution execution op term term bool holds iff time different eq time meta reduce mutex true bool meta reduce mutex time true bool ceq tl false time eq false eq qq false extend term executions op eq eq execution execution endfm command gives set executions defining schedules initial state time padding maude red system call returns set execution sentences represents schedule time process 
process execution time schedule problem maude red mutex process state wait period process state wait period 
result function defines algorithm finding schedules time padding processes start periods value process 
think starting arbitrary state starting middle periods tasks performed solution modified handle initial states checking possible arrive state period clocks start normal algorithm finding schedules 
strategy uses comparisons states easily accommodated handle general setting 
case studies addition scheduling problem simple examples tool case studies generalized railroad crossing controller see hl benchmark example real time systems 
development execution environment sifakis timed automata deadlines tad model bst 
deadline transition tad boolean combination linear inequalities clocks system 
tad tool computes maximum time elapse deadline true 
tad tool execute run tad default time increase strategy maximal time increase strategy execute runs tad certain length maximal time increase strategy 
collaboration bhattacharyya sprint talcott stanford specified formally analyzed aer nca kbk suite active network protocol components reliable multicast 
complex suite protocols studied far maude time sensitive behavior need analyze correctness performance 
real time maude tool allowed find important errors inconsistencies maude specification derived original case informal specification 
chapter describes aer nca protocol specification analysis effort protocol suite detail 
chapter maude specification real time maude chapter shows maude reflective features loop mode parsing facilities specify real time maude tool maude 
section presents specification real time maude strategy library execute real time maude search model checking commands real time maude user access module timed meta level 
section shows specification full maude dm extended specification real time maude tool 
overview real time maude specification real time maude specification extends full maude allow reuse full maude facilities parameterized object oriented modules operations parsing modules commands useful operations functions facilities letting user defined module easy access meta representation user defined modules 
real time maude extends full maude ways grammar module full maude parse input time extended module timed grammar describes syntax timed modules timed execution search commands 
persistent state extended having table timed module assigned set labels lazy rules module submodules 
module timed prelude described sections imported timed modules module transformation untimed modules added built module database 
add modules ltime time inf ltime inf extending time domain module timed oo prelude imported implicitly objectoriented timed modules theories 
input real time maude tool parsed extended grammar 
resulting term indicates input timed module theory extracting signature module defined term transformed term parsed full maude untimed module 
changes terms corresponding lazy rules changed normal rule declarations 
declaration importing module timed prelude timed oo prelude case object oriented modules added term 
module timed meta level imported parameter treated adding declaration importing meta level parameter full maude job assigning meta representation module corresponding constant importing module timed meta level parameters adding declaration constant denoting lazy labels module parameter defining value adding equation 
addition table labels lazy rules persistent state updated current module lazy labels 
resulting term term sort passed full maude part real time maude 
full maude real job extracting signature module parsing bubbles extracted signature arrive complete module defined adding module module database flattening get executable module needed 
input untimed module treatment meta level importation handled timed modules term passed full maude modifications 
untimed command treated full maude part specification 
timed commands interpreted calling appropriate strategy functions defined real time maude part tool 
section give overview library strategies analyzing real time specifications available module timed meta level 
providing precise semantics search commands real time maude strategy functions define application specific strategies 
real time maude strategy library section presents strategy library needed execute rewrite search commands real time maude 
real time maude comes equipped powerful search strategy language seen section may want extend strategy language application specific purposes see chapter want optimize strategies certain kinds rewrite theories 
real time maude strategy library available user level meta level added full maude database built module 
strategies real time maude implemented functions parameters representation maude module representation term parameters function meta apply basic building block simulate rewrite steps need define data type representation timed modules 
timed module flattened untimed version includes module timed prelude set lazy rules represented set quoted identifiers 
strategies course assume module parameter result transforming timed module 
instance assume global state form operator sort system automatically imported module timed prelude definition real time rewrite theories def 
prohibits operators sort system global state equipped timestamp denoting total time elapse path leading state term form time furthermore strategies may assume declarations module timed prelude operators zero plus operators sort time defined user example letting zero interpreted 
strategies may assume time domain satisfies theory time section 
strategies comparing time values time limits finding maximal time increases assume time domain linear satisfies theory ltime section interpretations sorts operators time standard interpretation described section 
assumed time domain allowing user flexibility define time domain 
assumptions modules treated strategies described chapter 
example tick rule required form allows strategies extract possible time values time increase 
decide enabledness eager rules enabled lazy rule applied eager rule tick rule assumed form new variables righthand side condition 
patterns search expressions mentioned assumed ground irreducible 
specific strategies real time systems 
indicated reasons having strategies specific real time theories presence eager lazy rules nondeterministic tick rules need relate execution length simulated time usefulness clearly illustrated scheduling example section case study chapter 
similarly model checking search timed systems involve time specific features just na increasing time maximally nondeterministic tick rules 
illustrate subtle aspects model checking real time specifications timed temporal logic properties look problem model checking say liveness property execution state satisfying matching property time equal 
states path time maximal time increase strategy lead state total time elapse path give path satisfying property 
time elapsed state total time elapse property holding state 
liveness property considered invalidated path 
view system implicitly visiting moments time presence nondeterministic tick rules may consider property valid desired state passed time way time time 
viewpoint trying adjust time increase time advance deadline temporal formula model checking strategies real time maude possible cases may natural interpretation correctness property setting strategy bother try time deadline reachability property simulated searching example case pattern deadline time xr xr le real time maude strategy library consists lines maude code entirety 
high level summary library indicate strategies available similar strategies strategies defined user easily write new strategies give actual semantics nontrivial strategies example 
strategy library consists parts useful data types operations untimed systems 
example define data types sets terms various operations modules deciding term certain sort new variable introduced righthand side condition rule finding terms reachable step term 
data types operations finding representing time values time may advance application tick rule 
includes data type representing sets time intervals operation deciding tick rule satisfies syntactic conditions section function finds values time advance state tick rule 
briefly discuss soundness completeness axioms finding set possible time advances 
operations executing real time specifications corresponding timed apply meta rewrite data type defining rewrite modes 
data type patterns define temporal logic properties functions deciding state matches pattern functions finding set terms match match pattern functions finding set terms associated timestamp greater smaller time value 
functions model check real time specifications initial term 
functions find mode time depth limits set terms representing rewrite paths satisfying satisfying temporal properties 
model checking search strategy defined different ways breadth search depth search techniques 
search methods extended allow set initial states 
searches search necessary time go searching forever state satisfying property 
variables strategy library variables frequently strategy library declared exposition vars machineint vars nz nz nz nz vars qid vars ql ql ql ql ql ql ql vars qs qs qs qs qs qidset vars term vars tl tl tl tl tl termlist vars mod module vars sb subst substitution var il var sd var var ods var vds var mas var es var rs ruleset vars rule rule rule var fmod vars gt gt gt groundterm vars dt dt var var trm vars ts ts termset standard data types operations extends level data types ground terms sets terms various useful functions terms modules 
sets terms defined full maude sort termset subsort term termset op emptytermset termset op termset termset termset termset assoc comm id emptytermset need distinguish ground terms terms containing variables sorts groundterm subsorts qid term subsort groundterm term subsorts termlist op qid groundterm op qid op qid qid groundterm op assoc gather prec op termlist assoc gather prec op termlist assoc gather prec absence idempotency axiom data type defines multisets terms 
declarations full maude module system transf add default term value sorts subsorts term subsort groundterm op useful functions extracting rules rule labels variables module lefthand righthand side rule ops lhs rhs rule term op rulename rule qid op variables module op rules module ruleset op module qidset op ruleset qidset op module qid rule op ruleset qid rule op var termlist qidset op var module qidset op var qidset functions extract term substitution op term op substitution operations sets lists quoted identifiers op qidset qidset qidset op qidset qidset bool op qid qidset bool op union qidset qidset qidset assoc comm op qidset qidset qidset op qidset qidset op qid bool op qidset apply substitution rule term substitution op substitution rule rule op substitution termlist termlist op substitution substitution substitution find term sort op module term qid bool function returns module rule rule second parameter 
checking term matches pattern 
removing rules benefit avoiding possibility having rule introduced label op module rule module functions return cardinality multiset terms op size termset machineint module added additional parameter function size check terms semantically equivalent return size set terms op size module termset machineint give flavor equational definitions functions show definition 
function returning lefthand side rule eq lhs rl eq lhs crl set rules extracted module follows eq rules mod il sd ods vds mas es rs endm rs eq rules fmod function assumes module contains rule label returns rule eq rules eq rl rs rl 
eq crl rs crl 
somewhat problematic check term sort descent function meta level take membership axioms considerations test works sort connected component eq meta reduce true bool false fi module strategies imports previous module standard uses descent function meta apply find respectively result applying rule term find terms reachable step applying rule top term finding terms reachable rewrite step term set rules op module term qid term op module term qid substitution term op module term qid termset op module term qid machineint termset op module term qidset termset find terms reachable step rewriting top apply meta apply applicable matches eq eq meta apply error emptytermset termset meta apply fi finding possible time increase values tick rule applications module lineartime sequences defines sequences time intervals represent possible time values linear time domain 
operations modules assume modules consideration timed specifications 
addition lineartime sequences assumes modules treated satisfy theory ltime 
time interval represented term interval le closed re open denotes time values le lt interval unbounded endpoint value inf sorts endpoint interval subsort interval subsorts endpoint ops open closed left right open left right closed 
op le term op re term op inf op interval interval constr 
op interval intervals 
combined union operator form interval sequence 
operations module assume maintain strictly increasing ordering intervals 
upper bound ii equal lower bound ii bounds equal ii right open ii left open 
sorts subsort subsort subsort interval op constant confused value inf sort timeinf module time inf 
assoc id op assoc id important operations interval sequences op merge module op intersect module op diff module module ok tick rule checks tick rule satisfies requirements section form tick rules introduced variables fmod ok tick rule including standard op module qid substitution bool op module qid bool op module rule substitution bool op rule substitution bool op rule bool eq subst subst eq eq rule subst rule subst eq rule subst subst rule unconditional tick rule satisfies requirements new variable introduced righthand side rule introduced variable duration term rule eq rl time var union var var qid var var union var conditional rule may introduce new variable righthand side condition case duration term variable furthermore condition desired form eq crl time true bool var union var union var var qid var union var var union var new variable equation tick rule embedded functions lt le gt ge plus monus eq tl var tl true tl lt le ge gt tl tl tl false fi fi fi fi eq true eq eq tl tl new variable occur terms sort time op termlist qid bool eq tl var tl true monus plus tl false fi fi eq true eq true eq tl var var tl tl fi module find solutions defines function op findsol module term takes boolean condition satisfying requirements defined previous command variables occurring lefthand side corresponding rule instantiated matching ground terms returns possible time values single variable instantiated condition true 
sketch soundness correctness proof parts specification assuming correctness operations lineartime sequences 
equations find time values boolean subterms condition 
strictly speaking boolean operators overloaded case may prudent add condition asserting terms involved sort bool 
associative may take arguments vars gt gt groundterm var var ngt var ceq findsol merge intersect findsol findsol true intersect findsol findsol bool eq findsol intersect findsol findsol eq findsol tl intersect findsol findsol tl eq findsol merge findsol findsol eq findsol tl merge findsol findsol tl eq findsol ngt diff interval le closed zero time inf findsol ngt boolean ground terms ceq findsol gt meta reduce gt true bool interval le closed zero time inf fi gt bool single uninstantiated variable sort time domain values making conditions form xr xr le true follows eq findsol gt interval le closed gt re closed gt eq findsol le gt interval le closed zero time re closed gt equation puts term variable left side eq findsol gt ngt findsol ngt gt treat closely case condition form xr plus term variable xr ground terms eq findsol plus ngt gt meta reduce le plus zero time gt true bool findsol ngt meta reduce monus gt plus zero time fi indicate axioms theory ltime prove soundness completeness function findsol find time values condition tick true 
equation says le values xr hold values xr xr plus xr le monus hold 
addition zero axiom just technical detail needed plus may parameters 
soundness proof part goes follows solution xr le monus congruence axiom time plus le monus plus le axiom time gives gives desired monus plus plus completeness assume solution xr plus plus holds 
furthermore assume hold 
linearity le monus monus le holds 
congruence axiom gives reduces write true 
monus plus le plus le plus le anti symmetry le implies congruence equational logic gives plus le le plus plus monus plus monus derived property xr yr yr xr time gives definition time gives monus le monus contradicting undesired assumption 
step time follows axiom xr instantiated xr yr gives xr yr yr xr xr yr yr yr xr xr yr yr yr xr yr yr xr yr follows trivially axioms axiom time gives desired lemma xr yr yr xr 
assumptions proof anti symmetry shown easily 
part equation says plus le holds case le holds 
soundness trivial 
completeness assume exists making plus le true 
side condition le hold assumed linearity gives lt congruence axiom identity element xr get xr xr yr case gives le plus property assumption give transitivity plus le le contradicting assumption le hold 
proved soundness completeness detail axioms finding time values 
axioms complete specification find solutions axiom pushes term variable step left list parameters plus ceq findsol plus gt gt findsol plus gt gt le monus eq findsol monus gt ngt gt meta reduce gt zero time true bool findsol le gt ngt meta reduce le gt gt true bool findsol ngt monus gt gt fi fi monus eq findsol monus ngt gt gt meta reduce gt zero time true bool findsol le ngt gt findsol ngt plus gt gt fi monus monus eq findsol le monus ngt gt gt findsol le ngt meta reduce plus gt gt eq findsol le monus gt ngt gt findsol le meta reduce monus gt gt ngt eq findsol lt findsol le eq findsol le gt ngt findsol le ngt gt gt ngt greater just definitions eq findsol gt findsol lt eq findsol ge findsol le time increase intervals uses function findsol find possible time increase values tick rule 
done function op module rule groundterm substitution op module rule groundterm op module qid groundterm substitution op module qid groundterm union possible time increase values match global state lefthand side rule eq rule time gt gt subst rule gt subst eq rule gt subst subst rule gt op module rule groundterm machineint eq rule gt matches gt lhs rule merge rule gt rule gt fi observe timestamped term time system part treated 
case functions strategies apply way state independently total time elapse path leading state 
function finds time increase values nth match lefthand side rule op module qid groundterm substitution machineint op module rule groundterm substitution machineint op module qid groundterm machineint op module rule groundterm machineint match directly rule meta apply indicate match exists presence new variable condition rule 
eq rule gt rule matches gt lhs rule lhs rule gt rule fi function calls findsol find appropriate interval duration variable rule instantiated nth match 
computes possible time increases op module rule eq crl gt time true bool findsol eq rl gt time gt interval le closed meta reduce gt re closed meta reduce gt eq crl gt time gt gt gt meta reduce gt gt true bool interval le closed meta reduce gt re closed meta reduce gt fi eq rl gt time interval le closed zero time inf functions timed meta apply timed meta rewrite module timed strategies defines basic timed strategy timed meta apply default rewrite strategy timed meta rewrite extend timed context descent functions meta apply meta rewrite untimed systems 
function timed meta apply takes additional parameter mode rewrite step 
mode dictates time increased application nondeterministic tick rule modes described section additional possibility time advance time option particularly useful model checking applications 
mode efficiently executing object oriented specification tokens lefthand side tick rule form variable sort tokens term sort configuration case instantiated set tokens outermost level state rule applied 
time advanced application tick rule zero application considered unsuccessful timed meta apply returns value error 
behavior timed meta apply mimic meta apply 
leads complications timed rewrite mode asks maximal time elapse respect match matches maximal time elapse value 
nth successful match timed meta apply may th successful match lefthand side tick rule 
timed meta apply may efficient matches lefthand side tick rule 
function timed meta apply behaves meta apply instantaneous rules exception rule applied system part term sort clockedsystem 
function apply applies rule term corresponds function apply module strategies 
function timed meta rewrite behaves standard interpreter function meta rewrite additional features nondeterministic tick rules applied rewrite mode execution related length rewrite path eagerness rewrite rules taken consideration 
functions declared follows op timed meta apply module groundterm qid substitution machineint term op apply module groundterm qid term op timed meta rewrite module groundterm machineint qidset term usage timed meta rewrite module deadline timed rewrite modes described section represented data type sorts sorts subsort subsorts ops default maxtime groundterm op timelimit groundterm op op global meaning operators clear 
parameter default maxtime default time increase value 
timelimit imposes time limit saying time advance possible 
function takes parameters interval sequence representing possible time increase values default time increase value possibly deadline computes maximal time increase way op groundterm groundterm op groundterm groundterm op groundterm groundterm groundterm third argument time limit 
var var eq gt zero time error value 
eq gt gt eq inf gt gt eq re closed gt gt gt eq re open gt gt gt eq gt gt fi gt zero time gt zero time le gt gt gt gt axiom ensures timed meta apply rewrites state part state timestamp 
observe time limit modified reflect time elapsed state eq timed meta apply time gt gt subst trm timed meta apply gt subst trm gt error error meta reduce time timed meta apply gt subst trm gt gt fi show apply rule default time increase mode 
default value gt 
rule consideration seen specification rule rule label tick rule duration term new variable variable instantiated gt calling meta apply 
rule tick rule deterministic tick rule executed directly meta apply 
filter return error resulting state timestamp zero ceq timed meta apply gt subst default gt meta apply gt tick rule subst time increase gt subst fi gt op module term term eq time meta reduce zero time true bool error time fi eq default time increase mode time limit gt timed meta apply tries instantiate new variable smallest default time increase value time limit value fails value satisfy condition resulting time increase zero time increased gt 
time domain assumed linear time limit current time comparable time limit ceq timed meta apply gt subst timelimit default gt gt timed meta apply gt subst default min gt gt error timed meta apply gt subst default min gt gt timed meta apply gt subst default gt fi gt rewrite mode maxtime time increased maximally match lefthand side rule trivial mentioned 
increasing time maximal time increase matches easier ceq timed meta apply gt subst gt meta apply gt tick rule subst time increase gt subst gt subst fi gt follows equation application deterministic tick rule may yield maximum time increase matches mode 
mode handled testing tick rule form described variable sort tokens tokens outermost level lefthand side rule 
case variable sort tokens function instantiated set tokens state function tokens timed meta apply called ceq timed meta apply gt subst trm subst timed meta apply gt subst tokens gt subst trm timed meta apply gt subst trm fi gt function timed meta rewrite takes addition module initial state maximum number rewrite steps perform time limit denoting maximal simulated duration rewrite timed rewrite mode set labels lazy rules 
calls function op timed meta module groundterm machineint machineint term timed meta ql ql ql ql mode timelimit module rewrite take place current state number rewrite steps performed maximal number rewrite steps perform ql list quoted identifiers denoting labels eager rules attempted applied current round ql list labels eager rules tried current round ql denotes list labels lazy rules tried current state ql list labels lazy rules tried current state mode timed rewrite mode timelimit desired maximal duration rewrite path 
upper time limit timelimit 
axiom starts process rewriting eq timed meta rewrite gt qs trm timed meta meta reduce gt nil qs nil qs trm time limit added rewrite mode try time elapse exactly desired time function transform sets quoted identifiers lists identifiers 
rules represented sets labels rule tried round 
lists allows certain fairness trying apply rules equally round robin strategy 
function nondeterministic flavor defined rewrite rules 
keep simpler equational definition nondeterministic say functions meta apply meta rewrite 
equation models case eager lazy rules tried unsuccessfully current round eq timed meta gt ql nil ql nil trm gt equation application eager rule attempted checked current state reached desired time limit maximum number rewrites performed 
tries apply rule current state 
application successful rewrite performed resulting state stays time limit get ready round updating state appending rules tried round list rules tried round eq timed meta gt ql nil ql ql trm gt gt apply gt trm trm error timed meta apply gt trm nil ql nil ql ql trm timed meta gt ql nil ql ql trm fi fi op apply module groundterm qid term eq apply gt trm tick rule timed meta apply gt trm gt fi eager rules tried current round lazy rule denoted equation tried eq timed meta gt ql nil ql ql trm gt gt apply gt trm trm error timed meta apply gt trm nil ql nil ql ql trm timed meta gt ql nil ql ql trm fi fi axiom concludes specification timed meta rewrite 
concluding description module timed strategies mention useful function op term term returns timestamp term zero time 
patterns search preliminaries module patterns defines patterns useful functions real time specifications finding terms reachable step state finding terms set terms timestamp smaller greater time value 
functions op module term qid termset op module term qidset termset find respectively terms reachable state tick rule rules module respectively qidset parameter denoting lazy rules 
checks set eager rules applicable assumes instantaneous rule introduces new variable righthand side condition 
functions return set terms terms timestamps respectively greater equal strictly greater strictly smaller smaller equal time value 
value interpreted cases infinity value ops module termset termset eq ts emptytermset eq dt emptytermset emptytermset eq termset ts meta reduce le true bool termset ts ts fi pattern meta representation term possibly variables may condition variables part 
default matched term pattern matched term 
data type patterns follows sort pattern subsort term pattern op term term pattern sort pattern default values subsort 
subsort pattern op op eq eq term matches term sort system state part matches term matches term sort clockedsystem addition associated time elapse state timestamp zero state timestamp matches timestamp part pattern 
matching decided checking state applied rule having pattern lefthand side 
condition corresponds condition rule var op module term bool eq time meta apply rl error meta apply rl time error eq meta apply rl error meta apply rl time zero time error eq time meta apply crl true bool error meta apply crl true bool time error eq meta apply crl true bool error meta apply crl true bool time zero time error eq false eq true eq pattern pattern functions gives set terms match resp 
match pattern op module termset termset op module termset termset eq emptytermset emptytermset eq termset ts termset ts ts fi model checking search functions search imports defines search functions explore rewrite paths mode certain length duration limits set initial states application nondeterministic tick rules performed rewrite mode 
search functions depth search techniques analyze model check specifications properties expressed real time temporal logic defined section 
functions return set states represent rewrite paths initial states satisfy property 
property hold paths reachable time equal time time limit added rewrite mode ensure time advance stops time possible 
adjustment performed formula applies paths duration strictly time search functions options restrict number resulting states optimized versions state returned 
function op module groundterm qidset machineint machineint termset searches terms reachable initial state rewritten time depth limits 
lazylabels timelimit mode maxdepth returns terms reachable rewritten state associated timestamp equal timelimit reached maxdepth number rewrite steps maxdepth 
lazylabels denotes labels lazy rules mode rewrite mode perform rewrites 
limit duration number solutions number rewrite steps path timelimit maxdepth respectively 
note result function necessarily results satisfying property matching timelimit matching rewrites inside time limit time limit returned representing counterexample temporal formula returned 
function differs searches states reached time strictly time limit 
attempt adjust rewrite mode time advance time 
useful find deadlocked states 
function op module groundterm qidset machineint machineint termset corresponds states limits rewritten returned 
function op module groundterm qidset machineint somewhat optimized version returns deadlocked state returns desired deadlocked state exists called maximal number solutions desired 
corresponding functions deadlocked state reached time time limit 
function op module groundterm qidset machineint machineint termset model check properties form pattern matching expression 
timelimit lazylabels pattern pattern timelimit mode maxdepth returns states representing paths satisfying temporal property 
state matching pattern path state matching pattern path state matching pattern exist depth time limits 
observe term path state matching pattern reached rewrites state time time limit represents bad path may successors time limit 
time limit adjusted time limit possible 
function op module groundterm qidset machineint finds state representing path satisfying property returns find counterexample 
give specification function detail 
calls function op module termset qidset machineint machineint performs depth search 
second parameter call ts denotes set terms analyze 
invariant states paths leading initial terms ts match pattern pattern ts nonempty set timestamps terms ts smaller equal time limit 
parameter denotes number rewrite steps paths leading terms ts 
search function initialized letting analyze initial state timestamp state greater time limit 
time limit added rewrite mode ensure time advance stops time limit possible eq gt qs dt trm gt dt gt gt qs dt trm dt fi term gt analyzed equation 
matches pattern denoted ends path satisfying formula returned 
gt match pattern denoted path gt counterexample gt returned 
furthermore gt match pattern successor states pattern matched path gt returned 
case upper bound number rewrite steps reached encountering pattern state 
gt immediate successor state time limit path pattern state reached time limit gt returned 
cases apply search function called recursively analyze successor states gt 
due test condition successor states recursive call satisfy invariant eq gt qs dt trm gt gt qs trm emptytermset solutions needed deadlocked term rewrites path gt dt gt qs trm emptytermset gt gt qs trm qs fi fi dt trm term analyzed solution term gt solution returned result analyzing remaining terms returned ceq termset gt ts qs dt trm gt qs dt trm gt qs dt trm ts qs dt trm fi ts emptytermset returning terms paths satisfying property functions find term matching pattern paths satisfying matching pattern timelimit matching pattern 
similarly functions find paths satisfying satisfying respectively temporal formulas form timelimit 
class properties stable properties describing paths matching expression satisfied second satisfied second matching property holds path 
example usefulness property interested finding values protocol chapter change 
interested returning states representing paths satisfy property 
stable operator expressed operators restricted logic search function model checking properties defined terms negative positive functions 
avoid multiple searches function op module groundterm qidset machineint machineint termset variations defined explicitly module depth search 
strategy library contain functions model check invariance properties simple liveness properties properties model checked significant additional cost functions model checking respectively stable properties properties 
module depth search extends depth search allowing search functions take set initial states parameter 
breadth search module breadth search specifies model checking search function breadth search techniques addition parameters depth search functions breadth functions take additional parameter maximal breadth level 
number terms certain depth exceeds maximum breadth terms omitted analysis 
example ninth parameter function op module groundterm qidset machineint machineint machineint termset denotes maximal number terms level search 
parameters semantics breadth search functions correspond depth search counterpart 
compare efficiency search strategies carefully 
initial results indicate breadth search methods advantages provide semi decision procedures various model checking problems depth bound specified suffer having huge sets states negatively impact performance 
real time maude extension full maude section describes full maude extended real time maude 
description intended illustrate changes necessary reuse full maude real time context localized changes 
real time maude extension full maude leaves treatment full maude modules execution commands unchanged 
current specification real time maude extends version full maude available url www csl sri com peter rtm 
full maude contains additional part illustrating extended handle new module composition operators 
removed part full maude specification 
minor changes specification full maude described 
real time maude adds specification tasks specification full maude strategy library defined previous section included specification real time maude uses execute real time maude commands available real time maude application level module timed meta level 
syntax real time maude modules commands include full maude modules commands defined module timed grammar meta parse parse input loop mode input facilities 
input parsed module timed grammar determined attempt declaration module treated passed full maude part specification 
timed transformed special breadth function solution requested 
untimed adding declarations importing module timed prelude module timed oo prelude transforming lazy rule declarations declarations ordinary rules 
set labels lazy rules updated stage data type tables labels defined 
furthermore checked importation timed meta level module treated described 
executing timed commands 
full maude database object storing user defined predefined modules extended store table labels lazy rules 
define new subclass full maude database class store table labels lazy rules persistent loop state 
certain modules timed prelude ltime timed oo prelude defined added real time maude database 
full maude extension loop mode treat input changed instantiate database additional modules listed parse input module defining grammar real time maude input 
section outlines changes full maude part specification presents real time maude additions full maude specification 
changes full maude specification real time maude modifies specification version full maude ways avoid unnecessary confusion specification omitted part full maude specification illustrating full maude extended new module composition operations 
module full maude sign subsequent modules omitted specification 
strategy library defined previous section real time maude extension defined section appended specification full maude 
module pre full maude handling input output removed 
module timed meta level fairly large want real time maude store database treat importation flattening 
maude module importation treated directly maude engine 
save lot space time 
avoid real time maude tries treat inclusion inclusion module module database declared built module adding module name timed meta level constant builtins module database modifying definition eq builtins truth value truth bool identical machine int qid qid list meta level loop mode timed meta level timed meta level stored real time maude database real time maude access meta representation timed meta level renamed manipulated real time maude user defined modules believe cause 
module database handling handles treatment full maude commands 
rules module theory treat full maude 
timed modules introduced database object instance treated real time maude possible handling inclusions timed meta level 
include module database handling declaration sort ensure current database timed database 
dealt module timed database handling timed modules introduced 
declarations sort subsort added module handling able test current database object timed database object test database added rule module changed crl module database db db input output nil default mn atts database db db input output introduced module default atts fmod endfm obj endo obj mod endm database rule theory modified way 
chosen omit rules keep treatment untimed specifications unchanged possible 
full maude grammar module defining syntax full maude input operator op assoc defines syntax concatenation declarations 
transforming term sort real module full maude assumes term returned meta parse parsing list declarations form 
top symbol different operator declared associative 
real time maude transformation may add new declarations may subterms form treat equation 
eq pu db pu unit pu db module unit processing replaced equations ceq tl pu db tl pu unit tl pu db eq pu db pu db adding strategy language real time maude extension full maude specification starts including strategy library defined section making library available timed meta level declaration fmod timed meta level protecting depth search protecting breadth search endfm modules included contain full strategy library described section 
defining syntax real time maude modules commands define syntax real time maude modules theories commands 
descent function meta parse takes parameter meta representation module list quoted identifiers parsed 
define syntax readable object level maude modules follow technique full maude specification syntax full maude modules commands modules maude object level meta representations obtained importing meta module module views specification full maude defines maude object level syntax full maude modules theories views 
extended module define signature timed modules timed theories fmod timed module syntax including views sorts timed 
subsorts subsort rules op lazy rl token bubble bubble op lazy crl 
token bubble bubble bubble op assoc timed modules theories op op tth declarations object oriented modules sort subsorts op assoc op tomod op toth endfm module commands defines syntax full maude commands definition syntax real time maude commands 
pre full maude sign defines sort bubble denote bubbles arbitrary length sort token denote bubbles length constructors 
get intuition syntax terms sort bubble intended develop terms user defined modules terms sort tokens intended represent single symbol number 
extended bnf syntax real time maude modules commands section fmod timed commands including commands sorts timed meta rewrite op mode dti time 
token bubble bubble op mode dti time 
token bubble bubble ops ma gd gm gma time limit op time limit op le bubble op lt bubble shows lazy rules current module op show lazy op show lazy 
exhaustive search strategies 
op term bubble op find maximal terms reachable mode dti time token token bubble op find deadlocks mode dti time token token bubble op find satisfying mode dti time token token bubble op find satisfying mode dti time token token bubble op find satisfying mode dti time token token bubble op find satisfying mode dti time token token bubble op find satisfying mode dti time 
token token bubble op find satisfying mode dti time token token bubble op keep token op remove matches op matching pattern bubble op matching pattern bubble op matching bubble bubble op matching bubble bubble op matching op matching wrapper op strat 
endfm syntax real time maude modules commands module fmod real time maude sign including timed module syntax including timed commands endfm meta representation equated constant timed grammar sort module fmod meta real time maude sign including meta level protecting meta pre full maude sign protecting unit op timed grammar eq timed grammar including real time maude sign grammar endfm unit function adds inclusion real time maude sign term grammar sort module defines operators sorts token bubble 
preprocessing untimed transformed meta representation full maude modules function module unit processing 
function called directly module timed database handling slightly preprocessed function transforms timed untimed adding appropriate inclusion declaration transforming lazy rule declaration ordinary rule declarations done function 
elements data type store timed module name labels lazy rules module submodules parameters 
function takes timed global table module names labels lazy rules returns table labels lazy rules labels lazy rules added 
function takes care possible timed meta level 
fmod timed unit processing including standard vars qid vars term var tl termlist var llt var qs qidset op term term timed untimed changing wrapper mod endm importing timed prelude transforming lazy rules ordinary rules eq mod endm including token timed prelude qid similarly object oriented timed imports module timed oo prelude eq tomod including token timed oo prelude qid theories treated way eq tth th including token timed prelude qid eq toth oth including token timed oo prelude qid takes meta representation transforms declarations lazy rules declarations ordinary rules leaves declarations unchanged op term term eq eq ceq ceq lazy rl ceq lazy crl 
eq eq lazy rl rl eq lazy crl crl define data type labels lazy rules lazy labels 
term qs represents entry table lazy labels module base name module name parameters associated set qs lazy labels sort op op qid qidset op assoc comm id function lazylabels returns set lazy labels associated module name op lazylabels qid qidset eq lazylabels qs llt qs ceq lazylabels llt llt op qid bool eq false eq qs llt llt function updates table adding entry timed 
variable equation instantiated similar constructor object oriented timed modules timed theories module name parameters denotes body op term eq llt llt getname llt llt getname returns module name possible parameters op getname term qid eq getname token qid strip eq getname token qid strip function extracts lazy labels module name 
extracts lazy labels parameter theories 
list pairs separated commas formal parameter module expression possibly involving renaming instantiations op term qidset eq token llt eq llt parameters may lazy rules llt op term qidset eq tl llt llt tl llt eq tl llt llt tl llt eq llt llt eq token qid llt lazylabels strip llt single theory renaming eq llt llt eq llt llt renaming views 
function takes set quoted identifiers representing lazy labels renaming map applies label renaming label lazy labels op qidset term qidset op qidset qid qid qidset eq qs qs ceq qs tl qs op op op op sort class attr msg msg msg eq qs label token qid token qid qs strip strip eq qs qs ceq qs qs qs function finds labels lazy rules body timed labels lazy rules imported modules labels lazy rules declared op term qidset eq tl llt llt tl llt eq tl llt llt tl llt eq lazy rl token qid llt strip eq lazy crl token qid llt strip ceq llt llt including 

protecting 
pr 
ceq tl llt including 

protecting 
pr 
lazy rl lazy crl importation timed meta level 
mn processed described section 
observe declaration equation eq lazylabels written eq bubble lazylabels qid bubble qid qid qid function handles importation timed meta level op term term ceq llt llt fmod endfm mod endm tomod fth th oth obj obj endo view tth toth eq llt llt llt equation treats importation timed meta apply list parameters meta level imported list parameters adds appropriate lazylabels declarations definitions ceq token timed meta level qid llt token meta level qid protecting token timed meta level qid llt including 

protecting 
pr 
ceq token qid llt token qid strip timed meta level including 

protecting 
pr ceq tl llt tl including 

protecting 
pr ceq token llt token including 

protecting 
pr 
ceq tl llt tl including 

protecting 
pr 
fmod endfm mod endm tomod fth th obj obj endo view tth toth op term term eq llt llt llt eq qid llt op token conc conc lazylabels strip qid qidset qid eq bubble conc conc lazylabels strip qid bubble lazylabels strip llt op qidset term eq qid eq conc qid ceq qs qs qs op qidset termlist ceq qs conc qid qid qs qs eq conc qid endfm executing timed commands section treats execution timed rewrite search commands 
module timed database 
command term resulting parsing user input grammar timed grammar 
states rewritten patterns search bubbles calling strategy functions strategy library executable module computed bubbles parsed terms 
reuse full maude facilities parsing bubbles computing modules 
function takes bubble module bubble parsed parameters returns term resulting parsing bubble 
function updates database evaluating module expression 
function returns module expression module name function produces executable module 
define functions process bubbles parts commands fmod timed command processing pr database pr depth search pr unit decl parsing pr evaluation pr unit meta pretty print pr timed unit processing data type lazy labels op term module database term op term machineint op term term module database usage mode dti term db 
op term module database op term module database var mn var db database vars term var qs qidset var module var var var ms vars qid var llt var tl termlist vars ts ts termset eq db meta reduce true db eq token eq matching pattern db true db eq matching pattern db true db eq matching db true db true db eq matching db true db true db eq matching db eq matching db eq db default db eq db maxtime db eq ma db db eq gd db global default db 
eq time limit db eq le db db eq lt db db function op term database executes timed rewrite computing executable module name calling function op term module database follows eq mode dti time tl mn db llt db mode dti time tl db db llt error module meta pretty print database 
fi eq mode dti time tl mn db llt mode dti time tl mn mn db db llt checks state rewrite default time increase value time limit expression parsable executable module 
parsable error message returned 
parses parts finds rewrite mode maximal number rewrite steps extracts set lazy labels table executes function timed meta rewrite defined section 
output set quoted identifiers function meta pretty print transforms resulting term list 
echo command written resulting term eq mode dti time mn db llt db error db error db timed rewrite meta pretty print db meta pretty print mn time increase dti meta pretty print db db 
result meta pretty print timed meta rewrite db lazylabels mn llt db db 
error time limit 
fi error default time increase term 
fi error 
term rewrite 
fi op term module database bool eq time limit db true eq le db db error eq lt db false op qid eq error eq eq par error eq eq ms op term module database eq time limit db time limit eq le db time meta pretty print db eq lt db time meta pretty print db op term eq default eq local maximal eq ma global maximal eq gd global strategy default 
function op term database handles search command computing executable module search take place set lazy labels calls function op term module database qidset follows eq mn db llt mn db mn db lazylabels mn llt function handles search command calling function op term module database qidset termset finds set terms resulting nested search expression follows eq strat mn db qs strategy db 
result db qs functions op module termset op term module database respectively transforms set term list quoted identifiers prints echo search command 
function parse search command call appropriate strategy function 
simplest case term find initial term eq term db qs meta reduce db search functions specified different versions depending time limit search strictly certain time value equal value 
example find reachable terms certain time depth limits call function function depending time limit strict eq find maximal terms reachable mode dti time db qs db qs qs db db db qs qs db db fi op term bool eq lt true eq le false eq time limit false treatment search expressions entirely similar eq find deadlocks mode dti time db qs 
finding terms satisfying invariant done calling find states representing paths satisfying matches eq find satisfying mode dti time db qs db qs qs db db db db qs qs db db db fi eq find satisfying mode dti time db qs 
eq find satisfying mode dti time db qs 
eq find satisfying mode dti time db qs 
eq find satisfying mode dti time db qs 
eq find satisfying mode dti time db qs 
eq keep db qs db qs eq remove db qs db qs db sets terms strategy echoes quoted identifiers follows eq emptytermset terms 
ceq termset ts ts ts ts ts emptytermset ts emptytermset eq meta pretty print op term qid eq token strip eq term db meta pretty print db eq find maximal terms reachable mode dti time db find terms reachable db db 
op term term term module database eq db time increase dti meta pretty print db db 
endfm database handling database object full maude persistent state stores application level modules entered full maude session responsible treating parsed input 
database class attributes db contains database modules read full maude input contains parsed input term representing treated output contains list quoted identifiers resulting treating input term default value name current module 
persistent state timed specifications store table lazy labels module 
modify class database define subclass database attribute lazylabels 
specification real time maude written core maude currently syntactic support object oriented specification 
module configuration defines features allowing define database objectoriented way albeit full maude convenient syntactic sugar defining classes 
recalling declarations sort subsort added module database handling class timed database handling declared follows mod timed database handling including database handling including timed unit processing importing data type lazy labels including timed command processing op op lazylabels attribute var atts var database var var db database var qid vars term var tl termlist var oid var mn var llt database object initially instance transformed object class timed module timed theory treated crl database input atts input atts lazylabels tomod tth toth database timed treated performing preprocessing described section calling function crl db db input output nil default mn lazylabels llt atts db llt db input output introduced timed module default lazylabels llt atts tomod crl db db input output nil default mn lazylabels llt atts db llt db input output introduced timed theory default lazylabels llt atts tth toth untimed read database object instance timed meta level preprocessing performed treated full maude crl module db db input output nil default mn lazylabels llt atts db llt db input output introduced module default lazylabels llt atts fmod endfm obj endo obj mod endm crl theory db db input output nil default mn lazylabels llt atts db llt db input output introduced theory default lazylabels llt atts fth th oth show lazy commands treated directly module rl db db input show lazy output nil default mn lazylabels llt atts db db input output lazy rules module mn including imported rules lazylabels mn llt default mn lazylabels llt atts rl db db input show lazy output nil default mn lazylabels llt atts db db input output lazy rules module getname including imported rules lazylabels getname llt default mn lazylabels llt atts timed rewrite search strategy commands treated functions respectively crl db db input tl output nil default mn lazylabels llt atts db db input output tl mn db llt default mn lazylabels llt atts mode dti time 
mode dti time 
rl strat db db input strat output nil default mn lazylabels llt atts db db input output strat mn db llt default mn lazylabels llt atts error messages printed timed commands timed modules read crl database input tl output nil atts database input output error timed module introduced atts mode dti time 
show lazy 
mode dti time 
strat database crl database input show lazy output nil atts database input output error timed module introduced atts database endm predefined modules units defines modules placed persistent database imported user defined real time maude module 
predefined modules module timed prelude imported automatically timed modules module time inf extends time domain infinity value inf module ltime assumes linear time domain defines functions min max module ltime inf combines modules module timed oo prelude defines richer sort structure object oriented real time specifications imported automatically object oriented timed modules fmod timed units protecting units op timed prelude eq timed prelude fmod timed prelude including bool sorts time state system clockedsystem subsort system clockedsystem op zero nil time op plus time time time assoc comm prec gather op monus time time time prec gather op le time time bool prec op lt time time bool prec op ge time time bool prec op gt time time bool prec op state system op time clockedsystem time clockedsystem var clockedsystem var time var time eq plus zero time monoid id 
eq time time time plus eq le lt define gt ge le lt eq ge le eq gt lt endfm op time inf eq time inf fmod time inf including timed prelude sorts timeinf subsort time timeinf op inf nil timeinf op plus timeinf timeinf timeinf assoc comm prec gather op monus timeinf time timeinf prec gather op le timeinf timeinf bool prec op lt timeinf timeinf bool prec op ge timeinf timeinf bool prec op gt timeinf timeinf bool prec var ti timeinf var ti timeinf var time eq plus inf timeinf ti inf timeinf eq monus inf timeinf inf timeinf eq le ti inf timeinf true bool eq le inf timeinf true bool eq lt inf timeinf ti false bool eq lt inf timeinf true bool eq ge ti ti le ti ti eq gt ti ti lt ti ti endfm op ltime eq ltime fmod ltime including timed prelude sorts op min time time time assoc comm op max time time time assoc comm var time var time ceq max le true bool ceq min le true bool endfm op ltime inf eq ltime inf fmod ltime inf including time inf including ltime sorts op min timeinf timeinf timeinf assoc comm op max timeinf timeinf timeinf assoc comm var ti timeinf eq max ti inf timeinf inf timeinf eq min ti inf timeinf ti endfm op timed oo prelude eq timed oo prelude fmod timed oo prelude including configuration including timed prelude sorts tokens subsort subsort subsort tokens subsort msg subsort object subsort subsort endfm subsort subsort subsort tokens subsort configuration subsort configuration subsort configuration subsort configuration subsort tokens subsort state op nil op nil op comm assoc id configuration op comm assoc id configuration op comm assoc id configuration op comm assoc id configuration op comm assoc id configuration op comm assoc id configuration op comm assoc id configuration op tokens tokens tokens comm assoc id configuration op comm assoc id configuration endfm handling input output defining persistent loop state module real time maude extends built maude module loop mode cde define initialize persistent state specify communication loop input output system database 
mod real time maude protecting meta real time maude sign protecting timed database handling protecting timed units including loop mode op oid state persistent system represented single object subsort object state constant init defines initial loop state op init system rl init init nil database db timed oo prelude ltime inf ltime time inf timed prelude configuration triv input output nil default real time maude july 
text introduced loop argument operator different nil fact activate rule enters input module command user database 
constant timed grammar names module containing signature defining top level syntax real time maude 
signature meta parse function parse input 
input syntactically valid parsed input placed input attribute database object error message placed output buffer loop var atts var database var oid var db database var mn vars var tl termlist crl database db db input output nil default mn atts meta parse timed grammar error nil database db db input output error incorrect input default mn atts nil database db db input meta parse timed grammar output nil default mn atts fi nil input may syntactically valid semantically valid processing example bubbles may reveal semantic inconsistency 
output attribute persistent object contains nonempty list quoted identifiers rule moves third argument loop 
maude system displays terminal crl database db db input tl output default mn atts database db db input tl output nil default mn atts nil endm chapter specifying analyzing aer nca active network protocol real time maude chapter describes effort specify analyze aer nca protocol suite new complex real time protocol suite reliable multicast active networks 
suite consists composable collection protocol components supporting active error recovery aer nominee congestion avoidance nca features 
aer nca protocol suite proposed bell labs bhattacharyya sprint labs kurose towsley umass amherst kbk 
protocol originally specified informally set cases 
informal specification appendix formalized protocol real time maude test version informal protocol appendix consulting mark various issues protocol 
real time maude specification formal specification protocol 
formalization phase helped clarifying ambiguities forced implicit essential knowledge explicit 
specifying protocol executed real time maude default interpreter set errors way 
flaws detected prototyping earlier versions protocol corrected leading better specification features example form accurate modeling communication added 
specification result iterations specification prototyping correction feature addition cycle 
parts protocol validated real time maude strategy library explore possible behaviors initial state 
parts final specification analyzed executing specification real time maude default interpreter revealed errors 
traced undesired behavior back original informal specification 
protocol revised specification analysis effort 
new version aer informal specification addresses issues brought terms behavior protocol terms making unstated fuzzy knowledge explicit clear 
section motivates need protocol gives overview 
section gives detailed real time maude specification protocol gives examples real time maude executions formally analyze various parts protocol 
section discusses formal methodology experience gained real time maude specify analyze aer nca protocol suite 
appendix presents original informal protocol specification 
overview protocol aer nca protocol suite protocol adaptive reliable multicast active networks possibility having processing capabilities active nodes sender receivers achieve scalability efficiency 
motivation goal reliable multicast send sequence data packets sender group receivers 
packets may lost due congestion network ensured receiver eventually receives data packet 
existing multicast protocols scalable guarantee delivery reasons include kbk ensure reliability sender feedback receivers acknowledging reception data packets ack signaling lack expected packet nak 
receivers frequently sends positive negative acknowledgments single sender sender links closest network easily overwhelmed traffic 
receivers packet lost time keeping sender busy retransmissions 
furthermore sender multicast repair packet receivers small group may lost packet increasing congestion network sender unicast repair packet group desirable efficiency purposes losses high 
addition protocol find appropriate sending rate ensure bandwidth left competing unicast tcp sessions 
repair servers overcome problems kbk suggested active services strategic locations inside network 
active services execute application level programs inside routers equivalently servers located routers physical multicast distribution tree 
caching packets active services subcast lost packets directly receivers localizing error recovery making error recovery efficient solving problem retransmission scoping 
call active service repair server 
repair server missing packet cache aggregates non acknowledgments naks receives sends request lost packet sender solving problem feedback implosion sender 
multicast distribution tree 
terminology multicast distribution tree sender root receivers multicast group leaf nodes repair servers internal nodes 
tree node path node root called parent siblings children node defined analogously 
parent denoted upstream node node children denoted downstream nodes 
expression upstream repair server node denote parent node repair server sender 
example multicast tree fig 
sender repair servers receivers sibling node repair server node real time aspects time dimension protocol due fact congestion essentially timedependent phenomenon addressed aer nca modeled 
packets sent links time takes packet sent node arrives receiver node link depends size packet number packets link link speeds propagation delays link 
factors affect degree congestion modeled faithfully analyze aer nca protocols 
real time aspects appear protocol timers start new queries detect loss various kinds packets 
informal description protocol main tasks protocol active error recovery component deals packet losses tries ensure packet eventually received receivers multicast group 
enhance efficiency error recovery happen close possible nodes losses detected 
rate control loss substantial number packets indicates congestion due high frequency sending packets 
rate control part protocol aims dynamically adjusting rate sender sends new packets frequency decreases packets lost increases time intervals packet losses detected 
finding nominee receiver sender needs feedback discovered packet losses adjust sending rate 
letting receivers report loss rates result messages sent just determine loss rate 
protocol tries find worst receiver loss rates distance sender 
sender takes losses reported nominee receiver account determining sending rate 
finding round trip time values finding sending rate nominee find frequently check missing packets knowledge various round trip times time takes packet travel node node back network needed 
sub protocols addressing tasks described separately informal specification appendix active error recovery active error recovery part protocol ensure packets received members multicast group handling error recovery close possible place packet lost 
sender sends sequence data packets multicast group 
handles messages indicating loss packet resending packet packets identified sequence numbers desired retransmission done 
repair server receiver discovers received data packets signals sending nak packet sequence number missing packet upstream repair server 
nak sending may somewhat delayed repeated certain retransmission intervals packet received 
repair server receiver needs estimate round trip time sender know frequently resend nak packet addition repair server stores received data packets cache original data packets downstream 
discovers packet loss nak packet downstream indicate children aware missing data packet started error recovery children complain 
repair server receives nak downstream missing data packet 
congestion control frequency sender sends new data packets specified previous protocol 
aim congestion control part find sending rate multicast session overly path sender receiver 
congested path identified sending frequency adjusted path overly example seconds complaint takes complaint seconds reach sender 
congested order ensure bandwidth competing tcp sessions worst receiver handle packets 
congestion control consists subtasks treated sub protocol finding worst receiver 
adjusting sending rate loss rate worst receiver 
rate control 
worst receiver nominee receiver receives original data packet sends congestion control message ccm packet sender 
simply speaking frequency increases ccm packets received sender decreases sender hasn seen ccm packet 
actual computations non trivial 
nominee receiver selection 
nominee receiver receiver highest value rtt lpe rtt estimated round trip time source lpe loss probability estimate 
receiver uses sliding window record sequence original packets received compute estimated loss rate lpe 
receiver sends congestion status message csm packet current lpe rtt estimates upstream repair server regular intervals 
repair server receives csm packets children containing nominee subtree child root associated rtt lpe values 
repair server computes nominee subtree received values 
change nominee data repair server sends csm packet upstream repair server new data 
resends data regular intervals blanks data nominee data updated 
sender chooses nominee receiver csm packets children 
new nominee receiver sender sends nominee activation message nam packet old new receiver notify change status new receiver report back acknowledgments 
sender resends nam packet nominee regular intervals 
specifying analyzing aer nca protocol real time maude specify section aer nca protocol suite real time maude object oriented style 
protocol components closely inter related interesting analyze part separately analyzing combined protocol 
specification section tried specify parts separately identifying interface parts 
specified combined protocol object oriented inheritance techniques transitions subprotocol executed executed parts reused stand combined protocol 
specification follows structure informal specification appendix label rewrite rule corresponding name case models 
protocol quite complex addresses scalability issues congestion phenomena associated symbolic simulation algorithm requires large states need efficiently execute large number rewrite steps 
considerations need performing formal analysis involving exhaustive state space searches dictated remove potentially time consuming bottlenecks altering specification 
particular choices execution efficiency purposes discrete time domain nonnegative machine integers dense time domain rationals 
tick rule deterministic 
techniques described section specifying object oriented realtime systems tokens rules global involving terms sort system 
yields specification essentially equivalent system tokens sense step sequential rewrite corresponding systems tokens local rules step sequential rewrite system 
timers set value modeling introducing new variable xr righthand side rule xr xr random number generator set value timer 
having natural numbers time domain poses problems 
lost having deterministic tick rule easy see protocol time deterministic sense instantaneous action take place time advances possible tick rule situation slightly inelegant global rules tokens step sequential rewrites equivalent obvious correspondence kinds specifications concurrency lost global rules simulated interleavings 
similarly pseudo random numbers having truly nondeterministic choice timer values amounts inconvenient overspecification protocol 
summary may view protocol specification section implementation refinement general conceptually satisfying specification protocol global instantaneous rules form replaced corresponding rules pseudo random numbers replaced corresponding nondeterministic rules 
time domain earlier versions protocol machine rational numbers time domain 
turned straightforward extension built machine integers nonnegative rational numbers appendix computations rationals inefficient rewrites required relatively simple computations 
possible exception sending new packets attempted time 
current specification rationals infeasible serious specification efforts 
extended machine integers efficient version fixed point real numbers told set natural numbers adequate time domain protocol 
fixed point reals specification rate control protocol integers sufficient 
specification machine natural numbers protocol fmod naturals including machine int sorts nat nznat subsort nat machineint subsort nznat nat subsort nznat op abs machineint nat op minus machineint machineint machineint prec gather op monus nat nat nat prec gather vars machineint var vars nat mb nat cmb nznat eq minus eq abs fi eq monus minus fi endfm machine naturals time domain scheme described section 
add sort non zero time values fmod discrete time domain including ltime inf including naturals sort subsort nat time subsort time subsort nznat vars nat eq zero eq plus eq lt endfm protocol uses timers 
intended timer force action take place certain time 
achieved letting time elapse expiration time timer turning resetting timer action associated expiration timer performed 
timer attribute value time value timer expires time value notimevalue timer turned 
handle default time value specification extends time domain sort deftime constant notimevalue sort extends operators time domain extended time domain 
clarity define new operators default le extending le new domain overloading fmod default value time domain including discrete time domain sorts deftime subsort time deftime subsort timeinf subsort deftime op notimevalue deftime op default le bool prec equal op default lt bool prec op default monus time prec gather op default min assoc comm vars ti ti timeinf var dt deftime vars time eq ti default le ti ti le ti eq ti default le notimevalue false eq notimevalue default le dt true eq ti default lt ti ti lt ti eq dt default lt notimevalue false eq notimevalue default lt ti true eq notimevalue default monus notimevalue eq ti default monus ti monus eq notimevalue default monus notimevalue eq default min ti ti min ti ti eq default min ti notimevalue ti eq default min notimevalue notimevalue inf endfm declarations object oriented real time systems object oriented timed module contains generic declarations object oriented real time systems 
defines object identifiers quoted identifiers cde defines set object identifiers default object 
module declares functions mte maximal time elapse delta action time object configuration adds axioms show functions distribute objects messages configuration tomod timed oo system including qid including ltime inf subsort qid oid oid just quoted identifiers 
sort oid default value nooid 
subsort oid op nooid sort subsort oid op op assoc comm id prec op delta configuration time configuration op mte configuration timeinf vars var time eq delta eq delta delta delta eq mte inf eq mte min mte mte module defines tick rule stated deterministic restrict timed behavior instantaneous rules system tomod deterministic tick rule including timed oo system var oc crl tick oc delta oc mte oc time mte oc mte oc inf mte oc variable oc sort requires configuration consists objects tick rule applied forces messages treated delay outermost level configuration rule match time advance messages configuration 
modeling communication communication topology communication topology modeled defining multicast tree sender repair servers located inside routers receivers 
appropriate classes objects defined class common classes follows class children class repairserver mentioned entirely convinced sending new data packets nondeterministic behavior time forcing nondeterministic tick rule latest discussions topic colleagues indicate case 
class sender subclass sender class receiver subclass receiver class repairserver subclass repairserver subclass repairserver router table explicitly 
implicitly multicast tree objects values children attributes initial states 
repairserver attribute values set protocol initial state value nooid 
multicast follows tree 
server sends packet children subcast children 
links packets travel bidirectional links 
link characterized nodes bound propagation delay 
link parent child pair topology 
bound defines packets travel link time 
packet lost attempt send link full 
class link defined follows tomod link including timed oo system including default value time domain lists messages may appropriate way storing messages sort subsort msg op nil op assoc id nil leftmost element channel oldest 
class link oid oid bound nznat maximal size buffer link propagation delay 
constant 
nznat megabits sec 
downmsgs buffer messages going downstream downsize nat size upmsgs buffer messages going upstream nat size defining behavior link list variables axioms specifying behavior module var msg vars time vars vars ml ml vars oid vars nat var nzn nznat vars ti ti timeinf var cf configuration var os var packet var transmission delay packet link packet size divided total delay packet entering link max propagation delay transmission delay current delay packet entered link packets link 
data packets usually bytes large kinds packets bytes large sorts packet subsort packet msg subsort msg transmission delay message link speed op msg nznat time eq nzn plus nzn minus nzn eq nzn plus nzn minus nzn nzn times gives bits millisecond round closest integer 
attempt enter packet link takes place method call message send 
message treated link discarding packet link full storing link dly time current delay packet 
time remaining packet delivered link 
packet delivered sending message global configuration treated object packet wrappers msg send msg oid oid msg msg msg oid oid msg msg dly msg time msg current version protocol link capacity limit related number packets regardless sizes packets 
furthermore possible ambiguity link full delay packet link attempt send packet link 
lost due link overflow packet ripe delivery packets released sending packet attempted 
current specification checks packet ready delivery releases packets treating sending messages new packets functions gives greatest delay message message list op timeinf eq nil inf eq dly ml op time eq nil eq ml dly rules take packet sent put link appropriate delay link full drop packet 
rules apply packet ready delivery link forcing link deliver packet treating send requests crl send link bound nzn downmsgs ml downsize cf lt link downmsgs ml dly max ml plus nzn downsize plus cf link cf fi ml crl send link bound nzn upmsgs ml cf lt link upmsgs ml dly max ml plus nzn cf link cf fi ml message ready get link delay rl link upmsgs dly ml cf link upmsgs ml minus cf rl link downmsgs dly ml downsize cf link downmsgs ml downsize minus cf timed behavior link follows assuming class link subclasses eq delta link downmsgs ml upmsgs ml link downmsgs delta ml upmsgs delta ml op delta time op delta msg time msg ensures regularity 
eq delta nil nil ceq delta ml ml delta ml delta ml ml nil ml nil eq delta dly dly monus eq mte link downmsgs ml upmsgs ml min ml ml define send packets group objects msg multisend msg oid configuration eq multisend os send multisend os eq multisend op oid eq os os os fi eq eq tick rule forces messages outermost level configuration treated time advances 
need define functions mte delta messages just avoid introducing junk terms sort time specification 
representation communication topology revisited 
communication topology represented multicast tree defined sender repair servers receivers value children attribute 
routers associated repair servers 
modeling topology may accurate path active nodes may involve links just 
possible way making model precise introduce passive router nodes job forward packets children 
model downstream subcast multicast communication accurately 
packets unicast upstream receivers repair servers 
passive nodes added easy way model upstream unicast unicast may necessarily follow multicast path 
version protocol followed advice network experts kept model communication described 
class hierarchy protocol specified parts rtt finding round trip times nom finding nominee receiver rc rate control algorithm rs repair service error recovery executed separately combined protocol 
object oriented inheritance techniques reuse parts common stand protocol sender sender class hierarchy 
combined protocol 
fig 
shows slightly simplified version class hierarchy sender objects 
class hierarchies repair servers receivers entirely similar 
objects class rtt part protocol analyzed separately sender object combined protocol instance class 
subclasses class rules apply stand part combined protocol involve objects class 
rules describe transitions may occur stand rtt protocol involve objects class transitions occur combined protocol involve objects class 
haven done technique specify combination subprotocols 
transitions differ slightly stand protocol combined protocol 
writing distinct rules case may write rule cases test object applied rule instance combined class indicating combined protocol executed 
examples rules rtt protocol 
purpose define sort define follows sort subsort object var oid mb mb mb frequently classes adequately prototype stand protocol needs data normally provided parts combined protocol 
simple setting environment object defining interface parts protocol attribute containing messages delays dly operator sent protocol 
environment messages generated rules initial state tomod environment including link var oid var mc vars var cf configuration var msg var time class env rl env env dly mc cf env mc cf eq mte env mc mc op timeinf eq dly eq inf eq min eq delta env mc env delta mc commonly module introduces pseudo random number generator protocols 
function random generating pseudo random sequence natural numbers natural numbers instance class pseudo random number generators knu 
object class randomngen carries seed random function object local seed 
seed updated applying random function random function applied seed 
tomod random including timed oo system including naturals class randomngen seed nat op random nat nat random generates random number var nat var nzn nznat var time var qid eq random seed may modified applying random function times op nat nat nat seed eq nzn random nzn minus eq eq delta randomngen randomngen eq mte randomngen inf classes clock attribute defined subclasses class clock class clock clock time list frequently variables avoid repeating exposition declarations variables frequently axioms list variables frequently modules 
var cf configuration vars dq dq dq vars dt dt dt dt deftime vars machineint vars msg vars mc mc vars ml ml vars nat vars vars nzn nzn nzn nzn nzn nznat vars oid vars time var os vars bool shared messages messages packets shared different subprotocols stand mode declared module shared msgs spmpacket nat packet msg deftime deftime oid msg msg bool packet nodes know upstream repair servers able unicast packets localized error handling parameter gives number data packets transmitted sender 
method calls new rtt values rtt protocol additional updates done repair service part protocol 
unicast receivers parameter tells receiver nominee receiver 
rtt protocol task rtt part protocol find repair server receiver object values sourcertt round trip time rtt sender object 
maxuprtt maximal rtt upstream repair server children 
round trip time values estimated values problem sourcertt 
maxuprtt value set time node receives values repair server value dependent values siblings 
interested fairly value maxuprtt 
auxiliary attributes determine desired attributes maxdownrtt largest rtt estimate node immediate downstream nodes 
tells value updated maxrecentdownrtt largest maxdownrtt value maxdownrtt time elapsed set 
myuprtt current rtt estimate node immediate upstream repair server sender 
addition timer attribute getrttresendtimer initiate rtt request objects repair server 
protocol goes roughly follows message initiates sender sends source path message spm packets downstream 
reception packet node initiates timer value ms spm packet downstream 
timer expires node sends packet upstream repair server current time node current estimate rtt repair server 
upstream repair server receives packet may need update maxdownrtt sends back downstream node timestamp unchanged current sourcertt current maxdownrtt values 
originator packet exchange receives response compute latest rtt upstream repair server just current time minus timestamp 
having step rtt adds received sourcertt value upstream repair server gets new sourcertt estimate 
compares received maxdownrtt value maxuprtt estimate 
timer interval may updated 
informal specification say interested round trip times large packets small packets time takes small packet go upstream plus time takes large packet go downstream 
protocol computes round trip times small packets changed declaring packets sort 
repair servers perform transitions sender receivers protocol 
find convenient define superclasses respectively sender repair servers repair servers receivers 
class hierarchy packets involved protocol follows tomod aer rtt including link include crucial module including random timed oo system including default value time domain including common classes including deterministic tick rule including shared msgs rtt objects subclasses rtt class rtt sourcertt deftime sender repair server class maxdownrtt deftime time maxrecentdownrtt time subclass rtt subclass subclass clock repair server receiver class resendinterval time maxuprtt deftime myuprtt deftime getrttresendtimer deftime subclass rtt subclass subclass clock sender stand combined protocols class subclass class subclass class subclass subclass objects stand protocol class subclass class subclass class subclass subclass class subclass subclass msg time deftime packet usage 
msg time deftime deftime packet usage sender initializes protocol multicasting spm packet 
handling spm packets quite elaborate combined protocol 
rtt part specified packets set repairserver attributes start protocol initializing getrttresendtimer value msg oid msg rl children os cf multisend spmpacket os cf rl rs spmpacket randomngen seed children os cf randomngen seed random repairserver getrttresendtimer random multisend spmpacket os cf rl rcv spmpacket randomngen seed cf randomngen seed random repairserver getrttresendtimer random cf node initiates request response round timer expires rl clock repairserver resendinterval myuprtt dt getrttresendtimer cf getrttresendtimer send dt cf split treatment packets myuprtt value second parameter packet value attribute maxdownrtt notimevalue time values exploit variables range time values dt dt range sort deftime comprising time values notimevalue maxdownrtt time values maxdownrtt crl clock sourcertt dt maxdownrtt cf maxdownrtt maxrecentdownrtt send dt cf lt time value maxdownrtt notimevalue rl clock sourcertt dt maxdownrtt notimevalue cf maxdownrtt maxrecentdownrtt send dt cf notimevalue rl notimevalue clock sourcertt dt maxdownrtt dt maxrecentdownrtt cf plus lt maxdownrtt maxrecentdownrtt send dt cf send dt dt cf fi maxdownrtt time values maxdownrtt crl clock sourcertt dt maxdownrtt maxrecentdownrtt cf plus lt maxdownrtt max maxrecentdownrtt send max dt cf maxrecentdownrtt max send dt cf fi le treatment packets divided cases depending maxuprtt attribute value value second parameter received packet time values 
repair service part combined protocol needs update values maxuprtt value changes 
repeating quite complex rules combining corresponding rules rs protocol convenient check object involved transition combined object case method message called sent object treated repair service part crl dt dt clock sourcertt dt resendinterval maxuprtt dt cf sourcertt dt notimevalue dt plus monus dt fi resendinterval min monus maxuprtt dt notimevalue max monus dt monus fi myuprtt monus getrttresendtimer monus send monus dt notimevalue dt plus monus dt fi dt notimevalue max monus dt monus fi fi cf dt notimevalue dt notimevalue maxuprtt notimevalue rl dt clock sourcertt dt resendinterval maxuprtt cf sourcertt dt notimevalue dt plus monus dt fi resendinterval min maxuprtt max monus myuprtt monus dt notimevalue dt plus monus dt fi max monus fi cf need specify time acts rtt object stand protocol long time advance timer expires eq delta clock clock plus eq delta clock getrttresendtimer dt clock plus getrttresendtimer dt default monus eq mte inf eq mte getrttresendtimer eq mte getrttresendtimer notimevalue inf analyzing rtt protocol real time maude define initial state parameterized initial value seed calls random execute rtt specification tomod aer rtt including aer rtt ops nat system 
eq clock sourcertt children maxdownrtt notimevalue maxrecentdownrtt clock sourcertt notimevalue repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue clock sourcertt notimevalue children maxdownrtt notimevalue maxrecentdownrtt repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue clock sourcertt notimevalue children maxdownrtt notimevalue maxrecentdownrtt repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue clock sourcertt notimevalue repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue clock sourcertt notimevalue repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue clock sourcertt notimevalue repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue random randomngen seed ab link bound downmsgs nil downsize upmsgs nil multicast distribution tree decorated transmission delay small packets empty links 
ac link bound downmsgs nil downsize upmsgs nil cd link bound downmsgs nil downsize upmsgs nil ce link bound downmsgs nil downsize upmsgs nil df link bound downmsgs nil downsize upmsgs nil dg link bound downmsgs nil downsize upmsgs nil fig 
shows shows multicast distribution tree number associated link indicates time takes small packet travel link link empty 
example empty links round trip time source nodes respectively maxuprtt nodes respectively 
quick prototyping check values obtained achieved maude rewrite command maude rew rewrites ms cpu ms real rewrites second rewrite aer rtt result error clockedsystem clock repairserver sourcertt getrttresendtimer myuprtt maxuprtt resendinterval efficient standard maude rewrite command tick rule deterministic system contains lazy rules 
clock children repairserver sourcertt maxrecentdownrtt maxdownrtt getrttresendtimer myuprtt maxuprtt resendinterval random randomngen seed clock children sourcertt maxrecentdownrtt maxdownrtt clock repairserver sourcertt getrttresendtimer myuprtt maxuprtt resendinterval clock children repairserver sourcertt maxrecentdownrtt maxdownrtt getrttresendtimer myuprtt maxuprtt resendinterval clock repairserver sourcertt getrttresendtimer myuprtt maxuprtt resendinterval ac link upmsgs nil downsize downmsgs nil bound ab link upmsgs nil downsize downmsgs nil bound clock repairserver sourcertt getrttresendtimer myuprtt maxuprtt resendinterval cd link upmsgs nil downsize downmsgs nil bound ce link upmsgs nil downsize downmsgs dly bound df link upmsgs nil downsize downmsgs nil bound dg link upmsgs nil downsize downmsgs nil bound time values correct 
assume nominee time need rtt values finding nominee receiver interesting check values time maude mode dti time le rewrites ms cpu ms real rewrites second 
result clock repairserver sourcertt getrttresendtimer myuprtt maxuprtt resendinterval clock children repairserver sourcertt maxrecentdownrtt maxdownrtt getrttresendtimer myuprtt maxuprtt resendinterval output real time maude executions manually tabulated readability purposes parts output omitted exposition replaced 

clock children repairserver sourcertt maxrecentdownrtt maxdownrtt getrttresendtimer myuprtt maxuprtt resendinterval 
time values values looking 
gain assurance correctness specification explore just behavior arbitrarily chosen real time maude default interpreter possible behaviors relative certain conditions starting initial state 
main property stand rtt protocol satisfy long packet travels simultaneously direction link rewrite path reach state desired sourcertt maxuprtt values time depth limits reachability desired values change time limit stability 
properties expressed formula matching timelimit matching pattern temporal logic defined section pattern containing desired values attributes objects 
module introduces variables needed express pattern desired states tomod protecting aer rtt vars atts atts atts var cf configuration pattern satisfied desired states sourcertt maxuprtt atts sourcertt maxuprtt atts sourcertt maxuprtt atts cf pattern matched states correct values sourcertt maxuprtt values objects real time maude search expression returns terms reachable satisfy desired reachability stability property rewrite paths total simulated time elapse equal follows maude strat find satisfying matching matching pattern sourcertt maxuprtt atts sourcertt maxuprtt atts sourcertt maxuprtt atts cf term mode gm dti time le unfortunately current version tool executes command slowly large states involved performs kinds checks lazy rules variables introduced righthand sides tick rules real time maude strategy library easily define optimized strategy corresponding search described 
see chapter explanation timed meta level features involved 
fmod aer strategies including timed meta level vars term vars ts ts ts ts termset var qid vars machineint var module var qs qidset var dt var dp eq termset including timed meta level access real time maude strategy library 
add parameter import declaration module analyzing protocols 
function uses fact rewrite rules global tick rule deterministic define reasonably efficient function giving result applying rule term form time form op module term qid machineint term eq meta apply eq time meta apply error error meta reduce time meta apply fi function extended find terms reachable rewrite step term knowledge lazy rules system op module term termset op module term qidset termset eq eq qs termset qs eq emptytermset op module term qid machineint termset eq error termset emptytermset fi observe timed meta level functions 
search property function mod timelimit pattern gives set terms representing paths invalidating reachability stability property described pattern starting initial term having maximal bound number rewrites path time limit timelimit total time elapse path 
enhance efficiency function return bad states state invalidate property op module term machineint termset usage timelimit search performed breadth search function op module machineint termset termset termset termset machineint termset usage timelimit mod timelimit pattern ts ts ts ts limit length rewrite paths stands unlimited timelimit limit stands absence limit total simulated time elapsed path current round ts set terms reachable initial state steps state path matched pattern rewritten current round ts denotes terms reached current round match pattern ts denotes set terms matching pattern rewritten round ts terms matching pattern reached round 
equation initializes search function 
initial state matches pattern placed ts place terms satisfying pattern checked current round eq dt dp dp meta reduce dt dp emptytermset emptytermset meta reduce emptytermset dt dp meta reduce emptytermset emptytermset emptytermset fi equation analyze states reachable step term satisfying pattern 
rewritten represents path invalidates desired property lead state satisfying pattern returned 
successor state time limit rewrite path desired state reached time limit returned case 
cases apply set terms reachable step added set terms checked round match pattern eq dt dp termset ts ts ts ts emptytermset dt emptytermset dt dp ts termset ts dp ts termset ts dp fi analyze states reachable state matching pattern 
successor states time limit match pattern stability part property invalidated successor states returned function 
reachable states time limit added terms check round eq dt dp ts ts termset ts ts dt dp emptytermset dt dp dt dp ts ts ts termset ts dt dp fi round ends terms treat current round 
number rounds completed equals depth limit states reached pattern returned 
terms check round counterexamples property proved initial state time depth limit 
new round started eq dt dp emptytermset ts emptytermset ts rounds ts emptytermset ts emptytermset ts dt dp ts emptytermset ts emptytermset fi endfm able develop application specific strategy quickly making heavy timed meta level data types patterns sets terms functions data types 
function get meta representation term check desired property holds rewrite paths total time elapse equal starting state maude fmod rtt strategies protecting aer strategies including meta level endfm rewrites ms cpu ms real rewrites second introduced module rtt strategies maude red nat nat sourcertt maxuprtt atts sourcertt maxuprtt atts sourcertt maxuprtt atts cf rewrites ms cpu ms real rewrites second 
result termset emptytermset path satisfying desired property increasing confidence correctness protocol 
gain assurance analyze executions starting states just changing seed random number generator changing communication topology 
nom protocol goal nom part protocol find receiver highest value rtt lpe rtt round trip time receiver sender lpe loss probability estimate receiver receiver know chosen nominee receiver 
sender receives messages type children packet containing lpe rtt values receiver congested path subtree child root 
sender compares received values values current nominee stored attributes csmnominee csmlpe csmrtt 
received values indicates congested receiver path nominee seconds elapsed nominee values updated values updated messages sent old new nominee receiver nominee changed 
resent nominee regular intervals expires 
sender declared follows tomod nca nom including random including link including window including common classes including deterministic tick rule including shared msgs including environment class deftime csmnominee csmlpe csmrtt deftime time subclass sender subclass clock class subclass message initiate protocol vars dn dn dn dn msg oid msg msg deftime packet usage lpe rtt rl children os cf multisend spmpacket os cf function take received stored nominee values current time time nominee values updated returns true iff nominee values updated 
comparing rtt lpe values compare squares rtt lpe 
furthermore new old nominee receivers unicast going links abstraction seen having delay 
ready read form op deftime deftime time time bool usage lpe rtt addr csmnominee csmlpe csmrtt currenttime eq dn dt dq dq dn dt dn dn dq nooid dq dq dn dn dt default lt dt plus lt dq nooid dq dq le dn dn le le dn dn le dn dt lt dn dt plus lt fi op nat deftime nat eq eq notimevalue rl dn dt dq clock csmnominee dq csmlpe dn csmrtt dt dt cf dn dt dq dq dn dt csmnominee dq csmlpe dn csmrtt dt dq dq dt fi dq dq dq nooid new nominee true dq fi dq dq dq nooid previous nominee false dq fi cf cf fi sent nominee seconds rl csmnominee dq cf dq nooid true dq cf notimevalue cf fi repair server stores values receiver congested path subtree 
change worst receiver status new values sent upstream repair server 
time csmtimer expires rule repair server sends current nominee values repair server seconds elapsed values updated case values set default values class csmlpe csmrtt deftime time csmtimer deftime subclass repairserver subclass clock class subclass initialize csm timer repairserver attributes rl spmpacket children os cf repairserver csmtimer multisend spmpacket os cf rl dn dt dq clock repairserver dq csmlpe dn csmrtt dt cf dn dt dq dq dn dt dq csmlpe dn csmrtt dt csmtimer dq nooid send dn dt dq fi cf cf fi rl clock repairserver csmlpe dn csmrtt dt dq csmtimer cf plus lt csmlpe csmrtt nooid csmtimer cf csmtimer dq nooid send dn dt dq fi cf fi time csmtimer receiver expires receiver send current lpe rtt values upstream 
stand protocol set sourcertt attribute initial state leave unchanged 
receiver updates sliding window sequence number data packets receives estimate loss probability 
declarations define interface sliding window module window lv needs default numbers may divide 
sort subsort nat op sort window op nznat window empty window max size op size window nat op add nznat window window adds sequence number window op window estimates lpe stand nom protocol simpler data packet define receiver follows msg datapacket nznat time usage datapacket seqno timestamp 
class isnominee bool sourcertt deftime window window storing message numbers csmtimer deftime subclass receiver class nomreceiveralone subclass nomreceiveralone var window timer started initial value randomly chosen rl spmpacket randomngen seed nomreceiveralone cf randomngen seed random nomreceiveralone repairserver csmtimer random cf rl datapacket nzn nomreceiveralone cf nomreceiveralone add nzn cf receiver sends current sourcertt lpe values repair server csmtimer expires 
original protocol lpe estimate considered unreliable size window default value sent 
easier prototyping changed number 
rl csmtimer repairserver sourcertt dt cf csmtimer send size fi dt cf isnominee attribute updated received status rl nomreceiveralone cf nomreceiveralone isnominee cf time acts nom objects rtt protocol updating clock timer attributes letting mte ensure time advance stops timer expires eq delta clock dt clock plus dt default monus eq delta clock csmtimer dt clock plus csmtimer dt default monus eq delta nomreceiveralone csmtimer dt nomreceiveralone csmtimer dt default monus eq mte dt dt notimevalue dt inf fi eq mte csmtimer dt dt notimevalue inf dt fi eq mte nomreceiveralone csmtimer dt dt notimevalue inf dt fi analyzing nom protocol module nca nom extends module nca nom declaration initial states having topology initial states analyze rtt protocol 
data packets generated stand protocol entered environment object initial state tomod nca nom protecting nca nom 
op nat system eq clock children notimevalue csmlpe csmrtt csmnominee nooid nomreceiveralone sourcertt repairserver nooid isnominee false csmtimer notimevalue clock children repairserver nooid csmlpe csmrtt nooid csmtimer notimevalue clock children repairserver nooid csmlpe csmrtt nooid csmtimer notimevalue nomreceiveralone sourcertt repairserver nooid isnominee false csmtimer notimevalue nomreceiveralone sourcertt repairserver nooid isnominee false csmtimer notimevalue nomreceiveralone sourcertt repairserver nooid isnominee false csmtimer notimevalue random randomngen seed ab link bound downmsgs nil downsize upmsgs nil ac link bound downmsgs nil downsize upmsgs nil cd link bound downmsgs nil downsize upmsgs nil ce link bound downmsgs nil downsize upmsgs nil df link bound downmsgs nil downsize upmsgs nil dg link bound downmsgs nil downsize upmsgs nil env env dly datapacket dly datapacket dly datapacket dly datapacket dly datapacket dly datapacket dly datapacket dly datapacket dly datapacket dly datapacket dly datapacket lpe values time starting initial state data packets received time receiver largest rtt value case chosen nominee maude mode dti time le 
result clock children csmlpe csmnominee csmrtt nomreceiveralone repairserver isnominee true csmtimer window nil sourcertt 
time time time receiver received packet remain nominee maude mode dti time le 
result csmlpe csmnominee 
nomreceiveralone isnominee true window nil 
time messages received time loss rate node loss rate nominee maude mode dti time le 
result nomreceiveralone isnominee true window sourcertt 
csmnominee csmlpe 
nomreceiveralone isnominee false window 
time executions real time maude default strategy gave desired results 
analyze protocol explore possible behaviors relative appropriate requirements initial state 
shown crucial combined protocol nominee receiver exist sender sends data packet 
property system receiver nominee knows stable system may receiver knows nominee false treated corresponding true treated 
function analyze rtt protocol analyze nom protocol 
defined module aer strategies earlier function op module term machineint termset usage module timelimit pattern 
efficiently finding rewrite paths pattern reached certain time number rewrites 
function model check liveness properties form timelimit matching pattern pattern exploring rewrite paths limit number rewrite steps path initial state 
returns state representing paths invalidate property hold emptytermset property holds 
usual limit length rewrite path means limit time limit means total time elapse allowed path unbounded 
breadth search performed function op module machineint termset termset machineint termset usage module timelimit 
fifth sixth arguments denote terms rewritten current round round respectively 
term sets matches pattern associated time elapse time limit 
equation initiates search letting initial state state analyze round satisfies pattern eq dt dp dt dp meta reduce dp emptytermset term analyzed current round successor state successor state total time elapse time limit term represents rewrite path pattern reached time limit 
successor states matching pattern added states checked round 
eq dt dp termset ts ts emptytermset dt emptytermset dt dp ts termset dp ts fi terms check current round new round started limit length rewrite paths reached states left analyzed eq dt dp emptytermset ts ts emptytermset ts dt dp ts emptytermset fi module tomod protecting nca nom var atts var cf configuration var qid pattern nomreceiveralone isnominee true atts cf matched receivers nominee flag set true 
temporal property matching pattern nomreceiveralone isnominee true atts cf holds nominee receiver time 
property successfully model checked initial state module fmod nom strategies protecting aer strategies including meta level endfm follows maude red nat nat nomreceiveralone isnominee true atts cf rewrites ms cpu ms real rewrites second 
result termset emptytermset path satisfying property 
case nominee aware status time command output readable assumption result single term 
maude red nat nat nomreceiveralone isnominee true atts cf rewrites ms cpu ms real rewrites second result error clockedsystem csmnominee nooid 
nomreceiveralone isnominee false 
nomreceiveralone isnominee false csmtimer 
time receiver nominee paths 
property defined temporal formula matches nomreceiveralone isnominee true atts cf checked successfully follows maude red nat nomreceiveralone isnominee true atts cf rewrites ms cpu ms real rewrites second 
result termset emptytermset show nominee set exists path point receiver knows nominee receiver 
property verified finding counterexamples property matching matching pattern nomreceiveralone isnominee true atts cf states value isnominee attribute receiver true receiver necessarily isnominee flag set true 
expected property hold refuted providing counterexample maude red nat nomreceiveralone isnominee true atts cf rewrites ms cpu ms real rewrites second result error clockedsystem nomreceiveralone isnominee false 
csmnominee 
nomreceiveralone isnominee false 
nomreceiveralone isnominee false 
nomreceiveralone isnominee false 
true 
time result counterexample showing expected scenario new nominee read false read true 
change nominee occur combined protocol due change rtt values cause problems data packet received time 
sum analysis effort default execution exhaustive search methods validated protocol addition confirmed times receiver systems thinks nominee receiver 
rate control protocol rate control protocol tries adjust sending frequency data packets feedback nominee receiver 
protocol decide shortest time packet sent reception message alter earliest time packet sent 
protocol decide packet sent current time 
sender decides allowed sending rate reception messages nominee receiver 
nominee receives data packet seen sends sequence number lowest outstanding data packet timestamp transmission flag received data packet sender 
sender part fairly complex just outline main ideas 
sender window sequence numbers defining set data packets sent starting sequence number lowest outstanding data packet nominee receiver attribute containing winsize elements 
lowest sequence number nominee receiver hasn seen window size highest sequence number data packet sent 
limitation sending new packet sent value denoting number original data packets sent received greater certain limit 
protocol concerned increasing decreasing winsize value feedback lack thereof nominee 
time received normal recovery mode value winsize attribute increases threshold reached winsize increases smaller amount sender goes fast repair mode winsize received lowest outstanding sequence number 
value 
fast recovery mode number messages sent lowered 
time passed sending data packets received rate control window reset start state albeit smaller threshold 
initial value depends round trip time estimate nominee number times row expired 
execution stand rc protocol interesting added sending mechanism attempts send new packet ms convenient analysis purposes add sender list times managed send original data packet 
strictly speaking part part protocol appear specification provided strategy records times packet sending rule applied add protocol get information directly just executing standard real time maude commands 
data type defining lists time values list concatenation denoted juxtaposition module nat time list 
value winsize attribute increased inverse divided 
rationals computationally inefficient extended machine integers fixed point reals number denoted term sort fixedpointnumber 
specification fixed point reals appendix suffices say term fixed gives fixed point number corresponding int gives truncated integer part fixed point number fixed point numbers equipped necessary functions plus minus times div le min floor abs 
stand rate control protocol specification tomod nca rc including link including common classes including deterministic tick rule including environment including fixed point reals msg nznat time bool data packet stand rc protocol 
usage seqno timestamp msg oid nat time bool packet usage originator timestamp reset isnominee flag msg bool packet usage 
class csmnominee nominee timer set winsize nat nat seqno nat seqno original data packet sent smoothedrtt machineint rttvariance machineint time threshold slower winsize increase nat times timer expired row bool fast recovery mode 
nat seqno stay fr mode nat number original data packets sent ccm packet received deftime subclass clock subclass sender attributes really part protocol execute standalone rc protocol interesting way 
appear combined protocol declared subclass class senddatatimer deftime timer send data 
initialized system find nominee 
nznat message number send 
times data packets 
subclass vars oid var seqno nznat vars timestamp time vars frf bool vars ws sst vars wls dls mss frs mbc nat vars srtt machineint var deftime var tl ignored come nominee receiver crl seqno timestamp csmnominee dq cf cf dq reception nominee somewhat complex cases rl seqno timestamp clock csmnominee winsize ws wls dls mss smoothedrtt srtt rttvariance sst frf frs mbc cf winsize seqno wls frf frs max seqno wls max min sst fixed fixed seqno wls frf seqno wls dls max min max winsize seqno wls frf ws sst div fixed fixed plus fixed fixed fixed seqno wls frf max seqno wls frs max min winsize seqno wls frf ws sst plus fixed fixed fixed winsize seqno wls frf ws sst fi fi fi max seqno wls seqno wls dls smoothedrtt srtt srtt max minus timestamp srtt max minus timestamp minus srtt fi fi rttvariance srtt abs max minus timestamp minus srtt abs max minus timestamp minus srtt minus fi fi seqno wls frf seqno wls dls max winsize seqno wls frf ws sst div fixed fixed sst fi srtt max minus timestamp abs max minus timestamp minus srtt srtt max minus timestamp minus srtt srtt max minus timestamp minus srtt abs max minus timestamp minus srtt minus fi fi fi frf max seqno wls frs seqno wls dls fi seqno wls frf frs max seqno wls seqno wls frf seqno wls dls max wls seqno int winsize seqno wls frf ws sst minus frs fi fi mss max wls seqno notimevalue fi cf op nat nat nat nat eq seqno wls dls seqno wls dls wls seqno dls fi fi op winsize nat nat bool gives winsize line true protocol eq winsize seqno wls frf ws sst frf seqno wls ws max min ws le sst ws plus fixed ws plus fixed div floor ws fi fixed fixed fi function decides new packet sent 
checks data packet having sequence number window sequence numbers sent sender fast recovery mode op nat nat bool nat bool usage winsize eq mss wls ws frf mbc mss wls int ws minus frf mbc mbc fi senddatatimer expires ms initial wait ms new data packet sent rule possible window updated rule expires rl children os clock csmnominee dq senddatatimer nzn mss wls winsize ws frf mbc dt dq tl cf nzn mss mss wls ws frf mbc senddatatimer nzn mss wls mss notimevalue fi mbc wls mss dq dq fi tl multisend nzn false os cf senddatatimer cf fi rl dq sst winsize ws wls mss frf frs mbc cf notimevalue dq nooid fixed max ws div fixed fixed fi dq nooid min fi winsize fixed mss false cf value changed nominee 
stand protocol change nominee modeled method msg msg rl dq csmnominee dq cf csmnominee dq dq nooid dq dq fi cf repair server packets repair server downstream rule propagates packets children upstream class subclass repairserver class subclass rl nzn children os cf multisend nzn os cf rl nzn repairserver cf send nzn cf receiver stores sequence numbers data packets seen attribute sort ordered lists nonzero natural numbers list concatenation denoted juxtaposition able find lowest outstanding sequence number 
sort operations add adding element sorted list operation inlist decide element list 
combined protocol lowest outstanding sequence number value attribute readnextseq 
class isnominee bool class subclass vars nnl nnl find lowest outstanding sequence number op nznat eq nil eq nzn nnl nzn nzn nnl fi op nznat eq nzn nzn nnl nzn nzn nzn nzn nnl fi eq nzn nzn nominee receiver send upstream unicast 
sender way intermediate repair servers new data packet received 
rule updates nominee status receiver 
rl nzn isnominee nnl cf add nzn nnl nzn inlist nnl send add nzn nnl fi cf rl cf isnominee cf timed behavior objects entirely eq mte dt senddatatimer dt default min dt dt eq delta clock dt senddatatimer dt clock plus dt default monus senddatatimer dt default monus eq delta eq mte inf eq delta eq mte inf add initial state suggested mark prototype stand rc protocol 
tomod nca rc protecting nca rc op system eq clock children csmnominee nooid nooid winsize fixed smoothedrtt rttvariance fixed false notimevalue senddatatimer nil children repairserver isnominee false nil env env dly dly true ab link bound downmsgs nil downsize upmsgs nil bc link bound downmsgs nil downsize upmsgs nil results expect executing specification 
sending window packet sent 
acknowledgment packet lowest outstanding sequence number received lowest window number size window increased window data packets sent 
acknowledgment packet received window packets sent 
sequence sending responses message sent response furthermore congestion delays sending rate grow exponentially 
message releases messages round trip time release messages round trip time cycle exponential increase flatten window size reached threshold window size increase inverse 
increasing sending frequency result packets getting lost 
full protocol packets repaired add repair service stand rc protocol 
system get stuck data packet lost receiver require get 
eventually day saved expiration reset packet sent reset window size starting slow sending 
sample execution protocol gives result maude rew rewrites ms cpu ms real rewrites second rewrite nca rc result error clockedsystem clock children csmnominee true rttvariance smoothedrtt winsize senddatatimer children repairserver isnominee true 
time packets sent pairwise exponentially 
increasing frequency 
packet lost number packet sent 
system gets stuck packet sent time quite long time ms timer expires system get back normal set packet waiting sent slow sending rate 
packet repaired cause problems 
relevant due lack repair service output part time analyzed 
repair service protocol repair service part main part aer nca protocol 
protocol specifies system receives variable sized data blocks sender application places data number data packets responsible transmitting data packets order group receiver applications original data blocks easily recovered 
sender protocol sender object tasks initialize protocol nodes multicasting spmpacket packets receive data blocks application layer protocol turn data block fixed sized data packets multicast data packets multicast regular intervals source path messages sequence number retransmitted data packet sent handle repair requests retransmitting requested data packets 
sender receives data blocks form content sender size application layer content identifier content data sender sender object useful case multicast groups trees size number data packets needed represent data block desired interval consecutive original data packets 
data packets form datapacket content seqno timestamp content identifier data block transmitted seqno sequence number data packet equals plus number original data packets sent current execution protocol timestamp time packet sent true iff packet data packet data block true iff data packet packet data block true iff packet repair packet 
messages declared module aer rs tomod aer rs including link including random including common classes including deterministic tick rule including shared msgs including environment msg qid oid nznat time msg msg datapacket qid nznat time bool bool bool sender store parts data blocks send 
done attribute list elements form data content size number data packets multicast data block size correspond parameters data block 
sort databuffer op data qid nznat nznat time databuffer op nil databuffer op databuffer databuffer databuffer assoc id nil databuffer sender class declared follows meaning attributes explained class nznat seqno data packet sent deftime retransmission buffer databuffer data multicast senddatatimer deftime try send data expires subclass sender subclass clock class subclass data block received application layer stored sender block sending wait seconds ensure nominee set var db databuffer var rl nzn db senddatatimer dt nzn cf db data nzn senddatatimer dt notimevalue nzn fi dt fi cf ms triggered expiration sender multicasts source path message sequence number original data packet sent 
furthermore sender starts operation multicasting source path messages initiate repair servers receivers allow set repairserver attributes msg oid msg initializes sender starts protocol 
rl children os nzn dt cf multisend spmpacket os multisend spmpacket os multisend spmpacket os multisend spmpacket os multisend spmpacket os multisend spmpacket os multisend spmpacket os multisend spmpacket os multisend spmpacket os multisend spmpacket os cf rl nzn children os cf multisend spmpacket nzn minus os cf able serve retransmission requests lost data packets sender store transmitted data packet attribute nak count value packet denotes approximately times repair packet requested 
retransmission buffer consists messages form data packet nakcount wrapper declared msg msg nat msg data packet sequence number multicast senddatatimer expires rl send children os clock nzn data nzn nzn db senddatatimer cf nzn nzn nzn nil data nzn nzn fi db datapacket nzn nzn nzn nzn nzn false senddatatimer nzn nzn db fi multisend datapacket nzn nzn nzn nzn nzn false os cf op databuffer deftime eq nil notimevalue eq data nzn nzn db child received data packet received needs see data packet requests retransmission data packet sending nakpacket message containing sequence number missing packet nak count 
nak count equal sender nak count packet repair underway performed msg nakpacket nznat nat bool packet usage nakpacket seqno nakcount fastrepairflag rl nakpacket nzn children os mc datapacket nzn cf mc datapacket nzn true fi max multisend datapacket nzn true os fi cf receiver protocol receiver receives data packets forwards receiver application increasing order sequence numbers data packets sequence numbers data packet received forwarded 
data packets received forwarded stored databuffer attribute smallest sequence number non received data packets stored readnextseq attribute 
receiver detects missing data packets data packets source path messages unexpectedly high sequence numbers received 
receiver waits small amount time case sibling repair server detects loss sending nak request newly detected packet loss repair server turn sends data packet cache forwards request upstream 
receiver requests repair data packet receive response repair request reasonable amount time 
time consecutive repair requests data packet depend round trip times source repair request may propagated way source worst case 
suppression time sending nak packet depends siblings repair server round trip times repair server 
nak packet sent delay receiver fastrepairflag set case nominee receiver 
sequence number values suppression retransmission timers nak count denoting number times repair requested suppressed stored missing data packet sort datainfo op info nznat deftime deftime nat datainfo info seqno nakcount op datainfo op datainfo datainfo datainfo assoc comm id datainfo receiver class declared follows class isnominee bool fastrepairflag bool readnextseq nznat expected seqno application 
smoothedrtt machineint smoothed rtt estimate source rttvariance machineint suppressto time time sending nak packet retransto time time resending nak packet databuffer buffers datainfo datainfo store info repairs bool spm message read 
subclass receiver class subclass set repairserver attribute find lost packets 
spm value received means source transmitted data packet sequence number data packets sequence numbers equal received considered missing 
detection missing packets error recovery started receiver initiates error recovery creating new repair state sequence number nak count mentioned suppresses repair request starting suppression timer packet requests repair timer expires 
done adding element info notimevalue suppression time receiver fast repair mode datainfo attribute done function vars di di datainfo rl spmpacket false cf spmpacket true repairserver cf rl spmpacket true cf repairserver cf rl spmpacket nzn randomngen seed true fastrepairflag readnextseq nzn suppressto databuffer mc datainfo di cf randomngen seed nzn minus max nzn minus mc di fi repairserver datainfo di max nzn mc di nzn cf op datainfo bool nat nat time nat datainfo usage datainfo fastrepairflag suppressto eq di di info notimevalue di random fi fi finds new suppression timer value op bool time nat time usage fastrepairflag suppressto eq true eq false random plus function removes repair information packet sequence number 
function finds highest sequence data buffer 
function finds highest sequence number nak count greater 
function decides repair information packet sequence number 
definition functions straightforward omitted exposition 
received data packet seen delivered receiver application case sequence number smaller readnextseq value databuffer receiver timers triggering repairs canceled crl datapacket nzn readnextseq nzn databuffer mc datainfo di cf datainfo di nzn cf nzn nzn nzn seqnoin mc op datainfo nznat datainfo eq nzn eq info nzn dt dt di nzn info nzn notimevalue notimevalue di ceq di nzn di nzn di op seqnoin nznat bool eq nzn seqnoin false eq nzn seqnoin nzn seqnoin nzn seqnoin eq nzn seqnoin datapacket nzn nzn nzn error recovery packets missing new data packet received similar case spm packets received 
addition sequence number received packet equals readnextseq packet sent receiver application subsequent packets sequence number gap received packets occurs 
avoid passing data packets receiver applications ordering packets sent message form datapacket id 
cat datapacket id 
cat 
cat datapacket id 
packets sent receiver application system removed sender buffer error recovery information store 
function sends packet application remove flush appropriate packets error recovery information crl datapacket nzn randomngen seed fastrepairflag readnextseq nzn suppressto databuffer mc datainfo di cf randomngen seed nzn minus monus max nzn minus di mc fi readnextseq max nzn datapacket nzn mc nzn databuffer mc datapacket nzn nzn datainfo remove di nzn max nzn mc di nzn minus mc datapacket nzn nzn datapacket nzn mc nzn cf nzn nzn nzn seqnoin mc msg oid msg msg op cat assoc eq mc cat mc eq cat mc mc op cat msg msg msg assoc function defines packets send application op nznat oid calls workhorse op nznat readnextseq eq mc nzn mc nzn mc nzn fi ceq mc nzn nzn seqnoin mc eq datapacket nzn mc nzn datapacket nzn cat mc nzn function removes sent application 
op nat op nat eq eq datapacket nzn nzn eq mc cat datapacket nzn nzn eq mc mc mc op nat removes seqno nd argument eq eq mc mc eq nzn nzn nzn eq datapacket nzn nzn nzn nzn datapacket nzn fi removes datainfo elements seqno nd argument op remove datainfo nat datainfo eq remove ceq remove di di remove di remove di di di eq remove info nzn dt dt nzn info nzn dt dt fi repair request missing data packet sent upstream suppression timer packet expires retransmission timer started 
receiver gives unsuccessfully requested repair times rl readnextseq nzn fastrepairflag databuffer mc repairserver datainfo info nzn dt di retransto cf nzn seqnoin mc nzn nzn datainfo info nzn notimevalue dt di cf error datainfo info nzn notimevalue di send nakpacket nzn cf fi fi op error configuration new repair session started retransmission timer lost data packet expires rl randomngen seed readnextseq nzn suppressto fastrepairflag databuffer mc datainfo info nzn dt di cf nzn nzn nzn seqnoin mc randomngen datainfo info nzn dt notimevalue di cf randomngen seed random fi datainfo info nzn notimevalue di cf fi receiver suppresses current repair request turning suppression timer turning retransmission timer receives relevant nakpacket repair server rl nakpacket nzn readnextseq nzn retransto databuffer mc datainfo info nzn dt dt di cf cf nzn seqnoin mc nzn nzn datainfo info nzn dt di fi crl nakpacket nzn readnextseq nzn retransto datainfo di cf datainfo nzn nzn info nzn notimevalue di di fi cf nzn di 
nominee receiver fast repair mode rl cf isnominee fastrepairflag cf receiver rtt part protocol finds new rtt value sends method call objectid treated rs part protocol rl dt smoothedrtt rttvariance suppressto cf smoothedrtt rttvariance retransto plus suppressto dt notimevalue dt fi cf smoothedrtt minus rttvariance abs minus minus retransto minus abs minus minus suppressto dt notimevalue dt fi cf fi rl notimevalue dt suppressto cf suppressto dt notimevalue dt fi cf repair server protocol repair server cache stores data packets seen information repairs involved 
tries repair lost data packets way receiver 
addition sends children notifying repair requested 
original data packets stored cache subcast downstream 
repair data packets stored subcast downstream nak pending packet 
repair request child treated subcasting requested data packet cache starting repair procedure packet 
data type store limited number data packets message list 
specification unstated informal specification reasonable assumption data packets stored buffer reception order sequence number order sort op nat nznat usage buffer size bound op add msg op seqnoin nznat bool op seqnoin nznat bool eq add ml nzn nzn ml nzn nzn ceq add ml nzn ml nzn nzn eq nzn seqnoin ml nzn nzn seqnoin ml eq nzn seqnoin nil false eq nzn seqnoin datapacket nzn ml nzn nzn nzn seqnoin ml repair server stores information repairs terms form nakstate seqno nakcount seqno sequence number data packet nakcount upstream nak count roughly corresponds number upstream repair requests downstream nak count communication children true child waiting repair packet timer values upstream repair requests way receiver protocol suppressing repair request case parent sibling request giving time repair attempted 
union nak states juxtaposition sort nakstates op nakstates op nakstates nakstates nakstates assoc comm id nakstates op nakstate nznat nat nat bool deftime deftime nakstates repair server classes repair service part protocol declared follows class rsrepairserver bool spm packet read 
nat smoothedrtt machineint rttvariance machineint retransto time suppressto time deftime nakstates nakstates info repairs databuffer data packet cache subclass rsrepairserver repairserver class subclass rsrepairserver operations combined protocol take place spmpacket read 
rule sets attribute value true spmpacket seen consuming spmpacket treated rule vars ns ns nakstates var bb rl init spmpacket false cf spmpacket true cf expiration indicates packets sent sender repair server bypassed case protocol state destroyed rl rsrepairserver cf error righthand side rule cf repair server erased 
detect loss data packets 
repair undertaken repair server receive data packet value 
sequence numbers sequence number currently treated spmpacket error recovery performed lost packets nak state object nakstates buffer 
new nak state added function nakpacket sent children function 
furthermore received spmpacket forwarded children rl spmpacket randomngen seed rsrepairserver true children os suppressto nakstates ns cf randomngen seed ns repairserver nakstates ns multisend spmpacket os ns os cf ns returns gives number sequence numbers interval nak state ns op nakstates nat nat nat eq ns eq ns nzn nzn nzn ns fi ns nzn fi op nznat nakstates bool eq nzn nakstates false ceq nzn ns ns nzn ns nzn ns ns ns eq nzn nakstate nzn dt dt nzn nzn ns updates nak state ns new nak states sequence numbers ns 
leaves ns unchanged 
seed random number generator value suppressto op nakstates nat nat nat time nakstates eq ns ns eq ns nzn nzn ns nzn ns ns nakstate nzn true random plus notimevalue ns fi nzn random fi ns os sends children os sequence numbers interval nak state ns op nakstates nat nat oid configuration eq ns os eq ns nzn os nzn ns nzn os nzn ns multisend nakpacket nzn false os fi fi received data packet stored cache condition nzn seqnoin bb added databuffer cache repair server subcast children original packet condition means retransmission flag packet set nak pending sequence number 
addition repairs lost data packets initiated previous case handled functions crl datapacket nzn rsrepairserver databuffer bb cf rsrepairserver cf nzn seqnoin bb crl datapacket nzn randomngen seed rsrepairserver children os databuffer bb nakstates ns suppressto cf rsrepairserver max nzn databuffer add bb datapacket nzn nakstates nzn ns nzn ns nzn minus fi randomngen seed ns nzn minus ns nzn multisend datapacket nzn os fi ns nzn minus os cf nzn seqnoin bb op nakstates nznat bool checks nak state exists nak pending ceq ns nzn false nzn ns eq nakstate nzn dt dt ns nzn op nznat nakstates nakstates cancels timers sets nak pending false 
eq nzn nakstate nzn dt dt ns nakstate nzn false notimevalue notimevalue ns ceq nzn ns ns nzn ns nakpacket count received upstream repair server indicates repair number attempted upstream 
means nth repair attempt undertaken forwarded children nak count smaller nak state exist 
furthermore retransmission timer reset round 
nakpacket comes upstream repair server object sender packet value object repairserver attribute packet cache don worry repairs crl nakpacket nzn rsrepairserver repairserver databuffer bb cf rsrepairserver cf nzn seqnoin bb packet cache update forward higher nak count received crl nakpacket nzn rsrepairserver repairserver databuffer bb retransto nakstates nakstate nzn dt dt ns children os cf rsrepairserver nakstates nakstate nzn max fi notimevalue ns multisend nakpacket nzn false os fi cf nzn seqnoin bb packet cache nak state crl nakpacket nzn rsrepairserver repairserver databuffer bb retransto children os nakstates ns cf rsrepairserver nakstates nakstate nzn true notimevalue ns multisend nakpacket nzn false os cf nzn seqnoin bb nzn ns rules treat unicast child repair server object seen sender element current object children attribute 
essentially data packet exists cache subcast children 
received nak count greater object nak count start new repair received nak count greater downstream nak count children aware current repair request 
note nakpacket fast repair flag set possible upstream repair undertaken delay sender repair fastrepairflag set 
rules treat different cases depending requested data packet object cache nak state exists requested packet fast repair flag packet set depending nak count values nak exists true data buffered crl nakpacket nzn true rsrepairserver repairserver children os retransto databuffer bb nakstates ns cf rsrepairserver nakstates nakstate nzn true notimevalue ns multisend nakpacket nzn false os send nakpacket nzn true cf nzn seqnoin bb nzn ns nak exists data buffered false crl nakpacket nzn false randomngen seed rsrepairserver children os suppressto databuffer bb nakstates ns cf randomngen seed random rsrepairserver nakstates nakstate nzn true random plus notimevalue ns multisend nakpacket nzn false os cf nzn seqnoin bb nzn ns data buffer nak state exists crl nakpacket nzn rsrepairserver repairserver children os nakstates nakstate nzn dt dt ns retransto databuffer bb cf rsrepairserver nakstates nakstate nzn true notimevalue dt fi dt fi ns multisend nakpacket nzn false os send nakpacket nzn true fi cf rsrepairserver nakstates nakstate nzn dt dt ns multisend nakpacket nzn false os cf rsrepairserver cf fi fi nzn seqnoin bb message buffer nak state exist 
crl nakpacket nzn rsrepairserver children os databuffer ml datapacket nzn xx ml nzn nakstates ns cf rsrepairserver nakstates nakstate nzn false notimevalue notimevalue ns multisend datapacket nzn true os cf nzn ns sequence number exists data buffer nak state rl nakpacket nzn rsrepairserver children os databuffer ml datapacket nzn xx ml nzn nakstates nakstate nzn dt dt ns cf rsrepairserver nakstates nakstate nzn false dt dt ns multisend datapacket nzn true os cf rsrepairserver cf fi new repair undertaken suppression timer expires packet nak pending packet cached rl rsrepairserver databuffer bb nakstates nakstate nzn dt ns retransto repairserver cf nzn seqnoin bb rsrepairserver nakstates nakstate nzn notimevalue ns send nakpacket nzn false cf rsrepairserver nakstates nakstate nzn notimevalue dt ns cf fi similarly nak count increased suppression timer set initiate new repair short time nakpacket sent child retransmission timer expires packet needing repair rl randomngen seed rsrepairserver suppressto databuffer bb children os nakstates nakstate nzn dt ns cf nzn seqnoin bb randomngen seed random rsrepairserver nakstates nakstate nzn random plus notimevalue ns multisend nakpacket nzn false os cf randomngen rsrepairserver nakstates nakstate nzn dt notimevalue ns cf fi new rtt values treated case receivers rl dt rsrepairserver smoothedrtt rttvariance suppressto cf rsrepairserver smoothedrtt rttvariance retransto plus suppressto dt notimevalue dt fi cf rsrepairserver smoothedrtt minus rttvariance abs minus minus retransto minus abs minus minus suppressto dt notimevalue dt fi cf fi rl notimevalue dt rsrepairserver suppressto cf rsrepairserver suppressto dt notimevalue dt fi cf behavior time time acts rs objects 
increases clocks decreases timers elapse time function mte sure time progress stops timer expires 
functions delta mte extended accommodate multiple timers datainfo attribute receivers nakstates attribute repair servers eq mte dt senddatatimer dt default min dt dt eq delta clock dt senddatatimer dt clock plus dt default monus senddatatimer dt default monus eq mte datainfo di mte di op mte datainfo timeinf eq mte datainfo inf ceq mte di di min mte di mte di di di eq mte info nzn dt dt default min dt dt eq delta datainfo di datainfo delta di op delta datainfo time datainfo eq delta datainfo datainfo ceq delta di di delta di delta di di di eq delta info nzn dt dt info nzn dt default monus dt default monus eq mte dt nakstates ns default min dt mte ns op mte nakstates timeinf eq mte nakstates inf ceq mte ns ns min mte ns mte ns ns ns eq mte nakstate nzn dt dt default min dt dt eq delta dt nakstates ns dt default monus nakstates delta ns op delta nakstates time nakstates eq delta nakstates nakstates ceq delta ns ns delta ns delta ns ns ns eq delta nakstate nzn dt dt nakstate nzn dt default monus dt default monus application layer stand rs protocol combined protocol receive data blocks application layer protocol relay data packets order receiver applications 
define simplistic model sender receiver application level 
sender application object stores data blocks delays message list attribute sends data blocks ready delivery sender object protocol 
application level receiver object stores attribute concatenation data packets received associated receiver protocol receiver attribute tomod aer applications including aer rs class rl dly ml cf ml cf eq mte ml ml eq delta ml delta ml class receiver oid rl receiver mc cf receiver mc cat cf eq mte inf eq delta initial state topology links substituted 
brevity exposition sender application wants transmit data blocks labeled second sizes respectively tomod rs applications including aer applications 
op nat system eq dly dly second receiver receiver receiver receiver clock children notimevalue nil senddatatimer notimevalue repairserver nooid isnominee false fastrepairflag false readnextseq smoothedrtt rttvariance suppressto retransto databuffer datainfo false children repairserver nooid false notimevalue smoothedrtt rttvariance suppressto retransto databuffer nil nakstates children repairserver nooid false notimevalue smoothedrtt rttvariance suppressto retransto databuffer nil nakstates repairserver nooid isnominee false fastrepairflag false readnextseq smoothedrtt rttvariance suppressto retransto databuffer datainfo false repairserver nooid isnominee false fastrepairflag false readnextseq smoothedrtt rttvariance suppressto retransto databuffer datainfo false repairserver nooid isnominee false fastrepairflag false readnextseq smoothedrtt rttvariance suppressto retransto databuffer datainfo false random randomngen seed env env dly true dly dly dly dly dly dly 
executing example maude default execution strategy lead state receiver applications objects received data packets 
get result maude rew rewrites ms cpu ms real rewrites second rewrite rs applications result error clockedsystem error time error state reached inability repair data packet attempts case elapsed time value set 
connections break setting execution indicate protocol may deficient 
snapshot system rewrites gives state maude rew rewrites ms cpu ms real rewrites second rewrite rs applications result error clockedsystem repairserver isnominee false datainfo info notimevalue info notimevalue notimevalue info notimevalue notimevalue databuffer datapacket false true false datapacket false false true datapacket second true false false 
clock children senddatatimer notimevalue nil datapacket true false false datapacket false true false 
datapacket false false true datapacket second true false false nil repairserver isnominee false true datainfo databuffer configuration retransto suppressto rttvariance smoothedrtt readnextseq fastrepairflag false children repairserver databuffer datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false false true datapacket false true true nakstates 
nakstate false notimevalue notimevalue nakstate true notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue 
env env datapacket true false false cat datapacket false true false cat 
cat datapacket false false false cat datapacket second true false false receiver note choice rules apply may real time maude timed rewrite ordinary rewrite command 
just rewrite say time timed rewrite command execute system 
datapacket true false false cat datapacket false true false cat 
cat datapacket false true false receiver 
time receiver application received data packets receivers removed output exposition 
receiver application received packets wait th packet 
associated protocol node packet missing dangerously high nak count packet 
continue analyze repair packet happens 
note suppression timer packet resulting term rewritten time start repair maude 
time mode gm dti time le 
result repairserver datainfo info notimevalue 
databuffer datapacket false true false datapacket false false true datapacket second true false false readnextseq 
children repairserver databuffer datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false false true datapacket false true true retransto suppressto rttvariance smoothedrtt nakstates 
nakstate true notimevalue notimevalue 
time observe repair server data packet cache probably overwritten repair requests 
repair server nak status packet suppression retransmission timers turned essentially implying try repair packet 
probably seen cases packet request came packet created nak state timers turned 
analyze nak request handled focus objects resulting state link maude rew 

ce link 
time rewrites ms cpu ms real rewrites second 
result error clockedsystem datainfo info notimevalue 
readnextseq 
nakstates nakstate true notimevalue notimevalue 
ce link downmsgs dly nakpacket false 
send nakpacket false time object received nak request acknowledged packets sent seen sent repair request packet repair server set suppression retransmission timer repair undertake repair 
set retransmission timer case repair arrived start error recovery attempt time eventually leading th repair attempt 
anomalous behavior traced back informally original protocol follows nak received repair server child case entered case entered nakcount nak count data packet seq case control goes case fastrepairflag false action taken 
analyze informally cases set true received nak count greater stored nak count 
flag superfluous 
execution test configuration protocol nodes suggested mark test repair service protocol op nat system eq dly receiver clock children notimevalue nil senddatatimer notimevalue children repairserver nooid false notimevalue smoothedrtt rttvariance suppressto retransto databuffer nil nakstates repairserver nooid isnominee false fastrepairflag false readnextseq smoothedrtt rttvariance suppressto retransto databuffer datainfo false random randomngen seed env env dly true dly dly ab link bound downmsgs nil downsize upmsgs nil bc link bound downmsgs nil downsize upmsgs nil data packets sent sending rate new packet ms propagation delay ms link ensures packets lost link bound 
link faster lose packets 
execution gives result maude rew rewrites ms cpu ms real rewrites second rewrite rs applications result error clockedsystem children datapacket true false false 
datapacket false false true 
children repairserver databuffer datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false false true datapacket false true true nakstates nakstate false notimevalue notimevalue 
nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue 
repairserver isnominee true datainfo info notimevalue notimevalue info notimevalue notimevalue 
info notimevalue notimevalue databuffer datapacket false true true datapacket false true false 
datapacket false false true readnextseq fastrepairflag true 
datapacket true false false cat 
cat datapacket false true true cat datapacket false true true receiver 
time execution reveals serious problem packet delivered receiver application missing receiver repair server 
furthermore repair state packet alarming holes repaired received spm packet data packet indicates packets lost 
stepwise analysis similar previous case undertaken find problem 
give details describe result analysis leading undoubtedly strange behavior sends data packets data packets enters link full 
continues send packets packets lost packet link lost 
reads packet discovers holes sends nak packets nak count 
time packet messages sent time 
link take packets packets lost data packet 
back link packet lost arrives safely discovers hole sends nak data packet 
reads stores nak packet nak count reads packet 
golden opportunity discover hole packet discovered repair server packet 
discovering hole goes backwards case finds nak state nak count exists packet stops search holes 
repair attempted packet 
combined protocol full protocol combines parts protocol transitions modeling treatment received packet sending data packets transitions combine treatment cases subprotocols 
example data packet received receiver object receiver update window calculate loss probability estimate nom protocol part rate control part respond nominee repair service part check lost data packets initiate repair 
similarly sending original data packet division tasks performed repair service protocol combined rate control algorithm certify sending allowed 
mentioned earlier class subclass inherits union attributes classes rewrite rules involving objects classes 
transitions shared different parts protocol put manually single transitions 
exception discovery new rtt value object calls method sending message treated part protocol 
reason combining rules give unnecessarily complicated rules 
approach calling methods object treated parts protocol applied cases say datapacket treated say repair service part protocol reading packet calls methods 
way protocol defined entirely subparts need combined rules 
possible exception combining sending data packet testing rate control allows sending packet solved exchange messages 
solution explicit combined rules chosen think clearer closer original specification 
addition events take place simultaneously 
method call approach actions may performed treatment datapacket associated 
may may affect behavior protocol anyway avoided various ways 
think crucial updates take place simultaneously associated discovery new rtt values 
send data packets 
rate control protocol specify data packets sent new data packet sent current time 
various choices packets sent 
sent urgently sense new packets sent early possible 
sending attempted certain times 
test sending application instantaneous rule application application instantaneous rule change sending condition 
long protocol wait sending possible desired time 
interval 
time sending possible 
allowing sending happen time sending condition true avoids overspecification part requires nondeterministic tick rule 
lead packets sent time possibility packet higher sequence number arrive just lower sequence number possibly leading unnecessary repair requests 
options may protocol 
urgent sending modeled letting time advance sending performed adding test tick rule making tick rule lazy 
note test condition change result instantaneous actions tick rule may remain deterministic case 
modifications approaches requiring consecutive take place time apart modeled straightforward way 
current version multicast new data packet attempted intervals data block 
multicast performed sending attempted ms 
classes combined protocol follows tomod combined protocol including aer rtt including nca nom including nca rc including aer rs subclass subclass subclass subclass subclass subclass subclass subclass rsrepairserver subclass subclass subclass subclass vars mss wls mbc nat var time var db databuffer var vars ws var frf bool var di datainfo var window var ns nakstates vars dn dn original data packet sent rate control algorithm allows 
holds 
sending attempted senddatatimer expires sending condition may change time due instantaneous actions 
sending possible attempted attempt ms senddatatimer reset sending interval data block rl children os clock data nzn nzn db nzn senddatatimer mss wls csmnominee dq winsize ws frf mbc dt dq cf nzn mss plus mss wls ws frf mbc nzn nzn nil data nzn nzn fi db datapacket nzn nzn nzn nzn nzn false nzn senddatatimer nzn nzn db fi mss wls mss notimevalue fi mbc wls mss dq dq fi multisend datapacket nzn nzn nzn nzn nzn false os cf senddatatimer cf fi sender rc part protocol may need reset value nominee set nooid result reading nom protocol rl dn dt dq clock csmnominee dq csmlpe dn csmrtt dt dt cf dn dt dq dq dn dt csmnominee dq csmlpe dn csmrtt dt dq dq dt fi dq nooid dq dq fi dq dq dq nooid true dq fi dq dq dq nooid false dq fi cf cf fi repair server receiver objects initialized receive rl spmpacket randomngen seed false cf spmpacket randomngen seed random true csmtimer getrttresendtimer random cf rl init spmpacket randomngen seed false cf spmpacket randomngen seed true getrttresendtimer random csmtimer cf reception new data packet receiver combines reception error recovery treatment case rs protocol case nom protocol updates window determine loss probability estimate case rc protocol sends receiver nominee receiver 
lowest outstanding packet number attribute readnextseq crl datapacket nzn randomngen seed isnominee fastrepairflag frf repairserver readnextseq nzn suppressto databuffer mc datainfo di cf randomngen seed frf nzn minus monus max nzn minus di mc fi readnextseq max nzn datapacket nzn mc nzn databuffer mc datapacket nzn nzn datainfo remove di nzn frf max nzn mc di nzn minus mc datapacket nzn nzn add nzn datapacket nzn mc nzn send max nzn datapacket nzn mc nzn fi cf nzn nzn nzn seqnoin mc rule applies data packet seen 
receiver objects nom rc protocols affected reception data packets sequence numbers seen case handled rule rs protocol 
behavior time combined objects straightforward eq mte dt dt dt senddatatimer dt default min dt dt dt dt eq delta clock dt dt senddatatimer dt dt clock plus dt default monus dt default monus senddatatimer dt default monus dt default monus eq mte getrttresendtimer dt csmtimer dt dt nakstates ns default min dt dt dt mte ns eq delta clock getrttresendtimer dt csmtimer dt dt nakstates ns clock plus getrttresendtimer dt default monus csmtimer dt default monus dt default monus nakstates delta ns eq mte getrttresendtimer dt csmtimer dt datainfo di default min dt dt mte di eq delta clock getrttresendtimer dt csmtimer dt datainfo di clock plus getrttresendtimer dt default monus csmtimer dt default monus datainfo delta di expect combined protocol desired light problems execution repair service part protocol possible rate control part excludes scenarios lead undesired behaviors particular second problem 
module gives set initial states topology state repair service protocol tomod combined protocol including combined protocol including aer applications 
op state nat system eq state dly receiver clock sourcertt children maxdownrtt notimevalue maxrecentdownrtt notimevalue csmlpe csmrtt csmnominee nooid nooid winsize fixed smoothedrtt rttvariance fixed false notimevalue notimevalue nil senddatatimer notimevalue clock sourcertt notimevalue children maxdownrtt notimevalue maxrecentdownrtt repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue csmlpe csmrtt nooid csmtimer notimevalue false notimevalue smoothedrtt rttvariance suppressto retransto databuffer nil nakstates clock sourcertt notimevalue repairserver nooid resendinterval maxuprtt notimevalue myuprtt notimevalue getrttresendtimer notimevalue isnominee false csmtimer notimevalue fastrepairflag false readnextseq smoothedrtt rttvariance suppressto retransto databuffer datainfo false random randomngen seed ab link bound downmsgs nil downsize upmsgs nil bc link bound downmsgs nil downsize upmsgs nil quick execution state gives result maude rew state rewrites ms cpu ms real rewrites second rewrite combined protocol state result error clockedsystem children csmnominee sourcertt maxdownrtt csmrtt csmlpe notimevalue true winsize nil datapacket true false false datapacket false true false datapacket false true false datapacket false true false datapacket false true false datapacket false true false datapacket false true false 
datapacket false true false datapacket false true false datapacket false true false datapacket false false false 
nil children repairserver sourcertt maxrecentdownrtt maxuprtt csmrtt csmlpe databuffer datapacket false true false datapacket false true false datapacket false true false datapacket false false false datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true datapacket false true true nakstates nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue nakstate false notimevalue notimevalue 
repairserver isnominee true sourcertt maxuprtt resendinterval csmtimer window datainfo databuffer configuration readnextseq fastrepairflag true 
datapacket true false false cat datapacket false true false cat 
cat datapacket false true false cat datapacket false false false receiver 
time gone execution data packets delivered order receiver application 
executing combined protocol way analyzing rate control protocol attempt repair lost packets 
current combined protocol executes expected significant flaw omission earlier version protocol execution 
data packet sent data packet sent nominee 
receiver acknowledge data packet sending analysis rate control protocol showed second packet sent acknowledged 
addressed problem sending data packet nominee 
troubling scenarios combined protocol related fact nominee receiver sends 
showed scenario analysis nominee selection protocol demonstrated moments receiver knows nominee 
data packet received times may acknowledged 
related scenario data packet received receiver rcv rcv nominee place receiver rcv due new rtt values received rcv change 
acknowledge packet packets transmitted 
similar unpleasant behaviors various attempts addressing problem suggesting acknowledgment knowing nominee somewhat problematic 
methodology experience discuss section methodology experience gained real time maude specify analyze aer nca real time network protocol suite 
outline formal methodology supported real time maude specify analyze protocol discuss specification formalism 
discuss new version informal specification developed influenced specification analysis effort 
formal methodology mentioned mes fact real time maude specifications executable allows range increasingly stronger formal methods system specification subjected 
costly methods leading better understanding important improvements corrections original specification meaningful worthwhile invest effort validation methods 
indicate real time maude support increasingly stronger methods formal specification execution model checking analysis narrowing analysis formal proof correctness parts specification 
formal specification formalization process results formal model essential implicit knowledge explicit spells fuzzy requirements precise way 
example assumptions stated informally described protocol communication model protocol depends crucially aspects fact packets sent link arrive order 
furthermore formalizing communication aspects packet sizes account led new questions needed clarified rtt protocol compute round trip times small large packets 
bound link depend size packets traveling link 
packets ready delivery released link new message entered link lost due full link 
examples hidden assumptions involved treatment default values cases new rtt value notimevalue unresolved question sender attempt send new data packet data packets delivered receiver application order 
packet received repair server store repair information unlimited number data packets 
execution specification immediate execution real time maude default interpreter gives feel specification find errors specification give validation protocol additional cost 
real time maude timed untimed default rewrite strategy immediately execute specification 
prototyping give feel system prior deeper analysis 
example rate control protocol able get helpful indication appropriate sending rates prior analyzing protocol 
furthermore result executing repair service protocol immediately drew attention large set nak states repair server objects may go protocol intention requiring little memory processing time repair servers possible 
validated rtt nom protocols default timed command just executing state checking resulting state satisfied expectations 
default executions repair service protocol returned undesired states invalidate protocol 
repeated real time maude timed untimed commands easy find undesired behaviors protocol able easily point corresponding scenarios original informal specification 
quickly errors including earlier versions protocol executing specifications mentioned nominee receiver data packets sent 
data packet sent receiver acknowledge data packet sending 
connection mentioned potential problems related acknowledgment data packets nominee know nominee 
execution led state new rtt value notimevalue execution protocol proceed cases handled original cases 
execution stopped negative value 
problem traced erroneous statement ccm packet timestamp currenttime ms original case immediately corrected 
model checking analysis distributed nondeterministic system may exhibit behaviors captured default execution system 
find errors revealed default executions increase confidence correctness specification costly verification effort undertaken specification subjected model checking analysis considers behaviors system initial state level condition 
real time maude search strategies user defined strategies built top real time maude strategy library model check specification 
defined search functions exploratory analysis rtt nom protocols see sections 
strategies extended strategy library meta level defined easily 
applied search strategies initial states rtt nom protocols got expected results increasing confidence correctness specification sub protocols 
model checking strategy potential error aware possibility problem analysis difficult find just executing specification default interpreter strategies 
currently analyzing output default executions rate control protocol reasonable state desired properties analysis protocol 
new specification repair service arrived moment need analyze repair service combined protocol default execution point undesired behaviors protocol 
narrowing analysis symbolic expressions variables analyze system behavior just single initial state possibly infinite set states described symbolic expression 
specification subjected form symbolic simulation 
formal proof highly critical properties possible carry formal proof correctness 
initial model specification provides precise model protocol subjected formal proof 
example initial model regarded kripke structure timed temporal logics state properties 
try formally prove parts specifications correct respect properties done 
specification formalism rewriting logic formalism fairly simple intuitive gives operational specification protocol appropriate level abstraction 
formalism involved real time rewriting logic suited specifying distributed systems local concurrent transitions specified timed rewrite rules 
formalism allows specification static dynamic aspects essentially formalism equations rewrite rules introduce language constructions expressing concurrency nondeterminism 
contrast protocol specification languages lotos iso bb sdl see bh fo static reactive real time aspects system described different formalisms 
furthermore intuitive object oriented style specification supported real time maude allowed specify separate subprotocols combined protocol maximal reuse common attributes common transitions 
simplicity formalism emphasized fruitful discussions real time maude specification colleagues previous experience term rewriting 
rewriting logic specification style allows away aspects concern essential features protocol 
example away irrelevant communication aspects routers direct packets repair servers intercept packets sent located routers 
specification operational nature describes protocol works abstracts away unnecessary details avoids protocol 
operational specification necessary describe protocols emphasis operates properties supposed satisfy packets eventually received receivers 
operational specification complemented property oriented specification defining desired properties protocol satisfy 
example criteria stating assumptions network protocol required deliver packets 
delivery guaranteed circumstances links certain bandwidth repair servers caches small 
operational specification verified properties stated requirement specification 
initial model rewrite specification durations associated arrows example regarded kripke structure real time temporal logic requirements stated 
investigating versions explicit clock temporal logics suitable specify properties real time rewrite theories 
details appear 
experience benefits gained real time maude real time network protocol specification analysis think case study shown real time maude suitable formalism adequate tool support specify natural way operational aspects sophisticated real time communication protocols 
experience gained real time maude tool includes timed rewrite command quite useful absence nondeterministic tick rules allowed relate execution simulated elapsed time include lazy tick rule case sending data packets performed urgently 
command may cases little slow efficiency purposes may want optimized timed rewrite command apply know time increase deterministic 
search commands real time maude sufficient express properties wanted analyze commands executed slowly larger states prompted need writing optimized application specific strategies 
easy satisfying solution lies developing optimized version strategy library substantially decrease need application specific strategies 
useful search strategies defined easily extensions timed meta level module 
useful built random function default interpreter time variable introduced righthand side rule 
tick rules cases timer arbitrary start value 
earlier specifications showed executions object oriented specifications tokens tick rules form described section efficiently executed special strategy instantiates variable sort tokens provided increase performance 
mentioned regard theory global instantaneous rules implementation corresponding system tokens 
current straightforward specification positive rational numbers appendix inefficient requiring rewrites simple calcu lations 
addressed developing high performance implementation rational numbers maude 
informal specification aer nca protocol suite changed substantially version version analysis effort described chapter undertaken 
problems pointed addresses data packets nominee receiver data packet takes additional parameter nominee receiver responsible acknowledging data packet 
repair service part changed significantly avoid flaws error recovery process reported 
repair servers longer longer store unlimited amount nak information 
information state variables available essential knowledge state explicit 
chapter thesis investigated theoretical methodological levels application rewriting logic model analyze real time hybrid systems 
theoretical level shown known models real time hybrid systems naturally expressed real time rewrite theories theories mapped ordinary rewriting logic theories adding clock way preserves interesting properties 
result designed language tool called real time maude formal specification analysis real time rewrite theories 
functor rwth mapping real time rewrite theories ordinary rewrite theories represented specification real time maude function transforms timed pre module untimed pre module 
identified certain commonly occurring characteristics typical real time systems need eager lazy rules tick rules nondeterministic time increase taken account design specification language tool timed rewrite interpreter model checking strategies extensible strategy library suit specification execution formal analysis typical real time systems 
tool built extension full maude allow real time maude specifications full maude support structured object oriented specification 
reuse full maude parsing module handling facilities possible tool performs transformation timed module untimed module stage 
maude reflective capabilities support defining specification execution tools maude sophisticated parsing facilities heavily design tool specification model checking strategies 
tested real time maude language tool practice formal methodology outlined mes specify analyze sophisticated new suite real time active network communication protocols 
protocol components specified object oriented timed modules subclass inheritance allowed specify execute different protocol components stand protocols combined protocol maximal reuse common rules attributes 
specification process protocol suite required explicit essential implicit assumptions clarify fuzzy arguments informal specification 
executions protocol components real time maude default interpreter revealed errors led new versions informal protocol errors corrected 
protocol components subjected formal analysis model checking involving exploration rewrite paths initial state 
turned built model checking strategies general inefficient defined specialized strategies model check protocols 
ease new model checking strategies defined extending tool strategy library encouraging 
model checking technique find errors rtt protocol error property concerned nom protocol 
experience real time maude specification analysis real time hybrid systems quite encouraging thesis just step application methods opens interesting research directions investigate 
tool polished improved adding features interactive simulation flexible default timed rewrite strategies 
search functions efficient specialized frequently occurring subset timed modules 
aer nca case study showed model checking performed reasonable amount time slightly specialized 
expect built search facilities upcoming version maude model checking efficient 
investigated ways mentioned real time rewrite theories help bridge gap property oriented requirement specification actual implementation 
spectrum investigate sublanguages real time temporal logic suitable describe properties real time rewrite theories develop implement proof techniques proving specification correct maude reflection interoperability features integrate existing verification tools tools development inductive theorem provers 
spectrum develop methods pass correct real time maude specifications correct actual implementations generating code specifications 
case studies needed 
till specified real time hybrid systems railroad crossing hl scheduling problem network protocol thesis 
application domains real time maude applied include embedded systems control systems robotics combined code generation techniques lead maude programmed robots 
bibliography aal van der aalst 
interval timed coloured petri nets analysis 
ajmone marsan editor application theory petri nets volume lecture notes computer science pages 
springer 
ach alur courcoubetis halbwachs henzinger 
ho nicollin olivero sifakis yovine 
algorithmic analysis hybrid systems 
theoretical computer science 
ad alur dill 
theory timed automata 
theoretical computer science 
aer active error recovery aer aer nca software release version 
www 
com panama aer may 
ah alur henzinger 
logics models real time survey 
de bakker huizing 
de roever rozenberg editors real time theory practice volume lecture notes computer science pages 
springer 
bb brinksma 
iso specification language lotos 
computer networks isdn systems 
bee beeson 
foundations constructive mathematics 
springer 
bh 
ccitt specification description language sdl 
computer networks isdn systems 
bkk borovansk kirchner kirchner 
moreau vittek 
elan logical framework computational systems 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science 
elsevier 
www elsevier nl locate entcs volume html 
bj rner manna sipma uribe 
deductive verification real time systems step 
rus editors proc 
arts volume lecture notes computer science pages 
springer 
bst sifakis tripakis 
modeling urgency timed systems 

de roever langmaack pnueli editors proc 
compositionality volume lecture notes computer science pages 
springer 
bt bergstra tucker 
algebraic specification computable semicomputable data types 
theoretical computer science 
bw barr wells 
category theory computing science 
centre de recherches math matiques third edition 
cde clavel duran eker lincoln mart oliet meseguer 
metalevel computation maude 
kirchner kirchner editors proc 
nd intl 
workshop rewriting logic applications volume electronic notes theoretical computer science 
elsevier 
www elsevier nl locate entcs volume html 
cde clavel duran eker lincoln mart oliet meseguer quesada 
maude specification programming rewriting logic 
computer science laboratory sri international menlo park 
maude csl sri com 
cde clavel dur eker meseguer 
stehr 
maude formal 
wing woodcock davies editors proc 
fm volume lecture notes computer science pages 
springer 
cde clavel eker patrick lincoln mart oliet meseguer quesada 
maude tutorial 
tutorial etaps 
cla clavel 
reflection general logics rewriting logic applications maude language 
phd thesis university 
cm clavel meseguer 
axiomatizing reflective logics languages 
kiczales editor proc 
reflection pages 
jerry cs uiuc edu reflection 
cm clavel meseguer 
reflection strategies rewriting logic 
meseguer editor proc 
st intl 
workshop rewriting logic applications volume electronic notes theoretical computer science 
elsevier 
www 
elsevier nl locate entcs volume html 
dj dershowitz 
jouannaud 
rewrite systems 
van leeuwen editor handbook theoretical computer science volume chapter 
elsevier amsterdam 
dm dur meseguer 
extensible module algebra maude 
kirchner kirchner editors proc 
nd intl 
workshop rewriting logic applications volume electronic notes theoretical computer science 
elsevier 
www elsevier nl locate entcs volume html 
dm dur meseguer 
maude specification full maude 
manuscript may 
maude csl sri com papers full maude 
dur dur reflective module algebra applications maude language 
phd thesis university 
fd futatsugi diaconescu 
cafeobj report 
amast series world scientific 
fo olsen 
sdl 
computer networks isdn systems 
gm goguen meseguer 
order sorted algebra equational deduction multiple inheritance overloading exceptions partial operations 
theoretical computer science 
han 
analysis place transition nets timed arcs application batch process control 
ajmone marsan editor application theory petri nets volume lecture notes computer science pages 
springer 
halbwachs caspi raymond pilaud 
synchronous dataflow programming language lustre 
proceedings ieee september 
henzinger 
ho wong toi 
hytech model checker hybrid systems 
software tools technology transfer 
see hytech home page www cad eecs berkeley edu hytech 
hl heitmeyer lynch 
generalized railroad crossing case study formal verification real time systems 
proc ieee real time system symposium san juan pages 
ieee computer society press 
iso information systems processing open systems interconnection lotos 
tech 
rep international standards organization dis 
kbk bhattacharyya kurose towsley 
scalable fair reliable multicast active services 
technical report tr university massachusetts amherst 
knu knuth 
art computer programming algorithms volume 
addison wesley second edition edition 
kw wirsing 
timed rewriting logic application objectbased specification 
science computer programming 
larsen pettersson yi 
uppaal nutshell 
software tools technology transfer october 
see uppaal home page www uppaal com 
lyn nancy lynch 
distributed algorithms 
morgan kaufmann 
mes meseguer 
general logics 

ebbinghaus editor logic colloquium pages 
north holland 
mes meseguer 
conditional rewriting logic unified model concurrency 
theoretical computer science 
mes meseguer 
logical theory concurrent objects realization maude language 
agha wegner yonezawa editors research directions concurrent object oriented programming pages 
mit press 
mes meseguer 
rewriting logic semantic framework concurrency progress report 
montanari sassone editors proc 
concur volume lecture notes computer science pages 
springer 
mes meseguer 
membership algebra logical framework equational specification 
parisi presicce editor proc 
wadt volume lecture notes computer science pages 
springer 
mes meseguer 
research directions rewriting logic 
berger schwichtenberg editors computational logic nato advanced study institute marktoberdorf germany july august nato asi series computer systems sciences pages 
springer 
mes meseguer 
rewriting logic maude wide spectrum semantic framework object distributed systems 
smith talcott editors formal methods open object distributed systems pages 
kluwer 
mes meseguer 
rewriting logic maude concepts applications 
bachmair editor rewriting techniques applications volume lecture notes computer science 
mm meseguer montanari 
petri nets monoids 
information computation 
meseguer 
stehr 
rewriting logic unifying framework petri nets 
submitted publication 
mp manna pnueli 
models reactivity 
acta informatica 
mp manna pnueli 
clocked transition systems 
logic software engineering pages 
available stanford university csd technical report stan cs tr 
mpt trubian 
timed high level nets 
journal real time systems 
ms manna sipma 
deductive verification hybrid systems step 
henzinger sastry editors hybrid systems computation control volume lecture notes computer science pages 
springer 
kw wirsing 
object oriented algebraic control specification 

abrial rger langmaack editors formal methods industrial application specifying programming steam boiler control volume lecture notes computer science pages 
springer 
lv 
specifying analyzing aer nca active networks protocols real time maude 
www csl sri com peter aer aer html 
meseguer 
specifying real time systems rewriting logic 
meseguer editor proc 
intl 
workshop rewriting logic applications volume electronic notes theoretical computer science 
elsevier 
www elsevier nl locate entcs volume html 
meseguer 
real time maude tool simulating analyzing real time hybrid systems 
third international workshop rewriting logic applications 
appear 
meseguer 
specification real time hybrid systems rewriting logic 
appear theoretical computer science 
available maude csl sri com papers september 
rab rabin 
computable algebra general theory theory computable fields 
transactions american mathematical society 
rei reisig 
petri nets volume eatcs monographs theoretical computer science 
springer 
sk steggles 
timed rewriting logic semantics sdl case study alternating bit protocol 
kirchner kirchner editors proc 
nd international workshop rewriting logic applications volume electronic notes theoretical computer science 
elsevier 
www 
elsevier nl locate entcs volume html 
sta stanford temporal prover 
www step stanford edu 
vir 
rewriting effective model concurrency 
theodoridis editors proc 
parle volume lecture notes computer science pages 
springer 
wir wirsing 
algebraic specification 
van leeuwen editor handbook theoretical computer science volume chapter 
elsevier amsterdam 
yovine 
kronos verification tool real time systems 
software tools technology transfer 
see kronos home page www verimag 
imag fr kronos 
appendix time domains appendix gives specifications time domains real time specifications 
efficiency purposes built top machine integers 
furthermore specify useful functions required theory time 
time domains extended adding infinity value inf appropriate containing inf 
machine natural numbers specification specifies machine natural numbers sort nonzero naturals specification aer nca protocol 
fmod naturals including machine int sorts nat nznat subsort nat machineint subsort nznat nat subsort nznat op abs machineint nat op minus machineint machineint machineint prec gather op monus nat nat nat prec gather vars machineint var vars nat mb nat cmb nznat eq minus eq abs fi eq monus minus fi endfm positive machine rationals appendix gives specification positive rationals specification scheduling section 
efficiency purposes built top machine integers 
fmod positive rationals including naturals denotes nonnegative rationals 
sorts subsort subsort nznat subsort nat op plus prec gather assoc comm op monus prec gather op times prec gather assoc comm div constructor rationals op div op div op gcd nznat op lt bool prec vars machineint vars nznat vars pr pr vars basic definitions eq lt eq plus eq times reduce nested div eq div pr div div pr times eq div div pr div pr times simplify result ceq div div gcd gcd gcd condition necessary termination remove div possible eq div pr pr eq div eq div pr plus pr div pr plus pr times eq pr times div pr div pr times pr eq pr monus div pr div pr times monus pr eq div pr monus pr div pr monus pr times comparators eq lt div times lt eq div lt lt times eq div lt div times lt times eq gcd endfm gcd monus gcd monus fi fi fixed point numbers fixed point number represents real number base choice base done user need application 
chosen keep sorts machineint different connected components poset sorts 
conversions fixed points numbers integers explicit conversion functions declared syntax int fixed 
base carefully chosen avoid overflow particular multiplication operation 
fmod fixed point reals including machine int sorts fixedpointnumber subsort fixedpointnumber sorts subsort subsort subsort fixedpointnumber vars machineint var nz vars fixedpointnumber op base eq base constructor op machineint fixedpointnumber op takes number fixed point base ial form op fixed machineint fixedpointnumber prec eq fixed base gives back integer part fixed point number 
op int fixedpointnumber machineint prec eq int base gives accurate rounded value op fixedpointnumber machineint eq base base base base fi usual operations op plus fixedpointnumber fixedpointnumber fixedpointnumber prec gather assoc comm op minus fixedpointnumber fixedpointnumber fixedpointnumber prec gather op monus prec gather op times fixedpointnumber fixedpointnumber fixedpointnumber prec gather assoc comm op div fixedpointnumber fixedpointnumber prec gather op lt fixedpointnumber fixedpointnumber bool prec op le fixedpointnumber fixedpointnumber bool prec op gt fixedpointnumber fixedpointnumber bool prec op ge fixedpointnumber fixedpointnumber bool prec op min fixedpointnumber fixedpointnumber fixedpointnumber assoc comm op max fixedpointnumber fixedpointnumber fixedpointnumber assoc comm useful operators op floor fixedpointnumber fixedpointnumber op abs fixedpointnumber fixedpointnumber op fixedpointnumber bool op fixedpointnumber fixedpointnumber mb cmb eq plus eq minus eq monus fi eq times base eq div nz base nz eq lt eq le eq gt eq ge ceq min le ceq max ge eq floor base base base base base fi eq abs le minus fi eq base base base base eq base base base base base base fi endfm fmod fixed point reals inf including fixed point reals sort subsort fixedpointnumber op inf usual operators extended inf op plus prec gather assoc comm op minus fixedpointnumber prec gather op monus fixedpointnumber prec gather op lt bool prec op le bool prec op gt bool prec op ge bool prec op min assoc comm op max assoc comm vars fi fi var fixedpointnumber eq inf plus fi inf eq inf minus inf eq inf monus inf eq lt inf true eq inf lt fi false eq fi le inf true eq inf le false eq fi gt fi fi lt fi eq fi ge fi fi le fi eq max inf fi fi eq min inf fi fi endfm appendix original specification aer nca protocol appendix presents specification aer nca protocol basis real time maude specification protocol 
addition specification communicated mark various issues protocol arrive real time maude specification earlier 
specification written entirely dr stephen mark diane reading mass dr don towsley dr jim kurose bhattacharyya university massachusetts amherst mass test version probably intended finished product 
document kind specifications basis developing formal specification 
specification useful allow comparison different specification notations methods protocol specifications 
aer rs protocol aer repair service cases test version section sender protocol state information sequence number original data packet sent 
instantiation protocol case begins sender protocol instantiated upper layers 
protocol data structures initialized endpoints sockets opened transmission reception packets 
state information initialized follows number source path message spm packets formed sent multicast group address obtained entity instantiates protocol 
spm packet format described appendix spm packet contains ip address sender multicast group address port number current highest data packet sequence number transmitted data packets equal 
highest data packet sequence number indicates data packets transmitted sender 
spm timer started sending spm packets 
duration spm timer set constant value seconds 
case ends protocol taken wait state waiting events described cases 
spm timer service routine case begins spm timer expires 
spm packet transmitted destination multicast address 
spm packet contains current highest data packet sequence number sent equal minus 
spm timer reset 
case ends spm timer reset 
sending data case begins data variable length data block received upper layer 
data placed data packets 
data packet segment flag set data packets segmentation flag set 
data packet retransmission flag cleared assigned sequence number incremented data packet 
data packets buffered retransmission buffer 
current sender nak count maximum value nak count seen nak packets far data packet initialized 
data packets sent multicast group testing original data packet sent case rate control algorithm allows 
timestamp data packet filled current time milliseconds just data packet sent 
data packet format described appendix case ends data packet transmission completed 
processing received nak packet case begins nak packet received lower layer 
nak packet contains sequence number data packet retransmission requested 
contains nak count data packet 
nak packet format shown appendix nak packet nak count greater current sender nak count data packet retransmission buffer current sender nak count data packet set nak packet nak count requested data packet fetched retransmission buffer data packet sent multicast group address 
nak packet ignored retransmission sent 
case ends repair data packet sent nak packet ignored 
processing case begins protocol request received upper layer 
resources allocated protocol layer freed 
case ends resources freed 
section receiver protocol state information fastrepairflag true repair procedure delayed 
false nak suppression 
repairserver address repair server receiver 
readnextseq sequence number data packet delivered application 
smoothedrtt smoothed receiver sender rtt estimate milliseconds 
rttvariance mean deviation receiver sender rtt estimate milliseconds 
retransto current nak retransmission timer duration milliseconds 
suppressto current nak suppression timer duration milliseconds adjusted uniform random variate 
instantiation protocol case begins receiver protocol instantiated upper layers 
protocol data structures initialized endpoints sockets opened transmission reception packets 
followed multicast join operation joining multicast group data nak packets expected 
multicast address port numbers received entity instantiates protocol state information initialized follows fastrepairflag false repairserver readnextseq initial data packet sequence number smoothedrtt rttvariance retransto smoothedrtt rttvariance suppressto case ends protocol taken wait state waits receive data nak spm packets waits expiration timers described 
processing received spm packet case begins spm packet received 
processing performed rs spm packet repair server address highest data packet sequence number repairserver rs call case case ends repairserver updated case returns 
processing received data packet case begins data packet received 
processing performed seq received data packet sequence number cancel nak retransmission timer data packet seq cancel nak suppression timer data packet seq data packet seq currently buffered seq readnextseq buffer received data packet call case discard received data packet case ends case returns received data packet discarded 
detecting gaps data packet sequence numbers case begins gaps received data packet sequence numbers detected handled 
processing performed seq sequence number passed case seq readnextseq data packet currently buffered nak count data packet break loop nak count data packet call case case ends processing complete 
nak suppression timer service routine case begins nak suppression timer missing data packet expires 
processing performed seq sequence number missing data packet data packet seq currently buffered seq readnextseq case nak count data packet seq error connection broken continue unicast nak packet data packet seq receiver nak count fastrepairflag repairserver start nak retransmission timer data packet seq duration retransto case ends timer ignored unrecoverable error occurs nak retransmission timer data packet started 
nak retransmission timer service routine case begins nak retransmission timer missing data packet expires 
processing performed seq sequence number missing data packet data packet seq currently buffered seq readnextseq case nak count data packet seq incremented call case case ends timer ignored case returns 
processing received nak packet case begins nak packet received 
processing performed seq nakcount nak packet sequence number nak count data packet seq currently buffered seq readnextseq case nakcount nak count data packet seq nak count data packet seq nakcount cancel nak retransmission timer data packet seq cancel nak suppression timer data packet seq start nak retransmission timer data packet seq duration retransto case ends nak packet ignored nak retransmission timer started 
processing buffered data packet case begins received data packet buffered 
processing performed seq data packet sequence number call case seq application asynchronous receive mode check data packets deliver application update readnextseq note delivering data packets application reassembly process performed readnextseq segment segmentation flags data packet headers 
case ends case returns readnextseq updated 
start suppression interval case begins nak suppression interval started missing data packet sequence number seq 
processing performed fastrepairflag false start nak suppression timer data packet seq duration random variate uniformly distributed upper limit times suppressto call case case ends nak suppression timer started case returns 
enable fast repair case begins fast repair option enabled 
fastrepairflag set true 
case ends fastrepairflag set true 
disable fast repair case begins fast repair option disabled 
fastrepairflag set false 
case ends fastrepairflag set false 
processing case begins protocol request received upper layer 
resources allocated protocol layer freed 
case ends resources freed 
updating round trip time estimates case begins new rtt estimate available 
processing performed new sender rtt estimate milliseconds maxuprtt new maximum peer group rtt estimate milliseconds 
maximum peer group rtt maximum rtt receiver repair server receivers repair servers serviced smoothedrtt smoothedrtt rttvariance error smoothedrtt smoothedrtt smoothedrtt error rttvariance rttvariance abs error rttvariance retransto smoothedrtt rttvariance suppressto maxuprtt case ends suppressto updated 
processing case begins protocol request received upper layer 
resources allocated protocol layer freed 
case ends resources freed 
section repair server protocol state information repairserver address repair server repair server 
maximum data packet sequence number received 
smoothedrtt smoothed repair server sender rtt estimate milliseconds 
rttvariance mean deviation repair server sender rtt estimate milliseconds 
retransto current nak retransmission timer duration milliseconds 
suppressto current nak suppression timer duration milliseconds adjusted uniform random variate 
instantiation protocol case begins active node receives spm packet 
active node searches repair server object source address multicast group finding creates new repair server object stream 
source address multicast group extracted spm packet stored repair server 
repair server object added active node cache source address multicast group 
state information initialized follows repairserver smoothedrtt rttvariance retransto smoothedrtt rttvariance suppressto case called spm packet processing 
case ends case returns 
spm wait timer service routine case begins spm wait timer expires 
event indicates packets sent sender anymore multicast group routes changed 
timers repair server canceled buffer resources repair server freed repair server object removed active node cache 
case ends protocol state destroyed 
processing received spm packet wait state case begins spm packet received wait state 
spm packet processed case forwarded multicast tree case 
processing performed rs spm packet repair server address highest data packet sequence number cancel current spm wait timer start spm wait timer fixed duration seconds call case repairserver rs subcast spm packet downstream spm packet repair server address field set local outgoing interface address note subcasting spm packet downstream sent outgoing interface multicast tree spm packets outgoing interface ip address repair server field 
case ends spm packet subcast downstream 
processing received data packet case begins data packet sequence number seq received repair server 
note original data packets forwarded outgoing interfaces multicast tree processing takes place 
repair data packets processed forwarded outgoing interfaces multicast tree cases call subcasting repair data packet downstream 
processing performed data packet seq currently buffered nak state exists data packet seq data packet seq repair data packet nak pending flag data packet seq true subcast data packet seq downstream cancel current nak suppression timer data packet seq cancel current nak retransmission timer data packet seq nak pending flag data packet seq false buffer data packet seq call case seq seq seq discard received data packet note repair server data packet buffer uses certain buffer management policy limited size fifo 
nak state consists nak pending flag nak count downstream nak count 
case ends case returns updated data packet discarded 
detecting gaps data packet sequence numbers case begins lost data packets detected handled 
processing performed seq sequence number passed case case seq seq nak state exists data packet seq call case case ends case returns missing data packet action taken 
starting data packet recovery case begins data packet seq detected missing data packet recovery process started 
processing performed create nakstate data packet seq nak count data packet seq downstream nak count data packet seq nak pending flag data packet seq true subcast nak packet data packet seq repair server nak count fast repair flag set false multicast group start nak suppression timer data packet seq duration random variate uniformly distributed upper limit times suppressto case ends nak suppression timer data packet seq started 
processing received multicast nak packet upstream case begins multicast nak packet received upstream 
processing performed seq nakcount nak packet sequence number nak count data packet seq currently buffered nak state exists data packet seq nakcount nak count data packet seq nak count nakstate data packet seq nakcount downstream nak count data packet seq nakcount subcast nak packet data packet seq nakcount fast repair flag set false multicast group cancel current nak suppression timer data packet seq cancel current nak retransmission timer data packet seq create nakstate data packet seq nak count nakstate data packet seq nakcount downstream nak count data packet seq nakcount nak pending flag nakstate data packet seq true subcast nak packet data packet seq nakcount fast repair flag set false multicast group start nak retransmission timer data packet seq duration retransto case ends nak retransmission timer started 
processing received unicast nak packet downstream case begins unicast nak packet received downstream 
processing performed seq nakcount fastrepairflag nak packet sequence number nak count fast repair flag nak state exists data packet seq create nak state data packet seq call case seq nakcount fastrepairflag true nakcount nak count data packet seq call case seq nakcount fastrepairflag false data packet seq currently buffered nakcount downstream nak count data packet seq downstream nak count data packet seq nakcount subcast nak packet data packet seq nakcount fast repair flag set false multicast group note repair server downstream nak count highest nak count seen repair server unicast nak packets data packet seq sent downstream 
purpose preventing unnecessary downstream multicasts nak packets nak suppression 
case ends returns nak packet subcast downstream action taken 
processing new nak packet nak state case begins received unicast nak packet new nak packet 
processing performed seq nakcount fastrepairflag passed case nak count data packet seq nakcount downstream nak count data packet seq nakcount data packet seq currently buffered nak pending flag data packet seq false get data packet seq buffer set retransmission flag data packet seq subcast data packet seq downstream nak pending flag data packet seq true subcast nak packet data packet seq nakcount fast repair flag set false multicast group call case seq nakcount fastrepairflag case ends data packet seq subcast downstream case returns 
start suppression interval case begins received unicast nak packet new nak packet 
processing performed seq nakcount fastrepairflag passed case fastrepairflag false true start nak suppression timer data packet seq duration random variate uniformly distributed upper limit times suppressto false cancel current nak suppression timer data packet seq cancel current nak retransmission timer data packet seq unicast nak packet data packet seq nakcount fastrepairflag repairserver start nak retransmission timer data packet seq duration retransto case ends nak suppression timer started nak retransmission timer started action taken 
nak suppression timer service routine case begins nak suppression timer data packet seq expires 
processing performed data packet seq currently buffered nak state exists data packet seq nak pending flag data packet seq false case unicast nak packet data packet seq nak count data packet packet fastrepairflag set false repairserver start nak retransmission timer data packet seq duration retransto case ends nak retransmission timer started 
nak retransmission timer service routine case begins nak retransmission timer data packet seq expires 
processing performed data packet seq currently buffered nak state exists data packet seq nak pending flag data packet seq false case nak count data packet seq incremented subcast nak packet data packet seq including repair server nak count fastrepairflag set false downstream start nak suppression timer data packet seq duration random variate uniformly distributed upper limit times suppressto case ends nak suppression timer started 
updating round trip time estimates case begins new rtt estimate available 
processing performed new sender rtt estimate milliseconds maxuprtt new maximum peer group rtt estimate milliseconds 
maximum peer group rtt maximum rtt receiver repair server receivers repair servers serviced smoothedrtt smoothedrtt rttvariance error smoothedrtt smoothedrtt smoothedrtt error rttvariance rttvariance abs error rttvariance retransto smoothedrtt rttvariance suppressto maxuprtt case ends suppressto updated 
appendix packet formats spm version number packet type multicast group address port number repair server address maximum transmitted data packet sequence number 
ip header spm contains spm option 
data packet version number packet type sequence number timestamp segment flag segmentation flag retransmission flag payload unicast nak version number packet type data packet sequence number nak count fast repair flag source address repair packet data packet 
addition ip header contains repair nak option 
multicast nak unicast nak packet 
addition ip header contains repair nak option 
aer rtt protocol nca cases estimation suppression timer retransmission timer values version order facilitate operation aer protocol network adaptive values nak suppression timer nak retransmission timer needed 
assessment behavioral characteristics aer heuristics reasonable suppression timer set scalar value times maximum round trip time nearest upstream repair server members nak originator peer group 
members peer group identically clients repair servers directly supplied originator upstream repair server intervening repair servers originator repair server members originator peer group retransmission timer set scalar value times round trip time originator nak sender 
settings directly reflect aer nak suppression strategy 
entity capable generating nak detects packet loss entity waits period time transmitting nak 
interval entity listens multicast channel repairs naks missing packet 
repair nak missing packet arrives suppression interval nak processing thread sends nak upstream subsequently sets awaits expiration retransmission timer 
alternately repair arrives suppression interval nak processing thread simply terminates 
nak arrives suppression interval nak processing thread terminates suppression timer subsequently sets awaits expiration retransmission timer 
repair operations initiation retransmission timer straightforward 
repair arrives retransmission interval nak processing thread assumes repair dropped begins nak processing thread top nak suppression timer set thread begins listening naks repairs missing packet 
nominally entity receiver repair server picks random number uniformly distributed scalar multiplier suppression timer maximum value 
hope entities wait little time issue naks wait longer periods see issued naks 
assuming entities issues nak immediately minimum time required nak observed peer sum transit time nak originator repair server queueing delays repair server transit time repair server peer 
worst case entity choosing smallest uniform random variable value longest transit time repair server peer nearly identical transit time case minimum observation time asymptotically round trip time furthest entity repair server 
set suppression timer maximum value constant times estimated maximum round trip time peer group 
establishing retransmission timer assume worst case repair request propagate way back sender order serviced 
set retransmission timer entity constant times estimated round trip time sender 
discussion describes mechanism estimating maximum round trip time peer group round trip time entity repair server receiver sender 
mechanism embodied get rtt algorithm described 
description get rtt algorithm 
high level description maximum round trip time peer group round trip time sender determined get rtt algorithm 
algorithm functions request response messages exchanged subscribers receivers repair servers nearest upstream providers repair servers sender 
get rtt request message format get rtt response message format 
state variable definitions initial settings algorithm parameters maximum amount time receiver repair server wait starting get rtt sequence 
nominal value milliseconds initial amount time receiver repair server wait starting get rtt sequence 
nominal value milliseconds maximum amount time receiver repair server wait starting get rtt sequence 
nominal value seconds maximum amount time sender repair server wait updating estimate maximum round trip time downstream peer group 
nominal value seconds sender peer group rtt variables time maxdownrtt updated 
initialized currenttime milliseconds 
maxdownrtt value currently largest rtt received directly supplied downstream receiver repair server 
initialized 
maxrecentdownrtt largest rtt received directly supplied downstream receiver repair server maxdownrtt set 
initialized 
sender rtt variables sourcertt rtt sender 

repair servers common variables resendinterval time successive get rtt requests 
initialized value 
peer group rtt variables time maxdownrtt updated 
initialized currenttime milliseconds 
maxdownrtt value currently largest rtt received directly supplied downstream receiver repair server 
initialized 
maxrecentdownrtt largest rtt received directly supplied downstream receiver repair server maxdownrtt set 
initialized 
maxuprtt largest rtt observed nearest upstream repair server sender 
value derive suppression timer value 
initialized 
myuprtt rtt observed nearest upstream repair server sender 
initialized 
sender rtt variables sourcertt rtt sender 
value derive retransmit timer value 
initialized 
receivers common variables resendinterval time successive get rtt requests 
initialized value 
peer group rtt variables maxuprtt largest rtt observed nearest upstream repair server sender 
value derive suppression timer value 
initialized 
myuprtt rtt observed nearest upstream repair server sender 
initialized 
sender rtt variables sourcertt rtt sender 
value derive retransmit timer value 
initialized 

estimation processing sequence maximum peer group rtt value maximum rtt repair server sender downstream level repair servers receivers 
source rtt round trip time sender repair server receiver 
initialization step repeated receipt spm packet receiver repair server sets get rtt resend timer value product random number uniformly distributed 
expiration get rtt resend timer get rtt resend timer reset current value resendinterval process continues step 
receiver repair server sends get rtt request nearest upstream repair server sender repair server 
host current time milliseconds inserted message value hosts current value myuprtt inserted message value 
receipt get rtt request upstream repair server sender compares message local value maxdownrtt 
value greater current value maxdownrtt sets maxdownrtt value value set current time milliseconds value maxrecentdownrtt set 
value greater maxdownrtt check see greater maxrecentdownrtt value maxrecentdownrtt set value maxdownrtt maxdownrtt currenttime milliseconds maxrecentdownrtt maxrecentdownrtt maxrecentdownrtt check determine maxdownrtt updated value comparing update time current time milliseconds 
currenttime maxdownrtt maxrecentdownrtt currenttime milliseconds maxrecentdownrtt repair server sender sends get rtt response message 
value response set value contained request 
value response set local value maxdownrtt 
value response set local value sourcertt 
receipt get rtt response message repair server receiver computes local round trip time myuprtt currenttime value maxuprtt equal value equal cancels current get rtt resend timer sets local value resendinterval equal myuprtt get rtt timer value resendinterval immediately sends get rtt request 
value resendinterval doubled limited necessary maximum value 
value maxuprtt set value message new value myuprtt whichever greater myuprtt maxuprtt myuprtt maxuprtt value response message nonnegative receiver repair server computes sets value sourcertt sum value value myuprtt 
cases sourcertt myuprtt initialization case begins get rtt initialized 
variables initialized follows sender currenttime milliseconds maxdownrtt maxrecentdownrtt sourcertt repair server currenttime milliseconds maxdownrtt maxrecentdownrtt maxuprtt myuprtt sourcertt resendinterval receiver maxuprtt myuprtt sourcertt resendinterval case ends variables initialized 
processing received spm packet case begins spm packet received receiver repair server 
receiver repair server starts get rtt resend timer duration random variate uniformly distributed times case ends get rtt resend timer set 
get rtt resend timer service routine case begins get rtt resend timer expires receiver repair server 
receiver repair server resets det rtt resend timer current value resendinterval subsequently sends get rtt request packet nearest upstream repair server sender 
get rtt request packet fields set follows currenttime myuprtt case ends get rtt request packet sent 
processing received get rtt request packet case begins get rtt request packet received repair server sender 
processing performed get rtt request packet fields maxdownrtt maxdownrtt currenttime milliseconds maxrecentdownrtt maxrecentdownrtt maxrecentdownrtt check determine maxdownrtt updated value comparing update time current time milliseconds currenttime maxdownrtt maxrecentdownrtt currenttime milliseconds maxrecentdownrtt repair server sender sends get rtt response packet 
get rtt response packet fields set follows maxdownrtt sourcertt case ends repair server sender sends get rtt response packet 
processing received get rtt response packet case begins get rtt response packet received receiver repair server 
receiver repair server computes local round trip time myuprtt currenttime value maxuprtt equal value equal immediately issues get rtt request follows maxuprtt resendinterval myuprtt cancel current get rtt resend timer start get rtt timer duration resendinterval send get rtt request packet currenttime myuprtt resend interval doubled limited value resendinterval resendinterval resendinterval resendinterval maxuprtt set value packet new value myuprtt whichever greater myuprtt maxuprtt myuprtt maxuprtt value response packet nonnegative receiver repair server computes sets value sourcertt sum value value myuprtt sourcertt myuprtt nca nom protocol section sender protocol nca cases algorithm version state information csmnominee address current nominee receiver 
csmlpe current loss probability estimate reported nominee receiver 
csmrtt current round trip time sender reported nominee receiver 
time milliseconds csmlpe csmrtt csmnominee set 
initialization case begins sender instantiated 
state information initialized follows csmnominee csmlpe csmrtt currenttime milliseconds case ends state information initialized 
processing received csm packet case begins csm packet arrives sender 
test performed addr lpe rtt csm packet receiver address loss probability estimate source receiver round trip time milliseconds 
currenttime current time milliseconds 
timeout parameter set constant milliseconds csmnominee addr csmnominee lpe csmlpe lpe csmlpe lpe rtt csmlpe csmrtt lpe csmlpe rtt csmrtt currenttime call case function lpe rtt follows lpe rtt rtt squareroot lpe lpe rtt case ends case returns csm packet ignored 
update nominee receiver parameters case begins csm receiver nominee receiver 
csm packet processed follows csmnominee csmnominee csm packet receiver address csmlpe csm packet loss probability estimate csmrtt csm packet receiver source round trip time currenttime milliseconds csmnominee csmnominee send nam packet csmnominee nominee address csmnominee send nam packet nominee address csmnominee cancel nam timer start nam timer constant duration milliseconds case ends nam timer restarted set 
nam timer service routine case begins nam timer expires 
processing performed csmnominee send nam packet csmnominee nominee address csmnominee restart nam timer constant duration milliseconds case ends nam timer restarted action taken 
section receiver protocol state information true indicates receiver nominated send congestion control signals sender false 
initialization case begins receiver protocol initialized upper layers 
state information initialized follows false sliding loss probability estimate lpe window fixed maximum size packets created recording arrival original data packets computing lpe 
csm timer started duration random variate uniformly distributed times fixed time value milliseconds 
case ends csm timer started 
processing received original data packet case begins original data packet retransmitted data packet received 
sliding lpe window updated record reception data packet rules window may expand empty maximum size window shrinks size maximum window size window may slid forward window size remains constant window may slid forward backward case ends sliding lpe window updated 
csm timer service routine case begins csm timer expires 
csm packet created lpe sourcertt fields set follows current sliding lpe window size csm packet lpe field csm packet lpe field receiver source round trip time rtt unavailable csm packet source rtt field csm packet source rtt field current receiver source rtt estimate milliseconds completed csm packet unicast receiver upstream repair server 
csm timer restarted constant duration milliseconds 
ends csm timer restarted 
processing received nam packet case begins nam packet received 
processing performed nam packet nominee address receiver local address true call enable fast repair case repair service algorithm false call disable fast repair case repair service algorithm case ends updated 
section repair server protocol state information address worst receiver downstream 
csmlpe current loss probability estimate reported worst receiver downstream 
csmrtt current round trip time sender reported worst receiver downstream 
time milliseconds csmlpe csmrtt csmnominee set 
initialization case begins repair server receives spm packet 
state information initialized follows csmlpe csmrtt currenttime milliseconds csm timer started constant duration milliseconds 
case ends csm timer started 
processing received csm packet case begins csm packet arrives repair server 
test performed addr lpe rtt csm packet receiver address loss probability estimate sender receiver round trip time milliseconds 
currenttime current time milliseconds 
timeout parameter set constant milliseconds addr lpe csmlpe lpe rtt csmlpe csmrtt lpe csmlpe rtt csmrtt currenttime call case function lpe rtt follows lpe rtt rtt squareroot lpe lpe rtt case ends case returns csm packet ignored 
update worst receiver parameters case begins csm packet received worst receiver downstream 
csm packet processed follows csm packet receiver address csmlpe csm packet loss probability estimate csmrtt csm packet receiver source round trip time currenttime send csm packet upstream repair server repair server lpe csmlpe sourcertt csmrtt receiver address cancel csm timer start csm timer constant duration milliseconds case ends csm timer restarted 
csm timer service routine case begins csm timer expires 
processing performed currenttime milliseconds csmlpe csmrtt currenttime milliseconds send csm packet receiver address set lpe set csmlpe sender rtt set csmrtt repair server repair server restart csm timer constant duration milliseconds case ends csm timer started 
appendix packet formats congestion status message csm packet csm packets unicast receiver repair server upstream repair server may sender 
fields version number packet type multicast group address port number loss probability estimate source receiver rtt 
nominee activation message nam packet unicast sender receiver intervention repair servers 
fields version number packet type multicast group address port number nominee address nca rc protocol section sender protocol nca cases rate control algorithm version state information nominee current nominee receiver address 
nominee equal 
address nominee receiver ccm timer set 
winsize current congestion window 
greater equal times 
slow start threshold window size 
sequence number oldest original data packet received ccm packet response 
lower congestion window 
greater equal 
number duplicate ccm packets received data packet 
sequence number original data packet sent 
may outside congestion window 
greater equal 
smoothedrtt smoothed rtt estimate milliseconds 
rttvariance mean deviation rtt estimate milliseconds la tcp 
maximum amount time milliseconds wait ccm packet 
time expires ccm packet received congestion window size dropped 
exponential backoff factor case successive timeouts 
flag recording fast recovery active 
sequence number data packet congestion window fast recovery activated 
set fast recovery active 
number original data packets sent ccm packet received 
initialization case begins sender instantiated 
constants nca follows max window max burst fr max burst min ss thresh max backoff state information initialized follows nominee winsize initial data packet sequence number smoothedrtt rttvariance false case ends state information initialized 
processing received ccm packet case begins ccm packet arrives sender 
ccm packet processed follows seq timestamp ccm packet ip source address retransmission flag sequence number time stamp nominee false call case passing timestamp call case passing seq cancel ccm timer case ends case returns ccm timer canceled 
updating rtt estimate case begins sender receives ccm update rtt estimate 
ccm packet processed follows timestamp time stamp value ccm packet passed case timestamp currenttime milliseconds smoothedrtt smoothedrtt smoothedrtt call case passing value case ends smoothedrtt updated case returns 
updating rtt estimate variance case begins rtt estimate variance updated new value 
processing performed error smoothedrtt smoothedrtt smoothedrtt error rttvariance rttvariance abs error rttvariance rttvariance abs error rttvariance smoothedrtt rttvariance note abs absolute value function 
case ends updated 
updating congestion window case begins congestion window needs updated due arrival ccm packet 
congestion window updated follows seq sequence number ccm packet passed case seq seq call case true call case call case call case case ends congestion window updated 
sliding congestion window forward case begins congestion window ready slid forward 
congestion window updated follows seq sequence number ccm packet passed case false call case seq case ends set 
increasing congestion window size case begins ccm packet received congestion window size increased fast recovery 
congestion window updated follows winsize winsize winsize winsize winsize floor winsize winsize min winsize max window winsize max winsize note floor function returns largest value greater argument equal mathematical integer 
case ends winsize updated 
increasing congestion window size fast recovery case begins ccm packet received congestion window size increased fast recovery 
congestion window updated follows winsize winsize winsize min winsize max window winsize max winsize case ends winsize updated 
leaving fast recovery case begins sender exit fast recovery state 
processing performed false winsize winsize min winsize max window winsize max winsize case ends winsize updated 
entering fast recovery case begins sender enter fast recovery state 
processing performed true floor winsize max winsize min ss thresh winsize winsize min winsize max window winsize max winsize case ends winsize updated 
testing original data packet sent case begins original data packet sequence number sent 
processing performed floor winsize original data packet sent current time case true fr max burst original data packet sent current time case max burst original data packet sent current time case original data packet sent current time case ends determination allow disallow original data packet sent 
sending original data packet case begins original data packet sequence number ready sent case allows packet sent 
processing performed cancel ccm timer nominee start ccm timer duration case ends ccm timer canceled canceled restarted 
ccm timer service routine case begins ccm timer expires 
processing performed max winsize min ss thresh min max backoff winsize false case ends updated 
updating receiver case begins nominee receiver address changed updated 
processing performed addr new nominee address nominee addr nominee initial value milliseconds case ends nominee updated 
section receiver protocol state information true indicates receiver nominated send congestion control signals sender false nca algorithm 
processing received data packet case begins data packet received 
receivers maintain lowest sequence number outstanding data packets times 
processing performed true data packet received send ccm packet sender seq lowest outstanding data packet sequence number timestamp data packet timestamp data packet retransmission flag case ends ccm packet sent sender processing occurs 
appendix packet formats congestion control message ccm packet unicast nominated receiver sender 
fields version number packet type multicast group address port number sequence number timestamp retransmission flag 
