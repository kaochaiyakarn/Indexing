function fold unfold 
jeremy gibbons university oxford graham hutton university nottingham thorsten altenkirch university nottingham april give necessary sufficient condition set theoretic function written recursion operator fold dual condition recursion operator unfold 
conditions simple practically useful generic underlying datatype 
recursion operator fold encapsulates common pattern defining programs consume values fixpoint type finite lists 
dually recursion operator unfold encapsulates common pattern defining programs produce values greatest fixpoint type infinite lists streams 
theory applications fold abound see surveys years increasingly clear known concept unfold just useful :10.1.1.42.1735:10.1.1.34.1618
interest fold unfold natural ask program written operators 
surprisingly little known question 
article gives complete answer special case programs total functions sets 
particular give necessary sufficient condition set theoretic function written fold dual condition unfold 
conditions simple practically useful generic underlying datatype 
proofs set theoretic essential axiom choice result generalize categories constructive functions fold unfold section review categorical treatment fold unfold terms initial algebras final coalgebras details see :10.1.1.41.125:10.1.1.37.1418
suppose fix category functor algebra pair comprising object arrow homomorphism algebra arrow square commutes initial algebra initial object category algebras objects homomorphisms arrows 
write initial algebra fold unique homomorphism initial algebra algebra 
fold defined unique arrow square commute fold fold dual notions coalgebra terminal coalgebra defined similarly 
write terminal coalgebra unfold unique coalgebra terminal coalgebra 
unfold defined unique arrow square commute effective topos category sets 
unfold unfold literature fold unfold written called catamorphisms anamorphisms respectively 
example finite lists suppose define functor set set id idn set natural numbers 
algebra pair comprising set function functions type uniquely decomposed form functions homomorphism function idn 
functor initial algebra defined list nil cons list set finite lists elements drawn nil list cons list list constructor functions set 
set functions function fold list uniquely defined equations fold nil fold cons idn fold fold processes list replacing nil constructor list function cons constructor list function example function sum list sums list naturals defined sum fold zero plus zero plus zero plus datatype examples 
notational simplicity write nil xs cons xs 
written definition fold fold fold xs fold xs example infinite lists suppose define functor set set sa sf idn coalgebra pair comprising set function functions type uniquely decomposed form functions function functor terminal coalgebra stream head tail stream set streams infinite lists elements drawn head stream tail stream stream destructor functions set 
set functions function unfold stream uniquely defined equations head unfold tail unfold unfold unfold produces stream function produce head stream function generate value unfolded way produce tail stream 
example function stream produces stream naturals ascending steps defined unfold idn succ succ succ 
arrow fold unfold 
fold operator encapsulates common pattern defining arrow type natural ask arrow type written fold 
precisely arbitrary arrow written form fold arrow 
technically complete unsatisfactory answer question provided universal property fold operator stated equivalence fold direction equivalence states fold homomorphism initial algebra algebra direction states homomorphism algebras equal fold taken universal property expresses fact fold unique homomorphism 
universal property provides complete answer question written form fold precisely helpful requires know specific universal property guide construction appropriate consider completely satisfactory answer approach heuristic difficult apply practice :10.1.1.34.1618:10.1.1.34.1618
problem universal property concerns intensional aspect function forms part implementation 
condition purely extensional aspects useful 
partial answer question purely extensional concerns left invertible arrow written fold :10.1.1.41.125
formally assume exists arrow id equation fold solved follows fold universal property identities idf functors id assumption functors composition summary derived implication id fold example function rev list list reverses list inverse rev rev idlist immediate rev written fold implication 
note implication provides partial answer question converse true general 
arrow written fold left invertible 
example function sum list written fold previous section left invertible 
dually unfold operator satisfies universal property show right invertible arrow type written unfold :10.1.1.41.125
example function stream stream removes element stream right inverse function inserts element adjacent pair stream immediate written unfold 
arrow written unfold right invertible 
example function stream written unfold previous section right invertible 
far aware invertibility results known results state arbitrary arrows correct type written fold unfold 
conclude section noting progress concerning specific kinds arrows 
example fusion law states composition homomorphism fold written fold banana split law states folds applied argument written single fold :10.1.1.41.125
function fold 
section give necessary sufficient condition arrow written fold special case category set arrows total functions sets 
dualize result unfolds section 
result depends definition definition kernel function set pairs elements identified ker main result section necessary sufficient condition arbitrary arrow set written form fold arrow theorem suppose fold ker ker crux proof known observation inclusion kernels equivalent existence lemma suppose ker ker proof proof straightforward 
left right direction assume clearly ker kernels leibniz assumption kernels ker conversely assume ker ker 
unique function note empty function empty 
type empty function equal define range proper definition choices assumption 
outside range define arbitrarily 
construction gives lemma proof note show implication holds proof theorem crucial lemma proof theorem embarrassingly simple fold universal property lemma ker ker lemma ker ker note lemma proof theorem involves constructing body fold 
similar result explicitly mentioning fold body suppose fold ker ker implication equivalence particular show certain expressed fold 
type list finite lists elements drawn constructors nil list cons list list theorem reduces stating arbitrary function list written directly fold precisely lists identified closed cons sense xs ys xs ys example function sum list section satisfies equations sum sum xs sum xs simple calculation verifies lists identified sum closed cons sum xs sum ys definition sum sum xs sum ys extensionality sum xs sum ys sum written directly fold 
example contrast define function list list safe tail equations xs xs simple counterexample verifies lists identified closed cons example xs ys xs ys xs ys 
written directly fold 
example datatype list finite lists reals consider problem computing floor list sums list reals floor rounds real largest integer result integer wonder computation carried fold integers avoiding computationally expensive real arithmetic 

hand reverse composition map floor floors element list summing written fold argument similar example applies 
instance deforestation efficiency improving transformation computations combined intermediate data structure type list eliminated :10.1.1.30.9032
type tree binary trees constructors leaf tree node tree tree tree theorem reduces stating arbitrary function tree written directly fold precisely trees identified closed node sense node node example example deforestation consider sum flatten flatten tree list generates list elements tree 
intermediate list computation eliminated node definition sum flatten node definition flatten sum flatten flatten sum distributes conclude trees identified closed node 
concatenates lists 
example predicate bal tree holds tree iff balanced leaves depth fold tree balanced depth tree balanced depth identified bal yielding true bal node bal node 
example function tree computes pair depth tree balanced fold 
depth node max depth depth bal node bal bal depth depth trees identified closed node 
example homomorphism transforming function form important step constructing efficient dataparallel algorithm computing 
function unfold 
theorem unfold straightforward 
purposes appropriate dual notion kernel function simply image definition image function set elements produced img duality kernel pairs images immediately evident revealed thinking relationally 
particular functions viewed relations obvious way relational composition function converse precisely kernel dual composition identity relation image 
elaborate characterization kernels needed relations general agrees restricted total functions 
result unfold gives necessary sufficient condition arbitrary arrow set written form unfold arrow theorem suppose unfold img img crux proof known observation time factoring functions direction 
lemma inclusion images equivalent existence suppose img img proof left right assume clearly img images assumption images img conversely assume img img 
empty function choose empty function empty equal define follows 
assumption img exists define doesn matter choose construction dual lemma lemma proof note show implication holds constant function functoriality putting results obtain proof theorem proof simple unfold universal property lemma img img lemma img img type stream streams naturals destructors head stream tail stream stream theorem reduces stating arbitrary function stream written unfold precisely tail stream sense img tail img example consider function stream defined section 
note tail stream general img tail set streams 
included img set streams 

expressible unfold 
example hand consider function stream yields stream multiples 
natural tail stream img tail included img includes streams head 
expressed directly unfold 
finite infinite lists elements drawn destructors hd tl theorem reduces stating arbitrary function written unfold precisely tl sense img tl img id example function rle performs encoding equal adjacent elements input grouped output single element occurrence count 
written unfold non empty encoding encoding non empty tail encoding resulting removing original initial elements equal head 
corresponding function type list list fold leave proof exercise 
infinite binary trees elements drawn destructors root left right theorem reduces stating arbitrary function written unfold precisely children sense img left img img right img example consider position tree infinite binary tree node labelled position tree finite sequence booleans recording left right turns root order reach node 
function positions list yields tree unfold img positions contains exactly tree empty sequence root left right children singleton lists roots 
hand function list list generates position tree starting position unfold left child bs true bs turn right child 
complete results arbitrary arrow written directly fold unfold special case category set interesting theoretical point view increases understanding important operators functional programming 
importantly expect practical applications program optimisation 
various research groups working deforestation :10.1.1.39.5086
structured program typically factored phases phase generating data structure consumed subsequent phase deforestation fuses adjacent phases eliminates intermediate data structure 
performed compiler optimisation yields efficient object code sacrificing structure clarity source code 
results determine phases fused fold unfold 
possible harness testing framework quickcheck task finding counterexamples appropriate inclusions 
investigate results generalised categories clear done 
particular proofs essential axiom choice carry computational categories cpo 
rule interesting categories proof carry rel may theorem variation 
fruitful direction extend results patterns recursion primitive recursion course value iteration 
grateful lambert meertens pointed crucial lemmas lemma lemma equivalences just implications simplifying proofs considerably 
graham hutton thorsten altenkirch supported esprit working group applied semantics 
part graham hutton supported epsrc structured recursive programming 
bird de moor 
algebra programming 
prentice hall 
claessen hughes 
quickcheck lightweight tool random testing haskell programs 
proc 
th acm sigplan international conference functional programming september 
cole 
parallel programming list homomorphisms 
parallel processing letters 
gibbons 
calculating functional programs 
summer school workshop algebraic coalgebraic methods mathematics program construction oxford april 
gibbons hutton 
proof methods structured programs 
proc 
st scottish functional programming workshop stirling scotland august 
gibbons jones 
appreciated unfold 
proc 
rd acm sigplan international conference functional programming baltimore maryland september 
fokkinga 
law order algorithmics 
phd thesis universiteit twente 

extracting implementing list homomorphisms parallel program development 
science computer programming 
hu iwasaki takeichi 
deriving structural hylomorphisms recursive definitions 
proc 
st acm sigplan international conference functional programming 
hutton 
fold unfold program semantics 
proc 
rd acm sigplan international conference functional programming baltimore maryland september 
hutton :10.1.1.34.1618
tutorial universality expressiveness fold 
journal functional programming july 
jacobs moss reichel rutten editors 
proc 
workshop coalgebraic methods computer science 
elsevier science 
electronic notes theoretical computer science volume 
jacobs rutten 
tutorial algebras induction 
bulletin european association theoretical computer science 
jacobs rutten editors 
proc 
second workshop coalgebraic methods computer science 
elsevier science 
electronic notes theoretical computer science volume 
launchbury sheard 
warm fusion deriving build recursive definitions 
proc 
conference functional programming languages computer architecture acm press 
mac lane 
categories working mathematician 
number graduate texts mathematics 
springer verlag 
malcolm 
algebraic data types program transformation 
science computer programming september 
meertens 
paramorphisms 
formal aspects computing 
meijer fokkinga paterson :10.1.1.41.125
functional programming bananas lenses envelopes barbed wire 
hughes editor proc 
conference functional programming computer architecture number lncs 
springer verlag 
takano meijer 
shortcut deforestation calculational form 
proc 
conference functional programming languages computer architecture acm press 
vene uustalu 
functional programming corecursion 
proceedings estonian academy sciences physics mathematics 
vene 
categorical programming inductive coinductive types 
phd thesis 
wadler :10.1.1.30.9032
deforestation transforming programs eliminate trees 
theoretical computer science 

