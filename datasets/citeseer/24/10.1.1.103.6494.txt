design patterns language constructs jan bosch university ronneby department computer science business administration ronneby sweden mail jan bosch ide hk se www www pt hk se bosch design patterns proven useful design object oriented systems 
power design patterns stems ability provide generic solutions problems specialised particular situations 
implementation design patterns received little attention identified problems associated implementation design patterns conventional object oriented languages 
traceability design pattern implementation insufficient design pattern lost 
second patterns require object forward messages objects increase flexibility self problem occurs 
thirdly pattern implementation mixed domain class reusability pattern implementations limited 
implementing design patterns may significant implementation overhead software engineer 
potentially large number simple methods implemented trivial behaviour forwarding message object 
solution problems context layered object model layom 
layom provides language support explicit representation design patterns programming language 
layom extended object oriented language contains components part conventional object model states categories layers 
layers represent design patterns level programming language example layer types design patterns adapter bridge composite facade state observer strategy 
layom extensible language software engineer may extend language model abstractions design patterns 
design patterns increasingly popular mechanism describe solutions general design problems customised particular applications 
authors gamma pree coplien schmidt written various aspects design patterns 
categories design patterns proposed general domain independent patterns domain specific patterns 
collective understanding object oriented paradigm develops continuously number available design patterns growing constantly 
software engineer uses paradigm set related concepts designing system 
size contents concept set depending experience software engineer 
inexperienced software engineer may just concepts programming language experienced engineer larger set 
popularity design patterns ability capture design concepts experienced software engineer designs 
authors propose design patterns mechanism specifically design 
relation implementation level discussed terms example template code allows software engineer conveniently transform design pattern 
general traditional object oriented language 
disadvantage programming language conventional object oriented paradigm support representation design patterns provided language 
leads problems related traceability self problem expressiveness implementation overhead problems related implementation design patterns 
take standpoint design patterns part software engineer paradigm task programming language represent concepts paradigm accurate possible 
impossible represent concepts believe proper programming language design concepts including design patterns represented programming language 
layered object model layom proposed language model explicit support representing design patterns 
layom language model provides explicit support modelling constructs object oriented design design patterns relations objects object state 
object layom consists instance variables methods states categories layers 
layers encapsulate object intercept messages send objects 
layers organised classes layer class represents concept relation object design pattern 
layom supported development environment translates classes applications defined layom code 
generated code construct applications direct integrated existing code 
advantage layom traditional object oriented language suffer identified problems related implementation design patterns 
layom losing compatibility legacy systems code developed translated 
resulting code integrated code program 
remainder organised follows 
section design patterns introduced problems associated implementation design patterns discussed 
section layered object model 
section describes implementation structural behavioural design patterns layers layom 
section compares ideas related concluded section 
design patterns designing system software engineer paradigm set related concepts 
object oriented paradigm concepts object class method inheritance model system 
inexperienced engineer generally small concept set primarily consisting concepts represented programming language 
somewhat experienced software engineers access larger concept sets including concepts presents typical data structures algorithms course 
course way student get access advanced concepts personal hands experience 
popularity design patterns believe stems ability capture implicit experience shared object oriented software engineering community 
patterns concept originate christopher alexander alexander 
pattern describes recurring problem generic solution adopted particular situations 
set patterns organised pattern language providing set composable solutions problems particular domain 
patterns notion adopted object orientation design patterns 
gamma define design patterns descriptions communicating objects classes customised solve general design problem particular context 
authors catalogue design patterns organised categories depending pattern purpose 
creational patterns concerned object creation structural patterns address composition classes objects 
behavioural patterns concerned ways classes objects interact distribute responsibility 
domain patterns limited design patterns discussed gamma 
example pree discusses design pattern catalogue gamma object oriented patterns coad coding patterns framework formal contracts helm patterns solving general design problems 
buschmann classifies design patterns granularity functionality structural principles 
example levels granularity recognised architectural frameworks design patterns idioms 
coplien schmidt vlissides design pattern related papers 
due fact design patterns popular object oriented community generally accepted classification design patterns exists 
issue seldom addressed design pattern community implementation support design patterns 
design patterns part set concepts paradigm software engineer modelling systems engineer benefit handling design patterns class entities design implementation 
pattern design implementable identifiable unit programming language 
goal programming language design represent concepts software development paradigm accurately possible 
implementing design patterns conventional object oriented language identify problems 
problems identified discussed section underlying problem design pattern represented class entity 
design pattern affects multiple aspects methods class multiple classes objects pattern language construct inherited composed traditional way 
powerful composition techniques required allow design pattern superimpose behaviour class object pattern domain entity remain identifiable entities 
problems implementing design patterns focus implementation object oriented language design patterns contained object oriented design model 
experienced problems implementing design patterns traditional object oriented language 
problems primarily related traceability design patterns implementation self problem language expressiveness implementation overhead design patterns 
traceability traceability design pattern lost programming language support corresponding concept 
software engineer required implement pattern distributed methods message exchanges pattern conceptual entity design level scattered different parts object multiple objects 
problem identified 
self problem implementation design patterns requires forwarding messages object receiving message object implementing behaviour executed response message 
receiving object example application domain object delegates messages strategy object 
message forwarded object originally receiving message longer available self refer delegated object original receiver message 
problem known self problem lieberman 
reusability design patterns primarily design structures 
design patterns cover parts object multiple objects patterns class representation implementation level 
implementation design pattern reused design reused software engineer forced implement pattern 
implementation overhead implementation overhead problem due fact software engineer implementing design pattern implement methods trivial behaviour forwarding message object method 
leads significant overhead software engineer decreased understandability resulting code 
examples problems section 
address problems propose solution context layered object model discussed section 
layered object model extensible object model objects encapsulated called layers 
illustrate design pattern implemented layer type 
software engineer instantiate layer type corresponding design pattern associate specification layer specialises behaviour layer type particular context 
illustrate approach applying design patterns design pattern catalogue gamma 
reason catalogue semantics design patterns relatively defined address relevant design problems 
layered object model layered object model extended object model defines additional components traditional object model components layers states categories 
example layom object 
layers encapsulate object messages send object pass layers 
layer intercepts message converts message passive message object evaluates contents determine appropriate course action 
layers various types functionality 
layer classes defined representation relations objects discussed section 
representation design patterns layers 

layered object model layom object contains object model instance variables methods 
semantics components similar conventional object model 
difference instance variables encapsulating layers adding functionality instance variable 
example layom class shown containing instance 
state layom abstraction internal state object 
layom internal state object referred concrete state 
object concrete state software engineer define externally visible abstraction concrete state referred state object 
object state generally simpler number dimensions domains state dimensions 
state shown 
abstracts location mouse window origin distance measure 
refer bosch extended description object state 
category expression defines client category 
client category describes discriminating characteristics subset possible clients treated equally class 
example class defines programmer client category restricting object instances class programmer subclasses 
behavioural layer types categories determine sender message member client category 
sender member message subject semantics specification behavioural layer type instance 
layer mentioned encapsulates object intercepts messages 
perform kinds behaviour response message 
previously layers primarily represent relations objects 
layom relations classified structural relations behavioural relations relations 
structural relation types define structure class provide reuse 
relation types extend functionality class 
inheritance delegation examples structural relation types 
second type relations behavioural relations relate object clients 
functionality class client objects class define behavioural relation client client category 
behavioural relations restrict behaviour class 
instance methods restricted certain clients specific situations 
third type relations application domain relations 
domains reusable application domain classes application domain relation types reused 
instance controls relation type important type relation domain process control 
sections structural behavioural relation layer types discussed 
information application domain relation types refer bosch bosch 
class layers 
layer defines instance part class 
layer defines class inherits methods class window method 
layer restricts access instances class programmer subclasses distance mouse location window origin units 
class layers rs programmer accept reject pin window po partof variables loc location methods newloc location returns boolean loc newloc self states returns point return self origin sqr self origin sqr sqrt categories programmer sender subclassof programmer class 
example layom class extended object model layered object model extensible object model object model extended software engineer new components 
layom example extended new layer types structural components events 
notion extensibility core feature object oriented paradigm applied object model 
object model extensibility may useful theory order apply practice requires extensibility translator compiler associated language 
case layom classes applications translated 
generated classes combined existing hand written code form executable 
layom compiler delegating compiler objects bosch concept facilitates modularisation reuse compiler specifications extensibility resulting compiler 
implementation layom compiler discussed section 
structural relation layers structural relation types described define structure application 
class uses structural relations extend behaviour class seen client class obtains functionality provided classes 
generally types structural relations object oriented systems development inheritance delegation part 
types relation provide form reuse 
inherited delegated part object provides behaviour reused respectively inheriting delegating object 
referring relation types structural define reuse relations 
orthogonal discussed relation types recognise additional dimensions describing extended behaviour object partiality 
indicates reusing object limits reuse occur certain states 
partially indicates reusing object reuses part reused object 
consider important relation classes objects regardless complexity modelled single entity model 
alternative approach define collection orthogonal constructs decompose relation objects instances orthogonal construct 
approach represent conceptual entity analysis design entity language model 
different aspects structural relation type partiality form dimensional space contains possible combinations 
compliance modelling principle define relation type combination 
results twelve structural relation types 
structural relation types shown table 
due space constraints possible describe syntax semantics structural relation types 
layer type partial inheritance described detail 
semantics layer types deduced reader 
relation type inheritance delegation part default inherit delegate partof partiality conditional partial table 
structural relation type identifiers contains partial inheritance layer configuration pin window semantics partial inheritance layer part interface inherited class reused excluded 
name layer type 
layer type accepts arguments 
argument name class inherited window case 
second argument list interface elements indicates interface elements inherited 
example indicates interface elements inherited 
third argument contain list interface elements 
example list consists element 
semantics inherits complete interface 
note different object oriented languages software engineer explicitly specify interface elements superclass inherited reused 
method automatically overridden subclass method name 
implementation semantics illustrated 
partial inheritance layer second layer class 
outer layer shown inner layer shown 
inheritance layers create instance inherited superclass 
instance shown 
layer contains message handler received message determines message passed inwards outwards redirected instance 
incoming message shown 
message reified handed message handler 
message handler reads selector field message compares partially inherited interface 
selector part set interface elements message redirected instance situation 
selector match interface redirected forwarded layer situation 

layer extensive description semantics structural relation types refer bosch bosch 
behavioural relation layers previous section discussed relations object containing relation client object extends structural relations 
section discuss relation types object clients 
relation types generally constrain access clients behaviour object way 
order keep type number clients object open ended define client categories message determined sender message member client category 
message subject behavioural relation defined client category 
relation object client category defined number behavioural constraints 
types constraints client access state access concurrency real time 
layered object model takes different approach defining modelling constructs compared conventional approaches 
aiming defining clean orthogonal constructs try define constructs correspond conceptual entities 
convinced supported object oriented analysis design methods concept relation objects conceptual entity different aspects relation defined part relation unrelated orthogonal constructs combined provide equivalent behaviour 
table behavioural relation layer types shown 
relation type viewed location space build constraint dimensions defined 
relation requires client category specified 
results dimensions part part relation 
combination relation type defined 
factor factor factors factors table 
behavioural relation type identifiers due space constraints unable discuss semantics behavioural relation types 
discuss semantics layer type detail 
layer type restricts access particular client category object certain states 
see layer configuration syntax rs programmer accept reject semantics layer specification 
clients classified members programmer client category access methods object provided equal 
larger message rejected error message returned client object sent message 
functionality layer type graphically 
layer intercept messages sent object 
message sent object classified member client category indicated layer specification message just passed layer 
selector message matched identifier list layer specification 
matches state referred specification evaluated 
depending message passed layer see 
message passed message stored message queue keyword see case keyword reject message discarded error message sent sender object see 

layer implementation mentioned earlier layered object model extended extensible object model 
extended contains components addition components traditional object model states categories layers 
extensible may extended new components software engineer considers appropriate 
possible extensions new layer types new object components events 
years primarily new layer types representation structural behavioural inter object relations acquaintance handling topic design patterns defined 
time may clear layer types design pattern represented proposed section lack expressiveness particular situations implemented differently 
response language extended changed reflect new requirements 
conventional object oriented languages complex due monolithic rigid compiler technology construct compilers languages 
important clear conventional programming languages due technological problems compiler technology due conceptual human factors 
software engineer modelling domain ideally able represent domain concept corresponding concept programming language 
traditional compiler technology unsuitable implement extensible languages alternative approach defined 
implementation layered object model notion delegating compiler objects bosch 
dco object compiles part syntax input language 
consists lexers parsers parse graph 
nodes parse graph ability generate code 
case layom class compiler consists class dco method dco state dco category dco dco layer type 
dco definition results class dco object instantiate dco delegate control 
delegated dco perform functionality return control delegating dco finished 
layom compiler generate output code 
layom code class application 
layom class compiled class layom application compiled main program 
generated class incorporated function subsequently executable program 
structure layom compiler shown 

overview layom compiler advantage dco approach supports extensibility language 
software engineer wants add new concept language required dco defining syntax code generation information particular concept 
new dco added set existing compiler 
minor modifications instantiate new dco changes required 
delegating compiler objects concept supported tool allows software engineer compose compilers instantiating 
dco subsequently assigned lexer parser 
compiler base dco initially instantiated 
tool provides editing facilities specifying parsers lexers parse graph node classes 
detailed description delegating compiler object concept associated tool refer bosch 
design patterns language constructs design patterns defined semantics basis defining language constructs explicitly support representation design pattern programming language 
noted researchers engineers opinion design patterns design guidelines adapted application 
consequence design patterns considered sufficiently specific contain application specific aspects applied infeasible represent language constructs 
disagree point view 
design patterns belong paradigm experienced software engineers 
primary aim programming languages provide accurate language constructs paradigm concepts logically integrated language 
argument increase complexity language hold programming language represents paradigm concepts software engineer 
lack expressive constructs paradigm concepts increase complexity engineer forced implement concept terms lower level language constructs reducing traceability understandability 
furthermore software engineer free available language constructs forced 
obtaining experience programming students increase set language constructs build programs 
similar development expect languages provide expressiveness design patterns 
discussion brought understanding beneficial programming language provide constructs representing design patterns 
identified problems associated implementation patterns conventional object oriented languages 
languages provide insufficient support implement design patterns traceable efficient manner 
traceability problematic design patterns lost implementation 
secondly pattern implementation involve forwarding messages causing self problem 
thirdly implementations patterns programming languages generally reusable 
design patterns require definition potentially large number methods trivial behaviour forwarding message nested object software engineer forced implement methods causing considerable implementation overhead 
address problems approach taken provide design patterns class implementation construct corresponding conceptual design entity pattern represents 
class design pattern implementations require advanced language model conventional object oriented model 
behaviour design pattern way superimposed object behaviour language model allows design pattern representation provide corresponding composition techniques 
section number layom layer types represent design patterns 
design patterns selected collection defined gamma particular structural behavioural design patterns 
collection contains structural design patterns behavioural design patterns unable describe layer types design patterns reasons space 
limit describing design patterns illustrative suitable layer types 
section design patterns discussed structural behavioural patterns 
structural design patterns described section structural design patterns define parts structure system 
patterns concerned composition classes objects 
gamma design patterns described 
mentioned traditional object oriented languages difficulty implementing design patterns traceable efficient manner 
solution proposed layered object model implementation design models patterns 
layom extensible object model object model extended adding new layer types 
facility define layer types implement functionality design patterns 
sections bridge composite pattern discussed 
adapter intent 
adapter design pattern convert interface class interface expected clients 
adapter design pattern allows classes cooperate incompatible due differences expected interfaces 
problem 
conventional object oriented language adapter implemented object forwards calls adaptation adaptee adapted object 
structure adapter object adaptation gamma shown 
class adaptation shown 
client target request adapter request adaptee 
structure design pattern adapter allows classes disadvantages associated implementation pattern 
disadvantage element interface needs adapted software engineer define method forwards call actual method 
case object adaptation requests required adaptation forwarded due intermediate adapter object 
leads implementation overhead software engineer suffers self problem lacks expressiveness 
behaviour adapter pattern mixed domain related behaviour class traceability reduced 
solution 
layered object model functionality adapter design pattern require separate object class defined 
layer type adapter defined provides functionality associated design pattern 
layer part class definition case represents class adaptation 
defined object representing object adaptation 
syntax layer type adapter id adapter accept mess sel new mess sel accept mess sel new mess sel semantics layer type message message selector mess sel specified layer passed new selector new mess sel 
layer type allows message selector translated new message selector 
layer translate messages send object encapsulated layer messages send object 
adapter layer class adaptation defining new adapter class consisting layers 
example shown class adapter layers adapt adapter accept mess accept mess mess inh inherit adaptee class adapter example translates message message message message 
methods presumably implemented class adaptee inherit layer redirect messages instance class adaptee contained layer 
adaptation object level achieved encapsulating object additional layer instantiation 
case adaptation effective particular instance instances class 
example adapted object declaration shown 
object declaration adaptee layers adapt adapter accept mess accept mess mess 
adaptee instance extended additional layer type adapter adapts interface match interface expected clients 
adapter layer outer layer object intercepting messages going object 
layer inverted situation situation single client needs access server objects client expects interface different interface offered server objects 
case client object class extended layer translating messages send client messages understood server objects 
evaluation 
adapter layer type allows software engineer translate adapter design pattern directly implementation losing pattern 
clear relation design implementation 
second advantage software engineer required define method method needs adapted 
specification layer required 
addition case object adaptation software engineer traditional implementation approach needs define method methods adapted class adapted 
layer avoided 
disadvantage adapter layer type definition arguments message passed sent 
situations pass arguments different order add remove arguments 
bridge intent 
pattern decouples abstraction implementation abstraction vary independently 
problem 
structure class employing bridge design pattern shown 
relevant methods abstraction forward calls part object containing implementation 
bridge pattern allows separate abstraction implementation problems identified approach 
problem implementation overhead resulting separation abstraction implementation 
method abstraction class needs forward message corresponding method implementation class 
second problem self problem abstraction class called implementation class call self directed implementation class 
excludes possibility abstraction class calls change implementation particular method 
third problem related traceability implementation bridge pattern distributed object correlation pattern implementation structure 
abstraction operation imp imp 
structure design pattern solution 
layom problem addressed bridge layer type allows software engineer specify message method combination implemented 
syntax layer type id bridge implement mess sel object method layer intercepts messages matching mess sel redirects message indicated object method 
message selector redirected object method 
layer implemented self pseudo variable object encapsulated bridge layer object redirected avoiding self problem 
implementor bridge layer type ways class object approach 
example class approach shown 
class abstraction layers bridge bridge implement mess imp mess implement mess mess imp mess methods implementation implementor imp variables imp implementor class abstraction individual objects extend implementation object approach 
example object representing abstraction extended bridge layer part layer providing implementation bridge implementation 
abstraction layers bridge bridge implement mess imp mess implement mess mess imp mess imp partof 
evaluation 
design pattern removes implementation overhead forwarding methods abstraction 
addition layered object model supports true delegation messages self problem 
traceability design pattern increases bridge layer type compared conventional implementation 
composite intent 
design pattern supports organisation objects part hierarchies 
resulting objects uniform interface clients object individual object composition objects 
problem 
composite pattern structure shown 
pattern ways maximizing safety transparency 
transparency optimal superclass component provides implementations child handling add 
methods meaning leaf classes methods invoked composites 
safety increased child handling methods implemented class decreases transparency 
client component operation add component remove component int leaf composite children operation operation add component remove component int forall children operation 
structure pattern design pattern important pattern proven applications 
identified problems associated pattern related traceability reusability modelling 
composite pattern implemented single identifiable entity divided various child handling methods leading diminished traceability pattern 
class libraries define container classes allow store objects arbitrary type container 
problem approach container component 
composite pattern solves problem introduces problem reusability code child handling 
child handling code embedded domain classes code separately reused 
modelling problem caused fact modelling domain software engineer forced address implementation aspects child handling aspects mixed code 
solution 
reusability problem caused fact child handling behaviour composed domain concepts single class 
solution problem remove limitation allow expressive composition behaviour provided layers 
composite layer type contains behaviour child handling extend domain classes composite behaviour 
syntax layer id composite add mess sel remove mess sel mess sel multicast mess sel layer implements child handling behaviour specified composite design pattern add remove multicasting operation messages children 
names default names child handling layer allows software engineer redefine names 
operations multicasted non default way arguments different child multicasting take place subset children implemented method class 
child handling interface calls 
layer added definition superclass component subclasses depending software engineer prefers transparency safety 
instances existing domain classes extended composite behaviour adding layer instance 
evaluation 
composite layer type provides solution identified problems 
traceability pattern improved class representation layer 
reusability improved layer type contains code child handling instantiation layer type reuses code 
composite layer added class point time mixed domain concepts superimposed 
disadvantage layer type different implementations child handling easily expressed 
conventional implementation true spirit extensible languages new layer type extending layer defined 
described section means infeasible layom 
facade intent 
facade design pattern provide single integrated interface set interfaces subsystem facade defines higher level interface simplifies subsystem 
problem 
structure subsystem incorporating design pattern looks 
subsystem defined class containing classes part subsystem 
function subsystem class basically twofold 
coordination classes subsystem second function provide integrated interface clients subsystem 
defining subsystem class function dealt acceptable manner 
second function forwarding messages objects subsystem problematic 
traditional approach define method subsystem class forwards message sent client appropriate object inside subsystem 
disadvantage approach message send client subsystem class define method 
number meth ods easily grow large defining methods just forwarding message 
second disadvantage traceability design pattern implementation lost 
facade 
structure design pattern solution 
solution identified problems associated traditional implementation approach layered object model layer type 
layer type provides functionality forwarding messages objects part subsystem 
layer defined follows id facade forward mess sel object forward mess sel object behaviour facade layer 
matches selector message message selectors defined mess sel message forwarded object object 
layer contain forwarding elements allowing subsystem class forward objects layer 
subsystem class layer defined follows class layers face facade forward mess mess forward mess partof partof class described section layered object model models relations objects layers 
relations include part relation implemented partof layer type 
facade layer forwards messages matching mess object contained subsystem 
messages forwarded 
evaluation 
facade layer type main advantages traditional implementation techniques 
advantage software engineer define possibly large number trivial methods just pass message objects subsystem 
second advantage direct correspondence design pattern design level facade layer defined implementation 
behavioural design patterns behavioural design patterns focus algorithms cooperation interaction objects 
addition structure group objects classes design patterns concerned communication objects classes 
gamma collection behavioural design patterns consists patterns 
mentioned earlier behavioural design patterns discussed section state observer strategy mediator 
state intent 
pattern situations behaviour object depends internal state object 
object changes relevant aspect state changes behaviour 
problem 
implementation approach suggested gamma define superclass defining methods change behaviour depending state 
class subclassed concrete subclasses different relevant states associated behaviours 
classes object supposed show state dependent behaviour referred 
object contains instance concrete state subclasses 
object changes state replaces instance instance concrete subclass 
structure design pattern shown 
context request state handle handle 
structure design pattern implementation approach appropriate traditional object oriented languages approach problems associated 
problem approach assumes relatively small number boolean states require unique implementation method set methods 
cases required dynamicity object behaviour structured 
refer bosch extended discussion problems 
second problem context object implement trivial method state dependent method implemented state class resulting self problem implementation overhead software engineer 
traceability implementation pattern far optimal 
solution 
similar solutions problems associated aforementioned design patterns define layer typestate allows software engineer specify depending object state appropriate method object message requesting state dependent behaviour 
described section layom provides notion state 
state abstraction internal concrete object state presents relevant state object interface 
state layer type object state 
syntax layer type defined id state state expr forward mess sel mess sel object state expr forward mess sel mess sel object semantics layer type message received layer evaluated element layer specification state expression state expr evaluates true selector message matches specified message selectors message forwarded method indicated mess sel object object 
state layer type scenarios 
situation number defined states exist associated behaviour software engineer define concrete subclass state declare part class 
layer direct messages appropriate state object 
example class specification shown 
handle message state dependent 
depending value message directed part concrete state 
class context layers st state forward handle forward handle partof partof states returns boolean class context state dependent behaviour object structured previous scenario software engineer define different methods message selector layer direct message appropri state handle handle ate method 
example approach shown 
depending value handle message directed 
class context layers st state forward handle forward handle methods returns 
class context evaluation 
state layer type advantages compared traditional implementation techniques 
software engineer write possibly large set trivial methods forwarding message appropriate method depending state 
secondly relation design pattern implementation kept improving traceability 
state layer performs message delegation forwarding self problem avoided 
observer intent 
design pattern deals situation set objects depending state changes object object changes state dependents notified 
problem 
observer pattern widely object oriented systems significantly decreases dependency object dependent objects 
structure observer pattern shown 
analysing approach taken implement pattern issues identified 
traceability pattern implementation ideal 
methods attach detach notify form conceptual entity especially fact invocation message placed locations object state changed elegant 
second issue proposed implementation pattern inheritance proposed obtaining behaviour domain class 
behaviour represent abstraction domain concept behaviour required implementation 
preferably object extended behaviour way inheritance 
third problem class subject needs prepared notification messages design 
behaviour added existing class software engineer forced understand implementation class add notification behaviour subclass existing class 
subject attach observer detach observer notify getstate observers observers update return subject 
structure pattern solution 
solution context layered object model define layer type observer extend class subject behaviour notifying dependent objects 
layers intercept messages sent object able inspect state object notice state changes observer layer able detect changes subject notify 
syntax layer id observer notify mess sel aspect aspect 
layer intercepts messages determines selector message matches message selectors mess sel specified layer configuration 
layer notify message processed object 
notification occurs depends observer update update subject getstate keyword layer 
similar smalltalk implementation goldberg robson observer pattern notified particular aspect allowing object limit actual updates aspects interesting particular 
administration observer objects part functionality layer type 
attach detach methods implemented layer messages object message selectors intercepted layer handled locally layer 
observer layer type extending class observer pattern functionality 
example class shown 
class sety change value andy instance variables 
class subject objects contains layer notify observer objects method invoked changes values layer instance observer objects notified message processed object 
aspect notified depends method name 
class layers st observer notify setx aspect axis notify sety aspect axis notify moveto aspect location methods setx location returns location sety newy location returns location moveto move location returns location class defining observer layer class definition extend individual instances observer layer 
may useful allows software engineer class observer pattern functionality situation play role subject 
instance regular point class observer pattern behaviour defined extended observer layer 
addition allows subject 
point layers st observer notify setx aspect axis notify sety aspect axis notify moveto aspect location evaluation 
observer layer type models observer design pattern class entity extend classes individual instances observer pattern behaviour 
advantages layer type traditional implementation increased traceability improved reusability reduced implementation overhead 
implementation layer type purposely defined close original pattern possible 
imagine alternative semantics layer type 
example register particular aspects notified changes 
solve problem observer layer type multiple instances defined single object layer may know layer particular attach detach message intended 
strategy intent 
strategy design pattern represents algorithm behaviour object objects pattern replace algorithm part behaviour replacing part object containing behaviour 
pattern solves situation hierarchy similar objects defined address fact top object requires situation dependent algorithm 
problem 
strategy design pattern situations implementation behavioural part class needs replaceable implementations 
typical situation strategy objectoriented frameworks 
example framework measurement systems designed bosch extensive strategies update strategies sensors calculation strategies converting read data form required entity actuation strategies actuators measurement system 
strategies characterised fact application dependent 
effect strategies applications developed framework solely defining appropriate application dependent strategies 
strategy pattern problems associated 
problem traceability strategy implemented part object invoked object algorithm executed 
analysing code software engineer determine part object regular part object strategy object 
secondly strategy pattern suffers self problem strategy object refers self addresses object containing strategy 
strategy object principle implements methods containing object ideally just plug methods containing object implementing separate object 
thirdly implementation overhead containing object needs forward client calls requiring strategy strategy object 
addition software engineer defining containing strategy objects needs explicitly distinguish calls object strategy containing object respectively 
context strategy 
structure pattern solution 
designing solution context layom solution approaches 
define delegating layer delegates messages strategy object strategy object contains second solution define layer type allows specify method implementation part layer configuration 
layer act method object encapsulates 
decided define layer types close definition design patterns possible adopted solution approach 
address problems described layer type strategy defined delegates relevant messages strategy object contained inside layer 
syntax layer type shown 
strategy layer delegates matching messages strategy object 
message matches depends layer configuration 
list messages defined message match set delegated 
messages matching interface strategy object delegated 
instantiation layer layer instantiates instance class class represents strategy object 
strategy object replaced set mess sel part 
id strategy delegate mess sel class set mess sel class define instances strategy layer type deal application dependent parts 
example class sensor update calculation strategy defined shown 
sensor strategies update strategy calculation strategy 
layers instantiate default strategy class allow replacement new strategy specifying method replacing strategy object 
class sensor layers update strategy delegate set calculate strategy delegate set class sensor evaluation 
evaluating layer type respect original design pattern specification identify strategy layer type implements complete functionality pattern intuitive way 
addition solves identified problems related traceability self problem implementation overhead 
traceability obviously improved layer type explicitly specifies design pattern implements 
due delegating behaviour layer original receiver message stored self problem occur 
strategy object directed originally message receiving object 
similarly self calls methods implemented strategy object intercepted layer delegated strategy object 
strategy layer type requires minimal implementation effort software engineer 
relevant aspects need specified overhead due message forwarding occurs 
mediator intent 
mediator design pattern encapsulates interaction set objects 
mediator decreases coupling objects refer directly 
mediator replaced independently allowing vary interaction objects 
problem 
implementation approach mediator design pattern decouple functionality object interaction objects 
interaction group objects encapsulated separate object indicated mediator 
shown class mediator object set mediates 
object set colleague mediator 
sending message colleagues directly sends message forward message appropriate object 
approach separates functionality object interaction objects making reusable flexible identify problems implementation traditional objectoriented language 
mediator consists set methods called colleague objects 
methods general consist call colleague object supposed take care message 
leads second problem structure interactions objects lost implementation traced design implementation 
mediator colleague 
structure design pattern solution 
solution layer type mediator proposed 
mediator layer part mediator class contains specification interactions objects 
syntax mediator layer type shown 
id mediator forward mess sel client object forward mess sel client object 
semantics mediator layer message mess sel set message selectors sent client object client forwarded object object 
client specification client categories layom 
software engineer specify client category relevant subset interacting objects 
defined client category matching possible clients 
example shown 
layer forwards messages object messages sent object object 
class layers med mediator forward forward class evaluation 
mediator layer type solves identified problems 
software engineer write series methods forwarding purposes 
specification single layer sufficient 
secondly layer specification shows clearly structure interaction objects 
traceability preserved 
composition design pattern layer types discussed section layer types implementing design pattern abstractions freely composable class descriptions instance declarations 
layers functioning message interception message proceeds intended destination message intercepted layers 
layers affect contents message implicitly trigger actions 
instance layer type adapter layer type mediator composed class 
adapter change selector certain messages mediator forward message colleague objects group due incompatible interfaces 
type composability important object oriented software development design patterns object oriented framework development 
designers increasingly making design patterns design mechanisms describing designs software engineers 
consequence classes design play role design patterns 
intertwining various patterns implementation classes traditional object oriented language may result complicated structures 
increased complexity poor traceability individual design patterns obviously important effective design patterns 
implementation classes layom suffer problems 
related author specifically addresses implementation aspects patterns 
discusses implementation design patterns identified problems 
patterns get lost implementation 
second composed patterns lead large clusters mutually dependent classes 
third design pattern authors classes implementation design patterns library concrete design pattern classes described 
addresses implementing design patterns classes 
evaluating approach conclude traceability design patterns implementation improved 
pattern classes uncertain patterns implemented classes 
consider patterns patterns addressed unsuited representation classes 
second aspect implementation efficiency problems addressed approach 
kim benner discuss implementation observer pattern 
identified observer pattern proposed gamma leaves room implementation 
authors propose implementation patterns address issue remain conventional object oriented paradigm 
tool automatic code generation design patterns described 
authors identified problems implementation patterns designers difficulty converting patterns code designers consider implementing chore avoid 
solution tool developed allows user specify application specific aspects pattern tool generates output code incorporated system 
similarities approach layom model code generator generating code conventional object oriented language main difference layom provides integrated language model tool results level integration 
addition uncertain traceability problem self problem addressed 
problems associated implementation design patterns traditional object oriented languages identified discussed 
problems categorised lack traceability design patterns implementation self problem pattern implementations suffer lack reusability design pattern implementations implementation overhead software engineer implementing design pattern 
solution context layered object model introduced 
layered object model layom extended extensible object model 
extended contains states categories layers additional components 
layom extensible object model extended new components new layer types 
identified problems addressed defining layer type design pattern 
design patterns adapter bridge composite facade state observer strategy mediator associated layer types examples applicability approach 
illustrated layers suffer aforementioned problems 
consider layered object model superior approach practitioners layom supported advanced implementation environment translates layom classes applications code 
generated code combination arbitrary programs generate applications 
software engineer layom advantages extended expressiveness avoids potential disadvantages limited particular environment language environment generates code 
second advantage layered object model supporting environment briefly mentioned extensibility object model 
allows software engineer define layer types design patterns available 
able extend compiler relatively easy due fact constructed concept delegating compiler objects 
part intend study design patterns different sources incorporated layered object model 
authors reported application domain specific design patterns 
extensibility layered object model suitable incorporate design patterns 
michael bosch provided valuable comments earlier versions 
alexander 
alexander ishikawa silverstein jacobson king angel pattern language oxford university press new york 
bosch 
bosch layered object model investigating paradigm extensibility ph dissertation department computer science lund university november 
bosch 
bosch relations object model components journal programming languages vol 
pp 

bosch 
bosch abstracting object state accepted publication object oriented systems 
bosch 
bosch delegating compiler objects object oriented approach crafting compilers proceedings compiler construction pp 

bosch 
bosch object oriented framework measurement systems draft university ronneby october 

vlissides yu automatic code generation design patterns ibm systems journal vol 

buschmann meunier 
buschmann meunier system patterns pattern languages program design coplien schmidt eds pp 
addison wesley 
buschmann 
buschmann kel meunier rohnert stahl pattern oriented software architecture system patterns john wiley sons 
coad 
coad object oriented patterns communications acm vol 
pp 
september 
coplien schmidt 
coplien schmidt patterns languages program design addison wesley 
foote yoder 
foote yoder architecture vlissides gamma 
gamma helm johnson vlissides design patterns elements reusable object oriented software addison wesley 
goldberg robson 
goldberg robson smalltalk language addison wesley 
helm 
helm holland contracts specifying behavioral compositions object oriented systems oopsla pp 

kim benner 
kim benner implementation patterns observer pattern vlissides 
lieberman 
lieberman prototypical objects implement shared behavior object oriented systems proceedings oopsla pp 


object oriented frameworks survey methodological issues licentiate thesis preparation department computer science lund university 
pree 
pree design patterns object oriented software engineering addison wesley 

implementing patterns pattern languages program design coplien schmidt eds pp 
addison wesley 
vlissides 
vlissides coplien pattern languages program design addison wesley 

