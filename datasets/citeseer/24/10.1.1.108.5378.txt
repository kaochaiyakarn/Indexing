arxiv cs cs ds jun fault tolerant routing peer peer systems james aspnes zo shah february consider problem designing overlay network routing mechanism permits finding resources efficiently peer peer system 
argue existing approaches problem modeled construction random graph embedded metric space points represent resource identifiers probability connection nodes depends distance metric space 
study performance peer peer system nodes embedded grid points simple metric space dimensional real line 
prove upper lower bounds message complexity locating particular resources system variety assumptions failures nodes connections 
lower bounds particular show inverse power law distributions routing suggested kleinberg close optimal 
give efficient heuristics dynamically maintain system new nodes arrive old nodes depart 
give experimental results suggest promising directions 
peer peer systems distributed systems central authority varying computational power machine 
study problem locating resources large network heterogeneous machines subject crash failures 
describe construct distributed data structures certain desirable properties allow efficient resource location 
decentralization critical feature system central server provides vulnerable point failure wastes power clients 
equally important scalability cost borne node depend network size ideally proportional polylogarithmic factors amount data node seeks provides 
expect nodes arrive depart high rate system resilient extended version appearing proceedings acm symposium principles distributed computing department computer science yale university new haven ct usa 
email aspnes cs yale edu 
supported nsf ccr ccr 
department computer science yale university new haven ct usa 
email cs yale edu 
supported part onr 
department computer science yale university new haven ct usa 
email shah yale edu 
supported nsf ccr ccr 
link node failures 
furthermore disruptions parts data structure self heal provide self stabilization 
approach provides hash table functionality keys uniquely identify system resources 
accomplish map resources points metric space directly keys keys hash values 
mapping dictates assignment nodes metric space points 
construct maintain random graph linking points greedy routing traverse edges find data items 
principle rely failures leave smaller random graph ensuring system robust face considerable damage 
compelling advantage random graphs eliminate need global coordination 
get fully distributed egalitarian scalable system bottlenecks 
measure performance terms number messages sent system search insert operation 
self repair mechanism may generate additional traffic expect amortize costs search insert operations 
growing storage capacity machines concerned minimizing storage node case space requirements small 
information stored node consists network address neighbor 
rest organized follows 
section explains model detail section describes existing peer peer systems 
prove results routing section 
section heuristic method constructing random graph provide experimental results show performance practice 
section describes results experiments performed test routing performance constructed distributed data structure 
discussed section 
approach idea underlying approach consists basic parts embed resources points metric space construct random graph appropriately linking points efficiently locate resources routing greedily edges graph 
set resources spread large heterogeneous network resource owner denotes node provides key denotes resource key 
set possible keys 
assume hash function resource maps point key metric space point set distance metric shown 
hash function assumed populate metric space evenly 
note resource embedding node mapped set vn key owner set metric space points assigned resources node provides 
step carefully construct directed random graph points embedded assume newly arrived node initially connected node node generates outgoing links vertex vn independently 
link vn vm simply denotes knows network node provides resource mapped view graph virtual overlay network information pieces stored locally node 
node constructs link executing search algorithm locate resource mapped sink link 
metric space populated densely choice sink may result vertex corresponding absent resource 
case chooses neighbor closest original sink 
moving nearby vertices nodes actual route physical network resources physical links keys hash virtual links virtual overlay network example metric space embedding 
virtual route introduce bias link distribution magnitude error appear large 
detailed description graph construction section 
having constructed overlay network information resource location 
new nodes arrive old nodes depart existing ones alter set resources provide crash resources available distributed database change 
time set available resources corresponding overlay network 
request node locate resource time served simple localized manner calculates metric space point corresponds request message routed vertex vn closest 
node needs local information set neighbors participate resource location 
routing done greedily forwarding message node mapped metric space point close possible 
problem resource location translated routing random graphs embedded metric space 
approximation approach similar small world routing kleinberg points dimensional grid connected links drawn normalized power law distribution exponent routing done having node route packet neighbor closest packet destination 
kleinberg approach somewhat brittle assumes constant number links leaving node 
getting performance technique depends having complete dimensional grid nodes carefully adjusting exponent random link distribution 
interested keeping degree accept larger degree get robustness 
assume complete grid fault tolerance main objectives nodes mapped points metric space resources provide may missing nodes 
random graphs partly motivated desire keep data structure scalable routing algorithm decentralized possible random graphs constructed locally global coordination 
important reason random graphs nature robust node failures node induced subgraph random graph generally random graph disappearance vertex incident links due failure machines implementing data structure allow routing repair mechanism note generally changes time may specifically change request served request message may routed series different overlay networks 
trying heal damage 
repair mechanism benefits random graphs random structures require maintain weaker invariants compared organized data structures 
embedding graph metric space important property information needed locate resource location corresponding metric space point 
location permanent sense unaffected disruption data structure easily computable node seeks resource 
pattern links nodes may damaged destroyed failure nodes underlying communication network metric space forms invulnerable foundation build ephemeral parts data structure 
current peer peer systems peer peer systems widespread scalable 
napster central server services requests shared resources actual resource transfer takes place peer requesting resource peer providing involving central authority 
disadvantages including vulnerable single point failure wasted computational power clients scalable 
gnutella floods network locate resource 
flooding creates trade overloading node network request cutting searches completion 
super peers problem somewhat practice improve performance limit 
generation systems inspired development sophisticated ones chord tapestry :10.1.1.105.3673
partitions dimensional metric space zones 
key mapped point zone stored node owns zone 
node stores information resource location done greedy routing takes dn time 
chord maps nodes identities bits placed modulo identifier circle 
resources stored existing successor nodes nodes mapped 
node stores routing table entries th entry stores key node succeeding identifier circle 
resource mapped identifier circle stored node succeeding location maps 
routing done greedily farthest possible node routing table hard see gives log delivery time nodes system 
tapestry uses plaxton algorithm form suffix hypercube routing routing mechanism algorithm message forwarded deterministically node identifier digit closer target identifier 
node maintains log pieces information delivery time log 
systems vastly different recurrent underlying theme variant overlay metric space nodes embedded 
location resource metric space determined key 
node maintains information neighbors metric space routing simply done forwarding packets neighbors closer target node respect metric 
metric space explicitly defined coordinate space covered zones distance metric simply euclidean distance 
chord nodes thought embedded grid points real circle distances measured circumference circle providing required distance metric 
tapestry think nodes embedded real line identifiers simply locations nodes real line 
euclidean distance metric distance greedy forwarding nodes identifiers closest target node 
inherent common structure leads similar results performance networks 
explain systems achieve similar performance guarantees describing general setting overlay metric spaces results apply dimensional spaces 
general fault tolerance properties systems defined 
system provides repair mechanism failures performance guarantees till mechanism kicks 
large systems nodes appear leave frequently resilience repeated concurrent failures desirable important property 
experiments show overlay space linking strategies system performs reasonably large number failures 
routing section lower upper bounds routing 
consider greedy routing graph embedded line node connected immediate neighbors multiple long distance neighbors chosen fixed link distribution 
give lower bounds greedy routing link distribution satisfying certain properties theorem 
upper bounds model long distance links chosen inverse power law distribution exponent analyze effects performance presence failures 
tools upper bounds proved known upper bound karp probabilistic recurrence relations 
restate bound lemma show similar technique get lower bounds additional conditions theorem 
lemma time needed nonincreasing real valued markov chain drop bounded dz xt xt xt nondecreasing function bound nice physical interpretation 
takes second jump meters traveling rate meters second interval 
zip past position traveling average speed determined starting point interval 
nondecreasing estimated speed underestimates actual speed passing integral computes time get way zero instantaneous speed passing position estimate speed low average estimate time high giving upper bound actual expected time 
get lower bounds processes addition upper bounds necessarily able guarantee defined lemma nondecreasing function basic intuition average speed pass maximum average speed jump takes past find maximum speed maximum unfortunately may give large estimate 
choose threshold short jumps compute maximum speed short jumps handle hopefully rare long jumps conditioning 
subject conditioning define upper bound mz average speed passing essentially integral get lower bound time 
additional account effect conditioning gives real lower bound appears theorem inequality 
theorem markov process state space constant 
non negative real valued function constants satisfy define define proof define pr xt xt xt 
pr xt xt xt 
min xt 
xt xt xt xt xt 
mz sup mz dz 

xt xt yt xt 
idea yt drops zero immediately long jump occurs 
show jumping yt drop quickly average 
intuition chance long jump reduces yt expected yt effect short jumps bounded applying definition ft algebra generated 
xt 
event xt xt jump xt xt short jump 
compute yt yt ft pr ft yt pr ft yt yt ft pr ft pr ft yt yt ft yt yt ft 
bound yt yt ft 
expanding definitions gives xt yt yt ft dz ft 
xt mz conditioning means xt xt xt entire range integral 
follows xt lies half open interval plugging mz xt 
inverting gives mz xt inequality gives xt yt yt ft dz ft xt xt xt xt ft xt xt xt 
applying gives yt yt ft 
shown yt drops slowly average 
turn lower bound time reaches zero define zt yt min 
conditioning observe zt zt ft yt yt ft alternatively 
zt zt ft 
case zt zt ft implying zt zt ft 
words zt ft 
zt ft stopping time relative ft 
solving gives lower bounds greedy routing show lower bound expected time taken greedy routing random graph embedded line 
node graph expected outdegree connected immediate neighbor side 
polylogarithmic values consider variants greedy routing algorithm derive lower bounds equal log log log log log log stated theorem 
routing variants machinery proofs associated lower bounds sections 
large lg values lower bound lg worst case routing time derived simply follows 
theorem lg nc 
link distribution routing strategy delivery log time log 
proof links node reach nodes step assuming minimum time reach nodes log gives lower bound lower bound polylogarithmic number links consider case expected outdegree node falling range lg 
probability node position connected positions 
depends set independent choice outgoing links nodes 
assume node connected immediate neighbors require appears 
consider variants greedy routing algorithm 
loss generality assume target search labeled 
sided greedy routing algorithm traverses link take past target 
algorithm currently trying reach move node smallest non negative label 
sided greedy routing algorithm chooses link minimizes distance target regard side target link sided case algorithm move node label smallest absolute value ties broken arbitrarily 
sided greedy routing thought modeling algorithms graph boundary target lies boundary algorithms links point direction chord 
results stronger sided case sided case 
sided greedy routing show lower bound log log log time reach point chosen uniformly range applies link distribution 
sided routing show lower bound log log log constraints distribution 
conjecture constraints unnecessary log log log correct lower bound models 
formal statement results appears theorem section prove develop machinery useful proofs sided sided lower bounds 
link sets notation distributions describe notation sets 
write assume nodes labeled integers identify node label avoid excessive notation 
log random variable drawn distribution finite sets individual general independent 
consist negative elements consist positive elements 
formally define sided routing assumptions distribution finite expectation contains 
sided routing assume generated including possible probability symmetric origin unimodal nonincreasing positive nondecreasing negative 
require events pairwise independent distinct aggregate chain fixed distribution trajectory single initial point markov chain determines outgoing links node reached time successor function selects node routing algorithm 
note chain markov presence links guarantees node appears twice sequence new node corresponds new choice links 
chain derive aggregate chain describes collective behavior nodes range 
state aggregate chain contiguous sets nodes labels sign define sign state common sign elements 
sided routing state interval form sided routing states general aggregate states characterized formally lemma 
contiguous set nodes set define 
intuition consists nodes algorithm choose outgoing link 
note contiguous range greediness algorithm 
define sgn 
simply split nodes negative zero positive successors 
set integer write 
build aggregate chain letting successors range ranges possible 
special case define arrive target leave 
pr st st define unconditional transition probabilities averaging 
lemma shows moving aggregate chain underlying chain constraints imply formally imagine ignored routing algorithm 
lemma drawn uniformly range uniformly chosen element pr pr 
proof clearly lemma holds 
fix st consider methods generating generates directly shows generated way distribution xt second generates st describe lemma produces distribution 
method choose uniformly st choose random compute transition rule applied xt induction hypothesis xt equal distribution xt second method choose random choose st choosing proportion size st uniformly chosen element st implement choice choosing uniformly st picking subrange contains simplify task choosing setting equal conditioning leaves uniform distribution 
implementing second method way reduced lemma proved 
lemma justifies earlier characterization aggregate state spaces lemma sided routing form sided routing interval integers element sign 
proof induction sided routing observe empty routing algorithm allowed jump negative nodes 

contains point greater contain min min 
result sided case immediate fact combined definition advantage aggregate chain single point chain bound progress single point arbitrary distribution show size drop quickly bound 
intuition successor set size occurs probability sets average 
lemma 
sided sided model pr 
proof fix note pr 
assume particular 
conditioning non empty sets st chosen probability 
probability choosing sets size observe pr pr da way write say pr ln ln ln give bound probability large jumps comes time apply theorem 
boundary points lemma says seldom drops large ratio doesn tell quickly drops short hops 
bound quantity need get bound subranges action 
showing certain points appear boundaries subranges direction 
fixed define set finite lemma fix defined 
suppose positive 
min set minimum elements subranges subset contains elements 
min 


case holds sided routing 
negative symmetric condition holds max 
proof consider subrange contains min case holds 
second case holds third case holds fourth case holds min odd depending tie breaking rule assigns 
call elements boundary points bounding changes ln lemmas lemma get upper bound rate ln drops function distribution 
lemma bound sum arises lemma 
lemma 
xi xi xi greater set xi greater xi ln xi xi ln max 
proof xi left hand side ln interesting case elements 
xi nc bc 
xi ln xi convex sum minimized fixed xi setting xi equal case left hand side simply ln xi observe setting xi equal gives xi nc bc nc nc lemma fix positive range define lemma 
min max 
event ln ln ln ln ln ln st pr st sided routing sided routing 
proof call subrange large small intent large ranges precisely yield ln ln ln observe large implying large set elements 
large max min 
similarly min max 
large intersects point 

tk set subranges large small intersect immediate definition tj 
lemma characterize elements follows 

set tj contains min tj 

set tj min tj 
set tj min tj 
sided routing set tj min tj min tj note may set minimum element min set accounted case 
elements sided routing elements sided routing 
conditioning equal large large tj large tj chosen proportional size fixed ln tj ln tj tj ln max ln inequality follows lemma 
compute ln ln ln ln ln ln ln ln st ln st ln st ln st pr st ln ln st pr st second step ln ln pr follows ln ln pr ln pr 
step ln ln follows concavity ln jensen inequality 
putting pieces tools need prove lower bound 
theorem random graph nodes labeled integers 
set integer offsets chosen independently common distribution subject constraint node outgoing link 
consider greedy routing trajectory starting point chosen uniformly 
sided routing expected time reach log 
log log sided routing expected time reach log log log provided generated including probability unimodal symmetric choices include particular pairwise independent 
proof 
going apply theorem sequence ln 
chosen reach target lower bound gives lower bound expected time routing algorithm 
apply theorem need show probability ln drops large amount small integral large 
ln lemma pr st st st ln pr ln st ln st ln st ln satisfies ln ln second step theorem requires bound speed change solely function 
sided routing problem lemma shows reveals characterizes exactly lower bound argument done 
sided routing situation complicated may st form 
st need bound speed ln st drops applies equally sets size 
purpose purpose conditions sided routing 
suppose appears probability probabilities pairwise independent sequence symmetric unimodal 
absolute ceiling 
observe effect counting midpoints pairs distinct elements regard elements adjacent 
expected number distinct pairs bk pk ipi convolution non negative symmetric unimodal sequence symmetric unimodal 
follows bk bk similarly 
punch line sgn upper bound expected number distinct pairs put turn upper bound pr grossly counts elements particular gives bound ordering property means bound expected number elements appear subrange positive st bound expected number elements appear corresponding subrange 
st similarly negative st 
pi satisfies similar ordering property bound number elements hit fixed subrange st st 

convenience formally define pi pr qi sided routing 
simplify summations summing pi qi certain pre defined intervals 
integer ai ai ai 
ai pi qi 
note ai sided routing ai ai sided routing 
observe sided routing sided routing 
consider st event ln st ln st ln lemma ln ln ln ln st pr st sided routing sided routing min max case lemma 
observed earlier choice lemma imply pr ln st ln st ln st ln pr st pr ln st ln st ln st ln sufficiently large replace ln ln ln ln obtain bound terms pi qi 
sided routing fact implies 

sided routing monotonicity pi qi replace 
particular replace sum pi qi subrange sum subrange 
large 
case get ln ln ln st ln st st bounded ln ln ln pi qi pi qi provided set ln ln compute mz defined 
ln mz ln larger observe mz sup mln ez ez bounds sum lie ez ln 
compute mz ln ln ln ln ae pi qi ln ln mz ln ln dz lnn ln get lower bound sum note ln ln ln ln dz ln ln ln sided routing sided routing 
case convex decreasing ln ln ln ln ln ln ln ln ln ln ln ln lnn ln ln ln lnn ln 
rewrite bound ln convenient asymptotic form 
ignore concentrate large fraction 
recall ln ln ln ln ln 
polynomial ln ln numerator simplifies ln 
look denominator 
consider term ln 
rewrite term ln goes zero grow ln ln 
term contribute 
turning second term fact ln 
ln ln ln ln ln log log log log bound simplifies log log log log assume log bound degenerates rewrite simply log log large approximation ln ln useful 
case simplifies ln ln ln natural interpretation terms tree successor nodes single starting node gives essentially bound theorem 
quite done theorem need plug get lower bound 
simply observe log denominator goes rapidly 
stated bounds obtained substituting possible strengthening lower bound examining proof theorem appears bound sided routing extra conditions imposed distribution arise artifacts need project range 
reduce problem tracking single parameter 
believe sophisticated argument collapse ranges show stronger result conjecture theorem 
consider greedy routing trajectory starting point chosen uniformly 
expected time reach log log log sided sided routing constraints distribution 
believe bound continues hold higher dimensions 
unfortunately fact embed line say dimensional grid justify belief divergence side line may change distribution boundaries segments break proof theorem 
upper bounds section upper bounds delivery time messages simple metric space dimensional real line 
simplify theoretical analysis system set follows 
nodes embedded grid points real line 
node connected nearest neighbor side neighbors 
long distance neighbors chosen inverse power law distribution exponent long distance neighbor chosen probability inversely proportional distance formally pr ith neighbor distance nodes metric space 
routing done greedily forwarding message neighbor closest target node 
analyze performance cases single long distance link multiple ones failure free network network link node failures 
note say node refer vertex virtual overlay network physical node earlier sections 
single long distance link analyze delivery time idealized model failures long distance link node 
kleinberg proved nodes embedded grid points dimensional grid node connected immediate neighbors long distance neighbor chosen probability proportional message delivered time polynomial log greedy routing 
result directly applied model give log delivery time get simpler proof lemma 
include proof completeness 
theorem node connected immediate neighbors distance neighbor chosen probability inversely proportional distance node 
expected delivery time nodes network 
possible distances covered source node proof expected number nodes crossed message node distance destination 
clearly non decreasing 
hn hn hn 
hn hn clearly non decreasing lemma get hn 
hn distribution delivery time logarithmic number nodes 
multiple long distance links interesting question improve log delivery time multiple links single 
addition improvement performance multiple links give benefit robustness face failures 
look improvement performance multiple links system go analysis failures section 
suppose links node 
consider different strategies generating links routing depending number links ranges lg lg 
kleinberg uses group structure get delivery time log case polylogarithmic number links 
uses complicated algorithm routing obtain bound case line greedy routing 
upper bound consider randomized strategy link distribution lg 
theorem node connected immediate neighbors distance neighbors chosen independently replacement probability proportional distances node 
lg 
expected delivery time log 
multiple long distance links node 
proof basic idea proof comes kleinberg model 
kleinberg considers dimensional grid nodes grid point 
delivery message divided phases 
message said phase distance current node destination node lg phases 
proves expected time spent phase log giving total upper bound log delivery time 
phase structure model proof similar lines 
multiple link model node long distance neighbors chosen replacement 
probability chooses node long distance neighbor get lower bound probability follows notice long distance neighbor lg lg probability chooses hn suppose message currently phase phase step message enter set nodes bj distance destination node nodes bj distance message enters bj probability hn hn xj total number steps spent phase xj pr xj hn hn denotes total number steps lg xj linearity expectation get ex lg hn log 
lg deterministic strategy 
represent location node number base generate links nodes distances 
log 
routing done eliminating significant digit distance step 
distance log get log 
strategy similar spirit plaxton algorithm 
special cases instructive 
log node link nodes directions distances log provided nodes distances 
gives log 
similarly 
links established directions existing nodes distances 

giving 
fact fixed theorem choose integer 
log node link nodes distances 

log 
delivery time log 
proof dt distances successive nodes delivery path target distance source node dt 
di ki 
log ki di ki di ki node connected node distance di bk 
get di di ki di ki di mod ki ki ki drops step 
log get log 
failure links appears linking strategies may fail give delivery time case links fail 
show get reasonable performance link failures 
model assume link independently probability look randomized strategy number links lg 
link prob 
absent link long distance link probability proof similar lines proof case failures 
intuitively links fail expect spend time phase time inversely proportional probability links 
prove expected time spent phase log gives total delivery time log 
assume links immediate neighbors message delivered takes long 
theorem model theorem 
assume links immediate neighbors 
probability long distance link expected delivery time log 
proof recall case link failures probability chooses node long distance neighbor consider link failures chose long distance neighbor probability link probability chooses node long distance neighbor pq hn rest proof proof theorem 
xj number steps spent phase xj pr xj hn denotes total number steps linearity expectation get ex lg hn log 
turn deterministic strategy lg links 
similar intuition works lg 
link fails node take shorter long distance link take message close target initial failed link 
clearly decreases message take shorter shorter links increases delivery time 
analysis simpler change link model bit node connected nodes distances log compute expected distance covered current node lemma get delivery time blog 
decreases delivery time increases decreases delivery time decreases information stored node increases 
theorem number links log node link distances 
log assume links nearest neighbors 
probability link delivery time 
proof distance current node destination represent distance covered starting node 
probability link covering distance log link absent probability cover distance log single link probability pq 
general average distance covered message distance destination pb log log 
pq log log log pb log pb log log pb log log log log lemma get failure nodes bk 
consider different cases node failures study effect system performance 
case described section nodes may fail remaining nodes link link distribution 
second case explained section nodes link neighbors nodes may fail 
binomially distributed nodes probability node point 
node connected nearest neighbors long distance neighbor 
addition probability choosing particular node long distance neighbor conditioned existence node 
theorem model theorem 
node probability nodes link existing nodes 
worst case expected delivery time log 
proof bound expected drop follows hn hn hn lemma get get section nodes 

exactly result result surprising nodes link existing nodes difference get smaller random graph 
affect routing algorithm delivery time 
general failures observe analysis node failures simple link failures longer important property independence case 
case link failures nodes choose neighbors possible links fail event node connected node completely independent event say neighbor connected node 
link fails independently accessibility target node node depends presence link nodes question 
case node failures important independence property longer true 
suppose node communicate node failed may functional link probability node able communicate independent probability communicate probability absent common cases 
complicates analysis performance longer case node communicate node chance doing passing message neighbor 
order analyze situation consider jumps phase lower jumping phases 
idea jumps phases independent move phase phase routing longer depends nodes phase condition number nodes alive lower phase estimate time spent phase 
intuitively node probability expect wait time inversely proportional anticipation finding node lower phase jump 
theorem model theorem node fail probability expected delivery time log 
proof time taken drop layer layer 
nodes alive layer probability node layer connected node layer 
expected time drop layer live nodes ql vary 
note live nodes lower layer routing fails point 
get ql pn pn surprisingly expected waiting time layer inversely proportional probability connected node lower layer probability node alive 
randomized routing strategy lg links hn 
lg layers get expected delivery time log 
contrast deterministic routing strategy certain carefully chosen node failures lead situations message get stuck local neighborhood hope getting eventually reaching destination node 
conjecture low probability event occurrence affect delivery time considerably 
analyzed situation formally 
construction graphs group nodes network changes graph virtual overlay network 
order routing techniques effective graph exhibit property likelihood vertices connected 
describe heuristic approach construct maintain random graph invariant 
choice links leaving vertex independent choices vertices assume points metric space added time 
th point added 
point chooses sinks outgoing links inverse power law distribution exponent connects running search algorithm 
desired sink connects closest live neighbor 
effect points surrounded basin attraction collecting probability mass proportion length 
assume hash function populates metric space evenly absolute symmetry basin length distribution points 
easy see high probability smaller expectation prob lower bound probability link point basin farthest bound holds points added aforementioned probability means need amend linking strategy transfer probability mass case having arrived case having arrived describe accomplish task 
new point 
give earlier points opportunity obtain outgoing links having calculate number incoming links points added arrived choose points inverse power law distribution exponent 
number outgoing links point expected number incoming links estimate step 
approximate number links poisson distribution rate probability incoming links 
expectation distribution 
step completed chosen point responds request choosing existing links replaced link choice link replace vary 
strategy builds 
authors ideas zhang build graph node single long distance link node distance probability node long distance link distance encounters new node distance due arrival due data request replaces existing link probability pi di links new node 
extend idea case multiple long distance links 
consider node neighbors distances 
dk 
new node distance dk requests incoming link replaces existing links link probability pk pj 
trivial extension formula 
probability distributed existing long distance links needs choose redirect choose inverse power law distribution exponent chooses replace link node distance di probability pi pj 
probability decides link decides replace existing link node distance di link equal pi pj pk pj 
notice may decide redirect existing links probability pk pj 
intuition replacement strategy comes invariant want maintain dynamically new nodes arrive link node distance di probability inversely proportional di conditioning constant absorbed normalizing constant distribution 
easily calculated link probabilities symmetric 
having long distance links equation hold 
prob replaces link link prob link arrives prob link arrives pi pj pi pj pi pj pk pj heuristic regeneration links node crashes 
analyze performance heuristic practice construct network nodes links separate times 
averaging results networks plotted distribution long distance links derived heuristic ideal inverse power law distribution exponent shown 
see derived distribution tracks ideal closely largest absolute error roughly equal links length shown graph 
performed experiments alternative link replacement strategy node chooses oldest link replace link new node 
performance strategy performance replacement strategy described previously 
omit results difficult distinguish results strategies scale graphs 
related construct support central server random graphs desirable properties small diameter guaranteed connectivity high probability 
clear kind fault tolerance properties approach offers central server crashes constructed graph efficient routing similar techniques useful setting 
experimental results simulated network nodes application level 
node connected immediate neighbors lg long distance links chosen inverse power law distribution exponent explained section 
routing done greedily forwarding message neighbor closest target node 
simulation network set afresh fraction nodes fail 
repeatedly choose random source destination nodes failed route message 
value ran simulations delivering messages simulation averaged number hops successful searches number failed searches 
node failures node may able find live neighbor closer target node 
studied possible strategies overcome problem follows 

terminate search 

randomly choose node deliver message new node try deliver message node original destination node similar hypercube routing strategy explained 
probability link derived ideal length link derived distribution 
absolute error derived length link absolute error 
distribution long distance links produced inverse distance heuristic derived compared ideal inverse power law distribution exponent ideal 
absolute error derived distribution ideal inverse power law distribution exponent 
keep track fixed number simulations nodes message routed backtrack 
search reaches node proceed backtracks visited node list chooses best neighbor route message 
strategies note node chooses best neighbor send message link finds best neighbor failed 
shows fraction messages fail delivered number hops successful searches versus fraction failed nodes 
see system behaves large number failed nodes 
addition backtracking gives significant improvement reducing number failures compared methods may take longer time delivery 
see case random rerouting average delivery time increase probability node failure increases 
happens quite searches fail ones succeed hops lead small average delivery time 
results may directly comparable chord different simulators experiments :10.1.1.105.3673
extent results comparable methods appear perform theirs 
just terminate search get fraction failed searches fraction failed nodes 
chord roughly performance network stabilizes repair mechanism :10.1.1.105.3673
backtracking see failed nodes get failed searches 
results promising interesting study backtracking analytically 
compared performance ideal network network constructed heuristics section 
ran iterations constructing network nodes ideally heuristic delivered messages fraction failed searches failed searches random re route backtracking fraction failed nodes fraction failed searches 
delivery time failed search random re route backtracking fraction failed nodes average delivery time successful searches 
fraction messages fail delivered function fraction failed nodes 
average delivery time successful searches function fraction failed nodes 
randomly chosen nodes 
shows number failed searches probability node failure increases 
see network constructed heuristic perform ideal network number failed searches comparable 
fraction failed searches constructed network ideal network probability node failure fraction failed searches 
model number links upper bound lower bound failures pr link log log log log lg log log log log lg nc log log log log lg log lg nc log pr node lg log table summary upper lower bounds routing 
table summarizes upper lower bounds 
shown greedy routing overlay network organized random graph metric space nearly optimal mechanism searching peer peer system presence faults 
see important step design efficient algorithms networks issues need addressed 
results apply dimensional metric spaces line circle 
interesting possibility similar strategies higher dimensional spaces particularly ones dimensions represent actual physical distribution nodes real space network building search mechanisms model allow efficient location nearby instances resource having resort local flooding 
promising direction study security properties greedy routing schemes see adapted provide desirable properties anonymity robustness byzantine failures 
acknowledgments authors grateful ben pointing error earlier version lemma 
gnutella 
gnutella wego com 
joseph kubiatowicz zhao 
tapestry infrastructure fault tolerant wide area location routing 
technical report ucb csd university california berkeley apr 
karp upfal wigderson 
complexity parallel search 
journal computer system sciences 
upper bound lg links number links logb 
deterministic strategy links lg link failures slightly different failures log 
lower bound column bound lg links sided routing 
kempe kleinberg demers 
spatial gossip resource location protocols 
proceedings rd annual acm symposium theory computing pages crete greece july 
kleinberg 
small world phenomenon algorithmic perspective 
proceedings nd annual acm symposium theory computing pages portland oregon usa may 
kleinberg 
small world phenomena dynamics information 
dietterich becker ghahramani editors advances neural information processing systems cambridge ma 
mit press 
morpheus 
www com 
napster 
www napster com 
raghavan upfal 
building low diameter networks 
proceedings nd annual ieee symposium foundations computer science focs pages las vegas nevada usa oct 
plaxton richa 
accessing nearby copies replicated objects distributed environment 
proceedings ninth annual acm symposium parallel algorithms architectures spaa pages newport ri usa june 
ratnasamy francis handley karp shenker 
scalable content addressable network 
proceedings acm sigcomm pages san diego ca usa aug 
roychowdhury 
random structure optimum cache size distributed hash table dht peer peer design 
oct 
arxiv org abs cs ni 
stoica morris karger kaashoek :10.1.1.105.3673
chord scalable peerto peer lookup service internet applications 
proceedings sigcomm pages san diego ca usa aug 
valiant 
scheme fast parallel communication 
siam journal computing 
zhang goel govindan 
small world model improve freenet performance 
proceedings ieee infocom new york ny usa june 

