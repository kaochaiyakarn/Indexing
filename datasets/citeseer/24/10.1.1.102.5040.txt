arxiv cs cs lo jan institut informationssysteme 
systeme technische universit wien wien austria tel fax sek kr tuwien ac www kr tuwien ac institut informationssysteme abteilung systeme computing preferred answer sets meta interpretation answer set programming thomas eiter wolfgang faber nicola leone gerald pfeifer infsys research report january infsys research report infsys research report january computing preferred answer sets meta interpretation answer set programming thomas eiter wolfgang faber nicola leone gerald pfeifer 
answer set programming asp attracting interest new paradigm problem solving 
important aspect needs supported handling preferences rules approaches 
consider problem implementing preference handling approaches means meta interpreters answer set programming 
particular consider preferred answer set approaches brewka eiter delgrande schaub tompits wang zhou lin 
suitable semantics dlv efficient engine asp 
meta interpreter weakly preferred answer set approach brewka eiter uses weak constraint feature dlv tool expressing solving underlying optimization problem 
consider advanced meta interpreters graphbased characterizations allow efficient computations 
approach shows suitability asp general dlv particular fast prototyping 
fruitfully exploited experimenting new languages knowledge representation formalisms 
institut informationssysteme abteilung systeme technische universit wien vienna austria 
mail eiter faber kr tuwien ac 
department mathematics university cs italy 
mail leone 
institut informationssysteme abteilung und ai technische universit wien vienna austria 
mail pfeifer dbai tuwien ac 
authors colleagues participants aaai spring symposium answer set programming comments 
supported austrian science fund fwf inf inf inf 
preliminary results appeared alessandro tran cao son editors proceedings aaai spring symposium answer set programming efficient scalable knowledge representation reasoning stanford ca march aaai press isbn 
copyright authors infsys rr handling preference information plays important role applications knowledge representation reasoning 
context logic programs related formalisms numerous approaches adding preference information proposed including mention 
approaches designed purposes capturing specificity normative preference see reviews comparisons 
example classical situation preference information 
example bird penguin consider logic program peng 
bird 
flies flies peng 
flies flies bird 
program answers sets peng bird flies peng bird flies 
assume rule higher priority iff rule highest priority rule lowest 
longer intuitive flies concluded higher priority flies concluded 
example simple various preference semantics arrive different results 
furthermore semantics coincide example may yield different results examples 
evaluating semantics number benchmark examples possibly involving rules quickly tedious task quick implementation semantics hand experimentation done computer support 
exploring large number examples helps assessing behavior semantics may performed significantly shorter time error prone manual evaluation 
address issue explore implementation preference semantics logic programs powerful technique answer set programming asp seen sort meta programming asp 
technique logic program preferences encoded suitable set facts added meta program pi intended answer sets determined answer sets logic program pi 
salient feature pi universal input programs recall meta interpretation established prolog style logic programming completely new asp similar technique applied previously defining semantics logic programming defeasible rules cf 
section 
focus similar different semantics prioritized logic programs preference semantics brewka eiter wang zhou lin delgrande schaub tompits refer preferred preferred preferred answer set semantics respectively 
asp meta programs pib pid answer sets pib pid correspond modulo simple projection function precisely preferred answer sets way running corresponding meta program dlv system compute preferred answer sets simple elegant way 
preferred answer sets provide alternate meta program pig implements graph algorithm deterministically checks answer set efficient general 
note suitable meta programs asp engines smodels 
infsys rr preferred answer set semantics refines previous approaches adding preferences default rules 
defined answer sets extended logic programs generalized reiter default logic 
important aspect approach definition preferred answer sets guided general principles argued preference semantics satisfy 
shown answer sets satisfy principles semantics 
preferred answer set semantics increasingly strengthen preferred answer set semantics 
general programs having answer set may lack preferred answer set relaxed notion weakly preferred answer sets defined 
implementing semantics provide metaprogram takes advantage weak constraints feature 
reported important respects put forward asp experimenting new semantics means meta interpretation technique 
logic programs lps provides new elegant way writing different prolog style meta interpretation 
high expressiveness disjunctive lps weak constraints meta interpreters written simple declarative fashion 
description meta programs implementing various preference semantics didactic value example way meta interpreters built asp 
particular develop core meta program plain extended logic programs answer set semantics may building block construction meta programs 
furthermore meta interpreters provided relevant se provide actual implementation preferred weakly preferred answer sets allow easy experimentation semantics practice 
knowledge implementation weakly preferred answer sets 
implementation preferred answer sets top dlv reported mapping programs framework compiled preferences 
implementation seen immediate translation definition preferred answer sets dlv code 
weak constraints encoding weakly preferred answer sets extremely simple elegant task cumbersome 
summary experience reported confirms power asp 
suggests dlv system high level machine employed powerful tool experimenting new semantics novel kr languages 
worthwhile noting meta interpretation approach aim efficiency approach fosters simple fast prototyping useful process designing experimenting new languages 
structure remainder follows section provide preliminaries extended logic programming answer set semantics 
develop section basic program extended logic programs answer set semantics 
consider section meta interpreter programs preferred preferred preferred answer answer sets 
subsequent section devoted refinement preferred answer sets weakly preferred answer sets 
discussion related provided section 
final section summarizes results draws 
infsys rr preliminaries logic programs syntax 
logic programs lps function free order language 
terms strings starting uppercase resp lowercase letters denote variables resp constants 
positive resp 
negative classical literal atom negated atom respectively complementary literal denoted respectively 
positive resp negative negation failure naf literal form classical literal 
stated literal mean classical literal 
rule formula bk bk bm 
ai bj classical literals 
part left head part right body omit 
set head literals set body literals 
bk bk 
bm sets positive negative body literals respectively 
integrity constraint rule 
datalog program lp finite set rules 
call positive free normal free 
weak constraint expression form bk bk bm 
bi literal priority level weight level 
integers set omitted 
sets defined viewing integrity constraint 
wc denotes set weak constraints usual term atom rule 
ground variables appear 
semantics 
answer sets lps weak constraints defined extending consistent answer sets lps introduced 
proceed steps define answer sets ground positive programs arbitrary ground programs optimal answer sets ground programs weak constraints 
usual optimal answer sets non ground program ground instantiation ground defined 
program herbrand universe bp set classical ground literals predicate symbols constants constant appears arbitrary constant added clause ground denote set ground instances 
ground ground 
note ground iff ground 
interpretation set bp ground literals 
consistent 
follows ground program 
consistent interpretation bp called closed positive program implies set bp answer set minimal set wrt 
set inclusion closed 
gelfond lifschitz reduct program bp program obtained deleting rules consider consistent answer sets inconsistent set bp may answer set 
infsys rr negative body literals remaining rules 
bp answer set iff answer set denote set answer sets example program answer sets 


dv 
program weak constraints interested answer sets part weak constraints minimize sum weights violated constraints highest priority level minimize sum weights violated constraints lower level expressed objective function answer set fp fp fp wc max hp lp max fp wn max max denote maximum weight maximum level weak constraint respec tively denotes set weak constraints level violated wn denotes weight weak constraint note wc wp max greater sum weights program guaranteed greater sum weights single level 
weights level multiplied fp sufficient calculate sum updated weights updated weight violated constraint greater level greater sum updated weights violated constraints lower levels 
optimal answer set wc hp minimal wc 
oas denote set optimal answer sets 
example enhance program example weak constraints resulting program single optimal answer set weight level 
meta interpreting answer set programs section show normal propositional answer set program encoded interpreted generic meta interpreter idea provide representation arbitrary normal propositional program set facts combine facts generic answer set program pia pia simple projection function 
assume integrity constraints written equivalent rules bad bad 
bad predicate occurring infsys rr representing answer set program translate propositional answer set program set facts follows 
rule 
am 
bn 
program contains facts unique rule identifier 
rule 
head 
pbl 
pbl am 

bn 

pair complementary literals occurring program explicitly add fact compl 
example program bird penguin example represented facts representing rules rule 
head peng 
rule 
head bird 
rule 
head neg flies 
pbl peng 
flies 
rule 
head flies 
pbl bird 
neg flies 
facts representing complementary literals basic meta interpreter program compl flies neg flies 
meta interpreters encounter sections consist parts program pia representing answer set checking 
section provide part common meta interpreters shown 
representing answer set 
define predicate 
true literals answer set literal answer set occurs head rule positive body definitely true negative body false 
head pos body true neg body false 
positive part body true literals answer set 
unfortunately encode universal quantification rule 
identify simple case positive body literals body trivially true 
pos body exists pbl 
pos body true rule pos body exists 
infsys rr positive body literals exist proceed iteratively 
dlv built total order constants defining successor relation positive body literals rule identify literal respectively positive rule body total order 
technically sufficient define auxiliary relations follows 
pbl inbetween pbl pbl pbl pbl pbl pbl pbl pbl pbl information define notion positive body true built order positive body literal 
positive body true literal positive body true 
pos body true upto pbl pbl 
pos body true upto pos body true upto pbl pbl inbetween 
pos body true pos body true upto pbl 
negative part body false literals answer set 
neg body false 
answer set needs consistent add integrity constraint rejects answer sets containing complementary literals 
compl 
rules described referred pia sequel need representing answer sets 
answer set pia represents answer set defined 
state theorem normal propositional program 
pia ii exists single pia proof consistent set literals head hold rule construction holds bp constraint compl 
satisfied construction bp show suffices show closed hold standard tp operator convenience denote ground pia 
show rule hr hr hr applied hr stem rule hr unique rule hr note head hr 
construction pbl induces linear ordering follows inductive argument pos body true upto holds pos body true furthermore infsys rr holds nr rule nr nr neg body false 
neg body false head construction follows hr 
hr applied hr proves 
suffices show added th step fixpoint iteration holds 
addition implies neg body false pos body true implies 
inductive argument obtain holds 
proves 
ii defined follows total order constants defined pos body true upto pos body true neg body false pos body exists pbl pbl pbl inbetween 
observe set literals defined lines call depend occur answer sets pia 
definitions directly reflect corresponding rule structure pia 
inclusion literals determined condition easy see rules defining neg body false satisfied case pos body true upto pos body true rule satisfaction seen constructive argument order 
see minimal answer set pia argument similar proof applied answer set exists added stage qa stage qa standard fixpoint operator 
inductive argument qa qa hold 
meta interpreter program pia benign property standard class programs class stratified programs easy evaluate interpreted efficiently 
recall normal propositional program stratified function associates atom integer rule satisfies 
denote program pir set rules ground pia representation literals literals rule head bpl satisfied 
proposition stratified normal propositional program 
pir locally stratified stratified viewed propositional program 
seen constructing stratification mapping suitable stratification mapping pir 
locally stratified programs efficiently handled 
intelligent grounding strategies pir efficiently computed dlv evaluation pia performed efficiently dlv stratified programs infsys rr preferred answer sets section introduce underpinnings common semantics preferred answer sets considering provide individual definitions 
prioritized programs recall adapt definitions needed current 
rest section programs tacitly assumed propositional 
definition prioritized program prioritized propositional program pair normal logic program constraints strict partial order irreflexive transitive relation 
informally means higher priority 
answer sets collection denoted 
definition full prioritization full prioritization prioritized program pair total order refining implies set full denoted fp 
call fully prioritized fp 
fully prioritized programs referred ordered sets 
rn rules ri rj iff preferred answer sets preferred answer sets introduced refinement previous approaches 
define preferred answer sets particular class fully prioritized programs 
call program prerequisite free rule holds 
furthermore literal resp set bp literals defeats rule form resp 
say rule defeats rule defeats definition 
rn fully prioritized prerequisite free program 
set bp literals sequence si bp defined follows si si si defeats ri ri defeats ri si ri 

set cb defined sn sn consistent bp 
infsys rr answer set divides rules definition groups generating rules applied contribute constructing dead rules applicable consequences add new applied appear zombies rules applicable consequences belong zombies potential render answer set non preferred 
case zombie killed generating rule higher priority 
fixpoint cb inductive construction guarantees zombies defeated generating rules higher preference 
definition preferred answer set fully prioritized prerequisite free program 
preferred answer set cb case prerequisite free kind dual gelfond lifschitz reduct computed follows 
definition fully prioritized program bp fully prioritized program set rules obtained deleting 

positive body literals remaining rules 
inherited map iff rule results step 
definition respect possible clashes rule priorities step may produce duplicate rules general 
definition preferred answer set ctd prioritized program 
fully prioritized preferred answer set iff preferred answer set preferred answer set iff preferred answer set fp 
denote set preferred answer sets example reconsider bird penguin example 
check peng bird flies preferred answer set 
determine dual reduct consists rules peng 
bird 
flies flies 
flies flies 
order coincides definition 
determine constructing sequence peng peng bird peng bird flies 
peng bird flies answer set preferred 
consider answer set peng bird flies 
dual reducts coincide means 
preferred single preferred answer set infsys rr example shows prioritized program answer set preferred 
example consider program 

single answer set 
preferred 
adapting meta interpreter extend meta interpreter answer set programs section cover prioritized answer set programs 
representing prioritized program 
prioritized program represented set facts contains plus rule preference belongs transitive reduction fact pr 
example case bird penguin example add facts pr 
pr 
pr 
checking 
definition create fully prioritized programs fp determine preferred answer sets 
add code guess total order rules refines pr vpr rule rule pr pr pr 
pr 
rules state axioms totality transitivity total order 
note possible replace disjunctive guessing rule rules involving negation 
disjunctive version readable 
build set cb definition compute sets si definitions clearly rule contribute element cb represent fact predicate lit 
observe duplicate rules arising dual reduct need special care occurrence rule relevant value cb occurrences duplicates si si hold 
definition condition ri added stated lit 
represents opposite negate condition conjunction condition interested 
call condition local defeat rules higher priority global defeat answer set 
infsys rr full prioritization refine pr total ordering 
pr pr rule rule pr pr pr 
pr 
check dual reduct build sets rule ids indices lit means literal occurs set 
lit head pos body true defeat local 
lit head pos body true defeat local defeat global 
defeat local lit pr 
defeat global 
include literal cp 
cp lit 
cp 
cp 
constraint redundant meta interpreter pib preferred answer sets pia definition applies prerequisite free programs general case include definition dual gelfond lifschitz reduct amounts stating rules true positive body answer set considered 
encoding straightforward lit head pos body true defeat local 
lit head pos body true defeat local defeat global 
defeat local lit pr 
defeat global 
set cb union literals lit cp lit 
definition preferred answer set satisfy cb formulate integrity constraints discard answer sets violating condition cp 
cp 
completes meta interpreter program pib compact listing showing pia explicitly 
result states works correctly 
theorem propositional prioritized program 
pib ii exists pib infsys rr proof pib qa pia 
known results splitting logic program obtain answer set restriction aa predicates qa answer set qa answer set pib qa aa 
suppose 
aa answer set qa theorem aa answer set furthermore clauses define constrain predicate pr pib defines total ordering equivalent pr 
consider dual reduct sp sp 
answer set remains show cb sp holds 
define sets si ordering follows 
denote sp rule dual reduct sr sr sr th rule sp si lit 
inductive argument 
obtain sequence 
sn satisfies condition definition 
true 
suppose true consider 
pos body true holds 
si holds condition definition anyway holds 
suppose si si si 
rules head lit applied means defeat local defeat global hold 
case implies induction hypothesis literal si si defeats case means defeats si satisfies definition case 
suppose si si 
lit means rules head lit applied defeat local induction hypothesis means defeated si defeat global definition defeat global means defeat condition definition satisfied 
proves claim sequence 
sn 
easily seen sn lit 
rule defining cp pib obtain cp holds iff sn constant 
constraints pib infer cb sp hold words preferred answer set 
ii suppose full prioritization 
obtain answer set follows predicates defined pia coincides answer set pia corresponding item ii theorem pr defined pr iff lit true iff rule applied defeat local true iff rule exists applied defeat global true iff cp true iff note satisfies constraints pib virtue theorem answer set infsys rr splitting result showing answer set need show 
restriction predicates pia pr answer set program contains plus clauses involve predicates lit defeat local defeat global cp satisfies literals predicates pia pr 
easily seen locally stratified stratification exists atoms occurring lit lit defeat local defeat local constants rules defeat local lit literals rules cp max lit head atoms 
verify stratified model coincides atoms iff immediate definition suppose statement true consider 
atom 
suppose consider possible cases defeat local exists applied definition lit holds induction hypothesis lit defeat local cp definition preferred answer set follows lit lit induction hypothesis lit implies cp lit definition applied construction head pos body true defeat global atoms rank lower lit 
furthermore defeat local hold defeat local lit induction hypothesis rule exist applied contradict applied means second rule head lit applied lit implies conversely suppose consider possible cases defeat local follows lit 
induction hypothesis lit definition means applied definition defeat local cp lit exists lit induction hypothesis definition applied definition means cp lit head pos body true defeat local defeat global case definition implies preferred answer set contradiction 
apply 
induction hypothesis obtain defeat global means applied lit definition 
shows implies concludes induction 
shown satisfies constraints pib follows stratified model answer set 
answer set proves result 
infsys rr example bird penguin example pib answer set contains peng bird flies 
note constraint pib fact redundant dropped possible sind definition equivalently replaced weaker condition 
fixpoint condition proposition fully prioritized prerequisite free program 
iff cb proof suffices show cb cb raises contradiction 
assume condition holds 
cb exist means generating rule exist 
definition hold ar cb hold 
hold defeat 
hold 
implies ar defeats sine ar cb follows cb contradiction 
deterministic checking method provided non deterministically generates prioritized program answer set full tests 
graph algorithm described checks answer set deterministically refining total order 
general method efficient 
approach works follows labeled directed graph constructed vertices rules edge leads vertex labeled generating zombie irrelevant 
algorithm performs kind topological sorting deciding answer set preferred outputs suitable full prioritization algorithm full order input propositional prioritized program answer set 
output full prioritization fp 
method step 
construct graph initialize 
step 
empty output halt 
step 
pick source vertex incoming edge labeled defeated exists output halt 
step 
labeled set 
step 
remove continue step 
infsys rr discussion algorithm 
note non deterministic step 
deterministic variant merely deciding arbitrary source sources satisfying condition selected step removed parallel step 
easily seen feasible source monotone destroyed removing source 
preferred answer set iff algorithm stops empty graph vertices removed 
deterministic algorithm readily encoded dlv 
idea stages modeling iterations steps 
number steps bounded number rules reuse rule ids stages stage rule 
stages ordered dlv built order constants 
stage stage run steps 
predicates rule labels respectively defined follows label interest omitted rule pos body true neg body false 
rule pos body true head 
initially sources zombies removed graph 
predicate informally means source node predicate remove means stage vertex longer pr 
remove rule stage 
stages iteration remove rules satisfying condition step 
predicate expresses source stage pr stage remove 
remove rule stage stage remove 
remove rule time time 
step add head generating rule removed step set 
represent predicate st informally means belongs set stage st add rule st remove st head 
step check rules removed processing graph done predicate removed projection remove rules rule plus constraint removed remove 
rule removed 
infsys rr label nodes nodes labels uninteresting rule neg body false pos body true 
rule pos body true head 
rules ids stages 
stage rule 
initial step algorithm consider global source nodes 
non nodes removed 
pr 
remove rule stage 
steps algorithm remove non nodes conditions nodes 
pr stage remove 
remove rule stage stage remove 
remove rule stage stage 
add head removed generating rule set st remove st head 
check rules removed 
removed remove 
rule removed 
meta interpreter pig preferred answer sets deterministic checking pia resulting meta interpreter program pig pia shown 
note pig general efficient pib unnecessary partial order avoided pig 
virtue results particular lemma state result theorem propositional prioritized program 
pig ii exists pig proof sketch proof theorem employ notion splitting program 
pig qa pia 
answer set restriction aa predicates qa answer set qa pib qa aa 
theorem aa answer set loosely argue deterministic variant full order input creates intermediate values set counting initialisation referred sn implicitly creates cumulative sets rn removed rules 
seen mapping rule labels rn ordered dlv built 
sn 
rn stage 
remove definition infsys rr remove proceed induction assume ri remove ri si ri seen ri remove ri si ri hold definition predicates remove observe rn removed graph empty iff rn satisfies final constraint pig rn guaranteed hold 
algorithm outputs holds 
ii construct answer set notion splitting restriction predicates defined qa pia answer set program contains plus clauses ground involve predicates remove removed satisfies literals involving predicates defined qa 
locally stratified stratification defined follows 
rn rule identifiers ordered dlv built removed ri remove ri ri atoms hold easy see extension answer set pia fully determined 
furthermore satisfy final constraint pig 
due facts effectively constructed 
example consider program example assume priorities 
suppose checked 
atoms representing labels derived 
sources labeled remove ri ri derived 

ri derived 
holds derive remove ri remove ri 
ri ri derived hold 
remove ri ri derived removed ri holds 
satisfying final constraint introduced 
preferred answer set 
alternate definition preferred answer sets provided meta interpreter program definition developed techniques similar ones employed pib pig interpreters sections 
preferred answer sets semantics seen section way assign meaning prioritized logic programs 
section introduce related approach due wang zhou lin presentation 
infsys rr definition preferred answer set rn prioritized program 
set bp literals sequence si bp defined follows si si active wrt 
si ii 
rule active wrt 
si si 

rule active wrt 
pair 
set cw defined sn sn consistent bp 
preferred cw set preferred answer sets denoted 
consider consistent preferred answer sets 
adapting meta interpreter provide meta interpreter preferred answer sets closely follows definition consists parts guesses consistent literal set part second proceeds stages rule application definition parts final verifies stability condition cw part 
part guess consistent set means rules extract literals occurring input program new predicate lit 
guess possible subsets lit means disjunctive rule true iff constraint ensures set consistent 
part handle preferences complete preference relation transitively close pr predicate verify irreflexive 
constraint violated case admits answer set rule preferred pr 
part stage ids similar definition indices rules rn reuse ids rules built arbitrary order ids ids consecutive stages definition 
safely number rules upper bound number stages computation part evaluate positive bodies definition need evaluate positive negative bodies rules ways verify rule active wrt 
si si respectively 
predicates pos body false pos body false si si represent sets rules bodies false set guessed part set si respectively si represented predicate si si si si 
pos body false covers base case positive body false positive body literal exists 
infsys rr part guess consistent set lit head 
lit bpl 
lit 
notin lit 
compl 
part handle preferences 
pr pr pr 
pr 
part stage ids 
stage rule 
part evaluate positive bodies 
pos body false rule pbl 
pos body false si si pbl stage si si si 
pos body false pbl 
part evaluate negative bodies 
neg body false rule 
neg body false si si stage si si si 
part determine active rules 
active si rule stage si pos body false si si neg body false 
active si si rule stage si pos body false neg body false si si 
active rule pos body false neg body false 
part check preferred generating rules 
head si si stage si head si si 
preferred generating rule exists si pr active si si head si si 
preferred generating rule exists pr pos body false 
part compute si 
si si head active sj stage sj stage si si sj preferred generating rule exists sj 
si si head active stage si preferred generating rule exists 
part verify stability 
pas si 
pas 
pas 
meta interpreter preferred answer sets infsys rr part evaluate negative bodies works analogously case positives bodies just need omit special case negative body literal occur 
part determine active rules need define rules active wrt 
si si 
handled rule second third rules si represented defined part si represented predicate si define 
third rule covers special case initial stage 
part check preferred generating rules rule preferred generating rule exists si head checks rule preferred exists active wrt 
si head occur si si represents si 
head si si auxiliary predicate checks head rule set si 
third rule covers base case simplify body rule shown 
part compute si compute si include head rules active wrt 
si preferred rule exists active wrt 
si head occur si 
need specialized rule base case si 
part verify stability define predicate pas union si check stability condition definition check relations pas equal 
difference lead violation constraints corresponding answer set exist 
provide theorem states correctness meta interpreter program pas 
theorem propositional prioritized program 
ii exists proof sketch proof result techniques proofs theorems 
major difference start answer sets generated pia consistent sets generated rules part splitting done literals defined rules part 
shown inductively sets sj definition correspond sets si rj upper bound ri rule labels ordered met 
dlv built order 
constraints part guarantee criterion cw ii split program obtained ground program dropping rules part adding answer set dropped rules keeping rules bodies agree locally stratified 
possible stratification follows pas infsys rr preferred generating rule exists ri active ri head si ri active si ri pos body false si ri neg body false si ri si ri preferred generating rule exists pos body false active atoms information effectively construct preferred answer sets way assign meaning prioritized logic programs introduced delgrande schaub tompits 
presentation follow 
definition preferred answer set rn prioritized program 
set bp literals sequence si bp defined follows si si active wrt 
si ii 
rule active wrt 
si rule si 

rule active wrt 
pair rule denotes rules effectively derive literals set cd defined sn sn consistent bp 
answer set preferred set preferred answer sets denoted 
infsys rr basic difference preferred preferred answer sets requires higher ranked rule derive literal sufficient literal appears head rule 
fact show approaches shown get increasingly restrictive approach admits subset preferred answer sets previous approach 
theorem due theorem schaub wang propositional prioritized program 
adapting meta interpreter changes pid relatively small marked lines pid differs vertical bar 
tracking literals means si need track concrete rule derive particular literal means new predicate rule si si specifies state denoted si literal derived means rule similarly replace head si new predicate rule generating si considers specific rule applied just head rule derived possibly different rule 
si simple projection rule si obtain union sis stability check 
result recall pas 
theorem propositional prioritized program 
pid ii exists pid proof sketch proof sketched theorem adapted straightforward way 
weakly preferred answer sets concept weakly preferred answer set relaxes priority ordering little necessary obtain preferred answer set answer set preferred 
seen conservative approximation preferred answer set 
far approximation defined preferred answer sets similar extensions approaches seen sections feasible 
definition distance total orderings finite set distance denoted number pairs definition uses ordinals deals possibly infinite equivalent finite infsys rr part guess consistent set lit head 
lit bpl 
lit 
notin lit 
compl 
part handle preferences 
pr pr pr 
pr 
part stage ids 
stage rule 
part evaluate positive bodies 
pos body false rule pbl 
pos body false si si pbl stage si si si 
pos body false pbl 
part evaluate negative bodies 
neg body false rule 
neg body false si si stage si si si 
part determine active rules 
active si rule stage si pos body false si si neg body false 
active si si rule stage si pos body false neg body false si si 
active rule pos body false neg body false 
part check preferred generating rules 
rule generating si si stage si head rule si si 
preferred generating rule exists si pr active si si rule generating si si 
preferred generating rule exists pr pos body false 
part compute si 
rule si si head active sj stage sj stage si si sj preferred generating rule exists sj 
rule si si head active stage si preferred generating rule exists 
si si rule si si 
part verify stability 
pas si 
pas 
pas 
meta interpreter pid preferred answer sets infsys rr clearly defines metric set total orderings example distance 
note amounts smallest number successive switches neighbored elements needed transform 
precisely number switches executed known bubble sort algorithm 
definition preference violation degree prioritized program 
preference violation degree denoted minimum distance full prioritization fully prioritized program preferred answer set min fp 
preference violation degree defined min 
weakly preferred answer sets answer sets minimize preference violation 
definition weakly preferred answer set prioritized program 
weakly preferred answer set iff 
denote collection weakly preferred answer sets example bird penguin example unique preferred answer set clearly preferred answer set prioritized program weakly preferred answer set single weakly preferred answer set program 
example reconsider program example 
answer set preferred 
switching priorities rules resulting prioritized program preferred weakly preferred answer set example consider program 


answer sets 
imposing iff preferred 
zombies dual reduct moved front takes switches 
hand single zombie dual reduct defeated moved front dead rule 
single weakly preferred answer set infsys rr adapting meta interpreter weakly preferred answer sets transition interpreter preferred answer sets weakly preferred answer sets simple just clauses added slightly altered 
weakly preferred answer sets generate second total ordering called pr needs compatible input partial order corresponds definition 
pr vpr rule rule pr pr pr 
pr 
ordering determine preferred answer sets 
input ordering occurs just rule original program just update rule defeat local lit pr 
want keep orderings minimize differences input ordering 
state weak constraint difference orderings gets penalty don need leveling concept 
pr pr 
way answer set weighted optimal answer sets minimize number corresponds exactly defs 

call resulting interpreter compact listing showing pia 
result theorem propositional prioritized program 
oas ii exists oas proof set clauses rules defining pr constraint pr weak constraint minimization violations 
renaming pr pr identical meta interpreter program pib minus redundant constraint cp 
infer theorem correspondence ii 
result adding rules defining pr constraint pr 
similar correspondence set tuples fp fp 
adding weak constraint results oas similar correspondence set turn naturally corresponds 
precisely conclude oas exists tuple corresponds conversely exists tuple corresponds oas proves items ii theorem 
example reconsider example preferred answer set 
optimal answer set weight level containing pr pr consistent example 
infsys rr full prioritization refine pr total ordering 
pr pr rule rule pr pr pr 
pr 
weakly preferred answer sets create total ordering pr close pr possible 
pr pr rule rule pr pr pr 
pr 
weak constraint minimize violations 
rule rule pr pr 
check dual reduct build sets rule ids indices lit means literal occurs set 
lit head pos body true defeat local 
lit head pos body true defeat local defeat global 
defeat local lit pr 
defeat global 
include literal cp 
cp lit 
cp 
meta interpreter weakly preferred answer sets pia example reconsider example preferred answer set 
optimal answer set weight level containing pr pr pair difference pr pr consistent example 
straightforward encoding definition weakly preferred answer set gives executable specification quite inefficient larger problem instances large search space generated possible total orderings pr pr 
improve efficiency variant graph algorithm full order section observation 
may arrange vertices removed order common prefix orderings definition 
need guess optimal completions rules remain termination full order 
particular empty coincide preferred answer set weakly preferred 
meta interpreter programs pig combined meta interpreter program computing weakly preferred answer sets conservatively extends computation preferred answer sets sense guessing comes play preferred answer sets exist 
discuss 
infsys rr related meta interpretation answer sets answer set semantics considered authors different contexts 
briefly discuss related 
gelfond son 
idea meta interpretation define semantics language rules preferences 
multi sorted logical language constants individuals definite rules default rules form lm true normally true functions relations domain special predicates defining rules expressing preference 
example formula default 
lm represents default rule name lm prolog list notation 
informally amounts rule lm extended logic programming 
language allows express conflicts default rules preferences conflicts declared dynamically means rules 
semantics defined terms transformation program extended logic program answer sets roughly speaking cast answer sets program salient differences approach 
foremost semantics defined means meta interpreter approach implements semantics defined previously meta interpretation techniques 
secondly interpretation program uses lists representing aggregations literals conditions particular conditions 
lists datalog programs arbitrarily deep function nesting required list concept 
avoid aggregations rule identifiers traversal mechanism exploits implicit ordering default negation 
thirdly approach extend general answer set meta interpreter clearly separating representation answer sets prioritization 
meta interpreter distinction obvious 
marek remmel 
marek remmel discussed issue meta interpreter propositional normal logic programs context expressiveness stable logic programming 
describe function free normal logic program meta input factual representation normal logic program clause positive body literals projection answer sets meta correspondence answer sets representation similar representation explicitly records position positive body literals 
meta interpreter meta similar differs respects firstly meta encodes simple guess check strategy computation stable model contains pair rules guess atom stable model 
remaining clauses mimic computation minimal model special predicate computed constraints check reconstructed 
hand meta interpreter pia separate guessing checking parts 
stability model infsys rr effected stable semantics underlying interpreter 
furthermore pia uses negation sensible structure program essence preserves stratification cf 
proposition 
secondly naive guess check strategy meta highly inefficient programs evaluated easily 
particular positive programs meta explores exponential search space computation unique stable model may take considerable time 
hand stratified meta interpreter program pia propagation input facts locally stratified program evaluated efficiently 
loosely speaking pia interprets significant class computational easy logic programs efficiently 
thirdly meta applicable normal logic programs 
extension arbitrary normal logic programs possible similar techniques 
considerations suggest meta interpreter meta theoretical interest fully compliant goals 
delgrande schaub tompits 
seminal approach adding priorities default logic delgrande developed plp framework expressing priorities logic programs 
framework extended logic programs preference information rules attached object level compiled extended logic program answer sets program amount preferred answer sets original program 
transformation uses number control predicates application rules rule preferences respected intended application rules constructing answer set program 
specifically control atoms ap bl state rule applied blocked respectively atoms ok rdy control applicability rules antecedent conditions reflecting order information 
framework provides flexibility modify standard transformation transformations different preference semantics designed 
plp framework significantly differs respects firstly plp fixed meta interpreter evaluating varying programs format processed meta interpreter 
plp performs schematic program construction ad hoc 
secondly plp aims tool realizing preferences semantics providing suite special predicates particular representation formalism 
contrast interest casting definitions principles extended logic programs way obtain executable specifications 
way variations definitions experimented flexibly 
thirdly similar plp obvious separation answer sets prioritization 
considered issue building experimental prototypes semantics extended logic programs equipped rule preferences technique meta interpretation 
course suite meta interpreters various semantics including simple answer set semantics plain extended logic programs 
meta interpreter benign computational properties building block meta interpreters semantics 
infsys rr focus propositional setting possible extend techniques handling non ground programs 
function symbols allowed code level currently case dlv technical realization completely straightforward 
extending deal cases reported prove useful creating front prioritized program evaluation issues 
believe provides supportive evidence items 
meta interpretation useful technique building experimental prototype implementations knowledge representation formalisms 
particular shown preferences formalisms extending seminal answer set semantics 
answer set programming possible cast definitions semantics quite naturally extended logic programs usage answer set programming engines provide executable specifications 
note line shown inheritance networks compiled logic programs hand semantics logic programs may refining semantics inheritance networks 
adding optimization constructs basic language extended logic programming weak constraints dlv constructs provided smodels valuable elegantly expressing semantics defined terms optimal values cost functions 
semantics weakly preferred answer sets provides striking example examples domain diagnostic reasoning 
enhancing asp engines constructs efficient realization important increasing usability asp compilation meta interpreter approach 
furthermore techniques methods design meta interpreters particular ordering relations may prove useful researchers designing asp implementations applications 
appears meta interpretation established prolog style logic programming topic interest asp exploration provides useful results core asp 
confident provide evidence view 
acknowledgments 
authors colleagues participants aaai spring symposium answer set programming comments 
supported austrian science fund fwf inf inf inf 
baader hollunder 
priorities defaults prerequisite application treating specificity terminological default logic 
journal automated reasoning 

prototypes reasoning infinite stable models function symbols 
thomas eiter wolfgang faber truszczy ski editors proceedings th international conference logic programming nonmonotonic reasoning lpnmr number lncs pages 
springer 
infsys rr 
reasoning infinite stable models 
proceedings seventeenth international joint conference artificial intelligence ijcai pages seattle wa usa august 
morgan kaufmann publishers 
brewka 
adding priorities specificity default logic 
proceedings jelia lnai pages 
springer 
brewka 
founded semantics extended logic programs dynamic preferences 
journal artificial intelligence research 
brewka eiter 
prioritizing default logic 
steffen lldobler editor computational logic papers honor wolfgang bibel pages 
kluwer 
isbn 
gerhard brewka thomas eiter 
preferred answer sets extended logic programs 
artificial intelligence 
leone 
semantics expressiveness disjunctive ordered logic 
annals mathematics artificial intelligence 
appear 
proceedings kr 
francesco nicola leone pasquale 
strong weak constraints disjunctive datalog 
rgen dix ulrich furbach anil nerode editors proceedings th international conference logic programming non monotonic reasoning lpnmr number lecture notes ai lnai pages dagstuhl germany july 
springer verlag 
delgrande schaub 
compiling reasoning preferences default logic 
proceedings ijcai pages 
delgrande schaub 
expressing preferences default logic 
artificial intelligence 
jim delgrande torsten schaub hans tompits 
logic programs compiled preferences 
werner horn editor proceedings th european conference artificial intelligence ecai pages 
ios press 
jim delgrande torsten schaub hans tompits 
prioritized default logic revisited compilation brewka eiter approach 
de guzm brewka pereira editors proceedings european workshop logics artificial intelligence journ es europ sur la logique en intelligence artificielle jelia malaga spain september october number lncs 
springer 
jim delgrande torsten schaub hans tompits 
plp generic compiler ordered logic programs 
thomas eiter wolfgang faber truszczy ski editors proceedings th international conference logic programming nonmonotonic reasoning lpnmr number lncs pages 
springer 
wolfgang faber nicola leone gerald pfeifer 
pushing goal derivation dlp computations 
michael gelfond nicola leone gerald pfeifer editors proceedings th international conference logic programming nonmonotonic reasoning lpnmr number lecture notes ai lnai pages el paso texas usa december 
springer verlag 
infsys rr wolfgang faber gerald pfeifer 
dlv homepage 
www dbai tuwien 
ac proj dlv 
gelfond lifschitz 
classical negation logic programs disjunctive databases 
new generation computing 
michael gelfond tran cao son 
reasoning prioritized defaults 
proceedings workshop logic programming knowledge representation pages 
springer 
lifschitz turner 
splitting logic program 
pascal van hentenryck editor proceedings th international conference logic programming iclp pages santa margherita ligure italy june 
mit press 
vladimir lifschitz 
foundations logic programming 
brewka editor principles knowledge representation pages 
csli publications stanford 
marek remmel 
expressibility stable logic programming 
thomas eiter wolfgang faber truszczy ski editors proceedings th international conference logic programming nonmonotonic reasoning lpnmr number lncs pages 
springer 
marek truszczy ski 
nonmonotonic logics context dependent reasoning 
springer verlag 
ilkka niemel patrik simons tommi 
smodels system answer set programming 
baral aw truszczy ski editors proceedings th international workshop non monotonic reasoning nmr breckenridge colorado usa april 
rintanen 
lexicographic priorities default logic 
artificial intelligence 
sakama inoue 
prioritized logic programming application commonsense reasoning 
artificial intelligence 
torsten schaub wang 
comparative study logic programs preference 
proceedings seventeenth international joint conference artificial intelligence ijcai pages seattle wa usa august 
morgan kaufmann publishers 
wang zhou fangzhen lin 
alternating fixpoint theory logic programs priority 
computational logic cl international conference proceedings number lecture notes ai lnai pages london uk july 
springer verlag 
jia wang li yan yuan 
compiling defeasible inheritance networks general logic programs 
artificial intelligence 
zhang foo 
answer sets prioritized logic programs 
proceedings ilps pages 
