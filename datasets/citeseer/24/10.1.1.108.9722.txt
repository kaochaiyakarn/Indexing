combinatorial strongly polynomial algorithm minimizing submodular functions satoru iwata university tokyo tokyo japan lisa fleischer carnegie mellon university pittsburgh pennsylvania satoru fujishige osaka university osaka japan 
presents combinatorial polynomial time algorithm minimizing submodular functions answering open question posed gr tschel lov sz schrijver 
algorithm employs scaling scheme uses flow complete directed graph underlying set arc capacity equal scaled parameter 
resulting algorithm runs time bounded polynomial size underlying set length largest absolute function value 
presents strongly polynomial version number steps bounded polynomial size underlying set independent function values 
preliminary version appeared proceedings nd annual acm symposium theory computing portland ore 
acm new york pp 

iwata done osaka university japan fields institute toronto ont canada 
iwata partly supported aid scientific research ministry education science sports culture japan 
fleischer done leave center operations research econometrics universite catholique de louvain belgium fields toronto ont canada 
fleischer supported part european network supported european community frame training mobility researchers programme contract number erb ct 
additional support university waterloo dept combinatorics optimization national science foundation nsf int eia 
fujishige partly supported aid scientific research ministry education science sports culture japan 
authors addresses iwata department mathematical engineering information physics university tokyo tokyo japan mail iwata sr tokyo ac jp fleischer graduate school industrial administration carnegie mellon university pittsburgh pa mail lkf andrew cmu edu fujishige division systems science graduate school engineering science osaka university osaka japan mail sys es osaka ac jp 
permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission association computing machinery acm copy republish post servers redistribute lists requires prior specific permission fee 
acm journal acm vol 
july pp 

iwata categories subject descriptors analysis algorithms problem complexity algorithms problems computations discrete structures discrete mathematics combinatorics combinatorial algorithms general terms algorithms additional key words phrases discrete optimization strongly polynomial algorithm submodular function 
finite nonempty set cardinality function defined subsets called submodular satisfies presents combinatorial polynomial time algorithm finding minimizer general submodular function provided oracle evaluating function value available 
assume loss generality subtracting scalar function value 
submodularity discrete analog convexity frank fujishige lov sz submodular functions arise naturally various fields including combinatorial optimization computational biology game theory scheduling probability information theory 
examples include matroid rank function cut capacity function entropy function 
problems diverse areas dynamic flows hoppe tardos facility location multiterminal source coding fujishige han rely algorithms general submodular function minimization 
submodular function minimization solve submodular flow problems cunningham frank edmonds karp fujishige iwata generalize network flow matroid optimization problems model graph augmentation connectivity problems edmonds giles frank tardos 
general background submodular functions see frank tardos fujishige lov sz 
natural polyhedra rv associated submodular function submodular polyhedron base polyhedron defined 
linear optimization problems polyhedra solved efficiently greedy algorithm edmonds 
polynomial time algorithm submodular function minimization due gr tschel 
showed general polynomial time equivalence separation optimization polyhedra ellipsoid method 
separation problem deciding submodular function defined subtracting scalar nonempty equivalent determining minimum submodular function 
problem solved ellipsoid algorithm conjunction greedy algorithm solves optimization problem 
maximum value equals minimum value embedding ellipsoid algorithm binary search yields polynomial time algorithm minimizing submodular functions submodular function minimization 
ellipsoid method far efficient practice combinatorial 
combinatorial polynomial time algorithm submodular function minimization 
algorithm uses augmenting path approach convex combination extreme points associated base polyhedron 
approach introduced cunningham minimizing submodular functions arise separation problem matroid polyhedra 
adapted general submodular function minimization bixby improved cunningham obtain combinatorial pseudopolynomial time algorithm 
narayanan introduced rounding technique improves cunningham algorithm matroid polyhedra 
minimum norm base characterization minimizers fujishige devised pseudopolynomial time algorithm 
closely related problem finding nonempty proper subset minimizes symmetric submodular function queyranne described combinatorial strongly polynomial algorithm 
symmetric set function satisfies queyranne algorithm extends undirected minimum cut algorithm ibaraki 
fundamental tool algorithms general submodular function minimization bixby cunningham narayanan move extreme point base polyhedron adjacent extreme point exchange operation increases coordinate decreases coordinate quantity 
quantity called exchange capacity 
previous methods maintain directed graph vertex set underlying set submodular function arc set represents set possible exchange operations 
progress iteratively performing sequence exchange operations augmenting path 
algorithms known polynomial best known lower bound amount augmentation small 
amount augmentation determined exchange capacities multiplied convex combination coefficients 
coefficients may small reciprocal maximum absolute value submodular function 
pseudopolynomial time algorithm run polynomial time edmonds karp introduced scaling technique design polynomial time minimum cost flow algorithm 
initial success polynomial time scaling algorithms designed various combinatorial optimization problems 
straightforward attempt apply scaling technique submodular function minimization 
mainly rounding submodular function may violate submodularity 
specifically set function defined necessarily submodular submodular function 
overcome difficulty employ scaling framework uses complete directed graph underlying set letting capacity arc set depend directly scaling parameter 
complete directed graph serves relaxation submodular function submodular function defined 
note second term cut function additional graph submodular 
relaxation natural interpretation setting network flows 
cut canceling algorithm minimum cost flows mccormick iwata relax capacity flow arc scaling parameter 
submodular function minimization graph set possible exchange arcs really complete directed graph additional graph introduced iwata capacity scaling algorithm submodular flow 
published submodular flow algorithms iwata fleischer developed techniques 
particular incorporating ideas iwata algorithm fleischer introduces method avoid exchange operations augmenting path 
done carefully performing exchange operations search augmenting path sufficient residual capacity 
employs technique develop capacity scaling augmenting path algorithm submodular function minimization 
resulting algorithm uses log arithmetic steps function evaluations max 
assumption bounded constant scaling algorithm faster best previous combinatorial pseudopolynomial time algorithm due cunningham uses log nm arithmetic steps function evaluations 
modify scaling algorithm run strongly polynomial time 
strongly polynomial algorithm submodular function minimization performs number steps bounded polynomial size underlying set independent gr tschel described algorithm ellipsoid method 
polynomial time algorithm run strongly polynomial time frank tardos developed generic preprocessing technique applicable fairly wide class combinatorial optimization problems including submodular flow assuming oracle computing exchange capacities testing membership matroid polyhedra 
framework readily apply scaling algorithm submodular function minimization 
establish proximity lemma devise combinatorial algorithm repeatedly detects new element contained minimizer new element contained minimizer new ordered pair minimizer containing contains resulting algorithm uses log arithmetic steps function evaluations 
approach general technique originated tardos design strongly polynomial minimum cost flow algorithm 
independently schrijver developed combinatorial strongly polynomial algorithm general submodular function minimization cunningham approach 
designing algorithm uses provably large augmentations schrijver complexity analysis depends algorithmic framework uses paths lengths provably nondecreasing 
algorithm shown function evaluations arithmetic steps 
modification algorithm improves quantities linear factor fleischer iwata 
schrijver algorithm gaussian elimination maintain representation vector convex combination small number extreme points 
require step establish polynomial time complexity algorithm 
schrijver poses open problem design strongly polynomial algorithm submodular function minimization consists additions subtractions comparisons oracle calls 
symmetric submodular function minimization algorithm queyranne fully combinatorial sense 
minimizing submodular functions iwata answered question describing fully combinatorial implementation strongly polynomial algorithm 
organized follows section provides background submodular functions 
section presents scaling algorithm submodular function minimization section gives strongly polynomial algorithm 
section discuss variants algorithms gaussian elimination 
conclude extensions section 
preliminaries denote set integers set reals respectively 
vector rv subset expression denotes 
vector rv denote vectors rv defined max min denote vector rv 
vector base polyhedron called base extreme point base 
easy see base subset 
fundamental lemma shows inequalities fact tight appropriately chosen lemma easily follows theorem edmonds vector reduction provide direct proof completeness 
lemma 
submodular function max min 
integer valued maximizer chosen integral bases 
proof 
maximizer left hand side 
exists subset 
follows submodularity satisfies 
establishes min max relation 
integrality assertion follows argument starting integral base maximizes integral bases 
completely obvious lemma provides characterization minimizer fact proving definition require exponential number function evaluations 
extreme base compact proof resulting greedy algorithm described 
maximizer may extreme base 
handle cunningham suggested maintaining base combination extreme bases yielding compact proof base generated algorithm 
vn linear ordering define vj 
greedy algorithm edmonds shapley iwata computes extreme base associated 
linear ordering provides certificate extreme base 
conversely extreme base generated applying greedy algorithm appropriate linear ordering 
fundamental tool algorithm move base base exchange operation increases component decreases component amount 
yi convex combination extreme bases realized applying exchange operation extreme base yi 
exchange amount yi corresponds exchange amount lemma shows interchanging consecutive elements linear ordering generates yi results exchange operation yi 
lemma 
suppose immediately succeeds linear ordering generates extreme base 
linear ordering obtained interchanging generates extreme base 
proof 
obvious greedy algorithm differ 
follows 
obtain 
quantity lemma called exchange capacity 
general exchange capacity defined base ordered pair distinct maximum amount exchange operation keeps base polyhedron 
exchange capacity expressed min 
special computation easier minimizing algorithm uses exchange capacities computed lemma 
scaling algorithm section describe combinatorial algorithm minimizing submodular function 
assume evaluation oracle function value algorithm augmenting path algorithm embedded scaling framework 
formal description algorithm sfm appears 

scaling framework 
algorithm consists scaling phases positive parameter 
algorithm starts arbitrary linear ordering extreme base generated initial value min 
scaling phase algorithm cuts half 
algorithm ends minimizing submodular functions fig 

scaling algorithm submodular function minimization 
algorithm finds subset minimizes submodular function uses directed graph 
adapt augmenting path approach scaling framework complete directed graph arc capacities depend directly scaling parameter 
flow complete directed graph vertex set arc set boundary defined 
net flow value emanating called feasible satisfies capacity constraints algorithm maintains equal zero algorithm maintains base convex combination yi extreme bases yi 
index algorithm maintains linear ordering li generates yi 
trying maximize directly algorithm uses seeks increase increasing feasibility 
base base polyhedron submodular function 
iwata 
scaling phase 
scaling phase maintains feasible flow subgraph arc set 
scaling phase aims increasing sending flow directed paths 
directed path called augmenting path 
augmenting path denote set vertices currently reachable triple ofi called active immediately succeeds li 
active algorithm performs appropriate exchange operation modifies invariant 
refer procedure double exchange 
detail double exchange described 
result double exchange remains unchanged vertex set vertices reachable capacity paths added algorithm performs double exchange long applicable augmenting path 
augmenting path algorithm augments flow setting arc inp 
increases changes initial terminal vertices extension technique developed fleischer finding augmenting paths submodular flows 
scaling phase ends augmenting path active triple 
algorithm cuts value half goes scaling phase 
keep feasibility algorithm halves flow arc step procedure double exchange compute exchange capacity yi 
updates remains unchanged 
amount exchange operation determined minimum yi 
note maximum amount feasible decrease yi maximum exchange possible effect yi performing exchange operation yi keeping extreme bases fixed 
procedure double exchange updates yi yi yi yi 
updates li interchanging maintains yi extreme base generated li 
double exchange called saturating yi 
called nonsaturating 
double exchange nonsaturating old yi remains convex representation coefficient yi 
double exchange nonsaturating updating yi adds new index yk yi yi lk li 
double exchange summarized 
augmentation scaling phase algorithm applies procedure reduce computes expression convex combination affinely independent extreme bases yi chosen current yi computation standard linear programming technique transforming feasible solution basic feasible solution 
set extreme points affinely independent set coefficients identically zero satisfies yi 
gaussian elimination start computing dependency detected 
point eliminate dependency computing min updating satisfies 
delete minimizing submodular functions double exchange yi li li yi min yi yi new index yi yi yk yi lk li yi yi yi update li interchanging fig 

algorithmic description procedure double exchange 
continue procedure eventually obtain affine independence 
step submodular function minimization algorithms cunningham schrijver 
algorithm need step obtain polynomial bound complexity 
include linear algebraic procedure significantly reduces running time algorithm 
analysis algorithm reduce see section 

correctness 
subsequent analysis scaling phase refers point immediately cut half 
lemma establishes relaxed strong duality plays crucial role analysis algorithm 
lemma 
scaling phase 
proof 
scaling phase active triples implies vertices li belong follows yi 
yi obtain yi 
scaling phase set satisfies 
definitions 
immediate consequence lemma obtain lemma leads correctness scaling algorithm 
lemma 
scaling phase 
proof 
lemma set satisfies 

theorem 
algorithm obtains minimizer scaling phase iwata proof 
lemma output algorithm satisfies 
weak duality lemma asserts implies 
follows integrality minimizes 
complexity 
investigate number iterations scaling phase 
lemma 
number augmentations scaling phase 
proof 
follows lemma scaling phase replacing decrease bounded decrease bounded 

hand scaling phase 
augmentation increases number augmentations phase phases 
phase denote initial extreme base 
start algorithm 
hold possible increase scaling phase bounded min 
initial setting guarantees number augmentations scaling phase lemma 
augmentations grows 
proof 
new index added nonsaturating double exchange 
nonsaturating double exchange adds new element happens times augmenting path 
lemma 
algorithm sfm performs procedure double exchange times augmentations 
proof 
algorithm applies double exchange vertices interchanged li triple active augmentation phase 
performing basis reduction augmentation algorithm lemma 
number times double exchange applied bounded number triples 
theorem 
algorithm sfm polynomial time algorithm performs log function evaluations arithmetic operations 
proof 
algorithm starts ends initial extreme base wehave sfm consists log scaling phases 
scaling phase performs augmentations lemma 
augmentations calls double exchange lemma 
procedure double exchange consists calls function evaluation oracle 
algorithm calls oracle log times total 
minimizing submodular functions result double exchange vertex set vertices reachable capacity paths may added 
set may determined standard graph search 
course augmentation updates take time 
find active triple efficiently maintain pointer index points element active triple li 
double exchange increase takes linear time update 
double exchange increases may need updated takes time 
augmentation takes time 
augmenting endpoints may removed augmentation update expression yi recover affine independence yi bottleneck procedure time spent computing coefficients described section 
lemma takes arithmetic operations 
performed correctly encoding length numbers generated gaussian elimination bounded polynomial size input includes maximum encoding length function values edmonds 
addition resulting multipliers basic solution system columns correspond extreme bases yi size bounded polynomial input size 
sfm polynomial time algorithm log arithmetic steps 
previous best known pseudopolynomial time bound log nm due cunningham 
theorem shows scaling algorithm faster fixed constant 
section shown weakly polynomial time algorithm minimizing integer valued submodular functions 
integrality submodular function guarantees base subset minimizer integrality follows real valued submodular function positive lower bound difference second minimum minimum value algorithm works submodular function log bound number steps max 

strongly polynomial algorithm section presents strongly polynomial algorithm minimizing real valued submodular function main idea show lemma log scaling phases algorithm detects new element contained minimizer new element contained minimizer new vertex pair minimizer containing detections log scaling phases algorithm finds minimizer lemma 
scaling phase sfm hold contained minimizer 
contained minimizer iwata proof 
lemma holds scaling phase 
minimizer wehave 

hand 
strongly polynomial algorithm denoted spm maintains subset included minimizer vertex set corresponding partition pairwise disjoint nonempty subsets submodular function defined directed acyclic graph 
arc ordered pair vertices minimizer containing denote corresponding set partition example vj denote 
algorithm keep correspondence minimizers minimizer represented minimizer initially algorithm assigns clearly satisfy properties 
denote set vertices reachable denote contraction submodular function ground set defined 
linear ordering called consistent ui implies extreme base generated consistent linear ordering called consistent 
lemma 
consistent extreme base satisfies proof 
consistent extreme base satisfies 
claim follows submodularity building block strongly polynomial algorithm subroutine fix performs log scaling phases starting extreme base consistent submodular function subroutine fix invoked subset 
fix performs scaling phases element satisfies scaling phase 
lemma element contained minimizer element satisfies scaling phase 
lemma element contained minimizer choice call fix determined lemma may invoked new element log phases ii number augmentations phase large 
accomplished setting 
explain holds ii holds proof theorem max 
minimizing submodular functions lemma implies consistent extreme base consistent satisfies case implies minimizes weak duality lemma 
algorithm returns minimizer element attains maximum right hand side 
values greater equal 
consider cases algorithm applies fix find new element minimizer case suffices minimize function subsets contain vertex 
algorithm deletes algorithm applies fix element minimizer case minimizer includes 
suffices minimize submodular function defined smaller underlying set algorithm sets algorithm applies fix du du defined restricted 
case fix du finds element contained minimizer algorithm adds tof 
creates cycle arcs cycle imply element cycle contained minimizer element cycle contained minimizer 
algorithm contracts cycle single vertex modifies regarding contracted vertex set single vertex 
algorithm summarized 
theorem 
algorithm spm strongly polynomial algorithm performs log function evaluations arithmetic operations 
proof 
time call procedure fix algorithm adds new arc deletes set vertices 
happen times 
call fix takes log phases 
lemma phase phase augmentations 
bound number augmentations phase recall choice implies extreme base consistent submodularity extreme base consistent du satisfies 
fix du 
number augmentations phase bounded number augmentations phase call fix bounded proof theorem shows number arithmetic operations function evaluations augmentation yields log bound total number steps 
applied rational valued submodular functions spm works space polynomial size 
particular noted earlier encoding length numbers generated gaussian elimination bounded polynomial input size iwata fig 

strongly polynomial algorithm submodular function minimization 
including maximum encoding length function values edmonds size resulting multipliers 
spm strongly polynomial algorithm 

removing gaussian elimination algorithms described sections employ gaussian elimination get representation convex combination small number extreme bases 
step necessary obtain polynomiality 
explain effect removing step 
size set convex combination representation increases augmentation due lemma 
number augmentations scaling phase affected size see proof lemma remains 
total number bases introduced algorithm bounded times number augmentations 
scaling algorithm sfm described section log 
size affect augmentation 
particular affects number calls double exchange search minimizing submodular functions augmentation 
proof lemma explained number double exchange operations augmentation extreme base total augmentation algorithm reduce log 
number arithmetic operations function evaluations combinatorial version sfm bounded log 
strongly polynomial algorithm spm described section depend reducing size strong polynomiality 
step omitted number extreme bases may grow log iteration fix 
call fix starts single extreme base size remain bounded spm log 
increase augmentation log 
bound number steps log 
contrast linear algebraic step omitted strongly polynomial algorithm described schrijver size exponential 
strongly polynomial algorithm minimizing submodular functions defined boolean lattices subsets ground set related problems shown require algorithms minimizing submodular functions restricted families subsets goemans ramakrishnan gr tschel 
problems combinatorial solutions modulo oracle submodular function minimization distributive lattices 
algorithms extended minimize submodular functions defined distributive lattices 
consider submodular function defined distributive lattice represented poset associated base polyhedron unbounded general 
easy way minimize function consider reduction sufficiently large vector 
described fujishige compute upper bound rank function reduction vector component equal submodular function defined set minimizers coincides may apply algorithms 
evaluation function value requires elementary operations addition single call evaluation schrijver describes similar method solve problem 
alternatively slightly extend algorithms sections keeping base convex combination extreme bases yi plus vector characteristic cone 
represented boundary nonnegative flow hasse diagram extension enables minimize min log log time upper bound submodular functions defined modular lattices naturally arise linear algebra 
minimization functions significant application canonical forms partitioned matrices ito iwata 
remains interesting open problem develop efficient algorithm minimizing submodular iwata functions modular lattices specific functions arise partitioned matrices 
acknowledgments 
grateful bill cunningham michel goemans useful comments 
bixby cunningham 
partial order extreme point 
math 
oper 
res 

cunningham 
testing membership matroid polyhedra 

theory 
cunningham 
submodular function minimization 
combinatorica 
cunningham frank 
primal dual algorithm submodular flows 
math 
oper 
res 

edmonds 
systems distinct representatives linear algebra 
res 
nbs 
edmonds 
submodular functions matroids certain polyhedra 
combinatorial structures applications 
guy sauer sch eds 
gordon breach pp 

edmonds giles 
min max relation submodular functions graphs 
ann 
discrete math 

edmonds karp 
theoretical improvements algorithmic efficiency network flow problems 
acm apr 
mccormick 
strongly polynomial cut canceling algorithms minimum cost network flow 
disc 
appl 
math 

fleischer iwata 
improved algorithms submodular function minimization submodular flow 
proceedings nd annual acm symposium theory computing portland ore may 
acm new york pp 

fleischer iwata mccormick 
faster capacity scaling algorithm submodular flow 
math 
prog appear 
frank 
algorithm submodular functions graphs 
ann 
discrete math 

frank tardos 

application simultaneous diophantine approximation combinatorial optimization 
combinatorica 
frank tardos 

generalized submodular flows 
math 
prog 

frank tardos 

application submodular flows 
linear alg 
appl 

fujishige 
dependence structure set random variables 
inf 
contr 

fujishige 
lexicographically optimal base respect weight vector 
math 
oper 
res 

fujishige 
submodular systems related topics 
math 
prog 
study 
fujishige 
theory submodular programs fenchel type min max theorem subgradients submodular functions 
math 
prog 

fujishige 
submodular functions optimization 
north holland amsterdam netherlands 
fujishige iwata 
algorithms submodular flows 
ieice trans 
inform 
syst 

goemans ramakrishnan 
minimizing submodular functions families subsets 
combinatorica 
gr tschel lov sz schrijver 
ellipsoid method consequences combinatorial optimization 
combinatorica 
gr tschel lov sz schrijver 
geometric algorithms combinatorial optimization 
springer verlag new york 
han 

capacity region general multiple access channel correlated sources 
inf 
cont 

hoppe tardos 

quickest transshipment problem 
math 
oper 
res 

minimizing submodular functions ito iwata 
block partitioned matrices similarity equivalence transformations 
siam matrix anal 
appl 

iwata 
capacity scaling algorithm convex cost submodular flows 
math 
prog 

iwata 
fully combinatorial algorithm submodular function minimization 

theory press 
iwata mccormick 
strongly polynomial cut canceling algorithm submodular flow problem 
proceedings th mps conference integer programming combinatorial optimization 
springer verlag berlin germany pp 

iwata 
minimax theorem mendelsohn type decomposition class generic partitioned matrices 
siam matrix anal 
appl 

lov sz 
submodular functions convexity 
mathematical programming state art gr tschel korte eds 
springer verlag new york pp 

ibaraki 
computing edge connectivity multigraphs capacitated graphs 
siam disc 
math 

narayanan 
rounding technique membership problem 
linear alg 
appl 

queyranne 
minimizing symmetric submodular functions 
math 
prog 

schrijver 
combinatorial algorithm minimizing submodular functions strongly polynomial time 

theory 
shapley 
cores convex games 
int 
game theory 

membership submodular polyhedra 
tech 
rep tr 
dept comput 
sci 
eng indian institute technology bombay india 

unifying location model tree graphs submodularity properties 
disc 
appl 
math 

tardos 

strongly polynomial minimum cost circulation algorithm 
combinatorica 
received july revised january accepted january journal acm vol 
july 
