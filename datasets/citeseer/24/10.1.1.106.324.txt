arxiv cs cs pl nov derivation efficient logic programs specialization reduction nondeterminism alberto disp university roma tor roma italy adp rm cnr maurizio cnr roma italy rm cnr sophie renault european patent office netherlands epo org february program specialization program transformation methodology improves program efficiency exploiting information input data available compile time 
show current techniques program specialization partial evaluation perform nondeterministic logic programs 
consider set transformation rules extend ones partial evaluation propose strategy guiding application extended rules derive efficient specialized programs 
efficiency improvements exponential due reduction nondeterminism fact computations performed initial programs different branches computation trees performed specialized programs single branches 
order reduce nondeterminism mode information guiding unfolding process 
exemplify technique show automatically derive efficient matching programs parsers regular languages 
derivations performed done previously known partial evaluation techniques 
goal program specialization adaptation generic program specific context 
partial evaluation established technique program specialization program static input portion input known compile time allows derive new efficient program portion output depends static input computed 
partial evaluation applied areas computer science applied logic programs called partial deduction 
follow rule approach specialization logic programs 
particular consider definite logic programs propose new program specialization techniques unfold fold transformation rules :10.1.1.19.4684
approach process program specialization viewed construction sequence say pn programs program specialized pn derived specialized program program sequence obtained previous applying transformation rule 
preliminary version appears reducing nondeterminism specializing logic programs 
proceedings th annual acm symposium principles programming languages paris france january acm press pp 

shown partial deduction viewed particular rule program transformation technique definition unfolding folding rules restrictions new predicate introduced definition rule defined precisely nonrecursive clause body consists precisely atom sense terminology partial deduction said ii folding rule uses clauses introduced definition rule 
follows definition folding rules comply restrictions ii called atomic definition atomic folding respectively 
section see restricted transformation rules easier automate partial deduction process may limit program improvements achieved program specialization 
particular perform partial deduction nondeterministic programs atomic definition unfolding atomic folding impossible combine information different branches computation trees consequence case reduce nondeterminism programs 
weakness partial deduction demonstrated section revisit familiar problem looking occurrences pattern string 
shown partial deduction string matching program may derive deterministic finite automaton dfa short similarly done knuth morris pratt algorithm 
string matching program partial deduction applied deterministic 
show applying partial deduction nondeterministic version matching program derive specialized program deterministic get program corresponds dfa 
conjunctive partial deduction program specialization technique extends partial deduction allowing specialization logic programs conjunctions atoms single atom 
conjunctive partial deduction realized definition unfolding folding rules new predicate introduced definition rule defined precisely non recursive clause body conjunction atoms sense conjunctive partial deduction said 
conjunctive partial deduction may reduce nondeterminism 
particular may transform generate test programs programs generation phase test phase interleaved 
shown section conjunctive partial deduction capable derive nondeterministic version matching program new program corresponds dfa 
propose specialization technique enhances partial deduction conjunctive partial deduction making powerful transformation rules 
particular section consider version definition rule new predicate may introduced means non recursive clauses bodies consist conjunctions atoms allow folding steps predicate definitions consisting clauses 
consider extra rules head generalization case split equation elimination disequation replacement 
rules may introduce replace eliminate equations negated equations terms 
similarly extended set program transformation rules preserves herbrand model semantics 
logic language equations negated equations considered adopt usual prolog operational semantics left right selection rule equations evaluated unification 
unfortunately unrestricted extended set transformation rules may preserve prolog operational semantics 
overcome problem consider class safe programs ii suitably restricted transformation rules called safe transformation rules 
examples show class safe programs safe transformation rules general allow significant program specializations 
notions safe programs transformation rules notion determinism modes associated predicate calls 
describe notions section prove application safe transformation rules preserve operational semantics safe programs 
section introduce strategy called determinization applying safe trans formation rules automatic way specialize programs reduce nondeterminism 
new features strategy specialization techniques mode information unfolding producing deterministic programs ii case split rule deriving mutually exclusive clauses clause body may derive clauses body body iii enhanced definition folding rules replacing clauses clause reducing nondeterminism 
section show means examples refer parsing matching problems strategy powerful partial deduction conjunctive partial deduction 
particular nondeterministic version matching program derive strategy specialized program corresponds dfa 
logic programs equations disequations terms section introduce extension definite logic programs equations negated equations terms 
negated equations called disequations 
equations disequations program specialization allows derive mutually exclusive clauses 
declarative semantics consider straightforward extension usual herbrand model definite logic programs 
operational semantics essentially sld resolution implemented prolog systems atoms selected left right equations evaluated unification 
operational semantics sound declarative semantics see theorem 
non ground disequations selected goal evaluated operational semantics fail true declarative semantics 
sense operational semantics complete declarative semantics 
notions substitution composition substitutions identity substitution domain substitution restriction substitution instance general unifier abbreviated mgu ground expression ground substitution renaming substitution variant notions defined refer 
syntax syntax language defined starting infinite pairwise disjoint sets variables ii function symbols arity iii predicate symbols arity true 
predicate symbols true said basic predicate symbols said non basic 
predicate symbols called predicates short 
introduce sets iv terms 
basic atoms 
vi non basic atoms 
vii goals 
syntax follows terms tn basic atoms true non basic atoms 
tm goals basic non basic atoms collectively called atoms 
goals basic atoms said basic goals 
goals non basic atom said non basic goals 
binary operator denotes conjunction assumed associative neutral element true 
goal goal true goal true 
clauses syntax clause form non basic atom called head denoted hd goal called body denoted bd 
clause basic goal called unit clause 
write unit clause form true 
say clause predicate iff clause form 
programs sets clauses 
follows feel free different meta variables denote syntactic expressions particular denote non basic atoms goals body body 
program consider relation pairs predicates holds transitive iff exists clause body contains occurrence closure say depends iff holds 
say predicate depends clause program iff clause clause predicate depends terms atoms goals clauses programs collectively called expressions ranged 
vars denote set variables occurring expression say local variable goal clause iff vars vars 
application renaming substitution expression called renaming variables 
renaming variables applied clause needed preserves herbrand model semantics define 
clause renamed apart clause clause obtained renaming variables variable fresh new variable 
formal definition concept see definition standardized apart clause unifiable terms exists mgu relevant variable occurring occurs vars vars idempotent 
loss generality assume mgu considered relevant idempotent 
declarative semantics section extend definition herbrand model definite logic programs logic programs equations disequations terms 
follow approach usually taken defining model clp programs see instance 
approach consider class herbrand models called models predicates true fixed interpretation 
particular predicate interpreted identity relation herbrand universe predicate interpreted complement identity relation 
define herbrand model logic program equations disequations terms model program 
herbrand base hb set ground non basic atoms 
interpretation subset hb 
interpretation ground goal ground clause program relation read true inductively defined follows usual indicate hold true ii ground term iii pair distinct ground terms iv non basic ground atom iff pair ground goals iff vi ground clause iff hd bd vii program iff ground instance clause consequence definition ground basic goal true interpretation iff true interpretations 
say ground basic goal holds iff true interpretations 
interpretation said model program iff model intersection property holds models similarly prove important result 
theorem program exists model set inclusion model 
herbrand model program defined model denoted 
operational semantics define operational semantics programs introducing program relation goals substitution defined follows iff iff unifiable mgu unifiable identity substitution bd iff non basic atom ii renamed apart clause iii hd unifiable mgu 
sequence 
gn called derivation gn true derivation said successful 
exists successful derivation 
true substitution obtained restricting composition variables say goal succeeds answer substitution 
denoting derivations feel free omit associated substitutions 
particular goals write iff exists substitution 
say derived step iff holds 
particular derived step point operational semantics clause reflexive say derived step relation transitive closure goals holds say derived 
feel free omit program understood context 
operational semantics viewed abstraction usual prolog semantics goal order derive goal consider leftmost atom ii predicate interpreted terms iii predicate interpreted non terms 
similarly relationship declarative operational semantics 
theorem program ground goal succeeds converse theorem hold 
consider program consisting clause 
exists value syntactically different 
succeed unifiable terms 
deterministic programs various notions determinism proposed logic programs literature see instance 
capture various properties program succeeds program succeeds exactly program backtrack find alternative solutions 
definition deterministic program 
definition operational semantics described section 
need notation 
program clause goals gn non basic atom write gn iff exists derivation gn ii derived step iii 
ai basic atom iv non basic atom gn basic atom true 
write gn iff exist clauses 
cn cn gn 
definition determinism program deterministic non basic atom iff goal exists clause goal say program nondeterministic non basic atom iff case deterministic exists goal derivable exist goals distinct clauses 
definition program deterministic atom form non zero xs ys xs ground list 

non zero 
non zero xs ys non zero xs ys 
non zero xs ys non zero xs ys notice definition deterministic program non basic atom allows search construction derivation starting may goal derived derive step new goals distinct clauses 
program deterministic evaluating basic atoms occurring leftmost positions new goals derivation continued successful derivation constructed 
instance goal non zero ys derive step distinct goals non zero ys clause ii non zero ys clause 
exists clause clause non zero ys goal non zero ys 
partial deduction unfold fold transformations section recall rule approach partial deduction 
point limitations partial deduction conjunctive partial deduction 
limitations motivate new enhanced rules strategies program specialization sections 
transformation rules strategies partial deduction rule approach partial deduction viewed construction sequence 
pn programs called transformation sequence initial program specialized pn final specialized program 
program pk derived program pk applying transformation rules pd pd 
rule pd atomic definition introduce clause called atomic definition clause form newp 
xh newp non basic predicate symbol occurring 
pk ii non basic atom predicate occurs program iii 
xh vars 
program pk program pk 
denote set atomic definition clauses introduced definition rule construction transformation sequence 
pk 
particular defs 
rule pd definition elimination 
predicate symbol 
definition elimination derive program pk pk depends 
rule pd unfolding 
renamed apart clause pk form non basic atom 
cm clauses pk 
unifiable head ci mgu unfolding 
derive clause di bd ci program pk program pk 
dm 
rule pd atomic folding 
renamed apart clause pk form non basic atom ii substitution atomic definition clause form folding derive non basic atom derive clause 
program pk program pk 
partial deduction program may realized applying atomic definition definition elimination unfolding atomic folding rules called partial deduction strategy describe 
partial deduction strategy uses subsidiary strategies unfold strategy derives new sets clauses repeatedly applying unfolding rule define fold strategy introduces new atomic definition clauses folds clauses derived unfold strategy 
subsidiary strategies unfolding selection function generalization function define 
introduce notation set non basic atoms ii clauses set clauses iii clauses set finite sequences clauses iv clauses powerset clauses sequence clauses denoted 
cn vi empty sequence clauses denoted 
unfolding selection function total function select clauses clauses halt halt symbol occurring 
assume 
cn clauses clauses select cn non basic atom body applying unfold strategy select function follows 
unfolding process starting set cls clauses consider clause say unfolded sequence ancestor clauses sequence cn clauses cls ii 
ck derived unfolding ck iii derived unfolding cn 
select cn non basic atom body unfolded ii select cn halt unfolded 
generalization function gen clauses clauses defined set defs atomic definition clauses non basic atom gen defs clause defs clause form xh xh vars ii instance iii new predicate occurs defs 
applying define fold strategy generalization function gen follows want fold clause non basic atom body consider set defs atomic definition clauses introduced far apply folding rule gen defs 
application folding rule possible construction instance body gen defs 
partial deduction strategy input program non basic atom 
th want specialize output program ppd non basic atom ppd 
xr 
xr vars 
th ii ground substitution 
xr ur 
th iff ppd ppd 
xr 
initialize clause ppd 
xr 
th 
ancestors empty sequence clauses 
defs cls cls unfold exists clause cls select ancestors halt unf derived unfolding select ancestors 
cls cls unf unf ancestors sequence ancestors followed define fold exists clause cls exists non basic atom bd derived folding atomic definition clause gen defs clause derived folding cls cls defs defs defs cls cls derive final program ppd applying definition elimination rule keeping clauses ppd depends 
unfolding selection function select said progressive iff empty sequence clauses clause body contains non basic atom select halt 
correctness result straightforward corollary theorem section 
theorem correctness partial deduction declarative semantics select progressive unfolding selection function 
program non basic atom th partial deduction strategy select terminates output program ppd output atom ppd xr ground substitution xr ur 
th iff ppd ppd 
xr 
say unfolding selection function select halting iff infinite sequence clauses exists select 
cn cn halt 
infinite sequence non basic atoms image generalization function gen sequence sets clauses defined follows newp 
xn xn vars gi gi gen gi ai 
say gen stabilizing iff infinite sequence non basic atoms image gen 
exists gk gn theorem proof similar 
theorem termination partial deduction select halting unfolding selection function gen stabilizing generalization function 
input program non basic atom 
th partial deduction strategy select gen terminates 
example shows unfolding rule partial deduction strategy correct operational semantics 
example consider program 

unfolding clause derive program 

goal succeed succeeds 
address correctness issue detail section set transformation rules correct operational semantics class safe programs see theorem 
example partial deduction string matching section illustrate partial deduction strategy means known program specialization example consists specializing general string matching program pattern see similar example 
program searching pattern string fixed ground pattern want derive new specialized program searching pattern string 
general program called match searching pattern string strings denoted lists program deterministic atoms form match ground lists 
program match initial deterministic 
match match 
match 
match match 
match match 
match match assume want specialize program match goal match want derive program tells pattern occurs string apply partial deduction strategy unfolding selection function generalization function variant 
function clauses clauses halt defined follows leftmost non basic atom body clause ii 
cn leftmost non basic atom body unifiable clause head program partially evaluated iii cn halt exists non basic atom body unifiable clause head program partially evaluated 
function variant clauses clauses defined follows variant defs clause bd variant defs exists clause ii variant defs clause newp 
xh newp new predicate symbol xh vars 
function corresponds determinate unfolding rule considered 
halting variant stabilizing 
example reader may verify partial deduction strategy variant terminates generates specialized program program 
new 
new new 
new new 
new new 
new new 
new 
new new specialized partial deduction deterministic program deterministic atoms form ground list corresponds dfa sense predicate corresponds state ii clause clause corresponds transition state corresponding predicate head state corresponding predicate body iii transition labelled symbol occurring head corresponding clause iv clause new initial state goals form ground list representing word clause corresponds transition labeled unnamed final state remaining portion input word accepted 
partial deduction may derive dfa deterministic string matching program derived program corresponds knuth morris pratt string matching algorithm 
limitations partial deduction fact partial deduction strategy derives dfa consequence fact initial string matching program match sophisticated correctness proof program match straightforward 
partial deduction strategy derive dfa consider program match naive initial program string matching program naive match initial nondeterministic 
naive match append append 
append 
append append program nondeterministic atoms form naive match ground lists 
correctness naive program straightforward pattern string naive match tests occurs looking nondeterministic way strings concatenation order 
reader may verify partial deduction strategy derive dfa starting program naive match 
specialize naive match goal naive match applying partial deduction strategy unfolding selection function generalization function variant derive program naive correspond dfa nondeterministic program naive specialized partial deduction nondeterministic 
naive new new 
new 
new new 
new 
new new naive program looks nondeterministic way strings concatenation pattern string position search restarted shift character right position 
program naive match derive specialized program efficient naive applying conjunctive partial deduction partial deduction 
conjunctive partial deduction viewed sequence applications transformation rules enhances partial deduction may introduce definition clause body conjunction atoms atom see rule pd ii may fold clause conjunction atoms body atom see rule pd 
applying conjunctive partial deduction may avoid intermediate data structures list constructed clause program naive match 
ecce system conjunctive partial deduction naive match program derive specialized program program naive specialized conjunctive partial deduction nondeterministic 
naive new 
new 
new new naive program searches pattern input string looking elements string 
order search succeeds search pattern continues tail string 
naive program efficient initial naive match program correspond dfa searching pattern looks prefix length input string symbol 
failure partial deduction conjunctive partial deduction derive dfa starting naive match program due limitations overcome enhanced transformation rules section 
applying enhanced rules define new predicate introducing clauses bodies non atomic goals applying rules partial deduction conjunctive partial deduction new predicate defined introducing clause 
folding definition clauses enhanced form derive specialized programs nondeterminism reduced intermediate data structures avoided 
enhanced rules called case split rule clause produces mutually exclusive instances clause introducing negated equations 
application rule allows subsequent folding steps reduce nondeterminism 
applying enhanced transformation rules determinization strategy section automatically specialize nondeterministic program naive match goal naive match deriving deterministic program derivation similar section program naive 
naive new 
new new 
new new 
new new 
new new 
new new 
new new 
new new 
new specialized determinization deterministic program naive corresponds straightforward way dfa 
clauses naive pairwise mutually exclusive disequations bodies dropped favor cuts equivalently constructs follows program naive 
naive new 
new new 
new new 
new new 
new new 
new new 
new new 
new new 
new specialized cuts computer experiments confirm final naive program efficient naive match naive naive programs 
section experimental results demonstrate specialized programs derived technique efficient derived partial deduction conjunctive partial deduction 
transformation rules logic programs equations disequations terms section program transformation rules program specialization 
rules extend unfold fold rules considered logic programs atoms denote equations disequations terms 
transformation rules section enhance respects rules pd pd partial deduction considered section 
particular consider definition rule see rule allows new predicates defined clauses bodies non atomic goals rule pd new predicate defined introducing clause body atomic goal 
consider folding rule see rule fold clauses time rule pd fold clause 
addition consider subsumption rule transformation rules introducing eliminating equations disequations head generalization ii case split iii equation elimination iv disequation replacement 
rules preserve herbrand model indicated theorem 
transformation rules similarly section process program transformation viewed transformation sequence constructed applying transformation rules 
mentioned section consider enhanced set transformation rules 
transformation sequence 
pn constructed initial program applications transformation rules follows 

program pk derived program pk selecting possibly empty subset clauses pk ii deriving set clauses applying transformation rule iii replacing pk 
notice rules fact equal rules pd pd respectively 
rewrite reader convenience 
rule definition introduce new clauses called definition clauses form 
newp 
xh body dm 
newp 
xh newp non basic predicate symbol occurring 
pk ii variables xh distinct 
exists 
xi occurs goal iii 
non basic predicate occurring occurs iv 
exists non basic atom program pk program pk dm 
section denote set definition clauses introduced definition rule construction transformation sequence pk 
particular defs 
rule definition elimination predicate symbol 
definition elimination derive program pk pk depends 
rule unfolding renamed apart clause pk form non basic atom 
cm clauses pk 
unifiable head ci mgu unfolding 
derive clause di bd ci program pk program pk 
dm 
notice application unfolding rule clause amounts deletion iff 
literature particular instance unfolding rule treated extra rule 
rule folding 
body cm 
body renamed clauses pk suitable substitution 
newp 
xh body dm 
newp 
xh body clauses newp head predicate 
suppose 
condition holds variable occurring goal body 
xh variable occur ii occur variable occurring different folding 
cm 
dm derive single clause newp 
xh 
program pk program pk 
cm 
instance clauses folded considering substitution definition clauses replace clause 
rule subsumption substitution say clause subsumes clause 
program pk derived program pk deleting clause subsumed clause pk 
rule head generalization clause form body pk substitution occurs occur head generalization derive clause body 
program pk program pk 
rule particular case rule generalization equality considered instance 
rule case split clause pk form body 
case split binding occur derive clauses 
body 
body 
program pk program pk 
rule assume occurs determinization strategy section apply case split rule clause body binding occurs case split rule sufficient derive mutually exclusive clauses 
operational semantics pk clause occurs exists pk clause 
holds interchanging 
return property definitions mutual exclusion 
rule equation elimination clause pk form 
unifiable general unifier equation elimination derive clause 
program pk program pk 
unifiable equation elimination derive program pk pk 
rule disequation replacement clause program pk 
program pk derived pk removing replacing indicate form unifiable replaced form 
tm 
um replaced clauses 
tm um form removed pk form replaced form exists substitution bijective mapping set local variables set local variables replaced 
particular rule disequation occurs twice body clause remove rightmost occurrence 
correctness transformation rules declarative semantics section show suitable hypotheses transformation rules preserve declarative semantics section 
sense say transformation rules correct declarative semantics 
correctness theorem extends similar results holding logic programs case logic programs equations disequations 
theorem correctness rules declarative semantics 
pn transformation sequence constructed transformation rules nonbasic predicate pn 
assume 
folding rule applied derivation clause program pk clauses 
cm program pk clauses 
dm 
exists 
di occurs pj pj derived pj unfolding di 

transformation sequence 
pn definition elimination rule applied applied predicate step deriving pn pn 
ground atom predicate defs iff pn proof simple extension similar result case unfolding folding generalization equality rules 
proof technique adapted prove correctness extended set rules 
example section shown unfolding rule may preserve operational semantics 
examples show transformation rules may preserve operational semantics 
example consider program 


rule may delete clause subsumed clause derive new program 
succeeds succeed 
example consider program 
case split rule may replace clause clauses 

derive new program 
goal succeeds succeed 
example consider program 
rule may replace clause 
derive new program 
goal succeed succeeds 
consider operations body clause removal duplicate atom ii reordering atoms 
examples show operations preserve declarative semantics may preserve operational semantics 
notice removal duplicate atom reordering atoms accomplished transformation rules listed section special case considered point disequation replacement rule 
example consider program 


program obtained replacing clause clause 
goal succeeds succeed 
program true ii program case ii unifiable respectively true hold 
example consider program 


program obtained replacing clause clause 
goal succeeds succeed 
section introduce class programs class goals transformation rules preserve declarative semantics operational semantics 
order associate mode predicate 
mode predicate specifies input arguments predicate assume predicate called input arguments bound ground terms 
see suitable conditions satisfied compliance modes guarantees preservation operational semantics 
fact illustrated examples restrict calls predicate ground arguments initial program derived program operational semantics 
notice incorrectness transformation example depend modes 
order ensure correctness operational semantics rule clauses clause program 
see section clauses consider satisfy condition variable occurs disequation occurs input argument head predicate local variable disequation 
program transformations modes modes provide information directionality predicates specifying argument input output see instance 
mode information useful specifying verifying logic programs existing compilers ciao mercury generate efficient code 
mode information context program transformation provide sufficient conditions ensure reorderings atoms body clause preserve program termination 
mode information specifying classes programs goals transformation rules section preserve operational semantics see section ii designing strategy specializing programs reducing nondeterminism 
modes mode non basic predicate arity expression form 
mh 
mi denoting ground term 
denoting term 
particular unique mode 
atom th mode mh 
term ti said input argument iff mi variable 
th occurrence input argument said input variable 
th 
mode program set modes non basic predicates containing exactly mode distinct non basic predicate occurring notice mode program may may contain modes non basic predicates occur mode program applying transformation rule derive new program occurrences predicate eliminated mode 
rules may eliminate occurrences predicates definition elimination unfolding folding subsumption disequation replacement case 
clearly derive applying definition rule order obtain mode add mode newly introduced predicate 
example program set mode different mode definition mode program non basic predicate 
say atom th satisfies mode iff mode belongs 
argument ti input argument ti ground term 
particular satisfies iff program satisfies mode iff non basic atom satisfies non basic atom goal satisfies example program satisfies mode satisfy mode 
general property program satisfies mode undecidable 
approaches usually followed verifying property uses interpretation methods see instance terminate may return don know answer ii second checks suitable syntactic properties program hand imply mode satisfied 
technique independent specific method verifying program satisfies mode 
reader may verify programs examples section moded satisfy modes 
correctness transformation rules operational semantics introduce class programs called safe programs prove transformation rules applied safe program suitable restrictions hold program derived program equivalent operational semantics 
definition safe programs mode program say clause safe iff disequation body variable occurring input variable hd local variable program safe iff clauses safe instance consider mode 
clause safe clause safe occurs 
mentioning safety property mode feel free omit irrelevant understood context 
order get desired correctness result see theorem need restrict transformation rules indicated definitions 
particular restrictions ensure applying transformation rules program safety mode satisfaction preserved see propositions appendix 
definition safe unfolding pk program mode pk 
consider application unfolding rule see rule section clause pk derive clauses 
bd dm 
bd cm cm clauses pk 
unifiable head ci mgu say application unfolding rule safe mode iff 
disequations bd ci variables occurring input variable local variable ci 
see unrestricted applications unfolding rule may preserve safety consider program 


mode 
unfolding clause atom derive clause 
clause safe occur head 
definition safe folding consider program pk mode pk 
consider application folding rule see rule section clauses pk 
cm 
am km definition clauses 
newp xh dm 
newp 
xh am km derive new clause newp 
xh say application folding rule safe mode iff property holds property input variable newp 
xh input variable non basic atoms occurring 
am 
unrestricted applications folding rule may preserve modes 
consider initial program 

suppose introduce definition clause 
new apply clause split rule deriving 
new 
new program clauses satisfies mode new 
folding clause clause derive 
new application folding rule safe program derived consisting clauses satisfy definition safe head generalization consider program pk mode pk 
say application head generalization rule see rule section clause pk safe iff input variable restrictions considered definition needed preserve safety 
instance clause safe mode 
definition safe case split consider program pk mode pk 
consider application case split rule see rule section clause pk form body derive clauses 
body 
body 
say application case split rule safe mode iff input variable occur variables vars input variable occur applying safe case split rule occurs goal case goals clause clause 
definition formalize property saying clauses mutually exclusive 
similarly unfolding head generalization rules unrestricted case split rule may preserve safety 
instance clause safe mode may derive clauses clause safe shown section see example reordering atoms body clause may preserve operational semantics 
prove particular reordering atoms called disequation promotion consists moving left disequations occurring body safe clause preserves operational semantics 
disequation promotion included reason simplicity transformation rules allows rewrite body safe clause disequation occurs left atom different disequation deriving normal form clause see section 
normal forms simplify proof theorem presentation determinization strategy section 
proposition correctness disequation promotion mode program 
assume safe satisfies clause 
program derived replacing clause clause 
safe ii satisfies iii non basic atom satisfies mode succeeds iff succeeds 
proof point follows fact safety depend position disequation clause 
evaluation goal program operational semantics bind variable get point ii 
point iii consequence points ii fact evaluation bind variable goals 
proposition hold interchange clause 
consider fact clause safe mode 
clause satisfies derivations starting ground instance atom succeed 
contrast clause derivation starting variable bound ground term clause satisfy mode element 
theorem show apply transformation rules safe versions restricted way program satisfies mode safe transformed new program say satisfies safe programs operational semantics 
theorem correctness rules operational semantics pn transformation sequence constructed transformation rules non basic predicate pn 
mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction pn safe suppose conditions theorem hold 
pn safe ii pn satisfies iii atom predicate satisfies mode succeeds defsn iff succeeds pn 
proof see appendix semideterministic programs section introduce concept characterizes class programs obtained determinization strategy section 
reader confuse notion considered 
noticed program deterministic atom definition successful derivation starting succeeds answer substitution 
atom succeeds program answer substitution substitutions general chance transform program new program deterministic atom 
instance consider generalization problem sections pattern string want compute position say occurrence want find strings concatenation ii length program match pos computes program match pos initial nondeterministic 
match pos append append length 
length 
length length 
append 
append append match pos program nondeterministic atoms form match pos ground lists computes answer substitution occurrence suppose want specialize match pos atom match pos 
want derive new specialized program match poss new binary predicate match poss 
new program able compute multiple answer substitutions goal 
instance atom match poss program match poss compute substitutions match poss deterministic atom match poss 
order deal programs may return multiple answer substitutions introduce notion weaker determinism 
informally may say semideterministic program minimum amount nondeterminism needed compute multiple answer substitutions 
section prove determinization strategy terminates derives semideterministic program 
definition program semideterministic non basic atom iff goal exists clause goal different true 
mode program say semideterministic iff semideterministic non basic atom satisfies show section applying determinization strategy match poss derive specialized program match poss semideterministic atoms form match poss ground list 
program match poss 
match poss new 
new new 
new new 
new new 
new new 
new new 
new new 
new new 
new 
new new 
new new specialized semideterministic give simple sufficient condition ensures 
concept mutually exclusive clauses introduce 
need preliminary definitions 
definition satisfiability disequations set variables set variables say conjunction disequations satisfiable iff exists ground substitution domain ground instance holds see section 
particular satisfiable iff ground instance holds 
satisfiability conjunction disequations set variables checked algorithm defined structural induction true empty conjunction disequations satisfiable satisfiable iff satisfiable satisfiable iff occurs non variable term variable occurring distinct satisfiable iff satisfiable 
distinct function symbols satisfiable 
tm um satisfiable iff disequation 
tm um satisfiable correctness algorithm relies fact set function symbols infinite see section 
definition linearity program said linear iff clause non basic atom body 
definition guard clause guard clause denoted grd bd atoms bd disequations grd possibly empty conjunction disequations occurring bd left leftmost atom disequation 
definition mutually exclusive clauses consider mode renamed apart clauses 

predicate arity arguments input arguments ii tuples terms denoting input arguments iii tuples terms 
say mutually exclusive mode iff unifiable ii unifiable mgu grd grd satisfiable vars 
stipulate empty tuples unifiable mgu identity substitution 
proposition useful proving program semideterministic 
proposition sufficient condition linear program ii safe mode iii satisfies iv non unit clauses pairwise mutually exclusive semideterministic proof see appendix section strategy deriving specialized programs satisfies hypotheses iv proposition derived programs semideterministic 
examples show proposition hypothesis program discarded 
example consider program mode 


linear safe satisfies non unit clauses clauses pairwise mutually exclusive 
semideterministic exist non basic goals 
example consider program mode 

linear satisfies safe input variable clauses mutually exclusive set input variables empty satisfiable 
semideterministic exist non basic goals 
example consider program mode 


linear safe satisfy ground term 
clauses pairwise mutually exclusive 
semideterministic exist non basic goals 
example consider program mode 

linear safe satisfies clauses pairwise mutually exclusive 
semideterministic exist non basic goals 
conclude section observing program consists mutually exclusive clauses semideterministic may executed efficiently standard prolog systems inserting cuts suitable way 
return point section discuss speedups obtained specialization technique 
transformation strategy specializing programs reducing nondeterminism section strategy called determinization guiding application transformation rules section 
strategy pursues objectives 
specialization program particular goal 
similar partial deduction 
elimination multiple intermediate data structures 
similar strategies eliminating unnecessary variables conjunctive partial deduction 
reduction nondeterminism 
accomplished deriving programs non unit clauses mutually exclusive mode proposition semideterministic programs 
determinization strategy subsidiary strategies unfold simplify subsidiary strategy uses safe unfolding equation elimination disequation replacement subsumption rules ii partition subsidiary strategy uses safe case split equation elimination disequation replacement subsumption safe head generalization rules iii define fold subsidiary strategy uses definition safe folding rules 
reasons clarity presentation determinization strategy high level descriptions subsidiary strategies 
descriptions establish correctness determinization see theorem 
full details subsidiary strategies sections respectively 
determinization strategy initial program mode atom 
th want specialize introduce definition rule clause ps 
xr th 
xr distinct variables occurring 
th 
define mode ps 
predicate ps stipulating 
mj iff xj input variable 
th mode assume program safe program safe ps 
assume satisfies mode program satisfies mode ps 

determinization strategy iterative procedure iteration manipulates sets clauses set clauses construct specialized program defs set clauses introduced definition rule cls set clauses transformed current iteration 
initially cls consists single clause ps 
xr 
th constructed indicated 
determinization strategy starts iteration applying unfold simplify subsidiary strategy set cls deriving new set clauses called 
unfold simplify strategy unfolds clauses cls simplifies derived set clauses applying equation elimination disequation replacement subsumption rules 
set divided sets set unit clauses ii set non unit clauses 
determinization strategy proceeds applying partition subsidiary strategy deriving new set clauses called 
partition strategy consists suitable applications case split equation elimination disequation replacement head generalization rules set property partitioned sets clauses called packets clauses taken different packets mutually exclusive suitable mode 
determinization strategy continues applying define fold subsidiary strategy clauses deriving new semideterministic set clauses called 
define fold subsidiary strategy introduces possibly empty set definition clauses packet folded single clause set definition clauses defs 
clauses derived folding different packets mutually exclusive semideterministic 
iteration added added defs value set cls updated 
determinization strategy terminates cls new predicate introduced current iteration 
determinization strategy input program atom th want specialize mode safe satisfies output specialized program ps atom ps 
xr 
xr vars th ground substitution xr ur 
th iff ps ps 
xr ii substitution 
xr vr atom th satisfies mode ii 
th succeeds iff ps 
xr succeeds ps ii ps semideterministic ps 
xr 
initialize clause ps 
xr th 
defs cls ms ps 

mj iff xj input variable th mode cls unfold simplify apply safe unfolding equation elimination disequation replacement subsumption rules unfold simplify strategy section cls derive new set clauses 
partition unit clauses occurring set non unit clauses 
apply safe case split equation elimination disequation replacement safe head generalization rules partition strategy section derive set clauses union disjoint subsets clauses 
subset called packet 
packets enjoy properties packet set clauses form modulo renaming variables diseqs diseqs gm diseqs conjunction disequations 
disequation occurs gk clauses packet different packet mutually exclusive mode ms 
define fold apply definition safe folding rules define fold subsidiary strategy section 
strategy introduce possibly empty set new definition clauses set mnew modes mnew exists exactly mode distinct head predicate packet derive single clause form diseqs newp 
application folding rule safe mnew clauses defs 
set clauses derived folding packets 
defs defs cls ms ms mnew derive specialized program ps applying definition elimination rule keeping clauses ps depends 
determinization strategy may fail terminate reasons unfold simplify subsidiary strategy may terminate may perform infinitely unfolding steps ii condition cls exiting loop may false iteration define fold subsidiary strategy may introduce new definition clauses 
discuss issues detail section 
show determinization strategy terminates herbrand model operational semantics preserved 
derived specialized program ps semideterministic ps 
xr indicated theorem 
theorem correctness determinization strategy consider program non basic atom 
th mode safe satisfies determinization strategy terminates output program ps output atom ps 
xr 
xr vars 
th ground substitution xr ur 
th iff ps ps 
xr ii substitution 
xr vr atom 
th satisfies mode ii 
th succeeds iff ps xr succeeds ps ii ps semideterministic ps xr 
proof defs ps set definition clauses specialized program obtained determinization strategy 
ps 
xr 
th clause ps defs 
xr vars 
th ground substitution 
xr ur th iff defs ps 
xr 
correctness transformation rules herbrand model see theorem defs ps 
xr iff ps ps 
xr 
point ii follows theorem determinization strategy application unfolding folding head generalization case split rule safe 
ii observe construction substitution atom 
th satisfies mode iff ps 
xr satisfies mode ms ms mode obtained determinization strategy 
point ii shown proving ps semideterministic ms order prove fact prove semideterministic ms set clauses value variable statement determinization strategy 
ps equal construction ps depend clause final application definition elimination rule clauses removed 
proposition prove linear safe ms satisfies ms non unit clauses pairwise mutually exclusive ms property holds determinization strategy application safe folding rule get clause form diseqs newp single non basic atom occurs body 
clauses unit clauses 
properties follow theorem recalling application unfolding folding head generalization case split rules safe 
property proved showing execution determinization strategy property holds non unit clauses pairwise mutually exclusive ms initially empty property holds 
furthermore property invariant loop 
execution body see point strategy non unit clauses added current value elements set non unit clauses derived applying partition define fold subsidiary strategies points respectively 
construction clauses pairwise mutually exclusive mnew head predicates occur 
clauses pairwise mutually exclusive ms mnew 
consequence assignments see point strategy ms ms mnew property holds 
describe subsidiary strategies realizing unfold simplify partition define fold transformations specified determinization strategy 
see subsidiary strategies action examples section 
application subsidiary strategies convenient rewrite safe clause normal form 
normal form safe clause constructed performing disequation replacements disequation promotions properties hold disequation form different unifiable disequation occurs bd left atom different disequation occurs bd input variables hd hd leftmost occurrence left leftmost occurrence disequation form input variable input variable pair disequations bd exist substitution bijective mapping set local variables set local variables 
normal form safe clause unique modulo renaming variables disequation promotion ii equal disequations occur normal form safe clause iii program mode safe satisfies rewrite clause normal form herbrand model semantics operational semantics preserved fact consequence theorem theorem proposition 
safe clause properties hold said normal form 
clause normal form property disequation bd occurs grd 
unfold simplify subsidiary strategy unfold simplify strategy unfolds clauses cls leftmost atom body keeps unfolding derived clauses long input variables instantiated 
order give formal definition unfold simplify strategy introduce concept 
definition consumer atom program mode non basic atom 
tk said consumer atom iff non unit clause head unifies non basic atom mgu 
ti input argument ti variant ti 
unfold simplify strategy realized unfold simplify procedure expression simplify denotes set clauses derived set clauses applying possible equation elimination rule clauses rewriting derived clauses normal form applying long possible subsumption rule 
procedure unfold simplify cls 
input set cls clauses program mode ms safe ms cls input variables leftmost non basic atom body input variables head output new set clauses derived cls applying safe unfolding equation elimination disequation replacement subsumption rules 
clauses safe ms 
unfold leftmost non basic atom exists clause cls clause derived unfolding leftmost non basic atom body simplify unfold leftmost consumer atom exists clause body leftmost consumer atom say unfolding safe derived unfolding simplify notice assumptions input program clauses cls ensure unfolding step performed unfold simplify procedure safe 
notice unfold simplify strategy may fail terminate 
briefly return issue section 
unfold simplify strategy differs usual unfolding strategies conjunctive partial deduction see instance mode information 
strategy effective examples shown section 
partition subsidiary strategy partition strategy realized procedure write denote atom non basic predicate arity tuple terms denoting input arguments ii tuple terms denoting arguments input arguments 
procedure partition 
input set non unit clauses normal form variables common 
mode ms 
clauses safe ms output set clauses union disjoint packets clauses packet set clauses form modulo renaming variables diseqs diseqs gm diseqs conjunction disequations 
disequation occurs gk clauses packet different packet mutually exclusive mode ms clauses normal form safe ms exist clauses form 
body 
body mutually exclusive mode ms ii variant ii variant mgu substitution bijective mapping set local variables grd set local variables grd grd syntactically equal grd applying disequation promotion take binding follows 
case suppose variant 
case mutually exclusive unifiable exists mgu ti tj binding ta tj ta variant tj 
loss generality may assume 
take binding ta 
case suppose variant mgu 
safe clause normal form disequation form local variable disequation clause mutually exclusive safe clause 
case substitution bind unifiable satisfiable 
exists disequation ta grd ci input variable hd ci substitution bijective mapping set local variables grd ci ci set local variables grd cj cj disequation tb grd cj ta different tb 
input variable hd cj 
loss generality may assume 
take binding ta 
apply case split rule clause derive clauses 
body 
body update value follows simplify 
set partitioned subsets clauses suitable renaming variables disequation promotion subset form diseqs goal um diseqs goal diseqs conjunction disequations 
disequation occurs clauses different subsets mutually exclusive mode ms process subset clauses derived applying safe head generalization rule replace non input arguments heads clauses belonging subset specific common generalization 
subset clauses eventually take form eqs diseqs goal diseqs specific common generalization terms 
um 
goal conjunction equations 
vr vr 
vr vr uk 
move disequations leftmost positions body clause getting set 
notice procedure application case split rule clause safe clauses safe ms ii input variable hd recall choice case ensures input variable hd iii variable input variable hd local variable 
clauses safe mode ms mutually exclusive ms property particularly important mechanization determinization strategy 
theorem partition procedure terminates 
proof see appendix partition procedure terminates returns set clauses union packets clauses enjoying properties indicated output specification procedure 
properties straightforward consequence termination condition statement procedure 
define fold subsidiary strategy define fold strategy realized procedure 
procedure define fold defs 
input mode ms ii set clauses safe ms iii set defs definition clauses 
union disjoint packets clauses computed partition subsidiary strategy 
output possibly empty set definition clauses mode mnew consisting exactly mode distinct head predicate 
input variables leftmost non basic atom body input variables head 
ii set folded clauses 
mnew exists packet form diseqs diseqs gm diseqs conjunction disequations 
disequation occurs gk apply definition safe folding rules follows 
case suppose set defs available definition clauses contains subset clauses form 
xh 
xh gm clauses defs predicate ii xh include variable occurs goals gm occurs goals diseqs property needed correctness folding see section iii 
xi input argument xi input variable mode ms input variable leftmost non basic atom goals gm 
fold packet get diseqs 
xh case defs set definition clauses satisfying conditions described case add clauses new predicate newr newr xh newr xh gm 
xi occurs goals 
gm occurs goals diseqs ii xi input variable leftmost non basic atom goals 
gm 
add mnew mode newr mh 
mi iff xi input variable input variable leftmost non basic atom goals gm 
fold packet consideration get diseqs newr 
xh notice post conditions set derived define fold procedure see point output procedure ensure satisfaction pre conditions set cls input unfold simplify procedure 
recall set cls constructed determinization strategy assignment cls 
recall pre conditions needed ensure unfolding step performed unfold simplify procedure safe 
notice application folding rule safe see definition 
fact implied case condition iii case definition mode newr 
notice define fold procedure terminates 
procedure guarantee termination specialization process iteration loop determinization strategy define fold procedure may introduce nonempty set new definition clauses 
briefly discuss issue section 
examples application determinization strategy section examples program specialization see action determinization strategy unfold simplify partition define fold subsidiary strategies 
complete derivation computing occurrences pattern string consider program match pos section 
mode program match pos match pos append length 
leave reader verify match pos satisfies derivation perform determinization strategy challenging ones literature see instance occurrence pattern string specified initial program see clause nondeterministic way stipulating existence substrings concatenation want specialize match pos program atom match pos 
introduce definition clause 
match poss match pos mode new predicate match poss 
input argument match pos input argument 
transformation strategy starts initial values defs cls match pos ms match poss 
iteration unfold simplify 
unfolding clause leftmost atom body derive 
match poss append append length body clause consumer atoms notice instance mgu append head clause binding input variable 
unfold simplify subsidiary strategy terminates 

partition 
clause partition subsidiary strategy immediately terminates produces set consists single packet clause 
define fold 
order fold clause define fold subsidiary strategy introduces definition clause 
new append append length mode new new 
folding clause clause derive 
match poss new iteration determinization strategy terminates defs cls match pos ms match poss new 
second iteration unfold simplify 
follow subsidiary strategy described section unfold clause cls leftmost atom body 
get 
new append length 
new append append length unfold clauses leftmost consumer atom bodies see underlined atoms 
unfolding clause amounts deletion atom append unifiable head program match pos 
unfolding clause yields new clauses unfolded unfold simplify subsidiary strategy 
unfolding steps derive clauses 
new append 
new append append length partition 
apply safe case split rule clause binding input argument head clause unifiable input argument head clause mgu 
derive clauses 
new append append length 
new append append length set clauses derived far partition subsidiary strategy partitioned packets clauses input argument head predicate form second clause input argument head predicate form partition subsidiary strategy terminates applying safe head generalization rule clauses replace second arguments heads specific common generalization arguments variable 
get packet 
new append 
new append append length packet clause application safe head generalization rule performed 
derived set clauses union packets 
define fold 
set definition clauses fold packet case define fold subsidiary strategy 
introduce new predicate new follows 
new append 
new append append length mode new new 
input variable head clause corresponding packet 
folding clauses clauses derive clause 
new new consider packet clause 
packet folded clause defs 
case define fold subsidiary strategy 
folding clause derive clause 
new new set 
folding steps conclude second iteration determinization strategy assignments defs defs cls ms ms new 
third iteration unfold simplify 
cls clauses derive set clauses 
new append 
new append 
new append append length partition 
set identical 
derive set union packets 
packet consists clauses 
new append 
new append 
new append append length second packet consists clause 
new append append length define fold 
introduce definition clauses 
new append 
new append 
new append append length mode new new 
folding derive clauses 
new new 
new new constitute set 
third iteration determinization strategy terminates assignments defs defs cls ms ms new 
fourth iteration unfold simplify 
cls derive new set clauses 
new append 
new append 
new append 
new append append length partition 
set identical 
derive new set clauses 
new append 
new append 
new append append length 
new append 
new append append length 
new append append length consists packets 
define fold 
introduce new predicates means definition clauses 
new append 
new append append length fold clauses derive set clauses 
new new 
new new 
new new fourth iteration terminates assignments defs defs cls ms ms new 
fifth iteration unfold simplify 
cls derive new set clauses 
new 
new append 
new append append length partition 
set clauses 
derive new set clauses 
new append 
new append append length 
new append append length consists packets 
define fold 
able perform required folding steps introducing new definition clauses see case define fold procedure 
particular fold clauses character return new new new new true finite automaton counter corresponds match poss 
clauses ii fold clause clause 
new definition introduced set cls empty transformation strategy terminates 
final specialized program program match poss shown section 
match poss program semideterministic corresponds finite automaton counter depicted fig 

predicates correspond states automaton clauses correspond transitions 
predicate new corresponds initial state program intended goals form match poss bound list characters clause match poss calls new 
notice finite automaton deterministic state corresponding predicate new automaton accept input string returning value moving final state true input string completely scanned see clause ii move state corresponding new symbol input string scanned see clause iii move state corresponding new symbol input string scanned different see clause 
multiple pattern matching list ps patterns string want compute position say occurrence pattern member list ps 
ps program computes nondeterministic way program initial nondeterministic 
ps match pos 
ps ps atom ps holds iff exists pattern list ps patterns occurs string position predicate match pos defined program match pos section clauses listed 
consider mode program match pos append length 
want specialize multi pattern matching program list patterns 
introduce definition clause 
mode new predicate 
input argument input argument 
determinization strategy starts initial values defs cls ms 
output determinization strategy program program specialized semideterministic 
new 
new new 
new new 
new new 
new new 
new new 
new new 
new new 
new 
new new 
new new 
new new 
new 
new new 
new new similarly single pattern string matching example previous section specialized semideterministic program corresponds finite automaton counters 
finite automaton deterministic states corresponding predicates new new remaining portion input word accepted 
similar derivation performed usual partial deduction techniques prior transformation failure continuation passing style 
regular expressions finite automata example show derivation deterministic finite automaton specializing general parser regular expressions regular expression 
initial program reg expr testing string belongs language denoted regular expression alphabet 
program reg expr initial nondeterministic 
language string accepts 
string 
string string 
string string 
accepts symbol 
accepts append accepts accepts 
accepts accepts 
accepts accepts 
accepts 
accepts ne append accepts accepts 
symbol 
symbol 
ne append 
ne append ne append language holds iff string belongs language denoted regular expression reg expr program predicate ne append holds iff non empty string concatenation nonempty string string 
atom ne append clause ensures terminating program program infinite derivation starting ground goal 
clause replace ne append append may construct infinite derivation goal form accepts derive new goal form accepts accepts 
consider mode program reg expr language string accepts symbol ne append append 
determinization strategy specialize program reg expr atom language aa bb 
introducing definition clause 
languages language aa bb mode new predicate languages input argument language 
output determinization strategy specialized program reg exprs program reg exprs 
languages new 
new 
new new 
new new 
new new 
new new 
new new 
new 
new new 
new new specialized program corresponds deterministic finite automaton 
matching regular expressions specialized semideterministic nondeterministic program defines relation re match regular expression string holds iff exists substring belongs language denoted program reg expr match initial nondeterministic 
re match append append accepts predicates append accepts defined programs naive match see section reg expr see section respectively clauses listed 
consider mode program reg expr match append accept re match 
want specialize program reg expr match regular expression aa introduce definition clause 
re re match aa mode new predicate re input argument re match 
output determinization strategy program program reg expr 
re new 
new new 
new new 
new new 
new new 
new new 
new new 
new new 
new specialized semideterministic similarly single pattern string matching example section specialized semideterministic program corresponds deterministic finite automaton 
specializing context free parsers regular grammars consider program parsing context free languages program cf parser initial nondeterministic 
string parse string parse 
string 
string string 
string string 
parse 
parse terminal parse 
parse nonterminal member append parse 
member 
member member clauses predicate append defined program match pos see section unit clauses stating terminals nonterminals 
argument parse context free grammar second argument list terminal nonterminal symbols third argument word represented list terminal symbols 
assume context free grammar represented list productions form nonterminal symbol list terminal nonterminal symbols 
parse holds iff symbol derive word grammar consider mode program cf parser string parse string parse terminal nonterminal member append 
want specialize parsing program regular grammar aim apply determinization strategy starting definition clause 
string parses parse mode new predicate string parses 
output determinization strategy specialized program cf parsers program cf parsers 
string parses new 
new new 
new new 
new new 
new 
new new 
new new 
new 
new 
new new 
new new specialized semideterministic program corresponds deterministic finite automaton 
discuss improvements achieved example applying determinization strategy 
consider derivation tree see fig 
generated initial parse string parse string parse parse parse parse parse parse successes parse parse parse true derivation tree string parse 
program cf parser starting goal string parse denotes grammar specialized cf parser program denotes list 
occurrences 
nodes labeled goals derived string parse 
particular root derivation tree labeled string parse node labeled goal children labeled goals 
gk derived see section 
tree number nodes 
initial program cf parser takes number steps search derivation root goal string parse goal true 
case uses prolog compiler 
contrast specialized program cf parsers takes steps search derivation goal string parses true derivation tree number nodes see fig 

improvement performance due fact determinization strategy able avoid repeated derivations introducing new definition clauses bodies goals common subgoals derived 
performing folding steps definition clauses reduce search space program execution 
instance strategy introduces predicate new defined clauses new string parse new string parse new string parse bodies goals common subgoals derived 
instance parse derived parse parse see fig 

reader may verify specialized program cf parsers repeated goal derived string parses 
ability determinization strategy putting computations performed initial program different branches computation tree common repeated subcomputations avoided ideas motivate tupling strategy proposed transformation technique functional languages 
experimental evaluation determinization strategy implemented map program transformation system 
program specialization examples sections worked fully automatic way map system 
compared specialization times speedups obtained map system obtained ecce system conjunctive partial deduction 
experimental results reported section obtained string parses new new new true derivation tree string parses 
sicstus prolog running pentium ii linux 
table consider examples sections show times taken performing partial deduction ecce system ii performing conjunctive partial deduction ecce system iii applying determinization strategy map system 
static input shown column table goal specialized programs column 
running ecce system suitable choices available unfolding strategies generalization strategies 
choices suggested system partial deduction conjunctive partial deduction changes specialization performed reasonable amount time 
running map system information provided user mode program specialized 
system assumes program satisfies mode mode analysis performed 
program static input ecce ecce map pd cpd det naive match naive match aab naive match naive match match pos match pos aab match pos match pos aaa aab aa aaa aab reg expr language aa bb reg expr language bb bbb reg expr match re match aa reg expr match re match bb cf parser string parse cf parser string parse table specialization times milliseconds 
experimental results table show map implementation determinization strategy faster ecce implementation partial deduction conjunctive partial deduction 
believe essentially due fact ecce employs sophisticated techniques homeomorphic embeddings controlling unfolding generalization steps ensuring termination specialization process 
fair comparison recall determinization may terminate examples different considered 
mentioned section performance programs derived determinization strategy may improved applying post processing transformations exploit programs 
particular may reorder clauses unit clauses appear non unit clauses ii remove disequations introducing cuts 
reader may verify transformations preserve operational semantics 
systematic treatment cut reader may refer 
example show program obtained match poss see section post processing transformations performed 
program match match poss new new new new new new new new new new new new new new new new new new new new specialized cuts table report speedups obtained partial deduction conjunctive partial deduction determinization determinization followed disequation removal cut 
speedup computed ratio timing initial program timing specialized program 
timings obtained running various programs times significantly large input lists items 
program static input speedup speedup speedup speedup pd cpd det det cut naive match naive match aab naive match naive match match pos match pos aab match pos match pos aaa aab aa aaa aab reg expr language aa bb reg expr language bb bbb reg expr match re match aa reg expr match re match bb cf parser string parse cf parser string parse table speedups 
clarify content table column shows names initial programs sections 
column shows static input 
argument aab denotes list 
similar notation static input arguments 
argument string parse atom denotes regular grammar considered example 
argument string parse atom denotes regular grammar 
column called speedup pd shows speedups obtained application partial deduction 
column called speedup cpd shows speedups obtained application conjunctive partial deduction 
column called speedup det shows speedups obtained application determinization strategy 
column called speedup det cut shows speedups obtained application determinization strategy followed removal disequations cuts 
discuss experimental results table 
examples best speedups obtained application determinization strategy followed removal disequations cuts see column det cut 
expected conjunctive partial deduction gives higher speedups partial deduction 
cases conjunctive partial deduction gives better results determinization see rows columns cpd det 
happens examples nondeterminism avoided eliminating intermediate lists see instance example section 
examples fact determinization strategy may advantageous conjunctive partial deduction introduces disequations may costly check runtime 
mentioned disequations may eliminated introducing cuts equivalently constructs programs derived disequation removal cut efficient derived conjunctive partial deduction see column det cut 
programs see instance entries reg expr cf parser speedups det column equal speedups det cut column 
reason fact absence disequations specialized program cuts improve efficiency 
notice post processing techniques applicable 
instance similarly familiar case finite automata may eliminate clauses corresponding transitions input symbols consumed clause program match poss may minimize number predicate symbols corresponds minimization number states 
post processing techniques outside scope 
summary experimental results table confirm examples considered determinization strategy followed removal disequations favour cuts achieves greater speedups conjunctive partial deduction 
noticed mentioned determinization guarantee termination conjunctive partial deduction order terminate cases conjunctive partial deduction employs generalization techniques may reduce speedups 
section discuss issue devising generalization technique ensures termination determinization strategy 
concluding remarks related proposed specialization technique logic programs automatic strategy called determinization strategy transformation rules definition definition elimination unfolding folding subsumption head generalization case split equation elimination disequation replacement 
safe versions rules 
shown strategy may reduce amount nondeterminism specialized programs may achieve exponential gains time complexity 
get results allow new predicates introduced non recursive definition clauses bodies may contain atom 
allow folding steps definition clauses 
folding step clauses replaced single clause reducing nondeterminism 
subsumption rule motivated desire increasing efficiency avoiding redundant computations 
head generalizations deriving clauses equal heads allow perform folding steps 
case split rule important reducing nondeterminism replaces clause say clauses correspond exhaustive mutually exclusive instantiations head get exhaustiveness mutual exclusion allow disequalities 
increase program efficiency post processing phase disequalities may removed favour cuts 
assume initial program specialized associated mode predicates 
determinization strategy mode information directing various transformation steps particular applications unfolding case split rules 
strategy terminates derives specialized programs semideterministic mode 
notion formally defined section 
guarantee efficiency improvement case efficiency increased nondeterminism reduced redundant computations avoided 
shown transformation rules program specialization correct declarative semantics logic programs herbrand model 
proof correctness result similar proofs correctness results 
considered operational semantics logic language disequation holds iff unifiable 
operational semantics sound complete declarative semantics 
goal operationally succeeds program true herbrand model program vice versa 
proof correctness transformation rules operational semantics previous results elaborate 
requires restrictions related modes predicates programs specialized applicability transformation rules 
section extensively discussed fact specialization technique powerful partial deduction 
main reason greater power technique uses powerful transformation rules 
particular partial deduction corresponds definition definition elimination unfolding folding transformation rules restriction may fold single atom time body clause 
extended rules allow introduce transform new predicates defined terms disjunctions conjunctions atoms recall set clauses head equivalent single clause premise disjunction bodies clauses set 
respect technique improves conjunctive partial deduction specialization technique new predicates defined terms conjunctions atoms 
implemented determinization strategy map transformation system tested implementation performing specializations string matching parsing programs 
compared results obtained map system obtained ecce system conjunctive partial deduction 
computer experiments confirm determinization strategy pays partial deduction conjunctive partial deduction 
transformation technique works programs negative literals allowed body clause disequations terms 
extension determinization strategy normal logic programs require extension transformation rules particular necessary negative unfolding rule rule unfolding clause possibly nonground negative literal different disequation 
correctness unfold fold transformation systems negative unfolding rule studied contexts different considered see instance transformation order programs determinization strategy requires 
determinization strategy may fail terminate reasons unfold simplify subsidiary strategy may apply unfolding rule infinitely ii loop determinization strategy may terminate iteration define fold subsidiary strategy may introduce new predicates 
termination unfold simplify strategy guaranteed applying techniques finite unfolding developed conjunctive partial deduction see instance :10.1.1.16.3949
unfolding rule similar unfolding rule partial deduction 
infinite number new predicates avoided extending various methods generalization conjunctive partial deduction 
recall conjunctive partial deduction may generalize predicate definition essentially means techniques replacement term variable taken argument new predicate definition ii splitting conjunction literals new predicate 
shown ii suitably controlled way allows conjunctive partial deduction terminate cases 
termination guaranteed expense possibly incomplete specialization possibly incomplete elimination intermediate data structures 
order avoid infinite number new predicate definitions applying determinization strategy may follow approach similar case conjunctive partial deduction 
generalization techniques ii mentioned may need iii splitting set clauses defining predicate subsets new predicate subset 
similarly case conjunctive partial deduction shown suitably controlled applications generalization techniques ii iii guarantee termination determinization strategy expense deriving programs may fail semideterministic 
leave research issue controlling generalization achieve termination specialization process time maximize reduction nondeterminism 
string matching examples worked strategy able automatically derive programs behave knuth morris pratt algorithm sense generate finite automaton pattern general pattern matcher 
done case programs matching sets patterns programs matching regular expressions 
examples improvement similar derivations performed partial deduction techniques consists fact started naive nondeterministic initial programs corresponding derivations partial deduction described literature initial programs deterministic 
derivations improve derivations performed supercompilation perfect driving generalized partial computation start initial functional programs incorporate ingenuity 
formal derivation knuth morris pratt algorithm pattern matching 
derivation follows calculational approach consists applying equivalences higher order functions 
hand calculational derivation general takes consideration generic pattern fixed string example hand calculational derivation specific deals single pattern string matching strategy able automatically derive programs larger class includes multi pattern matching matching regular expressions parsing 
case split rule form reasoning cases known technique mechanical theorem proving see instance edinburgh lcf theorem prover 
forms reasoning cases incorporated program specialization techniques mentioned supercompilation perfect driving generalized partial computation 
strategy fully automatic transformation technique uses case reasoning reduce nondeterminism logic programs 
specializing programs reducing nondeterminism strategy able eliminate intermediate data structures 
initial programs examples section intermediate lists specialized programs 
strategy regarded extension transformation strategies elimination intermediate data structures see deforestation technique case functional programs strategy eliminating unnecessary variables case logic programs :10.1.1.30.9032
strategy derives specialized programs avoid repeated subcomputations see context free parsing example section 
respect strategy similar tupling strategy functional programs 
specialization strategy related program derivation techniques called finite differencing 
techniques program invariants avoid costly repeated calculations function calls 
specialization strategy implicitly discovers exploits program invariants folding rule 
noticed difficult establish rigorous way formal connection basic ideas underlying specialization strategy mentioned program derivation methods program invariants 
methods fact different framework 
improved version 
appendix proof theorem reader convenience rewrite statement theorem 
theorem correctness rules operational semantics 
pn transformation sequence constructed transformation rules non basic predicate pn 
mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction 
pn safe suppose 
folding rule applied derivation clause program pk clauses 
cm program pk clauses 
dm 
exists 
di occurs pj pj derived pj unfolding di 

transformation sequence 
pn definition elimination rule applied applied predicate deriving pn pn 
pn safe ii pn satisfies iii atom predicate satisfies mode succeeds defsn iff succeeds pn 
proof theorem divided parts corresponding propositions 
proposition preservation safety shows program pn derived hypotheses theorem safe mode point thesis theorem 
proposition preservation modes shows pn satisfies point ii thesis theorem 
propositions partial correctness completeness show part part respectively point iii thesis theorem 
proving propositions various notions lemmata introduce 

preservation safety section prove transformation rules applied restrictions indicated theorem program safe mode derive program safe mode 
proposition preservation safety 
pn transformation sequence constructed transformation rules 
mode defsn defsn safe ii applications unfolding head generalization case split rules construction pn safe 
program pk safe proof proof proceeds induction proof omit mode particular simply say program clause safe saying program clause safe thesis follows directly hypothesis defsn safe safe 
assume program pk safe 
show pk safe 
consider cases corresponding rule applied derive pk pk 
case pk derived applying definition rule 
pk safe pk safe hypothesis definition clause defs safe 
case pk derived applying definition elimination rule 
pk safe pk safe pk pk 
case pk derived safe application unfolding rule see definition 
consider clause di pk derived unfolding clause pk form atom exists clause ci pk unifiable hd ci mgu ii clause di pk form bd ci show di safe 
take variable occurring disequation body di prove input variable hd di local variable di 
form disequation occurring bd ci 
consider cases case occurs 
form exists variable vars vars 
inductive hypothesis safe input variable hd local variable input variable hd input variable hd di ii local variable local variable di 
case occurs bd ci 
definition safe unfolding input variable local variable ci 
case input variable hd di equal case occur vars vars ci local variable equal di 
case pk derived applying folding rule 
consider clause pk form newp xh derived folding clauses pk 
cm 
am km definition clauses 
newp 
xh dm 
newp 
xh am km take variable occurring disequation body prove input variable local variable disequation occurs hypothesis pk safe input variable 
local variable ci 

local variable ci local variable definition folding rule see rule occur newp xh 
case pk derived applying subsumption rule 
pk safe pk pk 
case pk derived safe application head generalization rule see definition 
clause pk form body derived clause pk form body substitution occurs occur prove safe 
variable occurring disequation body 
inductive hypothesis safe input variable local variable input variable input variable definition safe head generalization follows input variables 
local variable local variable occur case pk derived safe application case split rule see definition clause pk 
consider clauses pk 
body 
body 
derived safe case split show safe 
consider clause variable occurring disequation body 
form occurs body 
consider cases 
case vars 
definition safe case split input variable occur input variable input variable occur local variable 
case vars 
occurs inductive hypothesis safe follows input variable local variable input variable input variable local variable local variable 
safe clause 
consider clause variable occurring disequation body 
occurs body inductive hypothesis safe follows input variable local variable 
definition safe case split input variable ii variable vars ii input variable ii occur body local variable 
safe clause 
case pk derived applying equation elimination rule clause pk form 
consider cases case unifiable general unifier 
derive clause 

show clause safe similarly case 
case unifiable 
case pk safe pk pk inductive hypothesis clauses pk safe 
case pk derived applying disequation replacement rule clause pk 
consider cases rule 
cases straightforward consist deletion disequation bd deletion clause cases safety program pk derives directly safety pk 
consider case 
suppose clause form tm um replaced clauses 

cm 
tm um prove 
cj safe 
consider variable occurring tj uj inductive hypothesis input variable ii local variable 
tm 
um local variable tj uj cj 
case occurs disequation follows directly inductive hypothesis input variable local variable disequation cj 
cj safe 

preservation modes show program defsn satisfies mode apply transformation rules restrictions indicated theorem derived program pn satisfies section rest notation terminology 
consider non basic atoms form 
tm um respectively 
denote conjunction equations 
tm um 
mgu denote relevant mgu unifiable non basic atoms 
similarly mgu denote relevant mgu unifiable terms 
length derivation gn program mode say derivation gn consistent iff 
leftmost atom gi non basic atom satisfies properties operational semantics proved induction length derivations 
lemma program goal 
succeeds answer substitution goals 
lemma safe program mode eqs conjunction equations goal occurrences disequations 
goals exists goal non basic atom satisfy eqs exists goal non basic atom satisfy eqs 
lemma pn transformation sequence constructed transformation rules 
mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction 
pn safe 
goals derivations defsn consistent derivations pk consistent proof proposition 
program pk safe proof proceeds induction base case follows fact derivations derivations defsn 
order prove step case prove statement goals exists goal gs pk gs gs satisfy exists goal gt pk gt satisfy proceed induction length derivation gs pk 
inductive hypothesis assume goals exists derivation pk pk ar gr length ar satisfy exists pk satisfy consider derivation pk pk gs length satisfy gs pk gs satisfy may assume true cases 
case equation 
point operational semantics section derivation gs pk form pk mgu pk pk gs inductive hypothesis exists mgu pk satisfy pk 
case disequation 
proof proceeds case point operational semantics inductive hypothesis 
case non basic atom satisfies 
case satisfy subsumed case point operational semantics derivation gs pk form pk bd mgu hd pk pk gs renamed apart clause pk 
pk pk bd mgu hd thesis follows directly inductive hypothesis 
pk pk prove exists goal gt pk gt satisfy considering cases corresponding rule applied derive case derived applying definition rule 
defsn follows inductive hypothesis hypothesis defsn satisfies case derived unfolding clause pk form conjunction disequations non basic atom proposition may assume disequation occurs 
cm clauses pk 
unifiable head ci mgu form bd ci 
derivation gs pk form pk bd ci pk pk gs mgu inductive hypothesis exists satisfy bd ci pk mgu hd ci relevant vars vars hd ci bd ci pk definition operational semantics point hd ci bd ci pk properties mgu hd ci bd ci pk satisfies safe ci renamed apart vars mgu vars hd ci 
mgu mgu mgu hd ci mgu hd ci bd ci pk lemma exists goal hd ci bd ci pk non basic atom satisfy cases case 
pk pk goal case clause pk mgu pk goal case pk satisfy case hd ci succeeds pk 
follows substitution hd ci bd ci pk hd ci bd ci lemma pk bd ci mgu hd ci pk goal pk pk bd ci mgu hd ci pk clause pk pk mgu relevant ci renamed apart non basic atom satisfy holds 
case derived safe application folding rule see definition 
particular suppose clauses pk 
cm 
am km definition clauses 
newp 
xh dm 
newp 
xh am km derived clause form newp 
xh property definition holds input variable newp 
xh input variable non basic atoms occurring 
am 
derivation gs pk form pk newp 
xh mgu pk gs inductive hypothesis exists goal satisfy holds newp 
xh mgu pk cases case mgu pk goal case 
goal pk ai ki mgu clause ci pk holds 
pk case mgu pk satisfy case mgu succeeds pk substitution pk newp xh pk property newp xh satisfies shown fact 
consider set definition clauses head predicate newp defs 
newp 
xh body newp 
xh substitution goal atom newp 
xh satisfies newp 
xh pk non basic atom satisfy 
exists goal gt pk gt non basic atom satisfy fact 
pk ai ki pk gt non basic atom satisfy holds 
case derived applying head generalization rule 
case follows inductive hypothesis definition operational semantics point 
case derived safe case split see definition clause pk 
proposition may assume form conjunction disequations occurrences disequations 
forms 

input variable occur variables vars input variable occur case 
derivation gs pk takes form pk mgu pk gs inductive hypothesis exists goal satisfy holds mgu pk properties mgu point operational semantics pk conditions safe case split vars mgu vars mgu pk clause pk pk mgu pk holds 
case 
derivation gs pk takes form pk mgu pk gs inductive hypothesis exists goal satisfy mgu pk answer substitution successful disequation identity substitution mgu pk clause pk pk holds 
case derived applying equation elimination rule 
case consequence inductive hypothesis point operational semantics safety pk lemma 
case derived applying disequation replacement rule 
case consequence inductive hypothesis point operational semantics properties unification 
lemma definition proposition 
proposition preservation modes pn transformation sequence constructed transformation rules 
mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction 
pn safe 
program pk satisfies 
partial correctness proving partial correctness transformation rules operational semantics proposition lemmata 
lemma safe program mode eqs conjunction equations goal occurrences disequations 
goals eqs eqs exists goal non basic atom satisfy 
lemma pn transformation sequence constructed transformation rules 
mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction 
pn safe 
goal exists derivation pk pk true consistent pk defs true succeeds pk defs proof hypotheses iii propositions 
program pk safe satisfies goal form exists derivation pk pk true consistent prove pk defsn true proof proceeds induction length derivation 
base case 
goal true thesis follows fact true succeeds programs 
step case 
assume inductive hypothesis goals exists derivation pk true length consistent pk defs true 
cases 
pk case equation 
point operational semantics section derivation form pk mgu pk pk true derivation mgu pk pk true length consistent inductive hypothesis exists derivation mgu true 
pk pk true succeeds pk defsn 
case disequation 
proof proceeds case point operational semantics inductive hypothesis 
case non basic atom satisfies derivation starting consistent 
point operational semantics derivation form pk bd mgu hd pk pk true renamed apart clause pk 
pk pk bd mgu hd thesis follows directly inductive hypothesis 
pk pk prove succeeds pk defsn considering cases correspond rules applied deriving case derived applying definition rule 
clause defsn form newp 
xh derivation form newp th defsn 
xh th pk pk true inductive hypothesis 
xh th pk true newp th pk defsn true case derived unfolding clause pk form conjunction disequations non basic atom proposition may assume disequation occurs 
cm clauses pk 
unifiable head ci mgu form bd ci 
derivation form pk bd ci pk pk true mgu inductive hypothesis bd ci pk true mgu hd ci relevant vars vars hd ci bd ci pk true definition operational semantics point hd ci bd ci pk true properties mgu hd ci bd ci pk true satisfies safe ci renamed apart vars mgu vars hd ci 
mgu mgu mgu hd ci mgu hd ci bd ci pk true lemma cases 
case 
hd ci bd ci pk true case points operational semantics pk true clause pk pk true case exists goal pk non basic atom satisfy mode case goal pk impossible pk satisfy case derived safe application folding rule see definition 
particular suppose clauses pk 
cm 
am km definition clauses 
newp 
xh dm 
newp 
xh am km derived clause form newp 
xh property definition holds input variable newp 
xh input variable non basic atoms occurring 
am 
derivation form pk newp 
xh mgu pk true inductive hypothesis holds newp 
xh mgu pk true substitution pk newp xh pk true property newp xh satisfies shown fact 
consider set definition clauses head predicate newp defs 
newp 
xh body newp 
xh substitution goal atom newp xh satisfies newp 
xh pk true 
body pk true 
fact 
pk ai ki pk true case derived applying head generalization rule 
case pk true follows inductive hypothesis definition operational semantics point 
case derived safe case split see definition clause pk 
proposition may assume form conjunction disequations occurrences disequations 
forms 

input variable occur variables vars input variable occur case 
derivation takes form pk mgu pk true inductive hypothesis mgu pk true properties mgu point operational semantics pk true conditions safe case split vars mgu vars mgu pk true clause pk pk mgu pk true case 
derivation takes form pk mgu pk true inductive hypothesis mgu pk true answer substitution successful disequation identity substitution mgu pk true clause pk pk true case derived applying equation elimination rule 
case true pk consequence inductive hypothesis point operational semantics fact pk safe satisfies lemma 
case derived applying disequation replacement rule 
case pk true consequence inductive hypothesis point operational semantics properties unification 
proposition partial correctness 
pn transformation sequence constructed transformation rules 
mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction 
pn safe 
non basic atom satisfies mode succeeds pk succeeds 
proof suppose non basic atom satisfies successful derivation pk 
proposition pk satisfies successful derivation pk consistent thesis follows lemma 

completeness proofs propositions preservation safety preservation modes partial correctness proceeded induction length derivations cases rule derive program pk program pk 
proof proposition completeness proceed induction sophisticated founded orderings 
proof technique suitable modification weight consistent proof trees 
definition introduces founded orders notions needed proofs section 
definition derivation form gz denote number goals gi gi form non basic atom 
ii define functions program goal return non negative integer assume non negative integers min successful derivation succeeds min length successful derivation succeeds iii program goals write iff 
similarly write iff 
iv programs say derivation gz iff 
gi gi leftmost atom gi basic atom gi gi 
program goals 
exists derivation write 
program relation founded order goals implies 
lemma program goal 
succeeds derivation quasi decreasing proof derivation successful derivations quasi decreasing lemma mode program safe satisfies eqs conjunction equations goals 
suppose disequation occurs derivations goal consistent eqs true iff eqs true ii eqs eqs iii eqs eqs proof induction length derivations 
lemma mode program safe satisfies substitution goals 
suppose disequation occurs derivations goal consistent true true ii iii proof induction length derivations 
lemma mode program safe satisfies diseqs conjunction disequations goal 
suppose vars diseqs vars 
diseqs true iff diseqs true ii diseqs diseqs iii diseqs diseqs proof proof proceeds induction length derivations 
consider transformation sequence pn constructed transformation rules hypothesis theorem 
reasons simplicity assume definition clause folding condition theorem unfolded construction pn 
rearrange sequence pn new sequence defsn pj pl 
pn defsn constructed applications definition rule defsn 
pj constructed unfolding clause defsn pj 
pl constructed applications rules pn derived pn application definition elimination rule predicate rest section refer transformation sequence 
defsn pj pn constructed indicated 
assume mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction 
pn safe propositions 
program pk safe satisfies lemma consider transformation sequence defsn pj constructed indicated 
properties hold 
clauses newp 
xh body defsn substitutions goals derivations body pj consistent body pj newp xh derivations starting newp 
xh pj consistent ii non basic atoms satisfying succeeds defsn succeeds pj 
notice point body succeeds pj newp 
xh succeeds pj 
proof induction length derivations 
proof lemma property 
lemma consider transformation sequence pj 
pl mode defsn indicated 

goals exists derivation pk pk derivations pj consistent derivations pj consistent proof proof proceeds induction length derivation pk pk 
omit details 
lemma consider transformation sequence pj 
pl mode defsn indicated 
goal disequation occurs ii derivations pj consistent 
successful derivation pj successful derivation pk quasi decreasing pj proof consider ordering goals iff pj pj pj pj 
founded order 
proof proceeds induction base case 
case follows lemma 
step case 
assume inductive hypothesis 
goal disequation occurs derivations pj consistent successful derivation pj successful derivation pk quasi decreasing pj consider goal form disequation occurs derivations pj consistent assume exists derivation form pk pk true quasi decreasing pj wish show exists derivation form pk pk true quasi decreasing pj prove existence derivation induction founded order 
assume inductive hypothesis 
goal disequation occurs derivations pj consistent exists derivation form pk pk true quasi decreasing pj exists derivation form pk pk true quasi decreasing pj proceed cases 
case equation 
point operational semantics section derivation form pk mgu pk pk true consider derivation mgu pk pk true proposition mgu succeed pj 
point operational semantics pj pj mgu 
mgu inductive hypothesis exists successful derivation form pk true mgu pk quasi decreasing pj pj mgu derivation pk mgu pk quasi decreasing pj pk true case non basic atom satisfies derivation starting consistent 
point operational semantics pk exists renamed apart clause derivation form pk bd mgu hd pk pk true proposition may assume clause form diseqs diseqs conjunction disequations goal occurrences disequations 
diseqs mgu succeeds form pk diseqs mgu pk pk mgu pk pk true pk pk diseqs mgu pk pk mgu thesis follows inductive hypothesis pj mgu recall quasi decreasing pj 
pk pk construct derivation considering cases correspond rules applied deriving pk pk 
case pk derived unfolding clause pk non basic atom say clause form diseqs 
cm clauses pk 
unifiable head ci 
pk pk dm 
di clause diseqs bd ci mgu hd ci 
reasons simplicity assume 
disequation occurs bd ci 
general case 
bd ci occurrences disequations proof proceeds similar way proposition lemma hypothesis applications unfolding rule safe see definition 
derivation form pk diseqs mgu pk pk true fact quasi decreasing pj point operational semantics definition pj pj diseqs derivation diseqs pk pk true quasi decreasing pj points operational semantics exists clause pk say ci derivation diseqs hd ci bd ci pk pk true quasi decreasing pj pj diseqs hd ci bd ci 
derivations pj consistent derivations diseqs pj consistent lemma derivations pk consistent disequation occurs lemma exists derivation diseqs hd ci bd ci pk pk true quasi decreasing pj pj diseqs hd ci bd ci 
lemma clauses pk safe vars diseqs mgu vars hd ci mgu properties mgu exists derivation hd ci diseqs bd ci pk pk true quasi decreasing pj mgu hd ci mgu 
points operational semantics diseqs succeeds exists derivation form bd ci pk pk true pj bd ci inductive hypothesis exists derivation form bd ci pk quasi decreasing pj pk true diseqs succeeds clause di pk step construct derivation pk diseqs bd ci pk pk true property quasi decreasing pj case pk derived pk safe application folding rule see definition 
particular suppose clause clauses occurring pk 
diseqs cm 
diseqs am km diseqs conjunction disequations disequation occurs 
suppose definition clauses occur 
newp 
xh dm 
newp 
xh am km derived clause form diseqs newp 
xh property definition holds input variable newp 
xh input variable non basic atoms occurring 
am 
pk pk 
cm 
may assume loss generality clause derivation form pk diseqs mgu pk pk true diseqs mgu succeeds consistent lemma mgu succeeds pj 
lemma derivations mgu pj consistent lemmata derivations newp 
xh mgu pj consistent exists derivation form newp 
xh mgu pj pj true quasi decreasing pj disequation occurs newp 
xh mgu inductive hypothesis exists derivation form newp 
xh mgu pk pk true quasi decreasing pj quasi decreasing pj lemma newp 
xh mgu inductive hypothesis exists derivation newp 
xh mgu pk pk true quasi decreasing pj diseqs mgu succeeds clause pk construct derivation pk diseqs newp xh mgu pk true quasi decreasing pj pk pj diseqs mgu quasi decreasing pj diseqs newp xh mgu lemma case pk derived deleting clause pk applying subsumption rule 
clause form diseqs exists clause pk form diseqs 
proposition may assume disequation occurs 
derivation form pk diseqs mgu pk pk true derivations starting pk consistent clause pk diseqs mgu derivations starting diseqs mgu pk consistent disequation occurs lemma exists derivation pk diseqs mgu pk pk true quasi decreasing pj diseqs mgu succeeds exists derivation mgu pk pk true quasi decreasing pj mgu inductive hypothesis exists derivation mgu pk pk true quasi decreasing pj belongs pk diseqs mgu succeeds exists derivation pk diseqs mgu pk pk true quasi decreasing pj case pk derived pk applying head generalization rule clause form body pk pk clause form body 
case show construct derivation quasi decreasing pj point operational semantics ii inductive hypothesis iii fact goals form unifiable terms programs 
case pk derived pk applying safe case split rule see definition clause proposition may assume clause form diseqs diseqs conjunction disequations goal occurrences disequations 
assume derived clauses form 
diseqs 
diseqs input variable occur variables vars input variable occur pk pk 
derivation form pk diseqs mgu pk pk true diseqs mgu succeeds quasi decreasing mgu 
goal mgu occurrences disequations inductive hypothesis exists derivation mgu pk pk true quasi decreasing pj diseqs mgu succeeds exists derivation diseqs mgu pk quasi decreasing pj pk true input variable exists binding mgu ground term 
consider cases 
case unifiable instance case unifiable hypotheses diseqs mgu diseqs mgu construct derivation form pk diseqs mgu pk pk true quasi decreasing pj case unifiable 
mgu succeeds derivation quasi decreasing pj 
pk diseqs mgu pk diseqs mgu pk pk true case pk derived pk applying equation elimination rule clause case existence derivation pk pk true quasi decreasing pj proved inductive hypothesis ii point operational semantics iii fact pk safe satisfies iv lemma 
case pk derived pk applying disequation replacement rule clause case existence derivation pk pk true quasi decreasing pj proved inductive hypothesis ii point operational semantics iii properties unification 
lemma consider transformation sequence pj 
pl mode defsn indicated 

non basic atom satisfies mode succeeds pj succeeds pk 
proof follows lemma atom satisfies succeeds pj successful derivation pj consistent quasi decreasing pj proposition pj satisfies derivations starting consistent lemma program pn derived program pn application definition elimination rule non basic predicate atom predicate succeeds defsn succeeds pn 
proof predicate depends clauses derivation starting derivation defsn derivation pn 
proposition completeness 
pn transformation sequence constructed transformation rules non basic predicate pn 
mode defsn defsn safe ii defsn satisfies iii applications unfolding folding head generalization case split rules construction 
pn safe suppose 
folding rule applied derivation clause program pk clauses 
cm program pk clauses 
dm 
exists 
di occurs pj pj derived pj unfolding di 

transformation sequence 
pn definition elimination rule applied applied predicate deriving pn pn 
atom predicate satisfies mode succeeds defsn succeeds pn 
proof consider transformation sequence pn constructed transformation rules conditions 
mentioned rearrange sequence pn new sequence defsn pj pl 
pn defsn constructed applications definition rule defsn 
pj constructed unfolding clause defsn pj 
pl constructed applications rules pn derived pn application definition elimination rule predicate proposition follows lemmata 
appendix proof proposition proof proposition need lemmata 
lemma consider program conjunction disequations 
succeeds iff ground instance holds 
proof consider conjunction 
rk sk disequations 
ground instance 
rk sk holds iff 
ground substitution ri si holds iff 
ground substitution ri ground term different si iff 
exist ground substitution ri si ground term iff 
ri si unifiable iff rk sk succeeds lemma program safe mode satisfies mode non unit clauses pairwise mutually exclusive mode non basic atom satisfies basic goal exists goal non basic atom 
proof definition relation see section need prove non basic atom satisfies basic goal exists goal non basic atom ii relation constructed applying exactly point operational semantics applying resulting goal points operational semantics times required evaluate leftmost basic atoms 
non unit clauses pairwise mutually exclusive non basic atom satisfies exists non unit clause say unifies hd mgu say grd succeeds fact suppose contrary non unit clauses say 
suppose clause cj renamed apart form cj 
tj uj kj tj tuple terms denoting input arguments ii goal grd guard cj conjunction disequations leftmost atom goal kj disequation 
suppose hd cj unifies mgu satisfies input variables hd cj bound ground terms 
common ground instance relevant mgu domain subset vars exists ground substitution domain vars 
clauses renamed apart property restrict vars tj 
hypothesis grd grd succeed lemma ground instance grd grd holds 
recall goals grd grd ground goals local variables disequation occurring 
safe variable occurring disequation grd occurs tj local variable disequation cj 
property grd grd grd grd 
ground instance grd grd holds ground instance grd grd holds 
words exists ground substitution domain vars ground instance grd grd holds 
definition means grd grd satisfiable vars 
contradicts fact non unit clauses mutually exclusive conclude non basic atom satisfies unifies mgu say head non unit clause say grd succeeds cases case unifies head clauses 
dn non unit clause clauses 
dn unit clauses case ii unifies head clauses dn clauses unit clauses 
consider case 
clause form non basic goal basic goal applying point operational semantics 
form bs bs conjunction basic atoms leftmost atom non basic 
basic atom goal exists goal points operational semantics exists goal bs atom non basic 
derivation starting applying point operational semantics clause dn goal basic goal basic goal derive non basic 
concludes proof lemma case 
proof case ii analogous part case 
give proof proposition 
proof take non basic atom satisfies non basic atom goal satisfies satisfies linear basic goal 
lemma exists goal non basic atom 
exists non unit clause 
means semideterministic appendix proof proposition proof show statement partition procedure terminates 
see consider set value set execution statement 
partitioned maximal sets clauses clauses belong distinct sets mutually exclusive ii clauses say cn belong set exists sequence clauses cn 
clauses ci ci mutually exclusive 
termination proof show termination partition procedure starting exactly maximal set say partition 
case execution partition procedure replacement clause say clauses say satisfies property clauses mutually exclusive mutually exclusive mutually exclusive 
clause renamed apart written form called equational form input arguments generalized new variables new variables bound equations body 
equational form clause denoted eq instance clause body mode 
eq body 
eq set eq 
eq form eqs diseqs body vn un eqs diseqs body 
vi denotes tuple variables input arguments ui denotes tuple arguments input arguments eqs denotes conjunction equations form bind variables vi diseqs denotes conjunction disequations body denotes conjunction atoms different disequations recall clauses normal form 
equations may occur body bind input variable vi ui 
introduce set term subterm occurring eqs diseqs 

execution body statement partition procedure works replacing safe clause say new safe clauses say 
prove termination partition procedure mapping replacements performs corresponding replacements clauses written equational form set eq ii showing set eq undergo infinite number replacements 
consider equational forms eq ceq ceq clauses respectively 
bd eq equation form bd ceq ii bd eq disequation form bd ceq 
exists finite number pairs variable symbol occurring term occurring finite set term subterm occurring mgu finite number elements 
considered mgu finite number elements mgu elements finite number clause heads may common instance 
order conclude proof remains show replacement 
rest proof notion occurrence equation disequation modulo renaming local variables 
case occur bd eq binding mgu input arguments hd hd clauses mutually exclusive occur bd occur bd eq construction occurs bd eq binding mgu input arguments heads clauses clauses obtained result simplify function eliminates occurrence variable case occur bd eq hypothesis variant occurs bd clauses mutually exclusive occur bd eq occur bd choose precisely satisfy condition acknowledgments de schreye gallagher gl ck jones leuschel martens rensen stimulating discussions partial deduction logic program specialization 
acknowledge constructive useful comments anonymous referees 
partially supported ec hcm project logic program synthesis transformation italian ministry education university research 
apt 
logic programming 
van leeuwen editor handbook theoretical computer science pages 
elsevier 
apt 
logic programming prolog 
prentice hall 
bird gibbons jones 
formal derivation pattern matching algorithm 
science computer programming 

method specializing logic programs 
acm transactions programming languages systems april 

transforming left terminating programs 
editor proceedings ninth international workshop logic program synthesis venezia italy september lecture notes computer science pages 
springer 
burstall darlington 
transformation system developing recursive programs 
journal acm january 
danvy gl ck thiemann editors 
partial evaluation 
international seminar dagstuhl castle germany february volume lecture notes computer science 
springer verlag 
de schreye gl ck rgensen leuschel martens rensen 
conjunctive partial deduction foundations control algorithms experiments 
journal logic programming 
debray warren 
automatic mode inference logic programs 
journal logic programming 
deville 
logic programming systematic program development 
addison wesley 
fujita 
algorithm partial evaluation constraints 
technical memorandum tm icot tokyo japan 
futamura takano 
essence generalized partial computation 
theoretical computer science 
gallagher 
tutorial specialisation logic programs 
proceedings acm sig plan symposium partial evaluation semantics program manipulation pepm copenhagen denmark pages 
acm press 

unfold fold transformations definite clause programs 
hermenegildo editors proceedings sixth international symposium programming language implementation logic programming plilp lecture notes computer science pages 
springer verlag 
gl ck 
occam razor metacomputation notion perfect process tree 
cousot falaschi fil editors rd international workshop static analysis padova italy september lecture notes computer science pages 
springer verlag 
gl ck rensen 
roadmap metacomputation supercompilation 
danvy gl ck thiemann editors partial evaluation lecture notes computer science pages 
springer 
gordon milner wadsworth 
edinburgh lcf 
lecture notes computer science 
springer verlag 
henderson somogyi conway 
determinism analysis mercury compiler 
proceedings australian computer science conference melbourne australia pages 
hermenegildo pez 
program analysis debugging optimization ciao system preprocessor 
de schreye editor proceedings international conference logic programming las cruces nm usa nov dec pages 
mit press 
jaffar maher marriott stuckey 
semantics constraint logic programming 
journal logic programming 
jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall 
knuth morris pratt 
fast pattern matching strings 
siam journal computing 
leuschel 
power homeomorphic embedding online termination 
levi editor proceedings fifth static analysis symposium sas pisa italy lecture notes computer science pages 
springer verlag 
leuschel 
ecce partial deduction system library benchmarks release nov 
accessible www ecs soton ac uk mal 
leuschel martens de schreye 
controlling generalization partial deduction normal logic programs 
acm transactions programming languages systems 
leuschel martens de schreye 
achievements prospects partial deduction 
acm computing surveys electronic section es 
liu 
efficiency 
higher order symbolic computation 
lloyd 
foundations logic programming 
springer verlag berlin 
second edition 
lloyd shepherdson 
partial evaluation logic programming 
journal logic programming 
martens de schreye th 
sound complete partial deduction unfolding founded measures 
theoretical computer science 
mellish 
global optimizations prolog compiler 
journal logic programming 
mellish 
interpretation prolog programs 
abramsky hankin editors interpretation languages chapter pages 
ellis horwood 
paige koenig 
finite differencing computable expressions 
acm transactions programming languages systems 

transformation programs tupling strategy 
proceedings informatica bled yugoslavia pages 
renault 
reducing nondeterminism specializing logic programs 
proc 
th acm symposium principles programming languages paris france pages 
acm press 

online partial deduction large programs 
acm sigplan symposium partial evaluation semantics program manipulation pepm copenhagen denmark pages 
acm press 

loop absorption generalization strategies development logic programs partial deduction 
journal logic programming 

unfolding definition folding order avoiding unnecessary variables logic programs 
theoretical computer science 
renault 
system transforming logic programs 
department computer science university rome tor rome italy 
narayan kumar ramakrishnan ramakrishnan 
parameterized unfold fold transformation framework definite logic programs 
proceedings principles practice declarative programming ppdp lecture notes computer science pages 
springer verlag 

automatic partial evaluator full prolog 
new generation computing 
sato 
equivalence preserving order unfold fold transformation system 
theoretical computer science 

recursive unsolvability determinacy solvable cases determinacy application prolog optimization 
proceedings international symposium logic programming boston pages 
ieee computer society press 
smith 
partial evaluation pattern matching constraint logic programming languages 
proceedings acm symposium partial evaluation semantics program manipulation pepm new haven ct usa sigplan notices pages 
acm press 
somogyi henderson conway 
execution algorithm mercury efficient purely declarative logic programming language 
journal logic programming 
tamaki sato 
unfold fold transformation logic programs 
editor proceedings second international conference logic programming uppsala sweden pages 
uppsala university 
turchin :10.1.1.30.9032
concept supercompiler 
acm toplas 
wadler :10.1.1.30.9032
deforestation transforming programs eliminate trees 
theoretical computer science 
warren 
implementing prolog compiling predicate logic programs 
research report department artificial intelligence university edinburgh 

