ibd cm acm transaction january featherweight java minimal core calculus java gj atsushi igarashi university tokyo benjamin pierce university pennsylvania philip wadler labs studies introduced lightweight versions java reduced languages complex features threads reflection dropped enable rigorous arguments key properties type safety 
carry process step omitting features full language including interfaces assignment obtain small calculus featherweight java rigorous proofs possible easy 
featherweight java bears similar relation java lambda calculus languages ml haskell 
offers similar computational feel providing classes methods fields inheritance dynamic semantics closely java proof type safety featherweight java illustrates interesting features safety proof full language remaining compact 
minimal syntax typing rules operational semantics featherweight java handy tool studying consequences extensions variations 
illustration utility regard extend featherweight java generic classes style gj bracha odersky stoutamire wadler give detailed proof type safety 
extended system formalizes time key features gj 
categories subject descriptors programming languages formal definitions theory programming languages language classifications object oriented languages programming languages language constructs features classes objects revised extended version proceedings acm sigplan conference object oriented programming systems languages applications oopsla acm sigplan notices volume number pages october 
done igarashi university pennsylvania research fellow japan society promotion science 
pierce supported university pennsylvania national science foundation ccr principled foundations programming objects 
authors addresses igarashi department graphics computer science graduate school arts sciences university tokyo ku tokyo japan email igarashi tokyo ac jp pierce department computer information science university pennsylvania south rd street philadelphia pa email cis upenn edu wadler mount road ridge nj email wadler com 
permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions programming languages systems vol 
may pages 
ibd cm acm transaction january featherweight java polymorphism logics meaning programs studies program constructs object oriented constructs general terms design languages theory additional key words phrases compilation generic classes java language design language semantics 
inside large language small language struggling get hoare formal modeling offer significant boost design complex real world artifacts programming languages 
formal model may describe aspect design precisely state prove properties direct attention issues overlooked 
formulating model tension completeness compactness aspects model addresses time unwieldy 
sensible choose model complete compact offering maximum insight minimum investment 
strategy may seen flurry papers formal properties java omit advanced features concurrency reflection concentrate fragments full language understood theory applied 
propose featherweight java fj new contender minimal core calculus modeling java type system 
design fj favors compactness completeness having just forms expression object creation method invocation field access casting variables 
syntax typing rules operational semantics fit comfortably pages 
aim omit features possible assignment retaining core features java typing 
direct correspondence fj purely functional core java sense fj program literally executable java program 
fj little larger church lambda calculus barendregt abadi cardelli object calculus significantly smaller previous formal models class languages java including put forth drossopoulou syme nipkow von oheimb flatt 
smaller fj lets focus just key issues 
example discovered tony hoare quote attributed informing second inside large program small program struggling get hoare efficient production large programs fat thin inside 
struck thin man inside fat man george coming air acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi capturing behavior java cast construct traditional small step operational semantics trickier expected point overlooked models 
fj starting point modeling languages extend java 
fj compact focus attention essential aspects extension 
proof soundness pure fj simple rigorous soundness proof significant extension may remain manageable 
second part article illustrates utility enriching fj generic classes methods bracha 
model omits important aspects gj raw types type argument inference generic method calls 
led discovery repair bug gj compiler importantly useful tool clarifying thought 
model small easy contemplate extensions begun adding raw types model far revealed corner design underspecified 
main goal designing fj proof type soundness welltyped programs get stuck concise possible capturing essence soundness argument full java language 
language feature soundness proof longer making significantly different candidate omission dropped features appear interact polymorphism significant ways 
previous studies type soundness java treat advanced mechanisms concurrency inner classes reflection 
addition java features omitted fj include assignment interfaces overloading messages super null pointers base types int bool method declarations shadowing superclass fields subclass fields access control public private exceptions 
features java model include mutually recursive class definitions object creation field access method invocation method override method recursion subtyping casting 
key simplification fj omission assignment 
essence fields method parameters fj implicitly marked final assume object fields initialized constructor changed afterward 
restricts fj functional fragment java common java idioms enumerations represented 
fragment computationally complete easy encode lambda calculus large include useful programs programs felleisen friedman java text purely functional style 
tricky typing issues java gj independent assignment 
important exception type inference algorithm generic method invocation gj twists imposed need maintain soundness presence assignment 
article treats simplified version gj type inference 
remainder article organized follows 
section introduces main ideas featherweight java presents syntax type rules reduction rules develops type soundness proof 
section extends acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java featherweight java featherweight gj includes generic classes methods 
section presents erasure map fgj fj modeling techniques compile gj java 
section discusses related section concludes 

featherweight java fj program consists collection class definitions plus expression evaluated 
expression corresponds body main method full java 
typical class definitions fj 
class extends object super class extends object super class pair extends object object fst object snd pair object fst object snd super fst fst snd snd pair object return new pair snd sake syntactic regularity include supertype object write constructor trivial classes andb write receiver field access inthis snd method invocation receiver 
constructors take stylized form parameter field name field super constructor invoked fields supertype remaining fields initialized corresponding parameters 
example supertype fields invocations arguments 
constructors place appears fj program 
fj provides side effecting operations method body consists return followed expression body 
context definitions expression evaluates expression new pair new new new new pair new new 
forms expression fj 
new new new pair object constructors method acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi invocation 
body expression snd field access occurrences variables 
syntax fj differs java variable keyword 
remaining form expression cast 
expression pair new pair new pair new new new fst snd evaluates expression new 
pair pair fst cast 
cast required field access fst declared contain object field access snd valid pair 
run time checked object stored fst field pair case check succeeds 
java may prefix field parameter declaration keyword final indicate may assigned parameters accessed inner class declared final 
fj contains assignment inner classes matters little appears omit brevity 
dropping side effects pleasant side effect evaluation easily formalized entirely syntax fj additional mechanisms modeling heap 
absence side effects order expressions evaluated affect final outcome modulo nontermination define operational semantics fj straightforwardly nondeterministic small step reduction relation long standing tradition lambda calculus 
course java call value evaluation strategy subsumed general relation soundness properties prove reduction hold java evaluation strategy special case 
basic computation rules field access method invocation casts 
recall lambda calculus rule applications assumes function simplified lambda abstraction 
similarly fj reduction rules assume object operated simplified anew expression 
just slogan lambda calculus function slogan object example shows rule field access action new pair new new snd new due stylized form object constructors know constructor parameter field order fields declared 
fields access field selects second parameter 
rule method invocation action denotes substitution new pair new new new new new pair snd new pair new new new pair new new pair new new snd acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java receiver invocation pair new new sowe look method pair class find formal parameter body new pair snd 
invocation reduces body formal parameter replaced actual special replaced receiver object 
similar beta rule lambda calculus 
key differences fact class receiver determines look body supporting method override substitution receiver supporting recursion self 
readers familiar abadi cardelli object calculus see strong similarity reduction rule abadi cardelli 
fj lambda calculus pure abadi cardelli calculus formal parameter appears body may lead duplication actual side effects causes problems 
rule cast action pair new pair new new new pair new new subject cast reduced object easy check class constructor subclass target cast 
case reduction removes cast 
expression new rule applies computation stuck denoting runtime error 
ways computation may get stuck attempt access field declared class attempt invoke method declared class message understood attempt cast superclass object runtime class 
prove happen typed programs third happens typed programs contain downcasts stupid casts technicality explained 
usual allow reductions apply subexpression expression 
computation second example expression subexpression reduced underlined step 
pair new pair new pair new new new fst snd pair new pair new new snd new pair new new snd new prove type soundness result fj typed normal form expression reduce normal form typed value expression consisting new type subtype type stuck failing 
informal mind may proceed formal definition fj 
syntax syntax fj class declarations constructor declarations method declarations expressions top 
metavariables class names field names acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi fig 

fj syntax subtyping rules auxiliary functions 
method names ranges variables range expressions ranges class declarations ranges constructor declarations ranges method declarations 
assume set variables includes special name argument method 
see restriction imposed typing rules 
considered implicitly bound method declaration 
evaluation rule method invocation job substituting appropriate object addition substituting argument values parameters 
note method bodies ordinary variable special syntax required 
write shorthand possibly empty sequence fn similarly write shorthand mn acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java commas 
write empty sequence denote concatenation sequences comma 
length sequence written 
abbreviate operations pairs sequences obvious way writing cn fn length similarly shorthand sequence declarations cn fn shorthand fn fn 
sequences field declarations parameter names method declarations assumed contain duplicate names 
java assume casts bind tightly forms expression 
class declaration class extends introduces class named superclass new class fields types single constructor suite methods instance variables declared added ones declared superclasses names distinct 
full java instance variables superclasses may case shadows original current class subclasses 
omit feature fj 
methods hand may override methods names add new functionality special constructor super shows initialize fields instance form completely determined instance variable declarations superclasses take exactly parameters instance variables body consist call superclass constructor initialize fields parameters followed assignment parameters new fields names declared 
constraints enforced typing rule classes 
method return introduces method named result parameters types body method single statement return 
variables special variable bound see typing rules prohibit appearing method parameter name 
class table ct mapping class names class declarations program pair ct class table expression 
notation follows assume fixed class table ct class superclass declared extends 
raises question superclass class object 
various ways deal issue simplest take object distinguished class name definition appear class table 
auxiliary functions look fields method declarations class table equipped special cases return empty sequence fields empty set methods 
full java methods 
ignore fj 
looking class table read subtype relation classes 
write subtype subtyping reflexive transitive closure immediate subclass relation extends clauses ct formally defined middle 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi fig 

fj typing rules 
class table assumed satisfy sanity conditions ct class dom ct object dom ct class appearing ct dom ct cycles subtype relation induced ct relation antisymmetric 
conditions identify class table sequence class declarations obvious way 
note types defined class table allowed recursive sense definition class may name types methods instance variables 
mutual recursion class definitions allowed 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java typing reduction rules need auxiliary definitions bottom 
write mean method definition name included fields class written sequence pairing class field name fields declared superclasses 
type class written mtype pair written sequence argument types result type 
java proper method body lookup method name static types actual arguments deal overloading drop fj 
similarly body class written mbody pair written sequence parameters expression note functions mtype mbody partial functions assumed methods fj mtype object mbody object undefined 
typing typing rules expressions method declarations class declarations 
environment finite mapping variables types written typing judgment expressions form read environment expression type abbreviate typing judgments sequences obvious way writing cas shorthand en writing das shorthand cn dn 
typing rules syntax directed rule form expression save rules casts 
straightforward adaptations rules java typing rules constructors method invocations check actual parameter type subtype corresponding formal parameter type 
technical innovation fj stupid casts 
rules type casts subject subclass target downcast target subclass subject stupid cast target unrelated subject 
java compiler rejects ill typed expression containing stupid cast allow stupid casts fj formulate type soundness subject reduction theorem small step semantics 
expression stupid casts may reduce containing stupid cast 
example consider uses classes defined previous section object new new indicate special nature stupid casts including hypothesis stupid warning type rule stupid casts fj typing corresponds legal java typing contain rule 
stupid casts omitted classic java flatt causing published proof type soundness incorrect error discovered independently classic java authors 
typing judgment method declarations form read method declaration ok occurs class uses expression typing judgment body method free variables acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi parameters method declared types plus special variable 
method parameter allowed type environment ill formed 
case overriding method name declared superclass type 
typing judgment class declarations form read class declaration ok checks constructor applies super fields superclass initializes fields declared class method declaration class ok type expression may depend type methods invokes type method depends type expression body check ill defined circularity 
circle broken type method explicitly declared 
possible load class table define auxiliary functions mtype mbody fields classes checked 
method body independently typecheck inspecting bodies methods may invoke 
reduction reduction relation form read expression reduces expression step write reflexive transitive closure 
reduction rules 
reduction rules field access method invocation casting 
explained section 
write result replacing xn dn expression 
reduction rules may applied point expression need obvious congruence rules ife appear 
properties formal definitions fun proof proof 
definitions sensible able prove type soundness result relates typing computation 
prove result term typed reduces normal form value subtype original term type expression gets stuck downcast 
type soundness theorem theorem proved standard technique subject reduction progress theorems wright felleisen 
theorem subject reduction 
cand proof 
see appendix 
chosen nondeterministic reduction relation similar full relation lambda calculus 
naturally restricted reduction strategies defined 
example call value variant fj pierce 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january fig 

fj reduction rules 
featherweight java show program typed way get stuck reaches point perform downcast 
theorem progress 
suppose typed expression 
subexpression fields andf 
includes new subexpression mbody 
proof 
new subexpression typedness subexpression easy check fields defined 
similarly subexpression easy show mbody fact mtype 
state type soundness formally give definition values syntax new 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi theorem fj type soundness 
cand normal form expression containing new proof 
immediate theorems 
state similar property casts say expression type derivations underlying ct downcasts stupid casts uses rules dcast 
words cast safe program includes 
see cast safe expression reduces cast safe expression cast safe expression fail shown pair theorems 
proofs straightforward 
theorem reduction preserves cast safety 
cast safe cast safe 
theorem progress cast safe programs 
suppose cast safe new subexpression corollary errors cast safe programs 
normal form value 
featherweight gj just gj adds generic types java featherweight gj fgj short adds generic types fj 
class definition pairs fj rewritten generic type parameters fgj 
class extends object super class extends object super class pair extends object extends object extends object fst snd pair fst snd super fst fst snd snd extends object pair return new pair snd classes methods may generic type parameters 
parameters class parameter method 
type parameter bound bounded object 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january context definitions expression featherweight java new pair new new new evaluates expression new pair new new extraordinarily write allow abbreviation order fj proper subset fgj 
gj type parameters generic method invocations inferred 
gj expression written new pair new new new invocation 
fj subset java fgj quite subset gj 
regard fgj intermediate language form result type parameters inferred 
fact type arguments optional gj allowed supply explicit type arguments generic method due parsing problem 
example gj expression parsed expressions separated comma 
possible way control inferred type arguments change static types value arguments inserting see gj bracha details 
parameter inference important aspect gj chose fgj concentrate modeling aspects gj 
bound type variable may type variable may type expression involving type variables may recursive bounds mutually recursive 
example classes parameter may bounds extends extends extends 
bounds including examples utility recursive bounds see gj bracha 
gj fgj intended support implementation styles 
may implemented type passing augmenting runtime system carry information type parameters may implemented erasure removing information type parameters runtime 
section explores style giving direct semantics fgj maintains type parameters proving type soundness theorem 
section explores second style giving erasure mapping fgj fj showing correspondence reductions fgj expressions reductions fj expressions 
second style corresponds current implementation gj compiles gj java virtual machine jvm course maintains information type parameters runtime style correspond augmented jvm maintains information type parameters 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi fig 

fj syntax 
syntax syntax fgj 
follows sake conciseness abbreviate symbol 
metavariables range type variables range types range nonvariable types types type variables 
write shorthand xn similarly assume sequences type variables contain duplicate names 
allow abbreviated respectively 
assume fixed class table ct mapping class class declarations essentially sanity conditions 
condition relation class names defined reflexive transitive closure induced clause 
fj typing reduction rules need auxiliary definitions fairly straightforward adaptations lookup rules previously 
fields nonvariable type written fields sequence corresponding types field names type method invocation nonvariable type written mtype type form form variables bound regard convertible ones equivalent application type substitution defined customary manner 
empty abbreviate body method nonvariable type parameters written mbody pair written sequence parameters expression typing environment finite mapping variables types written type environment finite mapping type variables nonvariable types written takes type variable bound 
main judgments fgj type system consist subtyping type wellformedness ok typing abbreviate sequence judgments obvious way sn tn ok tn ok ok en tn acm transactions programming languages systems vol 
may 
ibd cm acm transaction january fig 

fgj auxiliary functions 
featherweight java bounds types 
write bound upper bound defined 
calculi cardelli promotion relation need defined recursively bound type variable nonvariable type 
subtyping 
subtyping relation read subtype defined 
subtyping reflexive transitive closure extends relation 
type parameters invariant regard subtyping usual reasons type parameter argument result type method imply 
formed types 
declaration class begins class type formed substituting respects bounds write ok type formed context 
rules formed types appear middle 
note perform simultaneous substitution variable may appear permitting recursion mutual recursion variables bounds 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi fig 

fgj subtyping type formedness rules 
type environment formed ok dom 
say environment formed respect written ok ok dom 
typing rules 
typing rules expressions methods classes appear 
typing judgment expressions form read type environment environment expression acm transactions programming languages systems vol 
may 
ibd cm acm transaction january fig 

fgj typing rules 
featherweight java typet subtleties field method lookup relations seen typing rules straightforward 
rule gt dcast premise dcast ensures result cast runtime matter highlevel type passing reduction rules defined section erasure semantics considered section 
intuitively holds type arguments contribute relation hold 
example suppose defined classes acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi class list object object 
class linkedlist object list 
cast list permitted 
runtime bound new list cast fail type passing semantics succeed erasure semantics list erases list new list new list erase new list 
hand cl type list cast linkedlist cl permitted type passing erased versions cast guaranteed succeed fail 
formal definition dcast appears 
gj raw types provided overcome lack expressiveness caused restriction 
example programmers write expression list list type argument information lost point type list called raw type 
simplicity model raw types article currently working igarashi 
typing rule methods contains additional subtlety 
fgj gj fj java covariant overriding method result type allowed see rule valid method overriding bottom result type method may subtype result type corresponding method superclass bounds type variables argument types identical modulo renaming type variables 
class table ok class definitions ok reduction operational semantics fgj programs little complicated fj 
rules appear 
rule gr cast empty environment indicates fact subtype checked information runtime type arguments 
properties type soundness 
fgj programs enjoy subject reduction progress properties type soundness property exactly programs fj theorems basic structures proofs similar theorems 
subject reduction parametric polymorphism combined subtyping need lemmas main lemmas required term substitution lemma plus similar lemmas preservation subtyping typing type substitution 
readers familiar proofs subject reduction typed lambda calculi cardelli notice similarities 
required lemmas include substitution lemmas proved straightforward induction derivation tor proof underlying class table assumed ok theorem subject reduction 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january proof 
see appendix 
fig 

fgj reduction rules 
featherweight java theorem progress 
suppose typed expression 
subexpression fields andf 
subexpression mbody 
proof 
similar proof theorem 
fj give definition fgj values state fgj type soundness formally new 
theorem fgj type soundness 
normal form fgj value sand expression containing new proof 
immediate theorems 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi backward compatibility 
fgj backward compatible fj 
intuitively means implementation fgj typecheck execute fj programs changing meaning 
statements subscripts fj fgj show set rules 
lemma 
ct fj class table fields fj fields fgj dom ct 
lemma 
suppose ct fj class table 
mtype fj mtype fgj similarly mbody fj mbody fgj proof 
lemmas easy 
note fj class table substitutions derivations empty polymorphic methods 
show typed fj program typed fgj program fj fgj reduction correspond 
note quite case typedness fj program fgj rules implies typedness fj fgj allows covariant overriding fj 
words fgj conservative extension fj 
theorem backward compatibility 
fj program ct typed typing rules fj typed rules fgj 
fj programs typed fje proof 
half shown straightforward induction derivation fj typing rules followed analysis rules method class 
proof second half directions shown induction derivation reduction relation case analysis rule 

compiling fgj fj explore second implementation style gj fgj 
current gj compiler works translation standard jvm maintains information type parameters runtime 
model compilation framework erasure translation fgj fj 
show translation maps typed fgj programs typed fj programs behavior program fgj matches suitable sense behavior erasure fj reduction rules 
program erased replacing types erasures inserting downcasts required 
type erased removing type parameters replacing type variables erasure bounds 
example class pair previous section erases class pair extends object object fst object snd pair object fst object snd super fst fst snd snd acm transactions programming languages systems vol 
may 
ibd cm acm transaction january pair object return new pair snd similarly field selection new pair new new snd erases new pair new new snd featherweight java added downcast recovers type information original program 
call downcasts inserted erasure synthetic 
key property erasure transformation satisfies called cast iron guarantee fgj program typed downcast inserted erasure transformation fail runtime 
discussion distinguish synthetic casts derived original fgj programs expressions writing behave exactly ordinary 
erasure types erase type remove type parameters replace type variables erasure bounds 
write erasure type respect type environment defined bound 
field method lookup fgj gj subclass may extend instantiated superclass 
means fj java types fields methods subclass may identical types superclass 
order specify type preserving erasure fgj fj necessary define additional auxiliary functions look type field method highest superclass defined 
example consider slight variant generic class pair method declared polymorphic argument element type class pair extends object extends object extends object fst snd pair fst snd super fst fst snd snd pair acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi return new pair snd note erasure class 
subclass declared subclass instantiation pair instantiates class extends pair fst snd super fst snd return new snd method argument type matches argument type pair result type subtype result type permitted fgj covariant subtyping discussed previous section 
erasing class yields class extends pair object fst object snd super fst snd pair object return new snd arguments constructor method erasure result method erasure 
cases types chosen correspond types pair highest superclass fields methods defined 
notice synthetic cast inserted appears required recover type information original program snd 
define variants auxiliary functions find types fields methods highest superclass defined 
maximum field types class written sequence pairs type field name defined follows object class 
maximum method type written defined follows class 
mtype acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java class 
mtype undefined tm return need way look maximum type field 
set fi di 
erasure expressions erasure expression depends typing expression types determine downcasts insert 
erasure rules optimized omit casts trivially safe happens maximum type equal erased type 
write erasure typed expression respect environment type environment var field field cast cast new new new cast strictly speaking think erasure operation acting typing derivations expressions 
typed expressions correspondence typing derivations abuse notation creates confusion 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi erasure methods classes erasure respect type environment written defined follows xi ei di ti ti xi tm return dm return method erasure method definition involves subtlety discussed example 
erasure ti type parameter different corresponding argument type synthetic cast ti inserted parameter appears 

gj actual erasure somewhat complex involving bridge methods ends overloaded methods maximum type instantiated type 
example erasure class extends pair object fst object snd super fst snd pair return new snd pair object return second definition bridge method overrides definition pair 
model extra complexity depends overloading method names modeled fj rule method merges methods inline expanding body actual method body bridge method 
erasure constructors classes super super class extends extends class extends constructor class write ct erasure class table ct defined obvious way 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january fig 

commuting diagram 
featherweight java properties compilation having defined erasure may investigate properties 
discussion backward compatibility subscripts fj fgj avoid confusion 
preservation typing 
typed fgj program erases welltyped fj program expected synthetic casts stupid 
theorem erasure preserves typing 
fgj class table ct ok fgj ct ok fj typing rules fj 
synthetic cast ct involve stupid warning 
proof 
see appendix 
preservation execution 
interestingly intuitively expect erasure fgj fj preserve reduction behavior fgj programs commuting diagram shown 
unfortunately quite true 
example consider fgj expression new pair fst expressions type respectively consider erasure new pair fst 
fgj toa erasure reduces fj reduce anew expression 
note artifact nondeterministic reduction strategy happens adopt callby value reduction strategy method invocation may obtain expression anew expression 
diagram commute step reduction bottom replaced step reduction 
general synthetic casts persist fj expression expect casts eventually turn reduces new expression 
example fj expression reduced synthetic casts 
case may casts reduction step involves method invocation 
consider fgj expression new pair acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi erasure new pair expression type type fgj fgj new pair new pair snd 
fj hand pair new pair snd fewer synthetic casts new pair new pair snd erasure reduced expression fgj 
subtlety observe erased term reduced synthetic casts may coarser casts inserted reduced term erased may removed entirely example 
removal downcasts considered combination operations replacement coarser cast object removal object affect result computation 
formalize observations define auxiliary relation relates fj expressions differing addition replacement synthetic casts 
suppose fj call expression expansion written exp obtained combination addition zero synthetic replacement synthetic casts supertype ofd removal synthetic casts fj example 
suppose classes exp new pair new pair snd exp new pair new pair snd 
reduction commutes erasure modulo expansion theorem erasure preserves reduction modulo expansion 
commutes 
fgj exists fj expression exp words diagram proof 
see appendix 
conversely execution erased expression corresponding execution fgj semantics theorem erased program reflects fgj execution 
suppose exp zero steps acm transactions programming languages systems vol 
may 
ibd cm acm transaction january fig 

fig 

featherweight java removing synthetic casts followed step kinds reduction fgj exp words diagram shown commutes 
proof 
see appendix 
easy corollaries theorems shown fgj expression reduces fully evaluated expression erasure reduces exactly erasure vice versa 
similarly fgj reduction gets stuck stupid cast fj reduction gets stuck vice versa 
corollary erasure preserves execution results 
fgj fj 
similarly fj exists fgj value fgj proof 
theorem exist fj expression fgj exp fj value include dis obtained adding synthetic 
reduces 
second part follows similar argument theorem 
corollary erasure preserves errors 
fgj stuck subexpression new fj stuck subexpression new expansions erasures position modulo synthetic casts erasure similarly fj stuck subexpression new exists fgj expression acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi fgj exp stuck subexpression new expansions erasures position modulo synthetic casts proof 
similar proof corollary theorem 
related core calculi java 
known proofs literature type soundness subsets java 
earliest drossopoulou technique mechanically checked syme prove soundness fairly large subset sequential java 
small step operational semantics avoid subtleties stupid casts omitting casting entirely 
nipkow von oheimb give mechanically checked proof soundness somewhat larger core language 
language include casts formulated big step operational semantics stupid cast problem 
flatt small step semantics formalize language assignment casting 
system somewhat larger syntax typing operational semantics rules take times space soundness proof correspondingly longer similar complexity 
published proof subject reduction earlier version slightly flawed case motivated stupid casts handled properly problem repaired applying refinement 
studies flatt closest important sense goal choose core calculus small possible capturing just features java relevant particular task 
case task analyzing extension java common lisp style mixins extensions core type system 
goal systems hand include large subset java possible primary interest proving soundness java 
class object calculi 
literature foundations objectoriented languages contains papers formalizing class objectoriented languages classes primitive wand bruce bono translating classes lower level mechanisms fisher mitchell bono fisher abadi cardelli pierce turner 
systems pierce turner bruce include generic classes methods fairly simple forms 
generic extensions java 
number extensions java generic classes methods proposed various groups including language agesen myers pizza odersky wadler gj bracha cartwright steele jr lm 
languages believed typesafe study fgj give rigorous proof soundness generic extension java 
gj basis acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java generic extension similar techniques apply forms genericity rest languages 
duggan proposed technique translate monomorphic classes parametric classes inferring type argument information 
defined polymorphic extension java slightly expressive gj example polymorphic methods allowed subclass number type arguments superclass 
type soundness theorem language mentioned stupid cast problem taken account 

discussion featherweight java core language java modeled closely lambda calculus embodying key features java type system 
fj definition proof soundness concise straightforward making suitable arena study ambitious extensions type system generic types gj 
developed extension detail stated fundamental properties proofs 
pleasing discover fgj formulated straightforward extension fj giving additional confidence design gj right track 
investigation fgj led uncover bug compiler involving subtle relation subtyping raw types see 
importantly fgj useful vocabulary notation thinking design gj 
fj quite complete model interesting subtleties gj 
particular full gj language allows parameters instantiated special bottom type delicate rule avoid unsoundness presence assignment 
nonstandard subtyping allowed type argument left hand side recall type constructors invariant 
capturing relevant issues fgj require extending assignment values extensions straightforward cost pleasing compactness fj stands 
subtle aspect gj accurately modeled fgj bridge methods compilation gj jvm bytecodes 
treat compilation exactly gj need extend fj overloading 
formalization gj include raw types unique aspect gj design supports compatibility old code new parameterized code 
currently experimenting extension fgj raw types 
preliminary result igarashi uncovered currently implemented typing system version august raw types unsound repaired version type system incorporated release proved sound 
formalizing generics proven useful application domain fj areas extreme simplicity may yield significant leverage 
igarashi pierce formalized core java inner classes acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi top fj league developed type preserving compilation fj typed intermediate language studer studied denotational semantics fj schultz variant fj formal basis partial evaluation class object oriented languages ancona zucca developed module language java core language formalization close fj 
appendix proof theorem giving proof develop number required lemmas 
lemma 
mtype mtype proof 
straightforward induction derivation note defined ct mtype mtype class 
lemma term substitution preserves typing 
proof 
induction derivation intuitions exactly lambda calculus subtyping details vary little course 
case var 
immediate hand xi bi xi di letting ai finishes case 
case field 
fi fields ci induction hypothesis 
easy show fields fields rule field fi ci 
case 
mtype induction hypothesis lemma mtype transitivity 
rule case new 
new fields acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java induction hypothesis transitivity 
rule new new case 
induction hypothesis transitivity yields rule 
case dcast 
induction hypothesis dor rule dcast respectively 
hand stupid warning rule 
case 
induction hypothesis ande means 
see note class fj just superclass 
follows 
stupid warning 
lemma weakening 
proof 
straightforward induction 
lemma 
mtype mbody exists proof 
induction derivation mbody 
base case defined easy defined ct method 
induction step straightforward 
ready give proof subject reduction theorem 
proof theorem 
induction derivation ofe case analysis reduction rule 
case field 
new fi rule field wehave ei fields new di 
rule new particular ei ci finishing case ci di 
case 
new mbody new rules new wehave new mtype acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi lemma lemma lemma new transitivity 
letting finishes case 
case cast 
new new proof new rule derivation dcast contradicts assumption rules new wehave new finish case 
cases congruence rules easy 
show just case rc cast 
subcases typing rule 
subcase 
induction hypothesis 
transitivity rule additional stupid warning 
subcase dcast 
induction hypothesis 
rule dcast additional stupid warning 
hand andc stupid warning rule 
subcase 
induction hypothesis 
hold argument proof lemma case 
stupid warning 
proof theorem giving proof develop number required lemmas 
lemma weakening 
suppose nok ok 

ok 
tand proof 
proved straightforward induction derivation tand ok lemma 
proof 
easy see easily proved contradiction 
similar argument proof lemma acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java lemma 
suppose dcast proof 
case dcast dcast dcast easy note derivation derive direct superclass rule class class 
similarly fv case finishing proof 
lemma dcast andc dcast dcast 
proof 
easy 
lemma type substitution preserves subtyping 
ok appearing proof 
induction derivation case refl 
trivial 
case trans class 
easy 
case var 
ifx dom dom immediate 
hand ifx xi assumption ui ni 
lemma finishes case 
lemma type substitution preserves type formedness 
ok ok appearing tok 
proof 
induction derivation ok case analysis rule 
case wf object 
trivial 
case wf var 
dom xi follows ok lemma immediate 
case wf class 
ok class 
induction hypothesis tok 
hand lemma rule gt class include free variable 
ok wf class 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi lemma 
suppose ok ok appearing 
bound bound 
proof 
case nonvariable type trivial 
case type variable dom dom easy 
type bound ui bound ni assumption nand lemma finish proof 
lemma 
fields bound fields bound si ti gi fi 
proof 
straightforward induction derivation case refl 
trivial 
case var 
trivial bound bound 
case trans 
easy 
case class 
class 
rule class fields fields 
lemma ok mtype bound ok mtype bound 
proof 
straightforward induction derivation case analysis rule 
case refl 
trivial 
case var 
trivial bound bound 
case trans 
easy 
case class 
class 
include declaration easy show mtype bound mtype bound rule mt super 
hand suppose includes declaration ofm 
straightforward induction derivation mtype show mtype mtype 
loss generality assume distinct particular 
method case 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java lemmas 
mtype bound mtype class letting finishes case 
lemma type substitution preserves typing 
ok appears proof 
induction derivation case analysis rule 
case gt var 
trivial 
case gt field 
fi fields bound ti induction hypothesis 
lemma bound bound 
easy show bound bound 
lemma fields bound ands 
rule gt field fi si 
letting si ti finishes case 
case gt 
mtype bound ok induction hypothesis lemma easy show bound bound 
lemma mtype bound 
lemma acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi loss generality assume distinct appear 
lemma rule trans 
lemma 
rule gt finishing case 
case gt new gt 
easy 
case gt dcast 
bound bound dcast induction hypothesis 

subcases relation subcase 
bound rule gt subcase 
bound bound lemma fact implies bound bound bound bound 
bound 
ifc lemma dcast rule gt dcast finishes subcase 
case happen implies bound 
cased trivial 
subcase 
bound bound lemma fact implies bound bound bound bound 
bound 
show contradiction holds 
suppose exist bound 
lemma dcast follows lemma contradicting assumption bound hand suppose bound bound bound bound 
lemma contradicting assumption bound acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java rule gt stupid warning 
case gt 
bound induction hypothesis 
lemma bound bound 
bound 
case bound lemma rule gt stupid warning finishing case 
lemma term substitution preserves typing 
proof 
induction derivation case analysis rule 
case gt var 
dom immediate hand xi ti letting si finishes case 
case gt field 
fi fields bound ti induction hypothesis 
lemma fields bound thats andf 
rule gt field fi case gt 
mtype bound ok induction hypothesis lemma mtype bound lemma rule gt method letting finishes case 
new gt 
easy 
case gt dcast 
bound bound dcast induction hypothesis 
subcases relation subcase 
bound acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi rule gt subcase 
bound bound lemma fact implies bound bound bound bound 
bound 
ifc lemma dcast rule gt dcast finishes subcase 
happen implies bound case trivial 
subcase 
bound bound bound 
show contradiction 
transitivity fact implies bound bound bound 
contradicting assumption bound 
hand suppose bound bound bound bound 
lemma contradicting assumption bound 
rule gt stupid warning 
case gt 
bound induction hypothesis implies bound bound 
bound 
lemma rule gt stupid warning 
lemma mtype mbody ok ok exist ok ok proof 
induction derivation mbody lemmas 
case mb class 
class 
return rules gt class gt method wehave 
ok nby rule wf class 
lemmas 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java assume distinct loss generality 
rule mt class wehave rule trans lemmas assume occur loss generality letting finishes case 
case mb super 
class 
immediate induction hypothesis fact proof theorem 
induction derivation case analysis reduction rule 
show main cases 
case gr field 
new fi fields ei rules gt field gt new wehave new particular ei si finishes case 
case gr 
new mbody new rules gt gt new wehave new mtype bound ok nok lemma ok ok lemmas new rule trans wehave finishes case 
case gr cast 
easy 
case field 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi rule gt field wehave fields bound ti induction hypothesis 
lemma fields bound gi fi ti ti 
rule gt field ti letting ti finishes case 
case inv recv 
rule gt wehave mtype bound ok induction hypothesis 
lemma mtype bound lemma rule gt letting finishes case 
case cast 
subcases typing rule gt gt dcast gt 
subcases similar subcases case gt dcast proof lemma 
case inv arg new arg 
easy 
proof theorem show expression typed type formed lemma 
note assume underlying gj class table ct ok lemma 
tand ok formed type environment ok proof 
induction derivation case analysis rule 
cases refl trans easy 
case var 
formed formed 
case class 
class 
ok ct ok ok rule gt class 
lemmas ok acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java lemma 
fields fgj ok formed type environment ok proof 
induction derivation fields fgj case analysis rule 
case object 
trivial 
case class 
class fields fgj ct ok rule gt class ok lemmas ok induction hypothesis ok ok ok nby rule wf class 
hand rule gt class wehave ok lemmas ok finishing case 
lemma 
mtype fgj ok wellformed type environment ok proof 
induction derivation mtype fgj case analysis rule 
case mt class 
class 
return loss generality assume distinct 
rules gt class gt method wehave ok hand ok ok nby rule wf class 
lemmas ok finishing case 
case mt super 
ct ok rule gt class ok lemmas ok induction hypothesis finishes case 
lemma 
ok fgj formed type environment ok proof 
induction derivation fgj case analysis rule 
case gt var 
immediate definition formedness 
case gt field 
fgj bound acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi induction hypothesis ok formed bound ok lemma ok finishing case 
case gt 
fgj mtype fgj bound ok fgj induction hypothesis ok formed bound ok lemma ok lemma ok finishing case 
case gt 
fgj induction hypothesis ok lemma ok finishing case 
case gt new gt dcast gt 
immediate fact formed premise rules 
developing lemmas erasure prove theorem 
note discussions erased class table ct assumed ok ct ok erased class table ct defined fj defined ct 
lemma 
fj 
proof 
straightforward induction derivation 
lemma 
ok appear fgj fj 
proof 
nonvariable type result trivial 
type variable xi easy ti lemma ti ti fj ni ni 
lemma 
ok fields fgj fgj proof 
induction derivation fields fgj lemma fact class derived rule wf class 
lemma 
ok mtype fgj fgj fj 
proof 
ok sequence type object si derived rule class prove induction length sequence 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january case 

case class object 

featherweight java definition loss generality assume distinct 
definition mtype fgj fgj rule wf class wehave appear 
lemma fj fj finishing case 
case 

suppose class 
note fgj rule class 
subcases subcase 
undefined 
method declared similarly base case 
subcase 
defined defined bythe rule gt method case lemmas fj 
induction hypothesis transitivity fj finish subcase 
subcase 
mtype fgj defined defined easy mtype fgj mtype fgj rule mt super 
induction hypothesis finishes subcase 
proof theorem 
prove theorem steps shown fgj fj second show ct ok part proved induction derivation fgj case analysis rule 
case gt field 
fi fgj bound ti induction hypothesis fj 
lemma ok type variable lemma note definition obvious fields fj 
rule field wehave fj fi ci 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi ti ci equation fi fi derived rule field finishes case 
hand ti ci fi ti fi rule field cast fj fi rule dcast finishing case 
note synthetic cast stupid 
case gt 
similar case 
case gt new gt gt dcast gt 
easy 
notice nature cast stupid preserved 
second part ct ok follows part examination rules gt method gt class 
show ok suppose rule gt method wehave tm tx return dm dx return xi ei di ti ti xi 
fgj mtype fgj fgj class 
show fj mtype fj result part fj 
lemma ti di di ei ti 
lemma fj 
hand lemma 
fj lemma transitivity 
lete bec 
suppose defined 
mtype fgj defined 
definition mtype fj 
easy show fgj implies ok fj 
proof theorems rest section prove theorems corollaries prove required lemmas 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java lemma 
exp fj fj exp proof 
induction derivation fj lemma 
suppose dom dom appears 
fgj fgj ok fgj dom obtained combination replacements synthetic casts removals synthetic casts 
proof 
induction derivation case analysis rule 
case gt var 
trivial 
case gt field 
bound ti induction hypothesis obtained combination replacements synthetic casts removals synthetic casts 
theorem fj 
lemma fj subcases 
subcase 
ti ci rule field cast ti fi 
show fi fj 
lemmas lemmas lemma hand fgj fgj 
fields fgj bound ti fj ti 
rule field cast fi ti finishing subcase 
subcase 
ti ci acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi similar subcase 
case gt method 
fgj mtype fgj ok fgj fgj fgj induction hypothesis obtained combination replacements synthetic casts removals synthetic casts 
theorem fj 
lemma fje 
subcases subcase 
rule cast show 
fj 
lemmas fgj fgj 
loss generality assume distinct 
lemmas lemma mtype fgj bound fgj 
fgj lemma fgj 
lemmas fj fj 
hand easy show 
rule cast finishing subcase 
subcase 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java similar subcase 
case gt new gt gt dcast gt 
immediate induction hypothesis 
lemma 
suppose mbody fgj mtype fgj ok fgj fgj mbody fj exp proof 
induction derivation case analysis rule 
case mb class 
class 
sx return 
rule wf class fgj 
lemma obtained combination replacements synthetic casts fja removals synthetic casts 
theorem fj 
ei xi di si si xi 
fj fj lemmas ei variable variable environment 
fj fj lemma 
finishing case 
exp case mb super 
class 
induction hypothesis acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi lemma fig 

exp exp lemma obtained combination replacements synthetic casts fja removals synthetic casts 
hand lemma finishing case 
fj exp lemma 
fgj fgj exists fj expression fj exp fj words diagram shown commutes 
proof 
induction derivation fgj case analysis reduction rule 
show main base cases 
case gr field 
new fi fields fgj ei subcases depending erasure rule 
subcase field cast 
new fi definition erasure 
fields fj wehave fj ei 
hand theorem fgj ei ti ti 
theorem fj ei ti 
ti lemma ei obtained adding ei 
subcase field 
new fi follows induction hypothesis 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january fig 

case gr 
new mbody fgj new featherweight java subcases depending erasure rule 
subcase cast 
new mbody fgj defined mbody fj defined 
mbody fj types lemma lemma exp exp new note new 
theorems fj 
lemma 
exp 
exp new subcase 
similarly subcase 
case gr cast 
easy 
lemma 
fj fj exp exists fj expression exp fj words diagram shown commutes 
proof 
induction derivation fj case analysis reduction rule 
case field 
new fi fields fj ei acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi fig 

expansion form dn new fi exp di introduced 
fj new fi fj di 
base cases similar cases induction steps straightforward 
proof theorem 
induction length reduction sequence fgj case 
trivial 
case 
fgj fgj commuting diagram shown 
commutation proved lemma induction hypothesis lemma 
lemma 
suppose fgj fj fgj exp words diagram commutes 
proof 
induction derivation fj case analysis rule 
show main cases 
case rc cast 
subcases cast synthetic 
case follows induction hypothesis 
show case fj 
field access method invocation 
case analysis reduction rule derivation fj 
cases rc field rc recv rc arg omitted acm transactions programming languages systems vol 
may 
ibd cm acm transaction january follow induction hypothesis 
subcase field 
new fi ei fields fj fig 

featherweight java inspecting derivation case new fi ci 
theorems fgj ei fgj ei 
theorem fj ei 
lemma exp fj 
ei ei finishing case 
subcase 
new em new em inspecting derivation case new 
theorems 
case fgj new em em fgj new em theorem fact new em new em types wehave fj new em 
fj lemma new em exp new em 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi hand lemma fig 

em exp em 
lemma new em exp new em 
new em exp new em 
fact transitivity expansion relation new em exp new em case field 
similar subcase field case rc cast 
case 
similar subcase case rc cast 
case cast cases induction steps straightforward 
exp lemma 
suppose fgj tand zero steps removing synthetic casts followed step kinds reduction fj exp words diagram commutes 
proof 
induction derivation reduction step case analysis rule 
case field 
fj new fi fd ei form dn new fi wherec di ei reduces ei removing steps 
exp exp words 
expression fi new fi exp fj ei fj ei easy see exp ei ei exp ei ei 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january featherweight java base cases similar induction steps straightforward 
proof theorem 
follows lemmas 
acknowledgments robert harper anonymous referees oopsla toplas valuable comments suggestions 
abadi cardelli 
theory objects 
springer verlag new york ny 
agesen freund mitchell 
adding type parameterization java language 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla 
sigplan 

acm press atlanta ga 
ancona zucca 
true modules java languages 
proceedings th european conference object oriented programming ecoop knudsen ed 
lecture notes computer science 
springer verlag budapest hungary 
barendregt 
lambda calculus revised ed 
north holland amsterdam netherlands 
bono fisher 
imperative order calculus object extension 
proceedings th european conference object oriented programming ecoop jul ed 
lncs 
springer verlag 
bono patel shmatikov 
core calculus classes mixins 
proceedings th european conference object oriented programming ecoop 
lncs 
springer verlag 
bono patel shmatikov mitchell 
core calculus classes objects 
proceedings th conference mathematical foundations programming semantics mfps xv 
elsevier 
available www elsevier nl locate entcs volume html 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla chambers ed 
acm press new york ny 
bruce 
paradigmatic object oriented programming language design static typing semantics 
funct 
program 
april 
cardelli martini mitchell scedrov 
extension system subtyping 
inf 
comput 

cartwright steele jr 
compatible genericity run time types java programming language 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla chambers ed 
acm press new york ny 
drossopoulou eisenbach khurshid 
java type system sound 
theory pract 
object syst 

duggan 
modular type reverse engineering parameterized types java code 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla ed 
acm press new york ny 
felleisen friedman 
little java patterns 
mit press cambridge ma 
fisher mitchell 
relationship classes objects data abstraction 
theory pract 
object syst 

flatt krishnamurthi felleisen classes mixins 
proceedings acm sigplan sigact symposium principles programming languages 
acm press new york ny 
acm transactions programming languages systems vol 
may 
ibd cm acm transaction january igarashi flatt krishnamurthi felleisen 
programmer reduction semantics classes mixins 
tech 
rep tr computer science dept rice university 
feb corrected version june 
igarashi pierce 
inner classes 
proceedings th european conference object oriented programming ecoop bertino ed 
lncs 
springer verlag 
extended version appear inf 
comput 
igarashi pierce wadler 
recipe raw types 
informal proceedings th international workshop foundations object oriented languages fool 
london uk 
available www cs williams edu kim fool fool html 
league trifonov shao 
type preserving compilation featherweight java 
informal proceedings th international workshop foundations object oriented languages fool 
london uk 
available www cs williams edu kim fool fool html 
myers bank liskov 
parameterized types java 
proceedings acm sigplan sigact symposium principles programming languages 
acm press new york ny 
nipkow von oheimb 
java light type safe definitely 
proceedings acm sigplan sigact symposium principles programming languages 
acm press new york ny 
odersky wadler 
pizza java translating theory practice 
proceedings acm sigplan sigact symposium principles programming languages 
acm press new york ny 
pierce 
types programming languages 
mit press cambridge ma 
pierce turner 
simple type theoretic foundations object oriented programming 
funct 
program 
april 
schultz 
partial evaluation class object oriented languages 
proceedings nd symposium programs data objects pado ii danvy filinski eds 
lncs 
springer verlag 
studer 
constructive foundations featherweight java 
available unibe ch 
syme 
proving java type soundness 
tech 
rep computer lab 
univ cambridge 
june 

parametric polymorphism java approach translation reflective features 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla lea ed 
acm press new york ny 
wand 
type inference objects instance variables inheritance 
tech 
rep nu ccs college computer science northeastern univ feb wright felleisen 
syntactic approach type soundness 
inf 
comput 
nov 
received july accepted december acm transactions programming languages systems vol 
may 
