approved scalable visual hierarchy exploration daniel thesis submitted faculty worcester polytechnic institute partial fulfillment requirements degree master science computer science may professor elke rundensteiner thesis advisor professor matthew ward thesis advisor professor carolina ruiz thesis reader professor micha head department cu mei 
modern computer applications business decision support scientific data analysis utilize visualization techniques support exploratory activities 
visualization tools scale regard size dataset operate 
specifically level cluttering screen typically unacceptable performance poor 
solve problem cluttering interface level visualization tools extended support hierarchical views data support focusing drilling interactive brushes 
solve scal ability problem thesis investigates best couple visualization tool database management system losing real time characteristic required interactive application 
integration done carefully visual user interactions implemented main memory operations map directly efficient database operations 
context main efficiency issue avoid recursive processing required hierarchical data retrieval 
problem developed tree labeling method called minmax tree allows movement line recursive processing line precomputation step 
run time recursive processing operations translate linear cost range queries 
secondly employ main memory access strategy support incremental loading data main memory 
reduce response time system designed speculative non pure prefetcher brings data memory system idle 
techniques incorporated xmdvtool multidimensional visual exploration tool order achieve scalability 
tool efficiently scales datasets order records 
lastly report experimental results illustrate impact proposed techniques system performance 
professors friends support 
supported nsf iis nsf cise instrumentation iris 
contents caching prefetching large scale visualization 
approach 
contributions 
thesis organization 
related visual hierarchy exploration 
visualization database integrated systems 
relational processing hierarchies 
join processing 
hierarchy encoding 
main memory processing 
high level caching 
prefetching 
multivariate data visualization brush basics 
hierarchical clustering 
structure brushes 
ii creation manipulation 
geometric representation 
multidimensional extension 
model abstraction 
query specification minmax hierarchy encoding 
query processing minmax 
static tree hierarchies 
dynamic tree hierarchies 
arbitrary hierarchies 
memory management caching 
semantic caching 
probabilistic model 
cache replacement 
dbi case 
prefetching 
general characteristics 
strategies 
implementation system architecture 
threads synchronization 
interacting database 
iii experimental results user input 
settings 
experiments 


navigation operations notation conventions 
hierarchical clustering 
structure brushes 
structure brush 
structure brush 
relational semantics structure brushes 
minmax hierarchy encoding proof theorem 
proof theorem 
proof theorem 
complexity memory operations full size probability table 
reduced probability table 
iv list figures architecture main memory implementation 
architecture database implementation 
additional computation steps intensive 
structure brush combination focus region density factor 
structure brush combination horizontal vertical selection 
partition map tree hierarchy 
hierarchical tree obtained clustering 
structure brushing interface xmdvtool 
hierarchical tree frame contour corresponding current level detail leaf con tour approximates shape hierarchical tree structure brush interactive brush handles color map legend level detail con tour 
initial selection brush values 
initial selection brush values 
hierarchy map 
uniform levels detail 
hierarchy map 
arbitrary level detail function 
selection space abstraction 
active window selection space 
tree example 
navigation tree support set 
navigation grid 
active window 
base set 
objects level totally ordered 
continuous minmax tree 
discrete minmax tree 
structure brush 
structure brush 
allocation strategy 
arbitrary hierarchy 
bottom labeling arbitrary hierarchy 
la regions equal probability 
la regions equal probability 
la regions equal probability 
buffer content level twelve object example case re duced probability table 
finishing reading 
current objects painted solid overwritten ob jects stripped 
dash lines undefined pointers 
starting re reading 
traversal direction changes consumer producer 
buffer inconsistent state 
vi system architecture 
oval depicts initial data 
dash lines rect angles represent threads processes 
solid line rectangles agents 
squares represent meta knowledge 
solid arrows show control flow 
dash arrows show creation child threads 
system architecture 
oval depicts initial data 
dash lines rect angles represent threads processes 
solid line rectangles agents 
squares represent meta knowledge 
solid arrows show control flow 
dash arrows show creation child threads 
hot regions selections navigation space provides useful insight data 
minmax vs recursive 
structure brushes dataset 
minmax vs recursive 
structure brushes dataset 
minmax vs recursive 
structure brushes dataset 
varying level value 
functions compared logarithmic scale 
varying extent value 
functions compared 
varying dataset size 
levels defined 
varying delays strategy 
measured quality 
varying delays strategy 
measured hit ratio 
varying delays strategy 
measured latency 
varying delays various datasets 
measured quality 
varying number hot regions 
measured query object hit ratio 
varying keep direction factor 
measured query object hit ratio 
varying keep direction factor various datasets 
measured hit ratio 
vii varying prefetching strategy 
measured object query hit ratio 
varied prefetching strategy 
measured latency 
varied prefetching strategy 
measured latency 
providing hints query optimizer 
varying prefetching strategy 
measured hit ratio 
providing hints query optimizer 
varying data size 
measured latency 
varying dataset 
measured hit ratio 
varying dataset 
measured latency 
viii chapter caching prefetching large scale tion visualization effective tool analysis data 
statistics offers various tools testing model hypotheses finding model parameters task guessing right type model process automated 
domain stock data scientific data distribution sales visualization plays important role analysis 
humans detect patterns trends underlying data just looking aware advance data model ll face 
human perception course greatly influenced way data 
various techniques displaying data proposed years better emphasizes data characteristics versus :10.1.1.34.9201
techniques scale respect size data 
generalization postulates method displays single entity data point invariably results overlapped elements convoluted display suited visualization large datasets 
new approach proposed displaying large datasets 
idea data different levels detail applying aggregation function hierarchical structure results proximity clustering process 
problem cluttering interface level solved displaying limited set aggregates time 
hierarchical summarizations result increasing size data managed order magnitude making management data issue 
storing retrieving data sets efficiently traditionally ignored context visualization applications 
storing data main memory flat files appropriate small moderate sized datasets unacceptable scaling large datasets 
enable scaling visualization applications inte database management systems 
couple decades research area databases greatly contribute increasing performance data intensive application exploratory visualization 
coupling database visualization tool performed blindly 
techniques main memory processing typically efficient im plemented directly database environment 
trivial known example sort ing 
internal sorting strategies differ significantly external sorting ones 
example recursive processing involved navigating hierarchies main memory longer appropriate storing hierar disk 
propose technique called minmax trees purpose 
minmax labels hierarchies transformed recursive processing set fast range queries 
general questions answered doing visualization database integration 
effectively translate visual ex operations zooming brushing database understandable lan guage sql 
second store manage results database requests main memory subsequent memory access operations effi cient possible 
gives solutions questions 
approach approach reducing system latency line computation time push expensive computation line possible 
visual tools require data address space access 
simple main memory system data resides entirely main memory fig 

visualization tool issues request system entire computation performed demand line 
computation results set objects passed back front 
data moved main memory persistent storage additional processes fig 

requests need passed database translated format supported query processor 
request processed database line 
second result set needs loaded main memory sent graphical interface display 
demand computation data loading intensive longer cheap 
goal minimizing system latency achieved optimizing phases 
approach making step efficient move part line compu tation pre processing phase 
case front operations reducible particular class recursive unions joins divisions operate hierarchies 
adequate pre computation organizing hierarchical structure called minmax tree recursive processing operations class re duced range queries 
extensions method non tree dynamic architecture main memory implementation 
architecture database implementation 
additional computation steps intensive 
hierarchies designed chapter 
compared alternate approaches sim ilar problems literature hierarchy labeling method shown superior terms efficiency functionality 
previous proposed methods support dynamic arbitrary hierarchies able efficiently scale large datasets 
second step efficient employ main memory strategy support incremental loading data main memory 
show incremental loading efficient set operations needs support chapter 
reduce response time system designed speculative non pure prefetcher brings data memory system idle 
prefetcher property navigation systems queries remains local set currently selected objects small number choices objects selected 
property provides implicit hints system 
additional hints provided specific data user navigation preferences 
contributions main contribution consists developing suite techniques applied interactive visualization tools order suitable exploring large datasets 
designed implemented encoding technique efficiently supports fast retrieval data navigating line 
designed high level cache policy reduced latency system incrementally loading data memory buffer 
system idle prefetcher bring cache data 
purpose technique combined low granularity data object level semantic description content buffer 
performed experiments assess efficiency approach 
tested encoding technique stand method performed scaled 
second tested integrated system various input different settings 
system scale support millions datapoints typically dimensions 
confirmed important role precomputation applications showed benefit prefetching overcome significantly cache 
thesis organization chapter presents related research visualization database focusing main aspects hierarchical database processing main memory processing 
chapter introduces basic concepts visualization de solution achieve scalability front perspective 
formalizes model proposed approach works 
hierarchy encoding processing resulted minmax queries chapter 
chapter introduces memory management specifically caching prefetching strategies 
implementation system discussed chapter 
experimental results reported chapter 
directions research chapter 
chapter related visual hierarchy exploration considerable research efforts visualization area finding effective methods display explore hierarchical information tree maps cone trees reconfigurable disc trees :10.1.1.29.1549
methods provide modest modes interactions navigating hierarchy 
navigation plays important role aiding users find way complex structure see information available identify information interest 
hand techniques visual exploration hierarchies indepen dently proposed :10.1.1.11.9765
hierarchy visualizations evident instance cial applications microsoft windows explorer norton commander 
major disadvantage interfaces limited display space hierarchy 
suitable displaying large data 
visualization technique capability interactively navigating hierarchical structures capability displaying large datasets 
visualization database integrated systems integrated visualization database systems tioga idea devise represent closest related terms problem area 
approaches different 
tioga implements multiple browser architecture call recipe visual query 
system able buffer computed data problem translating front operations database queries database queries directly explicitly specified graphical interface 
idea integrated set tools support interactive data analysis exploration 
constraints data model imposed application domain line query translation memory management addressed 
devise set query visualization primitives support data analysis provided 
relationship primitives complex number primitives supported relatively large 
caching data done database level default mechanisms special memory management techniques considered 
area includes dynamic query interfaces dynamic query histograms direct manipulation query interfaces :10.1.1.52.2236
visual interface database back 
operations translate differently dynamic range queries temporal queries spatial queries 
works deal hierarchy exploration support 
relational processing hierarchies join processing relational systems hierarchies composite objects broken multiple fragments stored tuples separate relations 
traversing hierarchical structure order gather fragments query specific prop erties requires large number joins 
relational joins expensive operations immediate improvement handling hierarchical structures achieved improving join efficiency 
valduriez introduce new access path processing joins called join index 
join index simply binary relation contains pairs surrogates unique system identifiers tuples joined 
algorithm uses join indices 
join index efficiently supports computation joins particularly join composition complex objects case decomposed storage representation 
method speeds join processing uses hidden pointer fields link tuples joined 
hidden pointers special attributes contain record identi 
pointer join algorithms simple variants nested loops sort merge hybrid hash join analyzed 
hash method large main memory systems described 
author concentrates improvement joins traditional strategy sort merge 
algorithms evaluated simple hash grace hash th generation systems hybrid 
available main memory exceeds square root size relation hash algorithms successfully applied computing joins 
gain especially significant large relations involved 
techniques join processing efficient don limit way recursive processing typically involved traversing hierarchies 
number system calls high intermediate tuples unnecessarily retrieved 
hierarchy encoding way handle hierarchies emerged development object relational systems 
object extensions composite object represented nested non st nf relations 
recursive relations pre defined depth represented nesting 
novel idea hierarchical processing introduced ciaccia 
en code tree hierarchies mathematical properties simple continued fractions 
basically node tree unique label encodes ancestor path node root 
trees assumed ordered children order numbers ancestor path simply corresponds sequence integers 
sequence gives code ancestors node physical access data 
information sufficient performing operations getting common ancestor nodes testing node ancestor recursive retrieval data 
node method example efficiently provide list descendants limitation reduces number operations supported updates difficult handle 
important limitation method applied tree hierarchies arbitrary hierarchies 
similar idea introduced 
called signature encoding ancestor path 
important difference signature method previous approach code unique 
node code obtained applying hash function concatenating resulting value code parent 
non unique code quantity data retrieved larger needed 
code obtained concatenation ancestor codes exceed available precision deep trees 
fragmentation initial tree consequently additional joins need performed 
main memory processing high level caching high level caching systems objects individually identified set objects identified query generated called semantic caching predicate caching 
memory management similar semantic caching 
buffer content specified set queries 
due specific requirements case efficiency purposes applied concepts semantic caching quite different enabling data handled smaller granularity object level 
area object level caching database applications addressed example 
object caching studied context web applications 
prefetching interactive database applications sufficient time user re quests amount data prefetched limited cache size 
situation refered pure prefetching constitutes important theoretical model analyzing benefit prefetching 
practice prefetch requests interrupted user requests resulting data prefetched time 
cases called non pure prefetching issues cache replacement need considered 
pure prefetchers converted practical non pure ones com cache replacement strategy 
instance pure prefetcher lru cache replacement strategy significant re duction page fault rate shown 
multi threaded implementation non pure prefetcher reported 
latency disk operations improved threads 
estimation strategy called predictor usually proba model recorded statistics 
widely predictor systems similar markov chain theory 
main idea string letters alphabet compute probability letter position patterns existing markov predic tors prefetching context paged virtual memory systems name correlation prefetching 
uses markov predictors prefetching reports results 
chapter multivariate data visualization triggered goal adding database support xmdvtool 
xmdvtool software package designed exploration mul data 
tool provides distinct visualization techniques scatterplot ma parallel coordinates glyphs dimensional stacking interactive selections linked views 
efforts produced hierarchical parallel coordinates allows multi resolution data presentation 
main idea cluster datapoints distance metric apply aggregation function datapoints cluster aggregate values displayed datapoints 
model conceptualized hierarchy provides capability visualizing data various levels abstraction 
hierarchical structure explored interactively selecting displaying points different levels detail 
term exploration pro cess navigation 
follows describe visual exploration operations detail provide environment abstraction formal model summarizes semantics operations 
brush basics selection process subset entities display isolated manipulation highlighting deleting analysis 
wills defined taxonomy selection operations classifying techniques memory previous selections maintained selection controlled underlying data specific interactive tool brushing differentiate area display 
created selection calculus enumerates possible combinations actions previous selection new selection replace add subtract intersect toggle attempted identify configurations actions useful 
brushing process interactively painting subregion data display mouse stylus input device enables specification location attributes 
principles brushing explored becker cleveland applied high dimensional scatterplots 
ward martin extended brushing permit brushes dimensionality data 
explored concepts multiple brushes composite brushes formed logical combinations brushes fuzzy brushes allow points partially contained brush 
introduced ability show average value points currently selected brush 
common method classifying brushing techniques identify space selection performed screen data space 
specify containment criterion particular point inside outside brush 
screen space techniques brush completely specified contiguous subspace screen 
data space techniques complete specification consists enumeration data elements contained brush boundaries hyper box encapsulates selection 
third category structure space techniques allows selection structural relationships data points introduced 
structure data set specifies relationships data points 
structure may explicit categorical groupings time orderings implicit resulting analytic clustering partitioning algorithms 
examples structures include linear orderings tree hierarchies directed acyclic graphs arbitrary hierarchies 
focus tree hierarchies 
tree convenient mechanism organizing large data sets 
recursively clustering partitioning data related groups identifying suitable summarizations cluster examine data set methodically different levels abstraction moving hierarchy drill interesting features appear summarizations hierarchy roll sufficient information gleaned particular subtree 
described earlier brushing requires containment criteria 
con criterion augment node hierarchy cluster monotonic value relative parent 
value example level number cluster size population volume cluster defined minimum maximum values nodes cluster 
assigned value determines control level detail 
second containment criterion structure brushing fact node tree extents denoted left right leaf nodes originating node 
particular possible draw tree way children horizontally ordered 
extents ensure selected subspace contiguous structure space 
structure brush defined subrange structure extents level detail values 
intuitively looking tree structure point view root node fig 
extent subrange appears focus region focus point center level detail subrange corresponds sampling rate factor density 
representation tree fig 
subranges correspond horizontal vertical selection respectively 
structure brush combination focus region density factor 
hierarchical clustering structure brush combination horizontal vertical selection 
follows describe clustering process organize data tool 
clustering phase generates hierarchical tree exploration pre requisite technique 
method generates similar data structure may 
data set composed data points 
elements called base data points 
hierarchical clustering obtained recursively aggregating elements intermediate groups clusters 
conceptually hierarchical clustering thought iterative process successive cluster aggregations starts elements clusters element ends large cluster incorporates elements state transitory process defined partition elements state partition obtained grouping sub sets previous partition 
successive partitions called nested 
consequently define hierarchical clustering sequence nested partitions trivial partition set 
formal definition hierarchical clustering appendix graphical representation example hierarchical clustering fig 
set elements call representation partition map 
partition map tree hierarchy 
hierarchical tree obtained clustering 
hierarchical clustering may organized tree structure root leaves base data points 
node corresponds gation child 
graphical representation cluster tree obtained hierarchical clustering set elements fig 

data hierarchically structured explicitly explicit partitions example category driven partitioning implicitly intrinsic values data points 
case clustering algorithm needs form hierarchy 
tried clustering algorithms system suitable 
specifically birch simple 
structure brushes creation manipulation shows structure brushing interface implemented xmdvtool 
triangular frame depicts hierarchical tree 
contour near bottom frame delineates approximate shape formed chaining leaf nodes 
colored bold contour tree delineates tree cut represents cluster partition corresponding specified level detail 
xmdvtool uses proximity coloring scheme assigning colors partition nodes 
scheme linear order imposed data clusters gathered display level detail 
linear order directly derived order tree traversed gathering relevant nodes level detail 
colors assigned cluster looking linear colormap table 
colors display nodes corresponding data display 
movable handles base triangle apex triangle form wedge hierarchical space 
shown structure brush defined intersection independent selections necessarily follows setting brush requires com putational phases 
horizontal selection accomplished steps 
step set leaf nodes initially selected order property handles indicates fig 

basically step corresponds select leaves extreme values 
examples initial selections cor responding operators depicted fig 
fig 
respectively 
brush values examples nodes 
selected nodes highlighted shaded region 
second phase initial selection propagated structure brushing interface xmdvtool 
hierarchical tree frame contour corresponding current level detail leaf contour approximates shape hierarchical tree structure brush interactive brush handles color map legend level detail contour 
root termed semantic select nodes children selected semantics possible 
second computation phase vertical selection consists refining set nodes generated phase 
basically nodes desired level detail retrieved phase selection 
formal definition structure brushes appendix initial selection brush values 
initial selection brush values 
brush operations described inherently recursive 
recursive process ing relational database systems extremely time consuming unsuitable interactive applications 
chapter develop equivalent non recursive compu tation methods setting structure brushes assigning pre computed values nodes recast retrievals range queries 
geometric representation structure brush definition extend partition maps incorporate information level value 
objects get spatial representation 
example level hierarchy fig 

called type represen tation hierarchy map 
hierarchy maps especially useful generalize concept level detail extend type monotonic function 
example fig 

case level values initial final need stored object 
semantics structure brushes changes hierarchy maps 
see chapter reduces containment test dimensions 
typical example select points touch level detail brush interval 
multidimensional extension structure brushes just introduced implied natural order base data points leaf nodes existed 
case 
fact space initial selection performed dimensional 
principally initial se lection performed arbitrary dimensional space preferable user 
particularly anticipate dimensional selection useful 
hierarchy maps naturally generalize hierarchy maps 
extension hierarchy map 
uniform levels detail 
hierarchy map 
arbitrary level detail function 
implemented current version xmdvtool 
mentioned completeness 
model abstraction introduce formal model characterizing salient features application domain proposed techniques establishing applicability scope solution 
input space composed entries extent dimension level dimension 
dimensions independent space cartesian product entries 
envision space overlapping grid tree hierarchy fig 

representation selection sequence consecutive regions level value fig 

data points spatial objects distribution may unknown retrieved called query mechanism 
containment criterion specifies object included current selection window 
order able implement structure brush previously specified order enforced set leaf nodes general nodes level detail value 
selection space abstraction 
active window selection space 
example transforming tree structure navigation space set spatial objects 
tree fig 
represented hierarchy map overlapped grid integers 
tree example 
navigation tree support set 
set characteristics identifies requirements system needs order approach apply providing naming conventions 
navigation consists continuously changing selection window called active window defined grid integers called navigation grid 

axes navigation grid intervals indexed points 
axis called extent axis intervals denoted ei axis called level axis intervals denoted lk 
grid set rectangle regions form ei lk fig 

navigation grid 
active window 
active window compact selection points ei lk ei lk lk level fig 

active set specified triplet form ei lk 
active window uniquely identifies set spatial objects called active set selected objects set called base set fig 

base set 
properties base set assumed objects level totally ordered 
partial order relationship defined objects base set 
total order relationship objects level fig 

active set contain multiple objects 
number known advance change time 
object spread multiple regions level belong multiple levels 
active windows additive union active sets corresponding windows necessarily included active set corresponding 
active sets disjoint active windows necessarily disjoint 

active window may change incrementally pa rameters change time single unit 
essential property exploited memory management strategy shown section 
chapter query specification question addressed section translate visualization operations database operations 
purpose developed technique called minmax tree 
method places recursive processing precomputation stage labels assigned nodes 
labels provide containment criterion 
simply looking parameters active window node label able determine node belongs active selection 
minmax hierarchy encoding minmax tree ary tree nodes corresponds open intervals defined totally ordered set called initial set 
leaf nodes tree form sequence non overlapping intervals 
interior nodes unions intervals corresponding children 
initial set continuous interval real numbers discrete sequence integers 
case nodes labeled pairs values extents interval 
intervals unions child intervals follows node labeled minimum extent interval maximum extent interval node having example children labeled appendix 
trees called minmax 
examples minmax trees depicted continuous initial set fig 
discrete initial set fig 

continuous minmax tree 
discrete minmax tree 
essentially process labeling nodes recursive 
intervals computed assigned line time hierarchy created value distribution tree structure depend clustering method 
specif ically interval size distribution influenced hierarchy created bottom top 
bottom case leaf intervals size top case node intervals level size 
fig 
fig 
example top tree example bottom tree respectively 
important property minmax tree captured theorem exploited implementing navigation operations 
theorem minmax tree nodes extent values respectively node ancestor node 
theorem intuition node tree included parent interval constructed 
proof theorem appendix query processing minmax data represented relational table hier 
previous section hier incorporates node level minimum extent maximum extent aggregate values static tree hierarchies hier section give implementation navigation operations case static tree hierarchy updates navigation 
notice tree labeled minmax tree example start arbitrary continuous initial interval root recursively divide equal sub intervals sub interval assigned child see example binary tree fig 

structure brushes having hierarchy labeled minmax tree implement structure brush introduced section non recursive operation fol lowing property 
theorem brush values vmin vmax structure brush gener ates union nodes interval vmin vmax vmin extents fully contained brush vmax selection defined structure brush example fig 
brush values visually depicted fig 

selected nodes underlined 
proof theorem appendix structure brush 
structure brush hierarchy labeled minmax tree simple range query expressed sql structure brushes select hier min max level structure brush defined section implemented non recursive operation 
non recursive computation method theorem 
theorem brush values vmin vmax structure brush gener ates nodes intersection brush interval vmin vmax empty vmin vmax 
property states nodes touch brush interval selected 
shown fig 
intuitively true underlined nodes touched shaded brush area part structure brush example section 
proof theorem appendix structure brush 
non recursive query structure brush defined minmax tree form select hier max min level clearly technique powerful tree structure remains unchanged exploration 
practice nodes need added removed dy 
subsection addresses case dynamic hierarchy 
dynamic tree hierarchies dynamic hierarchy tree graph structure changes exploration 
type updates consider section adding new nodes leaves deleting existing nodes 
node deleted inner node interpret mean sub tree rooted node removed 
deleting nodes sub trees minmax tree require special computation rearranging trees re labeling nodes order preserve properties minmax trees 
deleting subtree rooted node example similar setting structure brush brush values delete hier min max inserting new node degree parent node changes siblings descendents need update intervals 
say node interval splits 
order increase efficiency process step method 
delay interval splitting inserting gaps tree nodes section 
second re label affected nodes splitting fast non recursive method section 
de compacting tree consider case node children 
method far divides interval sub intervals 
fourth node inserted split 
divided say intervals fourth node added problem splitting delayed 
idea chose allocation management suggested 
label minmax tree ary tree say allocate positions node 
new node inserted node positions allocated just doubles interval expands positions fig 

amortized analysis allocation strategy proven optimal maximum number elements stored unknown estimated 
re labeling nodes node splits re labeling process takes place 
extents nodes sub tree rooted recomputed 
sub tree selected allocation strategy 
values 
selected tuples affine transformation utilized update extent values arbitrary hierarchies update hier set min min max max min max arbitrary hierarchy node parent non tree acyclic di graph fig 

example application arbitrary hierarchies cad cam part hierarchies 
applications structure brushes interesting semantic 
set basic components leaf nodes structure brush defines set super components manufactured parts structure brush gives super components need part extension method designed handle arbitrary hierarchies 
arbitrary hierarchy interval assigned node 
example discrete bottom labeling tree fig 
intervals assigned node shown fig 

case handled inserting copies node hier table 
copy assigned interval labeled second copy arbitrary hierarchy 
bottom labeling arbitrary hierarchy 
assigned second interval labeled 
important notice number additional tuples inserted hier table depends ordering nodes 
example nodes change position node labeled duplicate copies need inserted 
address problem organize hierarchy nodes order decrease number stored tuples 
copy node exists hierarchy non recursive implementation queries structure brushes change 
nodes may occur multiple times table having different interval values possibly inside possibly outside brush interval brush select nodes intervals outside brush interval select distinct hier level select hier max min structure brush query changes handle duplicates select distinct hier max min level non recursive new queries significantly expensive designed tree hierarchies 
duplicate copies queries designed tree hierarchies preferred 
chapter memory management caching question addressed section organize data memory arrives database 
memory organization critical interactive applications influences performance subsequent operations 
request new objects issued front difference new active set set objects just selected current content buffer computed fast 
need able know moment data resides memory fully traversing buffer 
significant difference buffer management buffer large store objects active set 
refer cases database intensive dbi database semi intensive 
primarily concern case active set objects occupy space available propose technique handle dbi case 
space available memory system idle load additional data slow memory disk 
data full partially needed gets replaced time spent bringing buffer gain system latency 
purpose designed implemented speculative adaptive non pure strategy prefetching 
prefetcher speculative doesn explicit information operations try guess 
adaptive refers ability change prefetching strategy dynamically information available system 
case shown chapter fully implement adaptability part 
strategy proposed show strategies perform better information available 
prefetcher non pure implement non penalty policy user actions preempt prefetching decisions 
semantic caching semantic caching high level type cache queries cached pages tuples 
characteristic objects placed buffer referenced ids accessed front 
words front doesn ask object id id passes query back objects characteristics brush available 
object attributes extents uniquely identify entry classical lookup cache key possible testing object buffer 
set queries content associated buffer similar semantic caching 
query compared content determine objects content objects retrieved 
difference results fact new queries loaded objects 
problem determine corresponds queries usually known query folding 
shown problem reducible query containment problem 
query containment undecidable general case decidable case conjunctive queries 
show chapter queries case range queries conjunctive 
special attention paid semantic cache environment allow cates buffer 
qi content query stored buffer forced disjunct 
means new query modify semantic existing qi content queries refer common objects 
show partition objects level value 
partitioning task testing containment reduce checking extent values 
order object additions subtractions efficient store objects buffer ordered extent value 
order ensured query mechanism added new processing step 
case request objects queries defined section retrieved order adding ordered clause minmax derived sql queries 
sql clause require extra processing time store objects database ordered extent values left example 
require minimal extra processing store objects unordered index built 
problem cache strategies need solve cache replacement policy determine objects removed cache room new objects 
step implementing replacement policy provide estimation strategy able measure object needed near 
estimation strategy called predictor usually heuristics tic models recorded statistics 
case probability function 
probability function defines partition set objects 
objects memory partitioned level proba bility value 
efficient way implement hash bucket tables hash distribute objects appropriate buckets 
objects bucket connected double linked list 
explain functionality tion section 
probabilistic model consider navigation grid introduced section 
point support set region ei lk navigation grid associated probability measures point belong active set user operations 
probability measure point belong active set time operations 
obviously probability sum principle inclusion exclusion 
lookahead parameter la number operations considered advance computing probabilities parameter definitions 
say monotonicity property mp holds level function distri bution exists extent value monotonically values monotonically decreasing values greater la parameter dictates operations predictor needs predict 
general bigger la speculative system errors involved 
implementation la equal 
predic tion model accurate generates high confident predictions la equal may eventually 
don anticipate value greater 
say probabilities assigned objects operation driven probabilities predictor assign possible operations 
case possible operations restricting enlarging active window parameters 
assume example active window configuration going left probable going probable 
objects probability objects probability objects probability 
theorem navigation grid 
operation driven prob ability model lookahead la mp holds level proof consider 
operations numbered numbers order 
la 
selection regions equal probability fig 

mp holds trivially case 
region unselected points region selected points la 
operations possibly change selection define regions equal probability fig 
probabilities associated operations 
computed region 
region la regions equal probability 
region region region region la regions equal probability 
levels possible types configurations distributions mp holds 
level level level la 
probabilities associated user operation probabilities associated second 
similarly regions equal probability fig 

regions computed 
easy see mp holds case 
region region region region region region region region region region la regions equal probability 
consider 
selection exists extent value median extent active set doesn depend level lookahead value mp hold levels 
monotonic lookahead value 
probability sum monotonically increasing functions decreasing functions necessarily max monotonicity property mp holds level monotonically follows probabilistic model lookahead value assumed mp holds levels 
cache replacement shown section buffer organized bucket table probability values 
objects buffer hashed rounding fixed number values precision 
buckets values ranging uniformly open entry object currently active set 
objects bucket linked double linked list 
independently buffer hashed level value 
bucket table buckets level values 
objects bucket linked double linked list 
addition header keeps pointer element list 
invariant model level objects ordered linked linked list extent values 
assumed possible discussed chapter 
follows focus operations structure needs support 
main task cache replacement policy find buffer entries lowest probability remove room needed 
operation needs efficient occurs frequently 
new objects brought comply internal organization 
updating hash tables required 
request issued front containment test performed 
system check requested data entire reside memory 
case doesn compensation query send loader agent fetches data persistent storage 
front may sent refresh queries objects current selection needed 
important requirement system comes interactive nature user needs able preempt agents actions 
active window changes loading process interrupted restart recomputing new probability values objects 
buffer access operations summarize remove old objects 
get objects lowest probability reside buffer remove time room buffer needed 
bring new objects 
place object cursor buffer memory buffer rehash buffer entry 
display active set 
get objects buffer form active set send graphical interface displayed 
recompute probabilities 
recompute probabilities objects buffer active window gets changed ensure accurate predictions 
test containment 
test new active set fully resides buffer get missing objects support set new request issued 
remaining section show operations implemented buffer strategy 
speed buffer processing achieved simplified version probability bucket table 
storing object proba bility bucket store ones extreme elements level lists 
better understanding problem describe cases 
example consider navigation grid displayed fig 

twelve regions equal probability active windows selecting middle ones 
simplicity consider object resides region 
number objects 
picture presents levels 
probabilities assigned region implicitly object operation driven probability model 
objects probability chance window expands left 
example probability precision assumed consequently probability buckets 
probability table reduced see instance hashed entire level 
important assumption point query mechanism able provide objects active set increasing decreasing order buffer content level twelve object example case reduced probability table 
extent value 
sorting stage follow calls query mechanism 
main idea buffer access strategy keep sets objects level convex buffer respect relation total order defined objects level 
possible due fact probability objects need replaced removed level list extreme list 
follows implementation buffer access operations described 
better understanding full version probability table assumed 
com plexity operations appendix operation remove old objects equivalent retrieving elements empty probability buckets increasing order bucket value 
operation requires scan probability table interleaved traversals bucket lists 
operation bring new objects equivalent hashing entry respect level probability value 
hashing entry respect level value done exactly operations 
set entries level convex contains higher probability objects level new coming object highest probabilities objects buffer necessarily extreme 
entries level ordered extent value new object new element level list previous object new element necessarily greater previous element 
hashing respect probability takes unfortunately operations average case length current probability list 
need sure object correctly inserted respect extent value sequence elements having level probability bucket removing elements probability list leaves affected level lists convex 
efficiency improved reduced probability list 
operation display active set simply read entries probability bucket bucket 
number buffer accesses number elements bucket 
operation recompute probabilities requires complete scan data 
objects preserve level value change level lists needed 
probability table needs rebuilt 
takes operations 
deleting lists done probability recomputation step creating new ones basically list insertion object 
operation test containment composed steps 
inclusion test ensured convexity property 
active set corresponding active window included buffer list corresponding level lk ok left extent geometrical extremity ok le ft ok equal right extent right greater equal 
included difference intervals le ft ok right gives request addressed query mechanism 
consider case reduced simplified probability table 
complexity operations appendix operation revisited 
scan case full probability table needed retrieving empty bucket 
getting element probability list level list followed time long entries probabilities equal current bucket probability 
element probability greater inserted probability list remain extreme element process continues element probability list 
operation revisited 
rehashing level value takes number operations case reduced probability table 
rehashing respect probability takes exactly operations case 
new object inserted element probability list corresponding probability value second element second level list previous extreme removed probability list 
operation revisited 
operation change 
operation revisited 
clearly complete scan necessary recomputing probabilities scan deleting probability lists 
probability lists contain element level lists rebuilding probability table takes operations length level bucket table operation revisited 
operation change 
dbi case case level time 
level table circular list probability table entries probability 
problem needs addressed context synchronization producer process loader fetches data consumer process front displays data 
synchronization essential case tasks completely serialized 
dbi case number objects active set time may greater number entries available buffer 
producer process advances circular list may attempt overwrite old objects fig 

acceptable objects overwritten read front 
assure functionality model change dbi assumption 
intuitively instance data buffer needs read second time case refresh process consumer changes traversal direction 
producer positioned non overwritten entry changes traversal direction fig 

way traversal procedure keep pointers positioned element respectively current active set elements exist buffer 
pointers take part synchronization process 
synchronization simply requires consumer producer cross 
traversal direction irrelevant implement requirement allowing pointers take value matter follows 
finishing reading 
current objects painted solid overwritten objects stripped 
dash lines undefined pointers 
starting re reading 
traversal direction changes consumer producer 
buffer inconsistent state 
consistent state buffer contains sequence objects starts element active set refered state ends refered state undefined null time 
state usually occurs backward traversal state occurs forward traversal 
types access operations dbi case 
show operations leave buffer consistent state 
refreshing re reading buffer 
forward traversal starts 
ic set ip sequence step 
undefined set null 
loading process continues producer consumer active set reached termination character placed 
redefined 
process ends reader reaches termination character 
buffer left state 
backward traversal symmetric begins 
changing level 
changing level flush current buffer matter state load new active set forward direction 
state reached 
expanding brush left 
process corresponds continuation loading process temporary interrupted 
termination character removed producer continues place objects buffer 
reader starts reading elements previous position 
process ends state 
re read operation type usually follows 

expanding brush right 

similar symmetric 
restricting brush left 
elements longer belong active set removed buffer starting 
element new active set reached re read process begins 

restricting brush right 

similar symmetric 
cases re read usually needed sequence writings reading writing time typically overlap operations completely parallelized 
prefetching general characteristics computer memories usually organized hierarchically 
level memory consists relatively small fast cache internal memory relatively large slow memory disk storage 
data requested application cache computation proceed 
requested data cache application wait data fetched slow memory cache 
method fetching data cache specific request occured refered demand fetching 
applications users spend significant time interpreting data processor system typically idle period 
computer predict data user request start fetching data cache user asks 
user requests data available cache user perceives faster response time 
interactive database applications sufficient time user requests amount data prefetched limited cache size 
situation refered pure prefetching constitutes important theoretical model analyzing benefit prefetching 
practice prefetch requests interrupted user requests resulting data prefetched time 
cases called non pure prefetching issues cache replacement need considered 
basically pure prefetchers converted practical non pure ones combining cache replacement strategies 
informed line algorithm knowledge activity 
pro gram generating requests known priori prefetching decisions line done compiler directed prefetching instance 
algorithm speculative online decisions past history 
priori knowl edge statistics user request patterns case interactive hypertext applications prefetching speculative online 
important requirement speculative prefetching time spent making prefetch decisions minimal 
algorithm adaptive ability change prefetching policy due run time variations 
access behaviour program may vary execution changing issue prefetching requests amount data prefetched may influence performance prefetching 
designed implemented speculative adaptive non pure strategy prefetch ing 
describe approach remaining part chapter 
strategies approach generate various classes prefetching strategies different prefetching hints 
assumption predictor discover hints gradually 
approach implies behaviour information available predictor number prefetching hints discover reasonable confidence low 
time information statistics available patterns implicitly hints discovered 
cases prefetcher base strategy maximum amount information available 
case assume predictor discover navigation patterns 
specif ically assume predictor detect user tends frequently current navigation direction changing detect data analyzed regions interest called hot regions user go sooner 
assumptions designed prefetch strategies random direction focus 
experiments consid ered case prefetching case refered 
strategy random randomly choosing direction prefetch 
strategy appropriate predictor extract prefetching hints provide hints low confidence measure 
strategy direction implies direction operation deter mined 
patterns extracted user past explorations parameters current navigation predictor assign higher probability particular direction versus 
direction prefetching strategy says prefetch data direction 
presumption direction determined arbitrary 
intuitive instance user continue manipulation tool changing 
strategy focus uses information probable direction hints regions high interest data space 
strategy continue prefetch data direction 
hot region encountered prefetcher stops prefetching direction 
reason user spend time region 
chapter compare strategies 
results confirm general assertion information available efficient prefetching conclude changing prefetching strategy soon patterns dis covered improve performance 
chapter implementation system architecture described far implemented extension xmdvtool 
high level diagram modules added relationship modules original system 
xmdvtool coded tcl tk opengl primitives 
new added modules written proc embedded sql primitives 
interaction original system 
interaction original system shown gui reduce minimum 
implemented called prepare get paradigm 
user issues new request front inform back request calling prepare retrieve desired objects time repeatedly calling get 
query rewriter 
user request arrives rewriter 
module con sults information buffer decides weather request immediately served needs information database 
rewrites original query set loading requests 
query translator 
translator takes loading request input schema current table translates sql 
translated queries passed loader module service 
loader 
loader module interacts line database 
duties allocate deallocate oracle descriptors copy format data oracle structures application buffer 
determine elements needs removed cache room new entries loader cooperates estimator 
estimator 
estimator module predicts user actions assign probabilities buffer entries actions 
prefetcher 
running separate process prefetcher module generates line loading requests called prefetching requests 
prefetcher started stopped time new request arrives gui level 
synchronization parent process described section 
prefetcher cooperates estimator provides hints rewriter process prefetching requests 
threads synchronization main threads system 
addition tk comes complicated system priority queues ensure fairness optimization system 
precisely tk idle job queues keep track processes need performed system idle 
refreshing widgets process instance 
queues introduce hierarchy priorities ensure example user immediate requests preempt processes idle jobs interruptible 
tk able cancel requests queues determine system architecture 
oval depicts initial data 
dash lines rectangles represent threads processes 
solid line rectangles agents 
squares represent metaknowledge 
solid arrows show control flow 
dash arrows show creation child threads 
request needed 
said prefetcher thread created back system idle gets cancelled soon explicit request received 
synchronization diagram 
synchronization implemented pthread library 
interacting database order load data database dynamic sql statements specifically dynamic sql type 
types oracle provides type build dynamic sql statements contain unknown number select list items place holders bind variables take explicit control data type conversion oracle types 
process kind dynamic sql statements program explicitly declare select bind descriptors 
select descriptor holds de select list items addresses output buffers names system architecture 
oval depicts initial data 
dash lines rectangles represent threads processes 
solid line rectangles agents 
squares represent metaknowledge 
solid arrows show control flow 
dash arrows show creation child threads 
values select list items stored 
bind descriptor holds descriptions bind vari ables indicator variables addresses input buffers names values bind variables indicator variables stored 
solution required system due fact dataset explored schema table queried changes dynamically table name number attributes name attributes change exploration 
chapter experimental results user input performance measurements systems human interaction needed require way simulating users perform sequence operations multiple times 
case simulation influences behaviour system performance point view patterns navigation provide prefetcher arbitrary 
user input refered user script input script sequences user operations parameters operations time specification opera tions occur 
best thought sequence navigation primitives delays 
example input string column time specification second type operation third parameters operation requires 
main idea approach provide data specificity user specificity user input scripts generate 
words scripts need show particularities data may affect navigation particularities user preferences may influence 
particularities data user behaviour provide hints exploit prefetching 
simulate specificity data hot regions fig 

hot regions places navigation space properties data visible user consequently 
assumption sooner user reach hot regions ans moving slightly probable 
size number hot regions probability factors vary shown section 
hot regions selections navigation space provides useful insight data 
simulate specificity user 
probability factor gives user keeps moving direction 
pretty natural navigation environment user tool change tool 
second identified various classes delays may occur 
differentiate short delays mark transitions consecutive events moving manipulation tool way moderate delays instance user changes manipulation tool large delays user analyzes data 
probability value delay values varied shown section 
factors just described user moves pseudo randomly possible actions probable choosing ac tions performed 
input scripts affect system performance 
experiment ran multiple scripts generated parameters 
results obtained average multiple runs 
approach generate user input possible 
obviously feel method generates scripts close real ones research needed validate assumption 
case user input essential technique 
essential course predictor module shown chapter provides probability measure operations 
stage assumes predictor 
point approach applied 
settings ran set experiments measure performance system standard commercial technology oracle 
experiments conducted alpha dec station running oracle 
having concurrent clients tests 
host language embedded sql statements accessing data database 
various phases testing various datasets real synthetic consistent results 
experiments synthetic data 
choice avoid problems induced non homogeneous structures interpreting result performance depends degree shape tree distribution nodes clustering tree 
complete trees constant fan 
eleven datasets iris benchmark datapoints dimensions objects maximum number points displayed time 
datasets named respectively objects maximum number displayed objects respectively 
varied user input number focus regions delay factor keep direction factor system parameters prefetching strategy hints query optimizer size data 
experiments navigation scripts containing user operations 
values measured experiments quality query hit ratio objects hit ratio latency 
quality number objects displayed navigation session 
explained chapter display requests tk queued served system idle 
display requests refers widget older cancelled 
behaviour may result loosing information display requests annoying user 
consider number objects displayed measure visual quality 
hit ratio number hits total number items queries objects totally requested back 
latency total time expressed seconds user wait requests served line loading time 
experiments experiment minmax vs recursive 
measured system performance implementing structure brushes minmax tree technique recursive technique 
sql support recursive views recursive tech nique additional attribute mark selected tuples recursion steps 
cases created simple indexes join attributes compound indexes ex tent level attributes 
maintaining indexes issue trees static experiments 
result experiment figures 
expected minmax method substantially faster recursive cases 
results show clearly application minmax technique sys tem visual exploration large datasets practically feasible accomplishing ultimate goal 
minmax vs recursive 
structure brushes dataset 
minmax vs recursive 
structure brushes dataset 
experiment varying brush parameters 
experiments ana behaviour system size brushes changes 
specifically vary level value extent values size dataset 
experiments compound index hint oracle optimizer keep impact oracle caching small 
brushes implemented range queries expect response time vary linearly respect parameters 
experiment varying level value 
experiment extent values constant level value varies unit increments 
complete binary tree number points doubles level expected response time similar behaviour method linear size input 
see fig 
linear behaviour observed large levels small ones constant 
minmax vs recursive 
structure brushes dataset 
varying level value 
functions compared logarithmic scale 
experiment varying extent values 
experiment level value constant leaf level smallest dataset extent values varies increments captured axis 
behaviour expected linear 
experiment particularly important validates assumption incremental computing brushes needed 
shown fig 
increase response time linear processing time level brush proportionally reduced computing incrementally 
experiment varying size dataset 
experiment new dataset having tuples 
brush settings set values dataset changes tuples varying extent value 
functions compared 
varying dataset size 
levels defined 
tuples 
number nodes doubled shown axis 
see fig 
resulting time constant 
ensures system scale large datasets 
functions labeled defined levels 
experiment varying user input 
experiments analyze behaviour system user input changes 
specifically vary size delays events number hot regions probability parameter determines current direction abandoned 
experiments dataset having total objects objects maximum active set hint oracle optimizer 
results represent measurements direction focus prefetching strategies mini mum buffer size objects case 
experiment varying delays 
experiment vary delay factor 
ba multiply default delays factors 
increasing delays gives prefetcher time 
naturally quality fig 
hit ratio object query level fig 
latency fig 
improve 
compare execution direction prefetcher multiple data sizes 
tendency system performs better varying delays strategy 
measured quality 
varying delays strategy 
measured latency 
varying delays strategy 
measured hit ratio 
varying delays various datasets 
measured quality 
linearly soon exceeds short delay region 
normal short delays prefetching requests get cancelled 
experiment varying hot regions 
experiment vary number hot regions 
explained section largest delays associated changing focus region 
system predicts stage focus region time fetch necessary data increase hit ratio 
expected results show performance decreases fig 
number hot regions increases 
hit ratio measurements latency quality relevant input script changed varying number hot regions 
measured query object hit ratio 
measurement 
varying keep direction factor various datasets 
measured hit ratio 
varying keep direction factor 
measured query object hit ratio 
varying prefetching strategy 
measured object query hit ratio 
experiment varying keep direction parameter 
experiment vary probability maintaining direction current sequence operations 
basically probability factor gives user keep manipulation tool moderate size delay occurs 
factor values increments 
obvious tendency higher factor accurate prediction measured hit ratio fig 
latency quality non relevant due change input scripts 
note system uses prediction time proba bility 
part experiment vary size data direction strategy fig 

tendency 
experiment varying system settings 
experiments analyze typical user input suggested previous set experiments performance influenced various system settings 
user script focus regions delay multiplication factor keep direction factor 
experiments varied prefetching strategy hints query optimizer size dataset 
results obtained average multiple runs typically different input scripts generated parameters 
measurements point graphs result execution operation scripts 
varied prefetching strategy 
measured latency 
varied prefetching strategy 
measured latency 
experiment varying prefetching strategy 
experiment tested prefetcher strategies datasets 
indirect comparison performed previous set experiments 
results confirm typically efficient fig 
unexpected random prefetching performs nearly datasets fig 
rapport input generated parameters 
choose random prefetching default experiments 
providing hints query optimizer 
varying prefetching strategy 
measured hit ratio 
providing hints query optimizer 
varying data size 
measured latency 
experiment varying database cache hints 
experiment evaluate impact database cache policy system performance 
oracle provide support directly control cache try vary degree tuples cached providing optimizer cache hints 
cache hints cache 
cache object persist database buffer possible 
object loaded buffer 
prevents optimizer read object cache object 
results experiments higher degree deviation 
average hit ratio fig latency fig improves 
hand gain prefetching usually 
follows technique clear advantage commercial cache 
varied experiment prefetch strategy fig data size fig experiment varying dataset size 
experiment test scalability method 
purpose datasets prefetch strategies 
buffer size set minimum oracle hints 
see method scales varying dataset 
measured hit ratio 
varying dataset 
measured latency 
better linear similar logarithmic curve 
follows method appropriate exploring large datasets goal thesis 
discussion 
set experiments demonstrated recursive processing queries far expensive applied interactive tools xmdvtool 
minmax encoding problem tractable 
experiments confirmed gain pre computed information support line processing 
second set experiments demonstrated processing time structure brush proportional number objects selected independent brush parameter changed 
time required computing sequence brushes proportional sum objects selections 
experiments fully confirmed approach computing structure brushes incrementally 
third set experiments analyzed user input influences prefetcher accuracy system efficiency 
clear focus navigation time events requests performance increases considerable 
experiments confirmed important role predictor 
fourth set experiments analyzed performance system fixed type user input 
results show prefetching helps 
system performance improves significantly compared case cache policy matter cache database side application side 
shown system scales better linearly respect size data explored 
chapter increasing amount data accumulated nowadays need visually exploring large datasets important 
viable way achieve scalability visualization integrate visualization applications database man agement systems 
integrations raise kind problems 
requires design organization data corresponding query mechanism front operations easily translated efficient database operations 
second memory management strategy employed order reduce head database accesses database transparent users 
presents solution addresses aspects 
approach coupling xmdvtool visualization application interactive exploration mul data oracle database management system 
experiments assessing method showed despite recursive nature operations interface level processing time integrated system proportional number objects active selection 
system scales linearly respect size dataset 
summary main contributions approach minmax method developed order improve suitability relational systems class new applications visualization tools cad cam applications 
method provides important advantages traditional recur sive approaches implementing navigation operations hierarchical struc tures due fast way compute ancestors descendents nodes tree 
implemented minmax technique oracle host language showed minmax queries performed significantly faster equivalent recursive queries 
technique implement query mechanism xmdvtool 
cache strategy employed supports incremental loading data mem ory buffer 
hashing objects buffer level value keeping objects level order query containment test data memory complexity reduce response time system designed speculative non pure prefetcher brings data memory system idle 
order ensure efficiency interruption prefetcher uses cache replacement policy combines low granularity data object level semantic description content buffer 
users synthetically generated system 
navigation patterns simulates data specificity user specificity 
proper indirection input ensures exactly navigation script executed multiple times 
experiments showed proposed memory management strategy significantly decreased latency system 
system scales datasets order records 
directions research include refining current approach making general dropping constrains enforcing 
efficiency system improved developing accurate user model 
complex study need record analyze real input produce classes patterns invariantly occur real navigations 
think model provides fair approximation users purposes 
research needed validate hypothesis 
accurate user model provided design complex predictor model 
confidently know patterns look task extracting exact parameters real navigation script tractable statistical problem 
system functionally extended dropping current con strains example static assumption 
assumption aspects 
consider dynamic change dataset 
common information suffers intensive updates exploration 
second dynamically change tools exploration 
dynamic clustering dynamic computation aggregates possible instance 
appendix navigation operations notation conventions follows denote sequence integers variable takes values denoted variable takes values necessarily denoted hierarchical clustering xm set base data points 
pn defined partition iff pj pj pj pj denote set partition defined support 
partition indicate partition number superscript pi pi pi ni partitions pi pi ni pi pi ni called nested denoted nested iff support support ni ni pi pi hierarchical clustering defined sequence px pk partitions xm structure brushes hierarchical clustering process described appendix results tree struc ture formed pi partitions 
property gives parent cluster cluster pi tree 
follows parent node denoted set nodes zt denote set parents zt structure brush basically set function sbb ni pi sbb 
nk pk nk leaf nodes pk initial selection operator applied 
ni pi pi ni pi propagation operator propagates selection level adjacent level 
notation operator applied times 
structure brush consequently fully defined providing specification operators structure brush structure brushes operator defined xv xv nk operator structure brush defined tall ni ni ni structure brush operator structure brushes identical brushes xv xv propagation operator different ni nk relational semantics structure brushes definitions section section propagation operator corresponds division join respectively 
relation node id id parent considering initial selection defined operator structure brushes structure brushes define relational operations times times appendix minmax hierarchy encoding define anc desc sets ancestors descendents node hierarchy node anc node desc node node initial set am bm labels leaf nodes initial set am bm shown section 
minmax tree labeled tree form min lea desc max lea desc lea lea desc proof theorem ax ax ay ay nodes tree 
notice anc monotonic function 
relation implies anc anc induction get anc anc anc analogously proven desc monotonically desc desc desc implication desc 
desc ay desc desc 
similarly 
true construction proved 
implication desc prove contradiction 
lowest level common ancestor node exists root common ancestor unique nodes level common descendents 
necessarily 
exists child cx cx anc child cy cy anc 
cx cy follows assumption lowest level common ancestors 
construction cx cx cy cy 
cx anc implies cx cx cy anc implies cy cy hypothesis cx cx cy cy contradiction 
proof theorem ax ax node sbb implication sbb structure brush 
sbb ax ax implication sbb 

prove contradiction 
pi sbb xi ni pi xi xi ni pi xi xi nk pk xk aa aa desc xk proof theorem ax ax node sbb implication sbb contradiction 
structure brush 
sbb xk desc xk desc xk xi xk desc aa aa 
aa aa 
implication sbb 
desc 
desc path xk xk xi xk xi sbb 
appendix complexity memory operations easy buffer operations introduced chapter listed remove old objects 
get objects lowest probability reside buffer remove time room buffer needed 
bring new objects 
place object cursor buffer memory buffer rehash buffer entry 
display active set 
get objects buffer form active set send graphical interface displayed 
recompute probabilities 
recompute probabilities objects buffer active window gets changed ensure accurate predictions 
test containment 
test new active set fully resides buffer get missing objects support set new request issued 
full size probability table follows complexity buffer access operations 
function measured number buffer accesses number buffer entries visited 
better understanding full version probability table assumed 
remove old objects complexity log buffer accesses average element single bucket exactly buffer access elements bucket list 
lists usually order follows operation bring new objects probability 
complexity average operation half level re hashing operations average worst distribution probability rehashing 
operation display active set complexity buffer accesses worst case essary ones optimal 
operation recompute probabilities complexity objects preserve level value change level lists needed 
probability table needs rebuilt 
takes operations 
deleting lists done probability recomputation step creating new ones basically list insertion object 
operation test containment complexity testing loading objects requires buffer accesses reduced probability table number buffer accesses operation consider case reduced simplified probability table 
measured number buffer accesses 
shall see complexity operations de creases 
remove old objects complexity 
bring new objects complexity average half buffer accesses rehashing case 
operation display active set complexity 
recompute probabilities complexity buffer accesses 
constant operation test containment complexity 
bibliography andrews 
plots high dimensional data 
biometrics vol 


baer sager 
dynamic improvement locality virtual memory systems 
ieee transactions software engineering june 
becker cleveland 
brushing scatterplots 
technometrics vol 
calvanese giacomo lenzerini 
decidability query containment constraints 
proc seventeenth acm sigact sigmod sigart symp princ database systems seattle washington pages 
acm press 
cao felten karlin li 
study integrated prefetching caching strategies 
technical report tr princeton university computer science department dec 
chekuri rajaraman 
conjunctive query containment revisited 
afrati kolaitis editors database theory icdt th international conference delphi greece volume lecture notes computer science pages 
springer 
ciaccia maio 
method hierarchy processing relational systems 
information systems 
cleveland mcgill 
dynamic graphics statistics 
wadsworth 
copeland khoshafian smith valduriez 
buffering schemes permanent data 
proc second intl conf data engineering feb los angeles cal usa pages 
cormen leiserson rivest 
algorithms 
mit press mcgraw hill book th edition 
krishnan vitter 
practical prefetching data compression 
proc acm sigmod intl conf management data washington may pages 
acm press 
dar franklin nsson srivastava tan 
semantic data caching replacement 
proc th intl conf large data bases sept mumbai bombay india pages 
morgan kaufmann 
harrison moore roth 
efficient multi object dynamic query histograms 
proc 
information visualization pages oct 
feiner 
worlds worlds metaphors exploring ndimensional virtual worlds 
proc 
uist 
florescu levy suciu 
run time management data intensive web sites 
technical report inria institut national de recherche en informatique en automatique 
fua ward rundensteiner 
hierarchical parallel coordinates exploration large datasets 
ieee proc 
visualization pages oct 
fua ward rundensteiner 
navigating hierarchies structure brushes 
proc 
information visualization pages oct 
bradley craig unwin wills 
dynamic graphics exploring spatial data application locating global local anomalies 
statistical computing 
rundensteiner 
processing incremental multidimensional range queries direct manipulation visual query 
proc fourteenth intl conf data engineering orlando florida usa pages 

user interface evaluation direct manipulation temporal visual query language 
proc fifth acm intl multimedia conf multimedia pages new york reading nov 
acm press addison wesley 
ioannidis 
dynamic information visualization 
sigmod record acm special interest group management data dec 
jeong pang 
reconfigurable disc trees visualizing large hierarchical information space 
proc 
information visualization 
joseph grunwald 
prefetching markov predictors 
proc th annual intl symposium computer architecture isca computer architecture news pages new york june 
acm press 
kaushik rundensteiner 
spatial visual query exploration language 
lecture notes computer science 
keller basu 
predicate caching scheme client server database architectures 
vldb journal 
kohonen 
self organizing map 
proc 
ieee 
leung apperley :10.1.1.11.9765
review taxonomy distortion oriented presentation techniques 
acm transactions computer human interaction vol 
june 
livny ramakrishnan beyer chen myllymaki wenger 
devise integrated querying visualization large datasets 
proc acm sigmod intl conf management data may tucson arizona usa pages 
acm press 
martin ward 
high dimensional brushing interactive exploration multivariate data 
proc 
visualization 
mead 
review development multidimensional scaling methods 
statistician vol 

qian 
query folding 
su editor proceedings twelfth international conference data engineering february march new orleans louisiana pages 
ieee computer society 
robertson mackinlay card 
cone trees animated visualization hierarchical information 
proc 
computer human interaction 
roussopoulos 
chen kelley papakonstantinou 
project view 
data engineering bulletin 
selfridge srivastava wilson 
idea interactive data exploration analysis 
proc acm sigmod intl conf management data montreal quebec canada june pages 
acm press 
shapiro 
join processing database systems large main memories 
tods 
shekita carey 
performance evaluation pointer joins 
proc acm sigmod intl conf management data atlantic city nj may pages 
acm press 
shneiderman :10.1.1.29.1549
tree visualization tree maps space filling approach 
acm transactions graphics jan 
stonebraker 
inclusion new types relational data base systems 
proc intl conf data engineering volume ieee computer society order number pages los angeles ca feb 
ieee computer society ieee computer society press 
stonebraker chen nathan paxson wu 
tioga providing data management support scientific visualization applications 
th intl conf large data bases dublin ireland pages 
morgan kaufmann 
rundensteiner ward 
minmax trees efficient relational operation support hierarchy data exploration 
technical report tr worcester polytechnic institute computer science department 

fast multithreaded core visualization technique 
th intl parallel processing symposium th symposium parallel distributed processing apr 
beigel shneiderman 
incremental data structures algorithms dynamic query interfaces 
acm special interest group management data dec 

path signatures way speed recursion relational databases 
ieee transactions knowledge data engineering june 
valduriez 
join indices 
tods 
valduriez khoshafian copeland 
implementation techniques complex objects 
vldb twelfth intl conf large data bases august kyoto japan proc pages 
morgan kaufmann 
ward 
xmdvtool integrating multiple methods visualizing multivariate data 
proc 
visualization pages 
wills 
selection ways say interesting 
proc 
information visualization 
xmdvtool home page 
davis wpi edu 
zhang ramakrishnan livny 
birch efficient data clustering method large databases 
sigmod record vol pages june 

