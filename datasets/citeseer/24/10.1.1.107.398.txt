arxiv cs cs pl jun type classes constraint handling rules kevin glynn peter stuckey martin sulzmann dept computer science software engineering university melbourne australia 
pjs sulzmann cs mu oz au type classes elegant extension traditional hindley milner typing systems 
modern typed languages haskell support controlled overloading symbols 
haskell supports single parameter constructor type classes 
extensions multi parameter type classes highly desired officially supported haskell 
subtle issues arise extensions may lead loss feasible type inference ambiguous programs 
proper logical basis type class systems missing 
basis allow extensions characterised studied rigorously 
propose employ constraint handling rules tool study develop type class systems uniform way 
haskell language pha provides advanced type systems industrial strength language 
type classes distinctive features haskell 
form type classes haskell restricted single parameter constructor jon type classes 
rigorous treatment haskell type system jon fills serious gaps current specifications haskell 
original papers kae wb type classes researchers studied extensions existing type class system cho jjm 
particular multi parameter type classes desirable extension see jjm overview 
multi parameter type classes officially supported haskell 
authors note design decisions need taken great care order retain feasible type inference 
existing implementations haskell dictionary passing translation support type class overloading 
requires types unambiguous implementation know dictionary passed 
unfortunately existing single parameter class system ambiguous types occur 
jon jones extends type classes functional dependencies resolve ambiguity context multi parameter classes certain cases 
find type classes active area research debate features incorporated haskell specifications far settled 

contrast previous foremost goal propose extension type classes 
thesis constraint handling rules fru right way understand type class constraints extensions type classes 
particular constraint handling rules help understand main issues possible type class extensions feasible type inference unambiguous programs 
feasible type inference important property needs retained considering type class extensions 
type inference decidable compute principal types 
hindley milner types characterized constraints representable herbrand constraints solvable understood constraint solvers robinson unification algorithm 
clearly type classes simply form constraint system extending herbrand constraints constrains value various type variables take 
constraint handling rules chrs way extending constraint solving wellunderstood underlying constraint domain handle new forms constraints 
chrs simple language efficient implementations available 
give natural definition constraint solver type classes clarify issues meaning type class extensions give insight problems ambiguity overlapping instances type classes multi parameter type classes 
chrs allow specify conditions feasible type inference guaranteed 
purpose workshop explain ideas example giving rigorous formal treatment 
outline 
section motivates approach reviewing limitations haskell type class system overcome extensions defined chrs 
section review basic ideas chrs 
type inference described section 
section states sufficient conditions achieve feasible type inference unambiguous programs 
section show express previously proposed literature type class extensions terms chrs 
section show chrs prove useful defining novel type class extensions 
conclude section 
motivation type classes elegant extension traditional hindley milner typing systems 
addition supporting controlled overloading functions allow programmers language designers identify related types 
example new type instance eq class adding convenience operator telling users type inhabitants exact identifiable 
note choose type instance eq making statement inhabitants representing values inexact hard identify 
unfortunately haskell impossible enforce restrictions class membership 
worse instance declarations global program instance declaration type particular class 
requires instance declaration visible module exported modules import bypassing haskell name hiding mechanisms 
module declares bool member num class importing module treats booleans member num 
writer importing module may completely unaware happened 
errors import bool instance integral cap power num integral bool cap power surely intended compile just fine bizarre consequences 
researchers studied extensions useful main taining haskell decidable type inference 
particular extensions proposed support multi parameter type classes allow relationships components type class standard super sub class relations 
extensions ad hoc requiring special syntax hidden restrictions added language order guarantee principal types decidable type inference algorithm 
chrs provide framework allows freedom programmer language designer specify constraints type classes 
extra constraints serve programs typable powerful constraints remove potential ambiguity types program programs typable class constraints restrict types intended class writer 
chrs described section remainder section introduce examples give feel chrs language safer expressive 
disjoint classes haskell support type classes restrictive adding multi parameter type classes language 
example say integral fractional type classes disjoint 
expressed current haskell function div inferred type integral fractional immediately causing type error 
disjoint classes resolve ambiguities program 
overlapping type class instances thorny issue haskell implementations 
general overlapping instances lead unacceptable ambiguity programs 
improved class information clear overlapping instances really overlap 
example imagine division operator class defined follows class num instance fractional instance integral div instances appear overlap know integral fractional type classes intended disjoint ambiguity 
notice implies extension ghc existing experimental support overlapping instances 
currently ghc ignores instance constraints deciding instance declarations overlap 
special case disjoint sets allows specify instance declarations certain types error 
example add constraints prelude programmers types bool char function types instances num class 
done directly type declare disjoint set num types instances disjoint class 
multi parameter classes jones jon points need extend type classes relation types understood haskell implementations support multi parameter type classes non standard extensions 
practice haven worked hoped 
useful programs ambiguous types fall foul syntactic restrictions required feasible type inference 
allowing expressive constraints elements class relation programs typed addition class designer finer control 
show useful relationships collects class jones example 
class collects ce empty ce insert ce ce member ce bool functional dependencies jones proposes extend type classes functional dependencies support dependencies class components 
give programmer necessary control allowed relationships allow additional programs typed 
empty method collects ambiguous type ce fixed may possible instance declaration 
say type dependent type ce longer ambiguous 
chrs subsume expressiveness functional dependencies 
remaining examples possible functional dependencies supported chrs 
anti symmetrical relations collects class allows declare collection instance declaration collects 
sensible declare instance reverse collects chr specify relationship anti symmetrical making instance declaration type error 
irreflexive relations collects relation irreflexive wouldn sensible allow type collection type collects unifiable 
relationships transitivity symmetry expressed chrs 
constructor classes type constructors list functions types 
implicitly type constructor kind specifies number argument types required produce result type 
constructor classes supported haskell allow programmer write class type constructors 
type constructor correct kind instance class definition functor class haskell class functor fmap instances provided tree int don correct kind 
introducing kind system haskell chrs express constraints multi parameter class constraints 
chr system explicitly describe required constraints type constructor functional surjective correctly kinded 
constraint handling rules constraint handling rules fru chrs multi headed concurrent constraint language writing incremental constraint solvers 
effect define transitions constraint set equivalent constraint set 
transitions serve simplify constraints detect satisfiability unsatisfiability 
efficient implementations chrs available languages sicstus prolog eclipse prolog implementations currently developed java 
chrs manipulate constraint set parts global constraint language underlying solver global set primitive constraints defined constraint handling rules 
constraint handling rules chr rules forms sufficient simplification rulename 
cn dm propagation rulename 
cn 
dm rules rulename unique identifier rule cn chr constraints herbrand constraint dm chr herbrand constraints 
guard part optional 
omitted equivalent true 
simplification rule states constraint set 
cn hold set replaced dm 
propagation rule states constraint set 
cn hold add 
dm 
chr program set chr rules 
formally logical interpretation rules follows 
variables occurring cn resp 
variables occurring guard resp 
rhs 
dm rule 
assume local variables appear guard rhs 
logical reading simplification cn dm propagation cn dm operational semantics see abd detail transition system quadruple conjunction chr herbrand constraints conjunction chr constraints conjunction herbrand constraints set tokens controlling termination sequence variables logical reading yf variables tuple variable component changes omit presentation 
tokens take form rulename propagation rule conjunction chr constraints matching left hand side rule 
order avoid trivial non termination propagation rules applied applied operational semantics restricts propagation rule applied set matching chr constraints 
tokens introduced new chr constraint moved store application propagation rule 
define token set new propagation rule applications applied adding chr constraint chr store token tokens removed propagation rules longer applicable simplification solve herbrand constraint introduce token chr constraint simplify token propagate variables assumed new appearing chr 
note components triple treated conjunctions matching modulo idempotence commutativity associativity conjunction 
important property chr programs confluence 
confluence implies order transitions doesn affect final result 
states joinable exists derivations variant 
confluent chr programs guaranteed consistent usual sense theory 
chr program confluent iff state joinable 
importantly terminating chr programs confluence decidable abd termination decidable 
programs confluence equivalent local confluence test examining critical pair program seeing joinable 
critical pair rules pair states true true satisfiable 
deciding confluence requires chr program terminating 
number syntactic restrictions haskell class instance declarations assure resulting chr programs terminating 
number approaches proving termination chr programs fru 
type inference haskell implicitly typed language 
task type inference infer type program report error program typable 
identify issues 
class instance declarations correct 

type inference generate correct set constraints represent possible solutions typing problem 
program typable constraint problem solvable 

simplification constraints important reasons 
syntactically allows type class constraints programmer readable form 
operationally simplification allows put type class constraints efficient form 
type class constraints translated dictionaries 
simplifying type class constraints may allow efficient translation 
form simplification known context reduction haskell 
type inference starts processing class instance declarations translate class instance declarations chr program 
type inference generates constraints haskell program applies chr solving process 
chr constraint solvable derivation lead constraint including false 
simplification may invoked necessary 
sections expand issues 
class instance declarations section show translate class instance definitions chrs 
class definitions class definition class dm 
xn 
constrains instance class satisfy class constraints 
dm 
corresponding chr 
xn 
dm example 
consider standard prelude definitions ord translation class eq ord 
ord eq assert ord constraint satisfy eq constraint 
instance definitions instance definition instance dm 
tn 
maintains tuple 
tn instance constraints 
dm satisfied 
corresponds simplification rule 

tn 
dm example 
instances ord eq lists translations instance eq eq 
eq eq instance ord ord 
ord ord means prove type instance class eq ord prove instance 
checking instance definitions instance declaration compatible class definition 
instance declaration correct sense resulting chr program confluent 
example 
instance declaration ord didn require class ord instance ord 
ord true non confluent chr program ord derivations result joinable ord true true true true ord ord ord eq eq true ord true true ord eq ord true true true eq eq eq eq true true true true eq ord true true true true ord ord ord true true true true generating chr program assuming terminating check confluent 
isn confluent error instance declarations safely chr program type inference 
solving type class constraints view type classes simply constraints defined chr rules solving process obvious generate constraints program text apply chr solving process 
example 
consider haskell function tail init constraints generated ta tg tb th tf tg th tc ord bool ta tb tc note subscript notation associate expressions inferred type 
simplification unification obtain ta tg tb th tf bool ord apply constraint handling rules constraint ord obtain derivation ord true true true ord true ord ord ord ord true true true ord true ord ord eq eq ord true true eq ord true derivations laborious simplified derivations tuple represented single conjunction unification applied remove extra variables token set omitted 
corresponding derivation ord ord ord eq chr program confluent alternative rewritings eventually give result example gives answer 
ord ord eq ord eq ord eq presenting type class constraints chrs simplification rules replace type class constraint simpler equivalent form 
want type definition user wish simplest possible form 
contrary usual solving methodology adds redundant information simplify detection unsatisfiability 
worth adding separate simplification phase presenting constrained types users 
represented disjoint chr program 
presentation rules class definition class dm 
xn 
form 
xn di 
xn removes redundant constraints presentation 
example 
example class definition corresponding presentation rule class eq ord 
ord eq ord presenting answer example obtain type ord bool ord eq ord 
properties type class systems chrs allow characterize conditions retain feasible type inference unambiguous programs 
feasible type inference feasible type inference decidable yield principal types 
chr type inference decidable chr program terminating 
restrict instance class definitions allowed haskell report ghc multi parameter type class extensions resulting chr program terminating 
means haskell program inferred type subsumes types possibly give program 
chrs preserve principal types map constraints logically equivalent constraints 
note principal types syntactically unique example possible principal types chr program confluent type 
confluence chr program vital property 
guarantees chr program consistent meaningfully talk unsatisfiable type constraints guarantees instance definitions satisfy class definitions 
type signatures type signatures allow user declare variables certain type 
optional form program documentation necessary example retain decidability case polymorphic recursion 
presence type signatures moving type inference problem type reconstruction problem 
shift implies constraint solver needs handle entailment constraints 
decidable constraint entailment difficult establish 
jon find conditions haskell sufficient guarantee entailment decidable 
unambiguous types haskell framework function unambiguous type 
understand notion unambiguity terms chrs extend type system complex chrs retain property 
suppose inferred type function type unambiguous chr program renaming new variables variable vars 
sound check unambiguity type chr program seeing 
check complete haskell programs ignoring haskell numeric defaulting mechanism 
conjecture complete interesting haskell extensions functional dependencies 
example 
recall collects example section 
type empty empty collects ce ce 
type ambiguous collects ce collects ce ce ce allow propagation steps imply type defined insert insert collects ce ce ce clearly unambiguous 
understanding type classes extensions number extensions type classes proposed literature 
understood uniform framework chrs 
unifying representation different extensions gain insight kinds extensions feasible 
functional dependencies jones jon proposes extension multi parameter type classes include functional dependencies class arguments 
chr point view functional dependencies variables type class just extend proof requirements instance 
expressible straightforwardly chrs 
class definition functional dependencies form class 
dm 
xn fd 
fd 
fdi functional dependency form xi 
xik xi 
jon rhs list variables 
simpler form expressiveness equivalent 
functional dependency asserts fixed values xi xik value xi class constraint 
xn hold 
chr translation creates propagation rule functional dependency form 
xn 
yn xi yi xik xi yi chr enforces functional dependency 
example 
returning collection class example adding functional dependency 
rule simplified chr class collects ce ce 
collects ce collects ce note type empty unambiguous collects ce collects ce ce ce collects ce collects ce ce ce example 
type checking inference insert insert insert collects ce ce ce gives collects ce ce ce ty tc tz collects ce ce ce tx tz collects ce collects ce tc tz ce ce ty tx collects ce collects ce tc tz ce ce ty tx collects ce tc tz ce ce tx ty type inferred collects ce ce ce expected 
view functional dependencies chrs clarifies questions jones poses jon 
declarations class class jones framework constraints inferred chr rules support automatic inference inherited functional dependencies consider example constructor classes type constructors simply functional relation types 
understand simply chrs simply matter replacing constructor expressions lets say fe explicit kind constraints kind fe 
class constraints need satisfy appropriate properties functionality expressed chrs kind constraints 
example functional kind fe kind fe fe fe surjective kind fe kind fe kinding kind fe kind false clearly constructor classes expressed chrs uniform understanding meaning 
presentation constructor class constraints user preferable usual notation simply matter presentation 
extensions types classes chrs chrs specify existing type class extensions immediate question new extensions express terms chrs 
disjointness type classes example section illustrates may useful additional constraints instances class 
disjointness may able weaker definition nonoverlapping instances 
example 
chr expressing integral fractional type classes disjoint simply 
integral fractional false translate instance declarations motivation obtain di integral df fractional clearly resulting chrs confluent disjoint replacements weaken simplification rules di integral integral df fractional fractional give confluent system 
note reading remove constraint know integral fractional simply replace constraints 
extension allow negative information type classes 
example 
intention num class describe numeric types 
insist functional types numbers adding rule num false form class meant indicate types numbers functional types class expressed rules num false true case declaration instance num cause error detected resulting chr program confluent 
general considerable problems supporting overlapping class instances 
key thing understand confluence resulting chrs gives behaviour expect 
resulting chr program confluent error program class instance definitions 
chr program confluent doesn mean problems correctness types affected overlapping instances 
example 
consider program instance bool instance int 
question happen class constraint bool int 
bool int clear constraint holds simply choose instance methods 
allow overlapping class instances leaves fundamental problem choice 
record types define extensible record type class set types labels class constraints class rec select access record update update record class rec ext extend rec constraint constrains record type containing element labeled type ext constraint constraints type obtained extending new element labelled type obvious rules want hold order enforce type correctness 
consider code class defn ext rec functionality rec rec false extension ext rec false extension ext rec rec select select unique element type extend select select select simplified type constraints rec tx tf rec tx tf tx tf tf rec tx tl ts ext ty tl ts te tx ty tl te rec tx te rec tx te tx tx te demonstrated constraint handling rules useful tool understanding type class systems 
existing type class systems expressed terms chr rules 
surprisingly constructor classes multi parameter classes considered orthogonal extensions expressible terms chrs 
useful extensions disjoint classes naturally expressed chrs 
feasible type inference unambiguity important issues design type class system 
chrs allow characterize sufficient conditions retain properties 
conclude chrs offer natural way study type class systems 
development motivated examples intuition 
currently working formal treatment report separately 
abd 
operational semantics confluence constraint propagation rules 
proceedings third international conference principles practice constraint programming cp lncs pages 
springer 
cho kung chen paul hudak martin odersky 
parametric type classes 
proceedings acm conference lisp functional programming pages 
acm press june 
fru 
constraint handling rules 
podelski editor constraint programming basics trends volume lecture notes computer science 
springer verlag 
fru 
declarative language constraint systems theory practice constraint handling rules 
habilitation 
jjm simon peyton jones mark jones erik meijer 
type classes exploration design space 
haskell workshop june 
jon mark jones 
system constructor classes overloading implicit higher order polymorphism 
fpca conference functional programming languages computer architecture pages 
acm press june 
jon mark jones 
typing haskell haskell 
haskell workshop september 
jon mark jones 
type classes functional dependencies 
smolka editor proceedings th european symposium programming languages systems esop volume lecture notes computer science 
springer verlag march 
kae stefan kaes 
parametric overloading polymorphic programming languages 
esop programming languages systems volume lecture notes computer science pages 
springer verlag 
pha sl peyton jones hughes augustsson barton boutel burton fasel hammond hinze hudak johnsson mp jones launchbury meijer peterson reid runciman pl wadler 
report programming language haskell february 
www haskell org definition 
wb philip wadler stephen blott 
ad hoc polymorphism ad hoc 
proc 
th acm symposium principles programming languages popl pages january 

