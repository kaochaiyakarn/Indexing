albert cohen albert cohen inria fr claire claire cert fr synchronous kahn networks relaxed model synchrony real time systems marc marc philips com florence plateau florence plateau lri fr group inria lri paris sud university france lri paris sud university france philips research laboratories eindhoven netherlands cert toulouse france design high performance stream processing systems fast growing domain driven markets high tv gaming animation medical imaging 
surprisingly demanding task respect algorithmic conceptual simplicity streaming applications 
needs close cooperation numerical analysts parallel programming experts realtime control experts computer architects incurs high level quality insurance optimization 
search improved productivity propose programming model language dedicated high performance stream processing 
language builds synchronous programming model domain knowledge periodic evolution streams allow correct construction properties proven compiler 
properties include resource requirements delays input output streams 
automating task avoids tedious error prone engineering due combinatorics composition filters multiple data rates formats 
correctness implementation difficult assess traditional asynchronous simulation approaches 
language provided relaxed notion synchronous composition called synchrony processes synchronous communicate ordinary synchronous model fifo buffer size technically extend core synchronous data flow language notion periodic clocks design relaxed clock calculus type system clocks allow non strictly synchronous processes composed correlated 
relaxation associated sub typing rules clock calculus 
delay buffer insertion control code buffers automatically inferred clock types systematic transformation standard synchronous program 
formally define se permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl january charleston south carolina usa 
copyright acm 

christine christine inria fr marc marc lri fr mantics language prove soundness completeness clock calculus synchronization transformation 
language compared existing formalisms 

rapid evolution embedded system technology favored moore law standards increasingly blurring barriers design safety critical real time high performance systems 
example domain high video applications tera operations second pixel components hard real time soon common low power devices 
unfortunately general purpose architectures compilers suitable design real time high performance massively parallel low power programmable system chip 
achieving high compute density preserving programmability challenge choice appropriate architecture programming language compiler 
typically thousands operations cycle sustained chip exploiting multiple levels parallelism compute kernel enforcing strong real time properties 
synchronous languages help address challenges studied synchronous model computation allows generation custom parallel hardware software systems correct construction structural properties including real time resource constraints 
model met industrial success safety critical reactive systems languages signal lustre esterel :10.1.1.34.5059
enforce real time resources properties synchronous languages assume common clock registers predictable execution layer communications computations proven take physical logical clock cycle 
due wire delays massively parallel system chip divided multiple asynchronous clock domains called globally asynchronous locally synchronous gals model 
strong impact formalization synchronous execution associated compilation strategies 
due complexity high performance applications intrinsic combinatorics synchronous execution earlier showed multiple clock domains considered application level 
case modular designs separate compilation phases single system multiple input output associated different realtime clocks video streaming 
necessary compose independently scheduled processes 
kahn process networks kpn accommodate composition compensating local asynchrony unbounded blocking fifo buffers 
allowing global synchronous execution imposes additional constraints composition 
introduce concept synchronous clocks formalize concepts constraints 
concept describes naturally semantics kpn bounded statically computable buffer sizes 
extension allows modular composition independently scheduled components multiple periodic clocks satisfying flow preservation equation automatic inference bounded delays fifo buffers 
main contributions technically define relaxed principle called synchrony 
clock ck clock ck exists data flow causality preserving way making ck synchronous ck applying constant delay ck inserting intermediate fifo buffer 
principle currently restricted periodic clocks defined periodic infinite binary words 
different independent retiming ck ck modified optional insertion constant delay schedule choices associated ck ck impacted synchronization process 
define relaxed synchronous functional programming language clock calculus accepts synchronous composition operators 
type system underlying strictly synchronous clock calculus extended subtyping rules 
type inference follows ad hoc complete procedure 
show synchronous program transformed synchronous synchronous replacing bounded buffers synchronous code 
outline structure 
section motivate synchronous model presentation simple high performance video application 
section formalizes concepts periodic clocks 
section main contribution starting core synchronous language la lustre presents associated calculus periodic clocks extends calculus combine streams synchronizable clocks 
section describes semantics process composition translation strictly synchronous program automatically inserting buffers minimal size 
section discusses related frontier synchronous asynchronous systems 
conclude section 
motivation may contribute design wide range embedded systems primarily driven video stream processing high definition tv 
main algorithms deal picture scaling picture composition picture picture quality enhancement including picture rate conversions converting frame rate displayed video de interlacing flat panel displays sharpness improvement color enhancement 
processing requires considerable resources involves variety pipelined algorithms multidimensional streams 
hd input hf reorder vf sd output hf working set 
frame stripe vf working set applications involve set resize images real time 
running example classical depicted 
converts high definition hd video signal pixels frame standard definition sd output tv screen 
horizontal filter hf reduces number pixels line interpolating packets pixels 

reordering module reorder stores lines pixels 

vertical filter vf reduces number lines frame interpolating packets pixels 
processing frame involves constant number operations frame 
design tool expected automatically produce efficient code embedded architecture check real time constraints met optimize memory footprint intermediate data control code 
embedded system designer looking programming language offers precisely features precisely statically guarantees important properties 
proof worst case execution time hypotheses frame pixel rate sustained 
evaluation delay introduced video processing chain delay output process starts receiving pixels 
proof system bounded memory requirements 
evaluation memory requirements store data processes buffer stream produced vertical filter front output process 
theory synchronous languages suited implementation enforcing bounded resource requirements real time execution 
show existing synchronous languages implementation tedious error prone 
need capture periodic execution technically scaling algorithm produces th output ot interpolating consecutive pixels weighted coefficients predetermined matrix example phases taps polyphase filter ot pt coef mod 
clock ok rec cnt fby cnt cnt ok cnt cnt cnt node hf rec fby fby fby fby fby val hf int int val hf 
synchronous implementation filtering functions easily programmed strictly synchronous data flow language lustre lucid syn 
shows version horizontal filter implemented lucid 
consider active pixels bs digital high definition standards 
clock tick hf function computes interpolation consecutive pixels input fby stands previous value initialised value 
implementation scope assume sums arguments 
horizontal filter match production pixels input pixels 
signal processing algorithm defines precisely time pixel emitted th output appears th input 
factored periodic behavior size introducing auxiliary boolean stream clock sample output horizontal filter 
clock construction identifies syntactically particular boolean streams 
possible execution diagram 
true false true false false true false 
synchronous data flow model variable expression characterized stream values clock relative global clock called base clock system 
clock expression infinite boolean stream false stands absence true presence 
integer stream variable clock 
synchronous process transforms input clock output clock 
transformation encoded process clock signature clock type 
clocks signatures relative clock variables 
clock signature printed meaning clock clock output defined instant boolean condition true 
synchronous languages clock conditions arbitrarily complex boolean expressions meaning compilers hypothesis 
applications consider periodic behavior simplification consists enhancing syntax semantics notion periodic clocks 
need relaxed approach real time constraints filters deduced frame rate input output processes enforce frames sent received hz 
means hd pixels arrive hz called hd pixel clock sd pixels hz called sd pixel clock times slower 
numbers designer know delay seeing output pixel cycles hd pixel clock minimal size buffer vertical filter output process pixels 
synchronous languages typically offer guarantees static evaluations forcing programmer explicit synchronous execution application 
synchronous language requires designer explicitly implement synchronous code buffer outgoing pixels proper output rate helps automatically compute values 
unfortunately pixels produced periodic complex event clock 
synchronous code buffer handles storage pending write vertical filter dedicated register time output process fetch pixel reached 
forcing programmer provide synchronous buffer code tedious breaks modular composition 
scheme complex include periods 
design language computation process latencies buffer sizes automatic explicit periodic clocks 

ultimately periodic clocks section introduces formalism reasoning periodic clocks infinite data streams 
definitions notations infinite binary words words sake simplicity assume infinite binary word infinite number 
interested subset words called infinite ultimately periodic binary words simply infinite periodic binary words defined grammar limn denotes infinite repetition period prefix denote set infinite periodic binary words coincides set rational numbers 
consider infinite periodic binary words infinite number period contains 
corresponds removing integer numbers considering denote length denote number number denote th letter prefix length infinite number representations infinite periodic binary word 
equal 
fortunately exists normal representation unique representation form shortest prefix shortest period 
denote position th 
define precedence relation 
relation partial order infinite binary words 
abstracts causality relation stream computations check outputs produced consumers request inputs 
define upper bound lower bound infinite binary words max min 

proposition 
set complete lattice 
notice 
eventually allows operations infinite periodic binary words computed finite words 

considering infinite periodic binary words may transform expressions equivalent representatives satisfying conditions 
restriction lattice complete upwards downwards 
may choose max lcm lcm stands common multiple 
assuming lcm 

words rewritten 

likewise may obtain prefixes suffixes number max lcm 
suppose lcm 

pair words 

may write 
suppose lcm 

pair words rewritten 
clock sampling periodic clocks clock infinite streams infinite binary word composition defined grammar con clock infinite binary word denotes subsampled clock set clock words con clock obtained advancing clock pace clock 


con 
formally inductively defined follows won won won won won won clearly operator commutative 
proposition 
infinite binary words infinite binary word satisfies equation 
proof 
proven induction observing traversed rate associated th rank 
assuming equation true argument proves won distance concludes proof 
important corollary proposition associativity 
infinite binary words 

properties derive proposition proposition distributivity 
operator distributive respect lattice operations 
proposition monotonicity 
infinite binary word functions won monotone 
injective 
infinite binary words exhibit interesting set clocks call ultimately periodic clocks simply periodic clocks 
periodic clock clock stream periodic 
periodic clocks defined follows con 
case periodic clocks proposition algorithm allowing effectively compute result consider infinite periodic binary words possible 
computed likewise periodic clocks closed pointwise extensions boolean operators 
motivated example introduce equivalence relation characterize concept resynchronization infinite binary words necessarily periodic 
definition synchronizable words 
say infinite binary words synchronizable write iff exists dw means delay ticks occur reciprocally 
means th bounded distance th synchronizable synchronizable synchronizable asymptotically reads writes 
case periodic clocks notion computable 
proposition 
infinite periodic binary words synchronizable denoted iff rate throughput 
words means fraction asymptotic production rate 
means th bounded distance th proof 
consider 
iff exists 
sufficient cover prefixes finite length max 
case straightforward 
assume case symmetric 
means 
entails synchronizable 
denote vn na vn vn na minimal sense vn entails lim synchronizable 
conversely assume 
finite ru pu ku qu max 
max 
min min 
synchronizable 

additional delay period holds 

programming language section introduces simple data flow functional language infinite data streams 
semantics language strictly synchronous core enforced called clock calculus type system reject non synchronous programs 
main contribution extend core relaxed interpretation synchrony 
obtained extending clock calculus accept composition streams clocks equal 
program turn automatically transformed conventional synchronous programs inserting buffer code proper places 
synchronous data flow kernel introduce core data flow language infinite streams 
syntax derives 
expressions constant streams variables pairs local definitions functions stream variables applications initialized delays fby sampling functions pe sampled stream periodic clock value pe merge combination operator complementary streams opposite periodic clocks order form longer stream fst classical access functions 
syntactic sugar pe sampled stream negation periodic clock pe 
program sequence declarations stream functions node periodic clocks period pe 
period half defines half periodic clock alternating bit sequence clock build period quarter half half periodic clocks combined boolean operators 
note clocks static expressions simplified compile time normal form infinite periodic binary words 
op pe merge pe fst snd eat node dp period pe dp dp pe pe pe pe pe pe easily program language shown 
main function consists composing various filtering functions 
constraint programmer states output pixel produced clock times slower input clock 
period node hf rec 
node main rec hf reorder vf 
synchronous code periodic clock corresponds ml 
synchronous semantics synchronous denotational semantics core data flow language built classical theory synchronous languages 
syntactic details essentially core lustre language 
ease presentation restricted sampling operations apply periodic clocks boolean sequence sample stream existing synchronous languages 
periodic clocks defined globally constant values 
period expressions turn automatically transformed plain synchronous code circuits expressions 
kernel statically typed straightforward typing rules consider clock types 
way consider causality initialization problems rejection recursive stream functions 
classical analyses apply directly core language orthogonal synchrony 
compilation process takes steps 

clock calculus computes constraints satisfied clock generated specific type system 
constraints resolved unification procedure infer periodic clock expression program 
solution prove expressions periodic execution consistent rest program program synchronous rejected 

solution code generation step transforms data flow program imperative executable ocaml processes synchronously executed actual clock 
clock calculus propose type system generate clock constraints 
goal clock calculus produce judgments form ct meaning expression clock type ct environments periods environment 
clock types split categories clock schemes quantified set clock variables unquantified clock types ct 
clock may functional clock ct ct product ct ct stream clock ck 
stream clock may sampled clock pe clock variable 
ct ct ct ct ct ct ck ck pe xm pe pn pen distinction clock types ct stream clock types ck surprise reader 
kahn networks clock types clear distinction channel receives clock type ck stream function receives functional clock type ct ct pair expression receives clock type ct ct meaning expressions necessarily synchronized values 
clocks may instantiated generalized 
key feature achieve modularity analysis 
horizontal filter clock scheme means input clock output clock 
clock type turn instantiated ways replacing precise stream clock type sampled clock 
shall say clock clock type clear context 
rules instantiating generalizing clock type 
fv ct denotes set free clock variables ct ct ck ct ct ct fv ct states clock scheme instantiated replacing variables clock expressions ct returns fully generalized clock type variable ct quantified universally 
defining periods take care identifiers defined 
period environment function period names periods shall simply write pe free name appearing pe defined clocking rules defining predicate ct discussed 
im ck inst ct ct op ck ck op ck fby ck ck fby ck ck pe pe pe merge pe pe pe merge pe ck app ct ct ct ct ct ct ct ct ct pair ct ct ct ct fst ct ct fst ct snd ct ct snd ct ctr ck ck node ck ct ct node ct ct period pe period pe pe dh dh dh dh 
core clock calculus constant stream may clock ck rule im 
clock identifier instantiated rule inst 
inputs imported primitives clock rule op 
rule fby states clock fby identical 
rule states clock pe sub clock clock write ck pe 
doing check pe valid periodic clock 
rule merge states expression merge pe clocked clock ck clock ck pe clock complementary clock pe 
rule app classical typing rule ml type systems 
rule rule recursive definitions 
rules pair fst snd rules pairs 
rule ctr syntax states clock associated imposed clock type constraint clocks 
node declarations rule node clocked regular function definitions 
write ct clock environment extended association ct 
node definitions apply top level nested generalize variable appearing clock type 
rules period check period stream variables formed names period stream expressions defined 
structural clock unification synchronous data flow languages lustre lucid clocks arbitrarily complex boolean expressions 
practice compiler hypothesis condition clock type ck 
expressiveness essential feature synchronous languages forces compiler syntactical criteria unification process clock types ck ck unified ck ck unified syntactically equal 
approach applied case periodic clocks 
clock types ck ck unified ck ck unified equality infinite binary words 
result structural clock unification unable compare stream clocks absent instants 
clever unification mechanism purpose section 
semantics clocked streams provide language data flow semantics finite infinite sequences kahn formulation 
restrict kahn semantics making absence value explicit 
set instantaneous values enriched special value representing absence value 
need preliminary notations 
set denotes set finite infinite sequences elements set 
empty sequence noted denotes sequence head tail prefix order sequences prefix ordered set complete partial order cpo 
cpos cpo coordinate wise order 
set continuous functions cpo pointwise order 
continuous mapping shall write fix limn smallest fix point kleene theorem 
define set slightly simpler classical generalization rule ml restrict generalization variables appear free environment 
clocked sequences set finite infinite sequences elements set 
clocked sequence absent values 
define clock sequence boolean sequence absent values indicating value 
purpose define function clock clocked sequences boolean sequences clock clock clock clock clock shall letter values 
denotes stream element rest denotes stream element absent 
interpretation basic primitives core language clocked sequences 
mark distinguish syntactic construct fby interpretation stream transformer 
const const const const op op op op op fby fby fby fby fby fby fby fby fby fby merge merge merge merge merge 
semantics core primitives const primitive produces constant stream immediate value 
primitive polymorphic may produce value environment 
reason add extra argument giving clock 
const denotes constant stream stream clock clock const 
binary operator operands synchronous absent purpose clock calculus ensure statically buffering necessary 
fby unitary delay head argument second 
arguments result fby clock 
fby corresponds state machine arguments absent emits stays initial state fby 
emits argument enters new state fby storing previous value second argument 
state emits value time arguments 
sampling operator expects arguments clock 
clock result depends boolean condition 
definition merge states branch absent 
note operate boolean sequences 
boolean operations clocks follow principle 
easy check functions continuous clocked sequences 
semantics expressions passed clock calculus judgments 
define interpretation clock types ct ct ct ct ct ct ct ct ct ck ct ck ck clock ck order take away causality problems treated dedicated analysis synchronous languages ck contains streams clock prefix value ck particular empty sequence 
way equation clocked ck ck causal smallest solution receive synchronous semantics 
period environment clock environment assignment maps variable names values meaning expression ct ct ct denotational semantics language defined structurally 
example illustrate definitions 
suppose input clock type 
horizontal filter signature corresponding effective synchronous implementation process 

horizontal filter vertical filter reorder process stores previous lines sliding window size impact clock delaying output receives full lines cycles 
shall give reorder clock signature 

vertical filter produces pixels pixels repeatedly pixels stripe lines 
signature matching process synchronous implementation simplify presentation assume manual computations unit computation vertical filter line pixel replace previous signature yielding 

designer required global input clock clock output times subsampled input clock tolerating additional delay automatically deduced clock calculus 
op ck op ck ck ct ck ck fby ck fby ck ck pe pe ck pe merge pe ck merge pe pe pe ct ct ct ct ct ct ct ct fst ct ct ct snd ct ct ct ct ct ct fix ct ct node ct ct ct ct ck ck composition processes yield type constraints 
replacing variables definitions get output clock type 
result equal clock constraint stating clock type 
rejected conventional synchronous calculus 
reason introduce relaxed notion 
relaxed synchronous semantics example highlights fundamental problem embedding video streaming applications synchronous programming model 
designer reasons apply synchronous operator addition channels different clocks compose synchronous processes signatures match impose particular clock match solution constraints equations 
cases conflicting clocks may identical asymptotic production rate 
advocates relaxed interpretation synchronism 
main contribution clock calculus accept composition clocks identical defined structural extension relation infinite binary words stream clocks definition synchronizable clocks 
say stream clocks ck ck synchronizable write notice definition directly extend stream clocks different variables 
buffer processes processes communicate synchronizable clocks causality preserved writes precede coincide reads may effectively generate synchronous code storing bounded number pending writes 
consider infinite binary words buffer process clock type data flow semantics unbounded lossless fifo channel 
existence priori unbounded buffer guaranteed causality communication writes occur clock precede clock 
interested buffers finite size bounded buffers size buffer maximal number pending writes 
data flow semantics clocked sequences accomodate preserving semantics unbounded lossless fifo channel 
proposition 
consider processes ck ck exists buffer synchronous composition unification 
proof 
buffer size implemented data registers xi clocks wi ri pending writes stored data registers wi means pending write stored xi cycle clocks ri determine instants process associated reads data xi ri means data register xi read cycle sequence pushes pops imposed clocks case distinction simulates fifo xi registers statically controlled clocks wi ri nop 
operation affects buffer ri wi wi registers xi left unchanged 
push 
data written buffer stored register data buffer pushed xi xi 
xi xi input wi wi ri 
pop 
max wi 
zero register stores data cycle input data bypassed directly output crossing wire clocked setting ri wi wi 
conversely ri rp wi wi wp 
registers xi left unchanged notice symmetric operation 
pop push 
case boils implementation apop followed defined previous cases 
assuming periodic written lines sufficient conduct previous simulation cycles compute periodic clocks wi ri 
leads implementation plain synchronous language implementation impractical clock wi ri worst case quadratic size maximum periods application yielding cubic control space memory usage code size 
motivates search alternative buffer implementation decoupling memory management fifo combinatorial control space implementation proposed section 
relaxed clock calculus modify clock calculus ways 
subtyping rule sub added clock calculus permit automatic insertion finite buffer order synchronize clocks 
rule ctr modified subtyping rule allow automatic insertion calculation bounded delay 
subtyping rule definition 
relation defined partial order restriction equivalence classes relation forms complete lattice 
structurally extend definition stream clocks ck relation defines subtyping rule sub stream clocks types sub standard subsumption rule classical results subtyping apply 
clock calculus defined previous section rejects expressions clocks unified 
rule sub relax calculus allow expression clock ck clock ck soon ck ck synchronizable causality preserved 
program rejected synchronous calculus assuming clock unified 
node denote expression denote expression generate type constraints construct program 
node suppose signature form 
addition expects arguments clocks 
get ck clock ck clock 
sub synchronizable clocks ck ck 
final signature 
considering example subtyping rule solve clock conflict imposed clock needs delayed avoid starvation output process 
purpose rule 
clock constraint rule designer may impose clock certain expressions 
rule ctr relaxed subtyping rule ctr definition directly extends stream clocks different variables 
consider previous example additional constraint output clock 
node yat previously computed signature unify 
rule ctr yields yat 
cycle delay minimum allow synchronization imposed output clock 
relaxed clock calculus rules predicate ct states expression clock ct period environment clock environment synchronization mechanism 
definition extends ct new rules 
axiom rules identical ones judgments 
ctr sub 
relaxed clock calculus starting standard clock calculus purpose reject non synchronous program extend subtyping rules expressing stream produced clock ck read clock ck soon ck synchronized ck buffering mechanism 
presenting system steps additional expressiveness respect classical synchrony precise 
relaxed synchrony operator considered length preserving function data flow networks clock scheme synchronous case despite needs argument instant 
relaxed case chosen clock signatures 
signatures require argument instant overly restrictive practice 
third signature fully acceptable observation original length preserving signature reconstructed applying subtyping rule 
highlights fact operator place buffer 
construction system clock constraints system clock constraints build systematic application core rules relaxed calculus rules 
rules syntax directed sub application implicit function operator composition 
rule ctr special case clock constraint built computing possible value delay computation syntax directed choose minimize delay insertion delay min 
delay necessary 
note general delay delay 
proposition 
delay synchronize infinite periodic binary word imposed infinite periodic binary word automatically computed formula delay max max 
periodic words delay effectively computable 
proof 
max maxp minimal suppose exists satisfies simplified minimal delay resynchronize vertical filter output process clock cycles minimal value 
real fully developed vertical filter signature automatically computed minimal delay permit communication sd output 
unification need better unification procedure clock types structural see section types obtain effective resolution algorithm system constraints 
case syntactic unification unnecessarily reject synchronous programs periodic clocks 
propose semi interpreted unification takes account semantics periodic clocks 
precisely unification clock types ct ct purely structural functional pair types simplification periodic clocks applied aware properties sampling operator unifying stream clock types form ck cases considered 
unifying returns true general case assume clock variables clocks normalised associativity 
equation infinite number solutions solutions generate infinite number different infinite binary words 
intuitively periodic sampling consists insertion periodic manner 
possible delay th resp 
th resp 
insertion resp 

define subsampling relation ss ss note ss converse true solution 
proposition 
relation ss partial order 
proof 
ss trivially reflexive transitive 
antisymmetry holds partial order ss implies typical unification scheme replace type equation general clock type satisfying equation 
see general word common subsamples subsamples ss upper semi lattice expression von lead unique choice maximal unifiers fact infinite set words 
strictly synchronous setting need fall back incomplete unification scheme synchronous programs periodic clocks rejected choosing solutions 
chosen solution unification yields unique clock type von occurence resp 
replaced resp 

relaxed synchronous setting general unifier interesting property proposition synchronizable unifiers 
consider directly derives proposition 
arbitrary choice maximal unifiers select easy compute 
formally define earliest substitutions recurrent equations denote unifier computation terminates periodic words finite number configurations bounded product period 





proposition 
max 
proof 
inductive proof derives naturally previous algorithm 
particular observe consecutive associated subword sequence addition maximum common subsample interesting properties theorem structure subsamples 
subsampling relation ss forms upper semi lattice infinite binary words supremum pair words 
common subsamples form complete lower semilattice structure bottom element 
associative 
complete lower semi lattice structure holds common subsamples finite set infinite binary words 
proof 
proceed induction position th 
consider infinite binary word construction max 
assume common subsamples subsamples th 
proposition tells identical th th common subsamples subsamples ss reversed sub order get induction associativity derives directly proposition 
resolution system clock constraints may define resolution procedure set constraint simplification rules 
clock system turned algorithm introducing subtyping rule application point solving set constraints form ck program clocked set constraints satisfiable 
cycle sup inf equal ck ck ck ck cut umax umin fork umin join umax subst ck ck ck fv ck definition constraints satisfiability 
system clock constraints collection inequations clock types ck ck ck write ck ck extension system inequation ck ck 
write ck ck ck ck contain directed chain inequations free variable ck free variable ck 
example means appear left inequation leads transitively inequation appears right 
system satisfiable exists substitution variables infinite binary words ck ck 
straightforward important weak confluence property subsampling satisfiability proposition subsampling satisfiability 
satisfiable iff satisfiable 
proof 
suppose satisfiable build substitution satisfying system constraints choosing 
reciprocal obvious 
eventually define functions useful bound set subsamples word umin umax defined recursively follows umin umin umax umax notice pairs infinite binary words rational numbers infinite binary words technical interest proofs 
proposition 
umin umax umin umax umin umax infinite periodic binary word synchronizable proof 
part proposition proven inductively position subsampling 
second part consequence definition designed match asymptotic rate propagation fractional part asymptotic rate 
set subsamples word characterized technical proposition 
clock constraints resolution proposition 
umin von umin von umax umax 
umin von umin von umax umax 
proof 
pair implications proven inductively definition umin umax 
second pair implications observe umin resp 
umax yields lower resp 
upper bound umin umax observe synchronizable allows apply part proposition concludes proof 
define simplification relation clock constraints 
definition 
new variable appearing right hand side simplification relation assumed fresh 
theorem preservation satisfiability 
satisfiable satisfiable 
proof 
proposition authorizes sample slow system proof 
consider relation 
sup inf cycle 
satisfiability direct application propositions 
equal 
rule preserves satisfiability just subsamples pair variables 
cut 
definition umin umax right hand side relation sufficient condition satisfiability 
conversely consider solution 
umin umin replace 
umin 
choose proposition umax umax 
umin proposition yields umin 
umin 
righthand side relation satisfiable 
fork join 
proof similar choosing satisfies inequalities simultaneously 
subst 
consider form inequality 
right hand side relation course sufficient condition satisfiability 
clear necessary inequality belong circuit 
assuming belongs circuit simplify system systematic application rules enforcing inequality belongs multiple simple circuits 
retiming argument shows system satisfiable solution inequalities circuit converted equalities considering solution strict inequalities split circuit renaming common clock variable choosing name path inequality path unify broken inequalities effectively remove inequality solution 
proof second form rule equal provided factor unification step cut fork join rules 
consequence resolution algorithm assume rule equal enabling simplification applied rule cut fork join 
theorem resolution algorithm 
set rules defines non deterministic terminating resolution algorithm 
tree simplifications finite 
satisfiable sequence rule applications leading empty set 
proof 
proof graph structure induced 
sup inf strictly reduces number acyclic paths 
equal application cut fork join 
condition guarantees applied finite number times 
systematic application sup inf cut fork join leads system inequality belongs multiple simple circuits 
enables subst strictly reduces length circuit multi path sub graphs 
cycle reduces short circuits single variable 
ordering application rules terminates yields empty set satisfiable 
corollary theorem completeness 
expression period clock environments admissible clock type relaxed clock calculus type inference algorithm computes clock ct verifying ct intuitively type constraints imposed clock calculus satisfiable resolution algorithm discovers solution 
strong result guarantees clock calculus ability accept programs periodic clocks translated strictly synchronous framework 
completeness easier derive existence general type expression 
unification clock stream types purely structural exploits properties operator ways solve equation clock types 
hope system clock constraints solved set confluent rules multiple solutions equivalent retiming 
theorem proves completeness resolution algorithm guarantee quality result total buffer size period length rate common clock 

translation procedure network associated system clock inequalities simplified equalities execution undefined respect semantics synchronous programs 
buffer processes needed synchronize producers consumers 
translation semantics consider input clock ck output period ck fully synchronize communication insert new buffer node clock resp 
states push resp 
pop occurs 
proposition buffer size 
consider synchronizable infinite binary words minimal buffer allow communication size size max max 
communication called size synchronous 
periodic words size effectively computable 
proof 
maximal number pending writes appearing matching reads lower bound minimal size 
minimal size possible implement size buffer registers 
simplified buffer size equal clock may take advance tick respect clock 
real automatically computed size 
define translation semantics programs accepted relaxed clock calculus 
enable state cornerstone result programs accepted relaxed clock calculus turned synchronous programs accepted original clock calculus 
obtained program transformation inserts buffer time strict inequality stream clock types remains resolution 
buffer synchronous program resulting translated program clocked initial system synchronously evaluated 
translation obtained asserting judgment ct meaning period environment clock environment expression clock ct translated insertion rule translation rules simple morphisms 
practical buffer implementation definition section may define custom buffer process exact clock type resynchronize communication 
definition suffers intrinsic combinatorics notice ctr rule shifts clock constraint imposed programmer rule lead insertion synchronization buffer triggering translation rule indirectly 
push push push bn synchronous communication periodic clocks statically known periodic clocks 
propose alternative construction presence absence data captured dynamically computed clocks 
memory code size linear buffer size appropriate practical implementation 
downside static properties process harder exhibit automated tools model checking interpretation particular hard prove code behaves fifo buffer tokens sent received 
node buffer push pop empty memo push fby memo empty push pop false pop true true fby empty 
synchronous buffer implementation buffer size called buffer written synchronous program inputs outputs 
boolean inputs push pop data empty outputs 
behavior internal memory empty equals internal memory 
memory set push true 
empty flag gives status internal memory 
pop occur memory empty buffer bypassed 
push occurs empty false 
conversely apop occurs memory emptied 
behavior programmed synchronous language 
gives implementation buffer strictly synchronous language 
buffers size constructed connecting sequence buffers shown 
complete figures notice boolean streams push pop need computed explicitely periodic words output input stream clocks 
safety guaranteed calculus periodic clocks synchronous implementation buffer absolutely required 
array random access memory head tail pointers correct construction soon satisfies size requirements 
correctness define judgment ct denote expression clock ct period environment clock environment original synchronous system 
result states lucid distribution manual available www lri fr lucid 

synchronous buffer pop push empty pop program accepted relaxed clock calculus translates equivalent synchronous program terms data flow streams 
equivalent program clock types 
theorem correctness 
period environment clock environment ct ct proof derives subtyping rule underlying judgments classical subtyping theory reduces global correctness proof local synchronism process composition translated program clock constraints 
guaranteed previous buffer insertion scheme buffer signature tailored resynchronization pair different synchronizable clocks 
ensures translated program synchronous 

synchrony asynchrony system single synchronous clock necessarily asynchronous numerous studies tackled relaxed multi clocked synchrony hardware software levels 
discuss closely related wide historical perspective 
number approaches specification design hybrid hardware software systems 
graphical tools process networks 
kahn process networks kpn fundamental models functional properties opposed structural properties 
kpn number tools yapi cosy project tools require expertise different domains universal language combines functional structural features single framework 
steps synchronous control asynchronous systems conducted domain synchronous programming languages le guernic polychrony 
targets automatic correct construction refinement programs spirit clock composition consider quantitative properties clocks 
streamit language high performance streaming computations tackles mainly stream level algebraic optimization issues 
ptolemy rich platform simulation analysis tools design embedded streaming systems synchronous data flow sdf model computation 
synchronous languages sdf graphs express bounded recursion arbitrary aperiodic execution 
explicitly clocked synchrony consequence local balance equations periodic execution schemes 
sdf model allows static scheduling convenient automatic derivation timing properties lack clocks weakens amenability formal reasoning correct construction generation synchronous code respect synchronous languages 
interestingly synchronizable clocks fill hole leading definition formal semantics sdf exposing precise static schedule programmer increased control buffer management code generation 
analyses correspondence models left 

perspectives proposed synchronous programming language implement correct construction high performance streaming applications 
model addresses automatic synthesis communications processes strictly synchronous 
model show latencies buffer requirements inferred automatically 
extend core data flow language notion periodic clocks relaxed clock calculus compose synchronous processes 
relaxed synchronous model defines formal semantics synchronous data flow graphs building long bridge synchronous languages 
clock calculus translation procedure relaxed synchronous strictly synchronous programs proven correct associated type inference proven complete 
implementation synchronous language lucid way applied classical video example 
believe widens scope synchronous programming safety critical reactive systems circuit synthesis promising increased safety productivity design optimization large spectrum applications 
acknowledgments partially funded french aci 
grateful anonymous reviewers careful reading deep remarks contributed improve final version 
contributed key ideas lead concept synchrony 
aiken wimmers 
type inclusion constraints type inference 
functional programming languages computer architecture pages 
benveniste caspi edwards halbwachs le guernic de simone 
synchronous languages twelve years 
proceedings ieee 
benveniste le guernic 
synchronous programming events relations signal language semantics 
sci 
comput 
program 
berry 
foundations esterel 
mit press 

brunel pasquier de kock 
cosy communication ip th design automation conference dac pages los angeles california june 
buck ha lee messerschmitt 
ptolemy framework simulating prototyping heterogenous systems 
int 
journal computer simulation 
caspi 
embedded control asynchrony synchrony back 
volume lncs lake tahoe october 
springer verlag 
caspi 
synchronous kahn networks 
icfp proceedings acm sigplan international conference functional programming pages 
acm press 
cohen feautrier genius 
application domain driven system design pervasive video processing 
ambient intelligence impact embedded system design pages 

globally asynchronous locally synchronous systems 
phd thesis stanford university october 
cohen plateau 
synchronization periodic clocks 
acm conf 
embedded software jersey city new york september 

cola girault 
higher order synchronous data flow language 
pisa italy september 

cola 
clocks class types 
rajeev alur lee editors volume lecture notes computer science pages 
springer 
de kock van der wolf brunel vissers 
yapi application modeling signal processing systems 
th design automation conference los angeles ca june 
acm press 
messerschmitt lee 
static scheduling synchronous data flow programs digital signal processing 
ieee trans 
computers 
goossens prakash ver niranjan 
interconnect memory organization socs advanced set top boxes tv evolution analysis trends 
hannu axel jantsch editors interconnect centric design advanced soc noc chapter pages 
kluwer april 
halbwachs caspi raymond pilaud :10.1.1.34.5059
synchronous dataflow programming language lustre 
proceedings ieee september 
kahn 
semantics simple language parallel programming 
rosenfeld editor information processing pages stockholm sweden aug 
north holland amsterdam 
le guernic 
talpin 
le 
polychrony system design 
journal circuits systems computers special issue application specific hardware design april 
leiserson saxe 
retiming synchronous circuitry 
algorithmica 
moonen van 
timing analysis model network multiprocessor systems 
proceedings th annual workshop circuits system signal processing pages pages netherlands november 
isbn 
pierce 
types programming languages 
mit press 
pottier 
simplifying subtyping constraints 
acm intl 
conf 
functional programming icfp volume pages 
amarasinghe 
streamit language streaming applications 
international conference compiler construction grenoble france april 
vuillemin 
circuits numbers 
ieee trans 
comput 
