structural symmetry breaking constraint satisfaction problems pierre justin pearson pascal van hentenryck magnus department information technology uppsala university box se uppsala sweden justin uu se department computer science brown university box providence ri usa pvh cs brown edu 
years symmetry breaking constraint satisfaction problems csps attracted considerable attention 
various general schemes proposed eliminate symmetries 
general schemes may take exponential space time eliminate symmetries 
identify classes csps encompass practical problems symmetry breaking various forms value variable interchangeability tractable dedicated search procedures 
show limits efficient symmetry breaking dominance detection schemes proving intractability results classes csps 
constraint satisfaction problems csps naturally exhibit symmetries 
symmetry breaking may drastically improve performance 
important contribution area development various general schemes symmetry breaking search csps described briefly section 
unfortunately general schemes may require exponential resources break symmetries 
schemes may require exponential space store nogoods generated symmetries may take exponential time discover partial assignment symmetric existing nogoods 
consequence practical applications place limits nogoods stored symmetries break 
eliminating symmetries re modelling problem see important approach break symmetries adding constraints search starts 
unfortunately general super exponential number constraints may needed break symmetries 
instance lex leader scheme adds constraint symmetry number symmetries authors names ordered swedish alphabet 
super exponential matrix fully interchangeable rows columns 

symmetries 
consequence practical applications add symmetry breaking constraints see 
approach symmetry breaking different orthogonal standpoint 
goal identify classes csps practically relevant symmetry breaking tractable polynomial time space dedicated search procedures 
identify classes csps feature various forms value variable interchangeability encompass practical problems 
symmetry breaking performed constant overhead respect time space node explored 
introduce new notions existential nogoods derive results csp classes 
believe notions helpful derive classes tractable symmetries 
viewed step fascinating area 
show limits efficient symmetry breaking schemes proving intractability results certain classes csps 
useful contrast approach research avenue pioneered freuder value interchangeability 
introduced various forms value interchangeability 
goal discover symmetries inside csps remove preprocessing reformulation 
unfortunately discovering symmetries csps tractable interesting classes csps 
contrast assumes symmetries csp known 
focuses exploit knowledge search break symmetries efficiently 
address companion issue automatically detect symmetries csp models 
example 
consider scene allocation problem featured 
aims producing movie series minimal cost deciding shoot scenes 
scene involves number actors scenes day shot 
actors scene day scene shot 
actors fees representing amount paid day spend studio 
optimal solution modelled assignment scenes days minimizes production costs 
exact days assigned scenes importance fully interchangeable 
important scenes clustered 
fact original problem formulation number say days 
necessary naming days modelling problem say induces symmetries 
approach aim discovering fact focuses exploit break symmetries induces 
theoretical unites extends published structured follows 
section define csps assignments sections epilogue corollary new section generalized 
originally omitted proofs propositions lemmas theorems provided proofs theorem corollary expanded greater detail 
non standard way gives rise elegant formulations proofs results 
sections formally establish results various forms value variable interchangeability 
section summarizes results concludes 
preliminaries definition constraint satisfaction problems csps captures informal meaning non standard simplifies proofs definitions considerably 
basic idea set constraints csp abstracted boolean function returns true constraints satisfied 
interested constraint structure 
solutions represented functions variables possible values 
definition csp assignment solution 
constraint satisfaction problem csp triplet denotes set variables denotes set possible values variables called domain bool constraint specifies assignments values variables solutions 
assignment csp function domain power set set called universe say csp set csp set variables call set assignment say csp scalar variables 
solution csp assignment true 
set solutions csp denoted sol 
algorithms solve csps manipulate partial assignments 
important reason variables assigned scope partial assignment set values assigned image partial assignment 
definition partial assignment scope image 
partial assignment csp function scope denoted scope image denoted image set scope 
value image denote set scope 
denote empty partial assignment 
note assignment solution csp partial assignment scope denote partial assignment conjunction equations see constraint vi scope vi vik 
vi vik vik example 
partial assignment represents function scope assigns value vi 
definition extension partial assignment 
partial assignment csp extension partial assignment scope scope scope 
definition completion partial assignment 
completion partial assignment csp extension scope set completions denoted comp 
note set completions solution singleton 
definition nogood 
nogood csp partial assignment extended solution comp sol 
idea noun nogood partial assignment extend previously identified nogood 
definition violating nogood 
partial assignment csp violates nogood extension 
verb violates justified view partial assignment nogood constraint form conjunction equations 
strictly speaking notion nogood violation redundant notion nogood extension keep intuitive appeal 
extension nogood nogood proposition 
partial assignment csp violates nogood nogood proof 
assume partial assignment violates nogood assume nogood exists completion sol 
completion extension transitivity completion 
nogood sol 
contradiction nogood 
furthermore partial assignment extended nogood nogood proposition 
csp dm 
partial assignment scope vi vik 
vik di nogood nogood proof 
assume nogood exists extension sol 
include vik di extension vik di vik di nogood exist 
nogood words nogoods lifted children parent search tree child nodes explored nogoods forgotten parent nogood needs kept 
respect symmetry considered definitions symmetry solution symmetries essentially bijections set variable value pairs assignments preserve solutions constraint symmetries bijections structure constraints problem 
shown group constraint symmetries csp subgroup strict group solution symmetries 
symmetries defined subgroups set solution symmetries constraint symmetries 
specific definitions particular symmetry considered respective parts 
structural symmetry breaking variable value symmetry start investigation showing exists efficient algorithm constraint satisfaction problems set values set variables partitioned subsets subset variables values respectively interchangeable 
call problems piecewise value variable interchangeable csps definition piecewise bijection 
ipi sets pi disjoint pi pj implies write pi call pi partition bijection piecewise bijection pi pi pi pi pi 
definition piecewise interchangeable csp 
csp vk dl piecewise interchangeable csp solution sol piecewise bijection vk piecewise bijection dl sol 
piecewise bijection vk dl identity csp piecewise value interchangeable 
show break symmetry piecewise interchangeable csps means symmetry breaking dominance detection 
technique break symmetries search 
idea follows choice point search check subtree rooted current node maps application symmetry subtree fully explored earlier 
current node need investigated pruned 
different ways control limit number previously expanded subtrees checked developed 
results core procedure code determines efficiency dominance detection algorithm checks partial set assignment dominated 
formally define definition dominating assignment 
vk dl piecewise interchangeable csp 
assignment dominates assignment exist piecewise bijections dl scope 
assignments piecewise interchangeable csp call problem determining dominates dominance detection problem 
consequently solve dominance detection problem efficiently break symmetries efficiently 
key idea tackle dominance detection problem piecewise interchangeable csps consists structural abstractions model csp need uniquely label value variable name 
course problematic certain variables certain values interchangeable 
rectify viewing variable value member symmetry class 
classes correspond directly sets dl 
assignments committed initial symmetries broken 
order check csp objects interchangeable need introduce subclasses original symmetry classes 
see detect remaining symmetries labelling subclasses appropriate signature defined set initial symmetries assignments 
see really signatures capture intuitive wish csp model hand actual structure problem 
signatures consider example 
example 
take variables domain 
assume variables interchangeable 
assume values interchangeable 
consider partial assignments see 
looking see 
value taken variables variable 
value taken variable variable 
value taken variable 
hand see fig 

part illustrates assignments 
part gives signatures value links pairs values assignment dominates designates solid lines perfect matching proves dominates 
value taken variables variables 
ii 
value taken variable variable 
iii 
value taken variable variable 
lining ii iii see structurally partial assignment extended words dominates see 
done small example model arbitrary names variables values actual structure problem 
talking specific variables values considered members classes 
specifically partial assignment implicitly assigned value signature captures members variable symmetry class taken 
instance value signature shorter writing signature sig 
hand signature sig 
consequently viewed specialized may say dominates 
terminology signature sig dominates 
note sig dominate 
general definition dominating value 
value partial assignment dominates value partial assignment belong value symmetry class sig sig 
value partial assignment structurally equivalent value partial assignment belong value symmetry class sig sig 
sub section show notions dominance structural equivalence exploited devise polynomial time algorithm solves dominance detection problem piecewise interchangeable csps 
dominance detection signatures lemma shows signature abstractions help detect dominance relations partial assignments lemma 
partial assignment dominates partial assignment piecewise interchangeable csp exists piecewise bijection dl dominates proof 
assume dominates 
exist piecewise bijections dl scope 
belong symmetry class sig sig values say dominates 
second assume exists piecewise bijection dl sig sig variable assigned value exists piecewise bijection scope 
dominates 
relation vectors defined usual component wise comparison yields called dominance ordering different lexicographic ordering 
consequently dominates exists perfect matching bipartite graph edges defined signature relation values see 
denote set duplicates values obtained appending prime sign names 
definition dominance detection graph 
partial assignments dominance detection graph ddg dominates denotes set arcs 
theorem 
dominance detection problem partial assignments piecewise interchangeable csp complexity mn time needed determine exists perfect matching ddg number values number variables 
value variable symmetries piecewise interchangeable csp broken polynomial time overhead node explored 
proof 
lemma clear dominance detection problem solved basically determining exists perfect bipartite matching ddg 
additional complexity denoted theorem due necessity constructing ddg 
achieved time nm proves symmetry breaking scenario tractable 
runtime improved complexity claimed sparse representations signatures 
writing entire signatures value hold sparse list contains non zero entries signature information variable partition entry sparse list belongs 
set sparse representation order variable instantiations partial assignment partition corresponding variable belongs 
done time linear number variables maximum number symmetry classes exist 
order scan partial assignments set sparse signatures 
iterate signatures values compare signatures values 
sparse representation signatures takes time 
interestingly shown bipartite graph viewed dominance detection graph csp assignments determined time linear size graph 
perfect bipartite matching exists dominates dominance detection problem hard bipartite matching 
words show dominance detection takes time mn 
provided static counterpart considered dynamic structural symmetry breaking piecewise interchangeable csps exploited concept signature devise set symmetry breaking constraints break considered symmetries 
theorem trivially interesting consequences 
dropping assumed piecewise value interchangeability tightening assumed piecewise full worsen tractability result symmetries fully piecewise variable interchangeable csps fully value variable interchangeable csps broken polynomial time overhead node explored 
conversely dropping assumed piecewise variable interchangeability achieve tractability symmetries fully piecewise value interchangeable csps 
study special cases devise highly efficient symmetry breaking methods require complex matchings solved minimize computational overhead needed symmetry breaking special cases 
second dropping assumed piecewise value interchangeability switching set csps worsen tractability result 
set variables take subsets universe non interchangeable values seen scalar variables take scalar values domain non interchangeable values tractability results symmetry breaking fully piecewise variable interchangeability scalar csps symmetries fully piecewise variable interchangeable set csps broken polynomial time overhead node explored 
symmetry filtering theorem break symmetries piecewise interchangeable csp polynomial time symmetry breaking dominance detection approach 
annoying setting check choice point see dominated previously expanded touch garbage order see garbage 
develop algorithm suffer disadvantage 
achieve goal dominance detection filtering just pruning 
brute force approach try assignments dominance detection algorithm perform filtering 
procedure lead poor runtime 
show filtering symmetry performed efficiently 
exists natural distinction types filtering apply consists making sure newly created children symmetric node fully expanded node currently branching 
applying unary branching constraints assume achieved shrinking domains variables accordingly 
fundamentally different type filtering consists creation children symmetric 
types need addressed achieve symmetry free search tree corresponds filtering refer idea domain reduction constraint programming pruning refer detection sufficient reason backtracking 
ge trees 
distinguish types filtering naming differently symmetric ancestor filtering symmetric sibling filtering 
symmetric ancestor filtering goal symmetric ancestor filtering shrink domains instantiating variable domain values result creation search node symmetric previously expanded 
definition ancestor symmetry resistance 
depth search tree say choice point associated partial assignment captures previously committed unary branching decisions ancestor symmetry resistant previously fully expanded nodes called ancestor variables values dom dominate 
assume currently investigating choice point ancestor node dominate 
observe instantiating variable setting dl change signature sig sig ek ek denotes unit vector kth component 
set 
ddg ddg differ bipartite graph may contain additional edges incident right partition 
contains matching matching contain exactly additional edges 
consequently dominates contain matching 
case needs done ancestor symmetry resistant respect 
assume contains matching 
provided matching straightforward matching theory identify efficiently additional edges allow transform existing matching perfect matching theory refer matching viewed flow network closely corresponds bipartite graph 
consider usual residual network respect flow additional source node connects nodes partition sink node connected nodes second partition 
capacities residual network residual capacity edges flow routed including reverse edges edges positive flow 
maximum matching corresponding maximum flow defines cuts 
nodes reachable source residual network 
denote set cut 
second cut set nodes sink reachable residual network 
denote set cut 
note cuts computed time linear size networks maximum matching computed 
core observation cuts critical edges exactly run clearly adding edge yields improving path residual network matching 
hand note edge added leave cut untouched proves edge improve matching 
edges run follow analogously 
critical edges added allow construct matching ones need consider run nodes dl exists sig sig ek 
find pair nodes single extra assignment added result successful dominance detection 
precisely assignment previously unassigned variable result dominated choice point 
remove domain unassigned keep unique parts search space produce choice points symmetric expanded previously 
theorem runtime needed initial value matching algorithm bounded mn 
entire filtering algorithm runs time mn 
ancestor nodes need considered prove theorem theorem 
piecewise interchangeable csp achieve resistance search node time nm 
symmetric sibling filtering achieve full symmetry prevention need guarantee newly created siblings symmetric 
choosing variable assigned branching need perform filtering step implicit pruning step choose single representative value equivalence class values assigned chosen variable result creation symmetric choice points 
due fact sibling dominates structurally equivalent see definition avoid producing symmetric siblings choosing exactly representative value structurally equivalent 
complexity filtering step dominated symmetric ancestor filtering 
putting ancestor sibling filtering completed development effective symmetry breaking algorithm piecewise interchangeable csps runs polynomial time 
note practical performance algorithms sketched enhanced practice example fully sufficient check previously expanded nodes maximum matching variable instantiations different values committed 
usual considering incremental updates matchings memory traded cpu time 
fast algorithms break value symmetry section review special case piecewise interchangeable csps variable symmetry call piecewise value interchangeable csps 
previous results know symmetry breaking achieved polynomial time 
focus development algorithms break value symmetry minimal overhead 
section describe new approach full detail class fully value interchangeable csps showing leads known result value symmetries broken dedicated search procedure constant overhead respect time space node explored theorem 
section show result generalises piecewise value interchangeable csps theorem 
section show full detail result holds fully piecewise value interchangeable set csps theorems respectively 
fully value interchangeable csps values interchangeable variable symmetry speak fully value interchangeable csp 
definition fully value interchangeable csp 
csp fully value interchangeable csp solution sol bijection sol 
show case symmetry breaking performed constant overhead respect time space node explored 
method nogoods 
theorem gives fundamental characterization nogoods fully value interchangeable csps 
states nogoods preserved value interchanges theorem 
nogood fully value interchangeable bijection 
nogood proof 
completion assume sol 
bijection sol 
scope definition completion extended solution 
contradicts fact nogood 
extended solution nogood 
closure nogood fully value interchangeable csp set nogoods obtained applying possible value interchange value symmetry definition closure nogood 
nogood fully closure denoted closure set bijection 
main idea approach try closures nogoods representation takes polynomial space membership closure tested search polynomial time 
partial evaluation possible write search procedure breaks value symmetries extending member closures nogoods generated search 
existential nogoods nogoods 
show closure nogood fully value interchangeable csp characterized compactly 
introduce concept existential nogood simplifies proofs intuitions 
nogood generalized introducing distinct existentially quantified variables value image 
seen inverse skolemization 
definition existential nogood 
nogood fully image dk 
existential nogood denoted set functions scope satisfying condition ek vj di vj ei ek holds ai different values 
abuse language identify existential nogood set functions condition members satisfy 
example 
consider nogood written conjunction equations existential nogood condition precisely set functions scope satisfying condition 
lemma indicates existential nogood precisely captures closure nogood lemma 
nogood fully value interchangeable csp closure 
proof 
image dk 
definition image vj di vj di dk 
show closure 
closure 
means exists bijection 
satisfies vj di vj di dk definition bijection 
show closure 

exist values ak vj di vj ai ak 
ak different exists bijection satisfying di ai 
rewritten closure 
obvious membership existential nogood tested efficiently involves existential quantification 
due nature underlying conditions possible eliminate existential variables equating universally quantified variables value selecting condition representative variable set di 
precisely motivation concept nogoods defined definition nogood 
nogood fully image dk di nogood respect denoted set functions scope satisfying condition vj di vj vr 
abuse language identify nogood set functions condition members satisfy 
example 
existential nogood example variables eliminated produce nogood condition precisely set functions scope satisfying condition 
lemma indicates nogood precisely captures existential nogood lemma 
nogood fully value interchangeable csp 
proof 
image dk 
show 

exist values ak vj di vj ai ak 
show satisfies formula vj di vj vr di ak different exists bijection satisfying di ai 
written 
di ai 
show 

means vj di vj vr di show exist values ak vj di vj ai ak 
vr different may pick choice ai 

simplicity denote nogood condition terms global condition vj vj di vr holds ai value 
example 
nogood example rewritten testing violation nogoods 
show membership closure nogood tested linear time 
lemma 
nogood fully value interchangeable csp partial assignment exists linear time algorithm test violates nogood closure 
proof 
direct consequence lemmas fact size nogood condition linear 
suffices test satisfies nogood condition scope scope 
lemma 
fully value interchangeable csp dm 
partial assignment scope vi vik 
vik di nogood 
nogood 
partial assignment violates nogood closure violates nogood closure 
proof 
result follows proposition holds csps general 
closure bijection extends follows closure violates violates 
result 
maintaining nogoods 
lemma indicates nogoods needed current frontier nodes search tree closed nodes parents open 
child nodes explored nogood parent node subsumes nogoods child nodes 
maintaining nogood takes space set frontier nodes 
formalize result variable decomposition trees 
definition variable decomposition tree 
variable decomposition tree csp search tree nodes represent partial nodes decomposed follows node representing partial assignment scope vi vik child nodes represent partial assignments vik di di variable scope 
vik note variable decomposition trees capture static dynamic variable orderings variety search strategies depth search search 
theorem 
fully value interchangeable csp set frontier nodes variable decomposition tree 
value symmetry breaking requires space storing nogoods 

testing partial assignment violates nogood takes time worst case 
proof 
result follows fact size nogood linear 
result follows result lemma 
simplification 
result strengthened considerably partial evaluation structure nogoods 
show search procedures exploring variable decomposition tree fully csp remove value symmetries causing constant overhead respect time space node explored 
presenting theoretical results illustrate idea example depth search 
basic intuition comes structure nogoods 
example 
consider partial assignment assume depth search tries label variable set possible values 
failure produces nogood 
remain instantiated value tried nogood part branch partially evaluates imposing labelled value different 
failures produce similar nogoods values 
consider values observe happens failed labelling value say 
nogood partially evaluates 
disjunction partially evaluated nogoods obtained far condition satisfied labelling 
follows need labelled previously values exactly new value 
words variable decomposition tree child nodes partial assignment need explored label variable vik value image exactly value 
note result independent set constraints 
essence labelling procedure graph coloring scene allocation problem 
procedure breaks value symmetries fully value interchangeable csps formalized procedure 
uses function failure returns false extension partial assignment solution csp words satisfies property failure comp 
prove correctness related search procedures useful introduce concept compact variable decomposition tree definition compact variable decomposition tree 
compact variable decomposition tree fully value interchangeable csp search tree nodes represent partial assignments nodes decomposed follows node representing partial assignment scope vi vik child nodes represent partial assignments vik image partial assignment vik dn dn image image empty variable vik scope 
compact variable decomposition trees complete lemma 
set assignments compact variable decomposition tree fully value interchangeable csp closure bijection equal sol 
proof 
follows directly examination nogoods 
bool return bool scope return select scope image select forall failure return true return false fig 

labeling procedure fully value interchangeable csps compact variable decomposition tree extends nogood generated search lemma 
compact variable decomposition tree fully csp partial assignment node extends nogood generated exploration possibly generates 
proof 
lemma suffices show partial assignment extends nogood generated siblings siblings ancestors tree 
proof induction depth tree 
depth result follows inspections nogood discussed earlier 
consider depth dp dp nogood generated left right branches depth 
restrict attention projection variables instantiated depth restrict attention scope satisfying scope 
show closure 
variable assigned depth dp observe exists partial assignment 
definition compact variable decomposition tree values belong image image 
consider case image 
means exist vi vj scope vi vj vj vi 
closure rewritten bijection vi impossible 
assume image follows vi vi scope 
closure bijection 
vi impossible 
assume image vi vi scope 
closure bijection impossible vi vi scope 
establish correctness procedure theorem 
procedure breaks value symmetries fully value interchangeable csp constant overhead respect time space node explored extends member closure nogood generated search 
proof 
result follows directly lemmas 
search strategies limited discrepancy search adapted remove value symmetries fully value interchangeable csps constant overhead respect time space node explored 
experimental results known labelling procedure reported 
piecewise value interchangeable csps derive generalizations piecewise value interchangeable csps previous results 
definition piecewise value interchangeable csp 
csp dl piecewise value interchangeable csp solution sol piecewise bijection dl sol 
example 
scene allocation see example imagine version problem days divided morning afternoon sessions 
actors probably strong preferences different fees sessions day session may matter 
state main definitions theorems derivation similar fully value interchangeable csps 
definition closure nogood 
nogood piecewise value interchangeable csp dl closure denoted closure set piecewise bijection dl 
define nogoods piecewise value interchangeable csps 
key intuition separate values dl 
definition nogood 
nogood piecewise csp dl 
image ds ss dli dl dl sl nogood respect denoted bool return bool dl scope return select scope forall 
image dl forall 
dl select dl forall failure dl dl return true return false fig 

labelling procedure piecewise value interchangeable csps set functions scope dl satisfying condition sl vj vj dl sl vj dl vj dl rl sl depicts labelling procedure piecewise csps 
generalizes considering assigned values sets dl new value set procedure obtained partition part 
correctness proof similar theorem 
theorem 
procedure breaks value symmetries piecewise value interchangeable csp constant overhead respect time space node explored 
experimental results reported partitioned graph coloring 
piecewise value interchangeable set csps show symmetry breaking piecewise value interchangeable set csps tractable 
finite set denote set subsets definition piecewise set bijection 
pi partitioned set 
bijection piecewise set bijection pi induced piecewise bijection pi 
definition piecewise value interchangeable set csp 
set csp dl piecewise value interchangeable set csp solution sol piecewise set bijection dl sol 
establish definitions results full detail fully set csps results generalize piecewise case 
definition set bijection 
bijection set bijection ei ei bijection 
say induced definition fully value interchangeable set csp 
set csp fully value interchangeable set csp solution sol set bijection sol 
get impression problems interest consider example 
example 
set elements called varieties 
balanced incomplete block design bibd multi set subsets called blocks size constraint pair distinct varieties occurs exactly blocks constraint implied constraints variety occurs number blocks constraint bk vr bibd parameterized tuple parameters independent 
originally intended design statistical experiments bibds applications cryptography 
note varieties blocks fully interchangeable 
finding bibd means finding fixed number size subsets fully interchangeable set find subsets size set dually find subsets size set subject constraint 
definition closure nogood 
nogood fully interchangeable set csp closure denoted closure set set bijection 
existential nogoods nogoods 
define existential nogoods fully value interchangeable set csps showing intuition example 
take mentioned modelling approach finding subsets size set simplicity tackle full interchangeability blocks 
come back full interchangeability varieties just example 
consider bibd solution modulo symmetries want find subsets vi size universe giving blocks variety belongs block mentioned subsets subsets intersection size 
consider consistent partial assignment assume nogood backtracking 
existential nogood set partial assignments satisfying condition 
condition rewritten follows 
note values indistinguishable ones appear set 
similarly value indistinguishable value value appears second third sets 
formally definition indistinguishable values cluster 
values indistinguishable partial assignment denoted scope 
clusters values appear indistinguishable equivalence classes 
example clusters 
condition existential nogood rewritten follows existentially quantified cluster variables partition partition holds elements pi set list non empty mutually disjoint union set ni elements respectively ni elements integer list note cluster size conditions necessary general implied example 
values appear set values variables scope formed cluster 
consider domain elements partial assignment set variables size elements common disjoint 
size 
definition signature cluster 
signature cluster relative partial assignment denoted sig list indices variables vi set value subset sig vi scope vi 
instance sig subset 
signatures clusters relative respectively 
eliminating existentially quantified variables indices signatures clusters include exclude leads condition nogood partition order clusters 
values appear set values variables scope cluster empty list signature equal intersection empty collection sets drawn show closure nogood fully value interchangeable set csp characterized compactly membership closure nogood tested polynomial time case 
define concept existential nogood 
definition existential nogood 
nogood fully set csp cm equivalence classes universe nm respective sizes 
set indices variables scope 
ji set indices clusters vi 
existential nogood denoted set functions scope satisfying condition cm partition cm nm vi ji cj lemma indicates existential nogood precisely captures closure nogood lemma 
nogood fully value interchangeable set csp closure 
proof 
show closure 
member closure 
definition closure exists set bijection 
satisfies exists set cm equivalence classes universe satisfies existential formula 
set bijection takes cm cm witnesses satisfy 

show closure 

equivalence classes cm witnesses satisfy 
suppose equivalence classes sizes ci equal ci partition exists set bijection ci rewritten closure 
obvious membership existential nogood tested efficiently involves existential quantification 
due nature underlying conditions possible eliminate existential variables obtain nogood defined definition nogood 
nogood fully set csp set indices variables scope 
list equivalence classes universe list respective sizes 
nogood respect denoted set functions scope satisfying condition partition sig vj sig vj lemma indicates nogood precisely captures existential nogood lemma 
nogood fully value interchangeable set csp 
proof 
follows definition nogood fact expression vj vj sig sig captures exactly ci existential nogood 
maintaining nogoods simplification 
consider depth search instance see happens assignment undone making nogood 
definition clusters search procedure treat elements cluster indistinguishable 
imposing ordering elements cluster idea select th element cluster st element cluster selected member subset variable 
depicts labelling procedure fully set csps 
uses function failure returns bool return bool scope return select scope true update return return false bool set 
em return true head failure tail 
em true return true 
em true return true return false fig 

labelling procedure fully value interchangeable set csps false extension partial assignment solution words satisfies property failure comp 
procedure uses procedure update returns equivalence classes clusters definition compact set variable decomposition tree 
compact set variable decomposition tree fully value interchangeable set csp search tree nodes represents partial assignments pand nodes decomposed follows node representing partial assignment scope vi vik set equivalence classes universe child nodes represent partial assignment vik si conditions hold si sj si sj si sj si sj condition says sets number elements equivalence class elements second condition condition forces elements equivalence class picked certain order 
compact set variable decomposition trees complete lemma 
set assignments compact set variable decomposition tree fully value interchangeable set csp closure set bijection equal sol 
proof 
follows directly examination nogoods fact node representing partial assignment deeper node representing partial assignment set equivalence classes universe refinement set equivalence classes 
compact set variable decomposition tree extends nogood generated search 
lemma 
compact set variable decomposition tree fully set csp partial assignment node extends nogood generated exploration possibly generates 
proof 
main structure proof lemma similar lemma 
partial assignment show belong closure partial assignment lower depth 
suffices restrict restricted scope scope scope scope theta 
suffices show closure 
observe exists partial assignment 
definition compact set variable decomposition tree sets equivalence classes universe different refinement closure 
theorem 
procedure breaks value symmetries fully value interchangeable set csp constant overhead respect time space node explored 
proof 
result follows lemmas 
procedure performs called canonical labelling 
shown canonically labelling dimension matrix variables amounts lexicographically ordering flattening dimensions matrix 
experimental results reported 
theorem generalizes piecewise value interchangeable set csps theorem 
value symmetries piecewise value interchangeable set csp broken constant overhead respect time space node explored 
example 
reconsider bibds 
having set variables size pairwise intersections size block mentioned times matrix zero variables ones row ones column scalar products pair distinct rows 
lex chain global constraint sicstus prolog deployed lexicographically order rows matrix breaks symmetries labelling procedure set variables 
unfortunately global constraint efficient able filter domains labelling filtering 
return full interchangeability varieties 
breaking extra 
symmetries time hard compose 
block symmetries 

symmetries 
lexicographically ordering rows columns mentioned matrix zero variables break symmetries gives reasonable performance due constraint 
leads issue suitable nogood formulated tractable labelling procedure derived 
case sufficient store nogoods frontier nodes search tree nogoods stored higher search tree 
testing partial assignment extends nogood np complete 
see consider bibd blocks size nogood thought graph block specifying edge 
testing partial assignment closure nogood equivalent subgraph isomorphism np complete 
formal proof result section 
limits efficient symmetry breaking dealt cases symmetry broken efficiently 
particularly shown piecewise variable value symmetries broken efficiently extremely low overhead algorithms breaking value symmetry 
unfortunately see section limits efficient symmetry breaking 
consider set csps interchangeable variables values definition piecewise interchangeable set csp 
set csp piecewise interchangeable set csp solution sol piecewise bijection vk piecewise set bijection dl sol 
trying break symmetry piecewise interchangeable set csps means need solve dominance detection problem efficiently 
vk dl definition dominating set assignment 
piecewise interchangeable set csp 
set assignment dominates set assignment exist piecewise bijection piecewise set bijection dl scope 
vk dl show solving problem np hard proving able break piecewise symmetry set csps efficiently 
precisely reduce corresponding dominance detection problem subgraph isomorphism 
achieve desired reduction construct set assignment graph way definition set assignment 
undirected graph create set interchangeable values nc set interchangeable variables pij 
set assignment defined pij ni nj 
theorem 
undirected graphs sub isomorphic dominates variables values considered interchangeable 
proof 
start showing dominates sub isomorphic 
bijective implies 
pij scope pij ni nj 
dominates assume dominates exist functions pij scope pij ni nj pa nb nb 
construction equivalent nb nb sub isomorphism 
theorem possible prove corollary corollary 
dominance detection problem piecewise interchangeable set csps np hard 
proof 
reduce problem subgraph isomorphism 
order apply theorem need ensure graphs operate set nodes 
sets nodes graphs differ possible see sub isomorphic contains nodes 
contains fewer nodes possible see add isolated nodes affecting subgraph isomorphism 
graphs contain number nodes relabeling nodes graphs may assume graphs operate set nodes 
note despite negative result important special cases dominance detection problem piecewise interchangeable set csps tractable 
example set variables take overlapping sets values algorithm developed section adapted exchanging roles values variables break symmetries efficiently 
corollary theorem corollary 
dominance detection problem piecewise interchangeable set csps tractable non overlapping sets 
note dominance detection problem consider regards arbitrary partial assignments 
implies detection problem tractable break symmetries efficiently 
situation changes achieve intractability result previous 
methods partial assignments need compared differ specific fashion 
show specific dominance detection problems np hard proving general form incapable breaking symmetries piecewise interchangeable set csps efficiently 
specific dominance detection problems considers differ general dominance detection problem fact partial assignments compared arbitrary 
know exists exactly assignment dom partial assignments 
prove dominance detection limited problem nphard idea time consider complete subgraphs reduce clique problem arbitrary subgraph isomorphism 
graph value assignment complete graph size defined accordance definition 
second assignment additional disconnected component complete graph size just edge missing 
setting second assignments structural relationship assignments need compared 
graph contains clique size assignment dominates second 
consequently piecewise interchangeable set csps capable breaking symmetries efficiently 
final note negative result stress imply symmetry breaking np hard general consider methods adaptation branching scheme 
generalizations wreath value interchangeability far focussed piecewise symmetry 
section generalize tractability results complex class csps variable assigned pair values domain 
values interchangeable fixed value values interchangeable 
problems called wreath csps symmetry group corresponds wreath product groups 
problems arise naturally variety applications resource allocation scheduling 
example 
consider problem scheduling meeting different groups meet day week room subject constraints 
days fully interchangeable day rooms fully interchangeable 
wreath value interchangeable csps formally define class csps 
definitions results consider sets fully interchangeable values simplicity 
generalized arbitrary fixed number sets sets piecewise interchangeable values 
definition wreath bijection 
cartesian product 
bijection wreath bijection bijection bijection 
definition wreath value interchangeable csp 
csp wreath value interchangeable csp solution sol wreath bijection sol 
wreath value interchangeable csp value domain assigned variable values fully interchangeable fixed value values fully interchangeable 
devise highly efficient symmetry breaking algorithm wreath value interchangeable csps 
notations 
pair 
set tuples denotes set filter di denotes set di 
assignment denotes set 
definition closure nogood 
nogood wreath csp closure denoted closure set wreath bijection 
define relevant nogoods 
definition nogood 
nogood wreath csp image dk filter image di li di di dj li 
nogood respect denoted set functions bool return bool scope return select scope image select forall filter image select forall failure return true return false fig 

labelling procedure wreath value interchangeable csps scope satisfying condition vj vj di vr vj vj lk vj vj dk lk depicts labelling wreath value interchangeable csps 
correctness proof similar theorem 
theorem 
breaks value symmetries wreath value interchangeable csp constant overhead respect time space node explored 
wreath value interchangeable set csps show symmetry breaking wreath value interchangeable set csps tractable 
definition wreath set bijection 
cartesian product 
bijection wreath set bijection induced wreath bijection 
definition wreath value interchangeable set csp 
set csp wreath value interchangeable set csp solution sol wreath set bijection sol 
consider example 
example 
take set set variables universe set csp wreath value interchangeable constraint set arbitrary 
suppose tried partial assignment investigate partial assignment 
decide symmetric variant 
way construct permutation corresponding permutations sets transformed 
order construct permutation assess mapped 
mapped matter permute 
algorithmically infer checking number tuples starting number tuples starting assigned set variables 
important tuples 
means tuples matches number respective tuples 
respective tuples tuples 
hand tuples starting shows mapped 
investigate mapped 
check numbers tuples match 
tuples starting tuples starting 
tuples starting tuples starting 
initial check setting inconclusive 
check fully construct permutation need find exists permutation respective tuple sets map exactly just number 
need construct permutation need show permutation exists 
equations pose constraints permutation trying construct 
fig 

part gives bipartite graph constructed assess mapped 
part shows bipartite graph constructed find feasible permutation show exists 
fortunately constructing proving permutation exists done solving maximum matching problem bipartite graph 
node set defined union sets copies ei 
define edge set accordance constraints add edge ei ei ej allowed 
perfect matching exists exists permutation satisfies equations 
see maximum matching consequently permutation exists shows potentially set 
continue check setting possible 
find mappings construct corresponding legal permutation 
equipped knowledge try construct ensure 
idea check permutation exists solving maximum matching problem bipartite graph see 
perfect matching exists proof assignment symmetric 
hand construction failed permutation corresponding permutations existed 
generally state theorem 
value symmetries wreath value interchangeable set csp broken polynomial time overhead node explored 
proof 
pure cases value symmetry need check search nodes previously expanded siblings 
show dominance check performed abstracting concrete example 
potential mappings set variables vi assigned values check number tuples set vi starting matches number tuples set vi starting case note setting feasible 
set bipartite graph gd nd ed nd consists possible second tuple entries copies edge element ed set variables vi assigned values vi vi vi 
note feasible exists perfect matching gd set bipartite graph consists possible tuple entries copies edge element feasible 
report dominated exists perfect matching method constructs permutations prove dominance shows permutation exists 
denotes number possible tuple entries number possible second tuple entries algorithm implemented run time 
note dominance checker outlined proof generalized tuples entries 
run time exponential leave open efficient labelling algorithm formulated break type value symmetry 
point show wreath value symmetry allows tractable symmetry breaking set csps 
theoretically studied classes csps symmetry breaking tractable 
csp classes encompass practical problems feature various forms value variable interchangeability allow symmetry breaking performed polynomial constant overhead respect time space node explored dedicated search procedures 
unfortunately efficient symmetry breaking dominance detection schemes limits identified csp classes dominance detection intractable 
table summarizes main results thm means breaking symmetries mentioned corresponding row feasible polynomial overhead respect time space node explored corresponding set csp column proved theorem positive tractability results ones marked thm trivially derivable consequences theorem specialized labeling procedures particular csp classes 
negative tractability results marked np hard cor 
referring corollary concern dominance detection schemes remains open research issue schemes break symmetries polynomial time 
proved value symmetries csp polynomial time tractable proved group theoretic notions resulting complexities order low degree polynomial general efficient specialized algorithms 
key component proofs notion minimal ge tree essentially search tree results search procedure breaks symmetry 
compact symmetry csps set csps fully value interchangeable thm thm fully variable interchangeable thm thm fully value variable interchangeable thm np hard cor 
piecewise value interchangeable thm thm piecewise variable interchangeable thm thm piecewise value variable interchangeable thm np hard cor 
wreath value interchangeable thm thm table 
tractability symmetry breaking dominance detection set variable decomposition trees see definitions ge trees fact search procedures produce ge trees 
directions research 
particular interest study tractable classes csps exhibiting variable symmetries variable set complex structure partitions studied 
particular variable set obtained cartesian product index sets get known matrix model 
interesting forms interchangeability matrix models full piecewise wreath interchangeability matrix slices rows columns 

forms variable interchangeability including compositions various forms value interchangeability tractability results symmetry breaking missing finding effective search procedures challenging problem 
corollary shown negative tractability results call identification special cases symmetry breaking tractable 
authors partly supported institutional ig swedish foundation international cooperation research higher education 
pierre sabbatical university istanbul turkey 
sweden authors supported vr swedish research council part 
supported national science foundation career project nsf award number 
pascal van hentenryck partly supported nsf itr award dmi 

ahuja orlin 
network flows 
prentice hall 


excluding symmetries constraint search 
jaffar editor proceedings cp volume lncs pages 
springer verlag 


solving problem seconds 
van hentenryck editor proceedings cp volume lncs pages 
springer verlag 

cameron 
permutation groups 
number london mathematical society student texts 
cambridge university press 

carlsson 
arc consistency chain lexicographic ordering constraints 
technical report swedish institute computer science 

cohen jeavons jefferson petrie smith 
symmetry definitions constraint satisfaction problems 
van beek editor proceedings cp volume lncs pages 
springer verlag 

editors 
crc handbook combinatorial designs 
crc press 

crawford ginsberg luks roy 
symmetry breaking predicates search problems 
aiello doyle shapiro editors proceedings kr pages 
morgan kaufmann 

fahle 
symmetry breaking 
walsh editor proceedings cp volume lncs pages 
springer verlag 

frisch miguel pearson walsh 
symmetry matrix models 
pearson editors proceedings 
available www uu se research group 

frisch miguel pearson walsh 
breaking row column symmetries matrix models 
van hentenryck editor proceedings cp volume lncs pages 
springer verlag 

pearson van hentenryck 
static dynamic structural symmetry breaking 
benhamou editor proceedings cp volume lncs pages 
springer verlag 

milano 
global cut framework removing symmetries 
walsh editor proceedings cp volume lncs pages 
springer verlag 

freuder 
eliminating interchangeable values constraint satisfaction problems 
proceedings aaai pages 

gent smith 
symmetry breaking search constraint programming 
proceedings ecai pages 


generalized implicit enumeration algorithm graph coloring 
cacm 

meseguer 
exploiting symmetries constraint satisfaction search 
artificial intelligence 

pearson 
comma free codes 
van beek editor proceedings ai 
available rutgers edu 


puget 
satisfiability symmetrical constrained satisfaction problems 
komorowski ra editors proceedings ismis volume lnai pages 
springer verlag 


puget 
symmetry breaking revisited 
van hentenryck editor proceedings cp volume lncs pages 
springer verlag 

gent kelsey linton 
tractable symmetry breaking restricted search trees 
de saitta editors proceedings ecai pages 
ios press 

van hentenryck 
structural symmetry breaking 
proceedings ijcai pages 
ijcai 


generating effective symmetry breaking predicates search problems 
electronic notes discrete mathematics 
proceedings sat 

smith 
reducing symmetry combinatorial design problem 
wallace editors proceedings cp ai 

smith hubbard williams 
progressive party problem integer linear programming constraint programming compared 
constraints 

van hentenryck 
constraint integer programming opl 
informs journal computing 

van hentenryck pearson 
tractable symmetry breaking csps interchangeable values 
proceedings ijcai pages 
morgan kaufmann 

van hentenryck pearson 
compositional derivation symmetries constraint satisfaction 

zucker saitta editors proceedings sara volume lnai pages 
springer verlag 

