computationally sound symbolic secrecy presence hash functions cortier steve kremer ralf sters bogdan warinschi loria cnrs inria project nancy france lsv cnrs ens cachan inria project france christian universit zu kiel germany 
standard symbolic deducibility notions secrecy general insufficient cryptographic point view especially presence hash functions 
devise motivate appropriate secrecy criterion exactly captures standard cryptographic notion secrecy protocols involving public key hash functions protocols satisfy computationally secure violation criterion directly leads attack 
furthermore prove criterion decidable np decision procedure 
results hold standard security notions encryption hash functions modeled random oracles 
distinct kinds models developed rigorous design analysis cryptographic protocols called dolev yao symbolic formal models hand cryptographic computational concrete models hand 
symbolic models messages considered formal terms adversary manipulate terms fixed set operations 
main advantage symbolic approach relative simplicity amenable automated analysis tools see 
cryptographic models messages actual bit strings adversary arbitrary probabilistic polynomial time ppt turing machine 
proofs kind models yield strong security guarantees proofs quite involved rarely suitable automation see 
starting seminal abadi rogaway significant amount research directed bridging gap approaches 
goal obtain best worlds simple automated security proofs entail strong security guarantees 
typical approach show executions computational adversaries correspond executions symbolic adversaries result show translate security notions symbolic world computational world 
security notions integrity authentication derivation computational guarantees symbolic ones done relative simplicity 
contrast analogous results basic notion secrecy proved significantly elusive appeared 
apparent reason situation striking difference definitional ideas different models 
symbolic secrecy typically states adversary deduce entire secret messages gathers execution 
hand computational secrecy requires secret partial information leaked adversary 
typical formulation requires adversary distinguish secret completely unrelated alternative 
contributions 
investigate soundness results symbolic secrecy presence hash functions 
main motivations considering hash functions considered aforementioned results new challenge linking symbolic cryptographic secrecy ciphertexts hashes publicly verifiable third party verify value hash value corresponding message implies simple minded extension previous results symbolic computational secrecy fails 
assume example protocol hash secret sent clear network 
virtually symbolic models conclude remains secret naive assumption practice trivial attack works computational models compare recover similar verifiability properties occur settings digital signatures reveal message signed 
propose new symbolic definition nonce secrecy protocols party identities nonces hash functions public key encryption 
definition give intuitively appealing concept patterns 
central aspect criterion captures precisely security computational world sense sound complete 
specifically nonces secret symbolic criterion secret standard computational definition 
furthermore exist successful attacks secrecy nonce satisfy definition 
theorems hold protocols implemented encryption schemes satisfy standard notions security hash functions modeled random oracles 
proofs combine different techniques cryptography direct non trivial extension mapping theorem hash functions 
second important result prove decidability symbolic secrecy criterion bounded number sessions 
crucial result enables automatic verification computational secrecy nonces 
give np decision procedure constraint solving technique suitable practical implementations 
constraint solving technique standard automatic protocol analysis adapt symbolic secrecy criterion standard deducibility secrecy definition suffices transform constraint systems obtains called simple form 
symbolic secrecy criterion transformations required order procedure complete 
identifying sufficient set transformations proving sufficient turned non trivial 
related 
papers immediately related cortier warinschi backes pfitzmann canetti herzog exception hash functions allowed randomness extractors :10.1.1.117.6018
study computationally sound secrecy properties 
context tackle computationally sound secrecy presence hashes 
study translation symbolic secrecy computational version setting closely related :10.1.1.117.6018
hashes requires explained new notions non trivial extensions results proved 
concerned secrecy properties key exchange protocols context simulation security study different computational settings 
interestingly symbolic criterion formalized patterns unrelated 
mentioned works considers decidability issues 
outline 
section introduce symbolic computational models 
symbolic secrecy criterion developed section 
state prove soundness completeness criterion computational secrecy section prove decidability section 
symbolic concrete protocol intruder models section introduce symbolic concrete protocol intruder models see appendix details 
symbolic model define symbolic messages terms honest agents dolev yao style intruder derive messages set messages protocols specified 
messages terms 
define messages consider infinite set agent identities infinite sets randadv nonces random coins generated agents adversary respectively infinite set garbage representing garbage messages 
sets assumed pairwise disjoint 
set nonce rand randadv 
set messages nonce rand defined grammar nonce ek dk rand ek garbage ek dk denote public private key respectively denotes pairing ek denotes message encrypted ek random coins hash define subsets ciphertext hash pair sets messages starting ek dk respectively 
refer sets introduced types 
assume infinite set typed variables types variable certain type messages type may substituted 
particular assume variables ai 
agent identities variables ai fresh nonces generated ai 
set terms defined analogously set messages 
deriving messages denote set terms 
set terms derived defined deduction rules 
write rand say ek ek ek rand dk fig 

deduction rules mi derived randomness rand rand 
example dk ek randadv ek randadv 
protocols 
roles usually specified sequence input output actions 
order model branching protocols roles consider ordered edge labeled finite trees edge labeled agent rule messages variables certain syntactic conditions satisfied actions carried computational interpretation 
party protocol mapping roles 
roles denotes set roles 
symbolic execution protocol 
symbolic execution party protocol modeled finite sequence global states 
global state triple sid finite set messages current intruder knowledge sid finite set session ids maps session id sid current state corresponding session 
state called local state form 
ak index role executed session substitution domain subset variables occurring determines messages assigned variables far current session node determines node agent currently stands 
ak tuple names agents involved session ai agent carrying current session supposedly mentioned agents aj 
initial state qi intruder knows names public keys agents infinite set intruder nonces 
allow kinds transitions global states 
adversary corrupts set parties learns private keys corrupt agents qi dk aj 
note transition applied static corruption 
adversary initiate new sessions sid new ak sid sid defined follows 
sid sid session identifier new session sid denotes cardinality sid 
define sid sid sid 
function defined follows sid sid sid sid sid 
ak denotes root role tree aj aj ai nai adversary send messages sid send sid sid sid sid defined follows 
define sid sid sid sid 
suppose sid 
ak 
lh rh labels edges leaving order 
distinguish cases exist lj match 
define sid sid state remains unchanged minimal lj match 
matcher lj 
define sid pj 
ak rj ai sid 
finite sequence global states called symbolic execution trace protocol starts initial global state qi consecutive global states sequence connected transitions 
say trace valid send transition sid send sid sid verifies adversary deduce set valid symbolic execution traces protocol denoted exec 
set valid set messages defined msg sid state valid execution trace 
concrete model concrete model defined encryption scheme ae ke enc dec fix 
hashing modeled random oracle 
concrete messages 
concrete messages bit strings carry type efficiently computed 
bit strings type pair components efficiently strings type ciphertext carry public key supposedly encrypt plaintext 
set bit strings denoted set depends security parameter parameter determines length agent names nonces keys 
substitutions map variables type concrete messages type 
concrete execution protocol 
concrete global state tuple sid finite set bit strings sid finite set session ids maps session id sid current state corresponding session concrete local states 
concrete local state defined just symbolic variables mapped bit strings agent names bit strings 
fourth component carries state random oracle set couples bit string corresponding hash value 
protocol executed running ppt turing machine concrete adversary may queries corresponding transitions symbolic model 
allow kinds transitions global states refer corrupt new send transitions hash queries 
semantics queries defined analogy formal execution model 
addition adversary may queries random oracle sid hash sid defined follows 
exists define hash value generated random 
case returned adversary 
finite sequence concrete global states called concrete execution trace starts initial global state 
obviously adversary ppt turing machine length trace bounded polynomial security parameter 
sequence random coins execution honest agents random oracle sequence random coins ra adversary bounded length polynomials ga pa respectively 
clearly ra fixed obtain uniquely determined concrete trace denote exec ra 
symbolic computational secrecy properties section recall computational definition secrecy introduce new symbolic definition secrecy 
computational secrecy 
computational secrecy requires partial information leaked adversary 
typical way formalize idea require secret indistinguishable unrelated random bitstring chosen appropriate distribution 
secrecy nonce variable nonce generated ai ith role protocol protocol defined follows 
sec definition 
consider experiment parametrized bit involves adversary protocol 
experiment takes input security parameter starts generating random nonces adversary starts interacting protocol execution described exec 
point execution adversary initiates session role ai executed declares session attack 
session variable ai instantiated nb 
rest execution exactly exec 
point adversary requires nonces output guess bit result experiment 
define advantage adversary adv sec exec pr exp sec exec pr exp sec exec say nonce computationally secret protocol write ai adversary advantage negligible 
symbolic secrecy 
explained weak secrecy sufficient capture standard indistinguishability notion computational settings 
new notion secrecy propose relies intuitively appealing concept patterns 
roughly pattern expression obtained replacing subterms expression secret 
case subterm secret adversary verify construct formally add knowledge set deduction relation 
ideas definition patterns related offline guessing attacks adversary weak secret unable test weak secret observed messages 
definition patterns 
set closed terms 
mk term define patt pat pat 
pat mk pat defined recursively pat randadv pat pat pat pat pat ek ek randadv dk randadv pat pat randadv pat extended set messages expected pat pat 
messages may contain subterms form ek randadv 
random coins messages build adversary deducible 
consider augmented messages ek subterm 
valid message set msg protocol show 
definition nonce secrecy 
protocol nonce variable occur ai ring role ai 
say ai secret write valid set messages msg holds session number symbolic nonce nai occur 
better appreciate definitions consider examples 

nb 

preserves indistinguishability nb intuitively nb hidden secret nonce 
nb ek randadv 

example encryption hide nb 

nb ek randadv 
nb ek 
nb occurs 
corresponds attack 
encrypted adversary knows ciphertext 
computes ek ek compares nb ek yielding attack 

nb ek dk randadv 
nb ek dk 
nb occur 
attack intruder may get nb decrypting projecting message nb ek compare nb may compute 
notion secrecy useful equivalent formulation described lemma 
informally lemma states unencrypted occurrences secret nonce set messages occur term hashed computed lemma 
arbitrary set messages nonce symbol occurs 
occur patn subterm encryption symbolic secrecy equivalent computational secrecy prove soundness completeness secrecy criterion proceed steps relate symbolic concrete traces ii prove equivalence symbolic computational notions 
relating symbolic concrete traces 
step linking security properties symbolic concrete models exhibit relation individual execution traces 
relation similar developed previous works definitions results deal random oracles computational executions 
line common practice symbolic models hash applications explicitly captured queries random oracle concrete traces reflected symbolic traces 
define hash query free trace clean hash tc associated concrete trace tc sid 
sid gn hn 
trace clean hash tc concrete trace sid gi hi 
ik hik obtained removing tc states result hash request 
definition 
sid 
sid fn symbolic execution trace clean hash sid 
sid gn hn hash query free trace concrete execution trace tc 
say trace concrete instantiation partial mapping write holds sid sid sid sid sid sid sid sid 
ak sid sid sid sid 
ak sid sid sid sid sid sid trace concrete instantiation dolev yao hash queries write exists partial injective function message hk exists term randadv proposition 
executable protocol 
encryption scheme ae ind cca secure hash functions random oracles algorithm pr exec exec ra probability choice ra pa ga negligible function 
proof shares ideas earlier appendix 
symbolic secrecy equivalent computational secrecy 
theorem states symbolic secrecy criterion necessary sufficient computational secrecy hold 
theorem 
executable protocol nonce variable occur ai ring role ai 
encryption scheme ae implementation ind cca secure 
proof 
direction 
give ideal execution protocols replaces real nonces random strings 
show adversary distinguish modified execution call oracle execution real execution 
argue oracle execution nonces symbolically secret information theoretically hidden computational adversary 
symbolic secrecy property satisfied lemma nonce occurs hashed terms term secret sense computed efficiently 
random oracle model hash values independent hashed message view adversary independent value secret nonces 
step describe oracle execution 
protocol dictates honest party encrypts bitstring party encrypts randomly selected bitstring rm equal length 
execution keeps table association rm call random associations table rat 
rat available adversary honest parties 
specifically honest party receives encrypted messages party performs appropriate decryption recovers plaintext 
plaintext occurs rat party treats encryption encryption continues execution normal 
underlying plaintext set intuitively adversary behaves differently executions see difference encryptions true random ciphertexts 
formally output adversary executed protocol security parameter exec output adversary associated oracle execution lemma prove appendix 
lemma 
executable protocol arbitrary ppt adversary 
encryption scheme ae implementation ind cca secure pr pr exec negligible 
notice apply lemma case execution sec considered experiment exp write sec corresponding oracle execution obtain exists negligible function sec sec pr exp pr exp exec exec step ii 
step associate symbolic traces computational traces oracle execution 
enables reason adversary success oracle execution conceptually simpler 
association fact proof proposition additional parsing step necessary take account random association table detail 
addition access keys randomness parties parsing procedure uses access random association table follows step processing message search random association table 
occurs rat procedure proceeds replaced procedure remains unchanged 
argue symbolic traces obtained valid execution traces included traces execution 
formalization lemma 
proof appendix 
lemma 
symbolic traces exec valid overwhelming probability exec 
step iii 
prove ae ind cca secure 
arbitrary adversary secrecy nonce ai sec recall write exp oracle version experiment defining exec secrecy nonce ai corresponding advantage functions 
definition adv sec exec pr adv sec pr exp exp sec exec sec pr exp pr exp sec exec sec subtracting equation rearranging terms obtain negligible function adv sec exec show oracle execution advantage adv sec adversary negligible nonces symbolically secret informational theoretically hidden adversary 
seen follows 
consider symbolic trace corresponds execution experiment sec exp point adversary nonces asked exec determine bit id session attack symbolic nonce corresponds nonce attack 
lemma trace overwhelming probability dolev yao trace protocol 
hypothesis theorem lemma occurrences honest encryption term ti appears hash ti ti bitstrings correspond terms ti 
conclude observing real execution adversary may observe values provided query 
random oracle values particular value secret nonce independent 
queries random oracle images terms conclude request ti direction 
important observe message deducible set messages 
mn associated deduction tree translated efficient program bit string representations mi mi 
computes bit string representation proceed follows 
assume symbolic trace symbolic nonce ai occurs pat starting lemma show exist term deduction tree ai yields message ai yield know exists deduction tree yields construct stage adversary secrecy nonce ai stage adversary produces computational representation trace simply instructions dolev yao adversary defines 
created requests values nonce ai receives experiment nb computes mb nb retrieves comparing 
decidability symbolic secrecy section show notion secrecy decidable 
decides nonce non secrecy case bounded number sessions adversaries allowed fixed number new queries loss generality assume new queries performed execution 
decision procedure starts guessing sequence requests identities agents involved 
procedure guesses interleaving execution 
standard techniques executions translated constraint systems 
recall definition definition 
constraint system finite set expressions ti tt ti ui ti non empty set terms tt special symbol represents deducible term ui term ti ti var ti tj min var inclusion relation tj ti 
left hand side right hand side constraint respectively 
left hand side constraint system write lhs maximal set messages tn 
denote unsatisfiable system 
left hand side constraint represents messages sent network right hand side represents message expected agent order perform protocol step 
solution constraint system ground substitution randadv say preserves nonce secrecy exist solution occurs patn lhs 
transformation protocols constraint systems yields systems wellformed 
constraint system formed subterm form dk agent identity subterm form rand randadv 
theorem states notion nonce secrecy section decidable bounded number sessions 
theorem 
problem np complete case unbounded number sessions secrecy notion undecidable just standard deducibility notions 
formed constraint system nonce decide preserve nonce secrecy 
decision procedure nonce secrecy preservation works follows 
arbitrary constraint system reduce solved system non deterministic transformation rules similar see appendix 
constraint system solved different constraints form tt variable 
second check occurs patn lhs 
check simplified solved form preserve nonce secrecy 
note standard deducibility notions decision procedures soon constraint system transformed solved form secrecy notion transformations necessary 
np hardness proved analogously case standard deducibility notions 

abadi cortier 
deciding knowledge security protocols equational theories 
icalp volume lncs pages 

abadi rogaway 
reconciling views cryptography 
ifip tcs volume lncs pages august 

armando basin chevalier von oheimb rusinowitch santiago 
tool automated validation internet security protocols applications 
cav volume lncs 

backes christian jacobi 
cryptographically sound machine assisted verification security protocols 
stacs pages 

backes pfitzmann 
relating cryptographic und symbolic key secrecy 
proc 
th ieee symposium security privacy ssp pages 

bellare rogaway 
entity authentication key distribution 
crypto volume lncs pages 

blanchet 
efficient cryptographic protocol verifier prolog rules 
proc 
th ieee computer security foundations workshop csfw pages 

canetti herzog 
soundness formal encryption presence active adversaries 
tcc lncs 
appear 

comon shmatikov 
intruder deductions constraint solving insecurity decision presence exclusive 
lics pages 

cortier warinschi 
computationally sound automated proofs security protocols 
esop volume lncs pages 

goldwasser micali 
probabilistic encryption 
journal computer system sciences 

gupta shmatikov 
computationally sound symbolic analysis key exchange protocols 
pages 

micciancio warinschi 
soundness formal encryption presence active adversaries 
tcc volume lncs pages 

millen shmatikov 
constraint solving bounded process cryptographic protocol analysis 
ccs pages 

rusinowitch 
protocol insecurity finite number sessions composed keys np complete 
theoretical computer science april 
protocol roles agent rule tuple form written 
typically substitution variables fixed applications preceding agent rules sharing variables current agent rule 
agent receives message matched say matcher message produced output explained case contain variables 
match agent produce output 
match say rule applied applicable role agent performs run protocol specified ordered finite tree edge labeled agent rule 
run protocol agent stand certain node tree 
assume outgoing edges node form 
ls rs starting left edge 
agent receives message say agent apply agent rule left applicable produce output 
formally define role trees roles role tree satisfying certain conditions 
role tree finite ordered edge labeled tree domain finite subset ith successor node pi edge labeled agent rule 
node denote sequence agent rules edges path root labeled 
write denote sequence left right hand sides rules respectively 
consider sequences sets 
write denote agent rule edge leading labeled 
left hand side rule refered right hand side ruler ith role performed agent ai party protocol role tree certain conditions satisfied 
define conditions need notation 
node denote ki ek 
ek ak dk ai ai set terms agent ai knows node 
note set includes 
predecessor define define ki ek 
ek ak dk ai ai 
set coincides added 
formulate mentioned conditions required see informal description node require 
ruler contain subterm type 
occurs context term type ciphertext set subterms form singleton 
occurs occur occurs occurs term form ek ai 
ki ki ki condition says decryption keys contained agents rules 
implies keys may output agent 
second condition term form means ai computes encryption plain text key random coins agent ai computed ciphertext different places role 
term may occur different places agent rules 
ai computes encryption different plain text different key ai different random coins 
intuition third condition follows variables terms decrypting messages 
precisely concrete execution model term form ek ai cause ai perform action 
checks message ciphertext ek ai public key 
decrypt message try parse message message form ek ai occur left hand side agent rules terms form ek ai note term form ek aj occur left hand side agent rule ai mean ai decrypt message encrypted public key aj 
course forbidden 
parsing message ek ai don assume agent able extract random coins encrypt message 
depending encryption scheme possible importantly protocols typically information 
occur position agent rules ai 
previous conditions condition implies ai carry tests receiving message produce output message 
transitions formal execution model define transitions global states notation 
denote distinct nonces 
analogously denote distinct random coins 
denote mapping maps denote term obtained replacing occurring 
mapping replace randomness fresh randomness 
right hand side agent rule 
allow kinds transitions global states refer corrupt new send transitions respectively 
adversary corrupts set parties outputting set identities corrupt learns private keys agents qi dk aj 
note transition applied static corruption 
adversary initiate new sessions sid new ak sid sid defined follows 
sid sid session identifier new session sid denotes cardinality sid 
define sid sid sid 
function defined follows 
sid mf sid sid sid 
sid 
ak domain 
ak ai aj aj ai nai adversary send messages sid send sid sid sid sid defined follows 
define sid sid sid sid 
suppose sid 
ak 
lh rh labels edges leaving order 
distinguish cases exist lj match 
define sid sid state remains unchanged minimal lj match 
matcher lj 
define sid pj 
ak rj ai sid 
concrete types identify element bit string length 
denote set bit strings form denotes concatenation interpreted name agent 
recall set nonces set hash values defined replaced respectively 
specific details encoding types exact length bit strings sets essential results shown long certain conditions satisfied 
example size set nonces hashes grow exponentially specific definition case 
bit string type returns iff prefixed analogously types say bit string form may satisfy certain efficiently checkable conditions public key bit string type algorithm type returns message type 
analogously type assume public private keys obtained running ke prefixed respectively 
set bit strings type denoted 
denote efficiently computable functions satisfy conditions prefixed bit strings input algorithm type returns iff prefixed denote set bit strings type returns bit string obtained concatenation type public key defined bit string actual may satisfying certain efficiently computable conditions components efficiently recovered called ciphertext bit string type type returns bit string required form 
assume encryption algorithm returns bit string type set bit strings type denoted bit string type denote algorithm recovering public key second component message 
emphasize public key necessarily obtain actual message 
denote set bit strings type return types case require type return garbage 
transitions concrete execution model execution protocol adversary may sequence queries induces sequence concrete global states 
explain queries adversary may 
corrupt query execution adversary may corrupt set parties request corrupt 

result public private keys generated agents running ke times independent random coins 
agent names public private keys adversary added current intruder knowledge 
new session query adversary initiates new session issuing request form new 
ak 
ak result happens aj public key generated far public private key pair generated running ke 
instance running concrete version initiated 
instance gets 
ak public keys private key ai input 
variables occurring random nonces derived ai generated 
instance input 
accordingly sid current global state new state sid sid sid sid sid sid defined follows sid sid sid sid local states previous sessions remain unchanged sid 
ak defined follows aj aj ai occurring ai send message query issuing query form send sid sid sid adversary send message instance sid 
effect query assume current global state sid sid 
outgoing edges labeled agent rules 
lk rk order 
starting left rule agent ai carries session sid check matches agent rules 
say lj rj match 
ai produces output rule moves program pointer pj 
store values assigned variables lj rj way 
briefly explain lj matched explain output produced rj 
matching lj done recursively structure lj 
lj variable value stored variable far type variable checked running type assigned variable 
variable assigned variable checked coincides lj form checked type components extracted running 
components matched respectively order 
lj form ek ai checked type ciphertext public key extracted 
decrypted key ai 
decryption successful resulting plaintext matched lj form ek aj encryption bit string corresponding randomness replaced public key aj computed 
precisely distinguish cases ek aj occurred preceeding agent rule computed simply checked coincide 
ek aj occurred follows condition roles protocols ek aj derived messages seen far formally ki ki ek aj 
derivation tree compute bit string corresponding bit string encryption public key aj fresh random coins 
checked resulting bit string coincides 
technical detail variables ki assigned values example occur different component matched 
matching successful substituted bit string evaluate 
lj form follows condition roles protocols derived messages seen far formally implies 
evaluate results bit string compare bit string checks fails instance ignore incoming message internal state changed 
output bit string produced rj computed structure rj obvious way 
condition role protocols guarantee computation carried 
description current global state sid updated sid obvious way matching lj fails global state change 
obtained adding bit string produced output 
define sid sid sid sid 
sid 
new local state sid session sid pj 
obtained adding substitution variables lj matching lj hash query adversary may issue hash request random oracle form hash 
current global state sid effect query contain entry bit string chosen randomly bit string adversary 
global state particular updated accordingly 
ind cca security asymmetric encryption schemes appendix recall standard notion security asymmetric encryption schemes ind cca security 
formulation give multi user version known equivalent single user version see :10.1.1.117.6018
fixed encryption scheme ae ke enc dec left right encryption oracle parametrized bit encryption key pk oracle accepts queries pairs equal length bitstring returns encryption enc pk mb 
encryption scheme ae ke enc dec consider experiment exp ae parametrized bit uses adversary adversary provided access polynomially left right oracles parametrized public key pki generated pki ski ke 
adversary access corresponding decryption oracles oracles parametrized decryption keys ski accept input bitstrings return decryption bitstring ski 
adversary allowed encryption decryption queries likes condition submit decryption oracle ski ciphertext obtained encryption oracle pki 
finishes execution adversary outputs bit guess bit bit output experiment 
define advantage adv ae pr exp ae pr exp ae say ae ind cca secure probabilistic polynomial time adversaries function adv ae negligible 
proof lemma arbitrary set messages nonce symbol occurs 
right implication 
implies occurs patn induction proof obtained decomposition rules projections decryption 
second assume exists subterm encryption implies contains pairing hashes easy verify occurs pat patn deducible subterm 
left implication 
assume occurs patn encryption prove induction subterm occurs pat implies base case constant name 
occurs pat implies occur pat mi equal 
mi deduce induction hypothesis ek occurs pat 
randadv 
construction 
induction dk 
implies dk shown fact dk obtained decomposition rules 
deduce obtain induction hypothesis 
occurs pat applying induction hypothesis get means exists context computable adversary agent encryption terms 
nk deducible subterms 
nk 
see example proposition 
position 
exists adversary encryption exists subterm ek occurring pat construction 
induction hypothesis 
adversary encryption means encryption 
hypothesis exists equal 
nk sub context contradiction 
decidability nonce secrecy preservation appendix devoted proof theorem 
np hardness comes construction np hardness deciding usual secrecy 
non deterministic procedure decide nonce secrecy preservation works steps 
arbitrary constraint systems reduced solved constraint systems non deterministic transformation rules second show decide nonce preservation solved constraint systems 
reduction solved forms simplification rules solving general constraint systems reduced solving simpler constraint systems called solved 
simplification rules consider defined 
rules fact indexed substitution index identity substitution implicitly considered 
write 
cn cn cn 
write 
simplification rules correct complete terminating polynomial time 
theorem 
constraint system substitution nonce 

correctness constraint system substitution solution occurs patn lhs solution occurs patn lhs 
tt rand adv mgu st variables mgu st variables var rand adv rh randadv ek ek lhs key variable key position st denotes set subterms terms fig 

simplification rules 

completeness solution occurs patn lhs solved form exist constraint system substitutions solution occurs patn lhs 

termination constraint system substitution polynomially bounded size proof simple extension proof provided xor 
extension nonce secrecy notion simply relies fact lhs lhs lhs substitution solution rule added decidability purposes compromise correctness completeness transformation rules 
decidability nonce secrecy solved forms general approach previous section verifying nonce secrecy reduced non deterministic polynomial time deciding properties constraint systems solved form 
applying theorem constraint system preserves nonce secrecy exists system solved form preserves nonce secrecy definition constraint system solved form preserves nonce secrecy exist solution occurs patn lhs 
consider typed substitution ek agent identity key variable assume rule applied possible 
solved form nonce 
consider solved form defined follows var easy verify solution solution occurs patn lhs occurs patn lhs 
assume var case say contains variables 
follows solved form redefined formed constraint system solved form contains variables successor rules 
sufficient decide nonce secrecy solved forms 
solved form decision procedure works follows 
check lhs solution decidable 
clearly preserve nonce secrecy 

choose non deterministically successor solved form check occurs pat lhs lhs 
clearly preserve nonce secrecy 
preserves nonce secrecy completeness non deterministic decision procedure relies property 
proposition 
solved form nonce 
assume lhs solution 
assume preserve nonce secrecy exists solution occurs patn lhs 
occurs patn lhs exists preserve nonce secrecy assuming proposition get preserve nonce secrecy successor solved form occurs patn lhs proves correctness decision procedure 
applying proposition preserve nonce secrecy occurs patn lhs exists preserve nonce secrecy assume solved form apply theorem possibly times get solved form preserve nonce secrecy apply proposition occurs patn lhs 
remaining section devoted proof proposition 
need intermediate lemmas definitions 
define public terms terms constructed adversary 
definition 
public context terms variables defined inductively follows public terms variable agent identity garbage ek adversary encryption randadv hash pairing public context linear public term variable appears twice 
convention expression 
tn denotes term exact set variables 
xn 
tn xn 
lemma 
nonce term 
tl ti ti constraint system solved form solution tj randadv exists public context 
tk ti subterm tj tj randadv ti ti variable 
tj randadv exists public context 
tk ti subterm tj tj randadv ti ti variable 
proof 
prove part lemma second part done similarly 
consider minimal proof tj randadv sense step uses smallest premises 
formally sub proof tj randadv minimal index proof ti randadv ti randadv proof done induction length proof tj randadv lexicographical order 
exists ti randadv done induction hypothesis 
assume minimal index tj randadv consider 
tj tj 
variable done 
minimal index proof ti randadv variable ti 
definition constraint system exists tl solution tl randadv contradicts minimality applied rule construction rule 
tk enc 
induction exist public context ci ti 
ki 
consider public context 
cn 
note encryption adversary randomness 
applied rule projection rule 
tj randadv tj randadv mi induction hypothesis exist public context 
tk ti subterm tj tj randadv ti ti variable 
public context ci satisfies conditions 
non variable deducible subterm tj 
tj randadv mi 
variable done 
variable tj exists tl randadv mi contradicts minimality applied rule decryption rule 
tj randadv ek tj randadv dk tj randadv induction hypothesis exist public context ek 
tk ti subterm tj tj randadv ti ti variable 
public context satisfies conditions 
ek non variable deducible subterm tj 

variable rule applicable contradicts successor 
ek 
tj randadv dk induction hypothesis exists public context dk 
tk ti subterm tj tj randadv ti ti variable 
dk 
variable formedness constraint system dk tj randadv dk 
deduce tj randadv variable done 
variable show contradicts minimality lemma 
lhs randadv dk lhs randadv dk 
proof 
consequence lemma 
assume lhs randadv dk 
lemma exists public context dk 
tk ti subterm lhs lhs randadv ti ti variable 
dk 
variable formedness constraint system dk lhs randadv dk 
lemma 
lhs randadv lhs randadv proof 
lhs lhs lhs randadv implies lhs randadv conversely formed lhs lhs lhs lhs subterm randadv 
show term subterm randadv deducible lhs lemma exists public context 
tk ti subterm lhs lhs randadv ti ti variable 
formed appears ti 
lhs randadv lemma 
constraint system solved form solution term 
lhs randadv exists term lhs randadv 
proof 
exists term lhs randadv clearly lhs randadv conversely assume lhs randadv applying lemma nonce occur exists public context 
tk ti subterm lhs lhs randadv ti ti variable 
choose 
tk 

lhs randadv ti public context implies lhs randadv lemma 
nonce constraint system solved form solution assume lhs solution 
assume lhs 
solution occur pat lhs 
occur pat lhs term lhs randadv 
exists solution occurs pat lhs lhs 
note lemma implies proposition 
assume lhs lhs 
solution 
assume exists solution occurs pat lhs occurs pat lhs lhs lemma possibilities occur pat lhs term lhs randadv case know lemma term pat lhs pat lhs lhs randadv lhs randadv term lhs randadv lhs deduce occur patn lhs occur patn lhs contradiction 
exists occurs pat lhs lhs means preserve nonce secrecy sufficient prove lemma proof 
nonce constraint system solved form solution assume lhs solution 
assume occur pat lhs lhs 
exists solution occurs pat lhs lhs case done 
prove occur pat lhs term lhs randadv 
tl 
assume lhs randadv lemma exists term lhs randadv 
assume subterm lhs prove statement induction lexicographical ordering denotes size occur pat lhs term subterm tk lhs randadv base case atomic 
nonce name lhs 
solution 
occur pat lhs variable excluded subterm contains variables 
induction step subterm tk lhs randadv nonce name lhs 
solution 
occur pat lhs variable definition constraint systems exists tk deduce tk randadv 

applying lemma constraint system 
tk ak exist 
un subterms tk 
un public context 
deduce pat lhs pat lhs 
pat lhs un 
applying induction hypothesis get occur pat lhs ui occur pat lhs 
pat lhs pat lhs pat lhs lhs randadv implies lhs randadv subterms tk apply induction hypothesis get occur pat lhs 
ek 
ek variable 
case variable excluded application transformation rule 
assume ek 
case randadv excluded subterm tk formed 
lhs randadv dk case occur 
lhs randadv dk 
lemma lhs randadv dk 
lhs randadv subterm tk apply induction hypothesis 

lhs randadv case pat lhs occur 
lhs randadv 
applying lemma exists public context 
uk ui subterm lhs lhs randadv ui ui variable 
exists path variable ui ui 
ui variable rule transformation rules applied 
mgu ui 
occurs patn lhs lhs lhs lhs contradiction 

xk ui 

lhs randadv var lhs lhs ui subterms tk apply induction hypothesis 
general case applying lemma lhs randadv implies exists public context 
subterm lhs lhs randadv variable 
public context pat lhs pat lhs 
pat lhs subterms lhs seen occur conclude occur pat lhs proofs results section proof proposition proof sketch 


proof steps briefly sketch giving details 
associate computational trace arbitrary adversary symbolic trace parsing bit string basic components keys identities nonces randomness mapping components appropriate symbolic constants 
parsing messages may freely decryption keys fixed randomness trace 
second step show trace associated valid trace overwhelming probability coins execution 
proof characterization non valid traces identifies ways messages output adversary invalid 
construct adversary simulates execution protocol presence adversary adversary encryption scheme uses encryption oracles simulate execution honest parties 
non negligible probability outputs non dolev yao message adversary breaks security encryption scheme 
step concrete execution trace exec ra construct symbolic function tracing queries adversary translating symbolic queries 
notice require efficiently construction may safely assume decryption keys known notice fixed 
corrupt new queries translation straightforward party identities mapped appropriate symbols 
interesting party send queries treated 
bitstring occurs send query translated symbolic term follows 
agent identities cryptographic keys randomness encryption honest parties random nonces quantities uniquely determined canonically mapped symbolic representations example bit string representing encryption key party ai mapped ek ai 
ciphertexts created adversary decrypted appropriate key recall decryption keys available defining mapping 
rest messages interpreted occur message sent adversary parsed notice decryption keys needed parsing known fixed randomness experiment 
step ii 
second step proof show trace constructed dolev yao overwhelming probability 
proof relies lemma characterizes non dolev yao adversaries 
follows ag adv randadv 
lemma 

mk ground terms 
mk names names mi ag ek subterm ag ek subterm mi 
exists non deducible term subterm 
mk position 
path non deducible 
mk 
path ag ek subterm mi 
decryption key dk subterm mi nonce encrypted message form ag ek hash 
say attack 
proof 
prove lemma induction size base case nonce agent identity key garbage symbol 
non deducible construction deduction system nonce decryption key dk honest agent 
decryption key satisfies lemma 
nonce hypothesis names mi 
subterm mi 
take satisfies lemma 
induction step composed term 

subterm mi satisfies conditions lemma 
subterm mi 
non deducible 
deducible 
apply induction hypothesis find satisfying lemma 
mk adv ek non deducible deducible 
apply induction hypothesis find satisfying lemma 
mk say non deducible deducible 
apply induction hypothesis find satisfying lemma 
mk ag ek hypothesis implies subterm mi satisfies lemma 
cases easy verify satisfies lemma 
mk non deducible subterm mi pair 
proofs important show 
mn output honest parties symbolic execution protocol term occurs mi fact constructed honest parties adversary 
seen follows 

mk messages sent order execution protocol 
mi form mi rji rji edge role variable domain subterm 
mi deducible term 
mi 
satisfy lemma 
non deducible occur non trivial subterm rji exists non variable position rj rj shows computed honest party 
main final step proof show exists adversary associated symbolic traces non dolev yao non negligible probability construct adversary breaks encryption 
adversary construct uses access left right encryption oracle corresponding decryption oracles simulate parties normally executed simulates random oracle 
general intercepts answers queries follows 
sends corrupt 
request adversary generates private public keys parties 
sends adversary 
wants initiate new session new 
ak agents ai new requests new users corresponding agents multi party setting public key encryption 
generates honest nonces corresponding agents ai new session 
send request parses message possibly decryption oracle records hashes generated simulating random oracle answers protocol encrypting message 
hash request generated hash value simply returns generates new hash value memorizes association returns value critical part proof adversary uses non dolev yao message described lemma break encryption 
treat separately case decryption key honest agent case nonce encrypted message form ag ek hash subterm previously sent messages 
start case complex 
step guess occurs execution honest parties time 
created honest party see lemma done guessing session number instruction li ri position ri occurs 
key idea construct different bit string interpretations uses left right encryption oracles way view simulated bit string associated precisely tb selection bit encryption oracles 
non dolev yao query recovers tb decryption oracles needs produce bit string representation message mi contains proceeds follows 
nonce generates nonces encryption generates versions encryption calling encryption algorithm twice different random coins hash generates random values 
constructs bitstring mi tb bit left right encryption oracle 
notice non deducible occurs encryption hash 
case compute bitstring associated inner protection tb honest encryption hash left right oracle encryption application random value hash 
case say cheating hash 
give examples cases 
example 
mi form ag ek deducible projections unprotected computes concrete counterparts respectively generates cheating hash associated couple 
representation ag ek encryption computed 
mi form ag ek deducible tb projection computes concrete counterparts uses left right oracle compute mb ek 
final value computed generates hash value mb ek 
argue able proceed simulating rest protocol provide concrete counterpart mj tb bit left right encryption oracle 
problematic cases receives hash send requests send hash 
cases parses sure recover tb clear non dolev yao message 
receives hash query hash cases 
generated hash value simply answers generated cheating hash value means equal mb non dolev yao message contradiction 
generated hash value simply generates new value gives remembers association 
receives send request send sid simulates protocol knows values sid 

lk rk edges node 
tries recursively find substitution compatible li 
assume finds 
parsing adversary finds cheating hash encryption obtained left right oracle adversary recovers values know secret value deducible projection 
tb non deducible tb re encrypted hashed ri 
replaces inner protection tb honest encryption hash oracle replacing random value cheating hash 
explain recovers non dolev yao output abuse notation occasionally write symbolic representation message bit string representation 
case deduced context 
message occurs send query hash request 
symbolic representation non dolev yao query path characterization lemma 
claim parse recover tb associated path reason inductively structure opens path ek lemma occur subterm mi particular obtained encryption oracle 
may submit decryption oracle recovers tb 
tb recovered path mb obtained random oracle knows form mb opens path alternatively mb obtained doing cheating hash generated nonce 
case mb subterm mi contradicts lemma 
conclude able retrieve tb breaking encryption 
proof lemma proof 
adversary function non negligible show construct successful adversary encryption scheme enc 
recall access polynomially left right encryption oracles corresponding decryption oracles 
write pki ski 
encryption decryption keys parametrize oracle 
adversary executes subroutine simulates environment experiment defining secrecy nonces playing role honest parties public keys set keys pk pk 
notice know secret keys correspond encryption keys parties simulates parse messages sent decryption oracles 
difference normal execution execution simulated encryptions honest parties need compute computed left right encryption oracles follows 
honest party needs encrypt message public key party message sufficiently long longer security parameter adversary selects random message rm equal length 
encryption set cm result obtained submitting rm left right oracle public key 
adversary maintains table pairs cm 
party needs decrypt ciphertext cm obtained left right oracle sets underlying plaintext rest simulation parties precisely normal execution 
output adversary outputs 
notice bit left right oracles simulation offers precisely execution bit simulation offers exec 
adv enc pr exp enc pr exp enc pr pr exec enc ind cca secure lemma follows 
proof lemma proof 
proof similar lemma 
show exists computational adversary induced symbolic traces oracle execution dolev yao construct adversary breaks ae 
adversary executes adversary subroutine emulates environment expects simulating honest parties 
adversary intercepts queries answers precisely adversary proof lemma 
recall time honest party needs encrypt message adversary obtains corresponding ciphertext submitting rm left right encryption oracle 
rm selected uniformly random string length equal addition adversary keeps track symbolic trace corresponds execution trace simply parsing messages sent adversary honest parties constructing execution mapping time adversary sends message parties verifies symbolic representation obtained dolev yao operations symbolic representations messages adversary seen 
known closed terms verification procedure done polynomial time 
point message output dolev yao stops execution outputs 
finishes execution adversary outputs 
notice bit left right oracle simulates perfectly environment simulation exec 
denote event execution dolev yao 
similarly exec denote event execution exec dolev yao 
obtain adv enc pr exp enc pr exp enc pr pr exec pr negligible proposition adv enc negligible ae ind cca secure obtain pr exec pr adv enc negligible 
conclude exec computational execution traces valid dolev yao traces 

