functional shell dynamically combines compiled code van rinus plasmeijer computer science institute university nijmegen toernooiveld ed nijmegen netherlands cs kun nl rinus cs kun nl 
new shell provides full basic functionality strongly typed lazy functional language including overloading 
shell manipulating files applications data processes command line 
shell type checking executes typed expressions 
files typed applications simply files function type 
shell executes command line combining existing code functions disk 
hybrid static dynamic type system clean type checking inference 
dynamic linker store retrieve expression data code type disk 
shell combines advantages interpreters direct response compilers statically typed fast code 
applications compiled functions type safe way shell functions defined shell compiled application 
programming languages especially pure lazy functional languages clean haskell provide support abstraction subroutines overloading polymorphic functions composition application higher order functions module systems verification strong type checking inference 
contrast command line languages operating system shells usually little support abstraction composition especially verification 
provide higher order subroutines complex data structures type inference type checking evaluation 
limited set types specific area application recognized serious problem past 
think command line languages benefit programming language facilities increase flexibility reusability security 
previously done research reducing run time errors memory access violations type errors operating systems implementing micro kernel clean provides type safe communication value type functional processes called 
shown moderate dynamic typing combination clean dynamic run time part supported 
system dynamic linker enables processes communicate data code type type safe way 
development shell command line interface prototype functional operating system clear normal shell really run time type information derived compiler compile time 
reduce possibility run time errors execution scripts command lines need shell supports abstraction verification type checking way clean compiler 
order need better integration compile time static typing run time interactivity concepts 
shell functional language operating system combines best worlds interactivity interpreter efficiency type safety compiler 
shell user interface mentioned kernel prototype functional operating system development 
shell compiled functions programs losing type information 
functions defined shell compiled applications 
shell built top clean hybrid static dynamic type system dynamic run time support 
allows programmers save clean expression graph contain data functions closures disk 
clean expressions written disk dynamic contains representation polymorphic static type preserving sharing 
clean programs load dynamics disk run time type pattern matching statically typed program 
way new functionality plug ins added running program type safe way 
shell called esther extensible shell ype ch experiment capable reading expression console clean syntax basic complete functional language 
offers application lambda abstraction recursive pattern matching function definitions overloading compiled clean programs typed functions command line defining new functions compiled clean programs shell interpreter extracting type information indirectly code dynamics disk type checking expression solving overloading evaluation constructing new dynamic containing correct type code expression 
introduce static dynamic hybrid type system clean sect 

section gives global description esther uses dynamics type check expression 
give examples dynamics 
sect 
show construct dynamic kind subexpression correct semantics type compose type checked way 
related discussed sect 
conclude mention research sect 

dynamics clean addition static type system clean extended polymorphic dynamic type system 
dynamic clean value static type dynamic contains expression representation static type expression 
dynamics formed lifted static dynamic type system keyword dynamic combination value optional type 
compiler infer type omitted dynamic int dynamic map fst function alternatives case patterns pattern match values type dynamic bring dynamic back static type system 
pattern match consist value pattern type pattern 
example returns just value contained inside dynamic type int type 
compiler translates pattern match type run time type unification 
unification fails alternative tried common value pattern match 
just dynamic int int just type pattern contain type variables provided run time unification successful bound offered type 
example tests argument type function inside argument unified type value inside second argument 
case safely apply type variables instantiated run time unification 
compile time generally unknown type type pattern match succeeds compiler safely apply yields value type bound unification wrapped dynamic 
dynamic dynamic dynamic dynamic df dx dynamic error apply type variables dynamic patterns relate type variable static type function 
functions called type dependent functions :10.1.1.39.8178
variable pattern associates type variable types containing universally quantified variables currently inferred compiler 
write types ease presentation 
numerical denotations overloaded clean 
clean syntax haskell forall 
defines new data type clean haskell uses data keyword 
clean separates argument types whitespace 
type inferred compiler 
name static type function 
static type variable overloaded predefined tc type code class 
tc class carry type representation 
example static type variable determined static context impose restriction actual type accepted run time 
yields just value inside dynamic dynamic contains value required context dependent type 
dynamic tc just dynamic run time system clean supports writing dynamics disk reading back possibly program execution program 
dynamic read lazily successful run time unification triggered pattern match dynamic 
amount data code dynamic linker link determined amount evaluation value inside dynamic 
dynamics written program safely read program providing simple form persistence rudimentary means communication 
string dynamic world bool world string world bool dynamic world running prog prog example write function value dynamics disk 
running prog create new dynamic disk contains result applying function dynamic name function dynamic name value 
closure evaluated operator needs 
case dynamic application df dx lazy closure evaluated value dynamic disk named result needed 
running prog tries match dynamic dr file named result type int 
succeeds displays value evaluating expression semantically equal yielding 
prog world function dynamic int int int world prog world value dynamic world prog world ok df world function world ok dx world value world result df dx world prog world ok dr world result world case dr int world clean uses denote overloading 
haskell written tc dynamic uniqueness attribute indicating world environment passed single threaded way 
unique values allow safe destructive updates clean 
value type world corresponds hidden state io monad haskell 
overview esther example previous section shows store retrieve values expressions functions type file system 
shows function type check application run time static types stored dynamics 
combining interactive read expression apply dynamics evaluate show result loop gives simple shell supports type checked run time application programs documents 
obviously implemented type checking common algorithms involving building solving list type equations 
decided clean dynamic run time unification advantages clean dynamics allow type safe lazy expressions need convert hidden type representation dynamics type representation type checking algorithm shows clean current dynamics interface powerful implement basic type inference type checking get improvements clean dynamics interface free uniqueness attributes overloading 
common command interpreters shells shell esther untyped files consist executables streams characters 
functions programs stored dynamics forming rudimentary typed file system 
evaluating expression interpretation source code esther generates new dynamic contains closure refers compiled code programs 
shell hybrid interpreter generates compiled code 
resulting dynamic compiled clean program interpreter shell 
dynamics contain closures refer code data belonging compiled clean programs 
needed evaluation code automatically linked running program clean dynamic linker 
approach results overhead evaluation expression conventional source code interpreter 
esther performs steps loop reads string console parses clean expression 
supports denotations clean basic predefined types application infix operators lambda abstraction overloading rec case expressions identifiers bound lambda abstraction rec case pattern assumed names dynamics disk read disk type checks expression dynamic run time unification type pattern matching infers types command expression contain type errors esther displays result expression inferred type 
esther automatically extended code necessary display result requires evaluation dynamic linker 
fig 

combined screenshot incarnations esther example session esther illustrate expressive power esther show esther session fig 
left window white title bar explain happens 
simple arithmetic 
shell looks current search path find infix function 
overloaded shell searches instance type int 
responds value inferred type result 

typing name dynamic prompt shows contents contain unnamed lambda functions type 

dynamic map applied dynamic fst yielding expected type 

infix operator applied integer string 

overloaded function revealed overloaded 
id id caused way esther handles overloading see sect 


lambda expression written disk operator named twice 
defined left associative infix operator priority 
esther shows internal code type lambda expression exposing fact uses combinators see sect 


dynamic applied previously defined operator twice 

defines function named head selects argument list case expression 

applies head empty list yielding pattern mismatch exception 

defines function named fac yields factorial argument 

fac evaluated 

start esther stored dynamic new process computer right window black title bar evaluates cd programs change directory directory provides clean standard library esther storing functions dynamics file system 
cd type string result esther shows unit void 
evaluates application ls empty string showing files current directory functions standard library 
fig 

combined screenshot calculator action esther example calculator uses shell function shows sequence screenshots calculator program written clean 
initially calculator function buttons 
buttons add remove function buttons 
loaded dynamically adding dynamics contain tuples string real real real 
lower half fig 
shows command line esther shell writes tuple dynamic named dyn disk 
extension dyn added clean dynamic linker extension store file fixity attributes means prefix 
esther pretty prints attributes microsoft windows file selector shows file name raw form 
button name function pressing add button calculator opens file selection dialog shown bottom fig 

selecting dynamic named dyn available calculator button applied yielding 
calculator separately compiled clean executable runs esther 
alternatively write calculator type string real real real disk dynamic 
calculator started esther current shell separate process 
type checking dynamics section show type unification clean dynamic run time system type check common syntax tree construct corresponding clean expression 
parsing trivial assume string successfully parsed 
order support basic complete functional language shell need support function definitions lambda rec case expressions 
introduce syntax tree piecewise show kind expression construct dynamic contains corresponding clean expression type expression 
names occurring free command line read disk dynamics type checking 
expression contain dynamics compiled code functions automatically linked clean run time system 
application suppose syntax tree constant values function applications looks expr infixl expr expr application value dynamic constant dynamic value disk introduce function compose constructs dynamic containing value correct type evaluated yield result expression 
compose expr dynamic compose value compose case compose compose dynamic df dx raise apply typeof df typeof dx defines infix constructor priority left associative 
clean comment line haskell 
easier error reporting implemented imprecise user defined exceptions la haskell 
dynamics set exceptions extensible 
typeof dynamic string typeof dyn tostring dyn pretty print type composing constant value contained dynamic trivial 
composing application expression lot function sect 

importantly added error reporting typeof function pretty printing type value inside dynamic 
lambda expressions extend syntax tree lambda expressions variables 
expr 
previous def 
infixr expr expr lambda abstraction 
var string variable combinators sight looks simply replace lambda constructor syntax tree dynamic containing lambda expression clean compose var dynamic problem approach specify type lambda expression evaluation 
furthermore evaluated lambda expression applied argument 
problem unavoidable get lambda 
fortunately bracket abstraction solves problems 
applications constant values composed dynamics usual way 
translate lambda expression sequence combinators applications help function ski 
compose 
previous def 
compose compose ski compose dynamic compose dynamic compose dynamic ski expr expr expr common bracket abstraction ski ski ski ski var var ski ski ski ski composing lambda expressions uses ski eliminate lambda variable syntax constructors leaving applications dynamic values combinators 
composing combinator simply wraps corresponding definition type lambda expression dynamic 
special combinators combinator optimization rules improve speed generated combinator code reducing number guard fails function alternative 
combinators 
careful optimize generated combinator expressions way resulting type general 
untyped world allowed preserve intended semantics generating untyped code 
generated code contained dynamic typed 
essential preserve principal type expression bracket abstraction 
adding common conversion example results general type var var ab optimizations prevent getting principal type expression 
simple bracket abstraction performed ski preserves principal type 
code combined esther way fast code generated clean compiler 
combinators introduced bracket abstraction main reason slowdown 
additionally applications lazy specialized basic types 
disadvantages hold small lambda functions written command line plumbing 
faster execution required copy paste command line clean module writes dynamic disk running compiler 
order reduce number combinators generated expression current implementation uses algorithm conversion order preserve principal type reducing number generated combinators exponential quadratic 
current implementation fast explore optimizations bracket abstraction algorithms 
irrefutable patterns introduce irrefutable patterns 
nested tuples lambda expressions 
preparation upcoming rec expressions 
expr 
previous def 
tuple int tuple constructor compose 
previous def 
compose tuple int dynamic dynamic dynamic 

ski expr expr expr ski ski ski tuple value ski 
previous def 

clean support functions data types arity 
int dynamic dynamic fst snd dynamic fst snd 

extend syntax tree tuple constructors number elements tuple 
expressions tuple var var var tuple var var valid expressions 
example corresponds clean lambda expression 
ski function reaches application left hand side lambda abstraction processes sub patterns recursively 
ski function reaches tuple constructor replaces call function 
note right hand side lambda expression transformed lambda abstractions expect component tuple separate argument 
function extract component tuple separately 
uses lazy tuple selections fst snd clean tuple patterns eager prevent non termination recursive rec section 
rec expressions ready add irrefutable rec expressions 
refutable rec expressions written cases introduced section 
expr 
previous def 
letrec def expr rec 

combinator def infix expr expr 
compose 
previous def 
compose letrec ds compose ds compose dynamic def expr expr ds combine ds ski ski combine def def combine combine ds combine ds tuple tuple compose encounters rec expression uses convert lambda expression 
function combines possibly mutually recursive definitions pairing definitions single possibly recursive irrefutable tuple pattern 
leaves just single definition converts lambda expression usual way 
case expressions composing case expression done transforming alternative lambda expression takes expression match argument 
expression matches pattern right hand side alternative taken 
match lambda expression corresponding alternative applied expression forming cascade constructs 
results single lambda expression implements case construct apply expression wanted match 
expr 
previous def 
case expr alt case 

alt infix expr expr 
compose 
previous def 
compose case compose translate alternatives lambda expressions rules 
pattern consists application bracket abstraction argument just lambda expressions order deal subpattern recursively 
matching irrefutable pattern variables tuples succeeds reuse code ski matching lambda expressions 
matching basic values done uses clean built equalities basic type 
add default alternative mismatch function informs user patterns matched expression 
alt expr value mismatch ski var var tuple tuple value dyn th el case dyn int value th el char value th el 
basic types dynamic tc eq dynamic th el th el mismatch dynamic raise pattern mismatch matching constructor contained dynamic takes 
example put clean list constructor dynamic find type function type 
clean match closures functions constructors 
function construct node contains right constructor adding dummy arguments function type anymore 
function uses low level code match nodes see constructor pattern matches outermost constructor expression 
matches need extract arguments node 
done function decides arguments need extracted types inspection type curried constructor 
low level auxiliary code extract argument preserving laziness 
value dyn th el case dyn 
previous definition basic types constr value constr value dyn th el dynamic dynamic dynamic th el th el dynamic dynamic dynamic undef dynamic dynamic dynamic 
specific type dynamic arg arg dynamic arg dynamic bool low level code compares nodes 
ofn low level code selects th argument ary node pattern matching user defined constructors requires constructors available stored file system 
esther currently support type definitions command line clean compiler introduce new types constructors file system 
example shows write constructors type file system 
constructors available file system write command lines case type int int inferred 
int start world dynamic world dynamic int dynamic overloading support overloaded expressions dynamics clean implemented write dynamic bool eq 
dynamics implementation supports overloading way suits esther 
want solve overloading instances dictionaries file system may change time expect clean dynamic run time system box 
clean version overloaded functions 
functions running example 
class eq infix bool class instance eq int low level code compare integers instance int mimic clean overloading introduce type differentiate overloaded dynamics normal dynamics 
type shown type variables represent variable expression overloaded dictionary type original type expression type name overloaded function 
values type consists constructor followed overloaded expression type name overloaded function type 
motivate design type section 
overloaded expression dynamic id eq bool bool string dynamic id string instance eq int dynamic int int bool instance int dynamic int dynamic example esther representation clean overloaded function 
overloaded expression identity function result expression dictionary 
name class eq 
dynamic overloaded single variable type dictionary bool expected original type type name string 
likewise dynamic esther representation clean overloaded function 
separating different parts overloaded type obtain direct access variable expression overloaded 
easy detect overloading resolved variable longer unifies 
separating dictionary type original type expression easier check application overloaded dynamic allowed value type applied value type 
apply overloaded dynamic combine overloading information pair type shown function 
just pair dynamic dynamic dynamic nf vf df sf nx vx dx sx dynamic nf nx vf vx df dx sf sx private data type tuples allows differentiate pair variables single variable unified tuple 
applying yields expression semantically equal 
overloaded pair variables 
overloaded expression needs pair dictionaries build expression 
original type bool overloaded eq 
esther pretty print bool eq dynamic eq id eq id eq bool bool string string applying integer bind variable int 
esther able choose right instance eq 
searches file system files named instance eq int instance int applies code dictionaries applying overloaded expression 
result look example overloading removed 
dynamic eq id eq id eq int int bool overloading resolved example plumbing dictionary passing code 
increase evaluation time clear prevented 
concludes presentation inner machinery esther 
related seen interpreter shell esther ability precompiled code store expressions compiled code compiled programs type safe way 
es shell supports higher order functions allows user construct new functions command line 
unix shell haskell jim mattson interactive program launches executables provides pipelining redirections 
tcl popular tool combine programs provide communications 
programs provides way read write typed objects strings disk 
provide level type safety 
functional interpreter file system manipulation library provide functional expressiveness static dynamic type checking part command line 
example scheme shell scsh integrates common shell operations scheme language enable user full expressiveness scheme command line 
interpreters statically typed functional languages hugs provide static type checking advance 
type check source code type check application binary executables documents data structures untyped executables 
run time code generation specialize code run time certain parameters completely different 
related esther combines existing code 
shown build shell provides simple powerful strongly typed functional programming language 
virtually able clean support run time type unification dynamic linking albeit syntax transformations low level functions necessary 
shell named esther supports type checking inference evaluation 
offers application lambda abstraction recursive pattern matching function definitions basics functional language 
additionally infix operators support overloading shell easy 
support infix operators overloading required storage additional information file system 
chosen file attributes store infix information instances overloaded function stored files named instance ype 
combining compiled code esther allows pre compiled program function shell 
esther stores functions expressions constructed command line dynamic supports writing compiled programs command line 
furthermore expressions formed command line pre compiled clean program 
evaluation expressions recombined compiled code fast clean compiler 
speed improved introducing combinators bracket abstraction seams unfeasible esther perform optimizations clean compiler 
practice find esther responsive optimizations appear worth effort stage 
construct clean module syntax compiler generate dynamic contains efficient code 
research done elaborate typed file system support types type definitions command line 
esther incorporated ongoing research development strongly typed functional operating system 

rinus plasmeijer marko van eekelen 
concurrent clean language report version 
university nijmegen november 
cs kun nl clean 

simon peyton jones john hughes report programming language haskell 
university yale 
www haskell org definition 

van rinus plasmeijer 
strongly typed functional operating system 
pe arts editors th international workshop implementation functional languages ifl pages 
springer september 
lncs 

mart abadi luca cardelli benjamin pierce gordon plotkin 
dynamic typing statically typed language 
acm transactions programming languages systems april 

marco pil 
dynamic types type dependent functions 
hammond davie clack editors th international workshop implementation functional languages ifl volume lncs pages london 
springer 

martijn rinus plasmeijer 
lazy dynamic input output lazy functional language clean 
pe arts editors th international workshop implementation functional languages ifl pages 
springer september 
lncs 

abadi cardelli pierce plotkin 
dynamic typing polymorphic languages 
proceedings acm sigplan workshop ml applications san francisco june 

simon peyton jones alastair reid fergus henderson hoare simon marlow 
semantics imprecise exceptions 
sigplan conference programming language design implementation pages 

sch 
ber die der mathematischen logik 
mathematische annalen volume pages 


haskell curry robert feys 
combinatory logic volume 
north holland amsterdam 

roger hindley jonathan seldin 
combinators calculus 
cambridge university press 
isbn 


compiling functional languages 
john wiley feys sons 

simon peyton jones 
implementation functional programming languages 
prentice hall 

paul byron 
es shell higher order functions 
proceedings usenix winter technical conference pages 

jim mattson 
haskell shell 
www informatik uni bonn de ralf software examples html 

ousterhout 
tcl embeddable command language 
proceedings usenix winter technical conference pages berkeley ca 
usenix association 

shivers 
scheme shell 
technical report mit lcs tr 

mark jones alastair reid yale haskell group ogi school science engineering 
hugs user manual 
cvs haskell org hugs 
