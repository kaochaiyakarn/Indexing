usenix association proceedings general track usenix annual technical conference san antonio texas usa june advanced computing systems association usenix association rights reserved information usenix association phone fax email office usenix org www www usenix org rights individual papers remain author author employer 
permission granted noncommercial reproduction educational research purposes 
copyright notice included reproduced 
usenix acknowledges trademarks 
craig soules da silva marc auslander system support online reconfiguration jonathan gregory ganger michal online reconfiguration provides way extend replace active operating system components 
provides administrators developers applications system way update code adapt changing workloads pinpoint performance problems perform variety tasks system running 
generic support interposition hot swapping system allows active components wrapped additional functionality replaced different implementations interfaces 
describes support online reconfiguration operating system initial experiences 
describes base capabilities combined implement generic support interposition hot swapping 
examples utility describes performance enhancements achieved online reconfiguration mechanisms including adaptive algorithms common case optimizations workload specific specializations 
operating systems big complex 
expected serve needs workloads 
meant portable varied hardware resources 
expect demanding set requirements difficult satisfy 
result patches updates enhancements common 
addition tuning activities automated human driven involve dynamically adding monitoring capabilities reconfiguring system better match specific environment 
common requirements need modify system software deployed 
cases shutting system updating software restarting sufficient 
approach comes cost system availability human administrative time 
restarting system add monitoring generally clears state system 
render new monitoring code ineffective un carnegie mellon university university toronto ibm watson research center kevin hui robert wisniewski krieger michael stumm bryan jimi usenix association usenix annual technical conference request response profiler lru profiler interposed page manager 
request response lru fifo lru page manager hot swap fifo 
request response fifo fifo page manager fully swapped 
online reconfiguration 
shows online reconfiguration mechanisms interposition hot swapping 
shows lru page manager interposed profiler watch component calls returns see performing 
determines performance poor may decide switch existing component 
shows lru page manager swapped fifo page manager 
swap complete shown lru page manager deleted 
old state system reproduced 
online reconfiguration provide useful foundation enhancement deployed operating systems 
generic support built os core activities require system modification addressed adding new complexity individual subsystems 
example patches updates applied running system avoiding time associated human involvement 
addition monitoring code dynamically added removed gathering system measurements desired common case overhead 
illustrates basic mechanisms online reconfiguration interposition hot swapping 
interposition wraps active component extending functionality wrapper code executes call component 
hot swapping replaces active component new implementation 
modify active component maintaining availability component functionality 
implement interposition hot swapping implemented capabilities 
system able identify encapsulate code data swappable component 
second system able swappable component external actively code data 
third system able transfer internal state swappable component replacement version component 
fourth system able modify external data code pointers swappable component 
hot swapping consists exercising capabilities sequence 
interposition relies mainly fourth capability redirect external interposed code 
discusses capabilities detail describes initial prototype implementation interposition hot swapping operating system discusses online reconfiguration added traditional operating systems 
explore flexibility value online reconfiguration implemented number known dynamic performance enhancements 
include common case specialization workload specialization scalability specialization 
online reconfiguration variety reasons modifying deployed operating system 
common examples component upgrades particularly patches fix discovered security holes 
examples include dynamic monitoring system specializations adaptive performance enhancements integration third party modules 
usually supported distinct case case mechanisms example 
section motivates integrating system software generic infrastructure extending replacing active system components 
discusses aspects online reconfiguration interposition hot swapping 
discusses number common os improvements interposition hot swapping simplify enhance implementation 
online reconfiguration online reconfiguration support simplify dynamic updates changes wanted classes system enhancement 
generic infrastructure avoid collection similar reconfiguration mechanisms 
mechanisms provide generic infrastructure interposition hot swapping 
interposition wraps active component interface extending functionality 
interposition wrappers may specific particular component generic wrap component 
example generic wrapper measure average time threads spend component 
component specific wrapper fault handler count page faults determine threshold sequential page faults reached 
hot swapping replaces active component new component instance provides interface functionality 
maintain availability correctness service provided new component picks old left 
internal state old component transfered new external relinked 
hot swapping allows component replacement disrupting rest system place additional requirements clients component 
applying online reconfiguration interposition hot swapping general tools provide foundation dynamic os improvement 
remainder section discusses common os enhancements map 
patches updates security holes bugs performance anomalies identified fixed deployed systems repaired 
hot swapping patch applied system immediately need time scheduled 
capability avoids trade availability correctness security better performance 
adaptive algorithms os resources different algorithms perform better worse different conditions 
adaptive algorithms designed combine best attributes different algorithms monitoring particular algorithm best correct algorithm correct time 
online reconfiguration developers create adaptive algorithms modular fashion separate components 
cases implementing adaptive algorithm may simple approach allows adaptive algorithms updated expanded system running 
independent algorithm developed separate component hot swapped appropriate 
interposed code perform monitoring allowing easy upgrades monitoring methodology paying performance penalties sampling 
section evaluates online reconfiguration provide adaptive page replacement 
specializing common case individual algorithms common code path simple implemented efficiently 
supporting complex uncommon cases implementa usenix annual technical conference usenix association tion difficult 
handle cases system online reconfiguration hot swap component specialized common case standard component handles cases 
way getting behavior statement top component implementations 
hot swapping approach separates implementations simplifying testing reducing internal states increasing performance reducing negative cache effects uncommon case code 
section evaluates online reconfiguration specialize exclusive access file supporting full sharing semantics necessary 
dynamic monitoring instrumentation gives developers administrators useful information face system anomalies introduces overheads unnecessary normal operation 
reduce overhead systems provide dynamic monitoring knobs turn instrumentation 
interposition allows monitoring profiling instrumentation added needed removed unnecessary 
addition reducing overhead normal operation interposition removes need developers guess probes useful ahead time 
probes generic timing function call counting number parallel requests component 
probes implemented avoiding code replication components 
application specific optimizations application specializations known way improving particular application performance knowledge held application :10.1.1.15.51:10.1.1.15.51
online reconfiguration application provide new specialized component swap existing component implementation 
allows applications optimize component system requiring system developers add explicit hooks replace 
third party modules increasingly common form online reconfiguration loadable kernel modules 
particularly open source oses linux common download modules web provide functionality specialized hardware components 
case linux module concept business benefit dynamically loaded module affected gnu public license 
businesses produce value adding kernel modules hardened security modules linux module interface may evolve initial focus supporting device drivers providing general api hot swapping code linux 
mechanisms described natural endpoint evolution transition begun worked linux developers implement kernel module removal scheme quiescence 
summary online reconfiguration powerful tool provide number useful benefits developers administrators applications system 
individual example implemented ways 
generic support interposition hot swapping support single infrastructure 
integrating infrastructure core os amenable subsequent change 
online reconfiguration support section discusses main requirements online reconfiguration 
components welldefined interfaces encapsulate functionality data 
second possible force active component quiescent state long complete state transfer 
third way transfer state existing component new component instance 
fourth possible update external component 
component boundaries system component self contained defined interface functionality 
clear component boundaries possible sure component completely interposed swapped 
example interposed wrapper counts active calls component notice calls unknown interfaces 
similarly component stores state externally safely swapped external data lead improper unpredictable behavior 
achieving clear component boundaries requires programming discipline code modularity 
object oriented language help 
components implemented objects encapsulating functionality data defined interface 
object boundaries help prevent confusing code data sharing resulting cleaner components maintainable code base 
may possible detect rule violations code analysis solution relies developer adherence programming discipline 
quiescent states component swapped system ensure active state component concluded 
quiescence active calls usenix association usenix annual technical conference change state transfered causing unpredictable behavior 
operating systems characterized event driven 
majority activity os represented serviced individual requests request having identifiable start 
nature leveraged implement number interesting synchronization algorithms 
associating idempotent changes system data structures epoch requests identify states data structure longer referenced 
example swing head pointer linked list chain nodes divide accesses list epochs 
epoch includes threads system active swing second epoch includes new threads begun swing 
new threads able access new chain nodes nodes old chain guaranteed longer threads epoch ended 
point old chain quiescent modified including deleted 
utilized style synchronization termed read copy update implement semiautomatic garbage collector hot swapping 
linux implement number optimization lock free module loading unloading 
key leveraging techniques able divide system short lived requests cheaply identifiable start 
nonpreemptive systems linux number key points system calls context switches identify start requests 
preemptable designed general techniques ensuring system requests handled short lived system threads 
thread creation termination identify start requests 
section describes thread generation mechanism determine quiescent states 
state transfer state transfer synchronizes state new component instance existing component 
complete successful state transfer information required proper component functionality packaged transfered 
requires old new component agree package format transfer mechanism 
schemes extending current support linux preemptive versions proposed 
single catch solution data set data usage vary component component 
variety packaging transfer mechanisms suited component 
impossible predict mechanisms common ones 
example upgraded component understand existing component detail 
transferring old component sufficient new component extract necessary state 
single mechanism exists state transfer system provide support mechanisms simplify implementation 
hot swapping mechanism provide negotiation protocol helps components decide efficient transfer mechanisms understood 
second components share common interface functionality understand single canonical data format 
ensuring component developers need implement state transfer functions working implementation canonical form 
external component interposed hot swapped external interface redirected new piece code wrapper interposition new component hot swapping 
calls routed new code external original component updated 
counting indirection common ways handle 
counting garbage collection tracks component single client 
component changes tracked updated 
drawback counting overhead grows linearly number component 
hand indirection requires point single indirection pointer 
update client object system needs update single indirection pointer client 
similarly globally accessible object swapped indirection pointer client object updated 
space performance efficient small constant overhead component client 
drawback programmer aware indirection account counting handled transparently 
orthogonal safety issues focus mechanics online reconfiguration 
orthogonal issues safety usenix annual technical conference usenix association security related deciding reconfigurations permit containing suspect extensions :10.1.1.142.6054:10.1.1.142.4909
researchers addressed issues different proposals 
implementation described section guarantees safety reconfiguration 
prior techniques ensuring safety see section applied implementation 
online reconfiguration section describes integration online reconfiguration operating system 
overviews describes features details implementations interposition hot swapping 
open source research os cache coherent bit multiprocessor systems 
uses object oriented design achieve performance scalability maintainability 
supports linux api abi allowing unmodified linux applications libraries 
system fully functional bit applications run codes ranging scientific applications complex benchmarks sdet significant subsystems apache 
virtual resource instance particular file open file instance memory region implemented combining set objects 
example global page cache file independent object caches blocks file 
believe online reconfiguration useful general systems object oriented nature particularly platform exploring fine grained hot swapping interposition 
support mechanisms requirements online reconfiguration addressed follows 
component boundaries object oriented approach naturally maps system component language object 
requires external interface component defined virtual base class implementations component 
programmer convention enforces required component boundaries significant burden developers 
quiescent states employs technique similar discussed section establish quiescent states object 
system requests serviced new system thread 
requests divided epochs partitioning threads 
specifically pos sible determine threads existence processor specific instance time terminated 
maintains thread generations threads assigned 
generation records number threads active assigned 
time generations identified current generation new threads assigned 
determine current threads terminated algorithm non current generation count current generation wait zero current generation process switching current generation called generation swap 
algorithm illustrates generation swaps required establish current set threads terminated 
mechanism timely accurate face preemption design long lived system threads rely blocking system level threads 
note actual implementation wait implemented call back mechanism avoiding busy wait 
state transfer leaves implementation individual state transfer methods developer 
assist state transfer negotiation online reconfiguration mechanism provides transfer negotiation protocol 
set functionally compatible components set state transfer protocols form union possible state transfers components 
component developers create prioritized list state transfer protocols supports 
example may best pass internal structures memory copying entire structure components understand structure possible 
initiating hot swap requests lists old new component instances 
determining desirable format lists requests correct package format old component passes new component 
new component data transfer complete 
external uses client object translation table provide layer indirection accessing system components 
object instance design supports arbitrary number generations currently 
usenix association usenix annual technical conference caller object translation table 
interposition 
component caller object translation table 
interposition 
wrapper component component interposition 
shows steps component interposition 
shows callers access components object translation table 
case calls caller lookup component object translation table call component indirection 
shows interposed component 
case caller indirection points call generic 
calls wrapper original component call wrapper 
created entry created object translation table clients accessing external calls component 
perform hot swap interposition component updating entry appropriate tables 
incurs extra pointer dereference component call object translation table benefits improved smp scalability outweigh overhead 
online reconfiguration remainder section describes utilizes system support features described provide interposition hot swapping 
interposition object interposition interposes additional functionality function calls existing object instance 
partition interposed functionality pieces wrapper object generic 
wrapper object contains specific code executed call object 
generic wraps interface object transparently calling functions wrapper object forwarding call original object 
wrapper object standard object calls 
suspect called original object function called 
calls wrapper maintain state function call flight collect statistical information modify call parameters return values 
usenix annual technical conference usenix association redirect calls original object generic replaces object object translation table 
handle arbitrary object interfaces leverages fact external call goes virtual function table 
generic replaces original object object translation table calls go virtual function table 
overloads method pointers virtual function table point single interposition method forcing external calls function 
interposition method handles calls wrapper object methods calling appropriate method original component shown 
determines original methods called allowing method specific wrappers 
handle arbitrary call parameters return values method ensure register stack state left untouched call forwarded original component 
odds requirement need store information normally kept stack original return address local variables 
resolve conflict allocates space required information heap keeps pointer callee saved register 
register value guaranteed preserved function calls control returned retrieve saved information 
information saved heap space include original return address original value callee saved register saved callee original caller 
division labor generic wrapper object chosen interposition method calls generic inter threads mediator forward 
new old threads mediator block 
usenix association usenix annual technical conference new old threads mediator transfer 
component hot swapping 
shows phases hot swapping forward block transfer 
forward phase new calls tracked forwarded system waits calls complete 
phase wait old threads system complete threads allowed forward progress 
block phase new calls blocked system waits tracked calls complete 
blocking tracked calls component phase minimizes blocking time 
transfer phase calls component blocked state transfer take place 
transfer complete blocked threads proceed new component old component garbage collected 
poser virtual function table 
wrapper combined parent inheriting specific case interposition method locate correct specialized internal interfaces 
unfortunately difficult compiler specified locations difficult determine run time 
separating wrapper avoid specializing interposition method wrapper located wrapper virtual function table 
detach interposed wrapper corresponding object replaces object translation table entry pointer original object 
object translation table updated incoming calls sent directly original object 
garbage collection wrapper happen band 
hot swapping object hot swapping mechanism builds interposition 
step hot swapping current object instance new object instance interpose mediator 
mediator swap objects ensure flight calls component quiescent state 
get state mediator goes phase process forward block transfer 
forward phase mediator tracks threads making calls component forwards call original component 
phase continues calls started call tracking began completed 
detect relies thread generation mechanism 
forward phase begins request establish quiescent state respect current new threads generation mechanism 
generation swaps generation mechanism calls back current threads guaranteed terminated 
illustrates forward phase 
mediator interposed may calls progress example call marked 
waiting quiescent state new calls tracked mediator 
phase begins generation mechanism indicates quiescent state achieved 
mediator begins blocked phase calls component tracked 
phase mediator temporarily blocks new incoming calls waits calls tracking complete 
exception incoming recursive calls blocking create deadlock 
tracked calls completed component quiescent state state transfer 
illustrates blocked phase 
case thread progress complete phase complete 
new calls blocked blocking recursive call create deadlock allowed continue 
simpler combine forward blocked phase blocking new calls immediately waiting generation mechanism indicate quiescent state require blocking threads system completed 
due event driven model thread lifetimes guaranteed short blocking overloaded component waiting thread system expire may reduce component availability system performance 
separating phases blocking dependent lifetime threads active component 
old tradeoff event model cross processor cross address space calls done new threads 
means cyclic external call chain result deadlock recursion caught 
developers careful create situations hot swapping mechanism prevents deadlock situations timeout retry mechanism 
timeout triggered times hot swap return failure 
component entered quiescent state mediator begins transfer phase 
phase mediator performs state transfer old new components updates object translation table entry point new component allows blocked calls continue new component 
set functionally compatible components share set state transfer protocols 
acceptable protocols specified bit vector returned component 
intersection vectors gives list potential protocols 
mediator determines best common format requesting protocol vector component choosing protocol corresponding highest common bit vector 
protocol decided mediator retrieves packaged state original component passes new component 
illustrates transfer phase 
old component quiescent state transfered new component 
completes unblocked sent new component 
point mediator detached old component destroyed 
summary online reconfiguration mechanisms handle call interception mediation transparently clients external interfaces separates complexities flight call tracking deadlock avoidance implementation component 
exception component state transfer online reconfiguration process require support component simplifying creation components wish take advantage interposition hot swapping 
described considerable effort gone ensuring interposition hot swapping mechanisms scalable efficient multiprocessor see details 
support systems section discusses generally online reconfiguration supported systems specifically changes additions re quired add support linux 
supporting online reconfiguration support mechanisms provide online reconfiguration useful reasons implemented online reconfiguration considered 
similar reasons support mechanisms exist systems 
discussed section object oriented design leads better code structure cleaner interfaces maintainable code modular approach improves scalability 
reason modular approaches object oriented designs increasingly common operating systems vfs layer unix shared libraries plug play device drivers loadable module support 
systems incrementally add modularity components system eligible online reconfiguration 
linux explicit support techniques described section 
establishing quiescent state required hot swapping straightforward 
support utilized implement number lock free synchronization algorithms just hot swapping 
linux support added facilitate independent lock free optimizations 
importantly linux illustrates fact approach hot swapping generalizes equally applicable traditional systems 
surprising event driven nature operating systems widely accepted fundamental property relies 
indirection leads added flexibility systems points indirection built 
example indirection vfs layer operating systems abstracts underlying file system implementation rest system isolating components system internals various file systems 
examples indirection include device drivers virtual memory systems 
having different styles points indirection standard level indirection introduced front objects 
directing object access indirection allows support complex multiprocessor optimizations preserving simple object oriented model 
allowed entertain hot swapping instance object 
existing systems uniform model indirection hot swapping applied components live level indirection vfs modules 
flex usenix annual technical conference usenix association indirection proves useful expect components utilize 
time standard support accessing components level indirection similar employed 
state transfer protocol clear additional benefits online reconfiguration mechanism attached particular design system 
adding final support mechanism system wished take advantage online reconfiguration straightforward adding 
online reconfiguration linux section examines requirements online reconfiguration discusses existing mechanisms add additional mechanisms linux support online reconfiguration 
component boundaries linux strictly modular design interface abstractions added support loadable modules places 
defined abstractions provide component boundaries required online reconfiguration 
quiescent states years number patches developed linux add support mechanisms 
support leveraged number optimizations including adding lock free lookups dentry cache supporting hot plugging cpus safe module loading unloading scalable file descriptor management lookups ipv route cache 
linux kernel integrated support main line version 
infrastructure utilized identify necessary quiescent state done 
state transfer boundaries module state defined linux state transfer similar 
transfer negotiation protocol applied linux 
external linux module abstraction provide component boundaries handle external 
modules lie virtual interface updating pointers interface required replace module 
example replacing file system module individual pieces file system functionality done replacing appropriate function pointers file system vfs layer 
evaluation section evaluate flexibility performance online reconfiguration 
quantify overheads latencies interposition 
second illustrate flexibility online reconfiguration implement number known dynamic performance enhancements 
experimental setup experiments run different machines 
rs ibm powerpc bus cache coherent multiprocessors 
enterprise server mhz rs iv processors gb main memory 
workstation mhz power processors mb main memory 
specified results enterprise server 
evaluation separate benchmarks postmark sdet 
postmark designed model combination electronic mail netnews web commerce transactions 
creates large number small files performs specified number transactions 
transaction consists randomly chosen pairing file creation deletion file read append 
random biases number files transactions file size range specified parameter settings 
specified files transactions file sizes ranging kb biases 
sdet executes scripts user commands designed emulate typical software development environment editing compiling various unix utilities 
scripts generated predetermined mix commands executed concurrently 
extensive file system subsystems making useful scalability benchmarking 
section refer way sdet describes running concurrent scripts machine configured processors 
basic overheads normal operation overhead online reconfiguration indirection update external 
done object translation table virtual function table 
overhead object translation table single memory load data cached frequently run compile assembly link phases sdet time gcc executing bit platform unable generate correct bit powerpc code usenix association usenix annual technical conference operation seconds attach component call detach table overhead 
costs interposition attach call detach 
attaching involves initializing wrapper updating object translation table 
calls component involve additional method calls wrapper object heap allocation 
involves updating object translation table making cost component callers zero additional wait time process performing detach pay overhead destroying objects 
average cost operation listed microseconds standard deviation 
accessed objects 
overhead dispatching virtual function call approximately cycles 
remainder overheads online reconfiguration specific implementations interposition hot swapping 
overheads measured workstation 
interposition performance costs interposition attaching wrapper calling wrapper opposed instrumenting component directly wrapper 
measure costs attached called detached empty wrapper times calculating average time operations 
empty wrapper performs operations simply returning call overhead due interposition 
table lists costs interposition 
attaching expensive operation involving memory allocation object initialization point attach incoming calls blocked 
requires updating object translation table teardown wrapper listed overhead process performing detach 
simple optimization component calls skip possible 
doing removes expensive memory allocation state kept forwarded call control returned directly original caller 
hot swapping file cache manager objects track core pages individual files system 
determine expected performance perform null hot swap fcm swapping points high system contention running way sdet 
contention detected threads accessing fcm concurrently 
high system contention worst time swap threads block increasing number hot swaps time null swap 
presents histogram showing cost performing null swap fcm module contended points system execution 
bin count number swaps completion times fell bin 
average swap took complete swap took longer duration mediation phases important understand sort worst case swapping scenario 
single run way sdet system detected points high contention 
average time perform hot swap points standard deviation minimum maximum 
hot swapping system contention efficient forward block phases shorter 
performing random null way sdet run gave average hot swap time time spent doing hot swap spent waiting generation advance threads blocked affect hot swaps throughput sdet negligible 
reconfiguration performance section evaluates online reconfiguration flexibility implement known adaptive performance enhancements 
algorithms known focus section adaptive decisions fact online reconfiguration quickly efficiently implement 
single replicated experiment uses online reconfiguration hot swap different component implementations different workloads 
fcm implementations single fcm designed replicated fcm designed scale number processors 
single fcm uses memory pay performance penalty cross processor accesses 
replicated fcm creates instances processor accessed usenix annual technical conference usenix association normalized single replicated single postmark way sdet single replicated 
shows different fcm implementations run different workloads 
postmark single access fcm performs better memory overhead creation deletion files 
conversely replicated fcm performs better way sdet scales multiple processors 
cost additional memory 
shows performance fcm postmark files transactions file sizes ranging kb way sdet 
postmark single application acts large number temporary files overhead doing additional memory allocations file replicated fcm causes drop performance 
hand replicated fcm concurrent sdet benchmark gives performance improvements scale way sdet way sdet 
replicated fcm helps sdet scripts run separate processors share part working set 
detects multiple threads accessing single file hot swaps fcm implementations appropriate 
approach achieves best performance workloads 
exclusive shared file sessions experiment uses online reconfiguration swap efficient non shared component default shared component correctness 
file handle implementation resides entirely application 
improves performance application exclusive access file 
file sharing begins server implementation swapped maintain shared state 
shows performance swapping shared access version necessary postmark 
accesses postmark exclusive performance improvement achieved 
small large files experiment uses online reconfiguration hot swap specialized non default exclusive small file cache usenix association usenix annual technical conference transactions second common case optimization 
online reconfiguration cache exclusive file handles application swap shared implementation necessary correctness 
enhancement cache small exclusive files application address space 
compares system configurations default exclusive small file cache postmark 
online reconfiguration exclusive case shows performance small file caching shows additional improvement 
shared component default shared component 
general file data cached operating system access small exclusive files kb improved caching file data application address space 
incurs memory overhead double caching file application os acceptable small files leads improved performance 
shows postmark performance schemes default configuration exclusive caching scheme application side caching 
hot swapping caching implementations gives additional performance improvement exclusive access optimization 
originally implemented traditional adaptive approach hard coding decision process implementations single component 
anecdotally reimplementing online reconfiguration simplified clarified code time consuming implement debug 
adaptive page replacement experiment uses online reconfiguration implement adaptive page replacement algorithm 
interposed wrapper object watches fcm sequential page mappings 
sequence pages requested access deemed sequential system hot swaps sequentially optimized fcm approximates mru page replacement 
sequential behavior ends non sequential pages requested fcm swapped back default fcm 
shows performance way sdet way sdet throughput scripts hour default fcm adaptive fcm number concurrent background streams sequential page faults 
adaptive page replacement algorithm performs mru page replacement sequential streams 
reduces amount memory wasted streams pages accessed 
online reconfiguration detect sequential streams swap sequentially optimized fcm 
compares default page replacement adaptive algorithm running way sdet concurrently number streaming applications 
adaptive page replacement system degrades slowly reducing effect streaming applications performance entire system 
face competing streaming applications run nfs 
streaming applications access files significantly larger mb main memory available workstation experiment 
default fcm streaming applications quickly fill page cache useless pages incurring pager overhead immediately 
sdet performance 
hand adaptive approach sequential applications consume little memory throw away pages shortly 
sdet performance degrade slowly meaning streaming applications run achieving performance default fcm 
related modifying code running system powerful tool explored variety contexts 
simplest common example adding new code running system dynamic linking 
shared library updated programs dependent library automatically updated run 
possible update code running systems shared libraries application provide support handle aspects update loading code memory 
online reconfiguration methods exist middleware community realm oses due increased constraints timing resources 
identifying implementing online reconfiguration mechanism works os major contributions 
hj lmt gray describe mechanism dynamic objects :10.1.1.109.1634:10.1.1.109.1634
objects creating quiescent state 
achieve provide options 
old objects continue exist service requests new requests go new object 
requires form coordination state existing objects 
second object destroyed active threads object lost 
reason clients object able detect broken binding retry request 
corba dce rmi com application architectures support component replacement program execution 
architectures leave problems quiescence state transfer application providing mechanism updating client 
pu describe mechanism incremental optimistic specialization assume thread executing swappable module time 
constraint relaxed non scalable 
addition done different reconfiguration mechanisms groups applied online reconfiguration systems achieved variety benefits 
different adaptive techniques implemented improve system performance :10.1.1.44.6409
extensible operating systems shown performance benefits number interesting applications :10.1.1.100.6047
technologies compiler directed prefetching storage latency estimation descriptors improve application performance detailed knowledge state system structures 
incremental optimistic specialization remove unnecessary logic common case accesses 
online reconfiguration simplify implementation improvements removing complicated task instrumenting os necessary hooks reconfiguration case case basis 
operating system object oriented design 
object oriented designs helped organization extensibility reflection persistence decentralization 
addition method detecting quiescent state unique 
sequent similar mechanism detecting quiescent state linux integrated mechanism detecting quiescence kernel modules 
usenix annual technical conference usenix association open issues prototype provides solid base numerous os enhancements number open issues expand utility online reconfiguration 
section describes number issues addressed systems 
object creation management performance upgrade security patch released particular component implementation instance component hot swapped 
additionally place instance component created updated create new component type old 
common solution object factory responsible creating managing objects system 
upgrade requested factory responsible locating upgrading instance 
similar solution garbage collector track update objects :10.1.1.161.3137
coordinated swapping hot swapping individual components provide benefits times components swapped 
example architecture reconfiguration updates interfaces objects swap objects concurrently 
different groups looked perform ensuring correctness :10.1.1.135.2437
confirming component functionality requires swapped components support interface guarantees functionality provided components 
may possible components provide annotations functionality show type safety component validity proven generally undecidable :10.1.1.161.3137
systems tradeoff flexibility provable component correctness 
common method improving component correctness type safety 
unfortunately generally reduces flexibility performance potential reconfigurations 
dynamic ml provides type safety guarantees components unchanging external interfaces reliance space copying garbage collector unreasonable operating system environment :10.1.1.161.3137
hicks provides type safety guarantees components external data changing interfaces relies programmer defined safe swap points requires instance component swapped versions component exist system :10.1.1.135.2437:10.1.1.135.2437
interface management currently online reconfiguration requires swapped components support interface 
straightforward expand interfaces old interface subset new interface currently possible reduce interfaces particular possible know active code path system relies particular part interface 
systems looked allowing interface changes programmer defined safe points updates provide necessary information component usage :10.1.1.161.3137:10.1.1.135.2437
generic state transfer hot swapping mechanism provides protocol negotiating best common format state transfer objects 
relies support components swapped complete state transfer 
increasingly complex number implementations increases ideal infrastructure perform entire state transfer making hot swapping entirely transparent 
goal may fully attainable may possible provide support currently 
example hicks examines possibility automatically generating state transformation functions simple cases :10.1.1.135.2437
avoiding quiescence may possible instantiate new object start processing calls old object completes calls flight 
cases require way maintain coherence states objects cases may possible lazy update new object state flight calls completed 
online reconfiguration provides underlying mechanism component extension replacement interposition hot swapping 
mechanisms leveraged provide variety dynamic os enhancements 
identifies support mechanisms interposition hot swapping describes implementation operating system 
demonstrate flexibility online reconfiguration implementing adaptive paging algorithm common case optimizations workload specific specialization 
large community contributed project years helped get system state research possible 
craig soules supported usenix fellowship 
jonathan supported ibm fellowship 
usenix association usenix annual technical conference accetta baron bolosky golub rashid tevanian young 
mach new kernel foundation unix development 
summer usenix technical conference july 

adaptive algorithms managing distributed data processing workload 
ibm systems journal 
auslander silva krieger wisniewski 
providing linux api scalable kernel 
page appear 
hui stumm wisniewski silva krieger soules infrastructure multiprocessor run time adaptation 
acm sigsoft workshop self healing systems 
acm 
auslander franke krieger stumm 
customization lite 
hot topics operating systems pages 
ieee 
bennett 
distributed smalltalk reactiveness distributed systems 
phd thesis published 
department computer science university washington december 
bershad savage sirer fiuczynski becker chambers eggers 
extensibility safety performance spin operating system 
acm symposium operating system principles 
published operating systems review december 

dynamic reconfiguration service corba 
international conference configurable distributed systems pages 
ieee computer society press 
bloom 
dynamic module replacement distributed programming system 
phd thesis published mit lcs tr 
massachusetts institute technology cambridge ma march 
brown mowry krieger 
compiler prefetching core applications 
acm transactions computer systems 
acm 
campbell 
tan 
choices object oriented multimedia operating system 
hot topics operating systems pages 
ieee computer society may 
cardelli donahue glassman jordan kalsow nelson 
modula report revised 

digital equipment systems research center palo alto ca november 
distributed component object model protocol dcom www microsoft com com resources asp 
cook lee 
dynamic modification system 
pages 
dasgupta leblanc jr ahamad ramachandran 
clouds distributed operating system 
ieee computer november 
duggan 
type hot swapping running modules 
technical report sit cs 
october 
engler chen hallem chou chelf 
bugs deviant behavior general approach inferring errors systems code 
acm symposium operating system principles 
acm 
engler gupta kaashoek 
avm application level virtual memory 
hot topics operating systems pages 
ieee computer society may 
engler kaashoek jr exokernel operating system architecture application level resource management 
acm symposium operating system principles 
published operating systems review december 
fiuczynski bershad 
extensible protocol architecture application specific networking 
usenix 
annual technical conference pages 
usenix 
assoc 
krieger stumm 
tornado maximizing locality concurrency shared memory multiprocessor operating system 
symposium operating systems design implementation pages february 
ganger engler kaashoek hunt 
fast flexible application level networking exokernel systems 
acm transactions computer systems 
acm february 
gilmore walton :10.1.1.161.3137
dynamic ml dynamic types 
technical report ecs lfcs 
june 

shared libraries 
unix review august 
glass cao 
adaptive page replacement memory behavior 
acm sigmetrics conference measurement modeling computer systems 
gosling 
java language environment 
technical report 
october 
grimshaw wulf team 
legion vision worldwide virtual computer 
communications acm 
acm press january 
guardian digital www com 
gupta barua 
formal framework line software version change 
ieee transactions software engineering 
ieee february 
hicks moore nettles :10.1.1.135.2437
dynamic software updating 
acm sigplan conference programming language design implementation 
acm 
gray :10.1.1.109.1634
dynamic classes lightweight mechanism update code running program 
annual usenix technical conference pages 
usenix association 
operating system www research ibm com 
katcher 
postmark new file system benchmark 
technical report tr 
network appliance october 
kon costa blair campbell 
case reflective middleware 
communications acm 
acm press 
li 
tan chen campbell 
disk scheduling dynamic request priorities 
technical report 
university illinois urbana champaign il august 
mckenney sarma krieger russell 
read copy update 
ottawa linux symposium 
mckenney 
read copy update execution history solve concurrency problems 
international conference parallel distributed computing systems 
mcnamee walpole pu cowan goel wagle consel muller marlet 
specialization tools techniques systematic optimization system software 
acm transactions computer systems tocs 
acm press 
meter gao 
latency management storage systems 
symposium operating systems design implementation pages 
usenix association 
mosberger peterson bridges malley 
analysis techniques improve protocol processing latency 
acm sigcomm conference 
published computer communication review 
acm 
necula lee 
safe kernel extensions run time checking 
symposium operating systems design implementation pages 
usenix association berkeley ca october 
distributed computing environment overview 
osf dce pd 
open software foundation may 
pu black consel cowan inouye walpole zhang 
optimistic incremental specialization streamlining commercial operating system 
acm symposium operating system principles 
published operating systems review december 
read copy update mutual exclusion linux lse sourceforge net locking html 
posting linus linux kernel mailing list summary changes form marc com 
java remote method invocation distributed computing java november 
java sun com marketing collateral html 
russo 
object oriented operating system 
phd thesis published uiucdcs 
department computer science university illinois urbana champaign january 
security enhanced linux www nsa gov index html 
seltzer endo small smith 
architecture vino kernel 
technical report 

seltzer endo small smith 
dealing disaster surviving misbehaved kernel extensions 
symposium operating systems design implementation pages 
usenix association berkeley ca october 
stankovic ramamritham 
spring kernel new paradigm real time operating systems 
operating systems review july 
wahbe lucco anderson graham 
efficient fault isolation 
acm symposium operating system principles 
published operating systems review 
acm 
wallach engler kaashoek 
applicationspecific handlers high performance messaging 
acm sigcomm conference august 

reflective operating system concept implementation 
object oriented programming systems languages applications pages 
usenix annual technical conference usenix association 
