published proceedings th usenix security symposium security pages august washington dc usa 
static analysis executables detect malicious patterns mihai jha mihai cs wisc edu jha cs wisc edu computer sciences department university wisconsin madison malicious code detection crucial component defense mechanism 
unique viewpoint malicious code detection 
regard malicious code detection obfuscation game malicious code writers researchers working malicious code detection 
malicious code writers attempt obfuscate malicious code subvert malicious code detectors anti virus software 
tested resilience commercial virus scanners code obfuscation attacks 
results surprising commercial virus scanners subverted simple obfuscation transformations 
architecture detecting malicious patterns executables resilient common obfuscation transformations 
experimental results demonstrate efficacy prototype tool safe static analyzer executables 
interconnected world computers malicious code omnipresent dangerous threat 
malicious code hosts variety methods attacks known software flaws hidden functionality regular programs social engineering 
devastating effect malicious code cyber infrastructure identifying malicious programs important goal 
detecting presence malicious code host crucial component defense mechanism 
malicious code usually classified propagation method goal categories viruses programs self replicate host attaching programs documents carriers malicious code worms self replicate network trojan horses masquerade useful programs contain malicious code attack system leak data back doors open system external entities sub supported part office naval research contracts 
government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notices affixed thereon 
views contained authors interpreted necessarily representing official policies endorsements expressed implied government agencies government 
local security policies allow remote access control network useful software package transmits private user data external entity 
combining malicious code categories lead powerful attack tools 
example worm contain payload installs back door allow remote access 
worm replicates new system email means back door installed system providing attacker quick easy way gain access large set hosts 
staniford demonstrated worms propagate extremely quickly network potentially entire cyber infrastructure 
outbreak sapphire sql slammer worm reached peak infection rate minutes launch doubling seconds 
backdoor tool gains large installed base attacker compromised hosts launch coordinated attack distributed denial service ddos attack 
develop methodology detecting malicious patterns executables 
method general initially focused attention viruses 
computer virus replicates inserting copy code viral code host program 
user executes infected program virus copy runs infects programs original program continues execute 
casual user perceived difference clean copies program virus activates malicious payload 
classic virus detection techniques look presence virus specific sequence instructions called virus signature inside program signature highly probable program infected 
example virus detected checking hexadecimal sequence fe cfa corresponds ia instruction sequence constitutes part virus body call pop ebx lea ecx ebx push ecx push eax push eax fe esp pop ebx add ebx ch fa cli mov ebp ebx classic detection approach effective virus code change significantly time 
detection easier viruses originate source code minor modifications updates 
virus signature common virus variants 
example versions differ mainly trigger date malicious code active effectively detected scanning single signature shown 
virus writers antivirus software developers engaged obfuscation game 
virus writers try obfuscate vanilla virus signatures antivirus software detect morphed viruses 
detect obfuscated virus virus scanners undo obfuscation transformations virus writers 
game virus writers researchers working malicious code detection 
method detect malicious code resistant common obfuscation transformations 
introduces method 
main contributions include obfuscation game attacks commercial virus scanners view malicious code detection game virus writers researchers working detect malicious code 
back ground common obfuscation techniques virus writers section 
developed obfuscator executables 
surprisingly commercial virus scanners considered easily thwarted simple obfuscation transformations section 
example cases norton antivirus scanner detect insertions nop instructions 
general architecture detecting malicious patterns executables introduce general architecture detecting malicious patterns executables 
overview architecture novel features section 
external predicates uninterpreted symbols important elements architecture 
external predicates summarize results various static analyses points live range analysis 
allow external predicates referred abstraction patterns describe malicious code 
allow uninterpreted symbols patterns method resistant renaming common obfuscation transformation 
key components architecture program annotator malicious code detector described sections respectively 
prototype executables implemented prototype detecting malicious patterns executables 
tool called static analyzer executables safe 
successfully tried safe multiple viruses brevity report experience specific viruses 
experimental results section demonstrate efficacy safe 
interesting directions intend pursue summarized section 
extensibility analysis safe depends heavily static analysis techniques 
result precision tool directly depends static analysis techniques integrated 
words safe static analysis techniques built 
example safe uses result points analysis able track values memory 
absence pointsto analyzer safe conservative assumption memory access memory location points 
designed safe various static analysis techniques readily integrated 
simple static analysis techniques implemented safe 
related theoretical discussion theoretical limits malicious code detection specifically virus detection focus researchers 
cohen chess white showed general problem virus detection undecidable 
similarly important static analysis problems undecidable computationally hard 
problem considered slightly different considered cohen chess white 
assume vanilla virus contains malicious sequence instructions 
obfuscated version virus 
problem find exists sequence instructions semantically equivalent 
result proves general program obfuscation impossible 
leads believe computationally bounded adversary able obfuscate virus completely hide malicious behavior 
explore theoretical issues 
detection techniques closely related previous results static analysis techniques verifying security properties software 
larger context similar existing research software verification 
important differences 
viewing malicious code detection obfuscation game unique 
obfuscation viewpoint lead explore obfuscation attacks commercial virus scanners 
second knowledge existing static analysis techniques verifying security properties analyze source code 
hand analysis technique works executables 
certain contexts virus detection source code available 
believe uninterpreted variables specification malicious code unique section 
currie looked problem automatically checking equivalence dsp routines context verifying correctness optimizing transformations 
approach similar impose set simplifying assumptions simulation tool execute reasonable performance 
feng hu took approach step theorem prover determine unroll loops 
cases scope problem limited vliw dsp code limited support userspecified analyses 
applied ia assembly take full advantage static analyses available user safe tool 
necula adopts similar approach comparing transformed code sequence original code sequence setting verifying correctness gnu compiler 
knowledge transformations performed compiler equivalence com piler input compiler output proven simulation relation 
require priori knowledge obfuscation transformations performed unrealistic expect information presence malicious code 
plan enhance framework ideas existing type systems assembly code 
currently investigating morrisett typed assembly language 
apply simple type system section binaries analyze manually inserting type annotations 
unaware compiler produce typed assembly language plan support external type annotations enhance power static analysis 
dynamic monitoring malicious code detection 
cohen chess white propose virus detection model executes code sandbox 
approach rewrites binary introduce checks driven enforceable security policy known inline monitor irm approach 
believe static analysis improve efficiency dynamic analysis techniques static analysis remove redundant checks irm framework 
construct models executables similar done specification monitoring apply detection algorithm context insensitive fashion 
research context sensitive analysis employing push systems 
analyses described model checking algorithms pushdown systems verify security properties programs 
data structures interprocedural slicing interprocedural dfa boolean programs hierarchically structured graphs translated pushdown systems :10.1.1.50.4405
deciding initial obfuscation techniques focus influenced existing tools 
library binary obfuscation specifically written blend malicious code host program 
encrypt morph blend virus code host program 
binary obfuscator similar 
unfortunately successfully morph binaries perform direct comparison obfuscator 
linux binary encapsulation tool 
encrypts binary possibly multiple times packages new binary extraction tool 
considered encryption obfuscation techniques 
incorporate encryption obfuscation techniques tool incorporating extending existing libraries 
background obfuscating viruses detect obfuscated viruses antivirus software complex 
section discusses common obfuscation transformations virus writers antivirus software historically dealt obfuscated viruses 
polymorphic virus uses multiple techniques prevent signature matching 
virus code encrypted small clear routine designed decrypt code running virus 
polymorphic virus replicates infecting program encrypts virus body key changes decryption routine generating new code 
obfuscate decryption routine transformations applied 
include nop insertion code transposition changing order instructions placing jump instructions maintain original semantics register reassignment permuting register allocation 
transformations effectively change virus signature inhibiting effective signature scanning antivirus tool 
obfuscated code behave manner nop instruction effect incrementing program counter signature changed 
analysis detect simple nop insertion regular expressions fixed signatures 
catch nop insertions signature allow number instruction boundaries 
fact modern antivirus software regular expressions virus signatures 
antivirus software deals polymorphic viruses performing heuristic analyses code checking certain program locations virus code polymorphic viruses attach executable binary emulating program sandbox catch virus action 
emulation technique effective point execution infected program virus body appears decrypted main memory ready execution detection comes frequently scanning memory image program virus signatures program executes 
metamorphic viruses attempt evade heuristic detection techniques complex 
replicate viruses change code variety ways code transposition substitution equivalent instruction sequences register reassignment 
furthermore weave virus code host program making detection traditional heuristics impossible virus code mixed program code virus en try point longer program designated entry point obscuring epo viruses 
virus writers employ complex obfuscation techniques heuristic virus detection techniques bound fail 
need perform deeper analysis malicious code sophisticated static analysis techniques 
words inspection code detect malicious patterns structures closer semantics code purely syntactic techniques regular expression matching longer adequate 
suite viruses analyzed multiple viruses tool discuss 
descriptions viruses 
detailed description viruses symantec antivirus reseach center virus infects bit windows nt executable files 
user executes infected program windows virus resident memory 
virus resident infects files accessed 
infected files may size original files unique mode infection virus searches empty unused spaces file breaks smaller pieces inserts code unused spaces 
different payloads overwrites hard disk random data starting disk sector infinite loop 
second payload tries cause permanent damage computer corrupting flash bios 
zombie virus includes interesting feature polymorphic engine hides piece virus virus code added infected file chain differently sized routines making standard signature detection techniques useless 
sf sf virus uses polymorphic engine combined epo technique hide entry point 
labs infected file run virus code gains control searches portable executable files system directories infects 
infecting virus encrypts polymorphic loop writes result file 
gain control infected file run virus modify program start address writes jmp virus entry instruction middle file 
original code obfuscated code call call pop ebx pop ebx lea ecx ebx lea ecx ebx push ecx nop push eax push ecx push eax push eax fe esp push eax pop ebx nop add ebx ch fe esp fa cli pop ebx mov ebp ebx add ebx ch nop fa cli mov ebp ebx signature new signature fe cfa fe fa original code obfuscated code corresponding signatures 
newly added instructions highlighted 
fe fa extended signature insertion 
hare hare virus infects sectors floppy disks hard drives executable programs 
payload triggered virus overwrites random sectors hard disk making data inaccessible 
virus spreads polymorphically changing decryption routine encrypting main body 
hare viruses known antivirus community presence wild peaking respectively 
spite discovered current commercial virus scanners detect slightly obfuscated versions viruses 
obfuscation attacks commercial virus scanners tested commercial virus scanners common obfuscation transformations 
test resilience commercial virus scanners common obfuscation transformations developed obfuscator binaries 
obfuscator supports common obfuscation transformations dead code insertion code transposition register reassignment instruction substitution 
generic cation techniques described preferred malicious code writers possibly implementing easy add little memory footprint 
common obfuscation transformations dead code insertion known trash insertion dead code insertion adds code program modifying behavior 
inserting sequence instructions simplest example 
interesting involve constructing challenging code sequences modify program state restore immediately 
code sequences designed fool antivirus software solely rely signature matching detection mechanism 
code sequences complicated automatic analysis timeconsuming impossible 
example passing values memory registers stack requires accurate pointer analysis recover values 
example shown clarify 
code marked easily eliminated automated analysis 
hand second third insertions marked cancel analysis complex 
obfuscator supports dead code insertion 
dead code sequence detected eliminated problem reduces program equivalence code sequence equivalent empty program undecidable 
believe common dead code sequences detected eliminated acceptable performance 
quote docu mentation virus permutation engine program complex 
detecting algorithm written think difference nop complex trash 
detection tool safe identifies kinds dead code segments 
code transposition code transposition shuffles instructions order binary image different execution order order instructions assumed signature antivirus software 
achieve variation randomly reorder instructions insert unconditional branches jumps restore original control flow 
second variation swaps instructions interdependent similar compiler code generation different goal randomizing instruction stream 
versions obfuscation technique differ complexity 
code transposition technique unconditional branches relatively easy implement 
second technique interchanges independent instructions complicated independence instructions ascertained 
analysis side code transposition complicate matters human 
automatic analysis tools including intermediate representation control flow graph cfg program dependence graph pdg sensitive superfluous changes control flow :10.1.1.50.4405
note optimizer acts deobfuscator case finding unnecessary unconditional branches removing program code 
currently obfuscator supports code transposition inserting unconditional branches 
register reassignment register reassignment transformation replaces usage register specific live range 
technique exchanges register names effect program behavior 
example register ebx dead live range register eax replace eax live range 
certain cases register reassignment requires insertion prologue epilogue code live range restore state various registers 
binary obfuscator supports code transformation 
purpose transformation subvert antivirus software analyses rely 
real value gained process 
conceptually challenge equally complex register reassignment 
instruction substitution obfuscation technique uses dictionary equivalent instruction sequences replace instruction sequence 
transformation relies human knowledge equivalent instructions poses challenge automatic detection malicious code 
ia instruction set especially rich provides ways performing operation 
coupled architecturally ambivalent features memory stack accessed stack dedicated instructions memory area standard memory operations ia assembly language provides ample opportunity instruction substitution 
handle obfuscation instruction substitution analysis tool maintain dictionary equivalent instruction sequences similar dictionary generate 
comprehensive solution cope common cases 
case ia problem slightly simplified simple intermediate language unwinds complex operations corresponding ia instruction 
cases theorem prover simplify pvs prove sequences instructions equivalent 
testing commercial antivirus tools tested commercial virus scanners obfuscated versions viruses described earlier 
results quite surprising combination nop insertion code transposition create obfuscated versions viruses commercial virus scanners detect 
norton antivirus software detect obfuscated version virus just 
safe resistant obfuscation transformations 
results summarized table 
indicates antivirus software detected virus 
means software detect virus 
note versions viruses detected tools 
architecture section gives overview architecture safe 
subsequent sections provide detailed descriptions major components safe 
detect malicious patterns executables build representation malicious code virus 
representation generalization malicious code incorporates obfuscation transformations superfluous changes code obfuscated code obfuscated code obfuscated original code dead code insertion code transposition instruction substitution call call call call pop ebx pop ebx pop ebx pop ebx lea ecx ebx lea ecx ebx jmp lea ecx ebx push ecx nop push eax sub esp push eax nop push eax esp push eax push ecx esp add esp ch esp push eax jmp mov ebx esp pop ebx eax add ebx ch esp add ebx ch push eax jmp cli cli dec esp lea ecx ebx mov ebp ebx mov ebp ebx dec eax push ecx esp jmp pop ebx pop ebx add ebx ch cli cli jmp mov ebp ebx mov ebp ebx examples obfuscation dead code insertion code transposition instruction substitution 
newly added instructions highlighted 
sf hare considered norton mcafee command antivirus antivirus safe original obfuscated original obfuscated original obfuscated original obfuscated nop insertion form dead code insertion code transposition table results testing various virus scanners obfuscated viruses 
control flow register 
similarly construct representation executable trying find malicious pattern 
generalization malicious code representation executable created detect malicious code executable 
describe component safe 
generalizing malicious code building malicious code automaton malicious code generalized automaton uninterpreted symbols 
uninterpreted symbols section provide generic way representing data dependencies variables specifically referring storage location variable 
pattern definition loader component takes library abstraction patterns creates internal representation 
abstraction patterns alphabet symbols malicious code automaton 
executable loader component transforms executable internal representation collection control flow graphs cfgs program procedure 
executable loader uses shelf components ida pro codesurfer 
ida pro commercial interactive disassembler 
codesurfer program understanding tool performs variety static analyses 
codesurfer provides api access various structures cfgs call graph results variety static analyses points analysis 
collaboration developed connector transforms ida pro internal structures intermediate form codesurfer parse 
annotator component inputs cfg executable set abstraction patterns produces annotated cfg representation program procedure 
annotated cfg includes information indicates specific abstraction pattern executable 
annotator runs procedure program transforming cfg 
section describes annotator detail 
pattern definitions binary executable malicious code automaton ida pro static analyzer executables safe pattern definition loader executable loader intermediate form patterns cfg executable annotator malicious code trace program architecture static analyzer executables safe 
executable loader connector codesurfer implementation executable loader module 
detector component computes malicious code represented malicious code automaton appears representation executable created annotator 
component uses algorithm language containment unification 
details section 
rest malicious code fragment shown running example 
code fragment extracted virus version 
obtain obfuscated code fragment depicted applied obfuscation transformations dead code insertion code transposition register reassignment 
incidentally commercial antivirus software norton mcafee command detected original code fragment shown 
obfuscated version detected commercial antivirus software 
program annotator section describes program annotator detail data structures static analysis concepts detection algorithm 
program annotator inputs cfg executable set abstraction patterns outputs annotated cfg 
annotated cfg associates node cfg set patterns match program point corresponding node precise syntax abstraction original code annotated cfg detector mov eax dr mov ebx eax mov edi eax pop ecx mov esi ecx mov eax pop edx pop ecx call edi jmp pop ebx pop eax stc original code fragment virus version 
pattern semantics matching provided section 
shows cfg simple annotated cfg corresponding obfuscated code 
note node annotated cfg correspond nodes original cfg 
example nodes annotated corresponds instructions 
annotations appear intuitive formulating static analysis framework requires formal definitions 
enhance safe framework type system typestate system described 
type systems designed assembly languages typed assembly language safe framework 
definitions patterns matching procedure described sections respectively 
obfuscated code mov eax dr jmp loc loc mov edi eax pop ecx nop mov esi ecx nop nop mov eax jmp loc loc mov ebx eax jmp loc loc pop edx pop ecx nop call edi jmp pop ebx pop eax push eax pop eax stc obfuscated version code 
basic definitions section provides formal definitions rest 
program points instruction function application 
type system preclude higher order functions function composition important note assembly languages including support concepts 
program sequence instructions 
program execution instructions processed sequential order appear program exception control flow instructions change sequential execution order 
index instruction program sequence called program point program counter denoted function pc 

defined pc ij def set program points program def 

pc function provides total ordering set program instructions 
control flow graph basic block maximal sequence instructions il 
im contains control flow instruction appear 
execution basic block definition sequential 
set basic blocks program set control flow transitions basic blocks 
edge marked corresponding condition true false edge followed 
unconditional jumps outgoing edges marked directed graph cf called control flow graph 
predicates predicates mechanism incorporate results various static analyses live range points analysis 
predicates definition abstraction patterns 
table lists predicates currently available system 
example code program points verified dead code section checking variable live program range value point value point 
change value program points denoted delta implemented polyhedral analysis 
explanations static analysis predicates shown table standard compiler textbook 
instructions data types type constructors build simple integer types listed ground class types allow array types variations pointer array type pointer middle array type structures unions pointers functions 
special types complete type system lattice 
represent types stored onn bits specific type specific type 
table describes constructors allowed type system 
type represents type field member structure 
field type independent types fields structure offset uniquely determines location field structure label identifies field structure cases label undefined 
physical subtyping takes account layout values memory :10.1.1.30.6614
type physical subtype denoted memory layout value type prefix memory layout value type 
describe rules physical subtyping refer reader xu thesis detailed account typestate system nop mov esi ecx nop nop mov eax jmp pop edx mov eax dr jmp mov ebx eax mov edi eax loop pop ecx pop ebx pop eax push eax pop eax stc pop ecx nop call edi jmp jmp loop assign esi ecx assign eax nop mov esi ecx nop nop mov eax pop edx pop ecx jmp assign eax dr assign ebx eax ecx pop edx edi pop ecx assign edi eax loop pop ecx pop ebx pop eax assign carry push flags nop call edi goto loop control flow graph obfuscated code fragment annotations 
mov eax dr jmp mov ebx eax jmp mov edi eax pop ebx loop pop ecx pop eax push eax pop eax stc jmp loop dominators set basic blocks dominate basic block set basic blocks dominated basic block red set basic blocks immediately precede succ set basic blocks immediately follow irst instruction basic block instruction basic block red irst bi bi 

succ irst bi bi 

kills true instruction program point kills variable uses true instruction program point uses variable alias true variable alias program point set program points start live range includes set program points live range includes delta difference integer variables program point delta change value program points true variable points location program point table examples static analysis predicates 
ground ground types pointer base array type size pointer middle array type size ptr pointer 
structure product types 
union function top type bits bottom type bits type bits member labeled type offset ground int uint 
including subtyping rules 
type int represents signed integer covers wide variety values storage locations 
parametrized parameters follows represents number highest bits ignored number middle bits represent sign number lowest bits represent value 
type int uses total bits 
dg 
ds ds 
dv dv 
ignored sign value represents unsigned integer just variation middle sign bits set zero 
allows separation data storage location type 
assembly languages possible storage location larger required data type stored 
example byte stored right aligned bit word associated type isint 
means table simple type system 
instruction xor significant byte bit word preserve leftmost bits bit word instruction addresses memory bit word boundary 
separation data storage location raises issue alignment information computer systems require prefer data memory address aligned data size 
example bit integers aligned byte boundaries drawback accessing unaligned bit integer leads slowdown due aligned memory accesses exception requires handling software 
presently alignment information provide significant covert way changing program flow 
shows types operands section code virus 
table illustrates type system intel ia architecture 
ia data types covered table including bit strings byte strings bit packed simd types bcd packed bcd formats 
code type call pop ebx ebx lea ecx ebx ecx ebx ptr push ecx ecx push eax eax push eax eax esp pop ebx eax add ebx ch ebx int cli mov ebp ebx ebp ebx ptr inferred types virus code 
ia logical address combination bit segment selector bit segment offset type cross product bit unsigned integer bit pointer 
abstraction patterns abstraction pattern tuple list typed variables sequence instructions boolean expression combining static analysis predicates program points 
formally pattern tuple defined follows 
xk 
vm boolean expression involving static analysis predicates logical operators instruction sequence number arguments vi argument literal value free variable xj 
write 
xk denote pattern free variables 
xk 
example pattern shown 
int int pop add afh pattern represents instructions pop register stack add constant value af 
note uninterpreted symbol pattern 
uninterpreted symbols pattern allows match multiple sequences instructions patterns shown matches instantiation pattern assigned specific register 
type int represents integer bits storage sign bit 
define binding set pairs variable value 
formally binding defined 
pair occurs binding write bindings said compatible bind variable different values compatible def union compatible bindings includes pairs bindings 
incompatible bindings union operation returns empty binding 
def vx vx vx compatible compatible matching abstraction pattern sequence instructions unification bind free variables actual values 
function unify 
opi xi 
xi ni 
returns general binding instruction sequence 
opi xi 
xi ni 
unified sequence instructions specified pattern 
instruction sequences unified unify returns false 
definitions algorithms related unification standard 
annotator operation annotator associates set matching patterns node cfg 
annotated cfg program procedure respect set patterns denoted 
assume node cfg corresponds program point instruction ip 
annotator attempts match possibly interprocedural instruction sequence 
ip ip ip patterns set 

cfg node labeled list pairs patterns bindings satisfy condition annotation 
unify unify returns false unification possible node annotated 
note pattern appear times albeit different bindings annotation 
pair unique annotation set node 
detector ia datatype type expression byte unsigned int uint word unsigned int uint unsigned int uint unsigned int uint double unsigned int uint byte signed int int word signed int int signed int int signed int int double signed int int single precision float float double precision float float double extended precision float float near pointer far pointer logical address uint uint eax ebx ecx edx esi edi ebp esp int cs ds ss es fs gs ax bx cx dx bl cl dl ah bh ch dh table ia datatypes corresponding expression type system table 
detector takes inputs annotated cfg executable program procedure malicious code automaton 
malicious pattern described malicious code automaton annotated cfg detector returns sequence instructions exhibiting pattern 
detector returns malicious pattern annotated cfg 
malicious code automaton intuitively malicious code automaton generalization vanilla virus malicious code automaton represents obfuscated strains virus 
formally malicious code automaton mca tuple 
vk set typed variables 
finite alphabet patterns parametrized variables pi vi oi ci vi finite set states transition function non empty set initial states non empty set final states 
mca generalization ordinary finite state automaton alphabets finite set patterns defined set typed variables 
binding variables 
vk finite state automaton obtained substituting vi vi denoted 
note vanilla finite state automaton 
explain example 
consider mca shown 
automata obtained corresponding bindings shown 
uninterpreted variables mca introduced handle obfuscation transformations register reassignment 
malicious code automaton corresponding code fragment shown virus depicted 
move move pop pop mov esi ecx mov eax pop edx pop ecx esi ecx eax edx mov esi eax mov ebx pop ecx pop eax esi eax ebx ecx malicious code automaton virus code fragment instantiations different register assignments shown respective bindings 
move move pop pop pop pop pop move dr move move jump malicious code automaton corresponding code fragment 
detector operation detector takes inputs annotated cfg program procedure malicious code automaton mca 
note set patterns construct annotated cfg alphabet malicious code automaton 
intuitively detector determines exists malicious pattern occurs 
formalize intuitive notion 
annotated cfg finite state automaton nodes states edges represent transitions node corresponding entry point initial state node final state 
detector determines language empty ball expression language corresponding annotated cfg ball set bindings variables set words detector determines exists binding intersection languages non empty 
detection algorithm similar classic algorithm determining intersection regular languages non empty 
due presence variables perform unification algorithm 
algorithm combines classic algorithm computing intersection regular languages unification 
implemented algorithm data flow analysis 
node annotated cfg pa associate pre post lists respectively 
element list pair state mca binding variables 
intuitively possible binding state just node initial condition initially lists associated nodes start node empty 
pre list associated start node list pairs initial state mca post list associated start node empty 
loop loop updates pre post lists nodes 
loop worklist ws contains set nodes pre post information changed 
loop executes pre post information associated nodes change fixed point reached 
join operation computes pre takes list state binding pairs post sets program points preceding copies pre repeated states 
case repeated states conflicting pairs merged single pair bindings compatible 
bindings incompatible pairs thrown 
diagnostic feedback suppose algorithm returns non empty set meaning malicious pattern common annotated cfg mca case return sequence instructions executable corresponding malicious pattern 
achieved keeping additional structure algorithm 
time post list node updated transition see statement store predecessor added state bs added add edge binding bs associated structure 
suppose detect contains state bs final state mca traceback associated structure reach initial state storing instructions occurring way 
experimental data major goals experiments measure execution time tool find false positive negative rates 
constructed obfuscated versions viruses 
vi denote th version th virus 
obfuscated versions created varying obfuscation parameters number nops inserted jumps 
th virus vi denoted vanilla version virus 
malicious code automata corresponding viruses 
testing environment testing environment consisted microsoft windows machine 
hardware configuration included amd athlon ghz processor gb ram 
codesurfer version ida pro version 
testing malicious code describe testing respect virus 
testing viruses analogous 
ran safe versions virus 
malicious code automaton 
experiment gave false negative rate pattern corresponding detected versions virus 
annotator detector avg 
std 
dev 
avg 
std 
dev 
sf hare table safe performance checking obfuscated viruses false negatives 
executed safe versions viruses vi malicious code automaton mj 
helped find false positive rate safe 
experiments safe false positive negative rate 
measured execution times run 
ida pro codesurfer implemented measure execution times components 
report average standard deviation execution times tables 
annotator detector avg 
std 
dev 
avg 
std 
dev 
sf hare table safe performance checking obfuscated viruses false positives virus 
testing benign code considered suite benign programs see section descriptions 
benign program executed safe malicious code automaton corresponding viruses 
detector reported negative case false positive rate 
average variance execution times reported table 
seen results certain cases execution times unacceptably large 
address performance enhancements safe 
descriptions benign executables exe command line utility toolkit version unix environment windows developed red hat 
input list patterns 
pr malicious code automaton annotated cfg 
output true program infected false 
pre entry node foreach pre foreach post ws ws old ws ws foreach update pre information ws ws foreach update post information foreach bs foreach annotation follow transition compatible bs add bs ws ws ws return bs algorithm check program model malicious code specification 
exe microsoft windows minesweeper game version 
exe microsoft visual studio spy utility allows querying properties monitoring messages windows applications 
executable tested marked version 
exe part apple quicktime media player version 
unique view malicious code detection obfuscation game 
viewpoint explore obfuscation attacks commercial virus scanners popular virus scanners susceptible attacks 
static analysis framework detecting malicious code patterns executables 
framework implemented safe static analyzer executables detects malicious patterns executables resilient common obfuscation transformations 
investigate theorem provers construction annotated cfg 
instance slam uses theorem prover simplify predicate abstraction programs 
detection algorithm context insensitive track calling context executable 
investigate push systems algorithm context sensitive 
existing pds formalism allow uninterpreted variables extended context 
availability safe prototype remains development distributing time 
please contact mihai mihai cs wisc edu updates 
acknowledgments thomas reps jonathon providing invaluable comments earlier drafts 
members collaborators wisconsin safety analyzer www cs wisc edu research group insightful feedback support development 
engler 
programmer written compiler extensions catch security holes 
executable text procedure annotator detector size size count avg 
std 
dev 
avg 
std 
dev 
exe exe exe exe table safe performance seconds checking clean programs virus 
ieee symposium security privacy oakland pages may 
ball rajamani 
automatically validating temporal safety properties interfaces 
proceedings th international spin workshop model checking software spin volume lecture notes computer science 
springer verlag 
barak goldreich impagliazzo rudich sahai yang 
im possibility obfuscating programs 
advances cryptology crypto volume lecture notes computer science pages 
springer verlag august 
bishop 
checking race conditions file accesses 
computing systems 
cert coordination center 
denial service attacks june 
www cert org tech tips denial service html accessed aug 
chandra reps physical type checking acm sigplan sigsoft workshop program analysis software tools engineering paste pages 
acm press september 
chen wagner 
mops infrastructure examining security properties software 
th acm conference computer communications security ccs 
acm press november 
chess 
improving computer security extending static checking 
ieee symposium security privacy oakland pages may 
chess white 
undetectable computer virus 
proceedings virus bulletin conference 
cohen 
computer viruses theory experiments 
computers security 
collberg thomborson low 
taxonomy obfuscating transformations 
technical report department computer science university auckland new zealand july 
collberg thomborson low 
manufacturing cheap resilient stealthy opaque constructs 
proceedings th annual acm sigplan sigact symp 
principles programming languages popl 
acm press january 
corbett dwyer hatcliff pasareanu robby laubach zheng 
bandera extracting finitestate models java source code 
proceedings nd international conference software engineering icse pages 
acm press 
cousot halbwachs 
automatic discovery linear restraints variables program 
proceedings th annual acm sigplan sigact symp 
principles programming languages popl pages 
acm press january 
currie hu rajan 
automatic formal verification dsp software 
proceedings th annual acm ieee conf 
design automation dac pages 
acm press 
detlefs nelson saxe 
simplify theorem prover 
research compaq com src esc simplify html schneider 
irm enforcement java stack inspection 
ieee symposium security privacy oakland pages may 
esparza hansel 
efficient algorithms model checking pushdown systems 
proceedings th international conference computer aided verification cav volume lecture notes computer science pages 
springer verlag july 
feng alan hu 
automatic formal verification scheduled vliw code 
proceedings joint conf 
languages compilers tools embedded systems software compilers embedded systems scopes pages 
acm press 
fitting 
order logic automated theorem proving 
springer verlag 
jha miller 
detecting manipulated remote call streams 
proceedings th usenix security symp 
security 
usenix association august 
hopcroft motwani ullman 
automata theory languages computation 
addison wesley 
horwitz reps binkley :10.1.1.50.4405
interprocedural slicing dependence graphs 
acm transactions programming languages systems toplas january 
codesurfer code analysis understanding tool 
www com products codesurfer index html accessed feb 
jensen metayer thorn 
verification control flow security properties 
ieee symposium security privacy oakland may 

virus list encyclopaedia chapter ways infection viruses entry point 
labs 
www com eng 
asp id key accessed feb 
labs 
www com accessed feb 
landi 
undecidability static analysis 
acm letters programming languages systems lo plas december 
lo levitt olsson 
mcf malicious code filter 
computers society 
mcgraw morrisett 
attacking malicious code report research council 
ieee software september october 
moore paxson savage shannon staniford weaver 
spread sapphire slammer worm 
technical report cooperative association internet data analysis caida february 
www caida org outreach papers sapphire sapphire html accessed feb 
morrisett crary glew walker 
typed assembly language 
xavier leroy atsushi ohori editors workshop types compilation volume lecture notes computer science pages 
springer verlag march 
morrisett walker crary glew 
system typed assembly language 
proceedings th annual acm sigplan sigact symp 
principles programming languages popl pages 
acm press january 
muchnick 
advanced compiler design implementation 
morgan kaufmann 
myers 
precise interprocedural data flow algorithm 
conference record th annual acm sigplan sigact symp 
principles programming languages popl pages 
acm press january 

polymorphic virus detection module 
united states patent december 

polymorphic virus detection module 
united states patent october 
necula 
translation validation optimizing compiler 
proceedings acm sigplan conf 
programming language design implementation pldi pages 
acm press june 
owre rajan rushby shankar srivas 
pvs combining specification proof checking model checking 
proceedings th international conference computer aided verification cav volume lecture notes computer science pages 
springer verlag august 
reps horwitz sagiv 
precise interprocedural dataflow analysis graph reachability 
proceedings th acm sigplan sigact symposium principles programming languages popl pages 
acm press january 

expanded threat list virus encyclopaedia chapter 
symantec antivirus research center 

symantec com data html accessed feb 
sa nv 
ida pro interactive disassembler 
www com accessed feb 
staniford paxson weaver 
wn internet spare time 
proceedings th usenix security symp 
security pages 
usenix association august 
sz 
hunting metamorphic 
proceedings virus bulletin conference pages september 

elf encryption program 
https scene accessed feb 
wagner dean 
intrusion detection static analysis 
ieee symp 
security privacy oakland may 
wang 
flash pan 
virus bulletin july 
virus analysis library 
xu 
safety checking machine code 
phd thesis university wisconsin madison 

automated reverse engineering engine 
host sk txt accessed feb 

mutation engine 

host sk zip accessed feb 

homepage 
host 
sk accessed feb 
notes note subroutine address computation updated take account 
trivial computation implemented adding number inserted nops initial offset hard coded virus morphing code 
executable formats require various sections executable file start certain aligned addresses respect target platform idiosyncrasies 
extra space section usually padded nulls 
way matching simpler full unification 
note instruction sequence contain variables 
instantiate variables pattern match corresponding terms instruction sequence 
