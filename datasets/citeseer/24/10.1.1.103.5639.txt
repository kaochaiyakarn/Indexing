type classes haskell cordelia hall kevin hammond simon peyton jones philip wadler glasgow university de nes set type inference rules resolving overloading introduced type classes 
programs including type classes transformed ones may typed hindley milner inference rules 
contrast type classes rules relate directly user programs 
innovative aspect second order lambda calculus record type information program 

goal haskell committee design standard lazy functional language applying existing understood methods 
committee surprise emerged standard way overloaded operations equality arithmetic conversion string show 
languages miranda tur standard ml mth mt er di ering solutions problems 
solutions di er languages language 
miranda uses technique equality de ned types including types unde ned arithmetic numeric type third string conversion 
standard ml uses technique arithmetic string conversion overloading resolved point appearance di erent equality type variables range equality types 
committee adopted completely new technique proposal wadler extends familiar hindley milner system mil type classes 
type classes provide uniform solution overloading including providing operations equality arithmetic string conversion 
generalise idea equality types standard ml subsume approach string conversion miranda 
system originally supported serc aqua project 
authors address computing science dept glasgow university glasgow scotland 
email kh simonpj dcs glasgow ac uk miranda trademark research software limited 
described wadler blott wb blo similar proposal independently kaes kae 
type system haskell certainly innovative feature provoked discussion 
closely related rou wright cw directly inspired type classes includes nipkow snelting ns volpano smith vs jones jon jon nipkow prehofer np odersky laufer laufer lau lau chen hudak odersky cho 
presents source language lambda calculus implicit typing overloading target language polymorphic lambda calculus explicit typing overloading 
semantics provided translation known semantics hue 
normally expects theorem stating translation sound translation preserves meaning programs 
possible translation de nes meaning programs 
grave shortcoming system direct way assigning meaning program done indirectly translation appears alternative 
note kae give direct semantics slightly simpler form overloading 
original type inference rules wb deliberately sparse intended re ect haskell language precisely 
result confusion precisely type classes haskell de ned 

contributions 
spells precise de nition type classes haskell 
rules arose practical impetus attempts build compiler haskell 
presents simpli ed subset rules derived 
full set rules pw contains judgement forms rules additional syntactic features declarations pattern matching list comprehensions 
wehave inspired formal semantics standard ml prepared milner tofte harper mth mt 
deliberately adopted mastering complexity 
approach unites theory practice 
industrial grade rules provide useful complement theoretical approaches wadler blott wb blo nipkow snelting ns nipkow prehofer np jones jon jon 
anumber simplifying assumptions papers 
wb assumed class exactly operation 
ns assumed intersection pair classes separately declared 
jon deal directly instance class declarations 
papers emphasises aspect theory stresses learned practice 
time rules monad wad implementation support provide clean high level speci cation implementation typechecker implementation oriented papers aug jon 
contribution explicit polymorphism target language 

type classes section introduces type classes de nes required terminology 
simple examples equality comparison operations introduced 
overloaded function de nitions show translate 
examples appear running examples rest 

classes instances 
class declaration provides names type signatures class operations class eq bool declares type belongs class eq operation type bool 
belongs eq equality de ned 
instance declaration provides method implements class operation type instance eq int instance eq char declares type int belongs class eq implementation equality type int int bool 
similarly characters 
write returns true false 
usual examples assume numerals type int 
functions equality may overloaded 
syntax ys stand ys 
member ys null ys head ys member tail ys type system infers general possible signature member member eq bool phrase eq called context type limits types range belonging class eq 
usual denotes type lists elements type inquire member member member sin cos tan instance equality functions 
similar ect achieved standard ml equality type variables type classes viewed generalising behaviour 
instance declarations may contain overloaded operations provided suitable context instance eq eq xs ys null xs null ys null xs null ys head xs head ys tail xs tail ys declares type belonging class eq thetype belongs class eq gives appropriate de nition equality lists 
note head xs head ys uses equality tail xs tail ys recursively uses equality 
ask 
entry context pairs class name type variable 
pairing class name type allowed 
example consider de nition palindrome xs xs reverse xs inferred signature palindrome eq bool note context eq eq 

superclasses 
class declaration may include context speci es superclasses class eq ord bool bool declares type belongs class ord operations appropriate type belongs class eq 
de ned type de ned type 
say eq superclass ord 
superclass hierarchy form directed acyclic graph 
instance declaration valid class instance declarations superclasses 
example instance ord int valid eq int declared instance 
superclasses allow simpler signatures inferred 
consider de nition uses search ys null ys head ys head ys search tail ys inferred signature search ord bool superclasses context inferred signature eq ord 

translation 
inference rules specify translation source programs target programs overloading explicit 
instance declaration generates appropriate corresponding dictionary declaration 
dictionary class contains dictionaries superclasses methods operators 
corresponding eq int ord int instances dictionaries eni builds dictionary 
dictionary ord contains dictionary superclass eq methods 
operation class selector extract appropriate method corresponding dictionary 
superclass selector extract superclass dictionary subclass dictionary 
corresponding eq ord classes selectors dicteq dicteq dicteq dicteq overloaded function extra parameters corresponding required dictionaries 
translation search search ys null ys type variable type class name simple type arity overloaded type mi polymorphic type context mi record type hv vn ni 
syntax types head ys head ys search tail ys call overloaded function supplies appropriate parameters 
term search translates search 
instance declaration context translation parameters corresponding required dictionaries 
translation instance eq eq deq xs ys null xs null ys null xs null ys deq head xs head ys deq tail xs tail ys dictionary eq yields dictionary eq 
get dictionary equality list integers writes 
actual target language di ers extra constructs explicit polymorphism 

notation section introduces source language target language various environments appear type inference rules 
program exp programs classdecl class decls 
instdecl instance decls 
classdecl class class declaration instdecl instance instance decl 
binds binds exp varn exp var variable var 
exp function abstraction exp exp function application var exp exp local de nition 
syntax source programs 
type syntax 
gives syntax types 
types come simple overloaded polymorphic 
record type maps class operation names types appears source syntax classes 
subtlety 
type entries angle brackets mayhave form polymorphic type context entries restricted form extra generality overloaded types required inference process 

source target syntax 
gives syntax source language syntax target language 
write nonterminals translated programs boldface translated form var var exp exp indicate target language variables expressions represent dictionaries dvar dexp 
target language di ers polymorphism explicit 
constructs type abstraction application bound variable labeled type 
includes constructs build select dictionaries perform type abstraction application 
program consists set bindings recursive followed expression 
class types appearing translation denote monotypes formal translation appears 
program letrec exp program var exp varn exp binding set exp var variable pat exp function abstraction exp exp function application var exp exp local de nition exp ni dictionary formation exp type abstraction exp type application pat var pat pat 
syntax target programs environment notation type type variable environment ae type constructor environment te kg type class environment ce class instance environment local instance environment lie variable environment fvar environment ae te ce lie top level environment pe fg te ce fg declaration environment de ce 
environments 
environments 
inference rules number di erent environments summarised 
write env name info indicate environment env maps name name information info 
information interest just write env name indicate name domain env 
written symbolic form fname 
write extract type environment compound environment similarly components compound environments 
operations combine environments 
checks domains arguments distinct shadows left te int bool list ce eq fclass eq 
ord fclass ord 
bool 
gg eq eq int eq list ord int 
bool 
bool 
bool fg te ce fg argument right 
initial environments env env var env var var dom env var dom env env var var dom env var dom env env var env var var dom env var dom env env var var dom env 
env brevity tuple sums components write combine appropriate component ofe similarly environments 
specify contents environment explicitly write env implicit side conditions associated environments 
variables may declared twice scope 
appears rule side condition dom dom implied 
variable appear environment 
rule side condition var dom implied 
instance declared class type constructor 
appears rule side type condition implied 
type poly type type var type con type pred type gen ae type type type ce ae type type mi ae kg type poly type 
rules types rules types source syntax constrain environments generated 
stated explicitly determines relation de ned 
rules determines ae ftv ae determines lie ran lie section gives inference rules various constructs source language 
consider turn types expressions dictionaries class declarations instance declarations full programs 

types 
rules types shown 
judgement forms de ned summarised upper left corner 
judgement ofthe form type holds environment simple type valid 
particular type variables appear ae checked rule type var type constructors appear appropriate arity checked rule type con 
judgements act similarly overloaded types polymorphic types 

expressions 
rules expressions shown 
judgement form exp exp exp holds environment expression exp simple type yields translation exp judgements act similarly overloaded polymorphic types 

dictionaries 
inference rules dictionaries shown 
judgement dict dexp holds environment instance class type dictionary dexp 
judgements act similarly overloaded polymorphic instances 

class declarations 
rule class declarations 
rule looks formidable workings straightforward 
judgement pe classdecl classdecl de holds environment pe class declaration classdecl valid generating new environment de yielding translation 
compound environment de ce class environment ce entry describes class instance environment entry superclass class class dictionary selects appropriate superclass dictionary value environment entry operator class class dictionary selects appropriate method 
exp exp exp exp exp exp poly exp exp exp taut spec rel abs comb pred gen var poly exp var var poly exp var var type exp var var exp var exp dicts exp var exp fvar exp exp exp exp var 
exp var exp exp exp exp exp exp exp exp exp exp exp exp dicts lie determines lie exp lie exp exp exp exp exp ae kg exp exp exp poly exp exp exp poly exp exp exp fvar exp exp exp exp var exp exp var exp exp 
rules expressions dict dexp dict dexp poly dict dexp dicts dict taut lie dict taut dict spec dict rel dicts lie dvar dict dvar dvar poly dict dvar poly dict dexp dict dexp dict dexp dicts dict dexp dict dexp dicts ni dexp ni 
rules dictionaries 
instance declarations 
rule instance declarations 
rule looks formidable workings straightforward 
judgement pe instdecl instdecl holds environment instance declaration instdecl valid generating new environment yielding translation 
instance environment contains single entry corresponding instance declaration contains single binding 
header instance declaration corresponding instance function expects dictionary entry returns dictionary instance 
classdecl classdecl de class pe ae pe ae lie type determines ae dicts determines lie pe sigs ae mpat pat mpat pe pe pe sigs sigs sigs sigs classdecl class class dvar fvar var pat dvar dvar dom lie fvar pat var var dom 
rule class declarations type sigs mi 
rule class signatures 
programs 
omit rules declaration sequences programs appear full technical report 

presents minimal readable set inference rules handle type classes haskell derived full static semantics pw 
important feature style presentation scales description entire haskell language 
practice rules directly implemented monads 
style applied full static semantics order construct type checker glasgow haskell compiler virtually passes compiler 
undoubtedly saved initially making countless bookkeeping errors instdecl instdecl inst pe ce pe class pe ae pe ae lie pe ae lie pe ae lie type determines ae dicts determines lie dicts dexp binds binds binds instdecl instance binds dom ae dvar dom ae pe 
rule instance declarations binds binds binds binds exp expi exp binds exp mi exp exp mi 
rule instance bindings continues pay code train students 
aug augustsson implementing haskell overloading 
functional programming computer architecture copenhagen june 
blo blott type classes 
ph thesis glasgow university 
cho chen hudak odersky parametric type classes 
lisp functional programming pp 

cw wright type dependent parameter inference 
programming language design implementation white plains new york june acm press 
hammond blott implementing haskell type classes 
glasgow workshop functional programming scotland september springer verlag pp 

hall hammond peyton jones wadler type classes haskell 
department computing science glasgow university jan 
hue gerard huet editor logical foundations functional programming addison wesley 
see part ii polymorphic lambda calculus especially reynolds 
jon jones theory quali ed types 
european symposium programming rennes february lncs springer verlag 
jon jones cient implementation type class overloading 
dept computing science oxford university 
jon jones system constructor classes overloading implicit higher order polymorphism 
functional programming computer architecture copenhagen june pp 

kae kaes parametric polymorphism 
european symposium programming nancy france march lncs springer verlag 
lau polymorphic type inference data types 
laufer ph thesis new york university 
lau extension haskell class types 
laufer technical report university chicago 
mth milner tofte harper de nition mit press cambridge massachusetts 
mt milner tofte commentary standard ml mit press cambridge massachusetts 
mil milner theory type polymorphism programming 
comput 
syst 
sci 
pp 

np nipkow prehofer type checking type classes 
acm symposium principles programming languages january pp 

ns nipkow snelting type classes overloading resolution order sorted uni cation 
functional programming languages computer architecture boston august lncs springer verlag 
odersky laufer type classes signatures types 
technical report ibm tj watson research centre may 
pw peyton jones wadler static semantics haskell 
department computing science glasgow university may 
rou safe run time overloading 
acm symposium principles programming languages san francisco january acm press 
tur turner miranda non strict functional language polymorphic types 
functional programming languages computer architecture nancy france september lncs springer verlag pp 

vs volpano smith complexity overloading 
functional programming languages computer architecture boston august lncs springer verlag 
wad wadler essence functional programming 
acm symposium principles programming languages albuquerque new mexico january 
wb wadler blott ad hoc polymorphism ad hoc acm symposium principles programming languages austin texas january pp 

