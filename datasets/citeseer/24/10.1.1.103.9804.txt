fine grained mobility emerald system eric jul henry levy norman hutchinson andrew black university washington emerald object language system designed construction distributed programs 
explicit goal emerald support object mobility objects emerald freely move system take advantage distribution dynamically changing environments 
say emerald fine grained mobility emerald objects small data objects process objects 
fine grained mobility allows apply mobility new ways presents imple mentation problems 
discusses benefits grained mobility emerald language run time mechanisms support mobility techniques implementing mobility degrade performance local operations 
performance measurements current implementation included 
categories subject descriptors computer communications networks distributed systems distributed applications network operating systems programming languages language constructs tract data types control structures operating systems storage management distributed memories systems communications management message sending operating systems organization design distributed system general terms design languages measurement performance additional key words phrases distributed languages object oriented languages object oriented systems process mobility 
process migration implemented described goal distributed systems 
systems entire address spaces moved node node 
example process manager initiate move share processor load evenly users initiate remote execution explicitly 
case running process typically ignorant location unaffected move 
supported part national science foundation mcs dcr ccr university copenhagen denmark nr 
digital equipment external research ibm graduate fellowship 
authors current addresses jul diku dept computer science university copenhagen dk copenhagen denmark levy university washington dept computer science fr seattle wa hutchinson dept computer science university arizona tucson az black digital equipment king st ma 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm transactions computer systems vol 
february pages 
jul levy hutchinson black years designed implemented emerald distributed object language system 
principal goal emerald experiment mobility distributed programming 
mobility emerald system differs existing process migration schemes important respects 
emerald object unit distribution mobility object 
emerald objects contain processes contain data arrays records single integers objects 
unit mobility smaller process migration systems 
object mobility emerald subsumes process migration data transfer 
second emerald language support mobility 
emerald language explicitly recognize notions location mobility design conventional parts language parameter passing affected mobility 
advantages process migration noted previous include load sharing moving objects system take advantage lightly processors 
communications performance active objects interact intensively moved node reduce communications cost duration interaction 
availability objects moved different nodes provide better failure coverage 
reconfiguration objects moved failure ery prior scheduled downtime 
utilizing special capabilities object move take advantage unique hardware software capabilities particular node 
advantages fine grained mobility provides additional benefits data movement mobility provides simple way programmer move data node node having explicitly package data 
separate message passing file transfer mechanism required 
invocation performance mobility potential improving formance remote invocation moving parameter objects remote site duration invocation 
garbage collection mobility help simplify distributed garbage collection moving objects sites exist 
knowledge system implements object mobility style similar emerald implementation distributed smalltalk 
addition mobility distribution intend emerald provide efficient execution 
want achieve performance competitive stan dard procedural languages local case standard remote procedure call rpc systems remote case 
goals trivial location independent object environment 
meet relied heavily acm transactions computer systems vol 
february 
fine grained mobility emerald system appropriate choice language semantics tight coupling compiler run time kernel careful attention implementation 
emerald intended run large long haul networks 
assume local area network modest number nodes 
addition assume nodes homogeneous sense run instruction set trusted 
concentrate primarily language run time mecha nisms support fine grained mobility retaining efficient operation 
brief overview emerald language system mobility location primitives 
detailed description object structure emerald type system 
second discuss implementation fine grained mobility emerald new problems arise providing support 
third measure ments implementation draw implications measurements design experience 

overview emerald previously stated important goal emerald explicit support mobility 
conceptual viewpoint important goal single object model 
object systems typically lie ends spectrum object lan guages smalltalk clu provide small local data objects object operating systems hydra clouds provide large active objects 
distributed systems argus eden support kinds objects separate object definition mechanism 
choosing right mechanism requires programmer know ahead time uses object put alternative accept inefficiency inconvenience wrong mechanism reprogram object needs change 
example programming collaborative editing system argus greif weihl observed designer forced guardian cluster appropriate 
motivation distinct definition mechanisms need distinct implementations 
distributed object systems clouds eden local execution general invocation mechanism take milliseconds tens milliseconds 
restrictive efficient implementation appropriate objects known local example shared store preference messages 
believe importance multiple implementations believe need visible programmer 
emerald programmers single object definition mechanism single semantics defining objects 
includes small local data objects active mobile distrib objects 
emerald compiler capable analyzing needs object generating appropriate implementation 
example array object entirely local object implemented differently array shared globally 
compiler produces different implementations piece code depending context compiled 
acm transactions computer systems vol 
february 
jul levy hutchinson black table timings local emerald invocations emerald time primitive integer invocation primitive real invocation local invocation op resident global invocation op motivation designing new language applying ideas existing language semantics language preclude efficient implementation local remote case 
designing emerald kept implementations mind 
emerald unique type system allows programmer state great deal variable general information compiler better code generates 
believe current emerald implementation demonstrates ity approach meets goal local performance commensurate procedural languages 
table shows performance local emerald operations executed microvax ii details compiler implementation 
resident global invocation time global object move network invoked object resident node 
comparison procedural languages procedure call takes microseconds concurrent euclid procedure call takes microseconds 
concurrent euclid slower emerald explicit stack overflow checks call 
emerald objects emerald object components unique network wide name representation data local object consists primitive data objects set operations invoked object optional process 
emerald objects contain process active objects process passive data structures 
objects processes invocations objects turn invoke objects depth 
consequence thread control originating object may span objects locally remote machines 
multiple threads control may active concurrently single object synchronization provided monitors 
shows example definition emerald object case simple directory object called 
representation object micro vax trademark digital equipment 
acm transactions computer systems vol 
february 
object export add lookup delete monitor const record var name string var obj const ray empty function lookup string var var integer lowerbound loop exit element element return loop nil lookup implementation add delete monitor fine grained mobility emerald system fig 

emerald directory object definition 
consists array directory elements 
object exports operations add lookup delete 
array operations defined monitor guarantee exclusive access array 
types emerald emerald language supports concept type 
type object defines interface number operations exports names number types parameters operation 
example consider type definition simple const type operation lookup string operation add string ani type definition operations lookup add 
lookup input parameter type string returns object type 
say object conforms type implements operations type types parameters conform proper way 
object assigned variable type object conform declared type variable 
objects conform type operation 
types permit new implementations object added executing system 
new object place type new object conform required type 
example assign object variable declared type conforms 
note object implement number different types type implemented number different objects 
acm transactions computer vol 
february 
jul levy hutchinson black emerald class instance hierarchy contrast smalltalk 
objects members class conceptually object carries code 
distinction important distributed environment separating object code costly 
identically implemented emerald objects node share code 
implementation code stored concrete type object 
concrete type objects immutable freely copied 
object moved node data moved 
object contains process part data include process stack code transferred 
kernel receives object determines copy concrete type object implementing object exists locally kernel obtains copy finding node location algorithm described section 
typically concrete type available node sent object 
concrete type object arrives dynamically linked kernel compiler generates relocatable code sufficient symbol table information dynamic linking possible 
scheme possible add dynamically new concrete types implement existing types 
concrete type objects kept node long objects referencing garbage collected 
primitives mobility object mobility emerald provided small set language primitives 
emerald object locate object locate returns node resides 
move object node move 
fix object particular node fix 
object mobile fix 
object atomically performing move fix new mode 
move primitive hint kernel obliged perform move object obliged remain destination site 
fix stronger semantics primitives succeed object stay destination explicitly 
central primitives concept location encapsulated node object 
node object abstraction physical machine 
location may specified naming node object object 
programmer specifies object location implied node object resides 
concepts similar location dependent primi tives eden 
crucial issue moving objects containing deciding move 
object part graph move single object levels objects entire graph 
simplest approach moving specified object may inappropriate 
depending object implemented invocations moved object may require remote avoided related objects moved 
acm transactions computer systems vol 
february 
fine grained mobility emerald system emerald programmer may wish specify explicitly objects move 
purpose emerald language allows programmer attach objects objects 
variable declared programmer specify variable attached variable example emerald mail system mail messages fields sender array destination mailboxes subject line text string 
sense array destination mailboxes attached mail message specified attached var tolist array mailbox mail message moved array pointed time tolist moved 
may affect performance invocations tolist semantics 
attachment transitive object attached li st moved 
example linked structures may moved attaching link fields 
attachment symmetric object named list moved invoked attempt move mail message 
parameter passing important issue design distributed object systems rpc systems choice parameter passing semantics 
object system variables refer objects 
natural parameter passing method call object argument object passed 
fact semantics chosen clu called call sharing smalltalk 
distributed object oriented system desire treat local remote operations identically leads semantics 
choice cause serious performance problems remote invocation access remote operation argument cause additional remote invocation 
reason systems argus required arguments remote calls passed value object 
similarly rpc systems require call value addresses context dependent meaning remote environment 
emerald language uses call object parameter passing seman tics invocations local remote 
cases invoking code constructs activation record contains argument objects 
local case invoked object called directly receives pointer activation record invocation 
remote case activation record reconstructed remote system basic operation semantics identical 
emerald objects mobile may possible avoid remote moving argument objects site remote invocation 
worthwhile depends size argument object current invocations argument number invocations issued remote object argument relative costs mobility local remote invocation 
acm transactions computer systems vol 
february 
jul levy hutchinson black current emerald prototype arguments moved cases 
basis compile time information emerald compiler may decide move object invocation 
example small immutable objects obvious candidates moving copied cheaply 
obviously little sense send remote small string integer 
second emerald programmer may decide object moved basis knowledge application 
possible emerald provides parameter passing mode call call move 
call move change semantics call object invocation time argument object relocated destination site 
call argument object may return source call remain destination site call modes call visit call move respectively 
call move convenience performance optimization 
arguments moved explicit move statements 
providing call move parameter passing mode allows packaging argument objects network packet invocation message 
example consider mail system example 
composing mail message fields described previously user invokes message deliver operation operation deliver var mailbox tolist length deliver move self var integer st loop exit tolist upperbound tolist getelement deliver ici loop deliver operation delivers message mailboxes tolist 
common case destination call move mail message single destination mailbox 
processes objects mobility emerald process thread control initiated object process created 
process invoke operations object object 
think process stack activation records shown 
thread control object process may pass objects case process owned object invokes operations objects think remote invocations ways 
traditional remote operation model sending process blocks existing remote process executes operation possibly returning value caller acm transactions computer systems vol 
february 
activation record operation activation record operation activation record operation process stack ease fine grained mobility emerald system fig 

process stack activation ords 
continues execution 
emerald remote invocation occurs think process moving destination node invoking object 
alternatively new activation record moves destination node base new segment process stack node 
invocation stack single emerald process distributed nodes 
mobility presents special problem process structure 
example process activation stack suppose object moved node 
case part thread executing move activation record move 
furthermore operation terminates return different node 
object move different node parts process stack different nodes 
invocation returns propagate control back node node 
imagine different scheme left stack intact invocations returning node root process resides point situation analyzed control passed proper location 
problem design leaves residual dependencies 
situation objects moved different nodes possible control return temporarily unreachable 
depending behavior may fact time return node required 
moving invocation frames objects execute ensures execution continue long possible removes computational burden nodes need involved communication 

implementing mobility emerald adding process mobility existing systems proves difficult task 
problem extracting entire state process may distributed numerous operating system data structures 
second process may variables directly index operating system data structures open file descriptors window numbers forth 
rec acm transactions computer system vol 
february 
jul levy hutchinson black distributed object system problem may somewhat simplified 
objects cleanly define boundaries system entities 
furthermore resources objects addressing standardized location independent 
objects user implemented kernel implemented addressed indirectly object id operations performed standard invocation interface 
distribution mobility increase generality system reduce performance 
building object system sensitive performance generally poor performance systems 
implementation mobility emerald involves trade offs performance mobility fundamental mechanisms local invocation 
possible trade offs favor performance frequent operations typically willing increase complexity mobility save microsecond local invocation 
furthermore takes times longer move object perform local invocation adding microseconds object move time little relative difference microseconds percent local invocation time 
result philosophy great extent existence mobility distribution emerald interfere performance objects single node 
sections describe implementation emerald kernel relevant mobility trade offs design 
object implementation addressing meet goal building distributed object system efficient local execution emerald implementation relies heavily shared memory 
implemented prototype emerald top dec ultrix system unix bsd running dec microvax ii workstations emerald kernel emerald objects single node execute single ultrix address space 
emerald processes lightweight threads scheduled address space 
protection objects guaranteed compiler type checking run time checks inserted code 
objects resident node address directly implementation style implications mobility 
previously stated objects coded single object definition mechanism 
knowledge object compiler free choose appropriate addressing mechanism storage strategy invocation protocol 
emerald compiler uses different styles object implementation global object moved independently referenced globally network invoked objects known compile time 
global objects heap allocated 
invocation object may require remote invocation 
object implemented global object 
unix trademark bell laboratories 
ultrix trademark digital equipment 
acm transactions computer systems vol 
february 
bit data fine grained mobility emerald system fig 

emerald addressing structures 
local object completely contained object local object exported outside boundary enclosing object 
objects move independently move enclosing object 
local objects heap allocated 
invocation implemented local procedure call line code 
array outside directory implemented local object 
direct object local object data area allocated directly representation enclosing object 
direct objects mainly primitive built types structures primitive types simple objects organization deduced compile time 
example integers direct objects 
shows various implementation addressing options emerald 
variable names global object value stored address local object descriptor 
node contains object descriptor global object exist node 
object deleted node object descriptor garbage collected 
object descriptor contains information state location global object 
word object descriptor identifies descriptor contains control bits indicating object local global bit object resident bit 
resident bit set object descriptor contains memory address object data area descriptor contains forwarding address object described section 
variable names local object 
value stored address object data area 
word data area word object descriptor contains fields identifying area indicating local object data area acts descriptor 
variable names direct object allocated variable 
notice single node objects addressed directly kernel intervention 
emerald variables contain location acm transactions computer systems vol 
february 
jul levy hutchinson black dependent meaning context particular node 
invocation global objects compiled code checks resident bit see local invocation performed directly 
target object resident compiled code trap kernel remote invocation performed 
way global objects invoked locally time comparable local procedure call 
finding objects objects allowed move freely possible know location object example invoking 
run time system keep track objects able find needed 
keeping node system date current location object expensive unnecessary 
scheme concept forwarding addresses described fowler 
global object assigned unique network wide object identifier oid node hashed access table mapping oids object descriptors 
access table contains entry local object remote exists remote object local exists 
previously described object descriptor contains forwarding address object oid 
forwarding address tuple timestamp node node known location object timestamp specifies age forwarding address 
fowler shown sufficient maintain timestamp counter incremented time object moves 
conflicting forwarding addresses object simple determine 
sent node boundary contains oid referenced object latest available forwarding address 
receiving node may update forwarding address referenced object required 
object moved node node update forwarding addresses object 
action taken inform nodes 
node try invoke object forward invocation message invocation completes send reply new forwarding address piggybacked reply message 
alternative strategy adopt keep track nodes particular object 
object move update messages sent nodes 
extra messages significantly increase cost move passing 
example object passed node time node register node responsible object 
demos mp system forwarding address update scheme updating forwarding addresses shown incur significant overhead 
addition sending update messages move avoid need invocation forwarding update messages arrive immediately destinations 
scheme places cost forwarding address maintenance current users forwarding address 
necessary locate object example locate primitive apply algorithm 
kernel forwarding address acm transactions computer systems vol 
february 
fine grained mobility emerald system object asks specified node object resident done 
node newer forwarding address start forwarding address 
node unreachable better information resort broadcast protocol 
broadcast protocol previous step failed find object 
searching kernel sends broadcast message nodes seeking location object 
reduce message traffic kernel specified object responds broadcast 
searching kernel receives response time limit sends second broadcast requesting positive negative reply nodes 
nodes responding short time sent reliable point point message location request 
node responds negatively conclude object unavailable 
performing remote invocations invocation message sent locating target object 
lost forwarding address path location algorithm 
optimizes common case object moved valid forwarding address exists 
finding translating pointers direct memory addresses emerald opposed indirect standard smalltalk implementation increases performance local invocations 
consequently movement object involves finding modifying direct addresses increases cost mobility 
feel reasonable motion frequent invocation 
design places price mobility 
finding translating done ways 
example tag bit word indicate word contains object 
smalltalk uses bits distinguish integers tags increases overhead arithmetic operations complicates implementation general 
emerald compiler generates templates object data areas de layout area 
template stored code concrete type object defines object operations 
object data area contains concrete type object code template data area 
addition mobility templates garbage collection debugging tasks understand object data area 
example consider emerald program shown defines single object containing variables inside monitor 
variable contains pointer object descriptor 
variable name initialized point local string object 
variable contain pointer integers implemented direct objects 
corresponding object data area template shown 
data area contains control information described earlier pointer code acm transactions computer systems vol 
february 
jul levy hutchinson black fig 

simple emerald object definition 
data area tag code pointer iif concrete type const object monitor var var string emerald var integer operation string nan monitor operation code monitor data pointer object descriptor emerald fig 

data area template structure 
lock monitor variable allocated bytes data variables name allocated pointer object 
template describe items data area contains 
template entry contains count number items described types items called template types 
typical template types pointer address object pointers translated object moved 
data direct data integers stored numbers bytes translated 
controls access object monitor 
monitors implemented boolean queue processes awaiting entry monitor 
monitor translated object moved 
attached objects move object moved indicated simply bit template entry 
compiler contiguously allocates variables described identical template entries 
average template contains entries 
addition data areas compiler produce templates describe activation records active invocations moved objects 
acm transactions computer systems vol 
february 
fine grained mobility emerald system template activation record describes things parameters operation local variables operation contents cpu registers 
simplify activation record templates emerald compiler permit registers change template type operation 
register contains pointer contain pointer lifetime invocation pointer register point different objects lifetime 
restriction similar segregation address data registers architectures dynamic division specific operation 
restriction need different templates different points operation execution design considered early project abandoned unnecessary 
moving objects addressing implementation structure described actual moving object straightforward 
systems objects moved performance reasons believe necessary emerald environment reasons 
process mobility systems copy entire address spaces 
second objects contain small amount data 
third object active process moved may need copy code 
moving data objects 
objects active invocations simplest ones move 
emerald kernel builds message transmitted destination node 
head message data area object moved 
previously described data area contain pointers global local objects 
data area translation information aid destination kernel mapping location dependent ad dresses 
global object pointers kernel sends oid forwarding address address object descriptor source node 
local objects data area sent address 
receipt information destination kernel allocates space moved objects copies data areas newly allocated space builds translation table maps original addresses addresses newly allocated space 
oids locate object descriptors existing global objects new object descriptors created necessary 
kernel locates template moved object traverses data area replaces pointers corresponding addresses translation table 
moving process activation records 
previously described sec tion object moved activation records processes executing operations move 
presents particularly difficult problem object move know activation records need move 
finding correct activation records requires list active invocations particular object 
solutions possible potentially serious performance implications 
simplest solution link activation record object invocation unlink invocation exit 
unfortunately acm transactions computer systems vol 
february 
jul levy hutchinson black increase invocation overhead percent current implementation 
hand finding list traversal 
invocations move require simple second solution create list move time 
eliminate invocation time cost require search activation records node 
believe mobility increase cost invocation move 
exhaustive search unacceptable price pay adopted intermediate solution 
maintain list activation records executing object solution 
invocation activation record linked structure 
space left links activation record marked linked inexpensive operation 
emerald process preempted activation stack searched linked activation records linked object descriptors respective objects 
search stops soon activation record linked previously 
way done preemption time cost related difference stack depth start execution interval number invocations performed 
operation unlink activation record terminates 
return check queued activation record dequeue freeing record 
returns find linked case need done 
activation record object moves find activation records move merely traversing linked list associated object 
activation records moved manner similar moving data areas described 
necessary activation records removed stack containing 
accomplished splitting stack parts bottom part remains source node middle part moved destination node top part copied new stack segment source node 
stack break points templates activation records 
stack breaks invocation frames modified appear remote invocations performed local invocations 
shows structure exist object moved node cy node 
handling processor registers 
additional complexity moving em processes activation records management processor registers 
emerald compiler attempts optimize addressing objects storing local variables registers activation record 
way processor registers may contain machine dependent pointers translated activation record moves 
unfortunately registers activation record kept place 
invocation saves activation record copy registers modified invocation 
referring back suppose acm transactions computer systems vol 
february 
activation record operation process stack segment node fine grained mobility emerald system activation record operation activation record operation process stack segment node fig 

process stack object move 
node invocation third invocation register 
case copy register saved activation record conventional stack language implementation 
object moves activation record move 
stack segmented rest stack left 
furthermore copy register stored activation record incorrect returns data refers different location different node 
handle situation kernel sends copy registers invocation moving activation record 
kernel finds template activation record concrete type object invoked object 
second determines registers pointers activation record looking template 
templates activation records special entries registers area activation record registers saved 
third kernel scans invocation stack looks activation record saved registers 
enables copies current values registers sent record 
destination node registers modified translation table described section stored newly created stack segment 
stack segment emerald process separate image registers 
invocation return crosses stack segment boundary registers stored stack segment receiving control 
acm transactions computer systems vol 
february 
jul levy hutchinson black possibly translated values registers computed stack segmented 
garbage collection object system emerald rely garbage collection recover memory occupied objects longer reachable 
furthermore emerald deal problems garbage collection distributed environment 
garbage collector fully implemented describe general design section 
principal problem distributed garbage collection object refer ences cross node boundaries 
system ensure delete object referenced 
distributed system object node different object node unavailable wire message 
emerald mobile objects presents special difficulty distributed object systems may mobile objects mobile root problem 
fact emerald object moves know implicitly garbage object actively executing object requested move 
furthermore garbage collection simpli fied presence object descriptors 
node retains descriptor object referenced collection 
emerald garbage collection design calls collectors node local collector run time independently nodes distributed collector requires nodes cooperate collecting distributed garbage 
mark sweep collectors modified operate parallel executing emerald processes 
expect garbage consist objects created disposed single node leaving node 
know objects collected node local collector object descriptor flag called bit 
kernel sets bit object descriptor object passed node 
kernel sets bit descriptor moving object arrived destination source node retains object 
node local collector finds object bit set considers object reachable 
node local collector ignores object 
distributed collection performed modified mark sweep collection algorithm 
conventional mark sweep objects initially marked white indicating known reachable 
objects known reachable example containing executable processes marked gray 
gray object reachable need scanned mark gray objects reachable object done original object marked black 
gray objects scanned system consists black objects reachable white objects garbage deleted 
perform distributed collection emerald collecting process started node global collectors proceed parallel 
global objects acm transactions computer systems vol 
february 
fine grained mobility emerald system objects set marked unreachable traditional mark sweep scheme 
global collector marks explicitly reachable global objects gray 
attempting scan gray object global collector may find object resides node 
case sends mark gray message node object resides 
collector receiving node adds object gray set sends back object black message object traversed marked 
receiving object black message collector removes object gray set marks black 
collection complete nodes exhausted gray sets 
prevent object traverse mark requests moving objects traversed marked black moved 
done objects currently marked white moved object priori reachable object eventually marked anyway 
node currently unavailable crashed mark gray message sent ignored moment 
eventually gray left objects unreachable nodes 
point collectors exchange information remaining gray objects collector knows objects need scanned 
unavailable node available collectors continue marking gray objects collection done gray object unavailable node 
collectors exchange gray sets wait node available 
process repeated collection completes point garbage objects object descriptors collected 
note necessary nodes simultaneously necessary node available long collection progress time 
major problem traditional mark sweep scheme activity suspended collecting 
distributed system obviously acceptable 
suggestions making mark sweep collectors operate parallel garbage generating pro cesses lo implemented 
typically parallel mark sweep requires processes cooperate collector setting coloring bits referenced objects performing assignments 
emerald avoids extra assignment scheme proposed hewitt 
start marking phase executable process marked allowed run 
marking process means marking objects reachable activation records process transitively object reachable objects 
individual process marked proceed parallel rest collection objects processes marked 
process executable waiting entry monitor process marked allowed execute 
scheme allows collectors proceed parallel executing pro cesses high initial cost making process executable objects reachable process marked 
reduce number objects traversed process may restarted developed faulting acm transactions computer systems vol 
february 
jul levy hutchinson black garbage collection scheme 
reachable global objects marked traversed 
frozen setting bit object descriptor 
process subsequently attempts invoke frozen object fault kernel exactly object remote 
kernel lets collector traverse object object allows invocation continue 
global objects immediately reachable process need traversed 
replaces large delay start garbage collection number smaller delays spread process execution 

performance measured performance emerald mobility primitives microvax ii workstations connected megabit second ethernet 
primitives operational short time effort optimize implementation 
addition measured impact mobility network message traffic emerald mail system driven synthetic workload 
results measurements reported sections 
emerald mobility primitives table ii shows elapsed time cost various emerald operations 
measured performance figures averages repeated measurements 
simplest remote invocation time spent emerald kernel milliseconds 
historical reasons currently set network communications routines provide reliable flow controlled message passing top udp datagrams 
routines slow time transmit bytes data receive reply milliseconds 
total elapsed time send invocation message receive reply milliseconds 
table iii shows benefit call move simple argument object 
table compares incremental cost call move call visit incremental cost call object 
additional cost call move milliseconds call visit costs milliseconds 
com puted subtracting time remote invocation argument local destination 
call visit time includes sending invocation message argument object performing remote invocation invokes argument returning argument object reply 
argument remote object object moved incremental cost milliseconds 
measurements somewhat lower bound cost moving object depends complexity object types objects names 
compared cost remote invocation call move call visit worthwhile single invocation argument object 
previously stated advantage call move depends size argument object number invocations argument object local remote invocation costs 
emerald fast local invocation time microseconds easily time move 
current unoptimized implementation call move call visit worthwhile remote invocation cost milliseconds 
acm transactions computer systems vol 
february 
fine grained mobility emerald system table ii 
remote operation timing operation type local invocation kernel cpu time 
remote invocation elapsed time remote invocation remote invocation local parameter remote invocation 
call bv move parameter remote invocation call visit parameter remote invocation remote parameter table iii 
incremental cost remote invocation parameters parameter passing mode time ms call bv move call bv visit call remote moving simple data object object takes milliseconds 
time round trip message time reply messages piggybacked messages move require unique reply 
moving object process complex previously stated emerald need move entire address space send translation data object linked address space destination node 
time move small process object variables milliseconds 
case emerald kernel constructs message consisting bytes information including object immediate data replicated objects stack segment general process control information 
process control information stack segment consume bytes 
message traffic emerald mail system elapsed time benefit call move shown table iii due primarily reduction network message traffic 
measured effect traffic reduction emerald mail system experimental application mod eden mail system 
mailboxes mail messages implemented emerald objects 
contrast traditional mail systems message addressed multiple recipients copied mailbox 
single mail message shared multiple mailboxes addressed 
workstation environment expect person mailbox normally remain owner private workstation 
person changes workstations reads mail workstation mailbox moved 
expect mail messages mobile 
message acm transactions computer systems vol 
february 
jul levy hutchinson black table iv 
mail system traffic mobility total elapsed time seconds remote invocations network messages sent network packets sent total bytes transferred total bytes moved mobility composed invoked heavily sender order define contents fields reside sender node 
section discussed mail messages may utilize call move single destination mailbox delivery 
multiple destinations reasonable message stay sender node message read may profitable message reader mailbox 
measure impact mobility mail system implemented versions mobility uses mobility attempt decrease message traffic 
emerald mail system reading mail message takes invocations get mail message mailbox read fields 
mail message remote reading message take remote invocations 
moving mail message remote invocations replaced move followed local invocations 
additional effort may required mailboxes find message moved 
facilitate comparison synthetic workload drive mail system implementations 
short messages bytes long messages bytes sent user nodes various combinations users nodes recipients read mail received 
table iv shows measurement data collected emerald kernel 
table shows mobility halved number remote invocations reduced number network packets percent cut total elapsed time percent 
number network messages sent exactly twice number invocations invocation requires send reply 
number packets slightly higher number network messages long mail messages require packets 
note number packets required invocation higher mobility mobile mail messages cause subsequent message readers follow forwarding addresses 
moving mail messages reduces total number bytes transferred slightly percent 
data eventually arrive remote site remote invocation move byte overhead move slightly invocation 
applications small portion data object required remote site invocation efficient move 
acm transactions computer systems vol 
february 
fine grained mobility emerald system interesting note percent execution time difference achieved simply adding word move places application 

summary designed implemented emerald object language system distributed programming 
emerald operational small network vax computers ported sun appli cations implemented including hierarchical directory system replicated name server load sharing application shared appointment calendar system mail system 
goals emerald included support fine grained object mobility efficient local execution single object model suitable programming small local data objects active mobile distributed objects 
described language features run time mechanisms support fine grained mobility 
process mobility movement complete address spaces previously demonstrated distributed sys tems believe object mobility implemented emerald additional benefits 
overhead emerald object commensurate complexity mobility provides relatively efficient way transfer fine grained data node node 
need semantic support mobility distribution types led design new language language support crucial part mobility emerald 
invocation location independent language primitives find manipulate location objects 
programmer declare attached variables objects named attached variables move objects attached 
important remote tions parameter passing mode called call move permits invocation argument object moved invocation request 
measure ments demonstrate potential facility improve remote invocation performance retaining advantages call semantics 
implementing fine grained mobility minimizing impact local performance presents significant problems 
emerald objects node share single address space objects addressed directly 
invocations implemented procedure call line code possible 
result pointers translated object moved 
addresses appear object representation activation records registers 
emerald run time system relies compiler produced templates describe format structures 
combination compiled invocation code run time support responsible maintaining data structures linking activation records objects invoke 
lazy evaluation structure helps reduce cost maintenance 
sun trademark sun microsystems acm transactions computer systems vol 
february 
jul levy hutchinson black language support tightly coupled compiler kernel believe design successful providing generalized mobility degradation local performance 
acknowledgments edward lazowska richard extensive reviews early versions 
brian bershad carl binding kevin jeffay raj referees helpful comments 

synchronization recovery actions 
proceedings sigact sigops symposium principles distributed computing montreal aug 
acm new york pp 


black wiebe 
locally distributed mail system 
proceedings th international conference software engineering orlando fla mar 
acm new york pp 


black lazowska noe eden system technical review 
ieee trans 
softw 
eng 
se ii jan 

bennett distributed smalltalk 
proceedings nd acm conference object oriented programming systems languages applications orlando fl oct 
acm new york pp 


black supporting distributed applications experience eden 
proceedings th acm symposium operating system principles orcas island wash dec 
acm new york pp 


black hutchinson jul levy 
object structure emerald system 
proceedings st acm conference object oriented programming systems applications portland ore oct 
acm new york pp 


black hutchinson jul levy carter distribution types emerald 
ieee trans 
softw 
eng 
jan 

popek network tasking locus distributed unix system 
usenix summer conference proceedings salt lake city ut june usenix association pp 


jr coupling systems processors 
phd dissertation dept computer science carnegie mellon univ pittsburgh pa aug 

dijkstra lamport martin scholten fly garbage collection exercise cooperation 
commun 
acm nov 

douglis process migration sprite operating system 
tech 
rep ucb csd computer science division univ california berkeley feb 

fowler decentralized object finding forwarding addresses 
phd dissertation univ washington seattle wash dec 
available dept computer science tech 
rep 

goldberg robson smalltalk language implementation 
addison wesley reading mass 

greif weihl atomic data abstractions distributed collaborative editing system 
proceedings th symposium principles distributed computing jan 
acm new york 

herlihy liskov value transmission method data types 
acm trans 
program 
lang 
syst 
oct 

network architecture knowledgeable systems 
conference record lisp conference palo alto calif aug 
stanford univ pp 


hewitt baker actors continuous functionals 
working conference formal description programming concepts st andrews aug 
north holland amsterdam pp 

acm transactions computer systems vol 
february 
fine grained mobility emerald system 
hutchinson emerald object language distributed programming 
phd dissertation univ washington seattle jan 
available dept computer science tech 
rep 

kung song efficient parallel garbage collection system correct ness proof 
proceedings th annual symposium foundations computer science providence ri oct 
ieee computer society new york pp 


lazowska levy fischer fowler architecture eden system 
proceedings th symposium operating systems principles pacific grove calif dec 
acm new york pp 


liskov overview argus language system 
programming methodology group memo mit laboratory computer science mit cambridge mass feb 

liskov atkinson bloom moss schaffert scheifler snyder clu manual 
tech 
rep mit lcs tr mit laboratory computer science mit cambridge mass oct 

powell miller process migration demos mp 
proceedings th acm symposium operating systems principles woods oct 
acm sigops new york pp 


rashid robertson accent communication oriented network operating system kernel 
proceedings th symposium operating system principles pacific grove calif dec 
acm new york pp 


sollins copying complex structures distributed system 
master thesis mit lcs tr mit cambridge mass may 

spafford kernel structures distributed operating system 
phd dissertation school information computer science georgia institute technology atlanta ga may 
available georgia institute technology tech 
rep git ics 

spector performing remote operations efficiently local computer network 
commun 
acm apr 

theimer cheriton preemptable remote execution facilities system 
proceedings th acm symposium operating systems principles orcas island wash dec 
acm sigops new york pp 


garbage collection exercise distributed fault tolerant programming 
phd dissertation univ washington seattle jan 
available dept computer science tech 
rep 

wulf levin harbison hydra mmp experimental computer system 
mcgraw hill new york 
received may revised august accepted september acm transactions computer systems vol 
february 
