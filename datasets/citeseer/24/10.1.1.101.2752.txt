ieee transactions software engineering vol 
june scaling step wise refinement don batory member ieee jacob neal student member ieee axel student member ieee step wise refinement powerful paradigm developing complex program simple program adding features incrementally 
ahead algebraic hierarchical equations application design model shows step wise refinement scales synthesize multiple programs multiple representations 
ahead shows software elegant hierarchical mathematical structure expressible nested sets equations 
review tool set supports ahead 
demonstration viability bootstrapped ahead tools equational specifications refining java non java artifacts automatically task accomplished ad hoc means previously 
index terms specification design notations documentation representation design concepts methodologies data abstraction extensible languages program synthesis feature oriented programming refinement 
step wise refinement powerful paradigm developing complex program simple program incrementally adding details 
program increments consider feature refinements modules encapsulate individual features feature product characteristic distinguishing programs family related programs product line 
implementations feature refinements different names capabilities limitations layers feature modules metaclasses collaborations subjects aspects concerns 
general traditional packages encapsulate sets complete classes feature refinement encapsulate fragments multiple classes 
fig 
depicts package classes 
refinement cross cuts classes encapsulates fragments 
holds refinements 
composing refinements yields package fully formed classes 
refinements reify levels abstraction feature refinements called layers name visually reinforced vertical stratification fig 

concepts refinements layers features closely related terms interchangeably 
general feature refinements modular albeit unconventional building blocks programs 
tools synthesize applications composing feature refinements generators focus production source code individual programs 
batory department computer sciences university texas austin austin texas 
mail batory cs utexas edu 
institut informatik ludwig maximilians universit nchen munich germany 
mail axel de 
manuscript received sept revised jan accepted mar 
recommended acceptance dillon 
information obtaining reprints article please send mail tse computer org ieeecs log number 
limited 
today systems individual programs groups different programs collaborating sophisticated ways 
client server architectures examples tool suites ms office 
systems solely described source code 
architects routinely different knowledge representations process models uml models makefiles design documents capture application design 
representation encodes different design information expressed language uml diagram ocl xml contribution shows step wise refinement scales simultaneous synthesis multiple programs multiple representations written different languages 
challenge possibility ad hoc ways 
challenge create algebraic model application synthesis treats representations code individual programs multiple programs uniform way 
expressing refinement system representations equations simplify tool development equations ideal program manipulation lay groundwork specifying generating optimizing application designs considerable complexity simple algebraic techniques 
review genvoca model shows code representation individual program expressed equation 
algebraic hierarchical equations application design ahead model generalizes equational specifications multiple programs multiple representations 
ahead related models aspect oriented programming multidimensional separation concerns results genvoca specific 
review tool set supports ahead 
demonstration ahead viability bootstrapped ahead tools generating loc java artifacts solely equational specifications automatically task accomplished ad hoc means previously 
ieee published ieee computer society ieee transactions software engineering vol 
june fig 

classes refinements layers 
genvoca genvoca design methodology creating application families architecturally extensible software software customizable module additions removals 
follows traditional step wise refinement major difference composing thousands microscopic program refinements 
yield admittedly small programs genvoca scales refinements adds feature program composing refinements yields entire program 
model concepts initial programs constants refinements functions add features programs 
consider constants represent programs different features program feature program feature refinement function takes program input produces feature augmented program output adds feature program adds feature program application equation named expression 
different equations define family applications app app features app app features app app features features application determined inspecting equation 
model set constants functions members building blocks product line 
note function represents feature implementation different functions different implementations feature adds implementation adds implementation application requires feature problem expression optimization determine implementation best provides best performance 
possible automatically design software find expression optimizes criteria set declarative constraints target application 

different equations represent different programs equation optimization space semantically equivalent programs 
similar relational query optimization query represented relational algebra expression expression optimized space semantically equivalent query evaluation programs 
fig 

implementing refinements mixin inheritance 
example kind automated reasoning historically called automatic programming 
expression optimization discussed detail section 
genvoca constants functions untyped typing constraints exist design rules 
design rules capture syntactic semantic constraints govern legal compositions 
details design rules germane elaborate importance section 
model implementation genvoca constant represents base program set classes 
genvoca function set classes class refinements 
class refinement introduce new data members methods constructors target class extend override existing methods constructors class 
years emulated class refinement inheritance mixins classes superclass specified parameter 
mixins add new data members methods constructors extend existing methods constructors superclass 
unfortunately mixins approximate class refinement inherit constructors superclass mixin assume name superclass 
simple design techniques avoid limitation illustrate 
fig 
depicts composition 
constant base program encapsulates classes ai di 
function refines classes vertical lines fig 
denote class refinement adds class 
encapsulates cross cut refines classes ai ci di represented mixins aj cj dj adds class ej 
application function results refinement classes cj dj 
linear refinement chains common method implementation 
composition fig 
produces classes 
class synthesized linear refinement chain members features expressed pseudo java code class extends aj ai class extends bi class extends ck cj ci class extends dk dj di class extends ej represent mixins class refinements functions 
mixin aj function applied base class ai 
expression aj ai defines linear refinement chain classes 
class name batory scaling step wise refinement fig 

refinement inheritance hierarchies 
terminal class chain 
similarly ck cj ci defines linear refinement chain classes class name terminal class chain classes instantiated synthesized application terminal classes refinement chains classes 
nonterminal classes unshaded fig 
instantiated 
synthesized classes need stand belong inheritance hierarchy 
suppose classes subclasses fig 
subclassing shown bold lines 
refinement chains synthesize fig 
classes bi ci declared subclasses synthesized class subtlety inheritance doing double duty implements subclassing bold lines fig 
emulates refinement relationships shown thin lines 
design scheme allows refine arbitrary subclassing hierarchies adding new classes refining existing classes key technique building jakarta tool suite set compiler compiler tools genvoca models build product lines preprocessors extended java languages 
arguably simplest implementation class refinements mixin inheritance sophisticated means possible 
examples include generators program transformations objects 
scaling refinements ideas led generalize genvoca model 
application representations source code 
application defined uml documents process diagrams makefiles performance models design rule files written language 
suggests conventional notions modularity broadened leads second idea module containment hierarchy artifacts include 
smaragdakis batory showed cases instantiation nonterminal classes useful possible special casting capability may languages 
java implementations example instantiate nonterminal classes refinement chain 
fig 

makefiles refined makefiles 
base makefile 
foo bar refined makefile 
multiple representations application 
traditional example object oriented source code class module encapsulating set data members methods identified signature 
similarly java package kind module encapsulates set class files identified fully qualified class name 
ee ear file module encapsulates set java jar files deployment descriptors html files identified entry name 
application kind module representation containment hierarchy named artifacts including code makefiles documentation 
third scalable notion refinement able refine representations consistent fashion 
application refined representations may changed 
application represented containment hierarchy refinement function transforms arbitrarily nested containment hierarchies primitive artifacts 
refinement may alter containment hierarchy adding new nodes refined application may introduce new java html files may refine existing nodes existing java html files modified 
leaves define refinements artifacts 
goal intuitive start original artifact apply zero refinements produce updated artifact 
general principle guide defining representation specific refinement artifact 
leads fourth idea call principle uniformity impose object structure artifacts type advantage natural indexing scheme may exist define refinement follow notions mixin inheritance specifically class refinement 
consider makefile typical artifact 
fig 
shows makefile targets main common clean 
common built main clean dependencies 
suppose targets part base feature 
fig 
shows refinement base foo ieee transactions software engineering vol 
june fig 

makefiles refinements composition 
base makefile foo refinement bar refinement bar foo base 
encapsulates cross cut targets adds file compile main file compile common 
fig 
shows refinement foo base bar adds file compile main new instruction delete ser 
makefile natural indexing scheme targets uniquely named target associated actions 
analogous association class method signatures method definitions 
take advantage analogy impose object structure makefiles target names play role method signatures target build actions play role method definitions 
idea applies makefile concepts properties 
steps augment makefile syntax declare makefile refinements create tool implements makefile composition 
fig 
base makefile 
fig 
fig 
respectively show way makefile syntax augmented introduce keyword super specify refining makefile target makefile 
makefile composition tool expand super textual substitution passing final result fig 
program 
approach possible implement overriding advice makefile methods makefile refinement 
new targets dependencies specified appropriate makefile refinement tool 
example fig 
shows makefile refinement baz overrides target common augments target clean adds targets gui lnk appropriate dependencies 
composition baz base textual substitution super shown fig 

interestingly artifact types today xml html word documents objectbased structure 
types aren objectoriented support inheritance general refinement relationships instances 
example support mixin inheritance word documents 
principle uniformity clear introducing new artifact type tasks done support inheritance relationships instances implement refinement operation realizes mixin inheritance 
word documents example reasonable support inheritance building natural indexing scheme chapters sections paragraphs admittedly daunting task implement refinement operation textual substitution 
ability refine artifacts scale refinements significant way 
ahead genvoca expressed code representation individual program equation 
model called algebraic hierarchical equations application design ahead expresses arbitrary number programs representations nested sets equations form ideal generators manipulate 
section show ahead constants functions compositions fig 

makefile refinement composition 
baz refinement baz base 
batory scaling step wise refinement fig 

constants functions sets collectives 
constant set constraints 
function set functions constants 
represented illustrate power model 
section review tool set ahead 
constants functions base artifacts constants artifact refinements functions 
artifact results refinement chain modeled series functions refinements applied constant base artifact 
fig 
depicts graphical notation genvoca constant encapsulates base artifacts af cf 
pictures express constant mathematically set constants fa bf cfg 
similarly fig 
depicts graphical notation genvoca function encapsulates functions ah bh constant dh 
function expressed mathematically set functions constants fa bh 
composition term collective alternative set members collective units represent constants functions 
writing denote composition henceforth write composition collectives governed rules inheritance 
units parent inner righthand side collective inherited child outer lefthand side collective 
units name ignoring subscripts composed pairwise parent unit inner term bh chg faf bf dfg af bh bf ch dfg equivalently set equations equation names unit names subscripts fa dg ah af bh bf ch df expression collective defines refinement chain artifact produced 
fig 
shows correspondence graphical notation ahead expression ah af refinement chain artifact bh bf chain artifacts refined unchanged original definitions 
fig 

expression refinement chain correspondence 
containment hierarchies compound artifacts expressed nesting units may collectives 
composition compound artifacts achieved composing nested collectives 
example suppose ah af fig 
collectives ah fx af fx expression ah af expands collective fx xf 
maximum depth collectives nested rank collective 
empty collective rank collective rank compound artifact containment hierarchy 
java program example compound artifact nonleaf node leaves set java files java java 
implement set xml files xml xml 
defines build scripts feature represents ahead constant function defined tree units 
features composed corresponding units composed 
feature composition simple interpretation 
polymorphism composition operator polymorphic 
artifacts composed operators specific artifact type 
java files design rule files xml files unique implementation operator 
different artifact types different artifact type specific composition operators 
see section may composition operators artifact type 
operator composing collectives rank different operator composing collectives rank 
call principle abstraction uniformity special case principle uniformity 
imposing uniformity levels abstraction produces compact powerful algebra defining composing systems 
scalability oo programming languages support parameterized inheritance define refine code artifacts unsuitable representations 
contrast equations elegantly express refinement relationships representations 
furthermore equations containment hierarchies enable step wise refinement generators scale 
building huge generator deals possible program representations impractical easier build elementary tool called composer expands high level ieee transactions software engineering vol 
june fig 

organization ahead generators 
equation constituent artifact equations 
simple composer tool orchestrating relatively simple artifact type specific tools produce complex set artifacts comprise synthesized system fig 

ahead tool support simple way implement collective file system directory 
directory contents files primitive units subdirectories collectives 
fig 
shows collective defines feature consists unit drc design rule file collectives code jak jak jak files extended java files htm htm 
fig 
depicts representation directory 
feature composition directory composition 
composite directory produced organization isomorphic directories composed 
fig 
shows composition features resulting feature corresponding units directory composed produce compound unit 
example jak composition jak jak organization initially built ahead tools jakarta tool suite mentioned earlier 
ahead tools written jts produced dialect java includes refinement declarations metaprogramming constructs lisp quote unquote hygienic macros 
bootstrapped implementation ahead tools 
discuss topic section 
main tool ahead composer takes equation input recursively expands equation nested collective equivalent 
creates composite feature directory name input equation invokes artifact specific composition tools synthesize artifact files generated nested fig 

collectives directories 
collective directory directory composition 
equations 
composer fairly simple written lines java 
tools implement composition operator specific artifact types 
tools built composed code artifacts verifying code synthesis capabilities ahead priority 
subsequently composition tools artifacts html files makefiles equation files design rule files xml files bnf grammar files synthesizing extensible preprocessors constructed 
anticipate set composition tools grow larger time 
sections illustrate composable code artifacts supported ahead 
code artifacts jak source code files composed ahead tools pure java superset java called jak pronounced jack short jakarta java extended embedded domain specific languages dsls refinements state machines metaprogramming 
ahead tools java language extensible ahead support java dialects 
jak specific tools invoked compose jak files 
different implementations operator mixin 
take equation input defines refinement chain jak artifact produces single composite jak file output 
third tool jak java translates jak file java counterpart 
step paradigm uses mixin compose jak files jak java derive corresponding java file composite jak file fig 

source code jak file defines code constant function 
code constant single interface class state machine 
jak interface class declaration indistinguishable java counterparts feature declaration specifies name feature file belongs see fig 

interesting state machine declaration consists state edge transition declarations 
state machine fsm fig 
declares states edges 
see details :10.1.1.17.5396:10.1.1.17.5396
code function refines interface class state machine 
refines modifier distinguishes constant declarations functions 
refinement class fig 
shown fig 

adds new data member batory scaling step wise refinement fig 

composing translating jak files 
counter new method method 
methods refined extended usual way overriding original method invoking method super call extension body 
refinement state machine fsm shown fig 

adds state edge 
composition mixin sophisticated tools java loc size 
functionality fairly simple 
conceptually compresses refinement chains single interface class state machine specification 
result composing function constant fig 
shown fig 
resulting class exposes union package imports data members methods visible bottom class refinement chain 
result composing fsm function fsm constant fig 
shown fig 

resulting state machine exposes union package imports states edges visible bottom state machine refinement chain 
tool compose code 
soon discovered preferred tool 
see typical debugging cycle 
compose jak files 
translate composite jak file java counterpart 
compile debug java file 
update composite jak file bug fixes 
translate compile update cycle continues changes needed 
lies problem preserve feature boundaries changes composite jak file manually propagated back original jak feature files 
tedious error prone 
mixin created alternative implementation jak composition operator 
preserves feature boundaries creating inheritance hierarchy refinement chain class interface state machine declarations single jak file bottom declaration public 
class interface state machine declaration source statement identifies feature name path file instantiated declaration originated 

adding new reserved words language may preclude compilation legacy programs new word previously legal program identifier 
case alteration keyword source minimizes likelihood conflict legacy program identifiers 
figs 
shows mixin output corresponding compositions figs 

availability source statements created fourth tool called takes mixin produced jak file input automatically propagates updates comments source statements original feature files 
saves considerable time development cycle 
strategy possible edit original feature files 
experience suggests debugging features similar debugging templates instantiates template debug develop changes eventually back propagated original definition 
know tools processes engineers prefer developing software ahead subject 
artifacts grammars grammars defined ahead bnf syntax 
grammar elementary calculator supports integer summations shown fig 

integer token predefined plus token explicitly defined 
refinement base grammar grammar fragment defines new tokens new productions extensions previously defined productions 
refinement calculator grammar generalizes computations additions subtractions shown fig 

defines new token minus extends previously defined production operator 
operator super construct says extend existing operator production 
composition fig 
fig 
fig 
union token definitions resulting set productions 
grammar refinement follows principle uniformity equating tokens data members productions methods 
grammars refined addition new data members tokens new methods productions extensions previously defined methods productions 
grammar composition arises synthesis ahead tools tools language extensible 
feature extends base language java compose grammars base language extension produce composite grammar 
grammar synthesize parsers analysis programs standard compiler compiler tools 
artifacts equation specifications equation file encodes ahead equation specification synthesizing code artifact 
file depicted fig 
name file equation file text file lists feature line innermost feature 
refinement equation follows principle uniformity treat equation method refinement equation may parent equation super 
refinement equation depicted fig 
result composing equation files figs 
fig 

refinement super constant overrides parent definition 
ieee transactions software engineering vol 
june fig 

ahead code constants functions 
class constant state machine constant class function state machine function 
depending replacement super equation file refinement add new features original equation file methods 
equation files useful command line input composer implementing metamodels topic section 
additional artifacts special domain specific language defining design rules 
rules essentially preconditions postconditions define legal ordering units composed 
composition design rule preconditions postconditions follows standard techniques described detail earlier research ahead documentation 
ahead expressions optimized way relational algebra expressions database systems optimized 
operator constant function requires distinct representations code representation implement operator design rule representation composition validation performance model representation evaluate efficiency composition 
see details performance models represented refined equations optimized 
examples calculator models elementary ahead models sketched detail section 
value serve double duty illustrate different ahead models relationships relationships expressed ahead models called metamodels topic section 
calc model consider synthesis family postfix calculators features arithmetic operations 
ahead model single constant representing calculator operations 
refinements add individual operations addition add subtraction sub calculator calc consider units calc 
unit collective single file 
source files listed fig 

jak base calculator jak introduces add operation jak introduces sub operation 
note jak jak class refinements add method class cal fig 

compositions jak files 
fig 

mixin compositions jak files 
batory scaling step wise refinement fig 

grammar files constant function composition 
synthesize calculator add sub operations evaluate equation sub calc 
result fig 

method refinements target class cal simply union members figs 

note order composed matter independent 
order add sub methods added cal class inconsequential 
gui cl models suppose want synthesize client callable interface calculator 
model synthesizes gui calculator gui units correspondence calc units gui 
calc unit gui collective single file 
source files listed fig 

briefly file jak defines base gui class text field clear enter buttons 
gui displayed jak shown fig 

key methods class gui atoms buttons text fields initialized gui atoms linked layout containment hierarchy display event listeners event actions coded 
fig 

equation files constant function composition 
calculator operation added gui add sub operations base jak class refined way gui button declared operation adds new data member class 
button initialized extending method 
button added containment hierarchy extending method 
button click events event actions added method 
evaluate equation gui model synthesize single class displays gui fig 

general unit gui model corresponds calculator operation adds new button bottom row 
operation units composed buttons operation gui 
reasoning possible imagine cl model gives command line interface calculator works lines cl composing units synthesizes class main method command line parser understands parse execute calls designated operations 
perspective calc gui cl models loosely coupled 
example may exist fully configured calculator class gui cl models allow synthesize customized interface class exposes selected operations 
alternatively models tightly coupled calculator user callable interfaces synthesized lock step 
tightly coupled models common formalized metamodels 
ieee transactions software engineering vol 
june fig 

calculator source code jak jak jak 
advanced topic metamodels recall model collective units building blocks product line 
suppose model 
suppose variations define ahead model called metamodel expresses product line models 
metamodel product line includes mm mm ab cd ab fig 

synthesized cal jak file 
cd mm synthesize models composing units mm ab cd ab cd units mm building blocks models 
interesting uses metamodels 
service packs service pack update model 
service pack metamodel sp contains initial model series service pack updates incrementally updates model sp fm composition operator called replace apply changes service pack existing model 
uk uj primitive units law replace operator uk uj uk uk replaces uj 
identical composition operator collectives 
special case 
model date regard service pack defined equation 
effects applied replacing old base artifacts new ones adding new artifacts 

special primitive units indicate physical deletion replacement designated files 
calculator metamodel return calc gui cl models section 
units models correspondence tight coupling models embed units metamodel cmm fig 

gui base 

design rule si applied si 
batory scaling step wise refinement fig 

calculator gui source code 
base jak add jak sub jak fig 

refined gui 
cmm calc gui cl 
calc lone constant gui cl functions add different front ends 
product line cmm distinct models basic calc front gui calc gui front cl calc command line front ieee transactions software engineering vol 
june fig 

declarative feature specification 
clg cl gui calc command line gui front ends consider 
model allows simultaneously synthesize calculator class corresponding gui front 
look contents expanding definition gui calc jak jak jak 
model number units names ignoring subscripts calc gui 
unit encapsulates pair files file represents calculator base refinement second represents corresponding gui base refinement 
example encapsulates refinement jak adds sub operation base calculator class refinement jak integrates subtraction button base gui class 
significance metamodels cmm separates concerns separates design specification possible implementations 
example design application specified equation sub add base 
equation states addition subtraction operations specifying implementation 
supply implementation evaluated context model 
model calc calculator source generated 
model calculator source gui generated 
example metamodels separate specification application design family implementations 
allow create declarative feature oriented specifications expressed gui front ends fig 

check boxes left column gui specify features calculator design check boxes right column specify model 
input equation metamodel equation cgl inferred 
equations specify particular calculator large space possible calculators implementations 
making feature design specifications orthogonal feature implementation specifications leads interesting result 
specifying application single equation pair equations define application 
generalize approach single application specified equations orthogonal concern 
call generalization significance 
show length equations terms 
calculator metamodel particular example 
length specification kn 
metamodels show corresponding ahead specification exponentially longer terms 
examples explain ahead tools synthesized compact equations 
applications ahead build generation distributed fire support simulators fsats army simulation training instrumentation command 
years ago built feature oriented prototype fsats :10.1.1.17.5396
nontrivial test ahead converted prototype source code included classes interfaces state machines ahead features 
added design rule files makefiles ahead features composed different representations fsats code design rules makefiles synthesized 
prototype defined single ahead equation composing features yielding files java loc 
significant test bootstrapping ahead 
mentioned earlier ahead tools initially built jts 
bootstrap ahead converted jts source ahead features 
addition code representations ahead directories included grammar bnf files defined syntax optional java language extensions 
ahead metamodel generate equations ahead tools including mixin jak java ahead tools synthesize executables 
convey complexity bootstrapping step offer arguments distinct ahead features constituting code base jak loc 
ahead equation tool approximately features features shared ahead tools 
tool generated composing jak grammar representations feature translating representations java resulting loc tool 
equational specifications generating ahead tool suite java loc automatically task accomplished ad hoc means previously 
subjectively estimate write main tools ats hand take man years 
effort manually replicate entire tool suite goes main tools include code formatters document generators graphical interface times 
experimentally validate estimates costly 
importantly tools feature extensible prime motivation batory scaling step wise refinement ahead require toolkit ahead available place 
reason bootstrap ahead demonstrate feature extensibility nontrivial application 
bootstrapping compiler major milestone compiler development convincing test compiler compile 
compilers multiple levels abstraction superimposed code 
bootstrapping requires levels separated 
doing nontrivial 
holds ats difficult ats just single tool suite interdependent tools requiring different representations composed 
short bootstrapping ats major achievement 
believe ats sophisticated system produced automatic step wise refinement 
ahead raises interesting questions including ability analyze designs tools model checkers critical design technologies 
tools fit refinements ahead designs 
preliminary results encouraging see 
operators collectives units operators 
javac example operator collective compiles encapsulated java files collective 
javadoc derive html documentation java files general development tools realized operators collectives 
equating standard tools operators enrich algebra software development 
applications specified algebraically amenable automated optimization reasoning 
possible derive artifacts class files derived java files javac composition operators needed basic artifact types 
maintaining consistency basic types refinement english explanations source code currently accomplish manually 
tool support artifact derivation consistency maintenance artifacts needed 
refinements impact cross cut different parts programs require sophisticated implementations refinements ahead 
example information multiple artifacts may decide refine artifacts en mass functions modeled implemented 
ahead constants functions typed 
feature directories composed ahead structure type tools sophisticated validate assumption 
type theory needed express refinements artifact hierarchies 
section mentioned operator polymorphic 
current implementation realizes overloading 
appears higherorder ahead implements composition time static transformations treat operands purely typed data type subtype unit 
applied java code java specific transformation tool invoked general type specific tool invoked implement composition 
sense bounded polymorphic 
type theory ahead clarify issues 
code composition tools preprocessors 
eventually needed proper extensions programming languages allow separate compilations features 
concept code refinement similar open class concept multijava separate compilation type checking class extensions correspond ahead features correctly handled multi java support method refinement composition selected extensions 
ahead developed functions parameter 
genvoca models containing functions multiple parameters 
cases functions natural software developers 
functions implemented ahead 
issue analogous single inheritance versus multiple inheritance 
features implemented cross cuts granularity feature scales individual feature encapsulated com net corba component 
ahead generalize represent features 
principle uniformity imposes object model organizations artifacts 
cases sequences artifacts sets expressed refinement operations sequences insert insert considered 
example xml documents trees order matters children parent node listed 
needed define precisely concept object model organizations sequencing generalization principle uniformity covers ordered sequences 
relationship ahead ideas disciplines 
place perspective consider broad relationships paradigms computer science relationships specific prior 
perspective relational query optimization believe software development lies compositional programming automated software engineering 
successful example relational query optimization 
relational query specified declarative domain specific language sql parser maps ieee transactions software engineering vol 
june inefficient relational algebra expression query optimizer optimizes expression automatically efficient query evaluation program generated optimized expression 
great example automatic programming transforming declarative specification efficient program compositional programming program synthesized composition algebraic operators 
ahead generalization paradigm compositional programming automated software development realized domains 
ahead supports paradigm mapping declarative specifications users specify features want program actual implementation 
possible programs synthesized composing modules implement required features mapping feature specifications equations difficult 
novelty ahead models software domains algebras features operators 
particular programs expressions compositions operators 
power paradigm optimizing equational representations programs algebraic identities 
joins distributivity projects joins examples relational algebra 
showed equational representations container data structures optimized equational rewrites demonstrating programs domains relational queries benefit equational optimizations 
current research shows tools automatically minimize tool build times equational manipulations 
believe ahead lays groundwork equational manipulation optimization programs 
algebraic specifications formal approach program development algebraic specifications 
specification java interface set method signatures importantly goes java additional formal contractual obligations demanding implementation certain properties 
implementation said satisfy specification conforms specification signatures adheres contract 
semantics specification defined implementations satisfy 
specification leaves implementation details executable intended understandable easily written humans 
step step concrete possible implementation 
point unique mapping specification program 
key points algebraic refinement step preserves behavior adding new functionality formally prove 
implementation refined specification provably implementation original specification 
ahead concept refinement different ahead refinements usually add functionality programs 
adding 
definitions refinement literature 
common 
functionality programs called extension algebraic specification parlance 
ahead algebraic specification complementary ahead profit rigorous formal foundation ideas behavioral contracts 
ahead encapsulates features unit composition general algebraic specification 
hand algebraic specifications ahead tree structured representation support multiple artifact types 
key difference ahead units designed encapsulate implementations reusable features required algebraic specifications 
ahead deal algebraic specifications traditional sense exact relationship subject 
goal extend ahead composition operator apply algebraic specifications collectives composed simultaneously construct combined specification implementation 
premise ahead single specification formalism cover cover aspects program 
ahead allows number related specifications composed 
regard ahead algebraic specification model driven architectures system defined multiple distinct overlapping specifications 
functional programming idea architectural designs programs functional form implicit papers software architecture 
core ideas metaprogramming programs values functions transform values originated functional languages 
recursive application apply operators fold trees elegant representation functional languages 
ahead shows functional algebraic descriptions programs scale 
traditional metaprograms deal definition composition small code fragments lisp quote unquote ahead contrast deals programs program refinements larger hierarchical multiclass scale 
ahead functional model programs built object oriented concepts classes inheritance concepts normally part functional languages 
feature interactions selection feature may disable enable selection features 
developed simple efficient algorithms validate compositions features automatically perry light semantics 
predominant form feature interactions seen 
domains generated software certified properties 
observed properties programs properties individual features 
features composed want assurances properties remain valid 
approach 
equally strong claim points macro programming 
focus functional programming section ahead model characteristics functional languages 
batory scaling step wise refinement synthesis correct software certify properties feature certify properties hold composition 
li developed special model checkers show state space programs reduced feature oriented approach 
may lead composition operators modelchecking feature oriented software 
domain telephony feature interactions extensively studied 
approach exemplified zave jackson independently define telephony features interface properties activation conditions formal description languages promela spin alloy 
descriptions goal composition operators combine subsystem descriptions consideration precedences priorities yield models formally evaluated 
prehofer motivated domains telephony feature interactions fundamental developed generalization mixin inheritance explicitly describes pairwise interactions lifting feature 
lifting set code modifications applied associated interaction occurs mixin composition 
example resolution mixin automatically incorporate pairwise liftings liftings appear give ahead refinements internal structure described exploited 
advanced generators model integrated computing mic vanderbilt 
mic embraces concept architects multiple representations specify application designs mic generators developed synthesize graphical domain specific languages architects specify designs 
information collected specifications integrated stored database 
specific artifacts design ranging source code representations analysis tools model checkers extracted derived database 
mic great success synthesizing software hardware engineering manufacturing domains building blocks systems composition construction paradigms understood 
mic success areas classical software applications building blocks construction composition paradigms understood 
believe ahead contributes ahead provides structure modularize domains features mechanism synthesize applications feature composition 
domain specific languages long recognized efficient way specify applications integrate domain specific analyses validate dsl programs 
dsl usage increasing particularly successful specification product lines 
ahead embraces different general purpose languages dsls primary means specifying artifacts advocates programs written languages refined 
refinement state machines equation files ahead example 
state machines expressed dsl embedded java equation files written standalone dsl 
scaling refinements code artifacts distinguishing feature ahead 
aspect oriented programming aop program refinement technology 
ahead essentially uses templates express refinements 
sophisticated way special compilers implement ahead functions perform computations collective determine collective modified advised 
aspects specifications refinements aspect execute specifications input programs 
aspects provide important kind function currently lacking ahead tool set 
gray shown aspects apply artifacts 
ahead shows code artifacts refined simultaneously collection hierarchies 
multidimensional separation concerns program refinement technology 
built genvoca generators hyper features correspond hyperslices genvoca equations correspond compositions hyperslices 
advocates techniques assembling customized code hyperslice compositions artifacts 
conjecture inspired ahead 
contribution ahead simple algebraic model supports thesis 
believe software engineering lies automation 
integral vision transformation application design art science body knowledge organized principles ideally expressible mathematics 
generators critical vision 
application complexity increases burdens placed generators ability synthesize multiple programs multiple representations increases 
challenge scaling refinement generators possibility number ad hoc ways done 
challenge show scaling accomplished principled manner generators just ad hoc collections tools incomprehensible patchwork techniques 
significance point clear generators technological statement development software domain understood automated 
claim generators complexity generators controlled remain low application complexity scales generator technology wide spread adoption 
ahead model offers practical solution problem 
key ideas represent plethora representations define program code containment hierarchy treat containment hierarchies values express feature refinements functions transform values 
refinements encapsulate ieee transactions software engineering vol 
june changes representations program feature added 
doing discovered application designs elegant hierarchical mathematical structure expressed nested sets equations 
imposing uniformity eliminate ad hoc complexity containment hierarchies scale enable small number operators manipulate ahead concepts importantly keep generators stepwise refinement simple systems synthesize scale complexity 
reviewed implementation ahead described nontrivial systems constructed principles fsats ahead tools 
believe ahead takes important step closer realizing broader vision automation software development 
acknowledgments authors martin wirsing alex knapp ira baxter discussions algebraic specifications 
melanie mark contributions design ahead tools jim browne stan perry roberto lopez helpful comments earlier drafts 
appreciate helpful comments referees 
supported part army simulation training command contract deutsche forschungsgemeinschaft dfg project wi balzer fifteen year perspective automatic programming software reusability ii biggerstaff perlis eds addison wesley 
batory malley design implementation hierarchical software systems reusable components acm trans 
software eng 
methodology oct 
batory composition validation subjectivity genvoca generators ieee trans 
software eng vol 
pp 
feb 
batory smaragdakis jts tools implementing domain specific languages proc 
fifth int conf 
software reuse june 
batory chen robertson wang design wizards visual programming environments genvoca generators ieee trans 
software eng vol 
pp 
may 
batory achieving extensibility product lines domain specific languages case study acm trans :10.1.1.17.5396
software eng 
methodology apr 
batory lopez 
martin generating product lines product families automated software eng sept 
batory liu refinements multi dimensional separation concerns proc 
acm sigsoft conf 
esec fse 
baxter design maintenance systems comm 
acm apr 
bernstein carlson pal sanders microsoft repository version open information model information systems vol 
pp 

bidoit mosses common algebraic specification language user manual lecture notes computer science ifip series springer verlag 
logic programming synthesis transformation proc 
ninth int workshop logic program synthesis transformation ed sept 
bracha cook mixin inheritance proc 
ann 
acm sigplan conf 
object oriented programming systems languages applications pp 

burstall goguen putting theories specifications proc 
fifth int joint conf 
artificial intelligence pp 

lin comparing frameworks layered refinement proc 
int conf 
software eng pp 

clifton leavens chambers millstein multi java modular open classes symmetric multiple dispatch java proc 
ann 
acm sigplan conf 
object oriented programming systems languages applications pp 

dijkstra discipline programming 
prentice hall 
ehrig mahr fundamentals algebraic specification equations initial semantics 
springer 
ehrig mahr fundamentals algebraic specification module specifications constraints 
springer 
forman putting metaclasses 
addison wesley 
flatt krishnamurthi felleisen classes mixins acm principles programming languages pp 

gray handling crosscutting constraints domain specific modeling comm 
acm oct 
griss implementing product line features composing component aspects proc 
int software product line conf aug 
harrison ossher subject oriented programming critique pure objects proc 
ann 
acm sigplan conf 
object oriented programming systems languages applications pp 

harrison barton mapping uml designs java proc 
ann 
acm sigplan conf 
object oriented programming systems languages applications 
hein schlick martins applying feature models industrial settings proc 
software product line conf 
aug 
holzmann spin model checker primer manual 
pearson educational sept 
jackson sridharan mechanism acm sigsoft conf 
fse esec sept 
jackson zave distributed feature composition virtual architecture telecommunications services ieee trans 
software eng vol 
pp 
oct 
liu batory automatic remodularization optimized synthesis product families appear 
lopez batory standard problem evaluating product line methodologies proc 
conf 
generative component software eng 
kang cohen hess novak peterson feature oriented domain analysis feasibility study technical report cmu sei tr software eng 
inst carnegie mellon univ 
kiczales lamping mendhekar maeda lopes loingtier irwin aspect oriented programming proc 
ann 
european conf 
object oriented programming pp 

li krishnamurthi interfaces modular feature verification proc 
conf 
automated software eng 
mezini lieberherr adaptive plug play components evolutionary software development proc 
ann 
acm sigplan conf 
object oriented programming systems languages applications pp 

flatt hsieh jiazzi new age components old fashioned java proc 
ann 
acm sigplan conf 
object oriented programming systems languages applications 
mellor clark model driven development ieee software pp 
sept oct 
implementing data structures composition reusable components formal approach proc 
icse workshop formal methods application software eng 
practice wirsing ed apr 
batory scaling step wise refinement ossher tarr multi dimensional separation concerns re shape evolving software comm 
acm vol 
pp 
oct 
perry logic propagation inscape environment proc 
acm sigsoft conf 
prehofer feature oriented programming fresh look objects proc 
ann 
european conf 
object oriented programming 
prehofer feature oriented programming new way object composition concurrency computation vol 

seamless support creation maintenance object oriented systems oo programming vol 
pp 
oct 
sannella algebraic specification program development stepwise refinement logic program synthesis transformation pp 

smaragdakis batory mixin layers object oriented implementation technique refinements collaboration designs acm trans 
software eng 
methodology apr 
generative programming embedded systems proc 
conf 
generative programming component eng 
oct 
sullivan notkin reconciling environment integration software evolution acm trans 
software eng 
methodology vol 
pp 
july 
tarr ossher harrison sutton jr degrees separation multi dimensional separation concerns proc 
int conf 
software eng 
univ texas center agile technology ahead tool documentation 
notkin role components implement designs proc 
ann 
acm sig plan conf 
object oriented programming systems languages applications pp 

klint little languages little maintenance proc 
sigplan workshop domain specification language 
weiss lai software product line engineering 
addison wesley 
wirsing algebraic specification handbook theoretical computer science pp 

wolf shaw hilfinger fundamental structures computer science 
addison wesley 
zave experiment feature engineering programming methodology pp 

don batory holds david university texas austin 
associate editor ieee transactions software engineering associate editor acm transactions database systems member acm software systems award committee committee chairman program generative programming component engineering conference 
numerous tutorials product line architectures generators reuse industry consultant product line architectures 
member ieee 
jacob neal received ma degree mathematics university california davis ms degree computer sciences university texas austin currently phd student 
research interests generative programming including formalization extension build systems 
student member ieee 
axel received diploma computer science university munich wrote diploma thesis cooperation university texas austin 
technical people shopping portal powers shopping pages wide range european sites yahoo aol hotbot 
currently phd student university munich 
main research interests graph knowledge representations aspects software engineering generative programming language design 
student member ieee 
information computing topic please visit digital library www computer org publications dlib 
