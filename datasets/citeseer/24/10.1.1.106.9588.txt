www computer org tse classification comparison framework software architecture description languages medvidovic richard taylor vol 
january material ensure timely dissemination scholarly technical 
copyright rights retained authors copyright holders 
persons copying information expected adhere terms constraints invoked author copyright 
cases works may explicit permission copyright holder 
ieee 
personal material permitted 
permission reprint republish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component works obtained ieee 
information please see www ieee org portal pages documentation copyright html 
ieee transactions software engineering vol 
january classification comparison framework software architecture description languages medvidovic richard taylor member ieee computer society software architectures shift focus developers lines code coarser grained architectural elements interconnection structure 
architecture description languages adls proposed modeling notations support architecture development 
little consensus research community adl aspects architecture modeled adl possible adls best suited particular problem 
furthermore distinction rarely adls hand formal specification module interconnection simulation programming languages 
attempts provide answer questions 
motivates presents definition classification framework adls 
utility definition demonstrated differentiate adls modeling notations 
framework classify compare existing adls enabling process identify key properties adls 
comparison highlights areas existing adls provide extensive support deficient suggesting research agenda 
index terms software architecture architecture description language component connector configuration definition classification comparison 
software architecture research directed reducing costs developing applications increasing potential commonality different members closely related product family :10.1.1.135.5430
software development common architectural idioms focus shifted lines code coarser grained architectural elements software components connectors interconnection structure 
support development formal modeling notations analysis development tools operate architectural specifications needed 
architecture description languages adls accompanying toolsets proposed answer 
loosely defined adl software applications focuses high level structure application implementation details specific source module 
adls area intense research software architecture community 
number adls proposed modeling architectures particular domain general purpose architecture modeling languages 
specifically consider languages commonly referred adls aesop darwin metah rapide sadl medvidovic department computer science university southern california los angeles ca :10.1.1.26.4897:10.1.1.53.3387:10.1.1.53.3387:10.1.1.25.7933
mail usc edu 
taylor department information computer science university california irvine ca 
mail taylor uci edu 
manuscript received feb revised dec accepted feb 
recommended acceptance jazayeri 
information obtaining reprints article please send mail tse computer org ieeecs log number 
ieee unicon weaves wright 
initial done architecture interchange language acme intended support mapping architectural specifications adl enable integration support tools adls 
strictly speaking acme adl contains number adl features 
furthermore useful compare differentiate adls highlight difference adl interchange language 
included 
little consensus research community adl aspects architecture modeled adl interchanged interchange language 
example rapide may characterized general purpose system description language allows modeling component interfaces externally visible behavior wright formalizes semantics architectural connections 
furthermore distinction rarely adls hand formal specification module interconnection mil simulation programming languages 
example rapide viewed adl simulation language clements contends code parallel programming language adl 
source level support adl provide developers 
spectrum argued primary role architectural descriptions aid understanding communication software system 
adl 
full name adl modeling architectures architectural style distinguish sadl resulted unrelated project referred simply 
medvidovic taylor classification comparison framework software architecture description 
simple understandable possibly graphical syntax understood necessarily formally defined semantics kinds tools aid visualization understanding simple analyses architectural descriptions argo 
spectrum tendency provide formal syntax semantics adls powerful analysis tools model checkers parsers compilers code synthesis tools runtime support tools sadl architecture refinement patterns darwin calculus formalize architectural semantics unicon parser compiler 
perspectives merit adl researchers generally adopted extreme view 
contention important reflected adl 
researchers attempted shed light issues surveying consider existing adls listing essential requirements adl :10.1.1.53.3387:10.1.1.53.3387:10.1.1.53.3387
previous attempted understand compare adls problem areas software architectures suited 
attempts understanding adl various reasons ultimately falls short providing definitive answer question 
builds results efforts 
influenced insights obtained studying individual adls relevant elements languages commonly considered adls programming languages experiences needs ongoing research project 
presents definition relatively concise classification framework adls adl explicitly model components connectors configurations furthermore truly usable useful provide tool support architecture development evolution 
elements adl broken constituent parts 
remainder organized follows section discusses contributions shortcomings attempts surveying classifying adls 
section defines taxonomy adls demonstrates utility determining existing notations adls 
section assesses mentioned adls criteria established section 
discussion round 
related approaches effort discoveries researchers 
closely examined adl surveys conducted clements 
studied researchers attempts identifying essential adl characteristics requirements luckham vera shaw shaw garlan tracz :10.1.1.53.3387:10.1.1.53.3387:10.1.1.53.3387
basis architectural interchange acme gave key insights needs remain constant adls 
built earlier attempts shed light nature needs architecture modeling 
previous surveys clements provide extensive classification existing adls 
classification exhaustive questionnaire adl characteristics features completed language design team 
survey conducted top fashion authors domain analysis techniques decide features adl assessed existing languages respect features 
taxonomy valuable understanding surveyed adls comes short respects 
domain analysis typically wellunderstood domains case adls 
survey provide deeper insight adl criteria including particular modeling notation 
quite contrary surveyed languages commonly considered adls little justification inclusion 
illustrative example specification language hard real time computer systems 
clements labels language edge adls utility architecture community lies sophisticated analysis model checking toolset 
tool support sufficient reason consider adl 
criteria clements adl evaluation ability model requirements algorithms outside adl scope 
kind survey runs risk asking relevant questions 
authors extrapolate specific information multiple potentially subjective vague misunderstood questions 
approach bottom 
surveyed existing adls metah rapide attempted identify common properties 
concluded model support concepts degree components connections hierarchical composition component contains entire computation paradigms semantics constraints nonfunctional properties communication paradigms underlying formal models tool support modeling analysis evaluation verification automatic application code composition 
cursory qualifies limited scope survey contains useful insights bring closer answering question adl approach survey closer clements 
previous attempted identify problems areas concern need addressed adls 
discussion scope software architectures adls perry wolf :10.1.1.135.5430
largely mirrored definition architectures shaw garlan 
ieee transactions software engineering vol 
january representation design process support static dynamic analysis specification time execution time evolution refinement traceability simulation executability 
understanding areas properties key better understanding needs software architectures architecture development architectural description interchange study areas needed guide development generation adls 
demonstrated existing adl currently supports small subset domains discussed possible reasons 
believe taxonomy gives architect sound foundation selecting adl orients discourse problem solving preliminary contribution 
furthermore comparison adls categories reveal specific characteristics constructs render adl suited solving particular set problems certain constructs complementary mutually exclusive 
consequently believe feature classification comparison adls needed 
insights individual systems luckham vera list requirements adl rapide component abstraction communication abstraction communication integrity mandates components connected architecture may communicate resulting implementation ability model dynamic architectures hierarchical composition relativity ability relate map behaviors architectures :10.1.1.53.3387:10.1.1.53.3387
result experience unicon shaw list properties adl exhibit ability model components property assertions interfaces implementations ability model connectors protocols property assertions implementations abstraction encapsulation types type checking ability accommodate analysis tools 
clearly features considered definitive indicators identify adl 
resulted limited experience research groups languages 
represent valuable data points trying understand classify adls 
attempts identifying underlying concepts tracz defines adl consisting components connectors configurations constraints 
taxonomy appealing especially simplicity needs elaboration justification definitions aspects need modeled necessary tool support 
tracz taxonomy similar perry wolf original model software architectures consists elements form rationale :10.1.1.135.5430
perry wolf elements tracz components connectors form subsumes architectural configuration rationale roughly equivalent constraints 
shaw garlan attempted identify unifying themes motivate research adls 
authors successfully argued need treat connectors explicitly class entities adl 
elaborate classes properties adl provide composition abstraction reusability configuration heterogeneity analysis 
demonstrate existing notations informal diagrams modularization facilities provided programming languages satisfy properties fulfill architecture modeling needs 
shaw garlan identify levels architecture specification capability capturing architectural information construction instance composition multiple instances selection design implementation alternatives verifying adherence implementation specification analysis automation 
conclude adls invariably provide notations capturing system descriptions level support levels 
unclear set criteria applied different adls stringent criteria particularly show number adls provide considerable amount support capabilities 
medvidovic argue order adequately support architecture development analysis model architectures levels abstraction internal component semantics component interfaces component interconnections architecture architectural style rules 
taxonomy presents accurate high level view architecture modeling needs general serve adequate adl comparison framework 
furthermore lacks focus connectors 
architecture interchange closest research community come consensus adls emerging endorsement segment community acme architecture interchange language 
order meaningfully interchange architectural specifications adls common basis adls established 
garlan colleagues believe common basis core ontology architectural representation components connectors medvidovic taylor classification comparison framework software architecture description 
systems configurations components connectors ports points interaction component roles points interaction connector representations model hierarchical compositions rep maps map composite component connector internal architecture elements external interface 
acme aspect architectural description represented property lists core 
acme resulted careful consideration issues notations modeling architectures 
viewed starting point studying existing adls developing new ones 
acme represents common denominator existing adls definition adl 
provide means understanding classifying features architectural description placed property lists 
certain structural constraints imposed acme connector may directly attached connector satisfy needs approaches aesop unicon wright 
adl classification comparison framework individually attempts adequately answer question adl reflect authors views adl able 
closer study collections features requirements shows common theme guide formulating framework adl classification comparison 
complete framework characteristics individual adls summaries discussions adls occurred international software architecture workshops studied 
large degree taxonomy reflects features supported existing adls 
certain cases argue characteristics typically supported current adls identified literature important architecture development resulted experience research project software architectures 
tried learn relevant apply extensive experience languages modeling aspects software formulating framework 
properly enable discussion definitions needed 
standard universally accepted definition architecture working definition provided shaw garlan software architecture level design involves description elements systems built interactions elements patterns guide composition constraints patterns 
adl language provides features modeling software system conceptual architecture distinguished system implementation 
adls provide concrete syntax conceptual framework characterizing architectures 
conceptual framework typically reflects characteristics domain adl intended architectural style 
framework typically subsumes adl underlying semantic theory csp petri nets finite state machines 
framework categories introduce top level categories adl classification comparison framework section 
building blocks architectural description components connectors architectural configurations 
adl provide means explicit specification enables determine particular notation adl 
order infer kind information architecture minimum interfaces constituent components modeled 
information architectural description collection interconnected identifiers similar boxes lines diagram explicit underlying semantics 
aspects components connectors configurations desirable essential benefits acknowledged possibly demonstrated context problem domain style absence mean language adl 
suitability language modeling software architectures independent kinds tool support provides accompanying toolset render adl usable useful 
conversely desired manipulations architectural models tools may influence modeling features provided adl 
large segment adl research community actively studying issue tool support effort identify canonical adl toolkit currently way 
adl classification comparison framework depicted fig 

intended extensible modifiable crucial field largely infancy 
remainder section motivates elaborates category framework 
categories identified framework orthogonal adl scope applicability 
model system high level abstraction adl intended expected provide partial depiction system 
types information adl focuses may characteristics application domain style system composition architectural style specific set properties distribution concurrency safety 
regardless focus nature adl general desired kinds representation manipulation qualities architectural models described adl identified fig 
remain constant 
modeling components component architecture unit computation data store 
components loci computation state 
components may small single procedure large entire application 
component may 
architectural configurations various times referred simply configurations topologies ieee transactions software engineering vol 
january fig 

adl classification comparison framework 
essential modeling features bold font 
require data execution space may share components 
discussed explicit component interfaces feature required adls 
additional comparison features modeling component types semantics constraints evolution nonfunctional properties 
discussed interface component interface set interaction points external world 
interface specifies services messages operations variables component provides 
order support reasoning component architecture includes adls may provide facilities specifying component needs services required components architecture 
interface defines computational commitments component constraints usage 
types component types abstractions encapsulate functionality reusable blocks 
component type instantiated multiple times single architecture may reused architectures 
component types parameterized facilitating reuse 
explicit modeling types aids understandability analyzability architecture properties type shared instances 
semantics define component semantics highlevel model component behavior 
model needed perform analysis enforce architectural constraints ensure consistent mappings architectures level abstraction 
note component interface allows certain limited degree reasoning semantics 
notion semantics refers strictly models component behavior 
constraints constraint property assertion system parts violation render system unacceptable desirable stakeholders 
order ensure adherence intended component uses enforce usage boundaries establish dependencies internal parts component constraints specified 
evolution architectural building blocks components continuously evolve 
component evolution informally defined modification subset component properties interface behavior implementation 
adls ensure evolution happens systematic manner employing techniques subtyping component types refinement component features 
nonfunctional properties component nonfunctional properties safety security performance portability typically directly derived specification behavior 
early specification properties architectural level needed enable simulation runtime behavior perform analysis enforce constraints map component implementations processors aid project management 
modeling connectors connectors architectural building blocks model interactions components rules govern interactions 
components connectors may correspond compilation units implemented system 
may implemented separately compilable message routing devices may manifest shared variables table entries buffers instructions linker dynamic data structures sequences procedure calls embedded code initialization parameters clientserver protocols pipes sql links database application forth 
features characterizing connectors interfaces types semantics constraints evolution nonfunctional properties 
defined motivated interface connector interface set interaction points connector components connectors attached 
connector perform application specific computations exports interface services expects attached components 
connector interfaces enable proper connectivity components interaction architecture reasoning architectural configurations 
types connector types abstractions encapsulate component communication coordination mediation decisions 
architecture level interactions may characterized complex protocols 
making protocols reusable architectures requires adls model connectors types 
typically done ways extensible type systems defined terms 
comparison categories components connectors identical derived refined independently 
medvidovic taylor classification comparison framework software architecture description 
interaction protocols built enumerated types particular implementation mechanisms 
semantics similarly components connector semantics defined high level model connector behavior 
components semantics express application level functionality connector semantics entail specifications computation independent interaction protocols 
adls may support modeling connector semantics order enable component interaction analysis consistent refinement architectures levels abstraction enforcement interconnection communication constraints 
constraints connector constraints ensure adherence intended interaction protocols establish dependencies enforce usage boundaries 
example simple easily enforceable constraint restriction number components interact connector 
establishing adherence complex connector constraints minimal throughput may require access information external connector model attached components dynamic semantics 
evolution analogously component evolution evolution connector defined modification subset properties interface semantics constraints 
component interactions architectures governed complex potentially changing expanding protocols 
furthermore individual components configurations evolve 
adls accommodate evolution modifying refining existing connectors techniques incremental information filtering subtyping refinement 
nonfunctional properties connector nonfunctional properties entirely derivable specification semantics 
represent additional requirements correct connector implementation 
modeling nonfunctional properties connectors enables simulation runtime behavior analysis connectors constraint enforcement selection appropriate shelf ots connectors message buses mappings processors 
modeling configurations architectural configurations topologies connected graphs components connectors describe architectural structure 
information needed determine appropriate components connected interfaces match connectors enable proper communication combined semantics result desired behavior 
concert models components connectors descriptions configurations enable assessment concurrent distributed aspects architecture potential deadlocks starvation performance reliability security 
descriptions configurations enable analyses architectures adherence design heuristics direct communication links components hamper evolvability architecture architectural style constraints direct communication links components disallowed 
characteristic features level architectural configurations fall general categories qualities configuration description understandability compositionality refinement traceability heterogeneity qualities described system heterogeneity scalability evolvability dynamism properties described system dynamism constraints nonfunctional properties 
note categories entirely orthogonal heterogeneity dynamism appear categories 
heterogeneity may manifested multiple employed formalisms configuration descriptions multiple programming languages system implementations 
anticipated dynamism system property system may architected specifically accommodate expected dynamic change unanticipated dynamism quality refers system general suitability dynamic change 
differences pairs features subtle particularly case dynamism 
keeping categorization mind order maintain conceptual simplicity framework avoid confusion proceed describing individual features include notions heterogeneity dynamism single respective headings 
motivate appropriate define configuration features understandable specifications role software architecture serve early communication conduit different stakeholders project facilitate understanding families systems high level abstraction 
adls model structural topological information simple understandable syntax 
structure system ideally clear configuration specification having study component connector specifications 
compositionality compositionality hierarchical composition mechanism allows architectures describe software systems different levels detail complex structure behavior may explicitly represented may abstracted away single component connector 
situations may arise entire architecture single component larger architecture 
abstraction mechanisms provided part adls modeling capabilities 
refinement traceability addition providing architects semantically elaborate facilities specifying architectures adls enable correct consistent refinement architectures executable systems traceability changes levels architectural refinement 
view supported prevailing argument developing adls necessary bridge gap informal boxes lines diagrams programming languages deemed low level application design activities 
heterogeneity goal software architectures facilitate development large scale systems preferably 
term quality conventional manner defined ghezzi 
term property refers characteristics application introduced address specific requirements 
ieee transactions software engineering vol 
january preexisting components connectors varying granularity possibly specified different formal modeling languages implemented different programming languages varying operating system requirements supporting different communication protocols 
important adls open provide facilities architectural specification development heterogeneous components connectors 
scalability architectures intended provide developers abstractions needed cope issues software complexity size 
adls directly support specification development largescale systems grow 
evolvability new software systems rarely provide entirely unprecedented functionality variations theme architecture evolves reflect enable evolution family software systems 
evolution maintenance single software development activity system evolvability key aspect architecture development 
adls need augment evolution support level components connectors features incremental addition removal replacement reconnection configuration 
dynamism evolution define refers offline changes architecture resulting system 
dynamism hand refers modifying architecture enacting modifications system system executing 
support dynamism important case certain safety mission critical systems air traffic control telephone switching high availability public information systems 
shutting restarting systems upgrades may incur unacceptable delays increased cost risk 
support architecture run time evolution adls need provide specific features modeling dynamic changes techniques effecting running system 
constraints constraints depict dependencies configuration complement specific individual components connectors 
global constraints derived directly depend local constraints 
example constraints valid configurations may expressed interaction constraints constituent components connectors turn expressed interfaces protocols performance system described configuration depend performance individual architectural element safety architecture function safety constituents 
nonfunctional properties certain nonfunctional properties system level individual component connector properties 
configuration level nonfunctional properties needed select appropriate components connectors perform analysis enforce constraints map architectural building blocks processors aid project management 
tool support architectural description motivation developing formal languages architectural description formality renders suitable reasoning manipulation software tools 
supporting toolset accompanies adl strictly speaking part language 
usefulness adl directly related kinds tools provides support architectural design analysis evolution executable system generation forth 
importance architectural tools reflected going effort large segment community identify components comprise canonical adl toolkit 
results preliminary general categories emerged 
reflect kinds tool support commonly provided existing architectural approaches active specification multiple views analysis refinement implementation generation dynamism 
discussed active specification adl tools provide active specification support reducing space possible design options current state architecture 
tools provide design guidance significantly reduce software architect cognitive load 
proactive suggesting courses action disallowing design options may result undesirable design states reactive informing architect states reached design 
active specification tools deliver feedback forcing architect acknowledge continuing allowing architect view feedback discretion 
multiple views defining architecture different stakeholders architects developers managers customers may require different views architecture 
customers may satisfied high level lines description developers may want detailed formal component connector specifications managers may require view corresponding system development process 
providing appropriate view stakeholder ensuring inter view consistency key issues addressed adl toolkit 
analysis architectural descriptions intended model large distributed concurrent systems 
ability evaluate properties systems upstream architectural level substantially lessen cost errors 
details abstracted away architectures task may easier source code level 
analysis architectures primary focus adl toolset developers 
refinement importance supporting refinement architectures levels detail briefly argued extensively garlan 
refining architectural descriptions complex task correctness consistency guaranteed formal proof adequate tool support give architects increased confidence respect 
implementation generation ultimate goal software design modeling endeavor produce executable system 
elegant architectural model limited value converted running application 
doing manually may result problems consistency traceability architecture implementation 
desirable imperative adl toolkit provide tools assist producing source code 
medvidovic taylor classification comparison framework software architecture description 
dynamism argued need model dynamic changes level architecture 
adl ability model dynamic changes insufficient guarantee applied executing system property preserving manner 
software tools needed analyze modified architecture ensure desirable properties correctly map changes expressed terms architectural constructs implementation modules ensure continuous execution application vital subsystems preservation state modification analyze test modified application executing 
differentiating adls languages order clarify adl may useful point notations similar adls definition high level design notations programming languages object oriented oo modeling notations formal specification languages 
requirement model configurations explicitly distinguishes adls high level design languages 
existing languages referred adls grouped categories model configurations implicit configuration languages model configurations implicitly interconnection information distributed definitions individual components connectors line configuration languages model configurations explicitly specify component interconnections interaction protocols line explicit configuration languages model components connectors separately configurations 
items category implicit configuration languages definition adls may serve useful tools modeling certain aspects architectures 
examples languages 
interconnection information distributed clauses individual packages package bindings view construct compositions 
configuration specification connector specifies component ports attached 
focus conceptual architecture explicit treatment connectors class entities differentiate adls programming languages oo notations languages unified modeling language uml 
typically describe uses relationships modules implemented system support type connection 
programming languages describe system implementation architecture typically implicit subprogram definitions calls 
explicit treatment connectors distinguishes adls oo languages demonstrated 
important note firm boundary adls 
certain adls wright rapide model components connectors high level abstraction assume prescribe particular relationship architectural description implementation 
refer languages implementation independent 
hand adls weaves unicon metah require higher degree fidelity architecture implementation 
components modeled languages directly related implementations module interconnection specification may indistinguishable architectural description language 
implementation constraining languages 
shown oo language uml model software architectures supports certain extensions 
extensions represent architectural abstractions differ topological constraints exist connectors oo design 
extending uml manner clearly useful supports mapping architecture familiar widely notation facilitating broader understanding architecture enabling extensive tool support manipulating 
unrealistic expect uml extended model feature adl initial experience confirms 
uml may provide modeling power equivalent surpassing adl abstractions provides match architect mental model system faithfully architect adl choice 
primary purpose language provide vehicle expression matches intuitions practices users language aspire reflect intentions practices 
believe key issue argues considering notation uml adl language uml offers set abstractions architect uses design tools certain abstractions components connectors buried classes architect job unnecessarily difficult separating components connectors raising visibility top level abstractions endowing certain features limitations raises consciousness designer 
adl typically subsumes formal semantic theory 
theory part adl underlying framework characterizing architectures influences adl suitability modeling particular kinds systems highly concurrent systems particular aspects system static properties 
examples formal specification theories statecharts partially ordered event sets communicating sequential processes csp model formalisms chemical machine cham algebraic formalisms obj axiomatic formalisms anna :10.1.1.20.461
abovementioned formal notations demonstrated appropriate modeling certain aspects architectures architectural style rules 
partially ordered event sets csp obj anna successfully existing modeling languages rapide wright respectively 
modeling capabilities remaining notations statecharts cham somewhat similar adls 
express systems terms components connectors configurations se ieee transactions software engineering vol 
january features may cast mold referred examples adls 
discuss remainder section inappropriate 
statecharts statecharts modeling formalism finite state machines fsm provides state encapsulation construct support concurrency broadcast communication 
compare statecharts adl states viewed components transitions simple connectors interconnections configurations 
statecharts model architectural configurations explicitly interconnections interactions set concurrently executing components implicit transition labels 
words case topology architecture described statechart determined studying constituent components 
statecharts adl 
deeper issue attempting model architectures fsms may useful represent component connector semantics statecharts doubtful adequate architectural breakdown system achieved state machine perspective 
harel agrees view arguing assume physical functional description system providing say hierarchical decomposition subsystems functions activities support :10.1.1.20.461
statecharts control internal activities 
assume kind description produced existing method 
chemical machine chemical machine cham approach architecture modeled machine fashioned chemicals chemical reactions 
cham specified defining molecules solutions transformation rules specify solutions evolve 
architecture specified processing data connecting elements 
interfaces processing connecting elements implied topology data elements current configuration allows exchange 
topology turn implicit solution transformation rules 
cham effectively prove certain properties architectures additional syntactic constructs fulfill requirements adl 
table adl scope applicability comparison adls section presents detailed comparison existing adls dimensions discussed section 
highlight representative approaches support arguments example adl specifications 
chosen examples deliberately kept simple 
intended give reader flavor kind solutions adl may provide particular problem independently adl syntax semantics 
decision provide multiple examples single representative example motivated inability research community identify model problem adls suited 
selecting candidate problem draw justified criticism focusing strengths certain languages 
point related discussion section different adls focus different application domains architectural styles aspects architectures model 
certainly case adls studied represent large existing area shown table 
adl support modeling components surveyed adl models components 
acme aesop darwin sadl unicon wright share vocabulary refer simply components rapide interfaces weaves tool fragments metah processes 
section discuss support provided adls different aspects components 
interface surveyed adls support specification component interfaces 
differ terminology kinds information specify 
example interface point sadl wright port unicon player 
hand entire interface provided single port individual interface elements messages 
weaves combines approaches allowing multiple component ports participate exchange interface elements objects 
adls typically distinguish interface points refer provided required functionality 
metah rapide additional distinction synchronous asynchronous interfaces 
example provides requires interface constituents rapide refer functions specify synchronous communication actions denote asynchronous events 
medvidovic taylor classification comparison framework software architecture description 
fig 

specification component player unicon 
fig 

interaction protocol component port wright denotes event transitions successfully terminating process nondeterministic choice deterministic choice 
interface points typed number adls acme aesop darwin metah sadl unicon 
unicon supports predefined set common player types including readfile 
hand ports weaves order maximize flexibility interconnection 
weaves ports perform wrapping unwrapping data objects means envelopes hide types underlying data objects ports designed handle messages 
wright unicon allow specification expected component behavior constraints component usage relevant point interaction 
example unicon allows specification number associations player involved 
fig 
depicts constraint input player type bound standard input participates exactly association architecture 
wright specifies protocol interaction port csp 
example fig 
simple input read port 
types surveyed adls distinguish component types instances 
rapide help separate types language 
weaves distinguishes sockets tool fragments populate 
exception metah unicon adls provide extensible component type systems 
metah unicon support predefined built set types 
metah component types process macro mode system application 
component types supported unicon module computation filter process general 
adls acme darwin rapide sadl wright explicit parameterization component interface signatures 
typically done manner similar programming languages ada 
rapide wright allow behavior associated particular type parameterized 
rapide specifying event patterns discussed 
wright 
examples adhere adl presentation conventions naming capitalization highlighting 

metah specify software hardware architecture application system hardware construct application pertains 
fig 

rapide component behavior specified posets 
allows parameterization component computation csp specification defines component behavior 
allows architect vary behavior component systematic manner 
semantics adls support specification component semantics varying degrees 
adls underlying semantic models range expressing semantic information component property lists unicon models dynamic component behavior rapide wright 
points spectrum arbitrarily complex behavioral specifications treated uninterpreted annotations acme accompanying language modeling algorithms adl domain metah specification static component semantics invariants operation pre post conditions models interaction composition properties composite components expressed calculus darwin 
rapide introduces unique mechanism expressing component behavior interaction components partially ordered sets events posets 
rapide uses event patterns recognize posets 
poset recognition free variables pattern bound specific matching values poset 
event patterns triggers outputs component state transitions 
fig 
shows example simple rapide component causal relationship events application component observes receive event generates results event response events string parameter 
constraints adls constrain usage component specifying interface legal means interaction 
formal specification component semantics specifies relationships dependencies internal elements component 
additional means constraining components common 
number adls provide stylistic invariants aesop sadl wright 
example stylistic invariant requirement component exactly communication ports top bottom sides 
component constrained attributes 
fig 
shows unicon component constrained restricting number associations players participate 
metah constrains implementation usage component specifying nonfunctional attributes deadline criticality 
rapide enables specification pattern constraints 
discussed preceding section wright uses csp specify component computation 
ieee transactions software engineering vol 
january fig 

pattern constraint rapide 
fig 

subtype specification sadl 
event posets generated observed component interface 
example shown fig 
constraint implies messages taken resource component delivered 
evolution number adls view model components inherently static 
example metah unicon define component types enumeration allowing subtyping evolution support weaves considers tool fragment evolution outside scope 
adls support component evolution subtyping 
typically support limited notion subtyping rely mechanisms provided underlying programming language 
example acme supports strictly structural subtyping extends feature rapide evolves components oo inheritance 
sadl allows specification high level properties satisfied subtypes example fig 
specifies local client subtype client instances satisfy predicate local 
aesop provide extensive component subtyping support 
aesop enforces behavior preserving subtyping create architectural style 
aesop subclass provide strict subtyping behavior operations succeed may introduce additional sources failure respect superclass 
hand supports multiple subtyping relationships components name interface behavior implementation 
different combinations relationships specified keywords 
fig 
demonstrates possible subtyping relationships preserves possibly extends behavior component matrix may change interface implementation subtyping relationship mandates alter matrix interface 
rapide sadl provide features refining components levels abstraction 
mechanism may evolve components explicating deferred design decisions somewhat similar extending inherited behavior oo languages 
subtyping simply form refinement general case 
true rapide sadl place additional constraints refinement maps order prove demonstrate certain properties architectures 
refinement components connectors rapide sadl byproduct refinement configurations true focus 
defer fig 

specification component subtypes 
discussion issue section 
nonfunctional properties despite need benefits specifying nonfunctional properties notable lack support existing adls 
acme aesop weaves allow specification arbitrary component properties annotations 
interprets properties direct 
metah unicon provide advanced support modeling nonfunctional properties 
require information analyze architecture real time schedulability adls reliability security metah 
source code location attributes implementation generation 
representative nonfunctional properties metah deadline criticality 
unicon allows specification priority library source object executable data processor 
summary adl components surveyed adls provide comprehensive support modeling components 
regard components class entities 
furthermore models interface distinguish component types instances 
hand majority adls support evolution nonfunctional properties 
illustrative aesop adl provides support classification categories adls support categories rapide model nonfunctional properties metah unicon weaves support evolution 
adl supports allows categories 
complete summary section table 
adl support modeling connectors adls model connectors various forms various names 
example acme aesop sadl unicon wright model connectors explicitly refer connectors 
weaves models connectors explicitly refers transport services 
rapide metah connections darwin bindings modeled line named reused connectors class entities 
darwin rapide allow abstracting away complex connection behaviors connector components section compare existing adls respect support provide different aspects connectors 
interface general adls model connectors firstclass entities support explicit specification connector interfaces 
adls model component connector interfaces manner refer differently 
connector interface points medvidovic taylor classification comparison framework software architecture description 
acme aesop unicon wright roles named typed 
explicit connection component ports players unicon connector roles required architectural configuration 
wright supports csp specifications role interaction protocol manner port protocols see fig 

allows compatibility analysis connected ports roles 
unicon role may include optional attributes type players serve role minimum maximum number connections 
unicon supports predefined set role types including source sink reader writer definer caller 
example unicon role shown fig 

belongs pipe connector type constrained connected single player 
note player shown fig 
participate exactly association role connected player 
sadl weaves model connector interfaces differently component interfaces 
sadl connector defined part design vocabulary particular architectural style 
specification connector architecture specifies type data connector supports connector declared fig 
expects table adl support modeling components token sequence 
information connector arity constraints usage definition style fig 

interfaces weaves connectors generic connectors indifferent types data handle main task mediate coordinate communication components 
additionally connector support arbitrary number components 
feature referred context reflection interface connector determined potentially dynamic interfaces components communicate depicted fig 

types adls model connectors class entities distinguish connector types instances 
excludes darwin metah rapide 
metah support connector types define broad categories connections port connections connect port component port event connections connect outgoing events incoming events event recipient components event process ieee transactions software engineering vol 
january fig 

specification connector role unicon 
fig 

sadl connector interfaces 
definition instantiation connector specification sadl architecture 
specification connector type definition dataflow style connectors df type support interactions components 
event mode equivalence connections specify objects shared components 
acme aesop sadl wright base connector types interaction protocols 
unicon hand allows connectors prespecified enumerated types pipe remote 
acme sadl provide parameterization facilities enable flexible specification connector signatures constraints connector semantics 
similarly components wright allows connector parameterized specification behavior glue 
semantics interesting note adls model connectors class objects rapide may model connector semantics languages model connectors explicitly acme provide means defining semantics 
adls tend single mechanism specifying semantics components connectors 
example rapide uses posets describe communication patterns components wright models connector glue event trace specifications csp shown fig 
unicon allows specification semantic information connectors property lists real time scheduling algorithm path traces real time code 
additionally connector semantics unicon implicit predefined connector types 
example declaring connector pipe implies certain functional properties 
adls different semantic model connectors components 
example demonstrated fig 
sadl provides constraint language specifying style specific connector semantics 
models connector message filtering policy message sink filtering message filtering prioritized 
weaves employs set naming conventions imply transport services semantics 
example single writer single reader queue transport service named queue 
constraints exception weaves connector interfaces function attached components see section adls model connectors class objects constrain usage interfaces 
adls specify connections line darwin metah rapide place constraints 
implementation usage connectors constrained adls model connector semantics 
aesop sadl wright impose stylistic invariants restriction connector port may attached single port 
unicon restricts number component players attached connector role attributes 
additionally types players serve role constrained unicon accept attribute wright specifying interaction protocols role see fig 

example output unicon role fig 
constrained accept player filter component type see fig 

evolution adls model connectors class objects darwin metah rapide provide facilities evolution 
focus configuration level evolution weaves provide predefined set connector types language features evolution support unicon 
adls employ identical mechanisms connector component evolution acme supports structural connector subtyping aesop supports behavior preserving subtyping sadl supports subtyping connectors refinements styles levels abstraction 
connectors inherently evolvable context reflective interfaces connectors evolve altering filtering policies 
wright supports fig 

connectors context reflective interfaces 
connector capable supporting arbitrary addition removal reconnection number components 
software architect selects set components connector design palette 
connector communication ports components attached 
components attached connector form architecture connector creates new communication ports support component 
medvidovic taylor classification comparison framework software architecture description 
fig 

connector specified wright role glue semantics expressed csp 
fig 

constraining unicon connector role accept specific component player 
connector evolution parameterization connector instantiated different glue 
table adl support modeling connectors nonfunctional properties unicon lone adl supports explicit specification nonfunctional connector properties information analyze architecture real time schedulability 
connector algorithm attribute 
value algorithm set unicon uses trace period execution time priority information schedulability analysis 
components acme aesop weaves allow specification arbitrary uninterpreted connector annotations 
summary adl connectors support provided adls modeling connectors considerably extensive components 
adls darwin metah rapide regard connectors class entities model line 
connectors specified instances manipulated design reused 
support connectors negligible observed table 
adls model connectors explicitly model interfaces connector types instances 
ieee transactions software engineering vol 
january fig 

configuration specification unicon 
connections separated component connector instantiations 
instantiations preceded uses keyword trivial unicon allows specification component connector instance attributes obscure structure configuration 
fig 

refinement mapping declared sadl 
level architecture component comp mapped level architecture new comp 
level connector conn implemented new comp subcomponent 
level port eliminated level architecture sadl ensures functionality associated port provided arch 
interesting note case components support evolution nonfunctional properties rare aesop adl provides support classification category 
complete summary section table 
adl support modeling configurations explicit architectural configuration facilitates communication system stakeholders various levels technical expertise familiarity problem hand 
accomplished abstracting away details individual components connectors representing system structure high level 
section discuss key aspects explicit configurations compare surveyed adls respect 
understandable specifications configuration descriptions line configuration adls rapide tend connector details 
hand explicit configuration adls wright best potential facilitate understandability architectural structure 
clearly potential realized depend particular adl syntax 
example unicon falls category allows connections players roles appear order possibly distributed individual component connector instantiations shown fig 

languages provide graphical notation means achieving understandability 
example architecture modeled graphical notation shown fig 

graphical architectural description may hinder understanding precise relationship underlying model textual graphical descriptions interchangeable 
languages darwin unicon fig 

top darwin composite component 
bottom graphical view component 
definitions basic components may composite omitted simplicity 
support semantically sound graphical notations acme sadl wright 
compositionality adls provide explicit features support hierarchical composition components syntax specifying composite components typically resembles specifying configurations 
wright allows composite components connectors computation glue composite component connector represented architectural description csp 
interesting note darwin unicon explicit constructs modeling architectures 
model architectures composite components 
statement sequence shown fig 
occurs inside specification unicon composite component 
example darwin component illustrating support compositionality shown fig 

refinement traceability architectural refinement traceability architectural decisions properties relationships refinements open research area 
support existing adls limited 
adls enable system generation directly architectural specification 
typically implementation constraining languages see section source file corresponds architectural element 
problems approach refining architecture 
primarily assumption relationship elements architectural description resulting executable system 
may unnecessary unreasonable architectures describe systems 
note graphical specification architecture may contain information textual counterpart formal component connector specifications vice versa graphical layout information 
additional support needed truly interchangeable see section 
medvidovic taylor classification comparison framework software architecture description 
higher level abstraction source code modules 
guarantee specified source modules correctly implement desired behavior 
specified modules currently implement needed behavior correctly approach provides means ensuring changes modules traced back architecture vice versa 
sadl rapide support refinement traceability extensively 
provide maps refining architectures different levels abstraction 
sadl uses maps see fig 
prove correctness architectural refinements rapide generates comparative simulations architectures different levels 
languages provide means tracing design decisions changes level architectural specification implementation 
enforce different refinement rules sadl stringent correctness preserving criterion ensures decisions level maintained subsequent levels disallows new decisions introduced rapide maps allow new decisions may eliminate high level behaviors lower levels 
garlan argued marriage approaches 
heterogeneity adl provides explicit support multiple formal specification languages 
adls support implementation architectures tightly tied particular programming language 
example aesop darwin support development components implemented metah restricted ada unicon hand currently supports development ada java weaves supports interconnection tool fragments implemented objective fortran 
adls place restrictions limit number kinds components connectors support 
example metah requires component include loop call procedure kernel wait dispatch periodically dispatch process 
existing components modified include construct metah architecture 
similarly unicon allows certain types components connectors pipes filters sequential files requires wrappers spreadsheets constraint solvers relational databases 
aspect heterogeneity granularity components 
surveyed adls support modeling fine coarse grain components 
extreme components describe single operation computations unicon procedures metah extreme achieved hierarchical composition discussed section 
scalability consider impact scaling architecture general dimensions adding elements architecture interior fig 
adding architecture boundaries fig 

support adls minimally employ compositionality features discussed section original architecture fig 

existing architecture scaled adding new components connectors interior expanding outward graphical notation illustration 
treated single composite component attached new components connectors 
objectively evaluating adls ability support difficult certain heuristics help 
generally easier expand architectures described explicit configuration adls line configuration adls connectors described solely terms components connect adding new components may require modifications existing connector instances 
additionally adls allow variable number components attached single connector better suited scaling specify exact number components connector service 
example acme aesop handle extension architecture shown fig 
redefining conn conn unicon 
properly evaluate adl support scalability heuristics accompanied criteria 
ultimate determinant scalability support ability developers implement analyze large systems architectural descriptions adl 
example line configuration language rapide highlighted adl features may hamper scalability specify architectures large real world systems 
adls applied large scale examples wright model analyze runtime infrastructure rti department defense high level architecture simulations original specification pages long 
sadl ensured consistency architecture implementation system tokyo electric power implemented fortran lines code loc 
specification implementation supporting environment consisting number large custom built ots components 
custom built components ieee transactions software engineering vol 
january fig 

declaration family architectures fam subfamily sub fam acme 
fam evolved sub fam adding new component property fam component ports 
comprise java loc ots components comprise loc 
weaves satellite telemetry processing applications size ranged loc 
representative example rapide open distributed transaction processing industry standard documentation pages long 
open architecture subsequent extensions successfully specified simulated rapide 
evolvability evolvability architectural configuration viewed different perspectives 
ability accommodate addition new components manner depicted fig 

issues inherent doing discussed section 
view evolvability adl tolerance support incomplete architectural descriptions 
incomplete architectures common design decisions deferred relevant 
advantageous adl allow incomplete descriptions 
existing adls supporting toolsets built notion precisely kinds situations prevented 
example darwin metah rapide unicon compilers constraint checkers runtime systems constructed raise exceptions situations arise 
case adl wright focuses analyses information local single connector better suited accommodate expansion architecture sadl rigorous refinement entire architectures 
aspect evolution support families applications 
way adls support families separating component connector types instances 
example weaves supports specification architectural frameworks populated sockets actual tool fragments transport services 
instantiation architecture considered member family 
limited notion family allow architecture modified 
furthermore family application belongs implicit architecture 
acme surveyed language specifies architectural families explicitly class language constructs supports evolution 
component connector types declared family provide design fig 

dynamic component instantiation darwin 
fig 

dynamic insertion component architecture sample arch 
start command informs implementation infrastructure see section start executing comp 
vocabulary systems declared members family 
example fig 
shows declaration simple acme family evolution 
dynamism majority existing adls view configurations statically 
exceptions darwin rapide weaves 
darwin rapide support constrained dynamic manipulation architectures runtime changes known priori 
darwin allows runtime replication components dynamic instantiation deletion rebinding components interpreting darwin scripts 
example dynamic instantiation darwin fig 
invoking service create inst data parameter results new instance component comp data passed 
rapide supports conditional configuration clause enables architectural rewiring runtime link unlink operators 
wright adopted similar approach dynamic architecture changes distinguishes communication control events control events specify conditions dynamic changes allowed 
reconfiguration actions triggered response control events new del attach detach 
weaves support dynamic manipulation restrictions types permitted changes 
arbitrary modifications allowed principle consistency ensured system runtime 
architecture modification sub language aml specifies set operations insertion removal rewiring elements architecture runtime weld 
example extension architecture depicted fig 
specified aml shown fig 

weaves provides similar support exporting application programmable interface api model weave 
constraints adls enforce built constraints consider valid configurations 
example unicon requires connector role attached component player darwin allows bindings provided required services 
hand adls provide facilities specifying medvidovic taylor classification comparison framework software architecture description 
fig 

pipe filter style declared wright 
constraint style specifies connectors pipes component ports data input data output ports 
arbitrary global constraints 
example rapide timed poset language constrain configurations manner components see fig 

similarly individual components metah explicitly constrains configurations nonfunctional attributes 
refinement maps sadl provide constraints valid refinements configuration see section 
wright allows specification structural invariants corresponding different architectural styles 
example wright style constraint fig 

nonfunctional properties adls support specification nonfunctional properties components connectors support hierarchical composition 
specify properties architectures treating composite components 
metah rapide support direct modeling nonfunctional properties architectures metah allows specification properties processor system execute rapide allows modeling timing information constraint language 
sadl model security software architecture adopting different approach providing security modeling features sadl original architecture modified adding necessary component connector parameters architectural constraints 
unclear approach applicable nonfunctional properties simple needed modifications general case 
summary adl configurations level configurations foci adls easily noticed 
example sadl particular contribution architectural refinement darwin focuses system compositionality dynamism 
single adl satisfies classification criteria rapide weaves come close 
coverage criteria sparse adls refinement traceability evolution dynamism nonfunctional properties 
indicators research directed 
hand adls allow provide explicit support understandability compositionality heterogeneity 
complete summary section table 
tool support adls need tool support architectures recognized 
definite gap research community identifies desirable state practice 
surveyed adl provides tool support exception rapide tend focus single area interest analysis wright refinement sadl dynamism weaves 
furthermore areas adls tend direct attention particular technique wright analysis deadlocks leaving facets unexplored 
reason acme proposed architecture interchange language enable interaction cooperation different adls toolsets fill gaps 
section surveys tools provided different languages attempting highlight biggest shortcomings 
active specification handful existing adls provide tools actively support specification architectures 
general tools proactive reactive 
proactive specification tools act manner similar syntax directed editors programming languages limit available design decisions current state architectural design 
example tools may prevent selection components interfaces match currently architecture disallow invocation analysis tools incomplete architectures 
unicon graphical editor operates manner 
invokes unicon language processing facilities prevent errors design correct fact 
furthermore editor limits kinds players roles assigned different types components connectors respectively 
similarly development environment proactively guides architecting process disallowing certain operations architectural type checking completed topological constraint checking 
darwin software architect assistant example proactive specification tool 
assistant automatically adds services interface points appropriate types components bound 
maintains consistency data types connected ports changing port type automatically propagated ports bound 
reactive specification tools detect existing errors 
may inform architect error nonintrusive force correct moving intrusive 
architect allows remedy problem sees fit altogether 
environment includes type checker provides nonintrusive support architect proceed implementation generation phase presence type mismatches 
case architect forced remedy current problem moving 
certain features metah graphical editor characterized intrusive metah editor gives architect full freedom manipulate architecture apply button depressed errors rectified architect may continue design 
multiple views adls support views architecture textual graphical provide automated support alternating 
aesop metah unicon weaves distinguish different types components ieee transactions software engineering vol 
january connectors allow top level detailed views composite elements 
support views sparse 
argo design environment provides view architecture centered development process 
darwin software architect assistant provides hierarchical view architecture shows component types include relationships tree structure 
rapide allow visualization architecture execution behavior table adl support modeling architectural configurations building executable simulation architecture providing tools viewing filtering events generated simulation 
particular rapide uses simulator tool build simulation animation tools animate execution 
rapide provides poset browser tool allows viewing events generated simulation 
weaves adopts similar approach allows insertion low overhead observers weave support real time execution animation 
medvidovic taylor classification comparison framework software architecture description 
analysis types analyses adl suited depend underlying semantic model lesser extent specification features 
example wright uses csp analyze individual connectors components attached deadlocks aesop ensure topological constraints type conformance architectural elements metah unicon support schedulability analysis specifying nonfunctional properties criticality priority sadl establish relative correctness architectures respect refinement map 
set analysis techniques involves simulation behavior described architecture 
examples rapide weaves event monitoring filtering tools 
similarly darwin allows instantiation parameters dynamic components enact scenarios 
related technique commonly employed weaves insert architecture listener component task analyze data receives adjacent components 
language parsers compilers kind analysis tool 
parsers analyze architectures syntactic correctness compilers establish semantic correctness 
surveyed languages parsers 
darwin metah unicon compilers enabling generate executable systems architectural descriptions provided component implementations exist 
rapide compiler generates executable simulations rapide architectures 
environment hand provides tool generates executable implementation skeletons architectural model skeletons completed developing new reusing ots functionality 
aspect analysis enforcement constraints 
parsers compilers enforce constraints implicit type information nonfunctional attributes component connector interfaces semantic models 
rapide supports explicit specification types constraints provides means checking enforcement 
constraint checker analyzes conformance rapide simulation formal constraints defined architecture 
constraint checker currently focuses topological rules style initial integration architecture constraint checking tool allows specification enforcement arbitrary constraints 
refinement adls support direct refinement architectural models executable code compilation darwin metah unicon achieve manner similar architectural components implemented programming language architectural description serves ensure proper interconnection communication 
drawbacks approach discussed section 
rapide hand provides executable sublanguage contains common programming language control structures 
goes linking existing modules far provide executable language constructs architecture fig 

method generated preceded precondition followed postcondition 
refined partial implementation contains completion guidelines developers derived architectural description 
example method accompanied specifications precondition postcondition shown fig 
developer ensure satisfaction implementing method need worry rest system 
sadl rapide provide tool support refining architectures multiple levels abstraction specificity 
sadl support partial 
requires manual proofs mappings constructs concrete architectural style 
proof performed sadl provides tool automatically checks architectures described styles adhere mapping 
rapide hand supports event maps individual architectures 
maps compiled rapide simulator constraint checker verify events generated simulation concrete architecture satisfy constraints architecture 
implementation generation large number adls support generation system architecture 
exceptions sadl acme wright currently strictly modeling notations provide implementation generation support 
interesting note sadl focuses refining architectures take final refinement step architectural descriptions source code 
adls employ architectural compilers discussed 
aesop adopts different approach provides class hierarchy concepts operations components connectors ports roles attachments 
hierarchy forms basis implementation architecture may produced hierarchy essence domain specific language implementing aesop architectures 
similar approach provides framework classes concepts 
components connectors applications subclassed appropriate framework classes 
framework implemented java ada ots middleware technologies integrated framework enable interactions components implemented different languages 
application skeletons produced code generation facilities discussed result instantiated partially implemented framework classes 
ieee transactions software engineering vol 
january dynamism limited support modeling dynamism existing adls discussed section reflected limited tool support dynamism 
darwin rapide model planned modifications runtime support conditional configuration darwin allows component replication 
compilation tools ensure possible configuration alternatives enabled 
weaves toolsets support dynamism extensively 
weaves provides visual editor uses provided api architectural model dynamically manipulate weave arbitrary fashion 
tool enables arbitrary interactive construction execution runtime modification style architectures implemented java 
supports modification architecture runtime dynamically loading linking new components connectors architecture 
table adl tool support weaves exploit flexible connectors see section support dynamism 
summary adl tool support existing adls span broad spectrum terms design development tools provide 
hand acme currently facilitates visualization architectures sadl toolset consists primarily refinement consistency checker weaves focused interactive specification manipulation architectures 
hand darwin rapide unicon provide powerful architecture modeling environments darwin adls provide tool support classification categories 
existing adls put greatest emphasis visualization analysis architectures refinement dynamism 
complete summary section table 
medvidovic taylor classification comparison framework software architecture description 
classifying comparing languages objectively difficult task 
example programming language ada contains mil features debates rage java better 
hand exist exact litmus test turing completeness ways distinguish different kinds programming languages imperative vs declarative vs functional procedural vs oo 
similarly formal specification languages grouped model state algebraic axiomatic forth 
definition classification existed adls 
main contribution just definition classification framework 
definition provides simple litmus test adls largely reflects community consensus essential modeling architecture architectural description differs notations explicit focus connectors architectural configurations 
demonstrated definition accompanying framework determine notation adl process discarded notations potential adls 
may surprising cham statecharts criteria applied 
languages passed litmus test boundary modeling connectors line line configuration adls assuming bijective relationship architecture implementation implementation constraining adls 
discussed drawbacks categories 
noted simplifying relationship architecture implementation implementation constraining adls successful generating implementations mainstream implementation independent adls 
example implementation independent assumed relationship building initial prototype implementation generation tools 
comparison existing adls highlighted areas provide extensive support terms architecture modeling capabilities tool support 
example number languages powerful formal notations modeling component connector semantics 
provide plethora architecture visualization analysis tools 
hand survey pointed areas existing adls severely lacking 
handful support specification nonfunctional properties properties may essential system implementation management corresponding development process 
architectural refinement constraint specification remained largely unexplored 
tools notations supporting architectural dynamism infancy 
adls attempted achieve unanticipated dynamism far 
surprising inconsistency adls support connectors especially argued primary role architectural descriptions 
adls provide minimal connector modeling capabilities 
allow modeling complex connectors wright implementation simple ones unicon 
provided initial demonstration feasibility implementing complex connectors employing existing research commercial connector technologies polylith corba 
remains wide open research issue 
definition accompanying framework proposed immutable laws adls 
quite contrary expect modified extended 
currently considering issues providing clearer distinction descriptive languages acme primarily enable semantic modeling wright comparing software adls hardware adls expanding framework include criteria support extensibility 
resort heuristics subjective criteria comparing adls times indicating areas concentrated 
taxonomy provides important advance answering question adl compares adls 
information needed evaluating new improving existing adls targeting research architecture interchange efforts precisely 
acknowledgments authors people insightful comments earlier drafts allen anderson clements fielding garlan griswold hilbert van der hoek kramer luckham magee monroe redmiles robbins rosenblum selby shaw whitehead wolf 
referees transactions software engineering helpful reviews 
effort sponsored defense advanced research projects agency rome laboratory air force materiel command usaf agreement number 
government authorized reproduce distribute reprints governmental purposes notwithstanding copyright annotation thereon 
views contained authors interpreted necessarily representing official policies endorsements expressed implied defense advanced research projects agency rome laboratory government 
abowd allen garlan style understand descriptions software architecture proc 
acm sigsoft symp 
foundations software eng pp 
dec 
allen formal approach software architecture phd thesis carnegie mellon univ cmu technical report cmu cs may 
allen douence garlan specifying dynamism software architectures proc 
workshop foundations component systems pp 
sept 
allen garlan formal basis architectural connection acm trans 
software eng 
methodology vol 
pp 
july 
ieee transactions software engineering vol 
january allen garlan formal modeling analysis hla component integration standard proc 
sixth acm sigsoft symp 
foundations software eng pp 
nov 
jackson domain specific software architectures guidance navigation control int software eng 
knowledge eng vol 

clements formal methods describing architectures proc 
workshop formal methods architecture 
clements survey architecture description languages proc 
eighth int workshop software specification design mar 
clements working constraints sub group architecture generation cluster apr 
www sei cmu edu clusters arch index html 
medvidovic taylor shelf middleware implement connectors distributed software architectures proc 
st int conf 
software eng 
icse pp 
may 
proc 
international workshop architectures software systems garlan ed apr 
garlan aesop system july 
www cs cmu edu afs cs project able www aesop html aesop overview ps 
garlan style refinement software architecture proc 
second int software architecture workshop wolf ed pp 
oct 
garlan allen exploiting style architectural design environments proc :10.1.1.26.4897
sigsoft foundations software eng pp 
dec 
garlan monroe acme architecture description interchange language proc 
cascon nov 
summary dagstuhl workshop software architecture acm software eng 
notes garlan tichy eds pp 
july 
garlan adl toolkit architecture generation cluster dec 
www cs cmu edu adl index html 
ghezzi jazayeri mandrioli fundamentals software engineering 
prentice hall 
goguen winkler introducing obj technical report sri csl sri int 
quilici visual programming large versus visual programming small proc 
ieee symp 
visual languages pp 
oct 
weaves software construction analysis proc 
th int conf 
software eng 
icse pp 
may 
modular interconnection language domain specific software architectures technical report univ maryland june 
harel statecharts visual formalism complex systems science computer programming :10.1.1.20.461
hoare communicating sequential processes 
prentice hall 
inverardi wolf formal specification analysis software architectures chemical machine model ieee trans 
software eng vol 
pp 
apr 
jahanian mok specification language real time systems ieee trans 
software eng vol 
pp 
dec 
clements features architecture description languages draft cmu sei technical report carnegie mellon univ dec 
clements feature analysis architecture description languages proc 
software technology conf 
stc apr 
krueger software reuse computing surveys vol 
pp 
june 
luckham anna language annotating ada programs manual berlin springer verlag 
luckham augustin vera bryan mann specification analysis system architecture rapide ieee trans 
software eng vol 
pp 
apr 
luckham vera event architecture definition language ieee trans :10.1.1.53.3387
software eng vol 
pp 
sept 
luckham vera bryan augustin belz partial orderings event sets application prototyping concurrent timed systems systems software vol 
pp 
june 
luckham vera concepts system architecture technical report csl tr stanford univ palo alto calif july 
magee dulay eisenbach kramer specifying distributed software architectures proc :10.1.1.25.7933
fifth european software eng 
conf 
esec sept 
magee kramer dynamic structure software architectures proc 
acm sigsoft fourth symp 
foundations software eng 
fse pp 
oct 
proc 
third int software architecture workshop magee perry eds nov 
medvidovic adls dynamic architecture changes proc 
second int software architecture workshop wolf ed pp 
oct 
medvidovic robbins taylor object oriented typing support architectural design style proc 
acm sigsoft fourth symp 
foundations software eng 
fse pp 
oct 
medvidovic rosenblum domains concern software architectures architecture description languages proc 
usenix conf 
domain specific languages pp 
oct 
medvidovic rosenblum assessing suitability standard design method modeling software architectures proc 
working ifip conf 
software architecture pp 
feb 
medvidovic rosenblum taylor language environment architecture software development evolution proc 
st int conf 
software eng 
icse pp 
may 
medvidovic taylor whitehead jr formal modeling software architectures multiple levels abstraction proc 
california software symp pp 
apr 
milner parrow walker calculus mobile processes parts ii information computation vol 
pp 

monroe capturing software architecture design expertise technical report cmu cs carnegie mellon univ oct 
sadl language specifying software architecture hierarchies technical report sri csl sri int mar 
qian correct architecture refinement ieee trans 
software eng vol 
pp 
apr 
qian gong secure software architectures proc 
ieee symp 
security privacy may 
newton browne code graphical parallel programming language proc 
acm int conf 
supercomputing july 
ng kramer magee case tool software architecture design automated software eng vol 
nos 
pp 

issues runtime modification software architectures technical report uci ics univ california irvine aug 
medvidovic taylor architecture runtime software evolution proc 
th int conf 
software eng 
icse pp 
apr 
edwards essential distributed objects survival guide 
john wiley sons 
perry wolf foundations study software architectures sigsoft software eng :10.1.1.135.5430
notes vol 
pp 
oct 
prieto diaz neighbors module interconnection languages systems software vol 
pp 
oct 
polylith software bus acm trans 
programming languages systems vol 
pp 
jan 
medvidovic taylor classification comparison framework software architecture description 
uml semantics rational partners object management group document ad sept 
www omg org docs ad pdf 
uml notation guide rational partners object management group document ad sept 
www omg org docs ad pdf 
robbins hilbert redmiles extending design environments software architecture design proc 
knowledge software eng 
conf 
pp 
sept 
robbins medvidovic redmiles rosenblum integrating architecture description languages standard design method proc 
th int conf 
software eng 
icse pp 
apr 
shaw procedure calls assembly language system interconnection connectors deserve class status proc 
workshop studies software design may 
shaw deline klein ross young abstractions software architecture tools support ieee trans 
software eng vol 
pp 
apr 
shaw deline abstractions implementations architectural connections proc 
third int conf 
configurable distributed systems may 
shaw garlan characteristics higher level languages software architecture technical report cmu cs carnegie mellon univ dec 
shaw garlan formulations formalisms software architecture computer science today trends developments 
van leeuwen ed 
springer verlag 
shaw garlan software architecture perspectives emerging discipline 
prentice hall apr 
spivey notation manual 
new york prentice hall 
shaw garlan allen klein scott schumacher candidate model problems software architecture unpublished manuscript nov 
www cs cmu edu afs cs project compose www html 
terry london architecture description language ar tek version technical report federal syst army research development eng 
center july 
tracz parameterized programming language proc 
second int workshop software reuse pp 
mar 
cursory overview comparison architecture description languages technical report honeywell technology center feb 
metah programmer manual version technical report honeywell technology center apr 
proc 
second international software architecture workshop wolf ed oct 
wolf second int software architecture workshop acm sigsoft vol 
pp 
jan 
medvidovic received bs degree computer science arizona state university graduated summa cum laude 
received ms degree information computer science phd degree department information computer science university california irvine respectively 
assistant professor computer science department university southern california los angeles 
research interests focus software architectures specifically architectural styles modeling analysis architectures architecture software evolution software reuse interoperability 
www home page accessed sunset usc edu 
richard taylor received phd degree computer science university colorado boulder 
recipient presidential young investigator award recognized acm fellow 
professor information computer science university california irvine 
research interests centered software architectures hypermedia world wide web protocols workflow technologies 
professor taylor director institute software research isr alliance corporate community university 
chairman acm special interest group software engineering sigsoft 
served program international conference software engineering icse general chair international joint conference activities coordination collaboration 
dr taylor member ieee computer society 
