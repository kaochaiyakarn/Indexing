arxiv cs cs lo may practical reasoning expressive description logics ian horrocks department computer science university manchester horrocks cs man ac uk ulrike sattler theoretical computer science rwth aachen sattler informatik rwth aachen de stephan tobies theoretical computer science rwth aachen tobies informatik rwth aachen de description logics dls family knowledge representation formalisms mainly characterised constructors build complex concepts roles atomic ones 
expressive role constructors important applications computationally problematical 
algorithm decides satisfiability dl alc extended transitive inverse roles functional restrictions respect general concept inclusion axioms role hierarchies early experiments indicate algorithm suited implementation 
additionally show alc extended just transitive inverse roles pspace 
investigate limits decidability family dls showing relaxing constraints placed kinds roles number restrictions leads undecidability inference problems 
describe number optimisation techniques crucial obtaining implementations decision procedures despite worst case complexity problem exhibit performance real life problems 
motivation description logics dls known family knowledge representation formalisms donini 
notion concepts appeared logic journal igpl may 
unary predicates classes roles binary relations mainly characterised constructors allow complex concepts roles built atomic ones 
sound complete algorithms interesting inference problems subsumption satisfiability concepts known wide variety dls 
transitive inverse roles play important role adequate representation complex aggregated objects horrocks sattler reasoning conceptual data models calvanese 
defining concepts general concept inclusion axioms natural crucial representing conceptual data models 
relevant inference problems extension alc augmented described manner known decidable de giacomo lenzerini worst case optimal inference algorithms described de giacomo massacci 
best knowledge efficient means deal high degree non determinism far prohibits realistic applications 
mainly due fact algorithms handle transitive roles transitive closure roles 
shown sattler restricting dl transitive roles lead lower complexity transitive roles combined role hierarchies allow algorithms behave quite realistic applications horrocks 
unclear true inverse roles 
various aspects research direction 
firstly motivate logics transitive roles transitive closure contrasting algorithms pairs logics differ kind transitivity supported 
secondly algorithm decides satisfiability alc extended transitive inverse roles role hierarchies functional restrictions 
algorithm checking satisfiability subsumption respect general concept inclusion axioms cyclic terminologies axioms internalised 
fact algorithm needs deal transitive roles transitive closure leads lower degree non determinism experiments indicate algorithm wellsuited implementation 
thirdly show alc extended transitive inverse roles pspace 
algorithm prove result introduces enhanced blocking technique provide useful efficiency gains implementations expressive dls 
fourthly investigate limits decidability family dls showing relaxing constraints impose kind roles allowed number restrictions leads undecidability inference problems 
describe range optimisation techniques produce implementations algorithms exhibit typical case performance 
preliminaries section syntax semantics various dls investigated subsequent sections 
includes definition inference problems concept subsumption satisfiability problems respect terminologies interrelated 
logics discuss extension known dl alc schmidt schau smolka include transitively closed primitive roles sattler call logic due relationship propositional multi modal logic schild 
basic dl extended variety ways see overview 
definition nc set concept names set role names transitive role names set si roles 
avoid considering roles define function inv roles inv role name inv speaking roles refer si roles approach capable dealing uniformly role names inverse roles 
obviously role transitive iff inv transitive 
define trans return true iff transitive role 
precisely trans true say transitive iff inv 
set si concepts smallest set 
concept name concept 
concepts si role concepts 
role inclusion axiom form roles inverse 
role hierarchy finite set role inclusion axioms shi obtained si allowing additionally role hierarchy sub role relation transitive reflexive closure inv inv 
shiq obtained shi allowing additionally qualified number restrictions hollunder baader concepts form nr nr simple role concept role called simple iff transitive transitive sub roles 
shin restriction shiq allowing unqualified number restrictions concepts form nr nr shif represents restriction arbitrary number restrictions functional restrictions form negation may occur 
interpretation consists set called domain function maps concept subset role logic previously called cumbersome adding letters represent additional features 
construct name syntax semantics atomic concept ai atomic role ri transitive role ri ri conjunction ci di disjunction ci di negation ci exists restriction ri ci value restriction ri implies ci role hierarchy ri si inverse role ri number restrictions nr nr ri ri qualifying number nr restrictions nr ci ri ci syntax semantics si family dls subset concepts roles nonnegative integers properties satisfied denotes cardinality set interpretation satisfies role hierarchy iff denote fact say model concept called satisfiable respect role hierarchy iff interpretation 
interpretation called model concept subsumes concept written iff holds model interpretation individual called instance concept iff dls considered closed negation subsumption un satisfiability role hierarchies reduced iff unsatisfiable unsatisfiable iff concept name kozen tiuryn baader schild baader internalisation terminological axioms introduced technique reduces reasoning respect possibly cyclic terminology satisfiability concepts 
horrocks saw role hierarchies reduction 
presence inverse roles reduction slightly modified 
definition terminology finite set general concept inclusion axioms 
cn dn ci di arbitrary shif concepts 
interpretation said model iff di holds ci di concept satisfiable respect iff model 
subsumes respect iff model lemma shows general concept inclusion axioms internalised universal role transitive super role roles occurring respective inverses 
lemma terminology role hierarchy ct ci di ci di 
transitive role occur set ru inv occurs 
satisfiable iff ct ct satisfiable ru 
subsumes iff ct ct unsatisfiable ru 
proof lemma similar ones schild baader 
importantly shown shif concept satisfiable respect terminology role hierarchy connected model reachable role path possibly involving inverse roles model ru easy consequences semantics definition theorem satisfiability subsumption shif concepts resp 
shi concepts terminologies role hierarchies polynomially reducible un satisfiability shif concepts resp 
shi concepts role hierarchies 
blocking algorithms going deciding satisfiability si shif concepts tableaux method hollunder satisfiability concept tested trying construct model model represented tree nodes correspond individuals edges correspond roles 
node labelled set concepts individual satisfy edges labelled sets role names 
algorithm starts single node labelled proceeds repeatedly applying set expansion rules recursively decompose concepts node labels new edges nodes added required order satisfy concepts 
construction terminates rules applied way extends tree discovery obvious contradictions demonstrates model 
order prove algorithm sound complete decision procedure concept satisfiability logic necessary demonstrate models constructs correct respect semantics find model exists terminates 
points usually dealt proving expansion rules preserve satisfiability case non deterministic expansion disjunctions possibilities exhaustively searched 
logics alc termination mainly due fact expansion rules add new concepts strictly smaller decomposed concept model stabilise concepts fully decomposed 
see longer true presence transitive roles 
transitive roles vs transitive closure argued reasoning logics transitive roles empirically tractable logics allow transitive closure roles sattler horrocks 
section give justification claim 
starting point investigations logics sh horrocks alc baader extend alc transitive roles role hierarchies transitive closure roles respectively 
syntactically alc similar addition transitive non transitive roles transitive closure role may appear existential universal restrictions 
formally interpreted ri ri sh alc concept satisfiability exptime complete problem 
result easily derived exptime hardness proof pdl fischer ladner proof pdl exptime pratt 
implementations algorithms sh exhibit performance realistic applications horrocks patel schneider moment problematical alc 
believe main reason discrepancy case tableau algorithm implementations lies different complexity blocking conditions needed guarantee termination respective algorithms 
going survey blocking techniques needed deal sh subsequent extensions shi shif 
underpin claim reasoning transitive roles empirically leads efficient implementations transitive closure blocking techniques deal transitive closure 
complicated introduce larger degree non determinism tableaux algorithms leading inferior performance implementations 
blocking sh termination expansion process tableaux algorithm guaranteed logics include transitive roles expansion rules introduce new concepts size decomposed concept 
particular concepts transitive role dealt propagating concept labelled edges sattler 
example node labelled transitive role combination concepts cause new node added tree label identical expansion process repeated indefinitely 
problem dealt blocking halting expansion process cycle detected baader buchheit 
logics inverse roles general procedure check label new node subset baader label ancestor node expansion performed said block resulting tree corresponds cyclical model identified deal transitive closure roles tableaux algorithms proceed non deterministically expanding concept size concepts path tree may decrease blocking techniques necessary guarantee termination 
adequate blocking condition alc identical sh distinguish bad cycles 
consider concept obviously satisfiable run tableaux algorithm generate tableau node blocked node generating obvious contradictions 
problem expanded postponing satisfaction step 
obtain correct tableaux algorithm alc blocking condition include check ensure concept appearing cycle expanded cycle 
cycles called cycles cycles expanded called bad cycles 
valid model may contain cycles 
summing transitive closure transitive roles twofold impact empirical tractability blocking situations cycles distinguished bad ones non deterministic expansion concepts form increases size search space 
dynamic blocking fails presence transitive closure 
adding inverse roles blocking problematical inverse roles added logic key feature algorithms horrocks sattler dynamic blocking strategy 
label equality subset strategy allowed blocks established broken re established 
inverse roles blocking condition considered carefully roles bi directional additional concepts label invalidate model respect predecessor 
problem overcome allowing node blocked ancestors labelled sets concepts 
dealing inverse roles complicated presence transitive closure 
example consider concept fig 
shows possible tableau expansions concept continuing expansion left hand tree necessarily lead clash concept expanded lead appearing 
right hand tree invalid contains bad cycle expanded satisfiable shown continuing expansion right hand path step 
de giacomo massacci solution problem strict superset alci alc plus inverse roles 
solution consists additional expansion rule called look analytical cut 
rule employs exhaustive non deterministic guessing past node tree explicit labelling node successor node added non deterministically label concept may appear expansion process 
obviously leads large increase size search space correspondingly large adverse impact empirical tractability 
experience kind exhaustive guessing leads believe implementation algorithm inefficient 
non existence implementations alci taken support view 
pair wise blocking extending logic shi shif adding functional restrictions concepts form meaning individual related individual role introduces new problems associated fact logic longer finite model property 
means concepts satisfiable exists finite model 
example concept transitive role model concept contain infinite sequence individuals related single successors role satisfying term propagated sequence transitive super role attempting terminate sequence cycle causes sequence collapse single node due functional restrictions results contradiction node label 
order deal infinite models algorithm terminates correctly input concept infinite models sophisticated pair wise blocking strategy introduced horrocks sattler soundness proved demonstrating blocked tree corresponding infinite model 
known algorithm able deal combination transitive closure inverse roles functional restrictions roles relies elaborate polynomial reduction terminology de giacomo lenzerini capability resulting general terminological axioms 
large number nature axioms generated reduction implementation tolerable runtime behaviour emerge 
reasoning si logics section tableaux algorithms decides satisfiability shif concepts shif reasoning problems see theorem second decides satisfiability subsumption pspace 
sketch proofs 
details shif algorithm please refer horrocks sattler details si sin algorithm please refer horrocks 
correctness algorithms proved showing create tableau concept iff satisfiable 
ease construction assume concepts negation normal form nnf negation occurs front concept names 
say may finite model 
shif concept easily transformed equivalent nnf pushing negations inwards hollunder 
definition shif concept nnf role hierarchy rd set roles occurring inverses sub subconcepts tableau iff set individuals sub maps individual set concepts rd maps role set pairs individuals individual 
furthermore sub rd holds 





trans 
iff inv 




tableaux si concepts defined analogously satisfy properties due absence role hierarchy identity 
due close relationship models tableaux lemma easily proved induction structure concepts 
consequence algorithm constructs possible tableau input concept decision procedure satisfiability concepts 
lemma shif concept resp 
si concept satisfiable role hierarchy iff tableau reasoning shif give algorithm shif concept decides existence tableaux implicitly assume arbitrary fixed role hierarchy definition completion tree shif concept tree node tree labelled set sub edge labelled set possibly inverse roles occurring sub 
completion tree node called successor node iff successor node called neighbour iff successor inv successor predecessors ancestors defined usual 
node blocked iff directly indirectly blocked 
node directly blocked iff ancestors blocked ancestors 
successor successor 


case say blocks node indirectly blocked iff ancestors blocked order avoid wasted expansion application rule successor node 
node said contain clash iff roles completion tree called clash free iff nodes contains clash called complete iff expansion rules applicable 
shif concept nnf algorithm starts completion tree consisting single node 
applies expansion rules stopping clash occurs answers satisfiable iff completion rules applied way yield complete clash free completion tree 
soundness completeness tableaux algorithm immediate consequence lemmas 
lemma shif concept 

tableaux algorithm terminates started 
expansion rules applied yield complete clash free completion tree tableau 

tableau expansion rules applied yield complete clash free completion tree 
sketch ideas proof discuss different expansion rules correspondence language constructors 
rules standard alc tableaux rules schmidt schau smolka 
rule handle transitive roles clause deals role hierarchy 
see horrocks sattler details 
rule 
indirectly blocked 
rule 
indirectly blocked 
rule 
blocked 
neighbour create new node rule 
indirectly blocked 
neighbour rule 
indirectly blocked 
trans 
neighbour rule 
blocked 
neighbour create new nodes rule 
indirectly blocked 
neighbours ancestor 

ancestor inv 
tableaux expansion rules shif functional restriction rules merit closer consideration 
order guarantee satisfaction constraint rule creates successors uses fresh atomic concept prohibit identification successors rule 
node neighbours contains functional restriction rule merges neighbours merges edges connecting labelling edges sets roles allows single node successor comparable contradicting functional restrictions taken care definition clash 
sketch main ideas proof lemma 
termination sub rd 
termination consequence properties expansion rules expansion rules remove nodes tree concepts node labels 
edge labels changed rule expands sets case node labelled edge blocked 
successors generated concepts form 
node concepts triggers generation successors 
successors rule subsequently causes changed neighbour 
definition clash implies concept led generation trigger rule application 
obviously degree tree bounded 
nodes labelled nonempty subsets sub edges subsets rd mn different possible labellings pair nodes edge 
path length mn nodes directly blocked path nodes blocked longer paths length mn 
soundness complete clash free tree induces existence tableaux follows 
individuals correspond paths root node node blocked 
going directly blocked node paths jump back blocking node yields paths arbitrary length 
blocking occurs construction yields infinite tableau 
complicated tableau construction necessary due presence functional restrictions validity ensured blocking condition considers blocked node predecessor 

completeness tableau steer application non deterministic rules way yields complete clash free tree 
theorem immediate consequence lemma lemma lemma 
theorem tableaux algorithm decision procedure satisfiability subsumption shif concepts respect terminologies role 
pspace algorithm si obtain pspace algorithm si shif algorithm modified follows si allow functional restrictions rule omitted blocking longer involves pairs nodes identical labels nodes similar labels 
due absence role hierarchies edge labels restricted roles sets roles 
obtain pspace algorithm employ refined blocking strategy necessitates second label node 
blocking technique discovered independently ideas similar spaan show satisfiability decided pspace 
modal logic syntactic variant si single transitive role name 
describe motivate blocking technique detailed proofs similar result sin horrocks 
please note naively cut rule yield pspace algorithm cut rule similar look analytical cut de giacomo massacci non deterministically guesses constraints propagated completion tree universal restrictions inverted roles 
si technique may lead paths exponential length due equality blocking 
way avoid long paths investigation path polynomial bound 
prove correctness approach necessary establish short path model property similar lemma 
furthermore believe algorithm better suited implementation don know non determinism 
distinguishes approach algorithm spaan intended form basis efficient implementation 
definition completion tree si concept tree node tree labelled sets sub edge labelled possibly inverse role occurring sub 
neighbours successors predecessors defined definition 
due absence role hierarchies identity rd node blocked iff ancestor blocked inv inv predecessor inv inv 
node said contain clash iff 
completion tree expansion rules applicable called complete 
si concept algorithm starts completion tree consisting single node 
applies expansion rules stopping clash occurs answers satisfiable iff completion rules applied way yield complete clash free completion tree 
shif correctness algorithm proved showing si concept satisfiable iff tableau proving si analogue lemma 
theorem tableaux algorithm decision procedure satisfiability subsumption si concepts 
dynamic blocking technique si shi described section label equality may lead completion trees exponentially long paths exponentially possibilities label sets rule 

rule 

rule 

successor 
predecessor 
rule 
trans 
successor 
predecessor 
rule 
blocked rule applicable ancestors 
neighbour create new node tableaux expansion rules si path 
due non deterministic rule exponentially sets may occur 
non determinism problematical disjunctions need completely decomposed yield subset blocking situation 
optimal si algorithm additional label introduced enable sort subset blocking independent non determinism 
intuitively restriction non decomposed concepts satisfy contains boolean decompositions concepts imposed value restrictions descendants 
blocked concepts eventually decomposed clash occurs 
order substitute constraints predecessors strong taken care second blocking condition 
consider path xn edges labelled trans kind paths length longest concept labels decrease 
rules applied xi inv xi inv xi xi ci ci triggered generation xi 
limits number labels guarantees blocking polynomial number steps 
lemma paths completion tree concept length sub 
slight modification expansion rules yields pspace algorithm 
modification necessary original algorithm keep completion tree memory needs exponential space length paths polynomially bounded 
original algorithm may forget branches restrictions pushed upwards tree necessary revisit paths considered 
solve problem follows rule applied node predecessor case rules delete successors completion tree 
necessary restart generation successors possible implement algorithm depth manner facilitates re space 
modification affect proof soundness completeness algorithm re prove termination horrocks relied fact removed nodes completion tree 
summing get theorem modified algorithm pspace decision procedure satisfiability subsumption si concepts 
undecidability unrestricted horrocks describe algorithm shiq shif algorithm 
earlier dls combine hierarchy transitive non transitive roles form number restrictions horrocks sattler horrocks shif dl shiq allows simple roles number restrictions 
justification limitation partly grounds doubtful semantics transitive functional roles partly simplify decision procedures 
section show simpler logic allowing arbitrary roles number restrictions leads undecidability decidability corresponding variant shif open problem 
convenience refer arbitrary roles number restrictions undecidability proof uses reduction domino problem berger adapted baader sattler 
problem asks set domino types exists tiling grid point grid covered domino types adjacent dominoes compatible respect predefined criteria 
definition domino system consists non empty set domino types 
dn sets horizontally vertically matching pairs problem determine exists tiling grid point grid covered domino type horizontally vertically adjacent pairs domino types respectively mapping problem reduced satisfiability concepts undecidability domino problem implies undecidability satisfiability concepts 
ensuring point satisfies compatibility conditions simple logics value restrictions boolean connectives applying conditions grid simple logic deal arbitrary axioms 
crucial difficulty representing grid horizontal vertical roles particular forcing coincidence successors 
accomplished alternating pattern horizontal roles vertical roles disjoint primitive concepts identify points grid different combinations successors 
coincidence successors enforced number restrictions transitive super roles possible combinations roles 
visualisation resulting grid suitable role hierarchy shown transitive roles 
ij alternation roles grid means transitive super roles ij connects point points visualisation grid role hierarchy 
points 
number restriction form ij enforce necessary coincidence successors 
complete specification grid axioms remains add axioms encode local compatibility conditions described baader sattler assert subsumed disjunction domino types 
concept satisfiable various axioms internalised described lemma iff compatible tiling grid 
implementation optimisation development si family dls motivated desire implement systems typical case performance 
discussed section achieved part design logics algorithms particular transitive roles reasoning number restrictions directly encodings 
important feature algorithms relative simplicity facilitates application range optimisation techniques 
systems logics implemented fact horrocks dlp patel schneider race haarslev ller demonstrated suitable optimisation techniques lead dramatic improvement performance algorithms realistic applications 
system shif logic implemented horrocks shown similarly amenable optimisation 
dl systems typically classify kb optimisation techniques systems divided categories stage classification process applied 
clash clash syntactic branching search 
preprocessing optimisations try modify kb classification subsumption testing easier 

partial ordering optimisations try minimise number subsumption tests required order classify kb 

subsumption optimisations try avoid performing potentially expensive satisfiability test usually substituting cheaper test 

satisfiability optimisations try improve typical case performance underlying satisfiability testing algorithm 
optimisations categories relatively independent underlying subsumption satisfiability testing algorithm applied dl system 
concerned algorithms si family dls concentrate fourth kind optimisation try improve performance algorithm 
aimed reducing size search space explored algorithm result applying non deterministic tableaux expansion rules 
semantic branching search implementations algorithms described previous sections typically search technique called syntactic branching 
expanding label node syntactic branching works choosing unexpanded disjunction 
cn searching different models obtained adding disjuncts 
cn giunchiglia sebastiani 
alternative branches search tree disjoint prevent recurrence unsatisfiable disjunct different branches 
resulting wasted expansion costly discovering unsatisfiability requires solution complex sub problem 
example tableaux expansion node unsatisfiable concept lead search pattern shown unsatisfiability demonstrated twice 
problem dealt semantic branching technique adapted davis putnam logemann loveland procedure dpl commonly solve propositional satisfiability sat problems davis freeman 
choosing unexpanded disjunction single disjunct chosen unexpanded disjunctions 
possible sub trees obtained adding searched 
sub trees strictly disjoint possibility wasted search syntactic branching 
note order branches explored irrelevant theoretical viewpoint may offer optimisation possibilities see section 
semantic branching search additional advantage great deal known implementation optimisation dpl algorithm 
particular local simplification see section heuristic guided search see section try minimise size search tree noted techniques adapted syntactic branching search 
disadvantages semantic branching search 
firstly possible performance degraded adding negated disjunct second branch search tree example disjunct large complex concept 
serious problem practice semantic branching rarely exhibiting significantly worse performance syntactic branching 
secondly effectiveness problem dependent 
effective randomly generated problems particularly constrained unsatisfiable horrocks patel schneider 
effective hand crafted problems tableaux benchmark suite 
little benefit classifying realistic kbs horrocks patel schneider 
local simplification local simplification technique reduce size search space resulting application non deterministic expansion rules 
non deterministic expansion node label performed disjunctions examined possible simplified 
simplification commonly deterministically expand disjunctions expansion possibility detect clash disjunction expansion possibilities 
simplification called boolean constraint propagation bcp freeman 
effect inference rule 
cn 
cn simplify conjunctive concept represented 
example node bcp deterministically expands disjunction adding 
deterministic expansion adds allowing bcp identify clash branching having occurred 
clash semantic branching search bcp simplification usually described integral part sat algorithms giunchiglia sebastiani syntactic branching 
effective semantic branching negated concepts introduced failed branches result additional simplifications 
example adding allows bcp deterministically expand disjunctions simplifications reduced search space resulting combination semantic branching bcp shown 
local simplification advantage increase size search space degrade performance extent overhead required perform simplification 
minimising overhead require complex data structures freeman particularly modal description logic setting 
semantic branching effectiveness problem dependent optimisation effective constrained randomly generated problems horrocks patel schneider 
dependency directed backtracking inherent unsatisfiability concealed sub problems lead large amounts unproductive backtracking search called thrashing 
example expanding node semantic branching 
cn dn lead fruitless exploration possible successors inherent unsatisfiability discovered 
search tree resulting tableaux expansion illustrated 
problem addressed adapting form dependency directed backtracking called backjumping solving constraint satisfiability problems baker similar technique harp theorem prover oppacher suen 
backjumping works labelling concept node label dependency set indicating branching points depends 
concept depends branching point added branching point generated expansion rule including simplification depends concept depends branching point 
concept depends concept added cn clash clash thrashing backtracking search deterministic expansion 
example derived expansion depends 
clash discovered dependency sets concepts identify branching point exploring branch alleviate cause clash 
possible jump back intervening branching points exploring alternative branches 
consider earlier example suppose dependency set di dependency set dj 
search proceeds 
cn added deterministically expanded clash occurs derived derived derivations deterministic dependency sets di dj respectively di dj returned 
set include branching points 
cn added di dj defined branching points reached 
algorithm backtrack preceding branching points exploring second branches continue backtrack reaches branching point equal maximum value di dj di dj algorithm backtrack branching points return unsatisfiable 
illustrates pruned search tree number successors explored reduced exponential number 
backjumping syntactic branching procedure slightly complex may possible choices branching point dependency set disjunction expanded taken account 
local simplification backjumping increase size search space 
lead dramatic reduction size clash pruning pruning search backjumping search tree huge performance improvement 
example fact dlp backjumping disabled order classify large concept kb derived european galen project rector single satisfiability tests encountered solved weeks cpu time 
classifying kb backjumping enabled takes cpu time fact dlp horrocks patel schneider 
backjumping disadvantage overhead propagating storing dependency sets 
alleviated extent pointer implementation propagating dependency set requires copying pointer 
heuristic guided search heuristic techniques guide search way tries minimise size search tree 
method widely dpl sat algorithms branch disjunct maximum number occurrences disjunctions minimum size known heuristic freeman 
choosing disjunct occurs frequently small disjunctions heuristic tries maximise effect bcp 
example label node contains unexpanded disjunctions 
dn branching leads deterministic expansion single step added disjunctions fully expanded added bcp expand disjunctions causing 
dn added 
branching 
dn hand cause single disjunction expanded 
value candidate concept computed simply counting number times negation occur minimally sized disjunctions 
variants heuristic including heuristic jeroslow wang jeroslow wang 
jeroslow wang heuristic considers occurrences disjunct weighting size disjunction occur 
heuristic selects disjunct highest weighting objective maximising effect bcp reducing size search tree 
disjunct selected disjunctions bcp maximising heuristic determine order possible branches explored 
done separating components heuristic weighting contributed occurrences trying smallest contribution trying 
intention prune search tree maximising bcp branch 
unfortunately style heuristics interact adversely backjumping optimisation take dependency information account 
discovered fact system noticed heuristic led worse performance 
cause phenomenon turned fact heuristic data structures implementation naturally led older disjunctions dependent earlier branching points expanded newer ones led effective pruning clash discovered 
heuristic disturbed ordering reduced effectiveness backjumping horrocks 
style heuristics little value description logic systems rely effectiveness finding disjuncts recurring multiple unexpanded disjunctions hard propositional problems disjuncts propositional variables number different variables usually small compared number disjunctive clauses problems general trivially satisfiable concept satisfiability problems disjuncts possibly non atomic concepts number different concepts usually large compared number disjunctive clauses 
result heuristics discover disjuncts similar equal priorities guidance provide particularly useful 
alternative strategy employ oldest heuristic tries maximise effectiveness backjumping dependency sets guide expansion horrocks patel schneider 
choosing disjunct branch heuristic selects disjunctions depend branching points minimal maximum values dependency sets selects disjunct disjunctions 
combined bcp maximising heuristic jeroslow wang heuristic select disjunct selected disjunctions 
oldest heuristic advantage selecting order existential role restrictions labels successors generate expanded 
possible technique heuristic select unexpanded existential role restriction label node apply rule rule necessary expand label resulting successor 
expansion results clash algorithm backtrack continue selecting expanding existential role restrictions fully expanded 
better technique apply rule rule exhaustively creating set successor nodes 
order expand successors minimal maximum values dependency sets concepts label may due universal role restrictions 
main advantage heuristics complement optimisations 
jeroslow wang heuristics example designed increase effectiveness bcp oldest heuristic designed increase effectiveness backjumping 
selected tuned take advantage kinds problem solved known 
bcp maximisation heuristics example generally quite effective large randomly generated hand crafted problems oldest heuristic effective classifying realistic kbs 
unfortunately heuristics disadvantages 
add significant overhead heuristic function may expensive evaluate may need reevaluated branching point 
may improve performance may significantly degrade example interacting adversely optimisations increasing frequency pathological worst cases expected occur generally easy problem sets 
caching satisfiability status satisfiability check may successor nodes created 
nodes similar particularly labels successors node contain concepts derived universal role restrictions 
systems dlp take advantage similarity caching satisfiability status sets concepts node labels initialised created 
tableaux expansion node avoided satisfiability status initial set concepts cache 
technique depends logic having property satisfiability node completely determined initial label set due possible presence inverse roles si logics property 
example expansion node generates successor node satisfiability clearly depends set concepts 
similar problems arise case contains number restriction concepts 
possible solve problems caching may effective technique si logics shown dlp system logic support inverse roles 
caching particularly useful kb classification cached values retained multiple satisfiability tests 
effective satisfiable unsatisfiable problems optimisation techniques primarily aimed speeding detection unsatisfiability 
main disadvantage caching storage overhead incurred retaining node labels additional information case si logics satisfiability status satisfiability test longer results satisfiability tests 
additional problem interacts adversely backjumping optimisation dependency information required backjumping effectively calculated nodes unsatisfiable result cache lookup 
set concepts initial label node expanded node un satisfiability status cached dependency sets attached concepts labels may 
weaker form backjumping performed dependency set unsatisfiable node union dependency sets concepts label 
discussion new dl system implemented shiq algorithm developed shif algorithm described section horrocks 
pending completion project existing fact system horrocks modified deal inverse roles shif blocking strategy resulting system referred 
conduct initial experiments terminology representing fragments database schemata inter schema assertions data warehousing application calvanese slightly simplified version proposed encoding generate shif terminologies 
able classify terminology contains concepts axioms mhz pentium cpu time 
contrast eliminating inverse roles embedding technique calvanese gives fact terminology additional axioms fact unable classify hours cpu time 
discussed section extension embedding technique eliminate number restrictions de giacomo lenzerini requires target logic supports transitive closure roles converse pdl 
larger number axioms embedding introduce tractable reasoning performed resulting terminology 
aware algorithm converse pdl employ called look analytical cut de giacomo massacci application introduces considerable additional non determinism 
inevitable lead degradation empirical tractability 
dl shiq allow mentioned encoding database schemata fully captured qualified number restrictions 
include completing implementation shiq algorithm testing behaviour kind application investigating new techniques improving empirical tractability 
baader baader 
nebel nutt smolka 
expressivity feature logics negation functional uncertainty sort equations 
journal logic language information 
baader baader buchheit hollunder 
cardinality restrictions concepts 
artificial intelligence 
baader baader 
augmenting concept languages transitive closure roles alternative terminological cycles 
technical report rr dfki kaiserslautern 
abridged version appeared proc 
ijcai pp 

baader sattler baader sattler 
number restrictions complex roles description logics 
aiello doyle shapiro editors proc 
kr pages 
morgan kaufmann publishers san francisco california november 
baker baker 
intelligent backtracking constraint satisfaction problems experimental theoretical results 
phd thesis university oregon 

comparison theorem provers modal logics summary 
vol 
lnai pages 
springer verlag 
berger berger 
undecidability problem 
mem 
amer 
math 
soc 
buchheit buchheit donini schaerf 
decidable reasoning terminological knowledge representation systems 
artificial intelligence research 
calvanese calvanese lenzerini nardi 
unified framework class representation formalisms 
doyle sandewall torasso editors proc 
kr pages bonn 
kaufmann los altos 
calvanese calvanese de giacomo lenzerini nardi rosati 
source integration data warehousing 
proc dexa pages 
ieee computer society press 
calvanese calvanese de giacomo rosati 
note encoding inverse roles functional restrictions alc knowledge bases 
franconi 
davis davis logemann loveland 
machine program theorem proving 
communications acm 
de giacomo lenzerini de giacomo lenzerini 
description logics inverse roles functional restrictions ary relations 
vol 
lnai pages 
springer verlag 
de giacomo lenzerini de giacomo lenzerini 
aggregate foundations description logics tuples sets 
proc 
ijcai pages 
de giacomo lenzerini de giacomo lenzerini 
tbox abox reasoning expressive description logics 
proc 
kr pages 
kaufmann los altos 
de giacomo massacci de giacomo massacci 
combining deduction model checking tableaux algorithms converse pdl 
information computation 
appear 
donini donini lenzerini nardi schaerf 
reasoning description logics 
brewka editor foundation knowledge representation 
csli publication cambridge university press 
fischer ladner fischer ladner 
propositional dynamic logic regular programs 
computer system science 
franconi franconi de giacomo macgregor nutt welty sebastiani editors 
proc 
dl 
ceur may 
freeman freeman 
improvements propositional satisfiability search algorithms 
phd thesis department computer information science university pennsylvania 
freeman freeman 
hard random sat problems davis putnam procedure 
aij 
giunchiglia sebastiani giunchiglia sebastiani 
building decision procedures modal logics propositional decision procedures case study modal proc 
cade lnai new brunswick nj usa 
haarslev ller haarslev ller 
race system description 
lambrix pages 

benchmark method propositional modal logics kt 
technical report iam university bern switzerland 
hollunder hollunder nutt schmidt 
subsumption algorithms concept description languages 
proc 
ecai pitman publishing london 
hollunder baader hollunder baader 
qualifying number restrictions concept languages 
proc 
kr pages boston ma usa 
horrocks horrocks sattler tobies 
deciding alci satisfiability 
technical report theoretical computer science rwth aachen 
horrocks horrocks sattler tobies 
practical reasoning expressive description logics 
proc 
lpar pages 
horrocks horrocks 
optimising tableaux decision procedures description logics 
phd thesis university manchester 
horrocks horrocks 
fact system 
de swart editor proc 
tableaux number lnai pages 
springer verlag berlin may 
horrocks horrocks 
expressive description logic fact fiction 
cohn schubert shapiro editors proc 
kr pages 
morgan kaufmann publishers san francisco california june 
horrocks horrocks 
fact 
lambrix pages 
horrocks patel schneider horrocks patel schneider 
comparing subsumption optimizations 
franconi pages 
horrocks patel schneider horrocks patel schneider 
optimising description logic subsumption 
logic computation 
horrocks sattler horrocks sattler 
description logic transitive inverse roles role hierarchies 
logic computation 
jeroslow wang jeroslow wang 
solving propositional satisfiability problems 
annals mathematics artificial intelligence 
kozen tiuryn kozen tiuryn 
logics programs 
leeuwen editor handbook theoretical computer science formal models semantics pages 
elsevier science publishers north holland amsterdam 
lambrix lambrix borgida lenzerini ller patel schneider editors 
proc 
dl 
oppacher suen oppacher suen 
harp tableau theorem prover 
automated reasoning 
patel schneider patel schneider 
dlp system description 
franconi pages 
pratt pratt 
models program logic 
proc 
focs pages 
rector rector nowlan 
goals concept representation galen project 
proc 
scamc pages washington dc usa 
sattler sattler 
concept language extended different kinds transitive roles 

deutsche ki vol 
lnai 
springer verlag 
schild schild 
correspondence theory terminological logics preliminary report 
proc 
ijcai pages sydney 
schmidt schau smolka schmidt schau smolka 
attributive concept descriptions complements 
artificial intelligence 
spaan spaan 
complexity propositional tense logics 
de rijke editor diamonds defaults pages 
kluwer academic publishers dordrecht 

