coordination models languages papadopoulos arbab software engineering sen sen december centrum voor wiskunde en informatica report sen issn cwi box gb amsterdam netherlands cwi national research institute mathematics computer science 
cwi part stichting mathematisch centrum smc dutch foundation promotion mathematics computer science applications 
smc sponsored netherlands organization scientific research nwo 
cwi member ercim european research consortium informatics mathematics 
copyright stichting mathematisch centrum box gb amsterdam nl kruislaan sj amsterdam nl telephone telefax coordination models languages george papadopoulos department computer science university cyprus nicosia cyprus arbab cwi box gb amsterdam netherlands new class models formalisms mechanisms evolved describing concurrent distributed computations concept coordination 
purpose coordination model associated language provide means integrating number possibly heterogeneous components interfacing component way collective set forms single application execute take advantage parallel distributed systems 
chapter initially define sufficient detail fundamental concepts constitutes coordination model language 
go classify models languages data driven control driven called process task oriented 
main existing coordination models languages described sufficient detail reader appreciate features put perspective respect 
chapter ends discussion comparing various models 
mathematics subject classification computing reviews classification system keywords phrases parallel distributed computing coordination models languages mimd models communication 
background motivation organisation article 
multilingual heterogeneous systems coordination models need multilinguality heterogeneity coordination paradigm 
coordination models languages data vs control driven coordination data driven coordination models control driven coordination models 
comparison 

background motivation massively parallel distributed systems open new horizons large applications new challenges software technology 
applications take advantage increased raw computational power provided parallel systems yield significantly shorter turn times 
availability processors single application presents new challenge software technology coordination cooperation large numbers concurrent active entities 
classical views concurrency programming languages extensions sequential programming paradigm ill suited meet challenge 
exploiting full potential massively parallel systems requires programming models explicitly deal concurrency cooperation large numbers active entities comprise single application 
led design implementation number coordination models associated programming languages 
models share intent provide framework enhances modularity reuse existing sequential parallel components portability language interoperability 
differ precisely define notion coordination exactly coordinated coordination achieved relevant metaphors 
purpose survey chapter twofold thorough view contemporary state art research area coordination models languages ii provide information historical evolution design implementation application give reader appropriate understanding important rapidly evolving research area computer science appreciate potential 
argue coordination models languages classified main categories data driven evolution computation driven types properties data involved coordination activities control driven process oriented changes coordination processes triggered events signifying things changes states coordinated processes 
organisation article rest chapter organised follows part provides historical perspective coordination programming explains evolved current form 
part describes detail important coordination models languages mentioned classification 
part presents general comparison classification models described previous part part ends chapter 

multilingual heterogeneous systems coordination models need multilinguality heterogeneity evolution distributed parallel systems new programming paradigms developed available parallelism massive number processors comprising system 
languages able exploit parallelism perform communication fault tolerant 
differed granularity unit parallelism offered sequential process object parallel statements communication mechanism employed message passing models rendezvous remote procedure calls data sharing models distributed data structures shared variables 
increased availability massively parallel open distributed systems lead design implementation complex large applications vehicle navigation air traffic control intelligent information retrieval multimedia environments name 
gradually apparent unique programming language machine architecture able deal satisfactory way facets developing complex multifunctional application 
furthermore issues reusability compositionality extensibility paramount importance 
order deal requirements programming large applications notions multilinguality heterogeneity came play 
multilingual multiparadigm programming able support number diverse paradigms provide interoperation paradigms time isolate unwanted interactions 
furthermore multilingual multiparadigm programming environment aims accommodating diverse execution models mechanisms various paradigms manage resources required implementing offer intuitive ways combining code written mixture paradigms time providing orthogonal programming interfaces involved paradigms 
basically ways produce multilingual multiparadigm languages design new offers facilities paradigms intended provide interface existing languages 
approach advantage usually providing coherent combination different paradigms 
disadvantages introducing programming language programmer learn plus fact single language possibly support functionality languages aims replace 
second approach fact realised different degrees integration ranging operating system communication primitives inter component collaboration providing concrete integration various languages involved case say module interconnection languages 
multilinguality closely related heterogeneity heterogeneous systems mixed mode computers demand programming language able express useful models computation 
usually impossible find single language able deal satisfactorily extensive variety models mixture language models may employed 
years number models metaphors devised purpose partially away encapsulate details communication cooperation number entities forming computation actual computational activities performed entities 
typical example blackboard model developed needs distributed artificial intelligence blackboard common forum number autonomous agents forming multi agent system solve problem cooperative manner 
typical example actor model principles concurrent object oriented programming actors represent self contained computational entities message passing direct manipulation internal data structures coordinate activities finding solution problem 
examples concerned primarily development parallel distributed systems 
sequential systems mention various component interconnection mechanisms developed mentioned instance general model 
coordination paradigm coordination paradigm offers promising way alleviate problems address issues related development complex distributed parallel computer systems outlined 
programming distributed parallel system seen combination distinct activities actual computing part comprising number processes involved manipulating data coordination part responsible communication cooperation processes 
coordination distinguish computational concerns distributed parallel application communication ones allowing separate development eventual amalgamation major development phases 
concept coordination closely related multilinguality heterogeneity 
coordination component separate computational views processes comprising black boxes actual programming languages write computational code play important role setting coordination apparatus 
furthermore coordination component offers homogeneous way interprocess communication abstracts away machine dependent details coordination encourages heterogeneous ensembles architectures 
concept coordination means limited computer science 
seminal malone crowston characterise coordination emerging research area interdisciplinary focus playing key issue diverse disciplines economics operational research organisation theory biology 
consequently definitions coordination ranging simple ones coordination managing dependencies activities 
elaborate ones coordination additional information processing performed multiple connected actors pursue goals single author pursuing goals perform 
area programming languages probably widely accepted definition carriero gelernter coordination process building programs gluing active pieces 
consequently coordination model glue binds separate activities ensemble 
coordination model viewed triple represents entities coordinated media coordinate entities semantic framework model adheres 
furthermore coordination language linguistic embodiment coordination model offering facilities controlling synchronisation communication creation termination computational activities 
closely related concept coordination configuration architectural description 
configuration architectural description languages share principles coordination languages 
view system comprising components interconnections aim separating structural description components component behaviour 
furthermore support formation complex components compositions elementary components 
understand changing state system activity performed level interconnecting components internal purely computational functionality component 
adopts slightly liberal view coordination include configuration architectural description languages category coordination languages 
reversely view coordination dealing architectures configuration computational entities 
sequel number coordination models languages coordination mean configuration architectural description 
cover cases ordinary languages coordination framework described 
collections coordination models languages survey article focus family models languages classification 

coordination models languages data vs control driven coordination purpose third main section chapter important coordination models languages 
number dimensions classify models languages kind entities coordinated underlying architectures assumed models semantics model adheres issues scalability 

provide classification summary comparison models languages section argue models fall major categories coordination programming data driven control driven task process oriented 
main characteristic data driven coordination models languages fact state computation moment time defined terms values data received sent actual configuration coordinated components 
words coordinator coordinated process responsible examining manipulating data coordinating processes invoking coordination mechanism language provides 
necessarily mean exist useful clear separation coordination functionality purely computational functionality process 
usually mean linguistically exists mixture coordination computation code process definition 
data driven coordination language typically offers coordination primitives coupled coordination metaphor mixed purely computational part code 
primitives encapsulate useful way communication configurational aspects computation conjunction purely computational manipulation data associated process 
means processes easily distinguished coordination computational processes 
usually programmer design program way coordination computational concerns clearly separated responsibility different processes time clear separation enforced syntactic level coordination model 
main difference models data driven category control driven category case complete separation coordination computational concerns 
state computation moment time defined terms coordinated patterns processes involved computation adhere 
actual values data manipulated processes involved 
means coordination component completely separated computational component usually achieved defining brand new coordination language computational parts treated black boxes clearly defined input output interfaces 
consequently case data driven category coordination component usually set primitives predefined functionality connection host computational language control driven category coordination component usually fully fledged language 
means easier second case fact usually enforced model syntactically separate processes program modules distinct groups purely computational ones purely coordination ones 
aside stylistic differences categories affect degree separation computational coordination concerns category suitable different type application domain 
data driven category tends parallelising computational problems 
control driven category tends primarily modelling systems 
may attributed fact configuration component programmer control manipulated data case data driven coordination languages case control driven ones 
category tends coordinate data tends coordinate entities addition ordinary computational processes devices system components 
stress point data vs control driven separation means clear cut 
instance regarding application domains data driven coordination language laura distributed systems control driven coordination languages manifold parallelising data intensive programs 
furthermore regarding degree syntactic decoupling computational coordination components ariadne concrete separate coordination component belongs data driven category 
main difference general categories hold data driven category coordination component sees manipulated data control driven category actual structure contents data little importance 
sequel describe detail major members main categories coordination models languages 
data driven coordination models coordination models belonging category evolved notion shared dataspace 
shared dataspace common content addressable data structure 
processes involved computation communicate indirectly medium 
particular post broadcast information medium retrieve information medium removing information shared medium merely copy 
interprocess communication done shared dataspace medium contents independent life history processes involved metaphor achieves decoupling processes space time 
processes send data medium carry doing things terminate execution processes asynchronously retrieve data producer need know identity consumer vice versa data posted medium retrieved read 
illustrates general scenario advocated coordination languages category 
round objects represent processes square ones represent data 
empty square boxes templates processes specify sort data retrieved removal copying shared medium 
filled square boxes represent various kinds data structures 
small round objects represent active data structures effectively processes execution terminates turn passive ordinary data 
process may pure producer pure consumer 
various models category different respect number parameters 
instance parameter actual structure data cases flat tuples records cases nested tuples records supported 
parameter actual mechanism employed retrieve data 
models various forms pattern matching sophisticated techniques view shared medium flat unstructured space view multiset 
distinction related issues locality shared medium security efficiency 
strictly speaking coordination models category follow pattern coordi nation cases say shared variables treat variables restricted version shared dataspace 
instance section messagepassing shared dataspace mechanism 
models data driven sense defined section 
linda linda historically genuine member family coordination languages 
provides simple elegant way separating computation communication concerns 
linda called generative communication paradigm processes wish exchange data sender generates new data object referred tuple places shared dataspace known tuple space receiver retrieve 
paradigm decouples processes space time process need know identity processes required processes involved computation alive time 
addition passive tuples containing data tuple space contain active tuples representing processes completion execution turn ordinary passive tuples 
linda fact fully fledged coordination language set simple coordination primitives 
particular put passive tuple tuple space retrieves passive tuple tuple space rd retrieves copy tuple space eval puts active tuple process tuple space 
primitives rd blocking primitives suspend execution desired tuple 
primitives eval non blocking primitives 
process executes eval carry executing parallel turn passive tuple completes execution 
years number additional primitives introduced basic model inp non blocking variants rd respectively desired tuple tuple space return false 
tuples sequences typed fields 
retrieved tuple space means associative pattern matching 
point parameter primitives inp rd rdp tuple schemata containing formal parameters pattern matching actual tuple ta tuple space succeed provided number position types fields match ta 
linda primitives completely independent host language possible derive natural linda variants programming language paradigm imperative logic functional object oriented 
linda friends modula pascal ada prolog lisp eiffel java name 
example implementation dining philosophers linda 
dining philosophers problem number typically philosophers seated table plate food typically spaghetti front fork plate 
eat forks adjacent 
act independently may pick left fork enter deadlocked state waiting forever right fork available 
standard problem developing coordination solutions independently executing processes 
define num philosopher int main int num think room ticket fork fork eval philosopher fork num num eat room ticket fork fork num room ticket linda model appealing deceptively simple comes implementing especially distributed usually case environments considered 
number issues linda implementor address precisely tuples stored retrieved load balancing achieved choices implementing eval primitive furthermore programmers usually adhere specific communication coordination patterns protocols optimised 
number different approaches implementing linda 
piranha example execution model linda particularly suited networks workstations 
piranha features adaptive parallelism processor assignment executed processes changes dynamically 
typical piranha program usually variant master slave paradigm 
particular exists feeder process responsible distributing computations selecting results number perform computations 
statically distributed available nodes network migrate run time 
remain dormant long node reside unavailable node available get activated 
node claimed back system removed list available nodes piranha residing retreat 
current task stopped retreating piranha posts tuple space information allow piranha take rest 
typical applications suitable piranha paradigm simulations lu decompositions 
general structure piranha program follows 
define done int index feeder piranha int count struct result result struct result result put tasks count count tasks count task index task count index done help compute results tasks done piranha task index collect results count count tasks count result count result data task index result result index result retreat tasks done index tasks done replace current task tasks task index task done linda inspired creation similar languages direct extensions basic linda model differ significantly 
derivatives aim improve extend basic model multiple tuple spaces enforcement security protection data posted tuple space proposals described promptly 
bauhaus linda bauhaus linda direct extension vanilla linda model featuring multiple tuple spaces implemented form multisets 
bauhaus linda differentiate tuples tuple spaces tuples anti tuples tuple templates active passive tuples 
adding tuples reading removing tuples single flat tuple space bauhaus linda rd operations add multisets read remove multisets multiset 
consequently linda ordered position dependent associative pattern matching tuples replaced unordered set inclusion 
assuming existence multiset abb elements capital letters denote processes rest denote ordinary tuples executes multiset abb multiset form abb xy executes rd get assigned structure xy 
multiset form abb executes assigned structure live due presence element 
furthermore language introduces new primitive move allows tuples move levels multiset 
instance multiset form abb executes move result abb 
exist variants move causes issuing process go level structure equivalent move sibling node contains possible organise data useful hierarchies world africa 

north america usa 
ct 
new haven 
yale 
cs 
assuming vector strings path represents travelling course move means commands path path bonita bonita collection new linda primitives aiming enhancing functionality basic model improve performance 
goal achieved providing functionality multiple tuple spaces aggregate tuple manipulation 
second goal achieved providing finer grain notion tuple retrieval request process finding tuple tuple space treated separately checking delivered requesting process activities done parallel consequently related overhead minimised 
particular bonita supports coordination primitives dispatch ts tuple non blocking puts tuple ts returns tuple id processes may want retrieve tuple 
dispatch ts template non blocking retrieves tuple ts matching template removing specified getting copy specified returns request id 
dispatch bulk ts ts template non blocking moves ts tuples matching template 
arrived non blocking tests locally environment issuing process tuple indicated id arrived returns true false accordingly 
obtain blocking suspends tuple indicated id available 
subtle differences basic linda model bonita understood considering retrieval tuples single tuple space general tuple space may involved linda bonita int dispatch ts dispatch ts dispatch ts get get get linda operation complete execution second commences bonita follows finer grain scenario requests sought tuples dispatched underlying system starts executing parallel 
time taken retrieve tuple overlapped time taken retrieve tuples 
bonita possible express efficiently basic linda model non deterministic selection construct linda bonita int dispatch ts dispatch ts inp arrived break break inp arrived second break second break linda version repeatedly polls global tuple space order check requested tuples appeared furthermore execution inp operations serialised 
bonita version dispatches requests underlying system able serve parallel keeps checking locally environment process requested tuples arrived 
literature bonita shows cases finer grain notion tuple handling model introduced produces substantial gains performance 
law governed linda bauhaus linda bonita extend basic language modifying model underlying implementation law governed linda set laws processes wishing participate exchange data tuple space adhere 
particular exists controller process system controllers copy law 
controller responsible intercepting attempted communication process controls rest world 
attempted communication allowed complete adheres law 
law governed linda system understood tuple cs tuple space set processes cs set control states associated process law governs system set controllers enforce law 
law formulated language natural choice host language linda system designers law governed linda chosen restricted subset prolog enhanced primitives complete carries operation invoked complete arg original argument operation replaced arg return conjunction linda effect deliver requested tuple issuing process return delivered matched operation tuple conventional linda primitive remove removes issuing process system 
furthermore tuple terms may contain attributes self unique id process clock current local time process op argument latest linda operation invoked issuing process 
addition adds sequence primitive operations ruling list executed ruling law complete add remove respectively term control state process 
process certain state represented global variable cs examined means operator 
user may enhance basic linda functionality formulating suitable law 
instance prolog clauses implement secure message passing message tuple form msg contents msg tag identifying tuple message sender process receiver process contents represents actual contents message 

msg self complete 

msg self complete return 

msg complete 

rd msg complete return 
allows process messages id sender field message forged 
allows process remove tuple tuple space id receiver field 
simply send read retrieve tuple space respectively tuple need adhere law 
possible law governed linda establish multiple tuple spaces means laws 
subspace cs complete 

rd subspace actual cs complete return 
initially process number terms control state identifying subspaces access 
allows process tuple subspace provided term control state 
uses primitive actual sure variable representing name subspace instantiated ground value process attempt query multiple subspaces proceeding retrieve read tuple subspace 
objective linda objective linda direct variant basic linda model influenced bauhaus linda particularly suited modelling open systems 
objective linda introduces object model suitable open systems independent host programming language objects objective linda described object interchange language oil language independent notation 
objects object space means suitably defined object space operations address requirements 
furthermore language supports hierarchies multiple object spaces ability objects communicate object spaces 
object spaces accessible object space passed objects object tuple space retrieved space special attach operation 
particular objective linda supports operations variants linda basic coordination primitives bool multiset double timeout tries move objects contained object space 
returns true attempted operation successful false operation completed timeout seconds 
bool eval multiset double timeout similar previous operation moved objects activated execution 
multiset oil object int min int max double timeout tries remove multiple objects matching template object object space returns multiset containing min matching objects timeout seconds 
case multiset contains max objects object space contained 
min objects timeout seconds null returned 
multiset rd oil object int min int max double timeout similar previous operation clones multiple objects returned 
int infinite matches constant value interpreted infinite number matching objects provided min max parameter 
double infinite time constant value interpreted infinite delay provided timeout parameter 
example models collision avoidance scenario cars driving cyclic grid 
class position public oil object private bool match position switching matching mode public int grid position int car car id bool match oil object obj match position return position obj position obj return position obj car car set match position match position true set match car match position false class car public oil object private int grid position int car car id direction dir direction move void wait wait arbitrary interval void evaluate multiset new multiset position int nx ny px py true put new position id void context context infinite time wait store position move nx ny nx 
ny 
new position id nx ny set match position context rd car front delete delete delete store position priority px py px 
py 
new position id px py set match position context rd car priority delete delete nx ny move delete new position car id set match car context context infinite time get delete agents responsible steering cars communicate object space 
agent puts object type position object space carries agent id position grid 
changing position agent consumes ins position object id replaces new updated position 
agent changes position checks rd position object directly front case wait 
checks car approaching direction case waits 
functionality modelled car 
laura laura approach deriving linda coordination model suitable open distributed systems 
laura system agents offer services functions 
agents communicate service space shared agents means exchanging forms 
form contain description service offer request arguments service result results 
suitable primitives provided language intention put retrieve offer request result forms service space 
point serve clients ask service service servers offer service result servers produce result form 
identification services done means naming schemes describing interface signature consisting set operation signatures 
operation signatures consist name types arguments parameters 
case objective linda host languageindependent interface description language stl service type language purpose 
furthermore service space monolithic fault tolerant 
code models activities travel ticket purchase system 
serve large agency operation cc day month year dest ack dollar cent cc day month year dest ack dollar cent line serve cc day month year dest ack dollar cent 
result large agency operation cc day month year dest ack dollar cent cc day month year dest ack dollar cent line result service small agency cc day month year dest ack dollar cent 
service cc day month year dest ack dollar cent 
service interface large agency offered code selected operation bound operation 
depending services offered large agency requested respective program variables cc day bound arguments offered service user 
serve executes serve form built arguments service space scanned service request form service type matches offered type code requested operation provided arguments copied serve form bound program variables binding list 
performing requested service service provider uses result deliver result form service space 
agent interface small agency wishes invoke service executes service program variables bound accordingly order small agency provide large agency needed information cc agency pass back agency results service ack 
ariadne hopla ariadne modelling language hopla attempt linda coordination manage hybrid collaborative processes 
linda models ariadne uses shared workspace holds tree shaped data self descriptive sense addition actual data holds constraints type definitions govern structure 
highly structured data forms consisting typed fields semi structured data email messages handled 
processes comprising ariadne system defined hybrid office process language hopla concept flexible records enhanced constructors set collections aggregate operations constraints 
tasks defined means action terms coordination operators serie sequential execution parl parallel execution execution random order 
example models electronic discussion group people discussion process group set action type actor value ps set discuss thread data serie message string action actor ps replies set parl type thread set actors participating discussion defined setting feature group 
group established string message feature provided actors group 
replies added parallel members group spawning different thread execution 
sonia sonia approach linda coordination languages model activities information systems 
fact sonia extension linda extra functionality adaptation coordinating human activities organisations 
basic linda functionality expressed higher level metaphors understandable including non computer specialists 
equivalent tuple space number actors communicating means posting extracting messages 
agora class citizen nested defined 
messages written tuples named values tuple shape square color red 
nested typed tuples supported 
traditional linda primitives rd replaced intuitively named primitives post pick peek respectively 
new primitive cancel introduced intended abort outstanding pick peek request 
templates enhanced timeout functionality rules template template shape color rule value red value blue match tuple shape long colour red blue 
linda world wide web concept coordination introduced development middleware web environments 
shared dataspace paradigm linda particularly attractive orchestrating distributed web applications number extensions proposed basic linda model suitable developing interactive www environments 
basic advantage introducing coordination formalism web application easier separate processing concerns 
cgi scripts deal getting data means electronic forms displaying coordination formalism responsible sending receiving data tuple space 
system enhanced major features coordination formalism heterogeneous execution applications multilinguality 
jada combination java linda able express mobile object coordination multithreading suited open systems 
suitable classes defined providing remote access tuple space communication done means sockets 
needs know host port id language provides appropriate constructs specifying information 
jada coordination language se kernel language designing complex coordination languages www 
jada program implements symmetric ping pong 
jada tuple import java client public class ping static final string ts host foo bar public void run tuple client interacts remote server tupleclient ts new tupleclient ts host ping pong true ts new tuple ping tuple tuple ts new tuple pong public static void main string args ping ping new ping ping run pong import jada tuple import java client public class pong static final string ts host foo bar public void run tuple client interacts remote server tupleclient ts new tupleclient ts host ping pong true ts new tuple pong tuple tuple ts new tuple ping public static void main string args pong pong new pong pong run shade higher level object oriented coordination language web 
shade coordinated entities java objects 
jada singleton tuple transactions shade multiset rewriting 
object shade name class state 
name pattern deliver messages 
type defines object behaviour 
state contents multiset associated object 
ping pong program defined shade follows 
class ping class class pong class ping pong send pong pong send ping ping done done terminate terminate class comprises methods separated 
method activated items ping pong appear proper object multiset 
method activated object ping say message pong sent object pong vice versa 
message delivered object put object multiset triggers activation method object 
second method triggered item done causes termination object 
gamma gamma general model multiset manipulation model coordination framework multiset rewriting 
basic data structure gamma multiset bag seen chemical solution ordinary set contain multiple occurrences element 
simple program pair reaction condition action execution involves replacing elements multiset satisfying reaction condition products action 
result obtained reactions take place system stable 
unique control structure associated multisets operator definition follows 
rm am xn ri xn xn ri xn rm am xn ai xn 
represents multisets ri ai pairs closed functions specifying reactions 
effect ri ai multiset replace subset elements xn ri xn xn 
gamma enjoys powerful locality property ri ai pure functions operating arguments 
reaction condition holds disjoint subsets reactions carried parallel 
code implements prime number generator 
prime numbers 
multiple solution consists removing multiple elements multiset 
remaining multiset contains exactly prime numbers operational behaviour model strictly implicit programmer specify order execution default completely parallel practical reveals number program schemes identified ones programs 
schemes referred tropes transmuter applies operation elements multiset element satisfies condition reducer reduces size multiset applying operation pairs elements satisfying optimiser optimises multiset criterion expressed ordering functions preserving structure multiset expander decomposes elements multiset collection basic values condition applying element removes multiset elements satisfying tropes combined form complex programs combination tropes opposed fundamental operator implements functionality fibonacci function fib add zero dec dec zero add true vanilla gamma model enriched sequential parallel operators higher order functionality types 
furthermore order express structure variant basic model proposed structured gamma featuring structured multisets 
seen set addresses satisfying specific relations associated value 
type defined terms rewrite rules structured multiset belongs type underlying set addresses satisfies invariant expressed rewrite system defining structured gamma reactions test modify relations addresses values associated addresses 
structured gamma particularly suited concept coordination addresses interpreted individual entities coordinated 
associated value defines behaviour programming language independent coordination relations correspond communications links 
structuring type provides description shape configuration 
structured gamma modelling software architectures particular type coordination usually modelled coordination languages control driven family 
instance structured gamma code models client server architecture cs nn nn cr cn ca nc nn nn sr ns sa sn nn nn mn cr respectively communication link client manager dual link new client added means rewrite rule mn cr cn ca nc lo linear objects lo object oriented language interaction machines computational model 
concept interaction closely related principles underpinning theory linear logic fact lo linearity multiset rewriting gamma asynchronous actor communication means broadcasting 
lo views computation system communicating agents state represented multiset 
agents evolve terms transitions transformations state addition agents created terminate 
inter agent communication achieved means broadcasting 
lo program set effectively multi headed rewrite rules general form multiset broadcast built ins goal multiset 
broadcast broadcast goal 
goal 
symbols par implication top bottom taken linear logic 
example implements multiplayer version mastermind 
coder current go coder coder calls player go coder try players result answer player coder current players 
coder sends player answer cows guess coder try victory answer player guessed secret code coder informs players decoder alp list decoder alp list decoder db alph 
creation players decoder go db alph try compute decoder db alph 
receiving message go player computes guess sends coder try waits answer decoder result db decoder db tried 
player stores answer guess result note purely computational procedures answer compute normally implemented ordinary programming language prolog variants natural choice 
initial query program coder players current decoder alp extends basic lo model modularity new form broadcast communication group multicast communication 
program set theories theory having structure theory theory name method 
communication broadcast group communication directed specific theories communications dest msg communications communications dest name theory receive msg 
methods general form conditions communications body conditions specify methods triggered communications specifies broadcast group communication body defines transition new configuration 
previous lo program written follows 
theory coder current decoder go try code players answer player decoder result current try code answer victory theory decoder list player alp list id db alph go id alph db compute coder try result db db tried victory program structured naturally theories furthermore employing group communication decoder refrains receiving guesses decoders 
previous query takes form coder code players current decoder alp denotes name theory 
messengers messengers coordination paradigm distributed systems particularly suited mobile computing 
messengers concept messengers autonomous messages 
messenger carrying just data case ordinary passive messages contains process program current status information program counter local variables 
node visited messenger resumes interpretation messenger program navigational command encountered causes leave current node 
distributed application viewed collection functions coordination managed group messengers navigating freely autonomously network 
addition navigational autonomy messengers supports inter intra object coordination 
case linda paradigms messengers supports concept structured global state space 
messengers explicitly partitions means navigational features supports 
example models manager worker scenario 
manager worker create hop ll task task null hop ll res compute task hop ll deposit res messenger script injected init node daemon 
creates logical nodes connected current node neighboring daemon 
causes replica messenger created node start executing 
messengers hops back original node traversed logical link obtained accessing system variable 
attempts get new task 
successful hops back logical node computes result carries back central node deposit 
activity repeated left case ceases exist 
primary role messenger functionality played hop statement defined follows hop ln ll represents logical node ll represents logical link represents link direction 
triple destination specification network address variable constant including special node init variable constant virtual link corresponding direct jump designated node denoting forward backward respectively playing role default value 
wild card applies obvious meanings 
example consider matrix multiplication 
distribute sched time abs mod copy block resid hop ll row new resid copy block rotate copy block resid sched time dlt synchronisation resid block multiply resid resid cij aij bij hol ll column rotate column code comprises messengers 
distribute implements movement array temporal coordination supported model distribute messengers schedules wake time corresponding position logical network 
rotate embodiment blocks matrix copies node resid private area enters loop keeps moving block responsible respective column 
temporal coordination fact messengers alternate respective executions 
time rotate wakes performs block multiplication block currently resident block adds resident block hops northern neighbor 
actor model computation set tools able express coordination patterns multi object language framework specifying enforcing constraints restrict invocation set objects 
constraints defined terms interface objects invoked internal representation 
constraints enforce access restrictions temporarily permanently 
constraints typically express certain properties fundamental concurrent object oriented languages temporal ordering atomicity method invocation 
expressed format independent syntax particular host languages underlying protocols enforce required object properties 
programmer specifies multi object constraints high level manner independent details involved explicit message passing 
furthermore implementation involve direct communication constrained objects indirect communication central coordinator process 
accessed directly message passing indirectly pattern matching 
code defines synchroniser enforces collective bound allocated resources 
adm adm max init prev prev max disables adm request adm request adm request adm request updates prev prev adm release adm release updates prev prev synchroniser local constraint prev max prevents means allocation resources system provides disabling invocation request method 
furthermore encountering invocation pattern local variable prev updated accordingly 
example shows coordination code philosophers encapsulated synchroniser 
atomic pick sender sender phil pick sender sender phil pick sender phil stops synchroniser parameterised chopsticks philosopher accesses chopsticks phil 
furthermore synchroniser applies pick messages sent phil 
assume existence eat method invokes concurrently pick needed chopsticks 
synchroniser enforces atomic access chopsticks phil successfully acquired chopsticks constraint terminated 
compositional programming concept compositionality important design principle task parallel programs shares goals coordination reusability sequential code generality heterogeneity portability seen coordination model 
compositional programming system properties program components preserved components composed parallel program components 
possible define compositional way recurring patterns parallel computation configuration ones mapping techniques communication ones mergers building blocks combine form bigger programs 
desired compositional assembly preserves deterministic behaviour constituent parts simplifying program development allowing program components constructed tested isolation rest environment 
basically approaches deriving compositional programs 
approach concurrent logic programming exemplified languages strand program composition notation pcn fortran compositional 
concurrent logic programming offers powerful computational model parallel computing years number techniques developed expressing useful coordination patterns 
case strand language express coordination aspects parallel program actual computation code written suitable language typically fortran 
code implements genetic sequence alignment algorithm 
align chunk sequences alignment pins chunks divide sequences alignment 
pins chunk cps chunk form pins best pin chunk 
cps seq sequences cps critical points seq cps cps sequences 
cps 
divide seqs pin alignment pin split seqs pin left right rest align chunk left random align chunk right random align chunk rest random combine alignment 
divide seqs alignment basic align seqs alignment 
program coordination communication component quite separate computational 
component expressed strand fact actual details taken care underlying concurrent logic model standard techniques shared single assignment variables dependent parallelism list composition appropriate guarded clauses 
second component procedures prefix written different mapping techniques explored notation case random specifies indicated procedure calls executed randomly selected processors 
strand concrete language needs dedicated wam implementation run program composition notation pcn set notations adhering concurrent logic paradigm pcn implemented extension host language 
program written pcn follows 
align chunk sequences alignment pins chunks divide sequences alignment pins chunk cps chunk form pins best pin chunk cps sequences sequences seq sequences cps critical points seq cps cps sequences sequences divide seqs pin alignment pin split seqs pin left right rest align chunk left node random align chunk right node random align chunk rest node random combine alignment pin basic align seqs alignment reader may recall logic programming expressing coordination laws law governed linda section 
logic programming interfaced coordination formalism tuple space 
concurrent logic programming coordination formalism 
second approach deriving compositional programs originates functional programming 
skeletons higher order functional forms built parallel behaviour 
away aspects program behaviour data partitioning placement communication 
skeletons naturally data parallel inherit desirable properties functional paradigm abstraction modularity transformation 
capability allows skeletons program transformed efficient time preserving properties original version 
analysis optimisation confined functional coordination level suitable purpose 
furthermore able reason correctness programs produced derived transformations 
skeletons configuration computational ones independent host computational language combined fortran configuration skeleton 
distribution align partition partition distribution takes function pairs specify required partitioning strategy respectively specify initial data rearrangement may required 
partition divides sequential array parallel array composed sequential subarrays 
align pairs corresponding subarrays distributed arrays form new configuration array tuples 
specialised partition dimensional array row block defined follows 
partition row block ii ii ii computational skeleton matrix addition performed parallel configuration skeleton defined follows gather map seq add distribution fl dl size size fl row block id row block id row block id dl note add defined computational language 
unique set skeletons number designed special purpose mind 
cola cola particularly suited distributed artificial intelligence applications implemented massive parallelism 
effectively set primitives quite independent host programming language introduce enforce number desired properties high level communication abstraction correspondents virtual communication topologies local view computation process 
particular associated process range vision defines set correspondents process locally communicate plus point view indicates specific communication topology process involved 
program models bi directional communication tree topology 
cola base topology class class define point view father const father node point view son const son node point view class implementation implementation point views son rule son 
father rule father son 
prolog clauses implementation procedure father self compute correspondence son self highest prio send tree topology enter loop read messages union exit build depiction send results upward father node procedure process sends information set processes computed relation son filter highest prio expects reply necessarily addressed processes 
sends computed results upwards father 
program uses predefined topology specification implementation 
setup procedure computes father children correspondents appropriate points view supplied parameters 
constructs message depiction destination processes sends message children selected filter highest prio 
receive answer program enters loop specifies topology ready process message forwards results father node 
note declarative prolog style implementing points view 
note predefined communication view primitives code 
opus opus effectively coordination top high performance fortran hpf designed purpose coordinating concurrent execution dataparallel components 
interaction concurrently executing tasks achieved shared abstraction sda linda common forum 
sda fact data type containing set data structures define state set methods manipulating state 
traditional adts act data servers concurrently executing tasks computation servers driven main controlling task 
respect opus combines data task parallelism 
execution opus program begins single coordinating task establishes participating computation data servers 
coordinating task drives computation invoking proper methods computation 
communication synchronisation concurrently executing tasks managed data 
code implements data server fifo bounded buffer 
sda type buffer type size integer size real private fifo size fifo buffer integer read count number full elements fifo integer private px producer index integer private cx consumer index 
contains subroutine put count lt size real intent fifo px put empty buffer element px mod px size count count subroutine get count gt 
real intent fifo cx get element full buffer cx mod cx size count count 
buffer type type created activated follows processors sda buffer type buffer buffer 
call buffer create processors call buffer create stat create status processors create statement generates sda buffer size allocates processor variable buffer playing role handle 
second create statement allocates bigger buffer size rest processors buffer handle 
opus fact languages data driven category separates quite clearly coordination component hpf computational component 
choose include model category control driven coordination languages sda mechanism employs quite shared dataspace 
control driven process oriented coordination models control driven process oriented coordination languages coordinated framework evolves means observing state changes processes possibly broadcast events 
contrary case data driven family coordinators directly handle examine data values processes coordination computational ones treated black boxes data handled process concern environment process 
processes communicate environment means clearly defined interfaces usually referred input output ports 
producer consumer relationships formed means setting stream channel connections output ports producers input ports consumers 
nature connections point point limited broadcasting functionality usually allowed forming relationships producer consumers vice versa 
certainly scheme contrasts shared dataspace approach usually advocated coordination languages previous family 
addition ports processes send environment control messages events purpose letting interested processes know state informing state changes 
diagram depicts concepts 
particular shows configuration involving producer input output ports consumers single input port single output port input ports output port 
stream connections established output ports producer input ports consumers stream entering input port leaving output port 
furthermore producer consumers raises observes presence events 
coordination languages described section realise way csp occam formalism 
differentiate exact functionality involved concepts 
instance languages events parametric types data values effectively mechanism interprocess communication languages events strictly simple units signifying state changes 
furthermore languages events broadcast means mechanisms different stream connections languages events travel streams 
stream connections realised number ways instance may may support synchronous communication 
cases streams interfaced common medium data bus point point connections ports case medium unrestricted broadcasting 
languages support dynamic creation ports exporting id processes limit functionality 
ability visualise evolution computation family coordination models metaphors similar ones shown irrelevant fact coordination languages graphical programming environments exist 
pcl proteus configuration language pcl language designed model architectures multiple versions computer systems 
furthermore model static dynamic configurations 
coordination pcl understood configuration unit configuration family entity representing versions logical component system 
family entity may related family entities inheritance composition relationship participation 
family entity various kinds associated information composition structure classification specifying type list attributes parts section specifying composition entity terms entities number version descriptors 
configuration paradigm application operating set components 
component encapsulates state may provide require services components 
exist single composite components merely providing abstraction mechanisms run time system unfolds comprising simple components realised processes 
simple components may classified active provide services components able execute absence external stimuli passive acting external stimulus requests service 
major element configuration paradigm ports represent provided required service 
component may number required provided ports 
inter component communication facilitated indirectly transmitting messages bindings binding connect ports 
communication synchronous asynchronous 
example models scenario involving log component controller component sensor components 
log provides services add service allowing sensor component register value readings service allowing controller component read sensor readings registered 
code log shown 
family log inherits component class type active attributes true interface provides add readings structure add sensor readings controller behaviour log defined active component periodically writes data disk component may substituted 
furthermore log supports persistent state sense dynamic reconfiguration persistent information survive 
mentioned framework inherently supports clear distinction configuration component pcl configured computational components written conventional programming language 
furthermore components context independent inter component interaction communication achieved means indirect interfaces comprising ports connected means bindings 
separation achieved functional description individual component behaviours global view formed system set processes interconnections 
addition port connections effectively unlimited buffers 
component replacement take place outstanding messages delivered component retained run time system eventually forwarded component replacement 
note pcl object oriented polymorphic 
inheritance exploited build hierarchies family entities example instance log inherits basic functionality component 
addition easy create reusable descriptions configuration scenarios 
conic conic language coordination viewed configuration 
fact conic languages programming language variant pascal enhanced message passing primitives plus configuration language similar nature pcl featuring logical nodes configured means links established input output ports 
logical node system configuration unit comprising sets tasks execute concurrently shared address space 
configured systems constructed sets interconnected logical nodes sets referred groups 
programming subcomponent conic notion task module types self contained sequential tasks run time conic system generate respective module instances exchange messages perform various activities 
modules interface defined terms strongly typed ports 
denotes interface message transactions initiated provide local name type holder place source name type 
denotes interface message transactions received provides local name place source name type 
link realised means invoking message passing facilities programming subcomponent 
system supports unidirectional asynchronous bi directional synchronous communication 
local objects direct naming modules communication entities 
programming module oblivious environment renders highly reusable simplifies reconfiguration clearly separates activities related purely programming concerns 
example illustrates syntax configuration subcomponent conic part typical regarding configuration languages example describing patient monitoring system comprising nurses patients 
group module patient alarm bed reply code 
group module nurse alarm bed reply code 
module models monitoring device patient 
device periodically reads sensors attached patient 
readings detected outside established ranges suitable alarm messages sent 
request message received returns current readings 
second module displays alarms received request display readings associated patient 
note nurse may monitoring patient arrays ports 
configuration code creates instances modules specified machine locations system establishes required communication links 
system ward create bed patient machine nurse nurse machine link bed alarm nurse alarm nurse bed bed bed 
conic supports limited form dynamic reconfiguration 
set task group types logical node type constructed fixed node compile time 
furthermore number task group instances node fixed time node created 
dynamic changes link set ups achieved unlink command 
example shows system evolve run time nurse module instance changes behaviour starts monitoring readings patient scenario sense nurse monitors maximum number patients handle 
manage ward create bed patient machine unlink bed alarm nurse alarm nurse bed bed bed link bed alarm nurse alarm nurse bed bed bed 
limitation dynamic reconfiguration functionality conic related nature links established 
particular links viewed unbounded buffer areas 
link severed pair set ports module instances involved communication stopped exchanging messages information may lost inconsistent states may result 
conic developers designed system reconfiguration model links may severed nodes enjoy quiescence property 
point node quiescent currently involved transaction initiated ii initiate new transactions iii currently engaged servicing transaction iv transactions initiated nodes require service node 
underestimate fact conic user constrained single programming language pascal conic programming subcomponent 
darwin regis regis system associated configuration language darwin effectively evolution mentioned conic model 
darwin generalises conic largely independent language program processes regis system uses specific language 
furthermore darwin realises stronger notion dynamic reconfiguration supports lazy component instantiation direct dynamic component instantiation contrast conic supports static configuration patterns changed run time explicitly invoking configuration manager 
furthermore allows components interact user defined communication primitives conic offers predefined set primitives 
clear separation communication computation conic computation code intermixed communication code 
conic darwin configuration comprises set components clearly defined interfaces realised ports queues typed messages 
ports types process receive data effectively input ports understood provided environment process benefit processes post messages send data effectively output ports understood requiring port remote port order post involved data 
fact ports darwin regis viewed general concept services provided required combined port allows realisation liberal notions port connections 
addition provided required ports included process definition processes may run time realise various communication configuration patterns exchanging port send receive messages 
example calculates distributed fashion number 
consists groups processes set worker processes dividing computational done supervisor process combines results top level coordinator process sets apparatus 
show configuration component example written darwin 
component supervisor int provide result port double require labour component int int int component worker int id int nw int intervals require result port double component int nw inst supervisor nw bind worker result result labour dyn worker supervisor process responsible dynamically spawning new worker processes 
note require part supervisor specifies required type service component merely port 
coordinator process generates instance supervisor furthermore dynamically generates instances labour means dyn primitive case creates instances worker invoked sets port connections accordingly 
criteria dictate precisely new worker processes spawned actual computation code form regis computation subcomponent shown 
worker worker int id int nw int intervals double area double width intervals int id intervals nw double width area width result send area exit supervisor supervisor int nw const int intervals double area int nw labour labour inst nw intervals int nw double tmp result tmp area tmp printf approx pi lf area note communication primitives send post retrieve respectively message port 
furthermore note expression labour inst nw intervals invokes new worker process primitive previous command line specify processor new process run 
architecture configuration language 
application consists set configurations specifying components interrelated 
components consist application tasks feature input output ports communication channels 
run time tasks create processes channels create links composite process configurations achieved links connect input output ports different processes 
main concern coordinate resources load execute programs different locations supporting heterogeneous processing route data reconfigure application members family coordination languages clear distinction application structure behaviour 
tasks implement functionality application channels implement communication facilities 
possible support different kinds communication furthermore reusability components enhanced 
example shows realise producer consumer scenario 
particular presents definitions producer task consumer task fifo channel 
task producer task consumer ports ports output input attributes attributes processor sun processor sun procedure name producer procedure name consumer library usr library usr producer channel fifo msg type identifier buffer size integer ports input type output type attributes processor sun bound buffer size package name fifo channel library usr channels fifo piece code defines producer task output port type message 
furthermore code specifies task instances producer run indicated machine task implementation code procedure producer directory usr 
similar things said task consumer channel fifo description generically specifies parameters types messages ports receive relevant information size channel 
actual implementation tasks channel shown written conventional programming language 
code uses defined entities generate compound task description featuring dynamic reconfiguration 
task dynamic producer consumer components buffer channel fifo message structures baseline buffer buffer output input baseline buffer buffer output input reconfigurations enter signal clusters cl buffer cl dynamic producer consumer scenario involves producer consumers fifo channel buffer size 
different configuration scenarios possible involving producer consumer channel similar nature second consumer 
case producer sends data output port input port second consumer channel 
initially configuration active transition done particular signal raised consumer 
tailored support rapid prototyping distributed heterogeneous applications test different configuration strategies means implement applications 
task emulator supports number useful features including timing constraints rendering language suitable real time applications implementation centralised 
furthermore principle implementation language system tailored ada 
unrestricted dynamic creation task instances possible instance code restricts involved entities run time producer consumers channel 
csdl csdl cooperative systems design language specification design language supports definition coordination aspects definition logical architecture cooperative system 
csdl configuration comprises users applications coordinators define cooperation policies control data flowing users shared applications 
coordinator composed parts specification defines groups cooperation policies terms requests exported selectively members different groups body defines access rights associated groups terms communication system control context defines coordinator dependencies terms groups mapping 
csdl code defines specification body windows coordinator 
coordinator group group output group input output invariant input requests extern join output actions insert insert output join input requires output input actions insert input leave output actions extract output extract leave input actions extract input coordinator body switcher inout group connected group output group input specification includes declaration group identifiers may involve definition type nesting 
includes invariant stating constraints group cardinality membership logical expressions set requests join leave exported selectively members groups desired policy 
instance extern refers sender belonging group coordinator 
exchange information components done means virtual switches defined body coordinator model multiplexing demultiplexing data streams 
declaration switches accompanied kinds modes access example members group connected send receive data input output channels disabled 
polylith polylith software interconnection system effectively mil enhanced functionality input output ports events usually coordination languages 
polylith clearly separates functional requirements interfacing requirements enhancing decoupling reuse software components 
component treated module modules interfaces communication channel running instances module processes send receive messages 
decoupling agent called software bus means process communication message passing routines provided system allows processes get plugged bus 
program code module written separately rest code describing interfaces rest system fact language supports mixed language approach 
furthermore software bus encapsulates separately interfacing decisions involved modules 
possible set modules different buses say distributed systems tcp ip paradigm tailored shared memory code shows outline implementation specification modules 
main argc argv main argc argv exec exec char str char str 
mh write msg mh read str 
mh read str mh write msg 
service orchestrate example implementation binary tool foo source string tool bar sink string tool bind foo bar bind bar service bind foo implementation binary source string sink string implementation part read write modules sends output channel messages msg msg respectively receives message type string input channel local variable msg 
specification part services defined type respectively furthermore specified outgoing interface 
application definition example effectively coordinator process creates specific scenario involving instance instances properly connects respective input output channels 
model enhanced events allowing event interaction modules register interest observing raising event point invoke procedure associated event 
furthermore event coordinators match events functionality different names number modules realising composite interaction 
code illustrates points 
module module declare sig integer string declare sig integer generate sig generate sig sig proc sig proc main main char event type event char event type event initialisation tt initialisation init argc argv null null init argc argv null null events declaration events declaration sig sig register interest register interest sig sig true true get event get event event type event event type event invoke proc invoke proc strcmp sig event type strcmp sig event type proc event proc event module declares event registers interest observing raising event 
detecting presence specified event module calls procedure 
part code specifies intended interaction second part presents outline implementation note events parameterised data fact substitute input output channels previous version polylith 
programmer playground programmer playground shares aims languages conic darwin software library run time system supporting dynamic reconfiguration distributed components 
furthermore model supports uniform treatment discrete continuous data types case models family clear separation communication computation concerns 
programmer playground notion abstraction 
abstraction model interprocess communication module system presentation consists data structures may externally observed manipulated 
application consists collection independent modules configuration logical connections data structures module presentations 
published data structures updated communication occurs implicitly logical connections 
abstraction uses declarative communication opposed imperative communication sense user declares high level logical connections state components modules expressing direct communication control flow program 
declarative communication enhances separation communication computation error prone facilitates automatic updating modules states cases changes state module reflected module 
functionality achieved means connections item module connected item module change value cause appropriate update value connections simple point point element aggregate furthermore unidirectional bi directional 
producer consumer apparatus illustrates points 
include pg hh mess send mess static int strcmp mess ok main producer int read world mess ok write world mess send include pg hh mess void consume int consumes list integers main consumer mess ok read world int write world consume int mess ok program consists modules forming producer consumer pair communicating synchronously exchange infinite list integers 
modules integer variable send receive integers string variable consumer declare ready receive integer 
variables published modules external name protection flag read write 
procedure suspend execution module variable indicated argument updated 
logical connection variables respective modules assumed established programmer playground achieved graphically modules shown boxes published variables input output ports logical connections lines drawn respective ports 
programmer playground language formalism implemented sun solaris 
claims clearly separate communication computation concerns different types code intermixed module 
model developed primarily developing distributed multimedia applications fact places emphasis supporting uniform treatment discrete continuous data differences communication requirements handled implicitly run time system 
nature data handled importance coordination models comprising category programmer playground included data driven category 
chose place defined input output connections process possesses sharing application domains configuration languages 
rapide rapide architecture definition language respect shares aims languages conic 
supports component communication abstractions separation formalisms 
architecture rapide executable specification class systems 
consists interfaces connections 
interfaces specify behaviour components system connections define communication components features specified components interfaces constraints restrict behaviour interfaces connections 
rapide event driven components generate independently observe events 
events parameterised data types 
asynchronous communication modelled connections react events generated components generate events components 
synchronous communication modelled connections function calls 
result executing rapide architecture set interfaces connections poset showing dependencies independencies events 
producer consumer example illustrates points 
type producer max positive interface action send integer action reply integer behavior start send integer reply max send producer type consumer interface action receive integer action ack integer behavior integer receive ack consumer architecture return prod producer cons consumer connect integer prod send cons receive cons ack prod reply architecture code initially declares types components 
producer designed accept events type reply broadcast events type send parameterised integer value 
commencing execution producer broadcasts receiving reply event send provided certain value 
consumer similar functionality 
coordinator creates process instances producer consumer furthermore associates output event input event vice versa 
note code specifies components interact actual details implementation left unspecified 
typical member family control driven coordination languages 
program dynamic collection computation processes coordination processes 
computation process executes sequential algorithm written conventional programming language augmented communication primitives 
coordination processes written ccl coordination language 
communication processes done usual way sending data output ports receiving data input ports effectively achieving complete decoupling producers consumers 
processes raise broadcast state fact event signal parameterised data 
states communicated message passing 
example shows dynamically evolving pipeline generic processes 
coordinator node data gen dyn pipeline data data states error done create node bind left loop choose sel node new right create node new bind right new left new sel node new right error gen dyn pipeline coordinator parameterised types computation processes forming pipeline node data communicated data 
pipeline nodes communicates outside world means ports dyn pipeline process get data processes output data 
initially process created ports left bound gen dyn pipeline sin respectively 
time process pipeline raises state new new process created inserted pipeline 
process raising state new pipeline determined means examining port right linked port particular configuration port left process 
case creating new process gen dyn pipeline raises state error 
language features nested hierarchies coordination domains synchronous asynchronous communication components 
particular computational process raising state blocks treated coordinator process charge communication appears synchronous process point view asynchronous point view coordinator process 
coordinator processes groups coordinated processes configured hierarchical manner top level configuration coordinator 
furthermore language enforces encourages building structured programs treating pair coordinator coordinated processes separate domain 
coordinator domain unaware nested subdomains treats homogeneously computational coordination processes 
furthermore state change notification process visible domain supervisor coordinator process 
coordination architecture reminiscent models polylith featuring component interconnection metaphor tools plugged 
consists number processes manage tools forming system 
number tools comprising system static number processes changes dynamically intended functionality system 
addition straightforward correspondence tools processes possible tool controlled number processes groups tools controlled process 
tools communicate implicitly direct tool tool communication allowed 
number primitives offered system realising synchronous asynchronous communication processes processes tools 
architecture recognises common format interchanged data tool adapter changes data formats accordingly 
furthermore intended behaviour system specified means scripts contain number definitions processes tools followed configuration statement 
example shows compiler editor cooperation modelled 
define compiler rec msg compile name snd eval compiler name 
rec value compiler error err loc loc snd note compile error name error err loc loc rec value compiler name res snd msg compile name res delta define editor subscribe compile error 
rec note compile error name error err loc loc snd editor store error name error err loc loc rec event editor error name snd editor visit name snd ack event editor delta define ui rec event ui button compile name snd msg compile name rec msg compile name res snd ack event ui delta compiler receives compilation request ui starts compilation broadcasts errors encounters sends result back process invoked 
editor receives message compilation error stores compiled program error location receives error event editor goes previously stored error location 
ui user interface compile button pushed causes compile message sent waits reply 
primitives program snd msg process synchronously send message process receive msg snd note process asynchronously broadcast messages processes receive invoking rec note process declare interest receiving certain asynchronous broadcasts processes 
furthermore rec event rec value process receive respectively event evaluation result tool snd process request evaluation term tool 
selection sequential operators respectively delta signifies process termination 
definitions number configurations possible set compiler editor ui compiler ui case simpler system configured ability refer back error locations 
enjoys formal semantics scripts formally analysed terms process algebras extended notion discrete time 
prototype interpreter implementation exists test model effectiveness number applications 
manifold manifold latest developments evolution control driven coordination languages 
case members family man coordinators clearly distinguished computational processes written conventional programming language augmented communication primitives 
manifolds manifold coordinators called communicate means input output ports connected means streams 
evolution manifold coordination topology eventdriven state transitions 
point manifold coordinator process moment time certain state typically set network coordinated processes communicating sending receiving data stream connections established respective input output ports 
observing raising event process question breaks stream connections evolves predefined state different network coordinated processes set 
note case coordination languages featuring events manifold events parameterised carry data purely triggering state changes causing evolution coordinated apparatus 
example bucket sorter written manifold 
export manifold sorter event filled flushed finished 
process filled 
stream reconnect kb input 
priority filled finished 
activate input guard input empty finished 
finished ignore filled 
output 
filled process merge output 
stream kk merge merge 
stream kk merge output 
activate merge input sorter merge merge merge output 
finished 
guard output disconnected flushed terminated void 
flushed halt 
apparatus created program functions follows sorter initially activates computation process performing actual sorting 
process capable performing fast sorting bucket numbers size raise event filled receives maximum number numbers sort 
detecting raising filled sorter activate new sorting computation process merger process responsible merging output sorting processes stream 
depending bucket size number units sorted arbitrary number sorting merger processes may created linked run time 
note process default input output port additionally may named ports 
triggering process fact responsible passing units sorted sorter printing output shown 
manifold main auto process read readfile unsorted 
auto process sort sorter 
auto process print 
read sort print 
concepts manifold control oriented coordination languages manifold generalises linguistic constructs defined semantics extends 
instance concept port class linguistic construct representing hole distinct sides powerful abstraction anonymous communication normally process owns port access private side third party coordinator process knows establish communication process connecting stream public side arbitrary connections departure sides arrival sides arbitrary ports multiple incoming multiple outgoing connections possible defined semantics 
fact computation coordinator processes absolutely indistinguishable point view processes means coordinator processes recursively manage communication coordinator processes just computation processes 
means coordinator higher level meta coordinator build sophisticated hierarchy coordination protocols 
higher level coordinators possible coordination languages models 
manifold advocates liberal view dynamic reconfiguration system consistency 
consistency manifold involves integrity topology communication links processes application independent states processes 
languages conic limit dynamic reconfiguration capability system allowing evolution take place processes involved reached sort safe state quiescence 
manifold impose constraints means plethora suitable primitives provides programmers tools establish safety criteria avoid reaching logically inconsistent states 
example program stream connected input port declared type kb keep break meaning disconnected arrival side part connected sorter remain connected departure side part connected process sends data stream case read 
read break connection filled sorter forward rest data sorted new sorting process data stream lost 
furthermore guards installed input output ports sorter sure units sorted received sorter got printed successfully 
primitives guards inherently encourage programmers express criteria terms externally observable input output behavior computation coordination processes 
contrast extensive repertoire coordination constructs manifold support ordinary computational entities data structures variables conditional loop statements syntactically sugared versions exist programmer convenience 
shown manifolds parameterised highly reusable generic manifolds called manners 
manifold successfully ported number platforms including ibm sp sp solaris sgi linux 
furthermore conventional programming languages including fortran 
extended real time capabilities 
underlying coordination model iwim fact independent actual language shown applicable coordination models frameworks 

comparison previous section described detail important members major families coordination models languages data driven control driven ones 
section tabular form comparison formalisms major dimensions characterise coordination formalism 
dimensions entities coordinated ii mechanism coordination iii coordination medium architecture iv semantics rules protocols coordination employed model supports different computational component coordination language involves add primitives vi model supports encourages computational languages vii relevant application domain model viii implementation status proposed framework 
means issues differentiate model 
instance regarding category control driven coordination models issue worth comparing exact nature port port connections streams model employs case dynamic reconfigurations realised 
example models support static configurations restrict access port owners models support dynamic re configurations exporting port identifiers 
lowlevel comparison useful felt run danger obscuring main differences models involved main categories 
case outlined differences nature respective sections model 
implementation status different robust implementations unix prototype pvm linda kernel needs support enforce laws pvm prototype prototype isis toolkit application domain data parallel programs groupware data batch parallel programs open secured distributed systems modelling open distributed systems modelling information systems prototype collaborative environments range comp languages wide range comput 
models wide range comput 
models wide range comput 
models models object oriented languages potentially wide potentially wide office automation prototype connection machine ipsc shared memory prototype sun implementation object oriented systems scientific computing data parallel programs potentially wide logic programming oriented potentially wide potentially oop languages message passing languages potentially wide coordination entities mechanism medium semantics rules degree language coordinated coordination coordination protocols decoupling linda active tuples tuple shared tuple space associative coordination pattern matching primitives bauhaus active tuples multisets hierarchies set inclusion coordination linda tuple spaces primitives bonita processes single group multiple associative coordination tuple handling tuple spaces pattern matching primitives law governed processes supervised tuples enhanced logically structured laws defining accept coordination rules linda law control info tuple space able tuple access written prolog objective objects adts multiset hierarchies type interfaces coordination linda object refs object spaces primitives laura servers exchange shared service typed interface de separate service clients typed forms space scription services description notation ariadne hopla hybrid matching semi tree shaped flexible separate coordination processes structured data tuple space records component sonia actors people possibly nested agora typed template coordination tools tuples shared tuple space associative matching primitives gamma distributed data chemical reactions possibly structured cham parametric coord 
structures fixpoint op multiset bag patterns tropes lo agents linear interagent broadcast multiset linear logic rule coord 
multiset objects group broadcast forum component messengers mobile processes autonomously explicitly partitioned intra inter object coordination executable messages distributed shared mem invocation primitives cola sequential correspondents hierarchically formed processes points ranges view message passing jada shade mobile agents exchange java internet multiple java html primitives coupled applets tuple space java code objects constraints message passing actor model constraints specified accessing objects separately pcn strand concurrent committed choice shared declarative concurrent logic separate coordination processes rule selection variables programming component functional skeletons sequential function application distributed string graph separate skeleton functions composition graph structure reduction templates separate coordination component prototype www intranet open systems modelling architectures parallel symbolic computing dai mobile computing java known distributed platforms various families skeletons pvm implementation distributed potentially wide application implementation domain status scientific prototype top computing modelling prototype system architectures configuring unix vms distributed systems graphical interface configuring unix distributed programs implementation rapid prototyping prototype distributed programs cooperative systems prototype range comp languages potentially wide fortran oriented semantics rules protocols data parallelism potentially wide pascal oriented dynamic configuration state transitions quiescence dynamically evolving state transitions event driven state transitions cscw metaphors medium coordination shared abstraction hierarchies tool family entities hierarchies logical nodes dynamically evolving component graphs statically defined component graphs separate fully fledged coord component potentially wide potentially wide transparent distributed tation systems implementation distributed multi distributed media systems implementation prototyping system prototype architectures distributed concurrent prototype top process oriented regis system integration prototype potentially wide potentially wide potentially wide degree decoupling separate coordination component separate coordination component pcl semi separate coord component separate fully fledged coord component separate fully fledged coord component separate fully fledged coord component mil specification syntax data exchange primitives separate coord component separate coordination language ccl separate coordination component metaphors software bus abstraction applicable poset model discrete continuous data streams connections defined hierarchical config 
event state domains coordination entities mechanism language coordinated coordination opus sequential method tasks invocation pcl tools forming exchanging services family entities ports conic system exchanging data components ports darwin regis sequential exchanging data processes ports components events channel resources connections csdl tools coordinators specifying access rights polylith software event components triggering programmer devices implicit playground communication rapide system components observing reacting events sequential processes satisfying conditions domain states group connections fully implemented platforms scientific computing architectures potentially wide separate coordination lang manifold pairs condition action process oriented scripts event driven state transitions software exchange software bus components ges notes manifold sequential processes events streams configuration process networks 
purpose report provide comprehensive survey models languages forming family coordination formalisms 
classified members coordination family broad categories data driven control driven ones 
furthermore described depth prominent members family highlighting features presenting typical examples 
members family evolved notion shared dataspace plays dual role global data repository interprocess communication medium 
processes forming computation post retrieve data medium 
prominent member family historically genuine coordination model linda common medium tuple space processes send retrieve tuples 
linda extensively years number similar models evolved main purpose address deficiencies weaknesses inefficiencies basic vanilla model issues security locality hierarchy global data optimisation tuple access 
number shared dataspace coordination models proposed emphasis providing implicit linda associative pattern matching semantics tuple handling multiset rewriting 
members family adhering shared dataspace concept message passing metaphor limited form shared dataspace form common buffer areas global synchronisation variables manipulated concurrently number processes 
family influenced concept shared medium second family evolved occam notion distinct entities communicating outside world means clearly marked interfaces input output ports connected appropriate fashion means streams channels 
fact coordination paradigm offered second family characterised channel opposed medium notion coordination supported family 
traditionally languages family initially proposed configuring systems modelling software architectures 
number proposals put forward control driven languages designed conventional coordination application areas mind 
members family share concept separate coordination language opposed case data driven models set coordination primitives conjunction host language define pure coordination modules featuring ports streams channels possibly event broadcasting 
differentiate issues id ports public communication asynchronous synchronous events carry values 
interesting quite fruitful confrontation data control driven coordination approaches respect extent program need structured locality communication supported 
shared dataspace vanilla models linda gamma encourage flat unstructured communication medium employing global broadcasting 
variants bauhaus linda structured gamma provide hierarchical levels communication medium able express locality communication support structure 
hand control driven coordination languages manifold support multiple port port stream connections employ limited forms broadcasting 
furthermore streams class citizens able hold data stream connections break get reconnected different coordinated processes providing certain extent functionality shared communication medium 
authors belief number novel coordination models languages proposed converge approaches formation communication media provide desired ideal 
degree shared point point communication support naturally structuring programs 
issue coordination broad article concentrated programming languages aspect furthermore advocated practical flavour 
aspects coordination related say workflow management cooperative software composition name addressed 
dwell theoretical issues semantics formal specification reasoning 
coordination models languages evolved rapidly past years concept coordination introduced aspects contemporary computer science including middleware domains web corba platforms modelling activities information systems coordination large application areas software engineering open distributed systems 
expect proliferation models languages years come addressing issues possibly offering unified solutions number different application domains 
acknowledgments number people provided useful feedback improving presentation survey contents 
special due anne alexandra jensen andrea omicini detailed comments earlier drafts chapter 
partially supported dc kit keep touch program developing software engineering environments distributed information systems financed commission european union 

agha actors model concurrent computation distributed systems mit press 

ahuja carriero gelernter linda friends ieee computer pp 



andreoli gallaire pareschi rule object coordination pp 



andreoli hankin le tayer coordination programming mechanisms models semantics world scientific 


andreoli pareschi linear objects logical processes built inheritance new generation computing pp 


arbab iwim model coordination activities pp 


arbab blom burger reusable coordinator modules massively concurrent applications europar lyon france aug lncs springer verlag pp 


arbab herman spilling overview manifold implementation concurrency practice experience pp 



ban tre le tayer gamma chemical reaction model years pp 


sonia adaptation linda coordination activities organizations pp 


barbacci weinstock doubleday gardner structure description language developing distributed applications software engineering journal ieee march pp 


barbacci wing language distributed applications international conference computer languages iccl new orleans lui usa march ieee press pp 


bergstra klint coordination architecture pp 


imperative language algorithmic skeletons efficient distributed programming fifth ieee international symposium high performance distributed computing hpdc new york usa aug ieee press pp 



andreoli concurrency communication choices implementing coordination language lo object distributed programming ecoop workshop kaiserslautern germany july lncs springer verlag pp 


arbab visual environment coordination language pp 


brogi ciancarini concurrent language shared prolog acm transactions programming languages systems pp 


burkhart frank skeleton programming language pp 


chapman haines mehrotra zima opus coordination language multidisciplinary applications scientific programming 

carriero gelernter linda context communications acm pp 


carriero gelernter coordination languages significance communications acm pp 


carriero gelernter zuck bauhaus linda pp 


castellani ciancarini enhancing coordination modularity mechanisms language objects multisets pp 


castellani ciancarini rossi shape shade coordination system technical report ublcs dipartimento di scienze dell informazione universit di bologna italy march 

chandy misra parallel program design foundation addison wesley 

chen configuration level programming distributed applications implicit invocation ieee singapore aug ieee press pp 


ciancarini coordination models languages architectures applications personal perspective university leuven feb www cs unibo coord toc html 

ciancarini hankin eds international conference coordination models languages applications coordination italy april lncs springer verlag 

ciancarini nierstrasz yonezawa eds object models languages concurrent systems bologna italy july lncs springer verlag 

ciancarini rossi jada coordination communication java agents second international workshop mobile object systems programmable internet mos linz austria july lncs springer verlag pp 


ciancarini tolksdorf weaving web coordination pp 


cole algorithmic skeletons structured management parallel computation pitman mit press 

di orlando methodology development support massively parallel programs programming languages parallel processing ieee press pp 


darlington guo yang functional skeletons parallel coordination europar stockholm sweden aug lncs springer verlag pp 


feng gao yuen distributed linda tuplespace algorithms implementations parallel processing vi linz austria sept lncs springer verlag pp 


ariadne hopla flexible coordination collaborative processes pp 


foster compositional parallel programming languages acm transactions programming languages systems pp 


fr lund agha language framework multi object coordination pp 


fr lund agha abstracting interactions message sets seventh european conference object oriented programming ecoop kaiserslautern germany july lncs springer verlag pp 


fukuda bic merchant intra inter object coordination messengers pp 


gelernter kaminsky supercomputing recycled garbage preliminary experience piranha sixth acm international conference supercomputing washington usa july acm press pp 


goldman swaminathan anderson sethuraman programmer playground abstractions user configurable distributed applications ieee transactions software engineering pp 


software environment concurrent coordinated programming pp 


aguilar krone cola coordination language massive parallelism acm symposium principles distributed computing podc los angeles ca usa aug 

designing coordination model open systems pp 


klein challenges directions coordination science second international conference design cooperative systems juan les pins france june pp 


kramer magee finkelstein constructive approach design distributed systems tenth international conference distributed computing systems icdcs paris france may june ieee press pp 


magee dulay kramer structured parallel distributed programs software engineering journal ieee march pp 


malone crowston interdisciplinary study coordination acm computing surveys pp 


agora groupware metaphors oo concurrent programming 

minsky law governed linda coordination model pp 


language features interconnection software components advances computers pp 


nii blackboard systems handbook artificial intelligence addison wesley pp 


papadopoulos arbab coordination systems real time properties manifold twentieth annual international computer software applications conference compsac seoul korea aug ieee press 
pp 


papadopoulos arbab control coordination human activities cooperative information systems second international conference coordination models languages applications coordination berlin germany sept lncs springer verlag pp 


papadopoulos arbab control driven coordination programming shared dataspace fourth international conference parallel computing technologies pact russia sept lncs springer verlag pp 


papathomas 
blair coulson model active object coordination distributed multimedia applications pp 


development collaborative application csdl thirteenth international conference distributed computing systems may pittsburgh usa ieee press pp 


cooperative systems configuration csdl fourteenth international conference distributed computing systems june poznan poland ieee press pp 


polylith software bus acm transactions programming languages systems pp 


rem program notation tuples variables acm transactions programming languages systems pp 


ren agha language support real time specifications distributed systems acm sigplan workshop languages compilers tools real time systems la jolla california june pp 


rice formal model module interconnection languages ieee transactions software engineering pp 



roman cunningham mixed programming metaphors shared dataspace model concurrency ieee transactions software engineering pp 


rowstron wood bonita set tuple space primitives distributed coordination th hawaii international conference systems sciences hicss maui hawaii jan ieee press vol 
pp 


shaw deline klein ross young abstractions software architecture tools support ieee transactions software engineering pp 


skillicorn higher level abstraction parallel programming programming models massively parallel computers berlin germany oct ieee press pp 


sommerville dean pcl language modelling evolving system architectures software engineering journal ieee march pp 


tolksdorf coordinating services open distributed systems laura pp 


weaver linguistic support heterogeneous parallel processing survey approach third heterogeneous computing workshop mexico apr pp 


wegner coordination constrained interaction pp 


wilson ed linda systems implementation edinburgh parallel computing centre tr 

zave compositional approach multiparadigm programming ieee software sept pp 


