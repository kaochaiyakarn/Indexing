theoretical basis communication centred concurrent programming marco kohei honda nobuko yoshida robin milner gary brown steve ross talbot queen mary university london uk imperial college london uk university cambridge uk pi technologies 
document presents different paradigms description communication behaviour focussing global message flows point behaviours formal calculi session types 
global calculus originates choreography description language web service description language developed ws cdl working group 
point calculus typed calculus 
global calculus describes interaction scenario vantage viewpoint endpoint calculus precisely identifies local behaviour participant 
introducing static dynamic semantics calculi explore theory endpoint projection defines principles structured global description 
theory defines translation principles sound complete sense behaviours specified global description realised communications point processes 
theory underlying type structures play fundamental role 
document divided parts part introduces descriptive frameworks simple non trivial examples second part establishes theory global point formalisms 
iii contents 
iii part 
introductory examples 
part 
describing communication behaviour 
describing communication behaviour 
describing communication behaviour 
correspondence cdl part 
formal theory structured global programming 
part 
informal preview 
global calculus syntax 
global calculus reduction 
global calculus typing 
point calculus syntax reduction 
point calculus typing 
theory point projection connectedness 
theory point projection threadedness 
theory point projection coherence 
main results epp theorem consequences 
extension applications 
related bibliography appendix appendix subject reduction global calculus type system appendix subject reduction point calculus type system appendix alternative inference algorithm threadedness part introductory examples 
part introduces different ways describing communication centred software form formal calculi discusses relationship 
different frameworks description centring global message flows centring local point behaviours share common feature structured representation communications 
global calculus originates choreography description language cdl web service description language developed ws cdl working group 
local calculus calculus representative calculi communicating processes 
show formed description technical sense shall clear global calculus precise representation local calculus 
calculi common notion structured communication called session 
session binds series communications parties distinguishing communications belonging sessions 
standard practice business protocols instance protocol distinguished instance protocols distributed programming interacting parties multiple tcp connections performing unit conversation 
shall explore notion session cleanly integrated notions branching recursion loop exceptions 
show examples taken simple non trivial business protocols concise structured description non trivial interactive behaviour possible sessions 
practical viewpoint session gives merits 
offers clean way describe complex sequence communications rigorous operational semantics allowing structured description interactive behaviour 
session programs simple algorithmically efficient typing algorithm check conformance expected interaction structures 
sessions offer high level abstraction communication behaviour refined reasoning techniques including type transition logic ones built 
presentation focusses point gives formal basis second point 
full discussion second point exploration third point left version 
engineering background explosive growth internet world wide web rise shape de facto standards omnipresent naming scheme uri url omnipresent communication protocols tcp ip omnipresent data format xml 
elements arguably offer key infra structural bases applicationlevel distributed programming 
engineering background feasible advantageous develop applications engaged complex sequences interactions parties 
background maturing theories processes centring calculus types 
calculus theories types singular enable study diverse ways structuring communication allow fruitful surprising connections existing formalisms including process algebras csp ccs functional computation calculus logics linear logic objects java 
believe combination strong practical needs interactional computation rich theoretical foundations lead rich dialogues practice theories 
intended offer technical elements may useful dialogue 
consists parts 
part give sections including informally introduce paradigms describing interactions incrementally complex examples 
examples come cases cdl cdl primer steve ross talbot tony fletcher examples communicated gary brown 
second part form remaining sections introduce formal semantics type discipline formal connection core parts formalisms 
structure 
rest sections devoted informal illustration key technical elements description small non trivial cases global local calculi 
description starts simple example reaches fairly complex illustrating essence construct relationship respective global descriptions corresponding local ones 
section comments correspondence differences formal calculi cdl 
second part section section formally introduces calculi global calculus sections endpoint calculus sections develops theory point projections calculi sections concludes related works topics section 
appendix offers technical details 
choice buyer shipper seller quotereject deliverydetails deliverydetails 
graphical representation simple protocol 
describing communication behaviour 
simple business protocol 
section show small increasingly complex business protocols accurately concisely described small programming languages global message flows local point behaviours 
way illustrate construct mini programming languages formal semantics discussed second part 
starting point simple business protocol purchasing buyer seller shipper call simple bsh protocol 
informally expected interaction described follows 
buyer asks seller specified channel offer quote assume buy fixed 
seller replies quote 
buyer answers 
answer seller sends confirmation buyer sends channel buyer shipper 
shipper sends delivery details buyer protocol terminates 
answer interaction terminates 
presents uml sequence diagram protocol 
observe details left unspecified real interaction need specify example types messages information exchanged interaction protocol include practically important elements conditional loops simplicity serves starting point introducing formalisms 

assumption underlying communication mechanisms 
outline basic assumptions common global local formalisms 
henceforth call personae protocol buyer seller shipper case participants 
assume participant communicates channels change content variables local participants may local variables name considered distinct 
communication sender participant sends message receiver receives consider point point communication 
communication done channel 
message communication consists operator name value passing value 
value assigned local variable receiver side arrival message 
communication session communication belongs session session initiation channels establishes session may liked establishing fresh transport connections piece conversation distributed peers 
session initiation communication fresh session channels belonging session declared session multiple channels 
channel session channel belongs specific session session initiating channel session initiation 
channel assume sender receiver pre determined 
may may demand order messages participant specified channel preserved 
communication synchronous sender immediately knows arrival message receiver 
party participating session session channel sending receiving 
assumptions leave undermined affect way formalise protocols understanding formal properties 
existence lack assumptions substantially affect informal discussions section 

representing communication initiating session 
buyer session initiating communication simple bsh protocol described global calculus follows 
buyer seller sch says buyer initiates session seller communication channel declaring fresh session channel sch 
interaction moves note indicates sequencing process calculi 
session initiation specify session channels needed example shows 
buyer seller sch bch declares fresh session channels buyer seller reverse direction 
local description behaviour split buyer seller familiar notation process algebras 
example buyer sch seller sch buyer specifies buyer behaviour seller specifies seller behaviour 
lined channel indicates output follows tradition ccs calculus csp action written sch 
note behaviour participant described interaction 
processes combined engage interaction described scenario 

representing communication session communication 
session communication specifies operator needed message content 
interaction communication values 
buyer seller sch sch session channel 
says buyer sends message seller interaction ensues 
behaviour written local calculus sch sch session communication may involve value passing follows 
seller buyer bch says seller sends message value buyer buyer reception assigns received value local variable description translated point behaviours follows 
bch bch describes precisely communication behaviour 

representing branching 
various high level protocols find situation sender invokes options offered receiver 
method invocation objectoriented languages simplest example 
global calculus may write session communication involves branching behaviour follows 
reads buyer seller sch quoteaccept buyer seller sch quotereject session channel sch buyer selects options offered seller quoteaccept quotereject respectively proceeds 
interaction written local calculus follows 
buyer side selects sch quoteaccept sch quotereject indicates agent may behave sch quoteaccept sch quotereject decision called internal sum nondeterminism comes internal behaviour 
turn seller side waits options sch quoteaccept sch quotereject indicates agent may behave sch quoteaccept sch quotereject depending interacting party communicates sch called external sum nondeterminism comes behaviour external process 
note branches start input channel sch 
local descriptions original sum global description decomposed internal choice external choice 
similarly resp 
may considered result interactions resp 

buyer seller sch 
buyer seller sch seller buyer sch xquote buyer seller sch quoteaccept seller buyer sch seller shipper inits hch 
seller shipper hch shipper seller hch deliverydetails seller buyer sch buyer seller sch quotereject 
global description simple protocol 
global description simple bsh protocol 
global description simple bsh protocol 
meaning clear foregoing illustration illustrate key aspects description 
buyer initiates session invoking seller session initiating channel declaring session channel sch 
buyer sends message seller operation name carried values message may combined practice 
seller sends buyer receives reply quote value 
variable local seller exact content irrelevant 
received value stored xquote local buyer 
step buyer decides quote acceptable 
accordingly buyer may send quoteaccept message seller 
seller confirms purchase asks shipper details delivery shipper answers requested details say delivery date buyer forwards seller 
reception message protocol terminates denoted inaction 
alternatively buyer may send quotereject message seller case protocol terminates interactions 

description channels example buyer seller interactions bch addition communication seller buyer 
sch may considered way describe request reply mini protocol inside session initial sender sends request channel receiver turn replies leaving involved channel implicit practice cdl cf 


local description simple bsh protocol 
describes simple bsh protocol vantage viewpoint having participants interaction flows view 
behaviour described focussing behaviours individual participants follows 
description divided buyer interactive behaviour seller interactive behaviour shipper interactive behaviour 
focus buyer behaviour 
intuitively see descriptions protocol global version local version represent software behaviours extract vice versa 
shall establish compatibility formal result 
basic difference nature descriptions global description allows see messages exchanged buyer sch 
sch sch xquote sch quoteaccept sch sch deliverydetails sch quotereject seller sch 
sch sch sch quoteaccept sch inits hch 
hch deliverydetails hch deliverydetails sch deliverydetails sch quotereject shipper inits hch 
hch deliverydetails hch deliverydetails 
local description simple protocol participants interaction scenario proceeds local description behaviour party explicit seen distinct forms choices buyer seller 
xquote buyer buyer seller sch quoteaccept seller buyer sch seller shipper inits hch 
seller shipper hch shipper seller hch deliverydetails seller buyer sch buyer seller sch quotereject 
global description simple protocol conditional buyer sch 
sch sch xquote xquote sch quoteaccept sch sch deliverydetails sch quotereject 
local description simple protocol conditional buyer 
describing communication behaviour 
conditional 
simple bsh protocol specified buyer may choose quoteaccept quotereject nondeterministically 
suppose wish refine description buyer choose quote bigger certain amount 
purpose conditional 
description specifies reason branch taken 
notice condition conditional branch explicitly located description says judgement takes place buyer 
scenario described follows point calculus 
participants behaviours remain 

recursion 
assume wish refine protocol specification quote high buyer asks quote receives satisfactory quote 
behaviour easily described loop generally recursion 
show global description enhanced protocol 
additional lines second line rec indicates intuitively name block occurs inside block recur top block 
line second branch recurs 
point description recurs point immediately rec third line 
significance recursion buyer seller sch 
rec buyer seller sch seller buyer sch xquote xquote buyer buyer seller sch quoteaccept seller buyer sch seller shipper inits hch 
seller shipper hch shipper seller hch deliverydetails seller buyer sch buyer seller sch quotereject 
global description simple protocol conditional recursion expressiveness easily express various forms loops theoretical tractability 
description assumed value updated appropriately seller omitted protocol description 
instructive see recursion translated point behaviour 
local counterpart omit shipper behaviour change 
observe buyer seller recursion collaboratively engaged recursive interactions 
change needed shipper local description involve recursion 

timeout 
consider refining simple bsh protocol follows buyer reply seconds seller presents quote seller abort transaction 
seller decides confirmation message arrives buyer deemed invalid 
describing refined behaviour means describe timeout 
consider mechanism consisting creating timer timeout value starting timer exception thrown time occurs 
exception local exception sense consider notion exceptions basis infra structural support exceptions caught handled participant locally participant may interact parties result 
standard low cost mechanism employed run times java 
see realised concrete syntax 
refine global description 
comments line initiating session session channels sch default communications aborting transaction communicated 
generalised form session participants multiple channels single session useful varied purposes 
buyer sch 
rec sch sch xquote xquote sch quoteaccept sch sch deliverydetails sch quotereject seller sch 
rec sch sch sch quoteaccept sch inits hch 
hch deliverydetails hch deliverydetails sch deliverydetails sch quotereject 
local description simple protocol recursion buyer seller buyer seller sch 
buyer seller sch seller buyer sch xquote timer seller buyer seller sch quoteaccept timer 
seller buyer sch seller buyer sch buyer seller sch quotereject timer catch timeout seller buyer abort 
global description simple protocol timeout fourth line timer timeout value initiated seller 
timer stopped input guard specifying timer lines receives message branches single choice timer 
seller sch 
sch sch timer sch quoteaccept timer 
sch sch deliverydetails sch quotereject timer catch timeout abort abort buyer sch 
sch sch xquote sch quoteaccept sch sch deliverydetails sch quotereject par abort abort 
local description simple protocol timeout second line exception handler says timer fires seller send abort message buyer 
omitted buyer message arrives seller behaves sink 
protocol described local formalism extended timeout follows 
exception branch seller assumed behave sink messages sch sch quoteaccept sch quotereject omitted possible behave non trivially abort mode 
hand buyer behaviour par indicates parallel composition 
behaviour reception abort channel added parallel 

combining conditional recursion timeout 
section combination constructs introduced far 
gives global description behaviour buyer asks seller specified channel offer quote assume buy fixed 
seller replies quote 
buyer answers buy price cheap buy seller 
answer buy seller sends confirmation buyer sends channel buyer shipper 
shipper sends delivery details buyer protocol terminates 
answer buy interaction recurs 
buyer seller sch 
rec buyer seller sch seller buyer sch xquote timer seller xquote buyer buyer seller sch quoteaccept timer 
seller buyer sch seller shipper inits hch 
seller shipper hch shipper seller hch deliverydetails seller buyer sch buyer seller sch quotereject timer catch timeout seller buyer abort 
global description bsh protocol conditional loop timeout buyer reply time seller abort transaction 
local description 
buyer sch 
rec sch sch xquote xquote sch quoteaccept sch sch deliverydetails sch quotereject par abort seller sch 
rec sch sch timer sch quoteaccept timer 
sch inits hch 
hch deliverydetails hch deliverydetails sch deliverydetails sch quotereject timer catch timeout abort abort shipper inits hch 
hch deliverydetails hch deliverydetails 
point description bsh protocol conditional loop timeout 
describing communication behaviour 
criss crossing actions proactive quoting 
section treat behaviours involve criss crossing participants say message goes parallel having stronger priority 
cases contributed gary brown 
brown case simplified form typical interaction patterns investment bank businesses 
narrative description extremely short induced behaviour non trivial describe 
assume participants 
initially sends request quote bch 
bch bch quote xquote ff bch tt par rec timer expired ff bch xquote 
proactive quoting criss cross global sends initial quote response 
enter loop sending pro actively new quote message seconds message arrives message race condition message quote accepted terminate loop 
leave unspecified case quote calculated decides accept quote notifies quote agreeing refinements easy 
repeated actions time interval cleanly modelled predicate invocation mechanism useful purposes 
predicate expression boolean type 
reads interaction start predicate true engaged 
precise semantics true start true start event missed case may start 
behaviour tends deterministic realisable busy waiting additional synchronisation mechanism 
construct describe case 
informally illustrate underlying idea suggested initial quote arrived consider independent threads interactions may decide send message receives set local variable truth initially false 
ready receive message new quote value hand far local variable false repeatedly send seconds fresh quote 
note variable communication threads ceases send new quotes cease react new quotes reaching quiescent state 
description global formalism augmented construct follows 
bch ach 
bch ach quote xquote bch xquote par rec ach xquote bch ach 
bch ach ff 
bch tt par rec timer expired ff ach 
proactive quoting criss cross local standard action local indicating passage unspecified duration time 
bch tt indicates sending quote value time may take place duration time receives message assign truth local variable 
may refine part follows construct 
satisfied bch tt satisfied unspecified predicate local indicating satisfaction say current quote value 
second thread engaged loop timer expires seconds expires predicate exception true body executed 
false sends quote re enters loop true terminates loop 
interaction bch xquote indicates sends message ready receive sets communicated quote variable xquote 
protocol description invites diverse forms refinement 
example may consider predicate satisfied boolean variable set receives new quote second thread 
leave exploration refinements reader 
consider local version point counterpart construct 

may compare behaviours 
construct semantics global calculus 
local description behaviour projection clear threads repeatedly gets ready receive messages independently may move stage sends message criss cross messages take place simply receives message sending bch ach 
bch ach quote quote xquote rec timer bch timer catch timeout ach xquote 
proactive quoting criss cross global atomic interaction message 
noted may refine behaviour example transition quote acceptance state 
local description thread start action local action starts reception message second thread engaged timeout loop construct variable 
local descriptions proactive quoting protocol directly related global description vice versa treatment criss crossing 
particular hard imagine project description simple principle 
natural question reverse translation general way integrate local descriptions synthesize global description 
general principle involved projection 
part question answered part ii 

criss crossing actions proactive quoting 
subsection alternative global description proactive quoting protocol 
simple understandable description sound strong assumption underlying communication mechanism 
description follows 
description terse understandable 
clarity possible assuming significant condition underlying messaging semantics interaction atomic 
assumption essential bch needs executed atomically possible sends message time caught sends sends message expected behaviour says bch happens moves timer realisable action atomic 
may costly realise atomicity general 
time description may suggest atomicity interaction lead terse specification complex behaviour 
due assumption atomicity interplay timer hard devise local descriptions directly corresponding 
stipulate atomicity assumption local descriptions hard construct projection problem loop activity observe indicate exited loop 
possible approach model guard condition include variable guard condition include aspect duration result blocking semantics guard simply block variable set true receive quote refresh messages 
participants required guard condition assumes synchronised clocks evaluate expressions exactly time 
rbc stc sch 
rbc stc sch stc rbc sch timer rbc stc rbc sch timer catch timeout rbc stc abort stc rbc stc rbc sch 
global description shirts procurement 
criss crossing actions shirts procurement protocol 
treat case describes protocol purchase orders really big rbc small shirts stc 
rbc sends purchase order po stc 
stc acknowledges po initiates business process handle po 
stc internal processes regarding po completed stc sends po completed rbc order rbc complete business process 
rbc send cancel order message abort stc business process po completed message time rbc receives po completed message stc cancel order arrives stc po completed sent stc stc aborts business process acknowledges rbc po cancelled order rbc abort business process 
stc sent po completed ignores cancel order rbc agreed honor pos cancellations sent agreed time frame 
rbc sent cancel order message receives po completed message aborting rbc completes 
presents global description protocol 
rbc initialises session channel sch sends order stc acknowledges 
rbc starts timer longest time willing wait po confirmation arrives 
timer frozen po confirmation 
alternatively time occurs handled catch part rbc sends abort message stc stc acknowledges po confirmation arrives 
note timer explicit description show description rely timer 
acute reader may observe description assumes atomicity communication previous subsection sense execution interaction ch op means things time sends message received message 
give point counterpart description 
stc description predicate exception mechanism 
syntax exception handling try catch semantics informally execute interaction predicate boolean valued expression satisfied note treated event 
case executed 
rbc sch 
sch rch timer rch timer catch timeout abort true rch stc sch 
sch false 
rch try rch catch rch par abort 
local description shirts procurement construct feasibly implemented catch part exception timeout explicitly thrown exceptions 
implementation involved predicate invocation case mechanism necessary watch update relevant variables 
note construct similar construct underlying mechanism realise 
alternative may realise similar behaviour busy waiting sleep construct alternatives may faithful intended semantics arbitrary predicates invocation 
illustrate behaviour rbc stc point description 
rbc local behaviour follows 
actions session init order request obviously implemented rbc sets timer waits time units receive po confirmation stc time triggered rbc send abort stc wait abort confirmation po confirmation 
local behaviour stc may illustrated 
rbc part actions need description apart fact stc variable checking rbc requested abort 
variable initialised false point stc checks abort variable true decides perform tau action send po confirmation 
abort variable true confirms abort parallel described thread thread just waits abort message rbc 
rbc stc sch 
rbc stc sch stc rbc sch par stc false 
stc stc stc rbc sch rbc true stc rbc rbc false 
rbc rbc rbc stc abort true 
global description shirts procurement timer note point description explicit timeout done criss crossing occurs terms distributed point behaviours 
believe faithfully realises global behaviour described assumption atomicity interactions time may observe point description automatically get extracted global description 
fact far initial protocol description goes local description arguably realises correct behaviour stipulate atomicity assumption communication actions notable cdl stipulate atomicity 

criss crossing actions shirts procurement protocol 
descriptions far depend explicit timer exception timeout timer engenders 
nondeterminism criss crossing message exchanges may directly related local timers 
description exchange interactions possible timers shall discuss 
protocol uses local variables stc rbc initialised false 
timing update variables key underlying idea protocol 
protocol description follows 
offer informal illustration protocol 
initial interactions remain sending purchase order rbc stc session initiation stc rbc 
stage interactions divided parallel composition behaviours 
thread interaction stc point check true rbc abort request arrived false rbc abort request arrived 
false stc send po confirmation message 
rbc receives set true stc moves completion po processing 
true stc send message 
rbc receives sites po process aborts 
thread interaction point rbc check 
false po confirmation arrived sends stc 
true po confirmation arrived rbc moves completion po processing 
stc resp 
rbc indicates action stc resp 
rbc may take unspecified amount time 
check protocol moves situation stc sends po confirmation rbc aborts rbc abort needs obtain message stc 
situation rbc receives po confirmation reason 
note possible stc may receive thread message time reason propagated thread time time stc sends po confirmation message rbc 
contradicts initial specification believe consistent standard business convention 
point projection example hard leave reader 
note presents different description cdl construct distributed predicates 

note 
section explored various ways describe business protocols ones far ways describe 
purpose formal representations business protocols calculi analyse behaviours protocols reason understand correspondence various constructs expressiveness 
having precise operational semantics discuss diverse aspects constructs needed represent large class communication behaviours precision 
analyses complex business protocols formalisms important stimulating research topic 
feature cdl formalism session channels located input restriction session initiation implicit explicit general relation adding polyadic sync typing name informal structure formal type checking local exception repetition loop recursion sequencing imperative prefix predicate invocation adding epp implemented proved global variable lookup global completion table 
correspondence differences 
correspondence cdl section briefly outline relationship cdl global local calculi previous sections 
correspondence differences summarised table 
comments channels fundamental elements communication languages security engineering arising diverse forms sockets remote object ids urls 
informal global description may mention channels names participants play role channels essential exception channel passing involved 
fact standard distributed programming may multiple channels shape transport connections unit conversation 
cdl channels located inputting side representing ports sender writes 
formalisms general channels input output 
concerning session initiation done implicitly cdl 
calculi place explicit session initiation underlying operational type structure explicit amenable analyses 
prevent calculus represent practical business protocols may regard session initiation subsequent action combined single message implementation 
relation significant features cdl 
relation considered way collectively treat multiple sessions conversation unit 
treated feature cleanly represented formal calculi 
method called polyadic synchronisation 
cdl proper notion type checking type inference 
equipped notions relationship roles participants specifications related xml schemas 
constructs play important role part documentation 
data usable basis typing called name approach java 
current cdl specification type checking verifying particular choreography typed part specification 
type checking may partly complemented type inference elaborating untyped phrases appropriate types 
verifications done formally calculus provide algorithm interaction type checks type transporting facility cdl development tool significant topics 
saw exception indispensable managing interesting real application situations 
thing missing ws cdl ability handling exceptions locally standard local scoping rule 
topic may deserve consideration 
repetition instructions usually dealt loops 
calculus recursion mechanism faithfully emulate standard loop operation forms recursive calls 
enjoy theoretical features 
mean better replace loops recursion loop behaviour intended writing loop leads understandable program 
sequencing interactions treated different ways way done cdl way done calculus 
cdl standard imperative language construct adopted 
formalisms simple prefixing operator 
superficially construct powerful mainly assumes simple operations allowed 
contrary combine complex expressions combined parallel operator 
precise embedding prefixing combination constructs lose generality allowing easier analysis 
cdl equipped predicate invocation mechanism construct 
mechanism powerful various specifications demands heavy implementation mechanism 
exploration cases construct indispensable important understanding status structured concurrent programming 
various features cdl incorporated naturally arise business protocols 
semantic content may precisely understood 
note behaviour effect realised interactions distributed peers 
level formalisms understanding certain global construct may realised interactions prerequisite proper inclusion formalisms 
precise appreciation high level global abstraction suitable describing communication centred software behaviour relate local communication realisation important topic study 
part formal theory structured global programming 
part part ii develops theory point projection epp gives exact condition framework relate global description communication centric software local description 
theory intended offer central formal underpinnings web service choreography description language ws cdl 
development theory benefitted greatly dialogue invited scientists ws cdl working group wg members fact dialogue theory may developed moment current shape 
theory may considered offering formal substrate designing implementing distributed applications written ws cdl related languages establishing principles applications global description local description naturally precisely related 
particular theory may usable combination results research threads mathematical underpinning various tools infrastructural support web services including static dynamic verification 
effort underway open source implementation ws cdl 
rest part section informally motivates idea point projection theory summarises key technical results engineering relevance 
sections formally introduce global calculus centring dynamic semantics reduction static semantics type disciplines 
section local calculus 
sections introduces key descriptive principles global calculus form basis theory 
section establishes main results exact correspondence type structures dynamics descriptions global calculus local point projection 
section discusses extensions 
section positions ideas historical context compares existing concludes topics 
auxiliary proofs definitions left appendix 

informal preview 
point projection 
point projection epp short concept frequently discussed development cdl ws cdl working group 
basic idea simple may summarised follows 
write communication centred concurrent program case business protocol globally project point obtain local description realises original global description interaction 
simple example consider interaction buyer seller sch quoteaccept interaction buyer seller communicating accepts quote price pounds dollars currency 
simple global description projected point local descriptions buyer sch seller sch description interaction sending receiving information thing decomposed local communication actions sending action receiving action separate 
see buyer specified sending seller receiving precisely interaction specified takes place 
regard local agents behave wish realise global interaction described 
regarded local programs implementing original global description alternatively local monitors constrain behaviour agent 

epp matters 
epp matter 
epp clear idea global description executed computational meaning clear central idea web services general communication centred programs services independently running concurrent agents achieve application goals communication 
global description considered describing behaviour distributed communicating processes meaning 
sense uniform notion epp computational content global descriptions determined 
second epp essential basis diverse engineering applications global descriptions 
clear notion epp offers point local behaviour global description specifies wish monitor independently developed point program behaves way specified global description compare epp 
wish develop program referring global description interactions start epp developing fully specified program development programmer designer working endpoint program check conforms original global description respect communication behaviour validation may call conformance validation particularly useful collaborative program development 
develop global description language specify full algorithmic details specification point case result epp detailed global specification points offers directly executable distributed programs behaviour definition conformant original global specification 
independence indicates primarily synchronisation boundaries indicate tion domain security boundaries 
thirdly epp offer central underpinning theoretical understanding structures global description 
epp opens essential conduit theories processes web service engineering relating global description equivalent description shape communicating processes 
established connection enables application algebras logics types theories process calculi engineering context 
subsequent inquiries clear leads deep structural analysis global descriptions 
web service engineering demands theoretical foundations interoperability disparate agents inhabiting distinct protection domains term organisations possibly conflicting interests complex trust relationships 
context different organisations need clear shared understanding interact business protocol 
example consider business protocol transaction stocks need bound regulations 
need clear criteria point organisation acting conforming protocol 
fact conformance protocol regulation initially clarified need clear engineering understanding preferably backed theoretical basis 
expect key elements theories processes offer critical engineering tools context 

criteria epp 
ad hoc epp framework may fact works 
simple reasons 
wish implement epp algorithm map large class global descriptions local counterparts 
need general way relate global descriptions local ones 
second relating global description local description wish avoid situation generated local description different notions epp compatible 
especially true global description serves description software infrastructure organisation social domain key various business decisions interoperability infrastructural development fact stated goals ws cdl 
need general framework epp uniformly map general class global descriptions point counterparts 
know epp correctly projecting global description local description 
informal important engineering criteria resulting local descriptions intuitively clear direct connection original global description 
designer specifies software behaviour global description surprises real computation realised communications projected local processes 
viewpoint interoperability important general uniform scheme applied large class global descriptions note assuming public standard global descriptions sufficiently general satisfactory epp mapping gives firm basis interoperability 
apart informal criteria natural formal criteria measure effectiveness epp scheme fact closely related informal criteria just noted 
mapping preserves types formedness conditions 
projected local description implements behaviours expected original global description 
concretely actions expected global description faithfully realised communication collection projected points 
property may called completeness epp 
reverse direction locally projected communicating processes exhibit observable behaviour prescribed global description far predefined interface goes 
concretely communications projected peers go actions stipulated original global description 
may called soundness epp 
criteria especially sense practice precise way say course actions kinds structures stipulated global description course interactions kinds structures expected local programs may need engage actions outside prescribed just implement ing prescribed actions 
collection local descriptions 
follow standard framework process algebras programming language semantics defining formal syntax formedness type disciplines evolution behaviour dynamic semantics 
mathematically defining ideas formulate correctness criteria ambiguity means prove refute framework epp satisfies criteria course formal definitions semantics process languages go point projections including concrete implementation formal basis developing diverse forms verification technologies deeper inquiries mathematical properties descriptive frameworks cf 

aim rest note carrying program just outlined formalising central notions global local languages distilled form presenting formal criteria correctness epp study general framework epp including formal arguments correctness including natural descriptive principles epp results sound complete local descriptions 
particular shall formal definition static dynamic semantics global local calculi respective descriptive paradigms languages static semantics specifies type discipline description dynamic semantics specifies computation proceeds description 
type disciplines respective formalisms act basis technical development 
theory point projection maps global description local description offering means examine properties 
basic principles global descriptions defines notion formedness description 
introduce simple inductive algorithm maps formed global description collection local descriptions point formal arguments map sound complete respect static dynamic semantics respective formalisms 
theoretical development focusses key elements global local formalisms features timeout exception 
believe technical obstacles extend theory additional features 

global calculus syntax section introduce syntax dynamic static semantics global calculus 
dynamic semantics specifies notion computation underlying formalism 
case turing machine move head read write slot tape 
case calculus application lambda term argument subsequent substitution example indicates function applied argument result application 
case global calculus represented transition global description global description carrying step interaction exchange message 
participant may local variables transition involve collection local variables participants involved 
engineering viewpoint dynamic semantics pins mathematical notion designers implementors users refer wish discuss dynamic behaviour description rigour 
example allow state precision implemented program conforms description 
dynamic semantics defined intuitive notation says global description state collection local states participants changed new configuration idea comes small step semantics imperative languages cf 
description interactions global calculus centres notion session interacting parties establish private connection series interactions private connection possibly interleaved sessions 
concretely processes exchange fresh session channels newly created session interactions belonging session equivalent implicit framework identity tokens message content signifying session 
idea natural association simple type discipline represent structured sequence interactions parties type 
types mean syntactic annotation descriptions interactions annotation describes notion interface service shared service channel inferred typing rules description syntactic structure 
example consider interaction buyer seller seller buyer buyer requests quote product specifying product name session channel channel seller replies quote value may consider ch socket connection 
interaction abstracted session type string 
int session type abstracts sequence actions performed ch specifying behaviour sends string operation name receives integer operation name 
note abstraction buyer viewpoint equally abstraction seller action string 
int simply reverses direction information flows 
note way natural notion duality associated session types 
section section complete presentation global calculus 
introduces formal syntax global calculus illustrations 
section dynamic semantics calculus followed static semantics 
show basic relationship dynamic semantics static semantics computation happens typed description result typed 

formal syntax 
formal syntax global calculus standard bnf 
symbols denote terms global calculus called interactions 
terms describe course information exchange ore parties global viewpoint 
ch init op com assign ifthenelse sum par new grammar uses symbols 
rec rec inaction ch range collection ch service channels called session initiating channels 
may considered shared channels web services 
range collection session channels 
session channels designate communication channels freshly generated session 
implemented various ways tcp concept realised called connection called session 
web services realised sending freshly generated identity information part messages 
range collection participants 
participants engaged communications equipped local state 
participant may threads interactions multiple channels 
range collection variables close variables traditional programming languages pascal content updatable 
range collection term variables representing recurrence loop combination recursion rec note term variables occur annotated participants 
range expressions grammar ek 
ranges appropriate set function symbols including standard arithmetic boolean operators 
range atomic values natural numbers booleans 
construct grammar illustrated subsection 

illustration syntax 
initial constructs represent communications 
indicates invokes service channel initiating new session fresh session channels followed interaction subsequent communications belonging session done communications belonging different sessions 
main part study shall assume distinct 
local session standard assume unbounded supply distinct symbols syntactic category 
natural constraint wish describe inter participants interactions focus business protocols 
shall discuss cf 
theoretical framework study works intact allow intra participant interactions 
unknown outside set si bound second op expresses sending action message consists selected operator op receiver value expression variables located assigned variable located 
third primitive operation assignment typical basic operation imperative languages 
assignment local operation specified participant variable updated result evaluating located conditional branch course actions evaluate evaluates true branch executed branch 
note condition located explicitly selecting branches choose nondeterministically behaves 
summation operator commutative associative write iii fold sum interactions 
launch threads interactions parallel denotes parallel composition 
standard process calculi communication just means independent threads interactions 
construction restriction hiding session channel binds free occurrences designating newly created session channels session initiated 
stands sequence restrictions 
restriction added outermost initialisation prefix reduces natural stipulate convention 
henceforth consider terms restrictions occur prefixes initiation communication assignment occur summand summation 
interaction repeated unboundedly realised recursion 
start recursion variable annotation participant name annotation point projection brief indicates principal participant determines recur 
term rec standard recursion construct rec called recursor binding free occurrences assume occurs free rec annotated type discipline automatically guarantees property 
annotation plays essential role typing 
irrelevant especially examples omit annotations 
inaction representing lack actions may considered empty parallel composition empty inactive choreography 
expressions assume variables order atomic values integers order operators arithmetic boolean operations 
include channels session channels expressions inquiry cf 
section 

examples 
illustrate syntax simple examples 
examples running examples 
example 
syntax example part buyer seller sch quoteaccept buyer seller sch quotereject example uses easy read strings channel operator variable names 
buyer seller participants write formal syntax sch session channel name write grammar quoteaccept quotereject operation names op op grammar 
read follows session channel sch buyer selects options offered seller quoteaccept quotereject 
option selected buyer sends quote stored seller proceeds 
case seller sends abort number stored variable stored seller proceeds 
note sum informally interpreted internal sum buyer buyer initiates choice external sum seller seller passively waits branches operators chosen environment 
reading formalised consider point projection 
example 
syntax refinement description follows 
xquote buyer buyer seller sch quoteaccept buyer seller sch quotereject description specifies reason branch taken 
notice condition conditional branch explicitly located description says judgement takes place buyer 
note description external choice seller buyer selects options seller waits passively 
description self contained adding initial session invocation service channel say ch request quote 
buyer seller ch sch bch 
seller buyer bch quote 
xquote buyer buyer seller sch quoteaccept buyer seller sch quotereject initially buyer invokes seller initiate session session channels sch bch 
rest previous description 
example 
syntax session multiple session names communication 
standard practice business protocols interaction centric applications essential multiple parallel interactions inside single session 
example suppose buyer wants start session channel acc communicates acceptance quote session name op parallel sends address session name data 
expressed buyer seller ch op data 
buyer seller op quoteaccept buyer seller data quoteaccept address session channels op data communicated time session initiation channel ch 
channels reach examples constructs recursion hiding sections 

comments syntax 
syntactic constructs include core part global calculus 
theory point projection simplest possible form 
discuss basic extensions alternatives syntax 
channel session passing values may include channels session channels 
session channels passed need obey certain linearity constraint discussed 
variables binding may logical variables imperative variables receptors communicated values result communication instantiation values assignment 
case may include imperative variables assignment represent notion local states cleanly 
operators operators 
expressions complex 
ws cdl includes operators query current time data involve distributed states 
mutual exclusion atomicity important role played mutual exclusion operator 
mutex operation incur issues deadlock taken care type system 
introducing mutual exclusion imply changing operational semantics need take care variables access may blocked mutex 
may introduce transactional atomic statement guarantees atomicity noninterference block local read writes threads inside participant 
may implemented phrase locking optimistically software transaction note interactional nature concerned descriptions rollbacks subtle simple imperative programs issue parallels treatment input output software transactional memories studied harris 
exception timeout predicate invocation part discusses exception timeout predicate invocation written waits guard true executes conditional useful representing advanced forms interactions 
loop imperative constructs standard operator easily encoded formalism 
term encoded rec syntactic operation attaches variable leaves ends syntax trees similarly sequencing encoded sequencing non trivial interplay parallel construct 
considering features explicit syntax useful need directly treat practical descriptive languages ws cdl extension theory 

global calculus reduction 
basic ideas reduction 
computation global calculus represented step transition step consisting execution primitive operation communication assignment conditional 
effects execution local state involved participant 
formalise idea configuration pair state collection local states participants involved interaction written 
formally state ranged function var val variable participant assigned value store 
shall write denote portion local denote new state identical equal dynamics defined form says configuration performs step computation assignment interaction new configuration relation called reduction reduction relation 
example communication action change state term shape send indicates sends message send value received assigned variable result residual interaction 
note communication action happens automatically having sending receiving actions separately having synchronisation 
assignment treated similarly 
assignment located updated interaction unfolded 
interaction involve choice branches chosen nondeterministically ok ok take place legitimate reductions 
conditional depends expression evaluates 
example stores ok 
stores say second branch selected 
recursion expect recurring behaviour 
example silly behaviour just continues assign variable 
case may rec rec shall realise recurrence structural rules 
constructs conditionals choice standard 
subsection illustrate notion reduction construct 
term reduction originally came calculus sole purpose computation reduce final answer calculation 
entirely suitable interaction computation term convention respect basic formalism started semantics studies 

reduction rules 
reduction relation defined having rule construct associated rules 
rule session initiating communication init vector pairwise distinct session channels 
rule says communicates session initiation fresh session channels share locally indicated binding unfolded 
state stays communication values takes place 
seen example reduction representing communication session channel formal rule follows 
comm op premise rule uses judgement called evaluation judgement says expression evaluated value portion state 
example says stores 
expression communicated evaluated source part state value communicated assigned target part state 
formal rule assignment assign updates state participant unfolds interaction 
rules conditional assumes evaluation judgement conditional expression evaluates tt truth ff falsity 
tt iftrue symmetrically condition evaluates falsity ff iffalse rule summation standard sum ii parallel composition rule defined just considering interleaving components 
define par reduce left hand side 
symmetric rule defined similarly subsumed structural rules stipulate 
restriction res says restriction affect reduction 
recursion standard unfolding rule 
rule says rec rec rec unfolding rec rec substitutes rec free reduces resulting state rec reach 
note participant annotation plays role rule 
shall discuss structural rule obtain essentially reduction 
inaction reduction 
rule says reduce take terms certain equality 
struct structural equality defined rules fn rule fn denotes free names including variables channels session channels occurring relation congruence terms including equations 
benefit structural rules reduction rules limited context comparison standard process calculi considering terms natural adds clarity practice 
may structural rule recursion rec rec dispense rec rule 
just rec rule says recursion unfolding identical behaviour 
resulting reduction identical 
table rules 

examples reduction 
example 
reduction communication recall term example def buyer seller sch quoteaccept buyer seller sch quotereject infer reductions 
reduction branch 
summand note buyer infer comm seller similarly reduction second branch 
assume stores say buyer buyer 
seller reductions 
example 
reduction conditional deduce reduction conditional example 
reproduce term 
def xquote buyer buyer seller sch quoteaccept buyer seller sch quotereject init comm op tt iftrue ff iffalse res struct assign par sum ii 
reduction semantics global calculus assume buyer xquote infer iftrue rec rec rec buyer tt buyer seller sch quoteaccept applying comm resulting configuration conclude buyer seller sch quoteaccept seller reduction sequences case 
assume hand buyer xquote 
buyer ff iffalse buyer seller sch quotereject case buyer seller sch quotereject seller possible reduction sequence assumption 
example 
reduction init par struct consider example def buyer seller acc op data 
buyer seller op quoteaccept buyer seller data quoteaccept call components parallel composition 
init obtain op data comm seller par arrive seller symmetric case assume buyer adr adr string standing address comm seller adr par arrive seller adr noting apply struct obtain seller adr note simplified resulting term 
summary sequences reductions op data seller data op data seller adr op set def seller seller adr 
example 
reduction recursion show example recursion silly example rec 
noting expected 
rec def rec rec rec rec 

global calculus typing 
session types 
briefly mentioned outset section session types type structures global calculus 
advanced web services business protocols structures interaction service participant engaged may restricted way messages rpc request replies 
type abstraction needs capture complex interaction structure services leading session types 
grammar types follow 
bool int 
opi opi rec range value types case includes atomic data types 
session types 
note session channels occur free session types necessary multiple session channels single session cf 

take commutative associative identity 
recursive types regarded regular trees standard way 
brief illustration construct follows 
opi branching input type indicating possibilities receiving operators opi pairwise distinct value type opi branching output type exact dual 
parallel composition abstracting parallel composition sessions 
demand session channels disjoint 
type variable rec recursive type rec binds free occurrences 
recursive type represents session loop 
assume recursion guarded rec type input output type ary parallel composition input output types 
inaction type indicating termination session 
omitted 
time session occurs shared service channel session channels freshly generated exchanged 
interface service indicate vector session channels exchanged addition 
represented session type service type concrete instances session channels session type abstracted written vector pairwise distinct session channels cover session channels contain free type variables 
binds occurrences session channels induces standard alpha equality 
illustrating types examples introduce natural notion duality 
type dual written follows 
isi opi isi opi isi opi isi opi rec rec example type string string exchanging input output 
duality plays essential role subsequent technical development 

examples session types 
example 
session type basics consider interaction cf 
example assuming adr prd variables string type located buyer seller 
buyer seller prd prd seller buyer buyer seller purchase adr adr interface seller offers far interaction goes described session type string 
int 
purchase string 
interaction type abstracted viewpoint buyer string 
int 
purchase string 
type 
add session initiation buyer seller ch 
buyer seller prd prd seller buyer buyer seller adr adr service type seller channel sh string 
int 
purchase string 
says firstly fresh session channels order exchanged channels communication represented shape takes place 
service type describes behaviour starting ch albeit abstractly 
example 
session type branching refine branching 
buyer seller prd prd seller buyer buyer seller purchase adr adr buyer seller abstracted viewpoint seller string 
int 
purchase string note sum means inputting party seller waits options purchase hand type seen buyer side string 
int 
purchase string sum means outputting party buyer may select purchase options 
example 
session type recursion consider behaviour continuously 
rec greeting hello behaviour viewpoint rec greetings string 
interaction abstracted rec greetings string 
states repeatedly receives greetings 
meaningful recursion consider refinement rec buyer buyer seller prd prd seller buyer buyer seller purchase adr adr buyer seller behaviour seen viewpoint seller abstracted session type string 
int 
rec purchase string may notable conditional session type 
rec buyer buyer seller prd prd seller buyer reasonable buyer buyer seller purchase adr adr buyer seller prefix session initiation example buyer seller ch case obtain service type ch string 
int 
rec purchase string says initialisation request exchanging fresh session channels designated waits message replies waits options purchase case finishes session recurs initial state waiting message 

typing rules 
typed term term annotated types set typing rules 
kinds types 
session types assigned session channels service types assigned service channels 
typed term call typing judgement shape assigns service types located service channels session types located session channels 
called service typing session typing include forms assignments 
grammar service session typings consists pairwise distinct session channels ch var service typing forms assignments 
ch says service channel ch located ch offers service interface represented service type 
located means service offered ch 
act binder binding occurrences 
taken convertibility 
assignment var says variable located may store values type 
service channels variable say located different participants distinct variables 
regard var mapping pair channel principal type var 
third assignment says interaction recurs session typing 
assignment term variable necessary type recursive behaviour 
term variable assigned unique principal name 
convention 
assume service typing defines function reading 
write ch pair principal service type assigned ch variable type assigned pair principal session typing assigned 
session typing uses primary form assignment says vector session channels belonging session session type seen viewpoint main part study assume shall demand typing 
regard mapping direction 
shall see thing mapping reverse direction dual 
stipulate convention 
assume session typing defines function reading 
write pair session type 
similarly assume domain disjoint dom 
example session typing interaction buyer seller req prd prd seller buyer rep price price possible assignment buyer seller req string 
rep int 
states simultaneously belong session session buyer seller session type seen buyer point view 
form assignment know session type abstracted session initiation known sure channels hidden see tres 
ready introduce typing rules 
start typing session initiation 
ch ch ch lower half introduces session initialisation prefix ch term 
abstracted session channels belonging single session demand premise upper half session type assignment assigns session type 
directed designates session type seen viewpoint safely ch service typing ch assumed premise ch may assumption service channel shared just standard url 
need mentioned premise session parties information erased ch ch multiple users participants 
type communication 
opj js op purpose type term opj ij 
type contain session type session channels contain session type combined type communication 
remaining session types remain unchanged 
communicated value typed source variable typed target type 
branching type include operator op value type possibly usually adding operator names communicated value types 
rule uses auxiliary judgement says type judgement derived standard way starting var int regardless 
session type focus direction abstracts structure interaction session viewpoint consistent reason view session viewpoint may regard viewpoint receiver symmetric variant 
opj js op typing assignment rule follows 
rule change session typing service typing assignment change interaction structure 
note types taken location conditionals bool premise rule demand identical session typing identical service typing 
branch taken type abstraction remains identical 
similarly type summation rule worth presenting derivable applying repeatedly 
notation fold summation 
ij ja opj ij ksk premise implicit symbols ranges type ja opj ij ij needs session type session channels contain session types distinct vector session channels combine single type 
session types remain common branches premise 
combine session types different branches single session type adding operator names communicated value types 
note value type typed source variable typed target 
note special case fold branching singleton 
rule obvious dual corresponding omit 
type parallel composition standard linearity condition 
operator defined linearity condition satisfied iff fsc symmetric case typing rule follows 
restriction rules 
hide session channel session type assignment 
tres understand rule note hiding introduced session initiation takes place see init section 
done possibility session channels abstracted 
session type longer necessary replace 
take hidden session channel empty takes away denotes empty vector tres treat typing rule term variable 
tres tvar base cases inaction treated introducing service typing left hand side turnstile 
typing follow conventions contain assignment term variable interest participant annotation 
introduce session typing 
recursion rule symmetric tvar trec xa rec purpose type rec session typing 
purpose suffices session typing assumption session typing standard treatment recursion 
typing rule inaction follows 
si si ai bi rule assigns pairwise disjoint vectors empty action types 
typing rules summarised 

properties type discipline 
discuss basic properties typing system 
write indicate disjoint union 
proposition 
weakening implies 
fresh 
implies 
thinning assume fc fc 
implies 
type implies 
proof 
standard 
type note information explicitly generated show induction hypothesis inference possible 
observe free session channels grouped arbitrary way typing rules 
proposition grouping session names 
suppose 

suppose 

proof 
easy induction typing rules disjointness premise construct assignment depending belongs 
easy induction tres observe shape typing fact treat assignment form 
proposition says grouping free session channels session typing fact arbitrary relevant abstracted 
type discipline minimal typing closely related automatic type inference la ml 
formulate minimality ordering 
closed types types free type variables 
ch ch ch opj 
opj 
tres trec rec bool tres tres tvar formed formed si si ai bi 
typing rules global calculus definition inclusion ordering 
inclusion ordering relation closed types iff satisfying rules rule says satisfied condition premise satisfied 
par iso opi ij js opi opi js opi standard tree isomorphism recursive types 
relation satisfying conditions called witness 
easy see witness defining largest 
extend formed session typings formed service typings ch ch call extended relations inclusion ordering 
brief means result cutting branches including input output zero points 
ordering different standard subtyping session types shall introduce section 
inclusion ordering technical development section 
observe proposition 
relation partial order types modulo 
proof 
standard noting coinductive definition definition means witness regarded simulation deterministic trees 
see corresponding proof proposition page subtyping session types 
convention 
henceforth take relation types modulo 
definition 
write upper bound exists 
proposition 
upper bound upper bound 
proof 
assumption holds superimpose possibly infinite trees take union branches node regular tree surely smaller upper bound 
establish existence minimal typing closely related preceding works principal types recursively typed session types cf 

write 
proposition 
subsumption implies 
existence minimal typing 
exists algorithmically calculable call minimum service typing proof 
rules information demands communication operation term uses included type 
making type include operations safe 
prove stronger result claim 
assume free session names grouped disjoint vectors say ordered pair involved participants say 
write set mutually disjoint vectors corresponding grouping cf 
proposition 
typable session typing conforms type assignments done disjoint vectors 
extends rule conforms conforms 
particular term variable occur replaced 
proof induction minimal typing rules comparison original typing rules 
inductively constructs typings minimal typing 
assumed subject term term type checked type safe 
write tvar set type variables mtinit min ch fn tvar ch min ch mtinit ch min tvar ch min ch min min opj op min opj opi 
min min min min min min min min bool min min min min min min min min min min min min si appropriate fresh min si ai bi min min rec solve si appropriate min si ai bi 
minimal typing rules global calculus 
need care calculating minimal typing presence recursive types follow preceding studies cf 

treated mtinit 
introduce term variable introduce type variable 
premise refers disjoint vectors extends abstracting session channels initialisation result precisely mentioned 
solve essentially solves equations si ai bi si ai bi 
appear si ai bi corresponding component si ai bi rec get si ai bi result substituting free bound name convention occurrence note simpler constraint solving positive occurrences type variables 
mtinit type variables occur simply replace result substituting free bound name convention occurrence type variables substitution sound know target term typed note original rule include free type variable 
chosen appropriately abstraction 
free session channels arbitrarily fix direction say 
rules mtinit merge operator observation claim 
implies 
claim cases rules immediate 
remaining rules direct shape pair corresponding rules 
turn subject reduction 
start basic lemmas 
henceforth write typing conforms 
lemma 
substitution xa 
substitution 
proof 
see appendix subject reduction typing preserve session typing obvious reason reduces may lose initial part interactions session channel demand truncation corresponding session typing 
theorem 
subject congruence alpha renaming 
subject reduction assume 
imply 
subject reduction assume 
imply proof 
see appendix 
examples typing 
example 
conclude section showing possible type example consider buyer seller case interaction described global calculus 
buyer seller sch buyer seller 
seller buyer xquote 
buyer seller quotereject buyer seller 
seller shipper 
seller shipper buyer shipper seller deliverydetails dd 
seller buyer deliverydetails sessions buyer seller seller shipper 
note initialised session init operation included choice 
notable thing interactions variable involved times times variable located seller assigned delivery details dd third variable located buyer just happen name completely distinguished semantics mini cdl 
types channels sch 
verified rules appendix interactions typed sch seller buyer seller shipper seller shipper quotereject 
deliverydetails ptype deliverydetails 
example 
example section give typing 
simply comm seller sch data sch string data string 

point calculus syntax reduction point calculus applied variant calculus specifies local behaviours points composition 
example consider term global calculus cf 
example buyer seller quoteaccept global description says buyer sends quoteaccept message value seller seller receives seller saves value local variable point calculus describes situation combination local behaviour located point 
buyer behaviour buyer quoteaccept buyer local state 
similarly seller local behaviour seller quoteaccept seller local state 
interaction takes place concurrently composed follows 
seller quoteaccept buyer quoteaccept term written communication event represented onestep reduction seller buyer note state seller updated result communication 
correspondence global calculus communication point calculus organised unit session session initiation done communicating fresh channels ordinary session communication done session channels involving operator selection value passing described 
formal syntax reduction rules point calculus section 
input output separately described point calculus possible communication mismatch interacting parties 
example may seller quoteaccept buyer quotereject seller expecting quoteaccept message integer value buyer sending nullary quotereject message 
avoid situation type discipline 
syntax types global calculus 
example seller interface represented session type seller quoteaccept int buyer abstracted buyer quotereject signatures clearly incompatible conclude composition typed 
session types point calculus notion subtyping plays central role theory point projection 
session typing point calculus basic properties studied section 

formal syntax 
point calculus applied form calculus augmented notion participants local state cf 
session initiation uses bound name passing session communication uses variables local store spirit 
grammar define processes ranged 
ch init ch init iop xi pi input op output assignment conditional internal sum parallel res variable rec recursion inaction global calculus cf 
section ch denote service channels session channels variables term variables 
symbol ch line indicates replication says input channel ch available unbounded number invocations 
processes located participants 
participants composition called networks written grammar participant parallel nw res nw inaction nw global calculus denote participant names simply called participants 
denote local states mapping finite set variables finite set values 

illustration syntax 
session initiation pair mutually complementary input output ch ch context web services process ch may considered embodying repeatedly available service accessible certain url denoted channel ch invocation offers interaction described session channels just received 
process ch turn may considered invoker service located ch communicate fresh session channels subsequent interaction described structure communication session abstracted session type 
practice session initiation may combined ordinary communication 
session communications operator names analogous methods objects 
iop xi pi op input iop xi pi says finite branches indexed invoked 
operators op pairwise distinct 
op invoked instantiates communicated value local variable xi subsequently behaves described pi 
xi note symbol denotes distributed state global calculus point calculus corre sponds local projection distributed state 
bind occurrences turn op invokes input operator op communicating result evaluating expression behaves prefix operator assignment assigns result evaluating local variable enclosing participant behaves constructs represent internal choice 
standard conditional written evaluate boolean value 
case evaluated deterministically choose nondeterministic behaviour embodied standard internal sum chooses nondeterministically chosen behaves 
fold composition written ipi 
combining multiple outputs channel distinct operator names fold internal sum construct output prefix dual branching input prefix 
sum useful introduce notation denoting 
iop ei pi assume op pairwise distinct 
note input branching output branching mixed choice components outputs inputs common session channel 
offer structured form choice easily implementable form mixed choice useful representing complex interaction discussed part syntax parallel composition standard standard process algebras parallel composition global calculus may engaged communication 
restriction uses standard syntax indicates local consider restriction service channels addition pose technical problem 
representing recursive behaviour start term variable forming process may occur free introduce rec rec free occurrences bound rec behaviourally free denotes recurring point recurs rec 
contrast global calculus cf 
section variables need principal annotation 
inaction denotes lack action unit parallel composition 
processes located participant follows says participant named equipped behaviour local state 
participants combined parallel composition typing rules discussed section network participants participant names 
session channel shared participants need restriction technical convenience introduce inaction networks denoting lack network 
acts unit parallel composition networks 
example 
example page global description represented endpoint formalism network shape buyer buyer seller seller processes realise behaviour expressed global calculus 
buyer behaviour represented sch quoteaccept quotereject seller behave sch quoteaccept quotereject elaborate example 
example 
example page presents construct case elaborate follows 
xquote sch quoteaccept sch quotereject sch quoteaccept quotereject note kept shape choice conditional guard located buyer side buyer chooses branches 
consider result adding session initiation second description example elaborate follows 
def ch sch bch 
bch xquote 
xquote def ch sch bch 
sch quoteaccept sch quotereject bch sch quoteaccept quotereject note input compensated output vice versa similarly branching selection 
example 
example page presents parallel session communications inside single session 
skeleton define follows def ch op data 
op data adr def ch op data 
op data buyer offers parallel outputs seller receives dual inputs 

reduction rules 
reduction indicates evolution processes networks communication actions 
binary relation networks written rule initiation session invocation shared service channel 
init ch ch ch addition rule may include intra participant communication discuss section 
session communication com xi pi opj pj rule local version omit 
assignment affects local store assign conditional evaluates guard expression depending value decides branch chosen 
tt iftrue ff iffalse internal sum standard reduction 
sum pi rule says behave 
parallel composition processes par restriction res list corresponding contextual rules networks 
recursion set par nw res nw rec rec rec rule says take reduction structural rules struct nw init ch ch ch com xi pi opj pj tt iftrue ff iffalse assign par nw res nw res sum par pi struct nw rec rec rec 
reduction rules point calculus congruence networks generated networks stipulate fn fn concludes presentation reduction rules 
list reduction rules table 

definition equations allows write fold sum ipi reduces reduction context ipi pi 
point calculus typing 
types subtyping 
global calculus session types typing controlling flow operations data channels 
set types global calculus grammar reproduced convenience 
bool int 
opi opi rec called session types 
take commutative associative identity 
recursive types regarded regular trees standard way 
service types ranged indicates service located invoked fresh session channels offers service shape indicates type abstraction dual invocation client service invokes fresh channels engages interactions abstracted 
note indicates location service forms 
vector pairwise distinct session channels cover session channels contain free type variables 
binds occurrences session channels induces standard alpha equality 
define duality notion duality remains 
point calculus useful consider subtyping relation session types 
subtyping defined closed types types free type variables occur 
relation written 
intuitively indicates gentle dually constrained behaviour 
define subtyping relation coinduction 
subtyping witness relation satisfies rules indicates condition saying satisfy satisfy condition premise 
rule standard type isomorphism 
sub js op opi rule says branching type gentle case subsequent behaviours input gentle offers options 
dually sub js op opi remaining rules close relation type constructors 
sub par sub sub iso rule subtyping rules equivalent saying take infinite trees compare structures simulation cf 

shall write subtyping witness 
note difference defining rules defining relations definition page input branching rule 
proposition 
types modulo partial order 
proof 
surely witness 
witness witness shape rule surely witness 
example ir par iso assumption 
applying par ir 
transitivity done 
anti symmetry show symbol dually formal content 
coincides 
clearly direction show bisimulation definition noting transition deterministic 
definition 
write lub exists 
proposition 
upper bound exists upper bound exists 
proof 
superimposing trees corresponding union intersection checking result regular tree 

typing rules 
typing judgement local calculus form mentions participant name inhabited 
network 
service typing session typing grammar 
ch var stipulate service session typings define appropriate functions 
particular write free channels session channels variables shared typings 
observations basic difference grammar global calculus see section session type assignment local calculus vector names single participant 
session type assigned endpoint behaviour channel session type sides coming 
sides session compatible compose leave assignment typing 
composable types effectively unusable composition 
standard linear typing calculus 
service typing ch thing global calculus identity 
called server type assignment 
ch called client type assignment 
stipulate composition ch ch ch service usable times 
standard replicated linear type discipline 
types control composition processes networks partial algebras 
say brief session types treated linearly service types treated server client types 
definition 
write indicate server client type 
set undefined 
write ch ch defined ch fn 
fn 
fn 
set union channel ch ch fn type newly assigned ch ch ch 
similarly set fc fc undefined 
define 
introduce typing rules 
rule typing inputting side initialisation 
ch ch note premise allow session channels target initialisation session typing server typing ch subject 
prevents free session channels replicated input guaranteeing linear usage prevents service channel ch 
constrain server 
mode channels ch uniform receptive sense 
outputting side initialisation analogous linearity constraint needs specified 
ch ch ch identical 
fact allow ch occur premise means par rule invocation service done times needed far type correct 
typing session communication starting input involves branching distinct operators 
pj pj ksk rule typing branches real process process prepared receive get invoked operation specified type 
dually var opj ks typing branches real process process invokes operators specified types 
combining output tries invoke non existent option matching input 
rules assignment standard 
conditional standard 
bool note session typings identical premise essentially linearity constraint ensuring linear name session channel precisely branch 
practical ramifications possible particular easily refine linear typing affine 
typing sum similar conditional 
rule parallel composition reads introduced types eliminated restriction 
tres tres tres denotes empty vector 
rules term variables recursion standard 
tvar trec rec rule inaction introduces empty session typing 
may constrain contains assignments term variables imperative variables client channels form ch 
add constraint rule tvar property existence input channel typing implies existence subject process network 
start session typing need introduce inaction types represent terminal point session type recursive variable introduced tvar 
weak fn weak fn rule links process typing typing network 
composition inaction rules networks follow 
nw nw restriction rules precise copy corresponding rules processes 
tres nw tres nw exact copy weakening rules listed fn fn weak nw weak nw list typing rules standard syntactic properties follow 
fn denotes names include term variables standard variables channels 
proposition 
weakening implies 
fresh implies 
thinning assume fc fn 
implies 
subsumption ch ch 
similarly 
proof 
appendix subsumption service channels 
subsumption service typing input channels hold system 
semantically service typing fact sound 
may add rule subs service ch ch basic consequence adding rule minimal typing principal typing see 
result says find representative typing process effectively 
type minimum assignable typings subtyping relation call minimal typing term 
convention 
typing strict free identifiers occur write similarly stands 
write extending point wise service session channels variables typing coincide 
ch ch ch ch ch pj pj var opj ks bool tres tvar weak fn tres trec rec nw tres nw nw weak nw weak nw fn fn weak fn tres nw 
typing rules point calculus definition minimal typing 
assume typable 
minimal typing strict 
proposition 
existence minimal typing minimal typing algorithmically calculable proof 
standard result session typing systems 
gives derivation rules 
rule uses lub cf 
definition mtinit 
mtinit expression denotes result substituting free bound name convention occurrence type variables denotes join respect subtyping ordering 
taken output type input type coherent way note means branches input point 
similarly service typing 
composition service typing preserves input side typing assuming def discussed proof proposition page section expression solve denotes result calculating proper recursive type appropriate substitution follows simpler standard constraint solving principal types recursively typed calculus lack channel passing 
expression returns component si si rec exist si 
system derives minimal typing induction typing rules comparing rule corresponding 
principal typing 
minimal typing typable network process determined uniquely standard isomorphism recursive types 
minimal typing may principal typing sense minimal may case lack syntactic subtyping service replicated channels discussed page adding subs service noted typable term principal typing 
prove central property typing rules subject reduction 
lemma 
substitution 

proof 
standard 
see appendix lemma 
subject congruence 
proof 
standard 
see appendix theorem 
subject reduction 
proof 
lemmas 
see appendix definition communication error 
say communication error cr iop xi pi op op op cr iop xi pi op op op 
cr iop pi opi op op 
reduction context context hole prefix 
min mtinit exhaust type variables 
ch min ch mtinit mtinit min ch min ch min ch min ch ch min pj min pj var min min opj js opj min min bool min min min pi min min min min min min ss si min si si min si min min nw min min nw min min min min min rec solve nw min ni min nw min min 
minimal typing rules point calculus communication error contains input output common channel match operator names add mismatch types evaluation 
basic corollary theorem follows 
corollary 
lack communication error contains communication error 
proof 
lemma noting incompatible redex typable 
process network typed go communication mismatch 

examples typed terms 
example 
give possible point version showed example buyer sch xquote 
quotereject quoteaccept deliverydetails seller sch quotereject quoteaccept buyer deliverydetails deliverydetails shipper deliverydetails dd simple verify typing gave previous section global view protocol just typing network 

theory point projection connectedness preceding sections example specifications global view global calculus local view written point calculus 
doing introduced global description recovered corresponding point processes 
engineering viewpoint steps start global description extract local description point offer effective methods designing coding communication centric programs 
simply pain design implement validate application involves complex interactions processes correctly solely rely descriptions local behaviours 
tools message sequence charts sequence diagrams primary way design communication behaviour 
fact primary concern design requirement communication behaviour application general global information exchange processes take place interactions lead desired effects local behaviour individual components matter realise global scenario 
designing implementing communication centric software may start global description expected behaviour translate local descriptions 
done generally uniformly formal foundation theme section studied distilled setting calculi interaction 
translating global description point counterpart process called point projection tricky easily produce global description correspond reasonable local counterpart 
words follow principles global description fact describe realisable interaction 
general principles global descriptions guarantee global description uniformly mapped correct point behaviour far follows 
principles restrictive allowing projection large class global descriptions efficient local realisations 
context core calculi identified simple descriptive principles technical examination purpose section 
connectedness says basic local causality principle obeyed global description 
threadedness says stronger locality principle session types 
coherence specifies basis threadedness consistency description service 
principles stipulated incrementally basis typedness threadedness sense interaction connected coherence defined threaded interactions 
conditions offer natural disciplines description offer gradually deeper analysis operational aspects global description 
connectedness uncovers causal relationship actions basis threadedness extract atomic chunks local activities called threads global interaction crucially underlying type structure 
coherence stipulates condition threads formed combined produce behaviour participant 
resulting participants realise combined interactions prescribed original global description 
way offering precise analysis conditions local global description principles arrive construction formally founded point projection 
descriptive principles structural analysis operational content global descriptions leading function maps corresponding local descriptions 

connectedness 
connectedness dictates local causality principle interaction initiates action say sending messages assignment 
result previous event reception message preceding event take place example consider op op 
dynamic semantics global calculus execution interaction interaction takes place 
implementing sequence interactions distributed setting need hidden notification message 
describe communication sequences needed realise demanded sequencing 
incomplete description communication behaviour 
wish avoid descriptions violating local causality principle 
formalise local causality principle informally discussed need say participant initiates action participant place preceding event happens 
notion defined follows 
definition initiating participants 
interaction hiding occur initiating participants denoted top inductively follows 
def top def ch def op def def xa def top def rec xa top top def top top def top say initiating participant 
convention cf 
page natural restrict concerned interactions terms restriction 
function top generates set participant 
generated set contains participants initiates action note count sending actions session initiation sending message initiating actions don corresponding receiving actions shall analyse section robust option alternatives 
annotation term variable revealed role initiating participant behaviour embodied discuss allows validation connectedness presence recursion 
inductive definition connectedness 
convention typedness 
henceforth consider typed terms global local calculi specified 
definition strong connectedness 
collection strongly connected interactions inductively generated follows considering typed terms cf 
convention 
ch strongly connected strongly connected top 
op strongly connected strongly connected top 
strongly connected strongly connected top top 
strongly connected strongly connected top top 
rec strongly connected top 
xa strongly connected 
strongly connected strongly connected top 
strongly connected strongly connected 
strongly connected strongly connected 
strongly connected 
course insert additional communication missing 
precisely need principle dictating insertion necessary may done 
note strongly connected implies typed 
strong connectedness says communication actions message reception leads activity receiving participant activity immediately follow reception messages 
variants notion connectedness loosen clauses definition discussed subsection 
variant allows identical technical development notion useful various examples 
shall discuss subsection looser variants connectedness place allowing remaining theoretical development go 
strong connectedness chosen allows transparent theoretical development 
encode descriptions looser principles strongly connected interactions preserving semantics 
defining clauses definition naturally understood 
illustrate treatment recursion 
recursion rec operational semantics cf 
section occurrence term variable seen link back recursion recursive term rec 
view suggests guaranteeing connectedness need sure action preceding connected recursion initiating participant happen annotate statically check preceding event happens demand body recursion start justifies participant annotation recursion variables 
henceforth assume typedness assume typed typed base including substitution typed 
lemma substitution 
strongly connected top 
strongly connected top top 
proof 
induction structure 
induction base 
case analysis 

immediate 
immediate induction inductive cases 
case analysis 
ch induction hypothesis strongly connected top top 
strongly connected 
top top done 
op immediate induction hypothesis 
rec bound name convention assume rec rec 
induction hypothesis 
lemma subject congruence strong connectedness 
interactions 
strongly connected strongly connected 
proof 
show holds cases si 
trivial 
trivial 
theorem subject reduction strong connectedness 
strongly connected typed 
implies strongly connected 
proof 
induction reduction rules 
init 
case ch definition strong connectedness connected strongly connected top strongly connected strongly connected concludes case 
comm 
applying rule get op definition strong connectedness strongly connected 
assign 
rule states 
definition strong connectedness strongly connected 
iftrue iffalse 
definition strong connectedness ii strongly connected 
par 
inferred 
definition strong connectedness strongly connected 
induction hypothesis strongly connected 
definition strong connectedness strongly connected 
res 
immediate induction hypothesis definition strong connectedness 
rec 
rec rec lemma rec strongly connected 
induction hypothesis done 
struct 
lemma 
strong connectedness variants imposes strong structural constraint shape interactions 
consequence observation 
intuitively says thread interactions single participant ready perform operation input remaining participants waiting input 
stage thread activity participant performing operation input 
contrary rest participant performing input 
definition input output form 
assume structurally equivalent ia opi ei xi ii ch consider tree generated unfolding recursion occurrences 
input output form occurs path leaves receiver zero ifthenelse assignments output 
lemma 
structurally equivalent ia opi ei xi ii ch strongly connected input output form 
proof direct definition strong connectedness 
shall observation analysis extract true units activity global description 

examination connectedness input output asymmetry 
strong connectedness regard sending action initiating 
observations point follows 
session initiation actions natural choice 
typing point calculus idea service channel available setting feasible choice guaranteeing sequencing specified global description sending party action 
second session communication actions swap inputting party outputting party initiator sequencing theoretically 
example compare interactions 
strongly connected second uses reverse sequencing 

op 
op 
close look observe assumption second action ready receive just second step sending action 
note assumption demanding strict sequencing inputting side outputting party takes responsibility timing communication action 
feasible demand parties ready complementary actions time 
allow local processes obey described sequencing assumption second action ready send sent just second step ready receive action 
note argument sequencing input holds context asynchronous communication pure arrival order nondeterminism 
discipline simply participant sending create datum may done result preceding event sender side receiver side 
viewpoint neglects hidden causality principle message creation may practical choice 
arguments suggest assumption sender receiver realises sequencing natural idea 
discuss basic variants connectedness understanding sequencing 

examination connectedness variants connectedness 
strong connectedness 
strong connectedness robust respect asynchrony messages assume messages sent asynchronously point processes principle guarantees strict sequencing 
strong connectedness strict 
example consider description buyer seller 
buyer seller seller buyer buyer requests seller start session service channel exchanging fresh session channel buyer request quote product name 
seller replies corresponding product price 
sending multiple consecutive messages party session practice business security protocols 
may violate essential idea strong connectedness logically implementation reception message acts trigger event different participant 
second send consecutive messages go works infrastructure implements message flow asynchronous messaging note send consecutive messages separately need guarantee order messages way purpose may widely transport level protocol tcp 
call refinement strong connectedness allows consecutive interactions sender receiver strong connectedness relative repetition strong connectedness 
give formal definition 
definition 
say starts action prefixed session initiation communication definition strong connectedness 
set strong connected interactions inductively generated follows 
ch strongly connected strongly connected top starts action practice may describe initial session initiation action action action ws cdl 
may consider representation idiom formal setting 
op strongly connected strongly connected top ii prefixed action terms clauses definition replacing strong connectedness strong connectedness 
may note relative strong connected interactions encoded strong connected interactions 
example translated buyer seller 
seller buyer ack buyer seller seller buyer add ack consecutive actions directions 
reason technical developments depend strong connectedness equally strong connectedness change essential arguments 
particular soundness completeness results endpoint projection hold 
connectedness 
loosen relative strong connectedness 
thing may consider description natural 
broker seller 
broker buyer 
broker seller broker buyer seller broker 
broker consecutive actions targeted different participants 
global description specifies fifth line seller replies buyer immediately preceding action goes buyer 
natural easy consider seller send message third line received broker fifth line 
description obeys locality principle directly realisable synchronous communication 
easy realise idea asynchronous communication far message sending order target preserved message order preserved participant may able group messages send go permutation complicated branching somewhat similar permutation instructions pipelining modern cpus 
principle simply call connectedness formalised accumulating potential initiating participants 
example line may case broker potential initiating participant 
line seller joins 
second line buyer joins 
fifth line seller invoke interaction 
simply connected interactions allow parallel technical development operational correspondence needs adjustment 
relaxed variant connectedness issue sequencing global action may show false dependency projected local behaviour 
means connected strong connected descriptions general threaded sense shall discuss 
spite observation strongly believe relaxed version connectedness basic role structuring principle global descriptions intending explore 
constructs 
introducing syntactic constructs join operation notion connectedness refined 
far variant imposes reasonable constraint locality principle actions believe corresponding principle sound substrate essentially equivalent technical development shall discuss subsequent subsections 

theory point projection threadedness 
service channel principle 
strong connectedness interaction direct consequence preceding local event 
basis finer analysis interaction possible allows extract unit behaviour acting global description 
unit called thread plays pivotal role theory endpoint projection 
introducing notion threads illustrate subtle point way service channels act initiating points sessions represented point calculus example 
consider global description chb 
cha 
op op asking service session chb asking service cha replying value session name belonging session cha sending value session name belonging chb 
consider naive implementation interaction communicating local processes focussing 
chb cha op op local description directly translates portion asks service chb waits somebody ask service cha sends value waits value sent faithful way represent behavioural content 
suppose client wishes service available cha 
projected behaviour indicates service cha available finishes interaction cha availability service cha dependent action issue worse waits reply offering cha 
generally formalism web service languages ws cdl channel initiating protocols service channels formalism initial channels starting ws cdl may public urls intended repeatedly available know port names 
fact standard practice web services service embodied shared channels form urls uris users throw requests time availability shared ports maintained part standard notion service service framework going web service 
construction services looks unnatural service channel available clients know url 
may called service channel principle 
engineering context basic form service channel principle rpc rmi web service embodiment soap 
context calculus notion representable replicated input receptive input ready 
easily enforce refined discipline guarantee input service channels prefix typing point calculus 
untypable 
local representation obeys service channel principle 
local code cha op chb op chb cha op op tracing reductions parallel composition check interaction proceed faithfully 

motivation false causality global description 
ready illustrate notions threads threadedness 
consider global description chb 
chc 
cha 
op note description strongly connected 
claim description structured impossible faithfully realised reasonable point processes 
examine behaviour described 
service channel principle observe behaviour different chunks code informally call threads 
thread starts fresh session invoking chb sends value thread provides service cha may realised 
local behaviour may represented cha pa chb op qa way may consider local implementation 
chb chc op pb consider point view chc cha pc see process interact 
asks service chc process op pb free react term op pa interacted component 
change local behaviours precisely represent original global behaviour 
reason follows 
service channel principle says channel cha replicated ready receive invocation 
session channel initiated thread cha cha initial move 
action take place immediately invocation cha cha contradiction 
conclude impossible impose global sequencing stipulated typed local behaviours 
means describes false dependency actions realised typed local interactions 
examples motivates main theme section descriptive principle called threadedness automatically prevents false dependency appearing global description 
introduce notion formally subsections 

annotating interactions threads 
come back global description realisable point processes 
analyse lines global description informally reproduced 
chb 
cha 
op 
op 
initial interaction line initiated output session initiation service channel chb dually interaction input reception session initiation chb 
line reacts interaction output session initiation service channel cha 
dually input action receiving session initiation cha 
input done independently initial output action 
point realise output action reaction previous input action code call causally connected sequence actions participant thread 
threads 
thread containing invocation chb opening channel thread containing reception invocation opening subsequent invocation cha opening 
thread containing reception invocation cha opening 
note thread thread separate threads new invocation service new session initiation done creates new thread receiving service side 
continue analysis 
line output reaction previous input thread thread 
uses session channel opened thread line action thread 
interaction third line input thread uses opened initial action thread 
line reacts output action opened thread know action thread 
similarly dual input action thread opened thread line interaction concluding analysis 
summary threads thread thread starting output thread service starting input service channel cha precisely processes reproduced cha op chb op similarly service thread reproduced chb cha op op extracting threads informal sense global description led obtaining local behaviours faithfully realise 
analysis local causality threads session types main focus discussion 
start annotating global interaction notion threads 
definition annotated interaction 
thread annotated interactions simply annotated interactions written grammar 
ch op rec natural number 
call occurring annotated interaction threads 
grammar extended annotated interactions range extended annotations abuse notations simply call annotated interactions 

parallel composition prefix anyway share initiating participant top level threads may different threads extended annotated threads represent 
restriction note occur outside prefixes convention 
annotated interaction annotates node syntax tree term threads natural numbers 
example annotated previous analysis chb 
cha 
op op annotate global interaction inconsistent annotation sense 
chb 
cha 

threadedness 
just seen thread annotation may may sense 
find consistent way annotate interaction threads 
previous analysis need stipulate causality specified globally precisely realisable locally 
fix terminology 
regarding syntax tree constructor root say prefix parallel composition annotated thread initiation communication ordered pair threads sender second receiver 
constructor direct subtree syntax tree 
possibly indirect subtree dominated direct indirect proper subtrees 
definition basic terminology threads 
root initialisation communication annotated resp 
active thread resp 
passive thread 
root constructors annotation active thread passive thread 
occurs proper subtree root predecessor root symmetrically define successor 
direct predecessor successor predecessor successor intermediate predecessor successor 
note root predecessor execution temporarily precedes 
definition consistent thread annotation 
annotated strongly connected interaction globally consistent conditions hold subtrees say 
distinctness freshness condition node node coincide 
starts initialisation passive thread fresh predecessors 
session consistency starts communication say subtree starts communication initialisation opens thread resp 
coincide thread resp 

causal consistency direct successor active thread coincide passive thread thread annotated interaction locally consistent globally consistent conditions hold possibly indirect subtrees 
local causal consistency suppose initialisation communication similarly contain subtree passive say active vice versa 
says thread belong participant fresh thread starts service invoked 
says distinct interactions session typing pair participants threads participant note gives grouping free session channels abstracted initialisation action note proposition grouping session channels arbitrary 
says input annotated passive thread immediately output annotated time active thread 
significant condition local causality 
says thread going interaction participant acts strictly alternating fashion initialisation communication actions 
illustrate condition go back initial example chb 
cha 
op op 
notice works just session flow information participant followed opposite flow information starts session chb name replies causality depicted global description realised locally 
embodies condition key local realisability causality global description 
somewhat surprisingly global consistency implies local consistency 
proposition 
globally consistent locally consistent 
proof 
outline suppose separate inputs annotated thread intermediate actions annotated consecutive inputs thread temporarily separated 
impossible immediately passive lead active occurrence direct subtree contradicts assumption 
symmetrically suppose separate outputs annotated thread intermediate actions annotated consecutive outputs thread temporarily separated 
impossible immediately second active preceded passive occurrence direct 
definition 
say consistent globally consistent equivalently locally consistent 
define threadedness 
say annotation result stripping annotations coincides definition threaded interactions 
strongly connected term threaded annotation consistent 
note threadedness implies strong connectedness typedness 
subsection introduce type discipline type threaded interactions consistent global local annotation 
annotations session typing 
natural consider consistent annotation conforms grouping session channels session typing 
suppose annotation may demand addition extension communication actions participant occur respectively belong type assignment actions thread 
strong connectedness section refined consecutive actions annotated threads 
strong connectedness section refined treat consecutive actions single chunk 
result related called switching condition game semantics 

examples threaded interactions 
important understand connection interaction annotation 
order give sound deterministic correspondence define function annotates interactions 
try explain rules typing system 
consider interaction chb 
op 
chc op consider implementation local calculus discussion get chb op 
chc op chb op op chc start talking threads notice going action take choice start new thread continue previous 
translation gave point calculus think annotation chb 
op 
chc op show case include recursion construct 
consider interaction chb 
rec op going details possible point representation clear problem notion threadedness 
fact starts session chb continuously sends session name goes notion threadedness 
add interaction remedy issue chb 
rec op op annotated interaction threaded example parallel composition 
chb 
chc ch note thread passive initial action turn active components parallel composition 
way prefixed parallel composition common initiating thread 
top level parallel composition ch result reducing interaction previous threaded 
wt init topt ch wt comm topt op wt var wt assign wt ifthenelse topt ai topt ai wt sum ai topt ai wt par ai topt ai ei wt par ext wt res ext formed wt zero wt rec formed topt rec 
typing rules checking threadedness 

type disciplines threadedness 
typed strongly connected annotated interaction threadedness compositionally checked typing system 
typing system checks 
refine validate 
henceforth range finite sets session channels 
assume defines function domain threads term variables 
indicates union dom dom 
say formed iff session channel assigned threads iff typing judgement form records free session channels thread inductively formed 
definition type discipline threadedness 
annotated strongly connected typed interaction derived rules convenience annotate inaction thread writing notation topt returns active thread non extended annotated interaction sense definition annotated set topt 
typing formedness inductively guaranteed threaded interactions required shape typing premise wt init wt comm satisfied 
wt init place threads 
rules parallel composition wt par wt par ext precise correspondence grammar annotated interactions cf 
definition note shall writing extended annotated interactions 
wt par demand initial active threads components identical 
hiding wt par ext extended annotated interactions 
basic property typing system follows 
theorem soundness wt typing 
extended annotated strongly connected interaction threaded 

henceforth ih stands induction hypothesis 
proof 
prove stronger result say thread complete occurs passive thread session initialisation 
incomplete 
claim 
formed consistent incomplete thread uses iff complete thread say contains 
wt init direct ih 
ih shape rule noting got completed 
wt comm direct ih 
ensured ih condition premise 
wt assign wt ifthenelse wt sum wt par wt ext par wt ext res direct ih corresponding condition premise 
wt var wt zero obvious 
wt rec direct ih obvious ih 
define exactly corresponding relations unannotated interactions cf 
page demand top level parallel compositions prefixes annotated reduction creates new top level parallel composition label taken 
theorem subject reduction threadedness 
include extended annotated interactions 

consistent annotation consistent annotation 
proof 
easy rule induction generation rules 
noting consistent annotation derivation witnessing leads 
rule induction reduction rules 
easy induction reduction recursion rec implies rec rec induction thinning done 
capture local consistency directly typing system refine type discipline 
refined system offers simple inductive justification proposition 
augment typing follows add thread direction latest action thread 
judgement form refined typing 
operation combines information direction defined iff directions coincide common thread fails thread composition undefined 
replace wt init wt comm follows wt init topt ch wt comm ai topt ai op condition direction non trivial 
giving activity thread comes back inside thread starts input 
remaining rules stay shape refined typings 
easy check typability refined system directly entails global consistency theorem local consistency guaranteeing strict alternation direction interactions thread 
show inductively refined system type checks precisely terms original system establishing proposition 

type disciplines threadedness 
consider existence representative annotation threaded interaction 
say consistent annotation minimal renaming consistent annotation arises collapsing annotations 
example simplest possible case consider threaded interaction 
chc ch minimal annotation injective renaming collapsing labels reach chc ch chc ch collapse labels consistent chc ch formally notion minimal annotations defined follows 
definition minimal consistent annotation 
threaded 
consistent annotation minimal consistent annotation possibly non injective substitution thread labels 
type discipline inductively constructs minimal annotated interaction iff 
annotated inaction convenience time participant name writing sequent shape min typing finite sequence assignments form participant set session names 
demand formed sense induces finite map threads pairs obvious sense 
case write function induced maps 
case 
formedness automatically ensured inductively typing rules 
rules refine rules inductively solve simple equational constraints 
constraint distilled operator com rules 
operator defined follows 
wt wt min topt com fresh min ch min topt com fresh min op wt min topt min wt min ai topt ai com min wt wt si min ai topt ai dom dom com min si min ai topt ai dom dom com min wt ext min ei dom dom min wt ext min min wt mzero wt mvar min xa min wt min topt min rec 
typing rules inferring minimal consistent annotations 
definition collapsing operator 
formed partial operator com defined returns formed typing inductively follows 
com defined value 
calculate substitution finite map thread labels subset finite set session channels follows 
step set empty acting identity step find 
step set obtained step set new union original map new union results original values done 
go back step new check procedure terminates 
resulting wellformed com defined value takes component 
undefined 
com defined value com defined value com defined value 
com defined value write com 
equivalently step com finds minimum dom assigned ti ti intersects non trivially tj outside intersect com combines participant uses common session channel assignments collapsed assignment union 
notion common ness taken hereditarily threads certain participant assigned transitively common session channels eventually collapsed 
notation rules 
notation 
com 
result collapsing assignments write result mean result collapsing thread labels assigning resulting thread labels unions corresponding session channel sets 
strongly connected typed assume conform standard bound name convention rules generate annotates labelling inaction term variable distinct thread labels occurrences term variable thread label inductively inferring thread labels term subterm rules assuming defined 
choosing fresh thread labels base cases wt wt induction automatically generates unique annotated term resulting term unique 
write partial function resulting term defined 
proposition existence minimal consistent annotation 
strongly connected 
defined gives minimal consistent annotation sense definition 
threaded defined 
threaded iff defined 
proof 
show induction typability means typability corresponding typings modulo vacuous lacking paired type assignments needed formedness original typing system 
easy induction 
directly check satisfaction conditions means typability 
immediate 

theory point projection coherence 
threads 
connectedness threadedness shown analyse structure global interaction collection different threads compose 
words threads point calculus constituents processes interact realise original behaviour global description 
section offers step ongoing analysis explore consistently construct concrete processes threads 
concern immediately leads final structuring principle global description top strong connectedness 
observe necessary merge threads obtain endpoint behaviour realises global interaction 
instance consider parallel composition interactions 
ch op op ch op op annotate interaction know marked threads corresponding ch invocations 
point processes need merge threads process naturally demand service offered ch 
merging necessary threads show different behaviours chooses option op offers chooses option op offers 
project threads point processes ch op op ch op op spite having behaviours service behaviour consistently integrate threads single behaviour branching input ch op op op combined behaviour act prescribed global description output threads invokes ch 
ch op op ch op op easily observe composition induce original global behaviour 
similarly easily extract threads combine consistent 
similarly ch op op ch op op ch op op ch op op cases parallel composition sum conditional central cases need merge threads arises 
cases merge related threads coming single global description 
consider interaction focussing behaviour 
ch op ch ch 
project description point behaviour 
invoked service ch thread replies invoker completely different 
fact obtain slices instances behaviour description ch op ch ch 
hardly merged consistently 
need formal notion judge point behaviours consistently mergeable 
example tells descriptions different invocations service ch transformed point processes fact mergeable yield single coherent behaviour 
call relation 
definition 
relation denoted smallest reflexive symmetric relation typed processes closed rules 
pi qi op pj xk qk cong pi qi pn qn zero struct second rule assume pn qn typed 
third forth rules assume empty session typing free session names 
say mergeable 
observe non trivial clause branching input says common branch behaviour essentially identical subexpressions 
intuitively relation checks processes identical 
identical means brief behaviours contradict come course interactions branch selected interacting party 
rules say allow differences branches overlap demand pair behaviours operation identical 
rules say condition noted merged assuming contain open sessions 
necessary global description example sum session invocation specific channel occurs branch natural behaviour 
simplest case consider ch op case empty process right hand side thread right thread projected behaviour starts output thread projected replicated process service ch located want mergeable allow merged 
point behaviours mergeable technical sense merge obtain single process simulates behaviours combining missing branches 
instance process go 
process 
mergeable result merging simply go 
observe result directly combining threads ch op ch 
conform components parallel composition global descriptions 
formal definition merge operation 
definition merge operator 
partial commutative binary operator typed processes defined iff satisfying ch ch ch ch yi pi yi qi op op rec rec def ch def ch def yi pi qi yi pi yi qi def def def def op def def rec def def def def right hand side rule safely assume application operator say merge operator merges point behaviours 
order merging successful partial operation requires definedness processes related 
guarantees definedness right hand side expression 
rule defined consistent defined 
significant rule definition branching input 
inspect operands start yi operation opi appears terms terms prefix ti merged ensured mergeable assumption 
cases new branch added summation 

thread projection coherence 
consistently thread annotated interaction project threads point process 
thread projection partial operation merge operator 
defining thread projection add annotation recursion recursion variable 
rec annotated interaction set threads occurring initiated annotate recursion rec free xa added information unnecessary recursion endpoint processes convention annotated interactions 
henceforth range extended annotated interactions cf 
definition 
annotated interaction means extended annotated interaction 
definition thread projection 
consistently annotated additional annotation noted 
partial operation tp follows assuming line pairwise distinct undefined iff 
undefined 
tp tp opi ei xi tp tp tp tp tp tp rec tp tp def def def def def tp tp tp op tp opi xi tp tp tp tp tp tp tp tp tp tp tp tp def tp tp def tp tp 
def def def tp undefined set tp 
observation rec tp tp initialisation communication cases concerned thread coincides active thread case obtain corresponding output prefix concerned thread coincides passive thread case obtain corresponding input prefix applies case simply obtain projection remaining body lemma input output form 
assignment parallel composition conditional ifthenelse annotated single thread cases projecting thread coincides thread interaction simply carry constructors endpoint processes simply merge threads identity case assignment 
cases defined compositionally 
definition thread projection demands wish defined behaviours inside thread built consistently operator defined 
notion coherence includes definedness extends inter thread consistency 
need consider inter thread consistency arises description behaviour service replicated input distributed places global description 
case combine result projecting multiple threads code merge operation 
example recall projections seen page reproduce annotations 
ch op ch ch 
call interaction tp tp tp tp def ch op ch def ch op def ch ch def ch 
clearly ch op ch ch mergeable 
point coherence multiple threads constitute parts behaviour permanent service mergeable 
channel ch uniquely defines service collect threads contributing behaviour service passive thread session initialisation interaction ch 
formally set definition threads channels 
map tpc ch defined follows assuming ch ch 
tpc ch ch tpc ch ch tpc op ch tpc ch tpc ch tpc ch tpc ch tpc rec ch tpc ch tpc ch def tpc ch def tpc ch def tpc ch def tpc ch def tpc ch tpc ch def tpc ch tpc ch def tpc ch tpc ch def tpc ch def def tpc ch threads parts behaviour service 
input threads service channel equivalent 
channels indicates set service channels occurring definition 
threaded annotated interaction define equivalence class tpc ch ch channels tpc ch 
write exists definition coherence 
threaded consistently annotated interaction say coherent conditions hold thread tp defined 
pair threads tp tp 
say threaded non annotated interaction coherent annotation coherent sense 
example 
thread projection coherence interactions page page page coherent page 
annotated global description appeared section henceforth write annotated interactions 
def ch op description says possible paths interactions path happen 
initiate session interaction session completes 
projection referring definition tp tp def def sop note second simply sop 
unique thread service ch conclude coherent 
slightly complex example consider def ch op hello ch op goodbye ch op hi case projections tp tp tp tp tp tp def ch sop def ch sop def ch op def ch sop hello def ch sop goodbye def ch op hi immediately tp defined 
tpc ch tpc ch order coherent tp tp possible iff op op 
example section 
subject reduction coherence 
defined precisely unannotated interactions 
proposition subject congruence coherence 
partially symmetric associative identity 
defined iff defined defined iff defined suppose coherent 
consistent annotation thread 
implies tp tp 
suppose coherent 
implies coherent 
proof 
immediate definition noting rule definition definition defined conflicting branch thing defined 
rule induction generation 
typical case suppose associativity top thread observe 
tp tp tp tp tp tp done 
top thread interpreted associative annotated analogue done 
consider threads 
purpose observe definition definition apply rule definition validate rules 
thread projection thread defined defined similarly tpc ch tp tp iff tp tp 
observe lemma substitution lemma coherence 
rec coherent rec 
proof 
outline consider consistent annotation rec write def rec consider def 
exact substituting passive initial thread fresh thread number leave point implicit affect argument 
consider thread 
starts positive position passive position communication 
tp rec induction check tp rec 
including definedness 
thread merged threads done 
hand occurs passive complete thread inside meaning complete see proof theorem page 
note annotation rec thread projection turns substituted term just done thread projection letting tp ch obtain tp ch projection projection coincide 
note reasoning holds thread merged change required 
assume noted just theorem top level parallel compositions unannotated reduction takes annotations newly formed top level parallel compositions 
theorem coherence subject reduction 
coherent coherent 
proof 
check collection threads associated thread projections transformed collection respectively 
abuse designation say sets coherent 
show claim rule induction reduction rules 
claim coherent coherent 
result truncating threads adding zero collections fresh complete threads collection multiple copies complete thread existing 
copies created due recursion 
assume coherent 
init take head complete thread ch target merging anymore truncates active thread threads 
originally passive thread say active thread originally active thread say passive thread put demands intra thread merging thread projection originally 
merging remains done 
com truncate non complete threads active passive 
originally active thread say passive originally passive thread say active 
change inter thread merging know coherent 
assign truncates single active thread iftrue false sum simply cut threads par assume accordingly set respectively come 
assume reduces new threads assumption know may truncate threads may add copies existing threads fresh thread numbers 
affect done note intra thread remains definition projection top level parallel composition 
res change threads 
rec ih lemma possibly adding collections fresh copies complete threads 
struct immediate proposition 
decidable know proposition coherence validation 
consistently annotated algorithm returns true coherent false 
typability connectedness threadedness calculable shows algorithmically check untyped interaction coherent 
complexity checking typability connectedness threadedness linear complexity validation linear validation done 
believe possible certain normal forms 

main results epp theorem consequences 
projection 
section introduce formal definition endpoint projection establish properties 
henceforth say restriction free contains terms form subterm 
recall coherent entails typed strongly connected threaded 
definition point projection 
coherent interaction restriction free 
consistent annotation point projection denoted epp network 
part tp part denotes set participants mentioned section shall illustrate constructions involved definition works step step mapping concrete non trivial global description 
mapping definition defined choosing specific annotation interaction 
result shows map fact depend specific consistent annotation chosen far global description incomplete threads free session channels programmers designers usually produce 
proposition invariance annotations 
coherent consistent annotations 
epp epp 
proof 
coherent loss generality restriction free 
minimal consistent annotation existence guaranteed proposition 
possibly different consistent annotation definition minimality cf 
definition construction surjective map threads thread threads 
complete thread notion complete threads see proof theorem start unique service channel multiple thread labels 
incomplete 
free session means active thread starting session initialisation 
initial action thread different prefix prefix passive part thread label 
initial active thread prime interaction interaction prime decomposed non trivial top level parallel composition 
iai noting precisely syntactic structure infer tp def tp projection projections coincide 

need pruning 
main results shall establish says dynamics coherent global description exactly preserved reflected endpoint counterpart epp mapping introduced 
state result accurately need preparation 
consider simple global description 

epp interaction environment obtain network ch ch reduces reduces ch ch ch note results empty configuration service ch remains replicated 
note discrepancy reductions reduction endpoint behaviour epp global description reduction longer epp 
far active behaviour induce immediate reduction goes precise match far take replicated service garbage longer inside configuration exact match 
subtle example consider interaction ack go ack projection interaction omitting trailing ch acks go ch acks ch ack step takes left branch reduces configuration ack go corresponding reduction leads ch acks go ch ack gos take epp ch acks go ch ack go discrepancy original lost branch keeps 
realise lost branch inessential viewpoint internal dynamics resulting configuration branch 
summary global interaction lose information reduction kept corresponding reduction epp due persistent behaviour service channels 
motivates asymmetric relation shall state property point projection 
write fold composition replications 
definition pruning 
assume minimal typing 
write short say prunes 
writing simply fact lose precision reconstruct appropriate typings 
indicates result cutting unnecessary branches light typing 
fact typed strong bisimulation sense means precisely observable behaviours visible input actions pruned inputs branches replicated channels 
particular satisfies condition 
lemma pruning lemma 
strong reduction bisimulation sense 
transitive imply proof 
branches pruned contribute reduction 
noting prune minimal typing prune minimum typing surely take branches replicated inputs light minimal typing obtains 
just observed satisfies stronger property strong bisimulation typed transitions minimal typing left hand processes 

epp theorem consequences 
ready state main results 
write stored values follow typing obvious sense 
denotes result replacing occurrence type assignment say 
rec denotes equality induced unfolding process recursion note change behaviour strong bisimilarity 
theorem point projection 
assume typed strongly connected coherent 
assume 
properties hold 
type preservation minimal typing epp 
soundness epp exists epp rec 
completeness epp epp corollary 
assume coherent 
assume 
properties hold 
rec transitive closure rec 
error freedom epp communication error cf 

soundness multi step reduction epp exists epp rec 
completeness multi step reduction epp epp proof 
immediate theorem corollary page 
lemma theorem combined standard tiling argument induction example case theorem 
suppose statement holds reductions assume epp definition means epp 
ih exists epp 
rec immediately satisfies simulation property epp theorem epp transitive rec epp required 
observations results follow 

corollary indicates type check global description ensures coherent endpoint projections type errors mutual interactions 
gives basic form guarantee properties runtime static validation global descriptions 
potential properties validation include deadlock freedom livelock freedom various security properties 
corollary says interactions endpoint processes engaged steps take precisely correspondence specified original global description 
theorem corollary strengthen reduction simulation theorem corollary annotating reduction associated constructors 
op op similarly point calculus 
explicit action original global description corresponds action point projection 
rest section devoted proof theorem 
prove clauses 

proof theorem type preservation 
type preservation proved steps introducing inference system single thread annotated interaction written mini 
relate original minimal global typing thread global typing show mini iff exhausts threads 
relate thread global typing minimal typing thread projections establishing min iff result replacing 
relate minimal typing mergeable processes minimal typing result merging showing general statement min ipi pi pj start inquiry observation relates lub inclusion ordering global typing lub session subtyping endpoint typing 
definition equi input subtyping 
define relation closed types setting iff witnessing relation satisfying rules definition page replacing rule call equi input subtyping 
eq js opi js opi proposition equi input subtyping 
partial order types modulo 
implies 
upper bound upper bound 
lub lubs coincide 
proof 
standard essentially identical proof proposition 
noting difference input rule 
existence lub upper bound propositions 
part know upper bound upper bound 
take lub say input branches join output branches 
take upper bound say adds input branches surely take upper bound say may take input branches 
required noted carry step additional typing system annotated global description thread minimal typing specific thread 
sequent system written extended annotated interaction thread slightly refined types associate participant information session types directly reconstruct global types set types 
typing rules omit obvious inverse communication rules 
gt gt set mutually disjoint vectors session channels see proof proposition page noted terms treated subterms term free session channels groupings uniquely determined 
typing done fixing distinct type variable inaction typing starts 
gt mtinit gt mtinit denotes self denotes denotes active denotes passive similarly communication rules self denotes typing target thread involved interaction 
treatment recursion recursive variables follow minimal typing system figures illustrated page 
gt mtinit ch fn tvar ch ch gt mtinit ch fn tvar ch ch gt mtinit ch ch fn tvar ch ch gt mtinit ch ch fn tvar ch ch gt mtinit fc ch gt sa opj op gt sp opj op gt fc opj gt gt gt bool gt fsc fsc gt gt gt gt gt gt rec solve si si ai bi si fresh si ai bi 
threaded minimal typing rules global calculus write mina assume thread annotation conforms grouping session names cf 
proposition 
calculation done obvious way merge get 
proposition threaded typing interaction 
exhausts threads mina iff mina proof 
mina mina structural induction show typing inductively figures 
initialisation cases original minimal typing cases threaded typing 
gt mtinit correspond gt mtinit ih 
case gt mtinit inferred corresponding gt mtinit induction noting includes subset relation 
case corresponds gt mtinit immediate induction 
case communication case initialisation 
cases assignment restrictions inaction trivial typings change case 
conditional sum parallel composition immediate induction hypothesis closed 
show types inferred simultaneously min fully covers inferred mina induction 
matters gt mtinit gt mtinit gt gt shape typing differ 
case non threaded inference mina covered gt mtinit gt done 
results show mina coincide merging threaded inference mina proceed step outlined outset page 
purpose relate threaded typing global description minimal typing corresponding thread projection bridging global typing endpoint typing 
purpose observation 
consider typings specific grouping session channels uniquely determined term subterm complete term 
lemma 
assume replicated processes 
typable grouping session names 
minp 
proof 
induction generation rules definition corresponding rule definition 
non trivial case merging input branch 
yi pi yi qi 
merge defined yi pi yi qi def yi pi qi yi pi yi qi corresponds definition 
safely neglecting invariant part effect argument set opi 
js op 
assumption pi qi induction hypothesis pi qi type know type 
may assuming interactions services treated similarly rule session invocation definition 
proposition thread projection thread typing 
assume coherent consistent annotation 
mina implies changes polarity service channel typings needed result information participants type assignments 
proof 
induction coherent relate result typing min hand result tp definition page typing minimum typing page lemma 
gt mtinit consider case 
assumption induction hypothesis implies mtinit ch minc ha ch required 
similarly gt mtinit reasoned mtinit 
gt mtinit assumption ch entails induction hypothesis ch tp consider typing thread projection observe ch claim 
upper bound definition 
put session initialisation ch thread ch passive thread ch contributed ch preceding derivation existence ch base merged merge exactly outputs common sequence actions come inputs dual interactions 
claim proposition know ch tp required 
gt mtinit reasoned essentially identical argument 
gt mtinit gt sa gt sp gt easy ih 
example gt thread projection ignores prefix precisely definition 
gt assumption summand top threads thread consider cases case thread projection thread projection summands case thread projection 
case minimal endpoint typing service typing session typing 
output service typings assignments term variables trivially identical reasoning claim shows 
session typings consider interacting dual behaviour common session channels thread 
mergeable offer set output branches common reachable point course interactions dually corresponding types inputs point 
ih done 
case immediate lemma ih 
remaining cases gt reasoned gt rules gt gt gt immediate ih gt gt vacuous identical shape corresponding typing rules 
note proposition typing merged threads 
coherent assume ch tpc ch 
implies min tp proof 
immediate lemma note order merging matter proposition commutativity associativity 
prove theorem 
take consistent annotation assume threads assume include free term variables simplicity 
min min proposition 
proposition min tp consider contains threads server ch consider min min tp proposition gives replicated input ch 
min tp gives service typing ch zero client typings addition assignment variables required 

proof theorem soundness 
soundness observe lemma 
assume def 
pi 
proof 
immediate construction noting compatible 
coherent assume threads 
thread projections pi def tp gives indexed family processes pi 
pi strict associated process pi replicated input service channel subject 
replicated input needs merged replicated inputs service channel merged 
merged threads 
form partition quotient set thread projections partitions family pi pi 
pi pj pi pj replicated processes service channel merged endpoint projection 
endpoint projection result merging processes result ps placing participant set participants subsets belong epp def ps note reduction affected participants information far projected processes go redexes inter participants involves single participant 
legibility neglect participant information consider initial configuration epp def pi pi aggregates local stores assuming local variables distinct loss generality 
easily regroup processes state participants grouping affects dynamics lose generality 
show soundness reduction rules page adapted shape 
rules init com assign iftrue iffalse sum rec directly closing reduction contexts 
calling adapted rules names corresponding ones list rules note noted assuming variables globally distinct need local assignments 
denotes reduction context context hole prefix set 
init cr ch ch cr ch com cr iop xi qi opj cr assign cr cr iftrue cr cr tt sum cr cr rec cr rec cr rec omit iffalse follows iftrue symmetric case sum 
easily check rules give reduction relation incorporate participants 
reason induction height derivation reduction rules neglecting inferring induction reduction rules non trivial recursion cases base cases 
cases set nai ai prime non trivial parallel composition 
simplicity safely neglect hiding affect reduction consider nai 
note case endpoint projection start init 
redex pair input ch def ch qi ch 
qi ch qi output ch ch ch write reduction ch ch ch note neglecting participants legibility stipulated 
ch come thread 
active top level thread output cf 
definition page 
complete interaction say starts dual passive thread say passive thread starting initialisation ch thread projection ch qi ch 
write induces reduction ch nai term right hand side including note set threads possible longer occurs case safely stipulate exists 
consider thread projections 
tp tp 
tp tp note longer replicated process ch service channel passive input anymore 
replicated process service channel fresh thread freshness definition 
construct constructed collection sets processes replace ch 
lose ch ch qi obtaining ch qi add 
remains identical 
obtain endpoint projection neglecting participants stipulated ch qi 
compare right hand side result reducing epp lemma ch qi ch qi qi done 
com reduction endpoint projection written yi qi sop thread say sop sop start intermediate node top level active thread 
thread corresponding yi qi dual 
prime interaction starting threads 
write op fact know sum assumed singleton restrict attention sop sop top level immediate session communication direct endpoint projection passive thread singleton sum note ways 
sums conditionals non trivial sums arise usually case endpoint projections meaningful protocols 
concrete examples 
reduction nai construction tp tp merged threads start passive service initialisation remaining case precise correspondence result reducing epp precisely epp 
assign reduction shape means comes initiating active passive thread say interaction form precisely matched global reduction nai observing tp tp tp done 
iftrue write reduction evaluates true 
singleton thread know prime shape global reduction def nai note lost write corresponding initial active passive thread tp definition thread projection conditional tp suppose occur simplicity just consider consider thread projection occur ai remain invariant simply added parallel 
tp tp tp thread projection smaller tp tp projection threads remain identical know 
tp tp done 
iffalse iftrue 
sum original reduction means set def corresponding case iftrue tp rest identical reasoning iftrue 
rec reduction rec pi rec pi specify recursion terms coming recursion global process say rec know writing def pi rec pi mp reduction folded version mechanical check unfolded version corresponding reduction 
easily check inferred inference steps folded version 
observe assuming comes projection observe def tp rec unfolding increase fresh passive threads contains initialisation trans lated replicated processes change resulting processes exact copy passive thread exists noting 
induction know rec epp 
done 
concludes cases 

proof theorem completeness 
completeness induction derivation reduction global calculus 
consider adapted reduction rules taken modulo structural equality reduction contexts equivalent reduction rules page 
list adapted rules names original rules 
assume variables distinct including participants write write cr reduction context grammar interactions 
init cr cr comm cr op cr assign cr cr iftrue cr cr tt sum cr cr rec cr rec cr rec omit iffalse symmetric case 
note rules par res longer necessary absorbed rules 
application rules rules rec base cases 
reasoning obvious annotated version rules preserve thread labels reduction new top level parallel composition arises result reduction take label 
induction height derivations show epp epp rec proof soundness neglect participants information endpoint processes aggregate local states assuming local variables distinct 
simplicity abbreviate rec epp set nai ai prime interaction interaction contain non trivial top level parallel composition 
henceforth safely neglect 
set threads partition family thread projections threads 
write elements 
init set def ch consider reduction nai endpoint projection contains pair input output corresponding redex reduction ch def ch qi ch 
qi ch qi output ch ch ch write ch ch reduction ch ch ch exactly identical reasoning corresponding case proof soundness residual related way epp nai ch required 
comm assume loss generality def op consider reduction nai thread projection form sop branching singleton omit symbol similarly henceforth sop form sop loss generality cf 
proposition regard 
set epp sop sop epp update store safely done due stipulation local variables distinct 
reasoning corresponding case proof soundness know required 
assign set consider reduction epp nai sigma def 
nai appropriate thread projection shape tp reduction tp tp corresponding case proof soundness shows thread projections remain invariant aggregate projection precisely matches residual required 
iftrue set reduction def nai observing tp def tp tp reduction endpoint projection tp tp evaluates true 
reasoning corresponding case soundness proof may contain replicated inputs result merging complete threads obtain epp nai tp required 
iffalse sum similarly reasoned 
rec def rec assume nai reduction comes recursion rule rec endpoint projections form epp def collection replicated processes replicated shape def rec pi 
consider endpoint projection unfolding epp rec def pi note right hand side times unfoldings 
induction hypothesis applying recursion rule endpoint processes times obtain epp epp nai required 
exhausts cases establishing completeness 
concludes proof theorem 

example endpoint projection 
example endpoint projection illustrate formal notion introduced preceding sections 
fairly large toy example involving participants 
explain example english introduce description global calculus project description endpoint processes 
global description english 
example extension buyer seller example introduced section 
participants involved protocol buyer seller vendor cc rm protocol proceeds follows buyer requests service check credit checker sending name 
point give positive negative answer 
answer positive buyer asks seller quote product prod seller asks vendor service chv seller starts recursion asks vendor quote product prod vendor replies quote quote seller forwards quote buyer increasing units quote quote reasonable reasonable quote buyer sends seller confirmation credit cred ii seller contacts checking credit iii credit seller contacts shipper service seller sends delivery address shipper sends confirmation seller forwards confirmation buyer iv credit bad tells buyer buyer tells seller terminating protocol quote reasonable protocol goes back point answer negative protocol terminates 
global description calculus 
global description consists components readability 
directly give annotated interaction 
main description line 
cc cc ack 
cc 

cc 

cc bad 

ack 
prod prod 
chv 
ack 
rec 
prod prod 
quote quote 
quote quote 
reasonable quote 
cred cred 
cc 

cc ack 
cc cred adr cred adr 

cc 

cc bad 



line 
chr 
ack 
deliv adr adr 
conf 
conf check descriptions typable strongly connected threaded coherent 
connectedness uses lot acks 
discussed long version acks fact unnecessary relaxed notion connectedness 
point projection global interaction 
definition epp project global description thread 
buyer thread 
tp ack chs ack prod rec quote reasonable quote cred bad conf note thread starts recursion go inside global recursion 
projected endpoint behaviour contains recursion 
projection thread note participant threads 
tp ack bad note recursion involved thread projection simply thread occur inside recursion 
jump thread component 
tp ack cred adr bad note process include recursion 
inside recursion initiates new thread 
result code identical projection thread 
move projection unique thread seller thread 
tp chs ack prod chv ack rec prod quote quote cred ack cred adr chr 
ack deliv adr conf conf bad thread starts outside recursion global description inside recursion recursion variable leading recursive behaviour process 
note session functions way handle recursion appropriately epp 
projection unique thread vendor follows 
tp chv ack rec prod quote projection thread giving simple behaviour 
tp chr 
ack deliv adr conf thread noon contain recursion fully inside global recursion initiating thread 
noted threads belong class equivalence part service channel 
means merge threads final epp 
applying merge operator noting evidently mergeable get process ack cred adr 
bad 
bad arrived endpoint behaviours participants realising original global description 
projection works linear usage channels inside session service channel principle structuredness conditions 
believe business protocols conform conditions modulo relaxation connectedness discussed long version 
conditions extended disciplined ways allow protocols involving exceptions treated theory interesting subject studies 

epp example 
consider slight modification interaction considered strong connectedness property buyer seller sch 
seller buyer 
buyer seller 
seller buyer quote xquote 
buyer seller quotereject buyer seller quoteaccept 
seller buyer buyer seller seller shipper 
shipper seller 
seller shipper buyer shipper seller deliverydetails dd 
seller buyer deliverydetails note basically added interactions just keep interaction strongly connected 
give encoding buyer sch xquote 
quotereject quoteaccept deliverydetails seller sch quotereject quoteaccept buyer deliverydetails deliverydetails shipper deliverydetails dd 
extension applications 
local variable declaration 
consider extensions applications theory epp 
augment syntax global local calculi useful construct local variable declaration newvar newvar construct indispensable especially repeatedly invocable behaviours services 
suppose invoked buyers simultaneously asking quote different book 
threads share variable requests get confused 
local variable declaration avoid confusion 
dynamics typing construct standard 
endpoint projection treated just assignment 

intra participant interaction 
demanded grammar service typing 
means typed global terms intra participant interaction 
natural assumption business protocol primarily specifies inter organisational interactions restrictive contexts 
connectedness definition change easily adapt epp theory inclusion intra participant interactions 
typing rules table page takes refines typing reflects direction interaction just inferred 
allows treat case equal demand interacting parties distinct threads 
key change threadedness 
condition session consistency definition problematic know threads participant 
stipulating local causality condition definition page solves ambiguity 
reproduce condition 
local causal consistency downward sequence actions starts active thread ends action occurs time occurs intermediate actions sequence occurs passively 
note proposition condition consequence theory interaction adding extra constraint inter participant interactions 

name passing 
extension technically significant practically useful channel passing 
channel passing essential business protocols 
example consider refinement buyer seller protocol 
buyer wants buy hardware seller buyer knows seller address net know seller service channel 
thing buyer knows service channel hardware send back address seller buyer turn interacts seller obtained channel 
situation buyer prior knowledge seller channel participant 
global description including typing participant names play basic role 
leave name participant channels unknown consistent epp theory 
open problem left ws cdl current specification allows channel passing fixed participant 
restrict attention service channel passing excluding session name passing poses additional technical issue 
level endpoint calculus suffices channel passing standard calculus 
describes initial behaviour buyer 
note imperative variable reads content uses communication 
typing rules extended accordingly 
global calculus introduce syntactic variable called participant placeholder denoting anonymous participants 
example write newly added intuitively says op starts session session names service channel stored location participant service offered left unknown placing placeholder instantiated variable inspected 
example evaluated ch store interaction takes place ch example buyer seller directory scenario discussed buyer directory 
directory buyer sell amazon uk 
buyer xs buyer ok data buyer directory directory buyer sell hardware uk buyer xs buyer ok data note depending channel sent directory assigned different participants 
dynamics global calculus adds rule infers ch types extend basic types 
add obvious extension syntax types typing rules extended deal terms containing participant variable manner 
epp theory need change notion connectedness 
annotate placeholders regarding start new thread annotate fresh 
definition threadedness remains 
coherence needs additional consideration 
variable store different channels different participants 
purpose typing system records possible set assignment shape set channels may instantiated concrete channel behaviour channel constrained coherence 
set inferred starting fixed set adding ch ch infer opj ch wi participants placeholders 
give flavour extension works point projection example 
consider annotated interaction placeholders 
buyer xs buyer ok data projection thread placed hole substituted appropriate service channels 
tp 
ok data checking coherence consists updating definition function threads induces thread equivalence classes 
equivalence classes threads belong 
prediction possible values assume runtime amazon uk hardware uk 
sure thread belongs tpc tpc hardware 
point projecting amazon uk substitute thread projections point projecting uk substitute hardware 

conformance 
relating global descriptions local counterpart theory allows best rich results study process calculi 
application conformance checking dynamic variant runtime monitoring discussed section 
purpose formal criteria say communication program conforms global specification process algebras conformance checking verifies behaviour process follows specification representable process 
theoretical basis notion conformance behavioural theories inverse simulation bisimulation 
context purpose verify implemented system say conforms typed description global calculus 
point projection reduce problem conformance endpoint processes allowing standard theory 
illustrate basic instance 
conformance checking consider starts type information 
global description participant behaviour interested 
epp program supposedly implements specification participant point projection generates process typing coincides original global description check typed minimal typing associated conform know typing conforms proceed validation behavioural conformance 
example quote may configuration accept reject buyer seller quote accept reject restart suppose wish check behaviour buyer conforms global specification follows 
buyer seller 
seller buyer quote buyer seller accept buyer seller reject seen point projection specification follows 
buyer quote 
accept reject seller quote accept reject endpoint process inhabiting buyer check typability quite easily sense typable minimal typing example minimal type channel quote int accept null reject null call type 
minimal type channel type assignable ch 
second basis typedness check conformance behaviour typed transition relation 
transition consider sequent form framework typed sense consider actions deemed possible 
particular specifies input branches inputs extra branches take place 
write standard weak transition abstracting silent transition 
define conformance relation include typability fix appropriate grouping free session channels 
say type relation typed terms endpoint calculus weak conformance iff minimal typings implies 
weak conformance say conforms 
apart typability conformance says visible behaviours specified 
check conforms sense 
conformance safety depending application needs may stringent notion conformance 
summary global description consisting participant participants 
suppose program implements behaviour 
check conformance specification projecting call check conforms conformance relation noted 
conformance may checked hand calculation coinduction model checking mechanical syntactic approximation runtime monitoring 

related 
global descriptions communication behaviour 
far know typed calculus global description communication behaviour integrated theory endpoint projection 
global methods describing communication behaviour practiced different engineering scenes addition ws cdl intended serve theoretical underpinning 
representative examples include standard notation cryptographic protocols message sequence charts msc uml sequence diagrams 
notations intended offer useful aid design specification stage offer full fledged programming language lacking standard control structures value passing 

global descriptions communication behaviour 
stands distributed consensus independently conceived predates ws cdl notation global description programming internet applications introduced studied fully expressive language representing interactions global method 
chooses programming primitives close user experience web web server invocation email web form filing general communication primitives 
semantics mscs direct operational semantics 
session types channel typing 
analogue theory endpoint projection developed context 

global descriptions communication behaviour 
petri nets may viewed offering global description useful specification analytical tool 
example study van der aalst presents analysis business protocol showing description inter participant business protocol implemented inside participant losing causal constraint represented petri nets 
quite different formal apparatus motivations shares technical interest analysis section causality analysis interactions 
current lack notions types petri nets may hard carry analogue full constructions done heavily rely types 

type disciplines concurrent programming languages 
shares works direction structured communication centred programming types 
pict programming language calculus rich type disciplines including linear polymorphic types come studies types calculus discussed paragraph 
polyphonic uses type discipline safe sophisticated object synchronisation 
dezani gay vasconcelos studied interplay session type disciplines different programming constructs program properties 
epp theory offers passage studies endpoint languages calculi reflected global descriptions demonstrated session types 
context session types extends session structure multiple session names useful having parallel communications inside session 

theories types calculus 
theories types calculus studied 
addition study session types mentioned include input output types linear types various kinds behavioural types include causality combination behavioural types model checking advanced behavioural analysis name 
behavioural types offer advanced analyses phenomena deadlock freedom 
currently studying advanced type validation techniques basis simple session type discipline lead effective validation techniques 
theories applicable global descriptions link established epp theory 

process calculus analysis web service 
gordon fournet corin studied security related aspects web services series works origin lies spi calculus applied calculus 
authors implemented part ws security libraries dialect ml shown annotated application level usage security libraries web services analysed respect security properties translation calculus 
benefits tool reflected global descriptions theory epp applying tool projections 
laneve padovani give model web services extensions calculus join patterns 
propose typing system guaranteeing notion smoothness constraint input join patterns subjects channels located order avoid classical global consensus problem communication 
reflecting centralised nature orchestration cf 
footnote global calculus endpoint projection considered 
bisimulation correspondence choreography orchestration context web services studied busi notion state variables semantics orchestration model 
operationally relate orchestration 
strong type systems disciplines point projection studied 
provide formal foundation ws cdl process calculi studied inception ws cdl 
example suggested fusion calculi foundation fusion calculi formally equivalent calculus representative name passing process calculi 
name passing calculi expressive power including calculus fusion calculi formalisms endpoint processes choice imperative refinement calculus resent merit direct transparent correspondence global formalism endpoint formalism 
semantic preserving encoding applied version calculi pure calculus pure name passing calculi including fusion calculi interesting topic study 
bibliography abadi fournet 
mobile values new names secure communication 
popl proceedings th acm sigplan sigact symposium principles programming languages pages new york ny usa 
acm press 
abadi gordon 
calculus cryptographic protocols spi calculus 
information computation jan 
amadio boudol 
receptive distributed pi calculus 
proc 
fst tcs volume lncs 
springer verlag 
baeten van beek 
specifying internet applications 
sac pages 
benton cardelli fournet 
modern concurrency abstractions 
acm trans 
program 
lang 
syst 
berger honda yoshida 
sequentiality calculus 
proc 
tlca 
berger honda yoshida 
genericity pi calculus 
proc 
fossacs 
bergstra klop 
algebra communicating processes 
theoretical computer science 
berry boudol 
chemical machine 
tcs 
fournet gordon 
verified implementations ws security protocols 
appear ws fm 
blanchet 
efficient cryptographic protocol verifier prolog rules 
csfw pages 
gunter 
correspondence assertions process synchronization concurrent communications 
journal functional programming 
brown 
post pi soa forum 
october 
busi gorrieri zavattaro 
choreography orchestration conformance system design 
coordination volume lncs pages 
nielsen sassone 
calculus trust management 
proc 
fst tcs volume lncs pages 
springer verlag 
coppo 
type inference recursive types syntax semantics 
inf 
comput 
chaki rajamani rehof 
types models model checking message passing programs 
popl pages 
dezani ciancaglini yoshida drossopoulou 
session types object oriented languages 
proceedings ecoop lncs 
gay hole 
subtyping session types pi calculus 
acta informatica nov 
gunter 
semantics programming languages 
mit press 
hennessy 
resource access control systems mobile agents 
proceedings volume entcs pages 
elsevier science publishers 
hoare 
communicating sequential processes 
prentice new york 
honda 
composing processes 
proceedings popl pages 
honda vasconcelos kubo 
language primitives type discipline structured communication programming 
esop pages 
springer 
honda yoshida berger 
control calculus 
proc 
fourth acm sigplan continuation workshop cw 
huet 
dans les langages ordre 

tat universit paris paris france 
igarashi kobayashi 
generic type system pi calculus 
popl pages 
international telecommunication union 
recommendation message sequence chart 

post petri pi mailing list 
august 
kobayashi pierce turner 
linear types calculus 
proceedings popl pages 
laneve padovani 
smooth 
fossacs lncs pages 
milner 
calculus communicating systems volume lecture notes computer science 
springer berlin 
milner 
functions processes 
mscs 
milner 
polyadic calculus tutorial 
logic algebra specification 
springer verlag heidelberg 
milner parrow walker 
calculus mobile processes ii 
information computation sept 
milner tofte harper 
definition standard ml 
mit press 
needham schroeder 
encryption authentication large networks computers 
commun 
acm 
omg 
unified modelling language version 
parrow victor 
fusion calculus expressiveness symmetry mobile processes 
lics 
pi soa 
www pi soa org 
pierce 
types programming languages 
mit press 
pierce sangiorgi 
typing subtyping mobile processes 
mathematical structures computer science oct 
pierce turner 
pict programming language pi calculus 
proof language interaction essays honour robin milner 
mit press 
rajamani rehof 
conformance checking models asynchronous message passing software 
cav pages 
ross talbot fletcher 
ws cdl primer 
unpublished draft may 
sangiorgi 
name discipline uniform 
icalp volume lncs pages 
sangiorgi 
modal theory 
icalp 
takeuchi honda kubo 
interaction language typing system 
parle volume lncs pages 
van der aalst 
inheritance interorganizational workflows agree disagree loosing control 
information technology management journal 
vasconcelos gay 
session types functional multithreading 
concur lncs pages 

choreography description language cdl web services choreography working group 
www org ws chor 
ws cdl working group 
web services choreography description language version 
www org tr wd ws cdl 
winskel 
formal semantics programming languages 
mit press 
gardner 
explicit fusions 
theor 
comput 
sci 
yoshida berger honda 
strong normalisation calculus 
proc 
lics pages 
ieee 
full version appear journal inf 
comp 
appendix appendix subject reduction global calculus type system appendix establishes subject reduction typing system global calculus theorem 
go intermediate results 
note lemma 
substitution 
substitution 
proof 
proof direct typing rules 
immediate typing rules 
prove main theorem section 
theorem 
subject congruence 
subject reduction assume 
imply 
subject reduction assume 
imply proof 
shall prove induction structural congruence rules 
proof trivial cases define commutative monoids 
suppose 
rule 
rule apply getting cases tres tres tres 
analyse similar 
apply tres exists 
applying rule prove defined 
defined linearity respected adding assumption fn fn 
proof concludes applying rule tres 
order prove shall prove stronger result imply statements true refer reduction types op 
note fsc fsc 
proof proceeds induction depth derivation 
basic cases 
comm 
hypothesis op op 
applicable rules 
cases similar shall inspect 
js op init 
ch ii 
applying rule ch ch ch ch 
applying rule tres repeatedly ch rule tres get ch 
rec 
rec rec rec 
applicable rule trec implies 
lemma rec 

semantics rule follows hypothesis 
applying rule 

similar previous case 
sum 
similar previous case 
assign 

applying rule get 
inductive cases 
par 
rule assume get 
exist applying rule 
induction hypothesis follows exists proof trivial 
possible prove preserves linearity respects linearity merged type 
struct 
follows point theorem 
res 
case possible cases typing restriction analyze rule tres cases similar 
applying rule induction hypothesis possible cases apply rule tres get 

applying rule tres get 
trivially get 
easy prove previous point 
appendix subject reduction point calculus type system give proofs point calculus type discipline 
mainly give proofs theorem 
proposition 
formedness implies formed 
weakening assume formed 
implies 
weakening formed fresh 
implies 
thinning assume fc fn 
implies 
subsumption ch ch subsumption 
proof 
induction typing rules 
proof similar global case 
proof proceeds induction typing rules 
need prove result holds processes implies 
case proof proceeds induction typing rules 
able prove result network 

rule 
proved rule 
nw 

induction hypothesis get rule nw get tres nw tres nw weak nw weak nw 
similar previous case 
proof proceeds induction typing rule 
previous proof need prove similar processes 
induction typing rules 
induction typing rules results direct consequence rules typing communication 
induction typing rules 
similar previous case 
give proof proposition 
proposition 
existence minimal typing minimal service typing vectors free session channels implies proof 
outline typing know session channels abstracted initialisation actions 
reason know grouping bound session channels determining uniquely vectors types types arbitrary grouping session channels 
starting inductively construct minimum typings syntax second clause simple generalisation note grouping free session channels construct typing 
proof lemma 
lemma 
proof 


trivial typing rules 
proof similar global case induction typing rules 
proof lemma lemma 
subject congruence 
proof 
rule induction generation rules 
main theorem section 
theorem 

proof 
standard lemma 
appendix alternative inference algorithm threadedness show simple algorithm inductively infer consistent annotation interaction informs failure doing 
notations 
indicates sequence thread assignments session assignment form intuitively indicates communications done thread 
write concatenation strings occurs 
definition annotating function 
annotating function partial function maps pair thread assignment typed strongly connected interaction initiating participant corresponding annotated interaction defined inductively follows 
line choose fresh incrementing maximum thread 
ch op rec def ch fresh def op def def def def def def rec function defined 
set typed strongly connected unique initiating participant contain hiding free session channels def top 
communication case condition guarantees choice unique 
thread assignment contains redundancy containing identical occurrences thread assignment readability clauses annotating functions 

