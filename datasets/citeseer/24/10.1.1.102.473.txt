mercury supporting scalable multi attribute range queries ashwin bharambe agrawal srinivasan seshan january cmu cs school computer science carnegie mellon university pittsburgh pa presents design mercury scalable protocol supporting multi attribute searches 
mercury differs previous range query systems supports multiple attributes performs explicit load balancing 
efficient routing load balancing implemented novel light weight sampling mechanisms uniformly sampling random nodes highly dynamic overlay network 
evaluation shows mercury able achieve goals logarithmic hop routing near uniform load balancing 
show publish subscribe system mercury protocol construct distributed object repository providing efficient scalable object lookups updates 
providing applications range query language express subscriptions object updates mercury considerably simplifies distributed state management 
experience design implementation simple distributed multiplayer game built top object management framework shows indicates useful building block distributed applications 
keywords range queries peer peer systems distributed applications multiplayer games building scalable peer peer networks concentrated distributed hash tables dhts :10.1.1.140.3129:10.1.1.28.5987:10.1.1.105.3673
dhts offer number scalability advantages previous systems napster gnutella including load balancing logarithmic hop routing small local state 
hash table exact match interface offered dhts fruitfully systems flexible applications 
example unclear dhts applied regain highly desirable flexibility offered lookups file sharing applications 
main contribution design evaluation mercury scalable routing protocol supporting multi attribute range queries 
model query conjunction ranges attributes 
attributes query assumed wildcards 
believe range queries significantly enhance search flexibility number scenarios 
addition useful answering user queries find range queries useful construction distributed applications 
publish subscribe system mercury show application flexibly scalably manage updates queries distributed application state 
design testbed evaluation distributed multiplayer game built framework 
number systems proposed distributed protocols support range queries :10.1.1.14.7680:10.1.1.118.8846
mercury mainly differs systems supports multi attribute range queries explicit load balancing 
main components mercury design 
mercury handles multi attribute queries creating routing hub attribute application schema 
routing hub logical collection nodes system 
queries passed exactly hubs corresponding attributes queried new data item sent hubs associated attribute 
ensures queries retrieve relevant data items system 
second supporting range queries mercury organizes routing hub circular overlay nodes places data contiguously ring node responsible range values particular attribute 
notion circular overlay similar spirit existing dht designs mercury randomizing hash functions placing data 
supporting range queries mercury requires data placed contiguously 
requirement introduces fundamental challenge mercury hash functions data partitioning nodes non uniform explain section requiring explicit load balancing mechanism 
load balancing mechanism fundamentally incompatible techniques dhts guarantee routing efficiency 
solution challenges forms core contribution 
interesting algorithms incorporated mercury include message routing algorithm supports range lookups routing hub log node maintains links nodes 
low overhead random sampling algorithm allows node create estimate system wide metrics data value load distribution 
load balancing algorithm exploits random sampling algorithm ensures routing load uniformly distributed participating nodes 
algorithm reducing query flooding estimating selective predicates query past database insertions 
addition describing design mercury explore added flexibility provided range query lookups simplify construction distributed applications especially state management tasks applications 
observe instance distributed application single point time typically interested small subset entire application state 
subset typically random objects related manner 
example instance distributed multiplayer game player interested virtual entities room arena 
show range query system built top mercury provide efficient scalable management distributed object updates lookups :10.1.1.100.2117
believe range query significantly enhances application ability accurately express interests 
proof concept system implemented simple multi player distributed game publish subscribe object repository framework outlined 
player game subscribes region game near ship 
result messages needed update particular player screen automatically delivered host 
testbed evaluation indicates mercury reduces bandwidth usage implementing effective filtering provides low routing hop delivery applications 
remainder organized follows 
section compare mercury prior related area 
section details basic mercury protocol routing data records queries 
section presents enhancements improve performance basic protocol 
section evaluate scalability load balancing properties mercury system 
section design publish subscribe object repository framework proof concept distributed game 
section concludes 
related section compare contrast approach implementing range queries related systems 
discussion focuses fundamental questions existing dhts building blocks implement range query predicates 
design different systems skipnet provide range query support :10.1.1.118.8846
existing dhts range queries large number distributed hash table designs proposed past years :10.1.1.140.3129:10.1.1.28.5987:10.1.1.105.3673
provide hash table interface application viz insert key value lookup key primitives 
research shown addition basic scalable routing mechanism dhts offer promise terms load balancing proximity routing static resilience natural question ask implement range queries just insert lookup abstractions provided dhts :10.1.1.3.8344
analysis analyzing possible strawman designs dhts indicates abstractions provided dht implementing range queries 
fundamental say application instance interested object wishes keep updated state 
argument fact existing dht designs randomizing hash functions inserting looking keys hash table 
hashing crucial dhts order get load balancing properties main barrier dht implementing range queries 
hash range correlated hash values range 
necessary create artificial correlation ranges values invariant hashing 
natural way achieve partition value space buckets map values ranges buckets 
bucket forms lookup key hash table 
range query satisfied simply performing lookups corresponding bucket underlying dht 
scheme fundamental drawbacks 
requires application priori perform partitioning space 
difficult impossible applications partitioning file names 
load balancing query performance highly dependent way partitioning performed 
example number buckets small partition coarse queries get mapped smaller set nodes creating load imbalance 
increasing number buckets hand increase routing hops required answer range query 
indicates dht scheme may impossibility implementation awkward complicated 
avoiding randomizing hash functions mercury seeks remove difficulty 
time note design mercury inspired similar respects existing dht designs 
believe easily build advances proximity routing achieving resilience dhts 
comparison systems supporting range queries section compare mercury systems offer range query support 
include skipnet pier dim :10.1.1.14.7680:10.1.1.118.8846
skipnet dht organizes peers data objects lexicographic addresses form variant probabilistic skip list 
supports logarithmic time range lookups guarantees path locality 
mercury general skipnet supports lookups multiple attributes 
random sampling estimate query selectivity constitutes novel contribution implementing scalable multi dimensional range queries 
load balancing important way mercury differs skipnet 
skipnet incorporates constrained load balancing mechanism useful part data name hashed case part inaccessible performing range query 
implies skipnet supports load balancing range queries 
argue query load imbalance skipnet corrected virtual servers suggested 
help regard reason effective load balancing number virtual servers needed proportional skew ratio max min load 
scheme proposed assumes load skew results standard deviation random hash function distributions typically small log see 
case skew results differences query workload grow quite large 
larger number virtual servers required increasing routing hops log skew 
scheme fare worse range lookups increase number distinct nodes accessed processing query 
pier system distributed query engine dhts 
queries exact match lookups uses multicast primitive performs controlled flood query nodes particular namespace 
dim data structure supports routing multi dimensional range queries embedding dimensional space geographic routing algorithm 
routing cost scales reasonable medium sized sensor network quite expensive larger scales 
furthermore volume expansion occurs projecting higher dimensions dimensions quite large resulting flooding query 
queries containing wildcards certain attributes get flooded nodes 
hand mercury databases uses query selectivity mechanisms route attribute hubs highest selectivity significantly reducing flooding queries containing attributes 
systems balancing load systems treat load node proportional range identifier values node responsible 
words assume uniform data distribution sensible dhts cryptographic hashes 
mercury hand defines load node number messages routed matched unit time supports explicit flexible load balancing 
note mercury uses leave join style load balancing algorithm similar 
karger ruhl independently discovered similar join leave load balancing mechanism 
protocol requires communication log random nodes system 
face skewed node range distributions sampling nodes uniformly random far trivial 
significant part mercury protocol aimed addressing difficulty 
general approaches diffusion dynamic load balancing hard get information dynamic distributed network informed decision 
mercury uses light weight sampling mechanisms track load distribution overlay 
mercury routing section provide overview basic mercury routing protocol 
note basic routing works limited set conditions 
section significantly extend capabilities basic routing wider set operating points 
data model mercury data item represented list typed attribute value pairs similar record relational database 
field tuple form type attribute value 
types recognized int char float string 
query conjunction predicates tuples form type attribute operator value 
disjunction implemented multiple distinct queries 
mercury supports operators 
string type mercury permits prefix postfix operators 
presents example 
basic data types enabling define numeric operations addition subtraction 
care needs taken handling string attributes 
float float string string coord coord player john team int score data float float string int coord coord player score query example data item query represented mercury system 
routing overview mercury supports queries multiple attributes partitioning nodes system groups called attribute hubs 
partition logical physical node part multiple logical hubs 
attribute hubs responsible specific attribute schema 
hubs thought orthogonal dimensions multi dimensional attribute space 
routing hop determines dimension route 
rest routing unidimensional values single attribute data item 
note mechanism scale number attributes schema increase believe schemas applications reasonably small 
simplify description notation denote set attributes schema application 
aq denotes set attributes query similarly set attributes data record denoted ad 
functions denote value range particular attribute data record query denote attribute hub attribute ha 
nodes hub ha arranged circular overlay node responsible contiguous range ra attribute values 
node responsible range ra resolves queries ra stores data records ra 
ranges assigned nodes join process 
routing queries data records queries passed exactly hubs corresponding attributes queried 
specifically query delivered ha attribute chosen aq 
see sections choosing attribute hub suffices matching correctness substantial savings network bandwidth achieved choice done intelligently query selectivity 
chosen hub query delivered processed nodes potentially matching values 
guarantee queries locate relevant data records data record insertion sent hb ad 
necessary set queries match arrive attribute hubs 
hub data record routed node responsible record value hub attribute 
notice ensured correctness sending data record single hub ad queries hubs aq 
glance appear better choice data records bigger size queries replicating expensive 
recall query get flooded multiple locations hub depending selectivity 
combined fact queries may extremely non selective attribute flooding particular hub led choose design data records broadcast hubs 
mercury easily modified support situation problem exist 
hub ha routing done follows routing data record route value 
query range 
routing queries route value appearing range contiguity range values spread query circle needed 
int int int int query data item int int routing data records queries 
fig illustrates routing queries data records 
depicts hubs hx hy may correspond example coordinates objects 
minimum maximum values attributes respectively 
accordingly ranges distributed various nodes 
data record sent hx hy stored nodes respectively 
query enters hx node routed processed nodes routing places additional requirement connectivity node 
addition having link predecessor successor hub node maintain link hubs 
expect number hubs particular system remain low expect significant burden 
discuss maintenance links section 
design rationale section discuss promising alternative designs implementing distributed multi attribute range search comment qualitatively trade offs involved 
dhts cryptographic hash random value give ids nodes data stored dht :10.1.1.13.1630:10.1.1.105.3673
mercury cryptographic hashes random values 
simpler mapping data nodes system allows lookup range predicates subscriptions collection contiguous nodes hub 
note main purposes cryptographic hash existing dhts assign data nodes uniformly randomly elimination randomness load balancing mercury concern 
particular ranges attribute popular publications subscriptions nodes responsible ranges unfairly overloaded routing computation tasks 
mercury performs explicit load balancing see section moving nodes changing responsibilities loads 
enables combination load balancing support range predicates important side effect distribution range sizes longer guaranteed uniform 
removal cryptographic hashes variety different dhts basis design 
design treats different attributes application schema independently routing data item hub attribute accomplished 
alternate design route values attributes treating attribute dimension :10.1.1.140.3129
node design responsible value range attribute subscription contains wild card attribute get flooded nodes 
merged dimensions dim data structure similar problems queries covering large areas 
making attributes independent restrict flooding attribute hub 
furthermore quite attribute query selective routing query hub eliminate flooding altogether 
constructing efficient routes recall routing mercury occurs attribute hub hop crosses hubs 
essential overlay structure attribute hub scalable efficient 
simply successor predecessor pointers result routing delays routing queries 
symphony key mercury route optimization selection long distance links maintained addition successor predecessor links :10.1.1.13.1630
result node routing table size including neighbors circle 
configurable parameter different different nodes 
routing algorithm simple neighbor ni charge range li ri 
node asked route value chooses neighbor ni li minimized denotes clockwise distance value distance 
ma ma minimum maximum values attribute respectively 
ma ma node value range constructs long distance links fashion denote unit interval 
link node draws number harmonic probability distribution function pn log 
contacts node routing protocol manages value ma ma wrapped hub 
attempts neighbor 
practical consideration set fan limit links node 
refer network constructed algorithm network 
self certifying names security additional valuable properties 
assumption node ranges uniform prove see expected number routing hops routing value hub log :10.1.1.13.1630
inter hub routing take hop number hops taken routing log 
guarantee kleinberg analysis small world networks 
unfortunately uniform node ranges assumption easily violated reasons 
example explicit load balancing cause nodes cluster closely parts ring popular 
section novel distributed histogram maintenance scheme light weight random sampling provide efficient routing highly non uniform ranges 
caching applications significant locality generated data items incremental updates example queries popular searches example 
mercury provides hooks application insert specific caching behavior protocol 
essentially mercury allows application specify additional long distance links represent cached destinations addendum routing table 
looking neighbor closest destination mercury considers nodes cache 
node join leave describes steady state behavior mercury address nodes join leave system 
section describes detailed protocol nodes join departure 
recall node mercury needs construct maintain set links successor predecessor links attribute hub long distance links efficient intra hub routing cross hub link hub connecting hubs 
link implies node knows representative hub system 
order recover node departures nodes keep small number successor predecessor cross hub links 
node join 
distributed overlays incoming mercury node needs information node part routing system 
information obtained match making server band means 
incoming node queries existing node obtains state hubs list representatives hub system 
randomly chooses hub join contacts member hub 
incoming node installs predecessor takes charge half range values part hub circle 
start new node copies routing state successor including links links nodes hubs 
point initiates maintenance processes firstly sets long distance links routing newly sampled values generated harmonic distribution described 
secondly starts random walks hubs obtain new cross hub neighbors distinct successor notice processes essential correctness affect efficiency routing protocol 
node departure 
nodes depart successor predecessor links long distance links inter hub links mercury repaired 
repair successor links query count number routing hops reach value range covers 
hub node maintains short list contiguous nodes clockwise ring immediate successor 
node successor departs node responsible finding node ring creating new successor link 
node departure break long distance links set nodes hub 
nodes establish new long distance links replace failed ones 
nodes directly affected departure take action 
departure nodes distort distribution links nodes affected directly 
repair distribution nodes periodically re construct long distance links estimates node counts 
repair initiated number nodes system changes dramatically factor addition departure 
repair broken cross hub link node considers choices uses backup cross hub link hub generate new cross hub neighbor random walk desired hub backup available queries successor predecessor links desired hub worst case node contacts match making bootstrap server query address node participating desired hub 
efficiency face non uniformity mercury protocol described far largely derivative previous structured overlay protocols 
shown provide efficient logarithmic routing responsibility handling various attribute values uniformly distributed nodes hub 
alluded section desire balance routing load create highly non uniform distribution ranges 
section analyzing non uniform range distributions design efficient distributed routing protocols hard 
find kleinberg basic small world network result certain assumptions non trivial satisfy distributed setting node ranges network non uniform 
novel algorithm ensures efficient routing assumptions violated 
tackle non uniformity dimensions query selectivity data popularity 
show core algorithm efficient routing non uniform range distributions re optimize query performance non uniformity query selectivity data popularity 
small world networks represent circle nodes 
define node link distance dn nodes length path clockwise direction 
objective find short routes pair nodes distributed algorithms 
kleinberg showed node constructs additional long link special manner number expected hops routing pair nodes log 
node constructs link rule generates integer harmonic distribution viz hn log establishes link node links away clockwise direction routing algorithm node choose link takes packet intuitive justification routing performance sensitive logarithm number nodes closest destination respect node link distance 
symphony extends result showing creating links reduces routing hop distance log :10.1.1.13.1630
creating long links appears deceptively straight forward 
may difficult expensive node determine node hops away 
contacting node simpler easily determine value range responsible 
allow existing long links contact node efficiently reduce number routing hops log systems symphony problem solved approximating hop distance node 
symphony places nodes randomly routing hub assumption nodes responsible approximately ranges size simply multiplying adding start values range symphony able estimate start range responsible 
unfortunately technique nodes responsible range size values ranges highly non uniform size 
mercury node maintains approximate map hop count value range 
sampling nodes system determine large range responsible 
samples create estimate density nodes different parts routing hub histogram distribution nodes 
allows easily map value start value range mapping turn enables construct long distance links section despite non uniform node ranges 
subsection details techniques uniformly sampling nodes distributed overlay maintain approximate histograms 
random sampling maintaining state uniformly random subset global participants distributed network scalable efficient timely manner non trivial 
context system na approach routing sample request message randomly generated data value works node ranges uniformly distributed 
unfortunately explained assumption easily violated 
obvious approach assign node random identifier cryptographic hash example route randomly generated identifier perform sampling 
order sampling process efficient need routing table delivering messages node identifiers 
approach protocols ransub specifically designed delivering random subset information 
unfortunately approaches require incurring overhead maintaining separate overlay may suited efficient data value routing 
mercury approach sampling novel show hub overlay constructed mercury randomized manner expander high probability 
expander property random walks links network converge quickly stationary distribution random walk 
hub overlay graph regular stationary distribution uniform distribution 
state lemma semi rigorous manner 
lemma 
circle nodes log additional links node generated harmonic probability distribution described section 
denote stationary distribution random walk denote distribution generated random walk proof omitted reasons space available related tech report 
steps 
high probability log small constants denotes statistical distance distributions 
see rigorous definitions 
leads simple algorithm performing random sampling send sample request message small log hop time live ttl 
node path selects random neighbor link forwards decrementing ttl 
node ttl expires sends back sample 
notice algorithm uses local information stage sampling process adapts easily highly dynamic distributed overlay 
addition messages piggy backed existing keep alive traffic neighbors reduce overhead 
simulations show mercury perform near perfect uniform random sampling ttl log describe important ways utilize random sampling system viz maintain node count histograms estimating selectivity queries effective load balancing 
maintaining approximate histograms section presents mechanism nodes maintaining histograms system statistic load distribution node count distribution basic idea sample distribution locally exchange estimates system epidemic style protocol 
nd denote local neighborhood node set nodes distance ignoring long distance links 
node periodically samples nodes nd produces local estimate system statistic consideration 
example node count distribution measured node local estimate ma ma nd nd rk rk range node ma ma minimum maximum attribute values attribute experiments 
addition node periodically samples nodes uniformly random sampling algorithm described section 
nodes reports back local estimate estimates received 
time progresses node builds list tuples form node id node range time estimate 
timestamp age old estimates 
tuples represent point required distribution stitching yields piecewise linear approximation 
parameters algorithm trade overhead accuracy histogram maintenance process 
section show simulations setting log sufficient give reasonably accurate histograms sampling population distribution 
system needs generate average histogram node properties collected samples exactly collected 
desire generate average histogram properties routing hub minor modifications needed 
consider objective estimating number nodes part hub 
sample represents node density estimate point hub 
decide estimate valid 
simple solution say sample valid location half way sample origin point origin sample hub 
number nodes responsible range values 
example unit hub consider situation samples measuring density nodes system node measurement 
say half hub range nodes divided half total nodes 
introduces systematic bias low density samples obviously nodes produce 
correct sample valid mid point weighted relative densities neighboring samples 
situation say density range wrapping clockwise density 
result total low density region high density region total nodes 
performed experiments show produces higher accuracy estimate 
density estimate different parts hub easily generate data needed efficiently contact neighbors constructing small world graph 
query selectivity recall query sent attribute hubs aq 
query conjunction predicates varying degree selectivity 
example predicate wildcard attribute exact match 
clearly wildcard predicate get flooded node attribute hub 
query sent hub selective minimize number nodes contacted 
problem estimating selectivity query widely studied database community 
established canonical solution maintain approximate histograms number database records bucket 
case want know number nodes particular bucket 
node hub easily gather histogram hub histogram maintenance mechanism described 
addition inter hub links gather histograms hubs efficiently 
histograms determine selectivity subscription hub 
see section conservative workload estimation reduce significant amount query flooding 
data popularity load balancing node joins mercury assigned responsibility range attribute 
unfortunately applications particular range values may exhibit greater popularity terms database insertions queries ranges 
cause node responsible popular range overloaded 
obvious solution determine way partition ranges proportion popularity 
load patterns change system move nodes needed 
leverage approximate histograms help implement load balancing mercury 
node histograms determine average load existing system determine relatively heavily lightly loaded 
second histograms contain information parts overlay lightly loaded 
information heavily loaded nodes send probes lightly loaded parts network 
probe encounters lightly loaded node requests lightly loaded node gracefully leave location routing ring re join location heavily loaded node 
leave re join effectively increases load neighboring lightly loaded nodes partitions previous heavy load nodes 
average load system denoted define local load node average load successor predecessor 
node said lightly loaded ratio local load heavily loaded ratio greater 
definition ensures node lightly loaded neighbors lightly loaded high probability 
case ratio neighbor loads lighter neighbor performs load balance heavier equalize loads 
easy show leave rejoin protocol described decreases variance load distribution step bounds maximum load imbalance converged system factor provided 
tolerating small skew prevent load oscillations system 
time leaves re joins result shift distribution nodes reflect distribution load 
shift node distribution significant implications 
properties mercury routing sampling rely harmonic distance distribution random long links 
nodes move adjust load distribution may changed 
technique creating long links takes node distribution account explicitly stated previously 
emphasize load balancing mechanism leave join new similar techniques proposed 
novel contribution random sampling mechanism enables techniques distributed overlays node range distributions skewed 
evaluation section presents detailed evaluation mercury protocol simulations 
implemented simple discrete event simulator assigns application level hop unit delay 
reduce overhead enable simulation large networks simulator model queuing delays packet loss links 
simplified simulation environment chosen reasons allows simulations scale large number nodes secondly evaluation focused proximity routing 
basic design similar spirit symphony chord believe heuristics performing proximity routing described adapted easily mercury 
evaluation centers main features mercury system scalable routing queries data records balancing routing load system 
evaluation core routing mechanisms random sampling histogram maintenance 
study impact mechanisms routing performance various workloads 
results showing utility caching query selectivity estimation context mercury 
query selectivity estimation experiments focus routing performance data single routing hub 
denote number nodes hub 
stated node establishes log intra hub long distance links 
rest section assume loss generality attribute consideration float value range 
node experiments responsible value interval omit proof reasons space 
idea simply variance reduction near heavier node larger variance increase near lighter node 
stat distance uniform distribution number links node ttl hops ttl hops ttl hops ttl hops ttl hops stat 
distance uniform distribution number nodes accuracy random walk sampling 
shows effect degree graph 
log overlay 
shows effect link structure 

follows denotes ideal small world overlay long distance links constructed harmonic distribution node link distance 
denotes overlay harmonic distribution value distance section 
denotes scenario links created node count histograms see section 
note performance overlay representative performance plain dht chord symphony absence hashing presence load balancing algorithms preserve value contiguity 
evaluating effect non uniform node ranges protocol assign node range width inversely proportional popularity load distribution 
choice reasonable load balancing produce precisely distribution nodes participate region load high 
ranges assigned zipf distribution 
particular data values near popular large number nodes share responsibility region care small node range 
simulator setup nodes lowest numeric ids 
random walk sampling goal random walk sampling algorithm produce uniform random sample nodes system 
measure performance algorithm terms statistical distance alternatively called distance perfect uniform distribution distribution obtained random walks 
experiments nodes assigned ranges zipf distribution 
sampling experiment pick node random record distribution samples taken kn random walks starting node 
sampling algorithm random walks hit node roughly times 
note parameter just evaluating distribution obtained protocol manner 
plots accuracy sampling process degree graph ttl random walks varied 
underlying overlay consider perfect small world network 
find certain threshold log ttl random walks influence sampling accuracy 
sampled distribution perfectly random graph degrees log small constant 
practice routing purposes sufficiently accurate histograms obtained 
neighbor id neighbor id node id neighbor id node id node id neighbor id node id log log distribution long distance links 
axis plots id log neighbors node axis 
nodes consecutively arranged hub circle 
number nodes 
means nodes queried round giving estimate reports exchange rounds performed 
shows construction underlying network affects sampling accuracy 
see overlays perform better vanilla dht hashing presence load balancing overlay 
effects explained plots distribution long distance links 
described earlier experiments nodes lowest identifiers responsible values near popular nodes value range popular 
recall overlay nodes construct links routing values generated harmonic distribution 
case node ranges uniformly distributed particular nodes near value nodes higher ids popular charge larger range values 
long distance links create tend skip nodes appropriate 
causes links correspondingly random walks crowd popular circle 
overlay offsets effect maintained histograms achieves sampling accuracy close achieved optimal overlay 
sample request message travels ttl hops obtaining random sample generates ttl additional messages system 
messages sent existing long distance links 
easily multiplexed piggy backed simply histogram error log scale reports round reports round reports round number nodes queried round total node count estimate distance node id histogram error distance node count estimates average routing hops reports round reports round reports round number nodes queried round effect routing performance accuracy sampled histograms 
shows node count estimates gathered node 
shows effect changing parameters average histogram error 
shows effect changing parameters routing performance 
appending ip address requesting node regular keep alive pings sent neighbors 
samples uniformly distributed nodes node receives sample requests sampling period 
conclude overhead sampling method small 
node count histograms section evaluate accuracy node count histograms obtained nodes mechanism described section 
histograms introduced section provide estimate total number nodes system help establishing long distance links correctly 
measure accuracy obtained histogram terms distance true histogram norm 
plots average accuracy histogram average taken nodes parameters histogram maintenance process varied 
experiment rounds exchanges performed 
see error consistently small decreases rapidly number nodes queried round increases 
obvious graph pattern observed number reports queried node graph show fluctuations magnitudes tiny result experimental variations 
average hops cache lru cache direct mapped cache number nodes average hops cache lru cache direct mapped cache number nodes uniform workload zipf skewed workload performance basic mercury protocol various workloads 
increased 
effects expected number samples received node round grows linearly parameters 
plots node count estimates produced node system nodes 
experiment run exchange rounds log see estimates tightly clustered actual node count value 
round histogram maintenance process node queries randomly sampled nodes receives estimate samples node 
messaging overhead round node proportional 
routing performance evaluation routing performance mercury 
factors effects random sampling histogram maintenance strategies 
performance basic protocol caching optimizations discuss effect skewed node range distributions validate claim protocol histograms achieves near optimal routing delays 
concentrate routing single hub 
experiments nodes establish log long distance links hub 
experiment different data workloads uniform zipf 
zipf workload high skewed generated distribution 
notice means attribute values near popular popular 
show performance types caching policies viz lru replacement direct mapped cache 
objective find best possible policy workload 
aim show ease application specific caching exist fruitfully mercury routing 
caching experiments node keeps cache log entries 
shows performance mercury node ranges uniformly distributed 
axis shows average number hops taken data item reach destination node stored hub 
graphs show results overlay performance similar expected 
see uniform node ranges number routing hops scales logarithmically low constant factors number nodes increases irrespective workload 
entry cache entry th region attribute space 
mercury provide low routing delays applications large number nodes 
caching enabled significant reduction hop count 
easy see skewed workload reduction uniform workload results fact cache effectively increases mercury routing table size 
believe caching important optimization mercury easily incorporate basic protocol 
effect non uniform ranges average hops lru cache number nodes effect non uniform node ranges average number routing hops 
workload zipf distribution 
compares performance protocol approximate histograms guide selection long distance links 
experiment node range distribution data distribution zipf skewed 
histogram maintenance experiment exchange rounds node queried log nodes round asking log estimate reports 
explained section na overlay vanilla dht presence load balancing creates links skip crowded popular region see 
packets destined nodes take circuitous routes circle short cuts provided long distance links 
caching effect performance worse compared optimal overlay 
hand see performance overlay nearly optimal overlay 
looking find node count histograms enable nodes establish correct link distribution corresponding overlay quickly low overheads 
shows effect histogram accuracy routing performance 
see parameters histogram maintenance process increase routing performance improves expected 
note influence limited note scale graph directly dependent accuracy obtained histograms see 
estimating query selectivity evaluate usefulness forwarding queries selective attribute hubs set experiment attribute hubs 
workload motivated distributed multi player game average nodes processing queries random hub selection histogram hub selection mean query range network bandwidth consumption forwarding queries 
application describe section 
attribute hubs correspond dimensions virtual space 
query contained range predicates attribute 
query specifies cuboid region virtual space 
range size predicate gaussian distributed range position attribute space zipf distributed 
node range distribution hub skewed 
plots average number nodes processing query number nodes grows 
number nodes grows range values node responsible decreases 
query tends get flooded hub 
plot shows conservative setting selecting hub selectivity estimates results reduction degree flooding query 
workloads exhibiting wildcards higher reductions expected 
load balancing convergence time load skew zipf parameter delta delta graph showing rounds taken achieve load balance function initial skew load 
degree load balance sought 
evaluating efficiency load balancing achieved mercury load balancing algorithm conduct experiment system nodes assign load node zipf distribution varying values initial skew zipf parameter 
system said load avg load holds nodes system 
load balanced experiment run multiple rounds load balancing algorithm system load balanced 
round consists steps 
node samples neighbors determine local node count 
requires roundtrip 

node runs round histogram maintenance algorithm 
recall round histogram maintenance algorithm involves sending log probes parallel traverse log hops 

nodes check histograms determine heavily loaded 
node heavily loaded sends probe lightly loaded node 
probe traverse log hops 

lightly loaded nodes leave re join network 
re join lightly loaded nodes establish new long links 
link establishment messages traverse log hops expectation 
plots number rounds load balancing required achieve load balance 
see mercury load balance factor rounds despite heavy skews workload zipf 
practical terms consider overlay nodes ms delay nodes 
time complete round load balancing product number hops traversed messages load balancing algorithm inter node delay 
time complete round log ms time load balance entire overlay log ms seconds 
distributed object management previous sections demonstrated mercury provides scalable range query lookups variety workloads 
section describe mercury building block distributed applications 
distributed object management framework mercury followed design testbed evaluation distributed multiplayer game called built top framework 
modeling object interactions challenges distributed application design managing distributed state includes code objects functions partitioned multiple physically distributed machines 
environment performing object lookups updates maintaining consistency scalable manner difficult 
observe applications instance typically interested small subset entire application state 
objects belonging subset related application specific manner 
observation enables publish subscribe architecture application instance registers subscription describing objects wishes keep updated :10.1.1.100.2117
object updated updates act publications delivered interested instances 
messages step sent parallel count number hops multiplying number messages 
similarly step key requirement design flexible subscription language allows application express object interests precisely 
time language permit scalable implementation underlying publish subscribe routing infrastructure 
providing scalable routing multi attribute range query subscription language mercury fits need 
previous sections demonstrated mercury desirable performance characteristics high performance system useful meets needs real applications 
illustrate usefulness mercury implemented mercury publish subscribe system library library build distributed multiplayer game 
focus single application natural question system generalizes 
implemented applications provide empirical evidence generalizability 
believe system provides general api suitable applications 
dimensional multi player shooter game 
player game ship supply missiles 
players pursue dimensional space fire missiles opponents range 
goal simply kill opponents possible 
presents screenshot game 
time player sees ships immediate vicinity defined game window 
virtual game world larger window 
example opponents located edges game window 
state game represented kinds objects ships missiles 
ship consists location velocity ancillary information fuel level 
missile created ship fires shots 
missile consists location velocity owner information main loop shown relatively simple 
messaging architectures distributed games multiplayer games multiple users exist single game world 
world contains number objects people ships weapons obstacles central problem distributed multiplayer gaming ensuring nodes consistent views game world 
provide consistency nodes send updates nodes world state changed 
date games broadcast messaging centralized server deliver updates 
broadcast games doom mimaze node broadcasts change state game world player moving position nodes 
broadcasting limits scalability ways 
imposes high load network 
second forces nodes process updates may irrelevant movements distant part world 
centralized designs improve broadcast messaging filtering updates game server 
designs node sends changes world state central server 
game server sends relevant updates movements players immediate owner credit appropriate player opponent killed 
screenshot void renderer render read keyboard events run physics publish dirty objects receive pubs delete useless objects main loop vicinity node 
designs suffer high network computational loads central server 
improve scalability researchers proposed area interest filtering schemes 
schemes game world divided fixed set regions tiles dimensional space 
regions mapped ip multicast groups 
approaches improve scalability distributing message filtering network 
fixed regions result delivery large number irrelevant updates clients maintenance large number ip multicast groups routers 
contrast mercury subscription language ideal implementing area interest filtering 
particular subscription language easy describe arbitrary physical regions 
example shows nodes expressing interests rectangular regions near 
interest fact regions example need fit pre defined tiling space 
note tiling space assigning tiles different channels possible simple dimensional game far difficult games irregular spaces corridors deal visibility constraints horizons 
course difficult channel schemes support arbitrary interests location int int int int player player int int int int game world example subscriptions teammates 
shown mercury able handle nodes keeping number routing hops 
assuming average case way delay nodes ms connected west coast results delay ms 
believe game specific caching algorithms improve routing performance making mercury games scalable thousands nodes 
managing distributed objects noted sec 
distributed game ensure nodes consistent views game world 
mercury provides solution aspects problem specifying areas interest game nodes efficiently routing world state updates relevant nodes 
complete solution requires additional support 
particular game requires facilities applying state updates local state creating update messages reflect local changes enumerating local state managing update conflicts 
having identified needs describe object management framework bridges gap services provided mercury services required distributed games 
object management framework implemented library interfaces game application fundamental data structure api calls upcalls 
describe turn 
fundamental data structure framework object registry 
object registry collection objects relevant local view game 
framework ensures remote changes objects registry reflected locally vice versa 
objects placed registry inherit defined 
api provides calls interest management expressing cancelling interests object management adding removing objects registry object updating method mark objects dirty method synchronize local state global state 
framework requires application provide upcalls virtual methods 
upcalls relate serialization constructor create local copies remote objects update method updates local object state publications serialization method 
api calls upcalls sufficient handle application needs enumerated update conflicts 
multiple nodes may copies object possible multiple nodes modify object 
ensure object state inconsistent framework permits single writer object 
framework maintains replica tag object signifying object created locally received network 
application calls synchronization method framework generate updates objects replica tag set 
believe simplicity model valuable acknowledge may need support alternate consistency models 
api evaluation evaluate framework api number lines code relate functionality provided 
divide costs groups interest management object management object updates serialization write conflicts 
group give number lines required call corresponding functions prepare relevant arguments 
example interest management includes calls interest management method code required compute game current area interest 
point entire code lines 
table gives results 
function group lines interest management object management object updates serialization write conflicts table lines code required significant costs interest management serialization 
interest management costs due primarily logic determining application area interest required non broadcast system 
broadcast systems clearly lower programming complexity respect interest management 
respect serialization code note serialization code inherent cost distributed applications toolkits available ease programming burden serialization 
unique costs interface object management object update conflict management facilities quite modest 
object management framework mercury appropriate building blocks distributed game 
performance evaluation evaluate performance system metrics hop count message count 
run varying number players 
players move world random waypoint model motion time chosen uniformly random seconds destination chosen uniformly random speed chosen uniformly random pixels second 
possible architect game sends updates describe changed fields serializing entire object 
clear doing reduce code complexity 
size game world scaled number players 
dimensions number players 
results average experiments experiment lasting seconds 
experiments include benefit log sized lru cache node include benefits long pointers 
table summarizes results 
respect hop count find hop count increases slightly double number nodes 
evaluate mercury messaging efficiency compare alternatives 
broadcast messages column table report number messages transmitted update sent node done generation distributed games 
optimal messages column report number messages required exactly satisfy node interests control message overhead 
find mercury performs substantially better broadcast scheme messages transmitted nodes performance difference increases increase number nodes mercury messages broadcast nodes 
players average hops broadcast messages mercury messages optimal messages table mercury routing overheads long pointers 
described design implementation mercury scalable protocol routing multi attribute range queries 
contributions compared previous systems include support multiple attributes explicit load balancing 
mercury incorporates novel techniques support random sampling nodes system 
random sampling enables number light weight approaches performing load balancing node count estimation selectivity estimation 
evaluation clearly shows mercury scales low lookup latency provides load balancing 
addition providing high query routing performance mercury provides easy facility maintenance distributed object database 
particular application system needs compute interests provide methods serialization register objects set dirty tag modified object 
providing range query language mercury allows applications express interests flexible manner 
directly shown ease mercury distributed games believe classes applications benefit system include collaborative applications shared whiteboards distributed inventories possibly sensing applications 
byers considine mitzenmacher simple load balancing distributed hash tables 
second international workshop peer peer systems 
cabrera jones theimer herald achieving global event notification service 
proceedings th ieee workshop hot topics operating systems germany may 
carzaniga rosenblum wolf design evaluation wide area event notification service :10.1.1.100.2117
acm transactions computer systems aug 
castro druschel hu rowstron exploiting network proximity distributed hash tables 
international workshop directions distributed computing june babaoglu birman marzullo eds pp 

castro druschel kermarrec nandi rowstron splitstream high bandwidth multicast cooperative environment 
proceedings th symposium operating system principles oct 
castro scribe large scale decentralized application level multicast infrastructure 
ieee journal selected areas communications jsac oct 
dabek kaashoek karger morris stoica wide area cooperative storage cfs 
proceedings th symposium operating system principles chateau lake louise banff canada oct 
gautier diot design evaluation mimaze multi player game internet 
ieee multimedia systems conference austin tx july 
ghosh leighton maggs muthukrishnan plaxton rajaraman richa tarjan zuckerman tight analyses local load balancing algorithms 
proceedings th acm stoc pp 

gummadi impact dht routing geometry resilience proximity 
proceedings acm sigcomm aug 
harvey jones saroiu theimer wolman skipnet scalable overlay network practical locality properties :10.1.1.118.8846
proceedings th usenix symposium internet technologies systems seattle wa mar 
hellerstein loo shenker stoica querying internet pier :10.1.1.14.7680
proceedings th international conference large databases sept 
karger ruhl simple efficient load balancing algorithms peer peer systems 
third international workshop peer peer systems 
kleinberg small world phenomenon algorithmic perspective 
proceedings th acm stoc 
rodriguez albrecht vahdat random subsets build scalable network services 
proceedings th usenix symposium internet technologies systems seattle wa mar 
li kim govindan hong multi dimensional range queries sensor networks 
proceedings acm sensys nov 
zyda pratt reality multicast groups network architecture large scale virtual environments 
proc 
ieee virtual reality symposium vrais mar 
manku bawa raghavan symphony distributed hashing small world :10.1.1.13.1630
proceedings th usenix symposium internet technologies systems seattle wa mar 
motwani raghavan randomized algorithms 
cambridge university press 

www net 
randall math rapidly mixing markov chains 
www math gatech edu randall course lewis ps 
rao lakshminarayanan surana karp stoica load balancing structured systems 
second international workshop peer peer systems 
ratnasamy francis handley karp shenker scalable content addressable network proceedings sigcomm symposium communications architectures protocols san diego california aug :10.1.1.140.3129
rowstron druschel pastry scalable distributed object location routing largescale peer peer systems 
ifip acm international conference distributed systems platforms middleware nov pp 

singhal cheriton projection aggregations support scalability distributed simulation 
proceedings th international conference distributed computing systems 
stoica morris karger kaashoek balakrishnan chord scalable peer peer lookup service internet applications 
proceedings sigcomm symposium communications architectures protocols 

