group communications database replication techniques issues performance th se pr sent la informatique communications cole polytechnique rale de lausanne pour du grade de sciences par matthias dipl tg ge jury prof schiper de th se prof aberer prof alonso dr lausanne epfl databases important part today infrastructure companies state institutions rely database systems store important data 
dependent database systems securing key facility priority 
research fault tolerant database systems increasing importance 
way ensure fault tolerance system replicating 
replication natural way deal failures copy available 
implementing consistent replication easy 
database replication hardly new area research papers subject years old 
build efficient consistent replicated database open research question 
new approach solve problem proposed 
idea rely communication infrastructure called group communications 
infrastructure offers high level primitives help design implementation replicated database 
promising approach database replication infancy 
thesis focuses group communication database replication strives give understanding topic 
thesis major contributions 
structural domain introduces classification replication techniques 
qualitative domain analysis fault tolerance semantics proposed 
quantitative domain performance evaluation group communication database replication 
classification gives overview different means implement database replication 
techniques described literature sorted classification 
classification highlights structural similarities techniques originating different communities database community distributed system community 
category classification analyse requirements imposed database component group communication primitives needed enforce consistency 
group communication database replication implies building system different components database system group communication system 
fault tolerance property system built components tends fault tolerant weakest component 
analysis fault tolerance semantics show fault tolerance guarantee ensured ii group communication replication techniques 
additionally new faulttolerance guarantee group safety proposed 
group safety better suited group communication database replication 
show group safe replication techniques offer improved performance 
performance evaluation offers quantitative view group communication replication techniques 
performance group communication techniques classical database replication techniques compared 
way different techniques react different loads explored 
optimisation group communication techniques described performance benefits evaluated 
sum les bases de donn es repr une de infrastructure informatique hui 
que ce soit dans le monde de ou de administration de plus en plus institutions des bases de donn es pour les informations 
chaque jour notre soci pend de mani re des bases de donn es 
la de ces syst mes est donc une 
de ce fait les bases de donn es tol aux sont un domaine de recherche dont importance va 
une mani re la tol rance aux est la plication 
la plication est une approche aux probl mes des si une des donn es ne plus une 
une plication du point de vue des donn es est pas chose ais la recherche sur les bases de donn es es est de pas nouvelle les res publications sur le leur quart de si cle 
la question une technique de plication de base de donn es hui encore 
une nouvelle approche au probl propos elle sur une infrastructure de communication appel communications de 
cette infrastructure permet au de primitives de niveau de simplifier architecture impl mentation de techniques de plication 
bien que cette approche en est qu ses premier la des recherches dans ce domaine en sont qu un 
cette th se se sur les techniques de plication de bases de donn es bas es sur les communications de 
le est une du domaine de une synth se 
cette th se trois contributions 
du point de vue elle une classification des techniques de plication 
du point de vue une analyse des de tol rance aux est propos une analyse de performance un point de vue sur le 
la classification donne un des diff au probl de la plication de bases de donn es 
les diff techniques propos es dans la sont classifi es es 
cette classification met en les entre des techniques de diff des de donn de syst mes 
pour chaque cat de techniques les imp iii iv au sous syst de base de donn ainsi que les primitives de communications pour la coh rence sont pr sent les techniques de bases de donn es bas es sur les communications de sur deux un module de communication de un module de base de donn es 
la tol rance aux est une propri un syst partir de deux aura tre aussi que le plus de ces deux 
analyse des de tol rance aux permet de quel niveau de est par une technique de plication bas sur des communications de 
un crit re de tol rance aux est propos group safety 
ce crit re est plus appropri pour la tol rance aux des techniques de plication bas es sur des communications de 
de plus techniques peuvent tre adapt es ce crit re ainsi des performances am es 
valuation de performances donne une vue quantitative des performances de techniques de plication bas es sur des communications de 
les performances de ces techniques ainsi que de techniques de plication sont compar es 
le comportement de les techniques des charges diff est pr sent 
des optimisations li es techniques bas es sur les communications de groupe sont pr sent es en termes de performance sont valu isabelle de vi am grateful people helped way 
andr schiper confidence accepting research group supervising 
wish people involved dragon project fernando pedone bettina kemme gustavo alonso people possible 
express gratitude people operating system lab distributed systems lab 
particular ter xavier available discuss issues distributed system algorithm programming bugs philippe interesting discussions software architecture programming languages ys sergio mena de la cruz support 
secretaries france logistical support gave roux proof reading final version 
vii viii table contents database replication 
group communications 
research 
research objectives 
research contributions 
thesis organisation 
database group communication models overview 
distributed systems 
database systems 
distributed systems model 
definitions 
synchrony 
process state 
communication primitives associated problems 
database systems 
transactions 
histories 
acid properties 
concurrency control 
network model 
distributed transactions 
practical issues 
client code 
high level transactions 
cold standby vs hot standby 
interactive transactions vs stored procedures 
determinism 
optimistic weak communication protocols 
summary synthetic model 
summary communities 
ix table contents synthetic model 
classification replication techniques classification criteria 
server architecture 
server interaction 
transaction termination 
replication techniques 
update 
primary copy 
discussion 
overview requirements 
server architecture primary copy vs update server interaction constant vs linear 
transaction termination voting vs non voting techniques recovery fault tolerance issues safety criterion 
view recovery 
existing systems 
roll forward recovery 

roll back recovery 
inter layer messages 
inter layer ack messages 
safe replication 
group safe replication 
group safety 
group durability 
group safe replication lazy replication 
building group safe replication technique 

performance comparison rd sim simulator 
server structure 
client module 
simulation settings 
experiments 
general performance 
scalability 
query proportion 
wide area network 
group safe replication 
table contents xi optimistic active replication 

research assessment 
classification 
fault tolerance criterion 
performance evaluation 
open questions research direction 
intra layer communications 
hybrid replication techniques 
best effort total order broadcast 
group safe replication 
optimistic mechanisms 
xii table contents list figures basic building blocks 
group communication stack 
distributed transactions 
process types 
group communication stack state 
optimistic concurrency control non deterministic scenario 
spontaneous ordering lan 
synthetic model 
relationship database server group communication process 
gray classification 
update constant interaction non voting 
update replication constant interaction voting 
update linear interaction non voting 
update linear interaction voting 
primary copy constant interaction non voting 
primary copy constant interaction voting 
primary copy linear interaction non voting 
primary copy linear interaction voting 
requirements classification 
unrecoverable failure scenario 
protocol stack 
messages exchange total order broadcast 
messages exchange total order broadcast including ack message recovery message replay 
group safe replication lazy replication 
general simulator architecture 
performance replication techniques medium load slow network 
performance replication techniques medium load fast network 
xiii xiv list figures influence network performance distributed locking technique 
performance replication techniques high load slow network 
performance replication techniques high load fast network 
abort rate high load situation fast network 
scalability update techniques query load correlation conflict function observed aborts 
conflict list scenario 
abort rate servers changing loads 
scalability update techniques query load performance changing query rate low load transactions second 
performance changing query rate moderate load transactions second 
performance certification replication changing query proportion changing loads 
performance ser replication changing query proportion changing loads 
performance distributed locking replication changing query proportion changing loads 
performance primary copy replication changing query proportion changing loads 
performance wan setting 
performance group safe certification 
overlap communication processing optimistic active replication 
performance active replication optimistic active replication response time restarted transactions optimistic active replication order message influence performance 
list tables crash membership properties different models 
state handling different models 
summary communities 
summary different safety levels 
safety constraints number crashes 
simulator parameters 
settings simulating performance replication techniques 
scalability configurations 
xv xvi list tables chapter tout dit mais comme il 
andr turn century seen tremendous advances field computing 
brought major changes 
number computer systems increased order magnitude 
desktop systems embedded circuitry computers ubiquitous 
secondly emergence networking infrastructure local global means computers increasingly interconnected 
changes happen technological field societies depend computers day activity starts rely computer 
aspects everyday life imply computer systems stage rare 
today impact computers society important 
computer system widespread complex distributed fragile 
failures frequent serious terms consequences 
crashes bugs problems increasingly important impact human lives neu 
issues fault tolerance security considered specialised fields long time 
nowadays society relies computers people aware fact 
research security fault tolerance important 
mainstream software vendors started security stability official priority man 
approaches build fault tolerant systems proposed 
reach aspects information systems hardened material components improved management projects 
techniques promise fault tolerance include software engineering specialised computer languages replication 
thesis concentrate replication 
chapter 
replication natural way deal failures replica fails takes 
living organisms achieve fault tolerance way cell dies cells share organism survive 
replication natural solution fault tolerance implementing consistent replicated system easy 
main issue computer system store data way different biological entities 
issue expectations different 
neuron dies brain memory lost information fuzzy 
acceptable solution computer systems 
safety critical system control factories power plants slightest error dire consequences 
banking applications having slightly wrong accounts server crash acceptable solution 
want system enforce strict guarantees case crash replication complex problem 
banking systems typical example database applications 
general databases represent key element infrastructure companies customer information inventories stored databases 
replicating databases increase fault tolerance appears idea 
consistent data replication complex issue cap database replication 
database replication ongoing research domain academia industry 
thesis discusses database replication particular techniques proposed rely network abstractions called group communications 
database replication database replication area research years publications subject appeared early eighties tho gif sto 
database replication object research 
core issue techniques proposed correct shown perform badly number sites increases 
main reason replication protocols designed impose minimal changes database engine 
yields high synchronisation costs high number deadlocks 
legacy performance main reasons black box approach 
large amount information stored databases everyday changing architecture migrating data imply lot 
databases important enterprises performance expectations replicated database risen jaj 
new replication mechanisms searched 
way get increased performance replicated databases relax consistency rules approach currently commercial database systems ora inf proposed 
group communications main avenue research bbc 
approach called lazy replication offers promising perspectives disconnected computing advantage black box approach 
main issue lazy replication problem consistent fault tolerant replication 
group communication replication proposed alternative lazy replication sr alo pgs 
techniques high level primitives offer fault tolerant database replication acceptable performance imply white box approach database system changed rely group communication abstractions 
unit database transaction 
transactions sets instructions executed database logical unit 
transaction processing defined acid rules atomicity ensures transaction executes completely consistency ensures transactions brings database legal state isolation ensures parallel execution transactions side effect transaction durability ensures transaction effect forever event failures 
order build consistent database replication acid properties enforced 
group communications group communications set high level communication primitives tools designed help build replicated services 
basic idea address replicas entity ht 
notion group communication originated distributed operating systems cz systems am ba kt kt 
group communications object ongoing research resulted theoretical results prototypes 
theoretical results include precisely defined semantics minimal conditions needed solve certain problems flp ct cht 
prototypes moved group communication infrastructure operating system autonomous toolkits 
isis group communication system bad bss proved group communication practical settings 
group communication toolkits developed dm bch hs bch mpr academic settings 
emergence middleware systems trend integrate group communication toolkits inside middleware infrastructure wal fel bch sw omg 
group communication toolkits offer similar high level abstractions 
group communication mechanisms ensure kinds properties agreement properties ordering properties 
agreement properties ensure members agree value delivery message 
ordering properties ensure messages delivered members certain order 
chapter 
research thesis started context dragon project database replication group communication joint project swiss federal institute technology lausanne epfl swiss federal institute technology rich ethz 
goal dragon explore possible group communication techniques context database replication 
important aspect project inter disciplinary nature 
database distributed system communities different 
order build efficient replication techniques understanding communities needed 
idea group communications database replication quite old chang proposed broadcast protocols form view synchronous broadcast simplify design phase commit protocol cha area research active 
research objectives lot research done domain group communication database replication sr pg pgs alo pgs ka ka pgs haa pf ka ka fp promising replication techniques proposed 
research domain explorative new techniques proposed performance assessed special restricted settings 
thesis explores database replication group communication systematic way 
goal get big picture understand issues related problem 
done ways classification replication techniques definition precise failure semantics performance evaluation 
approaches require solid groundwork understand differences common points models database systems group communication systems 
research contributions research contributions thesis match research objectives project classification techniques understanding failure semantics performance evaluation 
classification replication techniques large variety replication techniques proposed relationship techniques clear 
similar techniques appear 
research different defined different models terminologies 
time subtle changes protocol result different replication techniques 
better understand database replication different techniques proposed literature systematic classification proposed 
classification advantages helps understanding concepts mechanisms underlying replication requirements replication schemes second helps assert possible replication schemes described replication techniques proposed combination overlooked 
exploring solution space systematic way oversight spotted 
analysis fault tolerance semantics main goals replication fault tolerance replicated system expected withstand failure scenarios 
group communication systems database systems different failure assumptions guarantees offered system built technologies trivial 
fault tolerance property multiple components combined resulting system typically exhibits fault tolerance weakest component 
careful analysis needed understand fault tolerance system built combining group communication database elements 
show failure guarantees expected linking group communication database 
introduce new failure semantics better adapted express fault tolerance group communication database replication 
propose new variants existing replication schemes maximise performance respecting failure semantics 
performance evaluation order understand performance behaviour different replication schemes replication schemes implemented simulator performance measured 
classification gives qualitative view replication techniques performance evaluation gives quantitative view 
performance evaluation uses classification basis techniques relevant categories compared 
important contribution performance evaluation performance promising group techniques performance evaluated comparison techniques 
performance variants proposed analysis faulttolerant semantics evaluated 
optimisations group replication techniques evaluated 
thesis organisation thesis organised follows chapter discusses system models abstractions practical issues database distributed system communities chapter 
gives unified model 
chapter presents classification database replication techniques 
chapter discusses recovery fault tolerance issues 
chapter presents performance evaluation different replication techniques 
chapter summarises major results outlines research directions 
chapter database group communication models verbosity leads unclear things 
dan group communication systems build replicated database logical choice proposed time cha 
leveraging group communications toolkits design replicated database easier permit layered design network functionality separated database application 
group communication toolkit replicated database system database system basic building blocks approach logical practical implies assembling components originating different communities distributed system community database community 
components rely different models assumptions offer different properties 
community tends concentrate certain problems simplify issues outside scope 
database community tends simple network model chapter 
database group communication models distributed system community simple processing model 
communities different goals priorities different models metrics 
build efficient system combining group communications databases models understood 
resulting unified model help describe design replication strategies synthetic ways 
means grouping communication primitives communication module regardless fact originated community 
chapter describes sides fence presents philosophies models communities 
presents unified model chapters 
chapter structured follows section gives overview communities section presents distributed system model associated issues section presents database model section presents practical issues distinguish communities 
section gives summary differences presents unified model 
overview replication considered database community distributed system community quite time motivations replication quite different 
focus community quite different 
section basic goals philosophies communities 
distributed systems distributed system community focuses systems distributed network 
components system distributed different computing nodes communicate exchanging messages 
main goal distributed system community system consistent offering guarantees message flow ordering 
achieved adding layer top actual network way operating system adds abstraction layer top actual hardware 
architecture illustrated 
different ordering consistency levels specified corresponding algorithms implemented 
system built top group communication infrastructure application level infrastructure instance virtual shared memory environment bkt 
main goal replication distributed system community fault tolerance 
system replicated having multiple copies copy fails continues copies 
main problem keep copies synchronised hide failures occur 
ideally failures handled way transparent application 
communication infrastructure concerns ordering messages reliable delivery replication schemes associated 
overview application group communication infrastructure communication infrastructure group communication stack communication primitives tend consider simple application model 
issues multi threading non determinism load balancing large state transfers typical complex applications 
issues considered scope group communications addressed models considered 
means order replicate complex application issues handled application application simply replicated adequate communication primitives redesign needed 
problem communication primitives lacking precise semantics applications need applications need certain messages ordered ordering waste resources 
group communication difficult integrate communication channels control group communication system cs 
new communication primitives ps flexible group communication system bch hs mpr started address issues 
important issue lack focus practical issues lot research done define precise models understand properties devoted comprehensive performance study practical quantification fault tolerance kim 
led wide variety algorithms classified relative performance studied 
background group communication protocols tend perceived slow resource consuming 
limitations main reason group communication primitives deployed actual systems current done academic settings 
database systems database community focuses systems handle data storage 
resilience important issue databases replication central focus database community databases expected recover correctly chapter 
database group communication models crash 
replication considered administrative reasons data pertaining certain location location performance reasons moving data closer users fault tolerance 
replication hardware level ensure fault tolerance specialised hardware raid disk shared processors 
database systems rely notion transactions 
transaction execution satisfies acid properties atomicity consistency isolation durability see section 
system expected hide failures case crash transactions aborted system rolled back consistent state 
basic today database established eswaran 
distributed databases considered time usually handled additional layer top existing systems 
distributed transactions span sub transaction node sub transactions synchronised atomic commitment protocol ensures atomicity nodes 
illustrates architecture 
distributed transaction local transaction local transaction local transaction local transaction atomic commitment protocol distributed transactions replication traditionally seen particular case distributed databases distributed transaction updates copies database 
server crashes transaction processing transaction aborts needs restarted 
failure server fully transparent 
issue transaction typically abort reasons instance concurrency control users cope transaction aborts anyway 
approach shown scalable expensive proposed research concentrates relaxed constraints bbc 
lack transparency failures unpredictable aborts database systems unsuitable critical real time applications kim 
database systems intensively core enterprises heavy emphasis performance 
formal models relaxed get better performance 
reason database systems tend rely underlying layers operating systems relevant functionality implemented ad hoc way inside database system 

distributed systems model distributed systems model large number system models considered distributed system community see describing scope 
model needed specify group communication primitives time discussion group communication database replication tie specific model 
model describe communication primitives problems solve context 
show model relates actual models 
proposed unifying framework group communications systems framework concentrates systems views 
section give overview classical models relationship 
new model general framework integrates different existing models 
existing models described section usually considered literature static crash recovery model flp called crash fail dynamic crash recovery model bj called crash fail model views crash recovery model act 
conceptually close described synthetic way 
models considered rely bo timed asynchronous model cf complex actual system measurement reduced models 
different models considered classified basic criteria time state consider time state process handled 
section structured follow section gives basic definitions section presents different timing hypothesis section presents different state handling policies 
definitions system modelled group processes communicate messages 
messages transmitted channels 
mean communication available processes communicate processes access global clock 
sending receiving messages events happen process receiving sending message 
order specify communication protocols need define process take part protocol processes 
crashed process recover expected deliver message 
need define channels channel expected deliver message process crashed recovers 
different models different definitions processes channels 
yields different specifications problem depending model wish avoid 
need general abstraction 
chapter 
database group communication models processes illustrates categorise processes 
general categories processes crash processes eventually stay long finish computation 
criteria generally define processes group communications models consider 
consider intersection categories 
processes crash 
processes crash recover eventually long 
processes long 
say process green crashes 
red process process behaves way prevents participating solving problem instance crashing recovering unstable process crashes recovers crashes unstable process long useful 
process red green crashes eventually stays stable time take part computation 
call processes yellow 
red processes crashes yellow processes eventually forever process types green processes crash recovery model dynamic static flp ct green processes called correct crash 
red processes called incorrect fail 
processes recover problem unstable processes encountered 
processes red green yellow processes 
crash recovery model act red process crashes recover unstable 
processes called bad 
process crashes crashes recover eventually stays forever corresponds non red process 
process green yellow 
timing aspect model impact specification red green processes 
timing assumptions model long 
distributed systems model means forever 
timing assumptions green process stays forever 
timing model synchronous timing bounds process speed message delivery time 
long means longer time maximum bound time needed solve problem considered 
timing aspects model discussed section 
channels important aspect model communication channels 
conflicting definitions depending model 
order model need specification merges models 
crash recovery models tend reliable quasi reliable act channel specification 
reliable specification states process red sends messages green process message eventually received 
reliable channels reasonable assumptions real systems typically buffers pipelines 
process sends message crashes buffers lost 
expecting messages sent crashing processes delivered reasonable 
quasi reliable specification states green process sends message green process message eventually received 
sense model process recover poses problems model processes crash recover quasi reliable specification define yellow processes handle messages 
crash recovery models allows yellow processes processes crash recover 
fact crash prevent participating protocol recover yellow processes expected take part distributed algorithms send receive messages 
message reaches process crashed lost 
expect yellow processes lose messages 
hand yellow processes lose messages impossible solve problem 
reason crash recovery models tend rely fair loss channels 
specification loss specification different process sends infinite number messages process non red receive infinite number messages important thing notice models fact contradictory 
expecting loss sender receiver green crash contradict expecting fair loss sender receiver crash 
need specify loss messages ways cover models 
resulting specification creation process receives message sent duplication process receives message 
quasi loss sends green eventually receives chapter 
database group communication models fair loss sends messages non red process infinite number times receives infinite number messages channels defined specification equivalent fair loss channels crash recovery model quasi reliable channels crash recovery model 
crash recovery model fair loss clause reduced clauses apply resulting specification channels 
crash recovery model quasi loss clause reduced clauses resulting specification fair loss channels 
proposition fair loss property reduced clauses crash recovery model 
proof yellow processes model red green 
non red green 
green quasi loss clause applies sends message receive message 
sends infinite number messages receive infinite number messages 
red crash 
send infinite number messages crashing 
proposition quasi loss property reduced clauses crash recovery model 
proof processes green crash 
sends message infinite number times received 
quasi loss implemented fair loss channels algorithm sends message repeatedly sends receives ack message time receives message sends ack message 
crash eventually receive synchrony important aspect models timing issue 
model synchronous bound relative processing speed processes bound time needed message sent process delivered 
means process executes instruction step time unit process execute time units 
message sent time received latest time 
assume process execute infinite number operations finite time 

distributed systems model hand model asynchronous bounds exist 
bound relative processing speed message delivery 
time bound time basically meaning asynchronous model called timeless model 
shown flp asynchronous model powerful solve consensus problem process crash 
group communication problems reduced consensus 
consensus solved problems 
order useful asynchronous model augmented failure detectors 
failure detectors oracles tell process state 
consensus solved asynchronous model failure detectors ct 
failure detectors perfect imperfect imperfect failure detector incorrectly suspect non failed process called false suspicion 
failure detector detect red crashed processes completeness suspect non red non crashed processes accuracy 
kind failure detector leader election property processes agree non red process lam 
consider failure detectors failure detector perfect crashed processes eventually suspected processes strong completeness non crashed process suspected strong accuracy 
failure detector satisfies weak accuracy non crashed processes suspected eventually non crashed processes suspected implements strong completeness 
failure detector satisfies eventual leader election 
eventually leader selected processes 
su failure detector similar defined crash recovery model act means handle unstable processes 
strong completeness requires processes suspect unstable processes 
failure detectors equivalent sense solve consensus algorithm transform failure detector cht 
process state important aspect model concerns state different processes 
state process split different layers corresponding conceptual layers context group communications application communication infrastructure see 
normal course operation level maintains state processing 
chapter 
database group communication models application group communication infrastructure communication infrastructure state group communication stack state case crash part process state lost part stored volatile memory process 
state preserved replicated volatile memory processes stored stable storage 
different models handle state information different ways 
part process state preserved case crash decide processes able recover continue processing 
turn give model certain properties 
describe classify models handle state possible establish relationship different models describe general way 
communication infrastructure layer 
lowest layer process state concerns communication layer 
layer traditionally handled operating system networking hardware state usually volatile survive crash 
state stored stable storage replicated 
storing messages stable storage expensive terms performance stable storage usually implemented slow disk technology 
require redesign operating system communication hardware 
replicating state sense level group abstraction exist ip multicast abstractions peer peer relationships 
consider channel model described messages transmitted long crash 
crash state including pending messages lost 
application layer 
highest layer application layer 
state application needs replicated 
process recovers application layer state reconstructed 
done ways getting state process replaying messages rebuild state 
case means group communication layer access state application layer process 
second case means communication layer replay messages 
possible communication layer stored messages 
distinction 
distributed systems model impact model discussed discussed chapter 
group communication layer 
intermediate layer offers advanced communication primitives gives applications tools primitives needed system normal operation recovery 
primitives provide groundwork replicating application layer 
communication infrastructure typically operational settings adapted replication 
application layer isolated model 
abstractions group communication layer design validation simplified implementations portable 
application simply uses group communication primitives built properties primitives 
design application layer affected timing considerations failures detectors issues role group communication layer offer high level primitives guarantees enforce guarantees regard model 
reason model considerations affect group communication layer 
section describe group communication layer handles state information different models introduced section 
static crash recovery model model processes recover crashed 
recovery issue 
state need replicated recovery purposes 
application state probably replicated instance state machine replication sch group communication system need application layer gives state recovery purposes recovery 
processes recover point restoring state group communication layer 
model basis theoretical research flp ct useful practical cases 
dynamic crash recovery model dynamic crash recovery model introduced isis system bj 
addresses shortcomings static crash recovery model 
key idea model allow dynamic number process system 
composition group point time called view 
view vi set processes vi pi 
pin 
process crashes suspected crashing excluded view 
new processes join view 
process formally recover rejoin group recovers new identity called new incarnation process 
system defined sequence views 
vn new view installed time process leaves joins view event called view change 
view changes model behaves static crash recovery model 
view information replicated group communication state process 
mechanisms chapter 
database group communication models achieve replication group communication layer 
notion views model elegant information regarding replication replicated 
views address issues dynamic composition group administrative issue handling crashed processes fault tolerance issue 
view information replicated group communication layer recovery actions rely 
order part group recovering server update view include view 
view accessible process failures recovery impossible system blocks 
static crash recovery model stable storage crash recovery model recovering process take part computation immediately need wait view change installed 
means process take part protocol started process crashed 
order part state group communication system restored recovering process 
instance consider consensus protocol certain value decided process crashed 
means kept long decided 
multiple instances consensus run values kept 
consider total order broadcast messages delivered crashed kept sent recovers 
part state group communication layer replicated servers 
process recovers application layer state reconstructed querying state process dynamic crash recovery model state information group communication layer communication layer replays messages application layer 
todate state obtained replaying messages old state initial state rr 
means recovery process obtain date state application layer date state 
static membership dynamic membership crash recovery static crash recovery dynamic crash recovery crash recovery static crash recovery dynamic crash recovery table crash membership properties different models important thing note crash recovery model usually considered static act set processes considered changes 
model addresses failures handle system reconfigurations 
table shows combination group membership failure model group membership static dynamic crash behaviour crash recovery crash recovery 
dynamic crash recovery model possible 
distributed systems model quite complicated imply model handles view mechanism long term administration crash recovery model handle short term failures 
model described literature 
research separating administrative issues fault tolerance issues different failure detections mechanisms discussed 
static crash recovery model stable storage model similar crash recovery stable storage main difference process stores state group communication layer stable storage 
process recovers state group communication layer reconstructed requesting processes case stable storage reading stable storage 
stable storage sufficient state stable storage contain state related iterations protocols 
stable storage possible group survive catastrophic failures crash processes 
stable storage recovering failure impossible state information stored stable storage definitely lost catastrophic crash occurs 
important thing note presence absence stable storage concerns group communication layer 
application layer access stable storage purposes typically case replicated database 
properties obtained relying stable storage application layer discussed chapter 
summary table summarises different models handle state group communication layer 
model name group communication state crash recovery replicated dynamic crash recovery static crash recovery stable storage static crash recovery stable storage view information replicated replicated replicated stored stable storage table state handling different models chapter 
database group communication models communication primitives associated problems section describes problems group communication system solves 
group communications generally crash recovery model ht 
specified general model 
note consider atomic commitment group communication primitive traditionally case 
atomic commitment originated database community considered group communication primitive 
atomic commitment clearly agreement problem reduced consensus gue 
atomic commitment protocol useful primitive implement actual systems implementation atomic commitment protocols simplified group communication tools techniques cha bt 
integrating atomic commitment group communication toolkit lot sense 
case possible group communication problems module database model communication issues 
primitives described section typically strong sense guarantees absolute best effort 
implement uniform specification problem typically processes crash allowed bad things delivering messages wrong order delivering wrong decision 
primitives solve weaker versions problems section 
problems specified general model properties apply green red non green processes 
general properties uniform apply non red processes processes eventually forever 
typically means non red process need deliver certain message 
cases properties apply classes processes instance green processes issue discussed 
uniform reliable broadcast reliable broadcast primitive ensures processes set get message case failure 
reliable broadcast defines primitives deliver specified follows validity process delivers broadcast process 
uniform agreement non red process delivers message processes eventually deliver uniform integrity message process delivers previously broadcast sender 
uniform reliable broadcast solved green process ct 
crash recovery model stable storage uniform reliable broadcast solved yellow process 

distributed systems model uniform fifo reliable broadcast fifo reliable broadcast similar reliable broadcast enforces policy 
policy concerns messages source 
formally fifo reliable broadcast follows definition reliable broadcast augmented primitive 
fifo process rf delivers sender sender sent 
fifo reliable broadcast trivial implement sequence numbers 
uniform consensus consider consensus core problem group communications 
agreement problems reduced consensus 
algorithms solve problems built algorithm solves consensus available 
intuitively problem consensus processes agree value 
consensus defined primitives propose decide 
consensus specified follows uniform validity process decides proposed process 
uniform agreement processes decide differently 
uniform integrity process decides 
termination non red process eventually decides 
consensus solved synchronous model asynchronous model failure detector green process 
asynchronous model consensus solved ct su act failure detector lam long green red 
stable storage consensus solved green yellow red act 
uniform total order broadcast total order broadcast communication primitive ensures processes deliver messages order 
primitive called atomic broadcast 
atomic broadcast defines primitives broadcast deliver 
defined properties reliable broadcast additional property uniform total order process deliver messages delivers delivers condition green red sufficient regardless fact model permits yellow processes 
chapter 
database group communication models total order broadcast reduced consensus problem ct 
implement total order broadcast consensus 
reason total order broadcast solved situations consensus 
total order broadcast augmented fifo property yielding fifo total order broadcast 
uniform non blocking atomic commitment intuitively protocol ensures processes vote outcome 
outcome 
atomic commitment problem originated database community usually defined properties uniform agreement uniform validity defined properties called blocking atomic commitment 
properties required uniform protocol called uniform non uniform specification considered 
uniform non blocking atomic commitment defines primitives ac vote ac decide 
nonblocking atomic commitment ensures properties uniform agreement processes decide differently 
uniform validity process ac decide process ac voted 
fair non triviality processes green ac vote infinite number times ac decided infinite number times 
termination non red process eventually ac decides 
intuitively non triviality property states goes wrong sites vote processes decide 
note property defined green processes 
logical specification non triviality strong non triviality processes ac vote processes green processes eventually ac decide 
main issue specification problem implemented imperfect failure detectors 
specification implemented failure detectors gue reducing consensus weak non triviality processes ac vote processes green suspected failure detector process eventually ac decide 
problem introduces failure detectors specification see section 
choose fair non triviality 
failure detector guarantees weak accuracy weak non triviality enforces fair property 

database systems proposition model defines failure detector guarantees weak accuracy weak triviality property implements fair non triviality property 
proof processes green eventually suspected weak accuracy 
suspected ac vote ac decide weak non triviality 
ac vote infinite number times ac decide infinite number times 
database systems previous section described model group communication 
section formal model databases 
previous section exclusively describes group communication system model section describe single non replicated database model communication considerations replica consistency criteria transactions distributed 
advanced communications primitives described section 
model mainly transactions correct execution 
interesting note properties defined data quite different group communication systems model defines properties events 
transactions transactions sequences data operations terminated control operation 
data operations read write control operations commit abort 
operations inside transaction certain order noted executed order 
formally database composed data items 
dn 
transaction op op 
op length defined partial order operations respect operator 
op read dk write dk 
opi op iff 
op abort op commit histories transaction executions inside databases formalised notion histories bhg 
history defines order set transactions executed database 

tj 
complete history partial order read write operations 
partial ordering expressed operator 
tk transaction part history 
chapter 
database group communication models 
tk partial orders tk compatible partial ordering 

transactions contain operations conflict touch data item dk write ordering operations ordering respective transactions 
operations op dk op dk op dk write dk op dk read write op dk issued op dk issued op dk op dk op dk op dk 
history prefix complete history 
history history obtained removing operations transactions commit acid properties histories specify operations execute inside transactions specify transactions interact system 
specified acid properties gr atomicity 
transaction changes state atomic happen happen 
consistency 
transaction correct transformation state 
actions taken group violate integrity constraints associated state 
isolation 
transactions execute concurrently appears transaction executed 
durability 
transaction successfully completed commits changes state survive failures 
definitions broad need clarified context 
atomicity 
atomicity ensures property changes transactions performed 
consistency 
consistency ensures data inside database stays consistent 
database consistency respect integrity constraints 
integrity constraints rules define state database legal transitions state permitted 
transaction lead state database respect constraints aborted 
consistency typically defined level application running top database 

database systems isolation 
transactions isolated ansi standard ans defines isolation levels 
consider level called serialisability gr 
serialisability strongest isolation level ensures effects transactions executing parallel equivalent sense effect write values read serial execution 
isolation levels include snapshot isolation permits transaction read old data 
weaker level isolation typically increase performance considered 
isolation handled concurrency control mechanism detailed section 
durability 
durability assumption server crashes eventually recover critical data stored stable storage 
acid properties hold committed transactions 
system guarantee acid properties transaction abort aborting transaction unilateral decision 
transaction aborted explicit instruction abort inside transaction database 
party transaction database decides abort transaction party prevent abort 
acid properties lead abort transaction 
stable storage resources available system able enforce atomicity durability disk space write items transaction 
database enforces integrity constraints ensure database stays consistent 
integrity constraints defined application database linked semantics information inside database 
instance certain account type negative balance 
result transaction violates consistency database aborted 
important note acid properties safety properties 
ensure wrong happens data 
guarantee system progress 
implement database system aborts transactions 
system respect acid properties 
poses problems integrating database system algorithms coming distributed system community liveness properties specified 
concurrency control isolation enforced simple way database transactions executed sequentially isolation enforced transaction needs aborted 
concurrency control policy inefficient reasonable concurrency control techniques try process multiple transactions parallel enforcing isolation 
main approaches concurrency control chapter 
database group communication models called optimistic pessimistic concurrency control described 
actual concurrency control system usually strictly optimistic pessimistic extremes 
operations op op conflict part different transactions access object op op write operation 
transactions conflict contain operations conflict op op op op conflict see section 
concurrency control mechanism handles conflicting operations conflicting transactions appear executed serially terms results read writes 
pessimistic concurrency control pessimistic concurrency control done locks 
access item database controlled lock 
transaction accesses object acquire locks 
transactions share lock conflict 
usually locking done phase locking protocol pl phase transaction acquires locks second phase starts locks acquired occurs operation read write 
second phase locks released 
variant strict pl 
case write locks kept transaction commits aborts 
phase locking guarantees isolation additionally strict phase locking avoids cascading aborts 
cascading aborts happen abort transaction forces database abort concurrency control reasons case acquired lock aborting transaction released 
turn aborting force database abort phase locking lead deadlocks 
deadlocks detected building wait graph finding cycles timeouts 
case conflict transactions aborted 
deadlocks avoided transaction known advance case stored procedures see section 
deadlock detection time non deterministic wait graph deadlock detection deterministic 
optimistic concurrency control optimistic concurrency control locks transactions executed concurrently 
commit time certified 
certification consists checking transaction execution respects serialisability property 
serialisability ensured instance transaction reads stale version object aborted 
optimistic concurrency control considered efficient low conflict rate situations requires book keeping permits higher concurrency 
high conflict situations abort rates tends rise making concurrency control policy unsuitable 

database systems transaction transaction conflict transaction transaction optimistic concurrency control non deterministic scenario drawback optimistic concurrency control fact deterministic wps 
transactions submitted order transactions abort cases 
illustrates problem consider transactions conflict started 
terminates started execution serial concurrency control reason abort transaction 
starts terminates concurrency control system need handle conflict instance aborting 
depending timing system transaction commit abort 
system non deterministic 
network model precise formal model network database system 
communications usually considered point point synchrony assumptions 
crash process detected time mechanism false suspicions process failing respond time crashed considered 
corresponds synchronous model known bounds message transmission delays relative speed processes section 
process model similar crash recovery model stable storage section 
processes assumed crash recover 
log database serves stable storage 
database networking architecture share stable storage component log 
distributed transactions distributed transaction processing relies protocols solution replication techniques rely different ad hoc mechanisms 
basic protocols generally broadcast primitive atomic commitment protocol 
broadcast primitive distribute transaction processes chapter 
database group communication models atomic commitment protocol decide transaction outcome 
atomic commitment protocol follows roughly specification described section common protocol phase commit protocol pc gr ensure termination property pc algorithm terminate 
algorithm called blocking 
phase commit protocol pc ske non blocking rarely performance reasons 
variants pc protocol optimised different cases 
variant pc merges broadcast atomic commitment protocol resulting protocol broadcast atomic commitment 
new variants pc protocol replicate components protocol order non blocking 
consider strict replica control replication correctness criterion equivalence 
criterion requires copies database mutually consistent update transaction 
local histories partial order copies enforce serialisability resulting system enforces copy serialisability 
practical issues quite possible design system consistent efficient model practical build practical issues 
models offer view system express certain things reasonable 
database systems advanced complex systems reduced simple model design dictated issues deployment compatibility standard compliance course performance 
understanding practical issues important constrain architecture 
architecture logical model considered practical reasons 
extent consideration hold group communication systems primitives specified section implemented weaker form offer guarantees better performance 
problem practical issues complicated working model originating different communities 
community hidden assumptions reasonable possible case assumptions conflict 
cases practical issues large impact replication techniques 
means replication technique different characteristics depending community 
case understanding practical issues possible understand difference variants 
section describes issues discusses implications 

practical issues client code group communication replication protocols tend peer peer approach 
system represented equal processes 
model represent capacities processes processing power memory 
processes act client servers 
process server soon application running inside process 
common clients group communication possibilities 
possible handle failures transparently client communicates group failure server hidden 
group communication tend consider peer peer architecture databases usually rely client server paradigm 
server client machines tend different characteristics fixed roles 
database applications run dedicated machines special hardware minimise crashes time raid disks ups power supply 
clients diverse interactive user terminals application code running pc middle tier sophisticated applications 
client machines crash disconnected 
client processes little local stable storage little processing power 
number client machines processes order magnitude greater server machines 
client machines distributed geographically different administrative domains 
means clients limited access database administrative structure replication scheme access control security reasons 
distribution heterogeneity issues assumptions client kept simple 
large number client machines deploying new protocols interfaces expensive task 
consider model client aware advanced replication protocol 
configuration information stored clients minimal clients know connect static set servers 
information static updated human management 
clients connect server act proxy client 
call proxy delegate server 
interaction client delegate done standard mechanisms sql stored procedures 
burden replication shifted servers 
enables different protocols architectures server server connections client server connections 
servers peer peer group communication techniques servers reside machines roughly capacities 
client server connection hand relies standard protocols middleware 
high level transactions communication client server done high level language sql 
request parsed server translated low level instructions executed actual database 
translation requires access meta data database quite large larger chapter 
database group communication models data 
includes optimisation phase tries find minimal set low level instructions needed execute high language command 
optimisation np hard problem approximated heuristics consumes lot processing power 
call high level transaction transaction submitted client server 
call low level transaction sequence read write operations described section 
formally difference high level low level transactions replication techniques easily handle 
techniques high level transaction transmitted replicas called high level replication replica parses transforms high level transaction low level transaction 
low level replication techniques transformation done delegate server low level transaction transmitted processes 
high level replication advantage requiring little modification database system pf 
high level transaction orders magnitude shorter equivalent low level transaction single query imply millions read operations 
means bandwidth scarce highlevel replication advantage 
hand low level replication means doing costly transformation give better performance kem 
techniques considered low level technique high level technique mention explicitly 
cold standby vs hot standby formally state database system expressed current state di initial state modifications 
applied 
means equivalent database server date database server stale state updates change state 
practice applying changes take quite lot time typically back needs apply modifications 
system unavailable time updates applied 
keeping update consumes large amount memory load high server crash 
reason database community distinction types strategies cold hot standby gr 
cold standby server server state date server list changes 
order date able accept transactions changes applied 
hot standby server changes applied immediately accept requests delay 
difference especially important replication schemes server acts primary backup case server recovering acting back date 
important issue cold standby hot standby flow control implementing cold standby easy changes simply logged stable storage 
installing changes takes time transactions need 
practical issues executed precise order 
means case hot standby flow control mechanism needed ensure backup overwhelmed new changes 
means additional messages communication rounds needed sure server stays hot 
cold standby situations flow control needed avoid slow backup overloaded 
algorithms formally need synchronisation rounds ensure correctness practice implement rounds enforce flow control 
interactive transactions vs stored procedures distinguish basic transaction types 
type interactive transactions typically described high level command language sql 
transactions issued human operator program running client machine issues sql commands 
cases control transaction located server client client program handled human operator 
transactions system know transaction operations contain data items touched 
call transactions dynamic transactions 
second type consists stored procedures 
transactions invoked remote procedure call rpc mechanism 
transaction invoked represented form code stored executed server 
stored procedures typically written experts application developers 
stored procedures offer better performance access control simplified application development 
advantage operations invoked data items touched known advance 
call transaction static transactions 
theoretical level difference slim practice difference important 
impact performance mun certain problems deadlocks avoided static transactions 
dynamic transactions imply server executing transaction communication channel client interact 
reason certain replication techniques handle static transactions 
determinism important issue replication determinism pol 
actual database systems wide range non deterministic mechanisms performance reasons 
database programs multi threaded scheduling threads typically controlled blocking unblocking input output operations unpredictable 
databases rely heavily time outs detect deadlocks 
leads non deterministic system 
problem determinism important assumption replication 
common way replicating data replicas process se superset known advance 
chapter 
database group communication models quence instructions order 
replication technique called statemachine replication sch requires replicated object behaves completely deterministic way 
tools techniques replicated applications deterministic ongoing research topic building deterministic database system important challenge clear possible losing performance 
issues related determinism databases communication primitives studied detail 
requiring fully deterministic database reasonable replication techniques require determinism proposed 
alas techniques require additional rounds messages sure different copies data diverge leading bad performance 
techniques designed cover middle ground require full determinism execution deterministic point 
express amount determinism define point determinism wps point execution transaction processing deterministic 
different replication techniques require different points determinism 
point determinism formally point determinism dp transaction operation transaction operation dp executes deterministic way 
means dp executed execution rest transaction deterministic 
main implication point reached position transaction serial history determined 
notion determinism related notion serialisation point 
serialisation points sp operation transaction sp transaction executes sp transaction serial history 
words serialisation point transaction executed position transaction serial history known fixed 
serialisation points points determinism 
reverse true database deterministic reorder transactions way offering serialisation point 
reason doing minimise number conflicts deterministic re ordering ped 
note local database concurrency control determines determinism point 
fully deterministic database point determinism operation transaction 
strict phase locking deterministic phase locks acquired system deterministic point determinism read write operation consider dynamic transactions 
databases interface atomic commitment order support distributed transactions point determinism operation assume outcome commit abort transaction known fixed 

practical issues transaction 
operation executed transaction ready commit system able commit transaction fixed position serial history transaction aborted 
direct consequence relationship serialisation point points determinism 
notion serialisation points determine database server participate distributed transaction 
database offers serialisation point participate distributed transaction explicit interface atomic commitment 
database servers offer explicit interface atomic commitment protocol serialisation point 
serialisation points points determinism techniques controlled atomic commitment point determinism 
database completely non deterministic point determinism dp deterministic operation operation termination operation commit abort 
replication schemes typically require certain points determinism 
concurrency control schemes unsuitable certain replication techniques 
unilateral aborts important aspect related determinism issue unilateral aborts 
normal operations database system decide abort transaction long committed 
reasons aborting transactions usually related concurrency control caused issues scarce resources instance disk space disk error 
replication techniques require determinism tolerate unilateral aborts address issues 
instance conservative resource handling policy sure resources possible 
option system compensating transactions run new transaction tries redo effects transaction unilaterally aborted 
technique federated databases build distributed databases databases built support atomic commitment 
problem compensating transactions carefully scheduled resulting state consistent 
option artificially crash server unilateral abort 
sense cases instance disk failure prevents server working cases artificial crash warranted instance transaction aborts temporary shortage disk space 
overhead crashing going recovery protocol usually quite high 
general introducing artificial crashes solve control problems considered expensive 
chapter 
database group communication models optimistic weak communication protocols primitives introduced section offer strong guarantees database replication schemes primitives guarantees enforce acid properties replicated database 
strong guarantees come price terms performance 
protocols implement weaker primitives proposed specified promise better performance stronger counterparts 
certain cases weaker primitives sufficient place stronger variants 
properties communication primitives usually ensure isolation atomicity properties transactions consistency durability usually enforced locally replica 
group communication primitives benefits diminished deadlocks rates haa 
communication primitive strong properties ensure isolation atomicity 
communication primitives instance total order broadcast atomic commitment primitive responsible ensuring portion properties 
carefully chosen weaker communication primitives 
instance techniques rely total order broadcast atomic commitment isolation atomicity ensured atomic commitment total order broadcast decrease deadlocks 
case total order broadcast weaker properties performance 
way weaker protocols build optimistic protocols ped 
weak protocol part strong protocol 
instance uniform total order broadcast seen non uniform total order broadcast additional communication round 
guess outcome total order broadcast delivered early confirmed 
processing take place 
promising weak protocols non uniform total order broadcasts best effort total broadcast 
non uniform total order broadcast non uniform total order broadcast ws defined weakening total order agreement properties non uniform agreement green process delivers message green processes eventually delivers non uniform total order green processes deliver messages delivers delivers difference uniform non uniform total order broadcast non uniform case process green deliver messages 
practical issues wrong order deliver messages delivered 
typically means process deliver messages wrong order crash 
best effort total order broadcast best effort total order broadcast offers weaker guarantees non uniform total order broadcast 
basically best effort total order broadcast try respect specifications enforce certain circumstances 
best effort algorithms easier implement model assumptions true time 
instance timed asynchronous model cf assumes clocks available bounds messages transmission processing times known synchronous model bounds hold called performance failure 
context algorithm timing assumptions 
long timing assumptions hold total order ensured 
periods instability performance failures occur rare total order broadcast primitive correctly time total order broadcast increase performance 
proportion order messages error rate message interval ms spontaneous ordering lan example best effort algorithm total order broadcast observation messages lan delivered total order time 
due fact ethernet backbone message transmitted time backbone enforces total order 
shows observed proportion spontaneously ordered messages lan setting 
axis represents interval messages sent axis represents percentage messages delivered order 
experiment done cluster pentium iii mhz machines mb ram base tv full duplex ethernet network interface interconnected ethernet hub 
experiment run percentage order messages chapter 
database group communication models framework 
see load message ms spontaneous ordering 
interesting result experiment messages delivered order error sequences positions 
sequence messages mi mi mi mi worst case spontaneous delivery order mi mi mi mi 
call amount reordering message reordering level 
conditions best effort implementation total order broadcast simply relies underlying total order correct time 
spontaneous ordering property optimise certain replication techniques discussed section 
summary synthetic model summary communities replicated database systems distributed systems motivation performance fault tolerance operation type system model consistency data processes multiple transactions synchronous single remote invocations synchronous asynchronous 
copy serialisability table summary communities table summarises differences communities 
line describes aspect replication communities approach 
motivation replication different case replication mean get fault tolerance way achieve better performance 
second difference semantic element replicated distributed system context unit replication process functional entity calculation 
database context data replicated 
operation type considered different distributed system models consider single events remote procedure invocations rpc database systems consider groups operations transactions 
network model different database systems usually built synchronous model distributed systems rely multiple different models synchronous asynchronous failure detectors 
consistency criteria different 
distributed system community application level consistency considered consistency defined 
summary synthetic model regarding delivery events typically causal order view synchronous order total order 
application level consistency criterion distributed system hw 
stronger serialisability 
synthetic model models database module section communication module section 
need define model system case replicated database system 
goal replace models described previous sections integrate larger model takes account practical aspects described section 
illustrates synthetic model 
replicated database server group group communications server clients clients clients server synthetic model consider database distributed servers 
sn server si contains full copy database noted di 
server si contains database server capable executing transactions local copy database server full database system capable ensuring acid properties transactions executes 
consider database servers 
sn form group access group communication primitives described section 
server process group communication system 
call combination server process replica 
depending model replica attached process crash recovery model multiple incarnations process crash recovery model 
shows relationship database server group communication process server machine 
left part shows crash scenario dynamic crash recovery model 
database server group communication process crash machine crashes 
recovery database server group communication process recover 
right part shows scenario dynamic crash chapter 
database group communication models recovery model 
case recovery group communication process recover new incarnation process created joins group 
distinction implication recovery process discussed chapter 
crash recovery model crash recovery model database recovers database server database server database server group communication process machine crashes group communication process process recovers group communication process database recovers database server database server database server group communication process machine crashes new incarnation process created group communication process relationship database server group communication process consider clients 
clients part group rely group communications 
clients access point point communications 
clients interact database sending transactions 
transactions stored procedures interactive transactions section 
send transaction client connects server sc 
client selects sc choosing list servers 
list static updated group communication system 
contains potential servers system 
client get response server try 
server handle client request instance recovering acting back refuse handle request 
client submits transaction tc sc call sc delegate transaction tc 
delegate responsible processing tc database behalf client transaction interactive interactions done client delegate 
transaction stored procedure delegate responsible sending result transaction back client 
client aware replication interacts delegate server 
replicated database appears single non replicated database client guarantees copy serialisability acid properties 
system hides failure failure delegate client 
client crashes transaction delegate aborts transaction 
delegate crashes transaction commit abort client needs consider quorum systems 

summary synthetic model connect delegate order check outcome transaction 
chapter 
database group communication models chapter classification replication techniques crude classifications false generalisations curse organised life 
george bernard shaw numerous database replication techniques database community distributed system community proposed literature 
comparing protocols developed communities frustrating exercise 
due subtleties involved mechanisms conceptually identical different practice 
difficult take results area apply relate replication techniques 
issue possibilities explored difficult see possibilities considered 
way understand compare replication techniques classifying 
possible see techniques related verify solution space completely explored 
probably best known classification database replication techniques proposed gray 
classification uses criteria transaction initiated context executed 
classification summarised 
criterion object ownership describes nodes data 
node owns data accept updates 
criterion decides node system transactions submitted 
data owned nodes system transactions submitted node 
data owned master transactions need submitted master 
group ownership category called update replication peer peer master ownership category called primary copy primary backup 
chapter 
classification replication techniques transaction execution context eager lazy group master eager group ownership lazy group ownership object ownership eager master ownership lazy master ownership gray classification second criterion defines scope transactions executed 
case eager replication updates replicas done scope distributed transaction transaction aborted point copy 
guarantees replicas stay consistent called synchronous replication 
case lazy replication transaction updates replica changes shipped replicas outside scope transactions 
lead inconsistent system case failure violate acid properties failures gol 
replication scheme called asynchronous replication 
useful classification coarse trouble coping non voting replication techniques 
techniques atomic commitment final synchronisation phase transactions classified lazy 
hand ensure execution transaction allowed commit committing eager 
led people call consistent lazy techniques haa 
existing taxonomies data replication techniques take account broad spectrum replication schemes including weak consistency availability properties including techniques group communication considering simple cases cp 
chapter describe classification focuses eager replication techniques emphasises synergy communication transaction management 
eager replication mean techniques enforce serialisability committing transaction non voting techniques included 
reasons focusing eager replication 
eager replication group communications sense group communication offer strong guarantees useful build replicated system strong guarantees 
second difficult compare strategies relax consistency 
models relaxed serialisability proposed klw kb tradeoff performance consistency clear consistency gives 
classification criteria performance 
measure loss consistency 
models relaxed serialisability proposed relationship lazy replication clear 
benefits classification effort numerous 
allows identify key components database replication protocol 
second helps better understand role played component influence nature protocol 
strategies consider described literature 
third classification forms basis quantitative comparison various replication strategies identified 
quantitative comparison chapter 
quantitative comparisons shed light different aspects eager replication role transaction management group communication play implementing eager replication protocols 
classification criteria eager replication protocols organised parameters determine nature properties protocol cases performance 
parameters server architecture section changes operations propagated servers section transaction termination protocol section 
server architecture parameter matches gray classification 
distinguish update group ownership primary copy master ownership replication techniques 
primary copy replication technique requires specific site primary copy associated data item 
sites considered backups name primary backup 
update data item sent primary copy processed executed analysed establish serialisation order 
primary copy propagates update results see section sites 
primary copy techniques distributed system community database community wps 
distributed system community called passive replication gs relies group communications mechanism specifically view select primary ensure primary system 
database community issues addressed ad hoc way 
chapter 
classification replication techniques expected primary copy approaches introduce single point failure bottleneck 
limitations solved making protocol complicated 
primary crashes servers takes role primary requires election protocol 
avoid bottlenecks databases single site primary data items 
data partitioned different sites primary different data subsets 
follows ignore aspects protocols orthogonal discussion 
update update replication allows updates data item performed system 
updates concurrently arrive different copies data item happen primary copy 
property update approaches graceful dealing failures election protocol necessary continue processing 
similarly principle update introduces performance bottlenecks 
update may require site doing primary copy sites sense bottleneck eliminated replicated 
careful design update may affect performance primary copy approaches 
server interaction second parameter consider related degree communication database servers execution transaction 
determines amount network traffic generated replication algorithm overhead processing transactions 
parameter expressed function number messages necessary handle operations transaction termination 
number network interactions impact design replication protocol 
design affect properties different communication protocol offer order uniformity 
consider cases constant interaction linear interactions 
mt number operations transaction kt number network interactions consider cases kt kt mt 
constant interaction constant interaction corresponds techniques constant number messages synchronise servers transaction independently number operations transaction 
formally means kt 
single interaction simple broadcast message advanced protocol complex properties total order broadcast 
replication techniques category constant number messages typically high level message imply low level messages 
rest 
classification criteria discussion consider constant interaction replication techniques single interaction 
simplifies discussion reducing model 
replication techniques category exchange single message transaction grouping operations transaction message 
interaction takes place depends nature transaction 
transaction interactive see section client delegate communicate execution transaction transaction known bundled message clients asks delegate commit transaction 
transactions static exchange take place anytime 
linear interaction describe technique having linear number interactions kt mt number network interactions kt handle transaction proportional number operations mt transaction replication techniques category typically propagate operation transaction operation basis 
operations sent sql statements high level transactions log records containing results having executed operation particular server low level transactions 
simplify discussion consider linear interaction replication technique uses mt messages mt number operations transaction transaction termination parameter consider way transactions terminate atomicity guaranteed 
distinguish cases voting termination non voting termination 
parameter distinguishes replication techniques need message exchange ensure acid properties techniques properties ensured explicit termination messages 
factor independent number interactions 
argue transaction termination simply additional network interaction copies database counted 
factor affect order number network interactions constant linear influence discarded 
reasoning legitimate interaction important impact design performance database replication schemes simplified away 
lazy replication schemes group communication schemes promise better performance removing simplifying phase 
termination phase typically implies synchronisation replicas operations stable storage 
operations expensive terms performance 
presence absence termination phase complexity important aspect database replication 
transaction termination traditionally associated properties replication hot cold standby safe safe 
primary copy replication scheme chapter 
classification replication techniques voting termination phase little flow control backup tend cold standby backups see section voting phase help backups hot standby mode 
transaction termination criterion related established way classifying primary copy database replications gr pgm 
context system distinguished number sites transaction guaranteed committed client receives commit confirmation 
safe techniques transaction guaranteed committed site primary delegate 
safe techniques guaranteed commit sites primary backups 
traditionally techniques considered safe replication protocol uses voting 
show chapter issue complex 
voting termination voting termination requires extra round messages coordinate different replicas 
round complex atomic commitment protocol described section simple single confirmation message sent site usually delegate primary sites 
difference atomic commitment protocol simple message impact database replication scheme 
simple message means servers delegate unilateral aborts 
termination phase simply absent 
replication scheme strong voting termination phase atomic commitment weak simple message 
strong voting implies decision abort transaction multilateral replica cause abort transaction 
weak voting means decision unilateral primary delegate decide abort transaction 
important aspect voting termination phase flow control 
strong voting phase servers tell delegate handle load 
slow server able cope load pending transactions means request servers slow 
situation eventually lead server overloaded fail 
atomic commitment protocol forces servers wait system naturally synchronise 
main drawback voting especially strong voting system waits slowest replica 
non voting termination non voting termination implies sites decide commit abort transaction 
non voting techniques require replicas behave deterministically replicas need enforce atomicity replicas abort transaction commit copy serialisability replicas execute transactions serial order 
restrictive may appear glance determinism affects transactions serialised re 
replication techniques spect 
transactions operations conflict executed different orders different sites 
determinism discussed section 
replication techniques section explore combinations result classification parameters section 
technique categories described parts description requirements discussion summary 
description paragraph describes general framework replication techniques 
existing replication techniques fit category listed paragraph relevant bibliographic 
requirement paragraph describes requirements needed build replication technique fulfilling classification criteria 
requirements expressed communication infrastructure database system server 
requirements communication system usually ordering uniformity constraints delivery messages database servers 
database system requirement determinism expressed terms point determinism 
update update techniques clients send requests server 
server contacted act delegate requests submitted client 
delegate process requests synchronise servers ensure copy serialisability 
update constant interaction non voting techniques description 
shows basic structure replication technique 
discussion follows assume network interaction servers 
simplification description clearer leave important detail 
protocols category execute steps 
transaction starts delegate server 

transaction processed non deterministic way 

point determinism reached 

transaction sent servers atomic commitment 

processing continues replicas deterministic way 

replica terminates transaction way 
chapter 
classification replication techniques transaction processing point determinism delegate server server interaction total order broadcast processing deterministic processing deterministic server transaction transaction update constant interaction non voting 
previous works update constant interaction non voting model divided point determinism placed 
point determinism transaction transaction processing deterministic role delegate server simply forward transaction total order broadcast primitive step description really apply 
delegate simply acts proxy client contacting servers process client request 
possible optimisation delegate transforms high level transaction low level done 
approach close active replication sch 
early example approach pgm 
techniques category kei 
technique described uses total order broadcast early point determinism certain forms optimistic transaction execution 
techniques point determinism transaction processing called certification techniques 
case transaction handled non deterministic way delegate stage processing certification deterministic 
certification stage executed sites allows decide transaction committed aborted 
pgs information read write operations sent sites order detect conflicts certification phase 
protocol haa uses similar approach 
techniques ka ka snapshot isolation serialisability avoid conflicts read write operations certification phase restricted write operations 
cases certification phase deterministic 
requirements 
discuss correctness distinguishing transaction atomicity copies database commit transaction correctness criteria 

replication techniques independently point determinism lies mechanism guarantee copy serialisability 
total order broadcast acts guideline sites 
site guarantees local serialisation order follow total order sites produce serialisation order see total order 
differences protocols lie determinism point 
protocols place determinism point transaction total order suffices 
protocols place determinism point transaction things bit complicated 
particular confronted situations transaction needs aborted delegate server abort transactions seen sites 
protocol ensure soon transactions seen sites problems scheduling sites aborting transaction 
related techniques category need distributed deadlock detection system 
transactions sent step total order broadcast locks transaction acquired atomically order sites preventing distributed deadlocks 
transaction atomicity enforced uniform reliable broadcast messages deterministic behaviour different servers 
guarantees server delivers message commits transaction server deliver message uniformity commit transaction determinism 
discussion 
uniform reliable broadcast transactions delivery advantage site commit transaction soon delivered waiting sites 
result improvements response time sites tightly synchronised locks released soon transaction finishes lock contention lower 
point determinism transactions usually implies datasets transactions known advance static transaction 
sent sites typically invocation stored procedure 
follows sites execute procedure deterministically voting phase 
limitations approaches making sites completely deterministic difficult practice 
points determinism transactions imposes lower burden database system 
late point determinism require static transactions writes differed transaction executed shadow copy fact point determinism comes transaction implications 
main degree optimism execution 
servers accept transactions abort 
tradeoff early points determinism abort rate 
having point determinism early means low aborts due conflicts 
having point late implies having higher chances conflicts 
intermediate solutions point determinism middle transaction chapter 
classification replication techniques compromise 
way implementing solution execute reads transaction writes atomic deterministic step 
case point determinism write operation 
summary 
replication techniques update constant number interactions non voting require total order broadcast 
database point view necessary determinism achieved ensuring local serialisation order matches total order resolving conflicts deterministic way transactions go point determinism 
update constant interaction voting techniques description 
shows basic structure replication technique category 
technique similar previous section interactions done communication phase 
additionally final voting phase executed transaction execution ensure replicas agree outcome 
execution done way transaction processing delegate server server interaction processing broadcast processing server voting transaction transaction update replication constant interaction voting 
transaction starts delegate server 

transaction processed non deterministic way 

transaction broadcast servers 

processing continues replicas 

voting termination phase takes place 

replica terminates transaction outcome voting protocol 

replication techniques 
example technique fc delegate server broadcasts transaction sites immediately submitted total order broadcast total order implemented synchronised clocks 
total order guideline site transactions 
final voting phase ensure atomicity case different types failures 
failures occur site atomic commitment needed 
example constant interaction voting protocol called serialisability protocol ka ka protocol haa 
protocols transaction locally executed delegate site sent sites total order broadcast primitive 
delegate site decide transaction commit abort 
situation leading abort due serialisation problems local reads global writes seen sites delegate site needs communicate decision sites 
means voting weak single message indicates delegate server committed aborted transaction 
consequence delegate site choice commit abort transaction unilaterally sites behave deterministically sense obey commit abort decision delegate 
third example optimised form pc described bhg 
protocol write operations deferred transaction phase pc vote request contains transaction updates 
participants protocol respond vote obtain locks updates 
respond transaction aborted 
case interaction enhanced version pc protocol 
techniques category related semi active replication pcd 
replication technique process deliver requests non determinism appears leader chosen leaders sends result execution processes called followers 
system handle transactions mean case doubt leader send followers outcome transaction commit abort serialisation order chosen 
course leader decide abort transaction send result abort followers 
requirements 
principle protocols type form broadcast primitive including unreliable broadcasts 
type broadcast primitive determines voting phase 
primitive guarantee sites processing voting phase atomic commitment part phase discrepancies sites resolved 
furthermore distributed deadlocks occur resolved 
broadcast totally ordered requirements similar section need global deadlock detection 
chapter 
classification replication techniques atomicity guaranteed depends protocol 
atomic commitment strong voting guarantees atomicity 
technique relies weak voting primitive broadcasting transaction uniform single broadcast ensures atomicity message sent uniform reliable broadcast 
discussion 
having voting phase relaxes determinism requirements database servers 
practice complete determinism database server difficult achieve protocols include voting phase form 
limited form determinism total order broadcast considerably simplifies protocols 
checking copies executed transaction serial order commit time implies large waste resources serial orders match 
conflicting serialisation orders different replicas cause rising deadlock rate described main problem eager replication 
total order broadcast help decrease conflicts having voting phase consisting complete atomic commitment allows relax requirements total order 
total order strictly enforced atomic commitment phase detect discrepancies 
properties total order enforced detected corrected atomic commitment 
means weak total order broadcast non uniform best effort 
summary 
requirements intertwined 
broadcast impose total order voting phase atomic commitment involve form certification 
total order broadcast voting phase significantly simplified confirmation message long sites deterministic obey unilateral decision delegate server 
update linear interaction non voting techniques description 
category somewhat misleading 
non voting implies round fate transactions agreed 
protocols fully deterministic 
constant interactions possibility send transaction 
sending operations time requires sites treat exactly way 
delegate site indicate transaction finished 
implies termination message 
assuming termination message voting general structure techniques category outlined 
transaction starts delegate server 

replication techniques 
operation sent servers total order broadcast 

operation executed servers 

items repeated transaction ends 

delegate sends termination message indicate transaction 
transaction total order broadcast processing processing operation operation delegate server total order broadcast server total order broadcast transaction processing processing operation transaction operation update linear interaction non voting 
example technique category 
operation reads included broadcast total order sites sites behave deterministically order react identically operation 
techniques haa fit category 
techniques category similar replicated persistent objects ls 
replicated persistent objects modified invocations 
invocations delivered total order objects processed deterministically 
multiple invocations part transaction 
transaction terminates invocation transaction processed 
requirements 
voting phase atomicity guaranteed sending operations total order broadcast broadcast 
copy serialisability result local concurrency control mechanism site determinism sites 
total order broadcast needs uniform sending operation 
problem non uniform total order broadcast risk delivering message order crashing 
consider transaction op op 
opi 
server delivers opi order crashes lead incorrectly serialised transaction committed violating copy serialisability 
total order broadcast uniform 
server delivers opi order crashes chapter 
classification replication techniques committed wrong serial order aborted wrong order restarted correct order 
total order broadcasts non uniform 
sites fully deterministic distributed deadlocks sites wait graph cycles graph imply site 
local deadlocks assumed resolvable deterministic fashion 
discussion 
technique major drawback requiring absolute determinism sites strong requirement 
addition considerable network overhead operation results totally ordered broadcast 
general technique pursued literature viable option 
summary technique requires operation broadcast reliable total order broadcast 
operation broadcast uniform total order broadcast 
transaction processing fully deterministic 
update linear interaction voting techniques description 
form database replication technique studied literature 
variations best known read technique bhg 
shows interactions techniques category 
transaction starts delegate server 

operation broadcast quorum sites 

operation executed quorum 

items repeated transaction ends 

voting protocol executed 

replica terminates transaction outcome voting protocol 

category includes traditional database replication protocols read write write available quorums bhg 
effort area devoted provide different ways build quorums 
surveys early solutions bhg 
approaches mainly optimise quorum sizes communication costs analyse trade quorum sizes fault tolerance ks rst tp 
saa multicast primitives different ordering semantics 

replication techniques transaction broadcast processing processing operation operation delegate server broadcast broadcast server processing operation transaction processing operation voting transaction update linear interaction voting authors propose algorithms reliable broadcast causal broadcast require atomic commitment guarantee serialisability 
technique described haa delegate uses total order broadcast send write operations replicas final broadcast send decision commit abort implementing weak voting protocol 
optimistic version atomic commitment reduce latency 
requirements 
copy serialisability achieved executing read operation read quorum replicas write operation write quorum 
site follows local concurrency control protocol guarantees serialisability typically phase locking tho time stamp algorithms bsr 
atomicity guaranteed atomic commitment typically pc voting phase 
total order broadcast send operations replicas technique conceptually similar technique described section sends writes message uses weak voting phase 
conceptual difference sending operations spread totally ordered messages 
requirements weak voting messages stay 
case operations send non uniform total order broadcast voting message sent reliable uniform broadcast 
discussion 
technique understood 
spite amount invested technique relevant practice 
reason high overhead linear number messages proven significantly limit scalability due deadlocks 
addition voting phase involves complete atomic commitment client gets response replica ready commit changes result long response times 
chapter 
classification replication techniques primary copy primary copy techniques clients send requests particular server 
means server acting delegate clients point time server called primary 
server executing transactions conflict transactions detected solved place 
global transaction conflicts distributed deadlocks 
thing assured primary system time 
primary copy approach widely eager replicated databases minimise conflicts transactions executed replicated data 
group servers needs know server primary 
clients access information see section simply try servers list 
server requested handle transaction primary reject request send back identity current primary 
having servers agree current primary problem solved consensus 
group communication system offers view primary chosen member view 
similar mechanism built perfect failure detectors 
refer sites primary copy data item backups primary copy techniques called primary backup techniques 
backups install changes sent primary 
distinction active passive backups 
active backup primary subset data backup data 
site primary data passive backup 
main issue active backups transactions update data multiple primaries 
replication techniques support transactions requirements update replication execution transaction synchronised replicas 
reason concentrate passive backup replication schemes section 
primary copy constant interaction non voting techniques description 
techniques category generally cold standby replication 
protocols general outline see 
transaction executed primary 

transaction terminates corresponding log records sent backups fifo reliable broadcast 

primary commits transaction waiting backups install changes 

backups eventually install changes 

replication techniques transaction primary server processing server interaction fifo broadcast transaction processing deterministic server transaction primary copy constant interaction non voting concrete nature protocol depends type broadcast primitive 
simplest form protocol fifo delivery order ensure transaction changes installed backup order executed primary 

techniques category typically described database literature safe cold standby primary backup replication techniques gr pgm 
passive replication gs fits category 
semi passive replication dss primary copy selected automatically context variant consensus update form value decided 
replication protocol fp replicates high level transactions uses total order broadcast protocol detect case concurrent primaries 
techniques send message transaction transactions grouped batches called epochs backups install changes batches gmp techniques design safe 
requirements 
case passive backups long transaction changes installed order primary backups consistently reflect happened primary 
primary sends changes fifo order producing correct histories backups 
fifo broadcast uniform broadcast ensures atomicity 
holds case active backups long transactions access data executing site primary 
care taken transactions allowed read data executing site primary transactions distributed update data different primaries 
case scenario similar update server architectures primaries send changes fifo order total order necessary 
chapter 
classification replication techniques discussion 
lacking voting phase type protocols naturally primary way waiting secondaries apply changes 
depending guarantees offered communication system techniques category safe safe see chapter 
backups passive installing changes sent primary determinism simply requires install changes order arrive primary 
backups active executing transactions behalf rules prevent inconsistencies 
rules summarised follows local serialisation order contradict order remote transactions arrive 
case strategies similar described section summary 
requirements technique follows communication primitive guarantee fifo order passive configurations total order active configurations 
primary copy constant interaction voting techniques description 
voting phase allows ensure primary backups install updates 
safe property ensured voting phase see chapter having voting phase traditional way enforce safety property 
voting offers flow control behaviour system wait replicas ready install change transaction committing transaction 
replica left see section 
protocol transaction processing primary server server interaction processing broadcast processing server voting transaction transaction primary copy constant interaction voting 
transaction executed primary 

transaction terminates corresponding log records broadcast backups 

replication techniques 
primary initiates atomic commitment 

transaction installed committed sites 

techniques category typically safe hot standby primary copy replication techniques 
requirements 
compared primary copy constant interaction non voting voting phase possible weaker communication primitive broadcasting discrepancies detected voting phase 
means fifo broadcast non uniform best effort 
primary waits backups installed transaction system 
weak voting scheme possible simply imply sending transaction log non uniform fifo broadcast sending termination message uniform reliable broadcast techniques cold standby 
messages merged technique equivalent non voting technique 
discussion 
nature broadcast primitive depends achieved 
principle voting phase anyway done atomic commitment requirement broadcast primitive transaction sent backups fifo 
problem transaction abort atomic commitment 
atomic commitment greatly optimised synchronisation point guarantee atomicity 
open research question balance aspects terms cost overhead 
backups active atomic commitment allows minimise scheduling constraints transactions executed determinism requirement serial order 
experience shows minimising constraints results high abort rates 
probably best total order broadcast locally follow delivery oder avoid unnecessarily high abort rates 
summary 
aborting transactions backups due serialisation problems inefficient fifo order passive backups total order active backups reasonable requirement technique 
primary copy linear interaction non voting techniques description 
constant interaction techniques waiting transaction ends order propagate changes means replicas trouble keeping date primary hot standby 
protocol faster backups process transaction parallel primary 
order primary sends operations executed allowing backups chapter 
classification replication techniques start doing 
voting phase involved protocol follows see transaction broadcast processing processing operation operation primary server broadcast server broadcast processing operation transaction processing operation transaction primary copy linear interaction non voting 
transaction starts primary 

read operations executed locally 

results write operations broadcast backups 

termination message indicates transaction 
replication techniques stream elements log captured fall category sta 
requirements 
backups receive operations transactions careful order changes installed 
case passive backups primary produces correct histories sends operations serialisation order fifo delivery guarantee correctness 
general sent backups log records log records produced serialisation order primary need extra effort ensure property 
backups active transactions may access data primaries determinism achieved relying total order 
total order correctness assured similar described section message sent uniform fifo broadcast 
reason broadcast needs uniform reason section update case operation leads commit 
voting protocol hot cold standby depends backups install changes save disk 

replication techniques discussion 
sending operation executed primary allows backups parallel introduces significant message overhead 
transactions typically update operations 
sustain throughput transactions second communication system capable supporting traffic broadcasts second system 
practice biggest bottleneck type protocols 
summary 
type protocol requirements communication primitive guarantee fifo delivery passive backups total order active backups operations 
communication primitive guarantee uniform delivery message containing operation 
primary copy linear interaction voting techniques description 
techniques described section purpose introducing voting phase ensure hot standby behaviour transaction broadcast processing processing operation operation primary server broadcast broadcast server processing operation transaction processing operation voting transaction primary copy linear interaction voting 
transaction starts primary 

read operations executed locally 

results write operations broadcast backups 

primary starts atomic commitment protocol 

transaction installed committed sites 

corresponds classical database replication scheme distributed transaction 
similar described section chapter 
classification replication techniques requirements 
compared non voting correctness affected voting phase 
active backups free abort transaction propagate decision atomic commitment phase 
voting phase responsible atomicity fifo broadcasts need uniform 
discussion 
primary constant interaction voting techniques atomic commitment transaction removes requirements broadcast primitive 
fact protocol similar traditional replication protocols discussions section context voting techniques apply 
summary 
requirements technique minimal 
aborting transactions serialisation problems backups usually acceptable fifo respectively total order broadcast reasonable requirement technique 
discussion overview requirements primary copy update strong voting weak voting non voting atomic commitment atomic commitment fifo reliable broadcast uniform reliable broadcast total order broadcast uniform reliable broadcast uniform fifo reliable broadcast uniform total order broadcast requirements classification shows summary requirements different techniques classification 
clarity constant interactions techniques shown 
requirements linear techniques basically constant interaction techniques simply broadcast broadcasts 
additionally broadcast constant interaction techniques needs uniform corresponding linear interaction technique require broadcast uniform see section 
see symmetry primary copy update 
update technique requires total order broadcast 
discussion corresponding primary copy technique requires fifo broadcast requirements reliability uniformity stay 
primary copy scheme primary knows order messages delivered fifo broadcast sure serialisation problem 
server architecture primary copy vs update update desirable solution promising load balancing easier configuration actual techniques nowadays techniques 
reason simplicity 
primary copy techniques implemented relatively easily instance high level techniques triggers stored procedures sta gol 
cases primary copy runs unmodified version database special process capturing updates sending back ups bt 
update necessarily distribute load sites 
data replicated sites need perform updates anyway 
means significant amount read operations load read operations local system scale server nodes added 
way improve performances update preprocess operations site send results sites transform highlevel transactions low level transactions kem 
way processing need done 
mechanisms place update attractive solution robust failures facilitates distributing load sites 
server interaction constant vs linear number messages exchanged transaction key aspect replication protocol 
pointed sending message operation quickly lead unacceptable traffic rates 
addition messages need processed site significantly increases load 
operations arrive different points time coordinating execution result correct complicated 
rule thumb say messages exchanged transaction better 
instance protocols linear interaction combination update largely infeasible databases 
exactly type protocols heavily criticised database community unrealistic 
primary copy case things bit different consequences messages exchanged negligible 
particular sending updates message transaction help propagate changes transactions commit 
chapter 
classification replication techniques sending changes abort useless lowers performance uses network bandwidth transmit unneeded messages cause contention servers 
transactions requests locks operation logged 
exchanging message transaction introduces problems 
protocols especially service requests data accessed known advance 
case implementation straightforward abort rates small 
techniques optimised order handle network protocol transaction processing parallel yielding better response times 
ordinary transactions form optimism execute transaction delegate server determine serialisation order 
conflict rates high optimism result high abort rates 
techniques delegate needs wait message reach servers able decide outcome transaction 
means write locks held time lead high lock contention increase response time 
transaction termination voting vs non voting techniques non voting techniques demanding terms determinism requirements voting techniques 
non voting protocols server independently guarantee serialisation servers 
typical way total order guideline 
general transactions conflict serialisation order indicated total order 
depending protocol sites need known different things order ensure global correctness voting 
protocols transaction read operations included sent 
protocols site performs equivalent global scheduling system long scheduling deterministic correctness guaranteed 
determinism implemented total order transactions 
protocols update operations sent 
protocols careful read operations seen sites alter serialisation order 
means servers know read operations decide execution 
voting allowed transactions known sites take priority case conflicts local transactions aborted local meaning seen sites 
terms voting techniques considered possibilities atomic commitment confirmation message sent delegate primary copy indicate transaction committed aborted 
confirmation message needed delegate server primary copy transaction unilaterally decide outcome transaction 
remote sites behave determin 
discussion way able obey commit abort decision delegate server 
atomic commitment server reject transaction relaxing determinism requirements chance resolve things atomic commitment 
unfortunately shown cases coordination overhead higher conflict abort deadlock rates quickly bottleneck 
additionally voting provide atomicity take place sites completely executed transaction 
means delegate server waits slowest replicas finish processing returning result client increasing transaction response times considerably 
chapter 
classification replication techniques chapter recovery fault tolerance issues succeed run risk failure 
dan goals replication fault tolerance certain replica crash database available 
chapter examine fault tolerance guarantees obtained basing database replication group communications 
basic safety criteria database world safety safety gr 
traditionally recovery systems group communications view change mechanism 
show chapter mechanism adequate building safe replication show adequate recovery mechanism 
introduce new safety criterion stronger safe weaker safe call group safe 
criterion suited group communication replication permits implementations promise increased performance 
chapter structured follows section introduces safe safe safety criterion 
section introduces view group communication systems 
section explains current shortcomings building safe replication technique 
section shows shortcomings corrected basic recovery mechanism view system build safe replication technique 
section discusses check pointing mechanism needed safe replication 
section introduces new safety criterion discusses implications 
chapter 
recovery fault tolerance issues safety criterion safety criteria called safe safe safe gr 
client receives message transaction committed durability ensures effects transaction preserved stable storage 
depending safety criterion transaction lost case crash 
safe technique safe client receives notification commit committed delegate primary server safe technique safe client receives notification commit guaranteed eventually commit servers 
safe technique safe client receives notification commit guaranteed committed servers 
safety criterion different tradeoff safety availability system safe replication ensures transactions accepted transactions get lost case crash 
safe system ensures transaction committed servers means single crash renders system unavailable 
criterion practical systems safe safe 
distinction safe safe replication important case crash 
technique safe transactions get lost server crashes takes 
technique safe transaction get lost servers crash 
safety constraints implicitly assume read write policy 
safety constraints difficult map general quorum replication 
quorum system transaction commit certain replica 
quorums considered discussion 
view recovery existing systems database replication group communication usually considers group communication defined dynamic crash recovery model haa ka ped pf 
reason current toolkits bj dm model 
recovery model view mechanism see section 
crashed replica recovers view change occurs 
group communication system requests state replica transfer replica action called state transfer 
words group communication system forces checkpoint replica roll forward recovering replica checkpoint 

view recovery application recovery mechanism replicated databases described 
optimisations needed avoid transferring state database time database server recovers conceptually recovery mechanism stays 
issues view system 
view systems tolerate total crash server crash group communication layer blocks system recover 
precludes current group communications building safe replication techniques 
safety places bounds number crashes safe technique able tolerate arbitrary number servers crashing 
second view system tolerate total crash recovery mechanism insufficient ensure safety 
problem discussed section 
roll forward recovery main issue state transfer recovery scheme insufficient build safe replication regardless fact group communication layer tolerate total crash 
client notified commit transaction guarantee committed delegate 
group communication ensure commit merely message containing delivered view 
committed crash effects applied recovery mechanism 
crash occurs replica recover replica available state 
basic assumptions roll forwarding replica available state transfer 
replica consistent state state transfer replicas consistent state crashed recovery impossible 
reason group communication systems view change mechanism safe 
processing broadcast deliver committed deliver deliver committing committing committing unrecoverable failure scenario client notified recovers recovers chapter 
recovery fault tolerance issues illustrate problem consider scenario transaction submitted delegate replica sd 
terminates sd sends message containing replicas 
message sent total order broadcast 
delegate sd delivers locally commits confirms commit client crashes 
sd processed crashed commit 
replicas deliver crash committing system rebuild consistent state includes changes 
technique safe 
failure scenario illustrates issue non voting replication technique similar scenario exist replication schemes including voting replication schemes 
mean voting replication safe 
voting replication usually done atomic commitment protocols dynamic crash recovery model 
instance pc protocol includes logging phases crash occurs protocol decision protocol played back recovery 
impossible build safe replication technique group communication system crash recovery model 
reason group communication system guarantees messages delivered view offers guarantees application able process messages 
fact message delivered mean processed application 
recovery schemes hol assumption simply incorrect 
build safe replication need model group communication system 
roll back recovery order build safe database replication scheme need solve issues related view recovery 
safety property ensure safety need group communication system ensure messages delivered processed application database 
order sure recovery possible recovery roll backs roll forwards 
order get need synchronise application layer group communication layer 
outlined section application layer group communication layer contain state information 
key issues recovering database replication technique group communications synchronisation application layer database group communication system 
transactions executing time crash lead problems 
delivered group communication layer committed database 
layer 
roll back recovery processed 
recovery application group communication layer need synchronise restore transactions 
need define precisely relationship group communication layer application layer 
inter layer messages application group communication infrastructure communication infrastructure physical network protocol stack shows classical layered model consider 
top layer application group communication system underneath communication infrastructure physical network 
layer relies layers underneath implement services offers layer 
inter process communications specified inter layer communication specifically communications group communication layer application layer defined partially typically form function calls hides confuses flow control 
optimisation group communication primitives need change interfaces dss 
express communication group communication layer application layer messages 
application executes certain primitive sends message group communication layer 
group communication layer delivers message decision application group communication sends message application 
instance replica delivers message message sent application group communication layer 
way model inter layer intra process communication chapter 
recovery fault tolerance issues way inter process communication 
main difference layers share process fail moment 
channels communication reliable message loss case crash 
application send deliver group communication infrastructure messages exchange total order broadcast shows instance messages exchanged application group communication layers total order broadcast protocol 
application wants send message message delivered application 
inter layer ack messages specification group communication primitives ensures messages sent group communication application precise circumstances precise order 
specification guarantee application able handle messages 
application handle message crash say delivery unsuccessful 
application roll back delivery delivered replayed rr 
ensure group communication system needs know application finished processing delivery successful 
done having application send message ack group communication layer processing finished 
mechanism similar messages inter process communications 
assume behaved application application receives message group communication layer send ack soon possible 
application waits forever sending ack 
crash occurs group communication layer receive message ack sent application 
crash group communication layer replays messages ack message ack received application 
replaying messages group communication layer ensures process eventually stable non red 
roll back recovery ally successfully delivered 
application send deliver ack group communication infrastructure messages exchange total order broadcast including ack message shows exchange messages total order broadcast including ack message 
application sends send message group communication layer 
deliver message received application 
application processes sends back ack message signal successfully delivered note group communication layers needs garbage collect certain resources messages stored memory stable storage identifiers group communication layer receives ack resources associated reclaimed 
mechanism minimise log usage total order broadcast similar idea 
safe replication conditions needed build safe database replication scheme group communication 
order safe replication scheme ensure eventually transactions terminated correctly non red replicas 
decision commit transaction delivered message committed successfully delivered 
group communication layer ensures messages eventually successfully delivered replicas replicas crash green replicas replication technique safe 
summary need conditions group communication layer tolerate processes crash green 
group communication layer replay messages successfully delivered non red processes 
specifications group communication primitives described section need refined integrity constraint guarantees messages delivered 
messages replayed message delivered multiple times successfully delivered 
chapter 
recovery fault tolerance issues properties achieved relying crash recovery model stable storage see section 
formally group communication layer simply needs log message sending application 
group communication layer receives ack deleted stable storage 
practice logging merged logging operations group communication layer cause additional performance penalty 
processing broadcast deliver deliver deliver committed committing committing committing client notified recovery message replay ack recovers deliver committed committing recovers ack deliver committed committing ack shows scenario group communication layer survive total crash replays messages 
crash occurs replicas rolled back delivery delivery restarted eventually delivery successful committed 
way safety ensured 
group safe replication group safety shown section techniques dynamic crash model safe 
techniques safe client notified commit commit delegate server servers 
traditional safe techniques lose transactions server primary delegate crashes gr 
case techniques group communications primary delegate server crashes broadcast mechanism ensures transaction reaches servers committed 
transactions lost servers crash compromise group instance model asynchronous imperfect failure detectors majority servers crash transactions get lost see section 
group communication group communications crash recovery model processes crash implies stable storage messages logged 

group safe replication replication schemes enforce safety level stronger safety weaker safety 
call safety level group safety 
replication technique group safe client receives confirmation transaction commit transaction delivered available replicas 
traditionally database systems rely stable storage ensure durability transaction committed lost 
stable storage fail durability ensured 
group safety relies group replicas 
group fail instance majority non crashed replicas durability ensured 
notice group safety specify transaction committed replica 
client notified transaction commit committed replica 
transaction delivered replica replica replica transaction committed replica processing safety zero safe replica replica safe group safe group safe safe group safe safe table summary different safety levels relationship group safety safety criterion described section summarised table 
classification criteria number servers delivered transaction vertical axis number servers committed horizontal axis 
depending safety level transaction delivered certain number replicas committed certain number replicas 
transaction committed site delivered part table committed delivered grayed 
position remaining table corresponding safety level described processing transaction delivered replica processing possible 
safety case client notified transaction delivered executed server sd commit 
safety enforced 
chapter 
recovery fault tolerance issues sd crashes writes flushed sable storage lost 
call safety zero safe replication 
safe safe system client notified transaction delivered committed server sd 
sd crashes sent servers get lost 
situation occurs system accept new transactions conflict server sd knows alternative losing block new transactions sd recovers 
group safe client notified transaction delivered available servers commit servers 
group fails typically servers crash lost exact value depends model group communication system see section 
group safe safe client notified transaction delivered servers commit server sd 
system group safe safe call safety level group safety 
transaction lost servers server sd crash 
proposed database replication strategies group communication fall category 
safe client notified transaction delivered committed available servers 
transaction get lost 
consider number crashes tolerated basically safety levels table 
zero safe safe replication tolerate zero crashes single crash mean lost transaction 
group safe replication tolerate crashes safe replication tolerate crashes number servers 
number crashes safety constraint crashes zero safe safe crashes group safe group safe crashes safe table safety constraints number crashes difference zero safe safe replication behaviour case crash primary delegate 
crash occurs transaction processed lost technique zero safe 
technique safe committed server sd preserved stable storage 
restored system waits sd recover 
conflicting transaction accepted moment restored 
zero safe replication lost crash safe replication lost crash conflict 

group safe replication difference group safe group safe replication similar 
servers crash total crash processing replication scheme group safe lost stored stable storage 
replication scheme group safe servers crash processing committed stable storage server sd 
means restored system waits sd recover 
advantage safe zero safe group safe group safe possibility restore transactions stable storage 
safe group safe tradeoff availability accepting new transactions safety potentially violating acid properties committing transactions conflict 
waiting primary server recover acceptable alternative losing transactions primary copy setting number servers small primary restored short time 
setting servers act delegates acceptable option means system withstand total crash recover crash recovering replicas 
practical update setting difference group safe group safe replication terms availability fault tolerance negligible 
group safe replication offers possibility restoring transactions stable storage practice possibility lowering availability system 
group durability group communication replication techniques group safe 
enforce safety group safety practical difference safety criteria small 
advantages enforcing group safety safety 
non replicated setting writing stable storage necessary ensure durability 
expensive part transaction processing composed writing data stable storage 
transaction commit changes stored form stable storage 
read operations optimised mechanisms likes caches force writes generally expensive 
key idea group safe replication durability ensured stable storage anymore group group servers 
non replicated safe replicated database durability ensured stable storage 
long stable storage fail transactions get lost durability guaranteed 
group safe replication scheme durability ensured group group fail servers fail transaction lost durability guaranteed 
group safe replication technique require replica finished commit responding client 
response sent client actual force write operations executed 
transfer chapter 
recovery fault tolerance issues ring responsibility durability stable storage group sense lot sense 
sending message network faster writing data disk 
group safe replication lazy replication weak consistency group safe replication server server strong consistency disk disk weak consistency strong consistency server disk lazy safe replication weak consistency group safe replication lazy replication server disk strong consistency conceptual level group safe replication complement lazy replication 
approaches try get better performance weakening link elements system 
illustrates relationship 
group safe replication relaxes link server stable storage transaction commits state memory stable storage different writes committed disk 
lazy replication relaxes link replicas transaction commits state different replicas different replicas seen transaction 
approaches relax link synchronisation cost deemed expensive 
main differences cases conditions lead violation acid properties 
update setting lazy technique violate acid properties failure occurs 
hand group safe replication violate acid properties group fails instance majority servers crash 
group safe replication large advantage lazy replication cases number replicas large 
main problem lazy replication lies reconciliation number servers grows chances transaction originating different sites conflict grows 
chances acid properties violated grows number servers 
replication problem reconciliation hand acid properties get violated servers crash 
increases number failures needed violate acid properties increases 
assume probability failures occurring time decreases increases higher number replicas lower chances having 
lost transaction 
chances bad happens increases lazy replication decreases group safe replication 
building group safe replication technique group communication replication techniques described literature safe group safe 
transformed group safe replications techniques quite easily 
group safe replication basically means disk writes done asynchronously outside scope transaction enabling optimisations write caching 
typically disk writes done immediately periodically 
writes adjacent pages scheduled maximise drive throughput 
increased safety group safe database replication choose dynamically change policy regarding writes 
normal operation mode writes asynchronous technique group safe 
problematic situation instance certain number server crashed writes synchronous technique group safe 
group communication database replication promising approach database replication existing safety properties adapted quantify new techniques 
traditional safety criteria safety safety implicitly assume durability ensured stable storage 
group communication infrastructure build true safe replication techniques exists theory practical implementations available 
implementation crash recovery model additional layer top existing group communication toolkits 
second case second explicit round messages needed signal messages logged stable storage kei 
group communication safe replication techniques possible address issues classical safe replication techniques deadlocks haa 
network protocols needed build safe replication need access stable storage 
stable storage implemented disk resulting protocol certainly slow traditional safe techniques 
group communication replication techniques proposed safe offer safety 
techniques safe group safe 
removing safety criterion move responsibility durability stable storage group 
executing writes outside scope transaction known way improve performance transaction processing systems generally implies enforcing durability 
group safe replication enforces durability offers availability fault tolerance chapter 
recovery fault tolerance issues group safe replication increased performance 
simulations show see section performance group safe replication offers alternative lazy replication better performance better consistency 
shows performance obtained database replication sacrificing consistency 
interesting note approaches described chapter functionality log transferred group communication system 
safe replication group communication layer logs messages delivering transactions need logged application level logged group communication system 
case group safe replication safety enforced group writes done asynchronously logging sense 
fact group acts replicated volatile log messages kept replicas stable storage 
shows clearly build efficient replicated database system logging facility group communication layer need carefully integrated 
chapter performance comparison life increasing speed 
gandhi chapter presents quantitative comparison different replication techniques 
comparison performed simulator 
simulation studies investigate techniques group communication described literature haa kem 
simulation includes detailed model network layer covers replication algorithms simulated 
presentation simulation results follows structure classification chapter 
class linear interactions non voting shown perform badly haa simulated technique class update category 
group communication replication techniques simulated classical replication strategies lazy replication distributed locking primary copy replication 
group communication techniques called database state machine certification replication compared simulation replication techniques 
additionally performance gains realised optimisations group communication replication techniques evaluated 
chapter structured follows section describes architecture simulator presents different replication techniques 
section describes general settings experiments section describes different experiments results 
section discusses results compares simulation performance measurements literature 
chapter 
performance comparison rd sim simulator experiment described chapter performed discrete event simulator rd sim 
simulator written relies sim discrete event simulation engine mes 
goal detailed simulation get understanding different parameters database replication interact 
resulting simulator lines code long 
simulator roughly divided conceptual parts clients servers 
clients represent source transactions generate transactions certain parameters send servers collect performance data 
servers implement replicated database logic including local database group communication system replication strategies 
simulation concentrates low level aspects 
high level issues transaction parsing optimising considered 
server structure architecture servers follows logical structure outlined chapter 
replica network node group communication stack local database system 
simulator structured large modules illustrated 
modules 
low level machine module 

communication module 
database module 
database replication module communication module database module run top lowlevel machine module 
implement group communication infrastructure local non replicated database respectively 
database replication module represents replicated database implemented top group communication module database module 
modules implemented classes export relevant functionality 
machine module machine module represents hardware machine 
machine modules simulate servers 
instance module server system 
server machine simulated basic resources cpu disks 
resources high level modules simulator 
cpu resources model processing units 
disks resources database module 
basic input output operations cpu disk resources 

rd sim simulator database replication module communication module machine module database module general simulator architecture theses low level resources cpus disks simulated sim resources 
high level operations execution network protocol transaction operation implemented executed simulator 
simulations replication techniques group communication kem haa simulate high level protocols total order broadcast single operation 
hides complexity group communication sub system ignores interactions communication system database system instance cpu processing transactions sending messages 
simulating system finer granularity possible understand role low level resources play performance different replication techniques 
way see influence network performance system 
communication module communication module models network interactions 
instance module server 
low level point point multicast messages modelled 
high level group communications primitives described section implemented top low level messaging facilities 
high level primitives total order broadcast result simulated execution total order broadcast protocol low level messages 
algorithms simulated failure free runs common case normal operating conditions 
communication modules relies kinds simulated resources cpu network 
cpu resource exported machine module 
network resource shared communication modules servers represents network servers 
sending message modelled steps outgoing message processed sending node message transits network message processed receiving node 
resources queues handled fifo policy 
means resources involved simulating sending message cpu resource sending machine network resource cpu resource receiving chapter 
performance comparison machine 
way model network cpu contention messages contention communication system database system 
database module database module simulates single database system 
modules includes lock manager manager 
lock manager offers lock queues item database 
lock queues enforce strict phase locking pl locking manager supports locking operations atomic locking transaction force locking inserting locks front lock queue 
variants typically non voting replication techniques 
manager handles operations read write items database 
data items distributed different disks machine disk holds partition data 
manager simulates cache system 
database replication module module represents database replication strategy 
instance module server 
depending replication strategy different implementation module 
replication scheme represented concrete subclass database replication class 
implemented strategy update category non voting update constant number interaction section 
category considered interesting replicated databases 
algorithm category simulated haa performance significantly worse group communication techniques 
implemented update replication techniques group communications distributed locking replication technique 
additionally implemented primary copy techniques cold standby lazy non replicated technique get relative performance 
implemented techniques replication 
special setting lets system run single non replicated database standard phase locking pl 
useful comparison purposes 
active replication 
technique fits update constant interaction non voting category early point determinism section 
point determinism transaction 
transactions simply forwarded servers total order broadcast 
servers process transaction deterministic way 
technique requires static transactions see section 

rd sim simulator optimistic active replication technique variant active replication scheme optimistic assumption network spontaneous ordering see section 
transactions delivered total order determined processing starts tentative order 
total order determined system checks execution tentative order respects copy serialisability 
case execution aborted restarted definitive total order 
algorithm name fine granularity locking fg locking 
certification 
technique described pgs ped database state machine name 
fits update constant interaction non voting category section active replication 
difference active replication certification replication position point determinism 
certification technique point determinism late operation termination transaction 
transactions executed delegate 
commit time transactions sent replicas total order broadcast 
certification mechanism checks transaction conflict transactions currently executing 
case transaction aborted replicas 
certification test uses conflict list contains list transactions delivered committed servers van 
group safe certification 
technique group safe variant certification technique see section 
technique similar certification technique uses asynchronous write operations 
weak voting 
technique described kem name ser 
fits update constant interaction voting category section 
similar certification technique relying deterministic certification test delegate checks execution transaction sends outcome abort commit transaction reliable broadcast 
distributed locking 
technique fits update linear interaction voting category section 
classical read write technique 
operation broadcast replicas locks acquired name operations executed 
traditionally deadlock detection done timeout mechanism implementing mechanism introduce additional parameter simulator 
timeouts deterministic imply locking system different techniques comparison valid 
avoid problems distributed deadlocks resolved building wait graph 
cost deadlock detec chapter 
performance comparison tion mechanism included simulation distributed locking technique relies perfect cost deadlock detector 
issue distributed deadlocks rare simulation settings 
primary copy 
technique fits primary copy constant interactions non voting technique section 
typical cold standby primary copy techniques 
lazy update 
technique implementation lazy replication scheme 
implementation conflict detection reconciliation function 
technique simply executes transaction delegate ships updates replicas 
consistency checks done 
processing minimal replication technique outperform 
price pay system violates acid properties 
technique implemented simulator give upper bound performance lazy replication considered efficient eager replication 
client module clients replicated database system modelled addition servers 
clients simple sources transactions 
clients submit transaction wait processed sleep time start cycle 
client submit transaction time multiple sources modelled multiple clients 
important parameter clients time submitting transactions 
parameter time start transactions 
client starts transaction time transaction finished clients waits time issuing transaction 
variable random variable exponential distribution mean matches requested interval transactions 
adding randomness avoid bursty load situations 
typically server clients attached 
replication strategy update server number clients attached 
replication technique primary copy primary clients attached 
clients consume network bandwidth consider network interface interconnects servers separate network interface communicate clients servers 
clients gather performance data compute statistics 
clients control simulations runs experiment settings typically stopping simulation results obtained fit certain confidence interval 
client request consume cpu resource delivered considered part transaction parsing optimising considered 

simulation settings simulation settings performed extensive set simulations compare different replication techniques 
techniques shared infrastructure layer operational parameters 
main performance metric mean response time observed clients 
simulation run value confidence interval half width mean response time better confidence interval obtained 
avoid skewed measures due initial startup factors jai response times associated transactions discarded 
parameter value number items database number servers number clients server disks server cpus server transaction length operations probability operation write probability operation query buffer hit ratio time read ms time write ms cpu time operation ms time message network ms cpu time send receive message ms time broadcast network ms cpu time send receive broadcast ms table simulator parameters general simulations run operational parameters table parameters variables experiment 
load settings 
consists clients connected servers clients server technique update clients connected primary technique primary copy 
settings consists clients connected servers clients server update techniques clients connected primary primary copy case 
data set contains items 
servers composed cpus data disk units 
cpu access disk cpu access disk time 
data items distributed different data disks 
transaction length uniformly distributed operations 
transaction update transaction query transaction 
queries contain read operations updates contain read write operations 
chapter 
performance comparison read write operations access item database uniform distribution 
write operation overwrite read data uniform probability database size operating read write operation uses disk ms uniform distribution 
read operations chance hitting cache occur disk usage 
input output operation read write cpu overhead ms database settings numbers literature acl haa kem 
network settings observed values cluster pc machines 
machine equipped mhz processor mb full duplex network interface 
machines connected ethernet hub 
network performance estimated framework sending short messages approximately bytes 
sending point point message consumes ms cpu sender ms network resource ms cpu receiver 
assume low level multicast facility ip multicast send multicast single operation 
cost ms network ms cpu sender receiver 
experiments settings roughly represent mb network slower network adapters 
case cost sending receiving message ms cost message transmission ms call setting mb fast network setting second slow network setting mb 
experiments performed experiments compare different database replication strategies 
section presents different experiments results 
experiment explores different aspects replicated database 
section presents performance different techniques section explores issues scalability techniques behave number server increases 
section examines certain replication techniques distribute execution queries 
section shows group replication techniques perform wan setting 
section presents experiments compare group safe replication safe replication 
section compares performance optimistic active replication active replication 
section discusses different results 
general performance description experiment experiment aims comparing performance different replication techniques moderate high load medium number servers 
compared performance different replication techniques varying system load 
done changing time interval clients wait 
experiments issuing new transaction time measured transaction starts 
time transactions ms ms ms increments 
experiment done clients clients server 
clients load varied transactions second clients load varied transactions second 
experiment done slow network settings mb fast network settings mb 
gave basic settings summarised table 
operational parameters experiment described section 
medium load slow network medium load fast network mb mb high load slow network high load fast network mb mb table settings simulating performance replication techniques results response time ms active certification distributed locking primary copy lazy ser load transactions sec performance replication techniques medium load slow network medium load slow network illustrates result experiment clients server slow network 
experiment shows performance different replication schemes operating conditions 
axis represents load system expressed transactions second 
axis represents average response time committed transactions 
replication technique represented performance curve 
chapter 
performance comparison observed conflict rate local database managers changed depending replication technique low load situation high load reach 
abort rate techniques shown 
lazy replication scheme enforce consistency 
give form best performance achieved setting 
technique little extra processing synchronisation performance affected changes load 
basically performance lazy replication servers equivalent non replicated servers getting load 
low load situations left part graph techniques similar performance certification ser active primary copy basically response time 
reflects fact techniques fit category constant number network interactions 
lazy replication outperform techniques small margin 
main advantage lazy replication load balancing load limited results small difference 
explains noticeable difference techniques load balancing certification replication primary copy active replication 
distributed locking response time higher 
caused contention network distributed locking sends broadcast operation 
leads situation network bottleneck simulator usage rate network resource quickly reached 
load increases see response time techniques increases relative performance different techniques changes 
response time distributed locking increases shows asymptotic limit throughput transactions second 
caused high network contention 
similar phenomenon observable active replication maximum throughput transactions second 
reason time network highest load network usage rate high load important serialisation phase needed enforce determinism 
transactions need serialised locks granted active replication load balancing transactions executing replicas 
factors form bottleneck active replication high load causes lock contention lock contention slows serialisation phase 
serialisation phase bottleneck 
primary copy replication load problem done server performance tends degrade load increases 
performance ser technique certification technique remains close lazy replication 
interesting note response time ser replication ms higher response time observed conflict rate calculated marking transactions wait lock held transaction execution 

experiments certification technique 
explained differences techniques 
ser techniques weak voting transaction commit replicas wait delegate decide outcome transaction 
certification technique need replicas decide outcome transaction total order delivery 
difference certification ser techniques explained cost broadcast costs ms ms difference explained cost coordination servers need wait delegate finish processing order able terminate locally 
words time needed broadcast data negligible time lost waiting 
response time ms active certification distributed locking primary copy lazy ser load transactions sec performance replication techniques medium load fast network medium load fast network shows results experiment fast network mb 
techniques behave similar fashion technique different performance curve distributed locking technique 
sense network bottleneck technique previous experiment faster network implies different performance 
performance distributed locking better fast network response time higher response time group communication techniques ms 
difference partly explained network usage takes ms send message average operations transaction messages operations request lock confirm gives network overhead ms means major part performance penalty related way transactions processed 
processing overhead probably partially responsible overhead distributed locking technique slow network previous chapter 
performance comparison experiment majority overhead slow network due network contention 
interesting thing note comparing figures difference certification technique ser technique stays roughly 
shows difference techniques related network way techniques structured 
response time cost sending message cpu network value ms influence network performance distributed locking technique network cost distributed locking understand relationship performance network response time distributed locking technique measured response time technique changing performance network 
result experiment illustrated 
experiment changed cost sending message network plotted response time distributed locking technique interval transactions ms resulting load transactions second 
axis represents cost sending message cost changed cpu network 
ms corresponds settings fast network ms represents slow network 
axis represents response time milliseconds 
graph shows response time distributed locking technique increases cost networking operations 
see curve linear network bottleneck response time increases seen cost network ms point network facility average processes wait ms access network resource 
high load fast slow network shows result experiment clients slow network 
curves ser 
experiments tion lazy techniques plotted unable sustain transactions second 
shows results experiment clients fast network 
figures similar fact technique slow network case setting sustain high loads 
main difference experiments behaviour distributed locking technique concentrate discussion experiment fast network include distributed locking 
distributed locking considerations influence network performance performance weak 
fast slow network see performance degrades steadily load transactions second 
glance behaviour certification technique better distributed locking ser response time stays significantly lower system starts overloaded 
fact fast network setting load reaches transactions second response time decreases 
load transactions second response time certification technique confidence interval lazy replication 
difference lies abort rate different techniques 
moderate load situations abort rate different techniques marginal high load situation abort rate significant 
shows abort rate certification ser distributed locking techniques high load situations fast network parameters 
see response time certification replication low abort rate significantly higher 
overload system yields high conflict rate certification phase lot update transactions abort 
fact aborts update transactions 
see distributed locking sharp increase aborts load reaches transactions second point deadlocks start significant 
interesting note response time ser replication increases abort rate stays stable 
discussion performance measurements show replication techniques split categories network bound replication techniques distributed locking performance bound techniques active primary copy efficient group communication techniques ser certification lazy technique 
distributed locking affected network performance techniques performance similar slow fast network 
due fact rely single broadcast operation simple broadcast primary copy lazy total order broadcast group techniques 
performance group communication techniques depends architecture techniques designed database replication cer chapter 
performance comparison response time ms certification lazy ser load transactions sec performance replication techniques high load slow network response time ms certification lazy ser distributed locking load transactions sec performance replication techniques high load fast network abort rate certification distributed locking ser load transaction second abort rate high load situation fast network 
experiments ser outperform significantly basic technique active replication 
culprits active replication bad performance serialisation phase lack load balancing 
fast network configuration distributed locking outperformed efficient group communication techniques 
reason execution transactions distributed locking replication tightly coupled replicas 
synchronisation phases cause serious slow 
synchronisation cause performance difference ser certification replication 
ser technique synchronisation phase weak voting phase costs technique ms compared certification technique 
behaviour certification replication high load situations alleviated flow control techniques 
flow control help avoid situations conflict rate causes aborts technique unusable 
scalability description experiment important aspect replication techniques worth analysing scalability 
replication technique usable number replicas high 
experiment measured system reacted changing number servers 
interval transactions fixed ms number clients resulting load transactions second 
changed number servers observed performance system 
different configurations listed table 
primary copy requires broadcast technique scalable 
concentrated scalability update techniques 
experiment fast network different types transaction loads 
called mixed load contains queries 
second called queries contains queries 
servers clients server table scalability configurations chapter 
performance comparison results response time ms distributed locking ser certification number servers scalability update techniques query load mixed load shows results experiment query load 
compared response time replication techniques certification replication ser distributed locking lazy 
set bar represents performance number servers starting servers leftmost bar 
technique represented different bar height bar axis represents response time milliseconds 
general performance similar experiment section lazy replication outperforms techniques 
group communication techniques outperform distributed locking 
general see response time decreases number replica increases 
shows number servers grows part load queries distributed replicas giving better performance 
interesting part appears extreme case number replicas maximal servers performance distributed locking decreases significantly 
due network usage stays distributed deadlocks abort rate cost coordination inherent technique 
aborts significant impact distributed locking case certification technique 
shows abort rates certification technique ser technique 
axis represents number servers left axis represents abort rate percentage 
see abort rate ser technique stable abort rate certification technique increases number servers 
number server maximal abort rate reaches 
hypothesis explain behaviour related difference local global conflicts handled 
transactions conflict conflict lazy 
experiments abort rate certification technique abort rate ser technique abort rate servers number number servers correlation conflict function observed aborts handled ways 
transactions originate server delegate server conflict handled local locking mechanism 
local locking system execution conflicting transactions deadlock occurs abort 
transactions originate different servers conflict detected certification time result abort transaction 
number replicas increases chances abort 
transactions ta tb conflict chances conflict results abort proportional probability different servers number servers 
observed abort rate explained phenomenon 
observed conflict rate roughly proportional black line represents linear function right axis represents number servers clearly correlated abort rate 
secondly conflict rate low explain abort rate 
seen comparing abort rate certification ser techniques 
ser technique similar certification technique execute transactions order delivery total order broadcast check conflicts 
certification technique uses deterministic check mechanism ser relies delegate server detected actual conflicts 
certification needs guess transaction conflict unnecessary aborts 
number aborts certification technique slightly higher abort rate ser technique abort rates roughly 
shows abort rate ser technique clearly rates stays low 
real conflicts explain abort rate 
actual issue related way certification algorithm implemented 
transaction delivered placed conflict list 
list check potential conflicts certification test 
transaction number servers chapter 
performance comparison committed replica stable replica 
information transaction stable piggy backed subsequent total order broadcast messages 
transaction known stable replicas removed conflict list 
transaction removed conflict list committed replicas replicas sent total order broadcast message 
server server transaction processed transaction processed message contains transaction stable transaction stable transaction processed message contains transaction processed conflict list scenario transaction stable transaction processed transaction processed transaction stable means transactions executed sequentially conflict conflicts appear transactions stay long conflict list 
illustrates problem case system servers 
system consists replicas 
initially transaction conflict list 
transaction removed conflict list replicas total order broadcast messages delivered 
message contains transaction call respectively 
assume delivered delivered replicas know stable sender status unknown stays conflict list 
replicas start process content transaction 
conflict list cause abort conflict terminated replicas 
delivered system knows stable sender 
stable replicas removed conflict list 
cause abort 
replicas transaction removed conflict list messages 
mn delivered 
means potentially conflict transactions 
tn 
number potential conflict proportional number servers regardless load system 
verify hypothesis measured abort rate certification technique varying loads transactions second large number servers 
shows results experiment 
axis represents load system axis abort rate 
see load varies factor abort rate stays slightly 

experiments abort rate load transaction second abort rate servers changing loads queries load shows experiment query load 
graph similar better response time expected queries workload 
see increase significant queries performance distributed locking starts degrade number servers high 
discussion general group communication replication techniques scale assuming moderate load large proportion queries 
response time increase number servers diminishes expect 
showed certification technique problem leads aborts number servers high 
ser technique problems 
abort problem certification technique addressed ways version database 
case certification test response time ms distributed locking ser certification number servers scalability update techniques query load lazy chapter 
performance comparison rely version number items conflict list 
approach solves problem drawback imposes requirements access version numbers database system 
additional messages 
transaction stabilised server si server sends total order broadcast message contains transaction signals stable sending replica 
message sent committed impact directly response time processing 
main problem approach generates message explosion 
servers processing transaction require total order broadcast messages algorithm distributing information stable 
efficient total order broadcast algorithm impact messages important 
interesting aspect group communication replication issues scalability resolved outside replication scheme total order broadcast primitive scales rfv replication technique scale 
query proportion description experiment proportion queries load system important effect performance replicated database 
read write policy replication technique queries need executed replica 
cases executed requiring communication 
changing query rate compare load balancing capacities replication strategy 
measure different replication techniques handle queries fixed load system changed proportion queries submitted load measured changes response time 
query proportion update transactions query proportion transactions updates 
query proportion increased increments 
measured impact query load settings low load setting system configured clients servers connected fast network 
interval transactions fixed ms yielded load transactions second 
query rate setting corresponds left edge 
moderate load setting system consists clients servers connected fast network 
time interval transactions ms load transactions second 
query rate setting corresponds right edge 
message total order broadcast updates state certification test module behave deterministic way servers 

experiments results response time ms active replication certification distributed locking lazy ser primary query proportion performance changing query rate low load transactions second low load shows results experiment low load transactions second 
query rate load consists read operations transactions distributed servers 
situation certification ser replication performance lazy replication load perfectly balanced servers communication occurs 
distributed locking suffers slight overhead protocol complexity roughly performance 
remaining techniques active replication primary copy worse performances load balancing 
techniques done server 
primary copy case done primary 
active replication situation slightly different done replicas technically replicas primary 
cases load balancing 
techniques handle load way expect performance 
fact primary copy outperform active replication cost total order broadcast 
results show active replication outperforms primary copy replication approximately 
reason lies way active replication works 
active replication delegate server merely acts proxy servers transaction delivered sent servers including total order broadcast 
server processes transactions sends results back delegate delegate forwards response client 
practice means chapter 
performance comparison perceived response time client response time fastest server 
observed response time minimum response time replicas min 
rn 
difference response times servers 
response time transaction replica depends multiple factors actual load system number items cache time needed seek 
factors extent random number replicas increases observed response time improve get fast response 
benefit fact replicas technique load balancing 
improvement similar read operation improvement raid level systems ct 
proportion queries diminishes performance techniques degrades 
performance degradation noticeable distributed locking number writes increases overhead technique obvious 
interesting note performance certification technique distinguished performance lazy replication query proportion larger 
shows high query rates low load certification replication close optimum 
response time ms certification distributed locking lazy ser primary query proportion performance changing query rate moderate load transactions second caching algorithms usually random deterministic 
classic deterministic caching algorithms benefit active replication replicas caching behaviour 
simulation caching simulated statistical process benefited active replication 
special algorithms tailored active replication give better benefits instance having replica keep cache subset data 

experiments moderate load shows results experiment higher load transactions second 
thing see techniques bad performance active replication curve outside graph primary copy replication upper right corner 
techniques non linear response curves query proportion low performance drops suddenly 
compare graph interesting see relative performance active replication primary copy replication inverted techniques perform poorly primary copy better performance 
high load situations advantages selecting fastest response offset fact processing needed 
additionally serialisation phase active replication bottleneck high load situations see section 
changing load query rate understand linear curves transform plotted dimensional graphs techniques certification ser distributed locking primary copy plot remaining techniques performance moderate load setting bad 
technique axis represents query proportion axis depth represents load system transactions second axis height represents resulting response time 
technique represented separate surface surface marked limit ms ms see surfaces continuous shows techniques stable parameter space considered 
noticeable aspect figures distributed locking certification ser replication general shape performance load low query proportion high 
response time reaches peak high load low query proportion situations 
primary copy hand different general shape 
technique sensitive extent query proportion load far greater influence performance 
load increases response time forms wall load composed queries 
reason primary copy load balancing 
consider parameter values response time reaches ms ms respectively see performance difference distributed locking technique hand group chapter 
performance comparison response time ms query rate ms ms performance certification replication changing query proportion changing loads response time ms query rate ms ms performance ser replication changing query proportion changing loads load transactions second load transactions second 
experiments response time ms query rate performance distributed locking replication changing query proportion changing loads response time ms query rate performance primary copy replication changing query proportion changing loads ms ms load transactions second load transactions second chapter 
performance comparison communication replication techniques ser certification figures hand 
group communication replication techniques outperform distributed locking systematically 
general difference roughly equivalent difference query proportion distributed locking behaves query proportion group communication replication query proportion 
consistent performance difference observed load performance section 
discussion experiment shows load balancing features different replication techniques important impact performance especially load contains large proportion queries 
see group communication replication techniques offers load balancing 
techniques built optimistic hypotheses execute check network conflicts best proportion queries high 
conditions moderate load high query proportion techniques performance close performance lazy replication 
wide area network description previous experiments local area network lan settings servers connected moderate mb fast network mb 
classical database replication strategies simply cope long delays associated wide area network wan 
seen section group communication replication sensitive performance network latency network affect response time time locks held write locks kept total order broadcast delivered network interaction influence limited 
group communication wan database replication scheme proposed primary copy scheme fp 
reason interesting evaluate performance ser certification replication wan context 
changed time message transmission ms point point multicast messages 
represents time message quite large ping round trip epfl usa ms depending location 
contrary lan situation network contention issue wan context modelled 
resource sending message simply wait simulator 
system set clients connected servers 
changing interval transactions load transactions second submitted system 
load composed update transactions 
query execution involve network operation performance query processing affected long 
experiments network delay modelled query response time lan setting 
parameters described table 
results response time ms ser certification load transaction second performance wan setting shows result experiment 
response time quite high ms stable 
abort rate stable 
interesting note certification replication outperformed ser replication lan settings difference wan setting confidence interval 
discussion large response time group communication replication techniques stays reasonable wan setting 
performance techniques affected response time total order broadcast algorithm 
case total order broadcast algorithm optimised latency choosing different algorithm improve latency significantly 
group safe replication description goal experiment measure performance improvement gained transforming group communication replication strategy enforces group safety opposed group safety 
improvement discussed section 
chapter 
performance comparison compared replication strategies certification lazy group safe version certification 
experimental settings experiment section clients connected servers generating moderate load transactions second fast network mb 
results response time ms certification group safe certification group safe lazy load transaction second performance group safe certification shows results experiment 
axis represents load system transactions second axis measured response time milliseconds 
technique represented performance curve 
curve lazy certification clarity removed part certification curve transactions second response time drops technique aborts update transactions 
performance curves shows group safe replication performance 
see group safe certification technique outperforms lazy replication load transactions second 
abort rate technique constant slightly 
performance group safe technique due asynchronous writes 
means writes disk basically done separate thread outside scope transaction 
high load situations group safe replication loses advantage lazy replication 

experiments discussion group safe replication offers expected performance moderate load situations outperforms lazy replication 
shows transferring responsibility durability stable storage group see section sense lan setting writing value disk takes ms performing total order broadcast considered complex costly protocol takes approximately ms optimistic active replication description previous experiments showed active replication compared group communication techniques certification ser replication 
additionally active replication requires static transactions restricts usage 
main advantage active replication abort transactions transactions broadcast need pass certification phase certification replication wait commit message delegate site ser replication 
static transactions executed risk deadlock aborted 
characteristics active replication interesting real time applications aborted transactions mean unpredictable delays 
section evaluate optimisation active replication call optimistic active replication 
replication technique proposed name fine granularity locking 
technique relies early optimistic delivery messages start processing earlier 
optimistic early delivery possible lan setting spontaneous order property see section lan messages right order time 
starting processing earlier execution transaction execution total order broadcast algorithm delivers order overlap 
message ordering generated spontaneous ordering match definitive delivery order conflict occurs aborted restarted 
client need notified abort subsequent restart 
active replication optimistic active replication collect responses servers transmit response client 
yields improved response time response time observed client response time fastest server 
gives increased performance active replication see section optimistic active replication transaction restarted server si client get response server sj restart 
call technique response collection delegate collects response servers including forwards client 
experiments section done response collection 
experiments conducted response collections servers send back results delegate server 
setting client gets re chapter 
performance comparison sponse contains results delegate server 
case results similar higher response times ms 
optimistic technique sense need things spontaneous ordering property holds time second processing time transactions order magnitude time needed execute total order broadcast algorithm 
improvement response time portion time needed total order broadcast 
processing transaction longer processing total order broadcast improvement negligible 
processing time transaction shorter transmission time transactions need wait final delivery order commit 
write locks kept commit increase lock contention 
communication processing transaction processing opt delivery processing inactive period processing delivery overlap communication processing optimistic active replication illustrates problem processing time transaction shorter processing time total order broadcast algorithm 
opt delivery represents optimistic delivery total order broadcast effective delivery total order 
inactive period time transaction processing represents period time locks held processing occurs 
experiments optimistic active replication done parameters described table slow network clients attached servers 
represent faster processing transaction length shortened uniform distribution operations cache hit ratio raised 
difference techniques slim experiments run relative error rate response time 
time start consecutive transactions interval ms resulted load transactions second 
results performance 
shows compared performance active replication optimistic version active replication 
axis represents load system expressed transactions second axis represents response time expressed milliseconds 
measured performance active replication configurations optimistic active replication order messages transactions restarts restart 
experiments response time ms optimistic active restart optimistic active restart active load transactions second performance active replication optimistic active replication message reordering restart 
message reordering measured factors proportion messages reordered reordering level 
reordering level expresses positions serial order message displaced 
instance correct sequence messages 
reordering level delivered order sequence 
observed section message reordering level lan worst 
simulation reordering level uniform distribution 
reordering simulated tossing dice message message reordered pushed back positions serial order 
case restart setting messages shuffled positions 
delegate server collects responses servers observed response time shortest response time servers 
means restart occurs probably effect response time response come server restart occur 
influence restart measured response time restart occurs servers 
consider order messages transaction restarts independent random events server chances restart occurring servers quite low 
order measure response time restarted transaction set simulator deliver messages order servers time 
see conditions restarts optimistic algorithm outperforms classical algorithm ms optimistic algorithm transaction processing starts initial broadcast normal active replication processing starts total order broadcast protocol 
difference amount broadcasts round chapter 
performance comparison point point messages 
parameters simulator considering little network contention point point message broadcast take ms ms sender ms wire ms receiver 
difference optimistic active replication amount ms observed difference quite close 
see performance optimistic algorithm messages order 
show paragraph due restarted transaction increased lock contention degraded synchronisation 
interesting note difference response time settings optimistic technique restarts important load low 
probably due fact transactions delivered lower rate conflicts detected cost restart terms processing higher 
fact response time restarted transactions stable ms regardless load 
restart rates restart times 
see optimistic technique spontaneous ordering property holds 
understand influence order messages fixed load transactions second changed proportion order messages 
experiment measured data redo rate 
proportion transactions needed restarted 
response time 
mean response time system 
redo response time 
mean response time transactions restarted order messages 
response time ms response time time redo rate message reordering rate response time restarted transactions optimistic active replication redo rate 
experiments shows result experiment curves response time response time restarted transactions transaction restart rate 
left axis represents response time expressed milliseconds response time curves 
right axis represents restart rate transactions proportion transactions needed restarted 
redo response time point restarts 
response time ms optimistic active replication response time active replication response time redo rate message reordering rate order message influence performance shows close response time optimistic technique compared response time active replication technique 
restart proportion plotted 
axis represents proportion order messages 
left axis represents response time zoomed range ms right axis represents proportions restarted transactions 
response time corresponds response time restarts curve response time corresponds response time restarts curve 
expected see number restarted transactions increases number order messages rate stays low messages order 
see response time increases number order messages 
interesting thing increase response time explained simply increased number restarted transactions contribution negligible transactions doubled response time increase mean response time 
increase mean response time due higher lock contention synchronisation costs 
point optimistic technique performed classical active replication technique 
point transaction delivered order restarted locks held aborted delayed transactions 
redo rate chapter 
performance comparison reached messages order circle 
restarted transactions roughly response time twice large response time non restarted transactions 
traditionally assumed restarted transactions response time higher transactions transaction restarted average middle execution 
case 
response time restarted transaction transactions restarted immediately aborted definitive total order known 
avoids situations transaction restart multiple times ensures response time bounded 
contention latch locking items transaction atomic step lowered 
discussion optimistic active replication technique sense spontaneous ordering property holds time 
messages rare case time lan optimisation improves response time 
depending condition respective performance transaction processing communication protocol gain change quite lot 
restarts rare occur messages contain conflicting transactions delivered wrong relative order 
conflict rate reasonable event rare 
setting restart rates stayed 
order messages occur independently servers probability client observes response time restarted transaction probability restart server number servers 
low large number small 
event message delivered order servers number restarts bounded 
interesting means replication technique stable response time time soft real time applications 
added delay restarted transactions hidden collect response servers 
increases network usage response time lowered 
response collection sense time send message servers standard deviation response time 
spontaneous ordering property holds lan setting optimistic active replication wan setting heuristics build reasonable tentative order long tentative order generally final delivery order impact significant terms restarted transactions 
technique wan setting sense case transaction potentially restart level order delivery 
message positions order transaction restart times 

optimistic active replication tries optimise time needed process total order broadcast protocol 
lan setting response time total order broadcast low optimising probably worth trouble 
wan response time total order broadcast large optimising sense 
response collection sense wan setting increased latency means response remote servers arrive delegate local response event transaction restart 
impact bandwidth important 
summarise optimistic active replication offers increased performance interesting option processing time roughly time needed execute total order broadcast protocol spontaneous ordering property holds 
cost restarts hidden collecting response servers 
chapter measured performance different replication techniques 
focused different group communication techniques compared performance classical replication schemes primary copy distributed locking lazy update replication 
measured performance gain optimisations group safe certification replication optimistic active replication 
ser evaluated kem compared techniques distributed locking simplified network model 
performance certification replication evaluated ped compared techniques 
evaluation relied simplified network model database versioning 
evaluation performance certification replication prototype corba middleware van 
performance evaluations show group communication replication significantly outperforms traditional database replication protocols 
performance difference large network slow subject contention 
due fact distributed locking uses lot messaging 
group communication replication uses networking resources relying abstractions total order broadcast 
kind replication efficient slow network 
network fast contention rare group communication replication outperforms distributed locking albeit smaller amount faster network reduces cost techniques negate cost synchronising replicas 
results chapter confirm statements previous simulation ped haa kem group communication database replication offers performance 
results consistent described kem shows performance different variants ser outperforming distributed locking 
interesting note chapter 
performance comparison variants proposed kem offer increased performance relaxing serialisability relying cursor stability 
context worth noting certification replication outperforms ser replication cases enforcing serialisability 
results consistent observations performance certification replication ped 
lack difference experiment slow fast network resource usage simulator confirms general observation lan situation network contention real problem 
resources cpu disks candidates bottlenecks lan 
mean communication issue database replication multiple copies induce problems synchronisations costs high abort rates 
issues related performance network design replication scheme 
performance difference certification replication ser replication due cost executing total order broadcast cost adding synchronisation barrier replicas 
chapter research assessment dead eternal lie strange ons death may die 
abdul research led contributions understanding database replication group communication 
contribution structural qualitative quantitative 
structural contribution classification replication techniques 
qualitative contribution exploration fault tolerance criterion relationship database replication group communication 
quantitative contribution performance evaluation 
classification systematic classification database replication techniques proposed 
classification shows different way databases replicated analyses requirements category techniques 
requirements expressed database sub system amount determinism required group communication sub system properties communication primitives 
classification highlights logical structure replication techniques shows relationship techniques described literature 
shows categories techniques explored thoroughly 
chapter 
fault tolerance criterion relationship model group communication resulting fault tolerance criterion explored 
show safe replication group communication possible current group communication implementations 
shows limitation way group communication systems designed interfaces specified considering applications database systems recover state 
group safety 
alternative safety criterion group safety proposed 
criterion suited group communication replication techniques classical safety safety criterion 
group safe database replication techniques represents middle ground safe safe database replication 
safe replication technique lose transactions replica crashes safe technique replicas may crash transaction lost 
replication withstand failures losing transaction 
group safe replication 
group safety implies shift way durability aspect acid properties considered 
group safe technique durability ensured stable storage traditional databases 
group responsible ensuring transaction effect durable 
shift possible replicated database basically fault tolerance mechanisms stable storage replication 
transferring responsibility component disks group servers sense performance reasons lan network access faster disk access 
performance evaluation performance evaluation offers insight performance scalability group communication replication techniques 
results confirm group communication replication offer performance scalability 
group communication database replication 
experiment show group communication replication offers alternative database replication 
different important presence slow network remains apparent network fast 
active replication 
experiment active replication technique showed low load setting group servers offer improved performance giving client impression having best latency 
active replication improved optimistic delivery total order broadcast primitive 

open questions research direction certification ser techniques evaluation group communication techniques designed database replication ser certification show technique interesting performance point view 
comparison ser certification technique show communication costs low lan synchronisation impact performance 
comparison shows performance ser technique improved relaxing serialisability 
experiments showed kind certification algorithm large impact scalability certification technique 
group safe replication 
group safe version certification technique showed impressive results outperforming lazy replication 
confirms group safe replication interesting alternative lazy replication 
replication offers performance strong fault tolerance 
open questions research direction contributions previous section research raised interesting questions issues deserve research 
intra layer communications problem safety led analyse communications application group communication layer terms message exchange 
approach specify clear way group communication primitives 
help unify variants group communication primitives different flow controls calling semantics dss 
tool help design new variants group communication primitives 
clear specification group communication primitives give clearer view interface application group communication layer permit better design components 
ack messages highlight group communication application layer stable storage data responsibility faulttolerance gets transferred component 
notion extended context transport layer access stable storage instance message queues sending messages ms 
raises question durability ensure durability tier architecture certain elements access stable storage 
hybrid replication techniques possible replication techniques described classification implemented total order broadcast primitive chapter 
avoid deadlocks rely voting phase ensure atomicity 
hybrid techniques interesting mix mechanisms voting non voting replication 
rely total order broadcast minimise deadlocks network communication require strict determinism group communication replication techniques 
replicas act non deterministic way unilaterally abort transactions atomic commitment ensures replicas state 
best effort total order broadcast hybrid techniques optimistic active replication benefit fast best effort total order broadcast implementation 
spontaneous ordering property build implementation certainly possible area particular interest best effort total order broadcast man settings group communication replication lot sense spontaneous ordering property hold 
group safe replication group safe version certification technique showed performance performance certainly improved optimisations 
possible approach middle tier route certain transactions certain replicas optimising caching behaviour 
group safe replication writes executed outside scope transaction direct impact response time 
means read operations responsible large part response time optimising performance read operations improved caching lot sense 
optimistic mechanisms optimistic active replication scheme chapter represents possible early delivery messages 
drawback technique complexity transaction handling policy needs changed take advantage early delivery 
interesting early delivered messages control caching message delivered tentative order transaction contains parsed relevant items loaded cache 
design interesting couples optimistic designs early delivery caching 
wrong spontaneous ordering requires special care messages tentatively delivered wrong order items preloaded cache 
opportunity optimism techniques replicate highlevel transactions pf 
techniques high level transactions transformed low level transactions replica 
transformation started optimistic delivery result cached 
total order delivery 
open questions research direction cached version 
case order early delivery content cache discarded 
scheme interesting wan replication schemes fp time difference optimistic delivery total order delivery quite important 
chapter 
bibliography agrawal alonso el abbadi 
exploiting atomic broadcast replicated databases 
proceedings europar europar passau germany 
acl agrawal carey livny 
control performance modeling alternatives implications 
acm transactions database systems december 
act aguilera chen toueg 
quiescent reliable communication quiescent consensus partitionable networks 
technical report tr cornell university computer science department june 
act aguilera chen toueg 
failure detection consensus crash recovery model 
distributed computing april 
act aguilera chen toueg 
failure detection consensus crash recovery model 
proceedings th international symposium distributed computing disc volume lecture notes computer science pages greece september 
springer verlag 
alo alonso 
partial database replication group communication primitives extended 
proceedings nd european research seminar advances distributed systems er pages switzerland january 
ans american national information systems street nw washington dc usa 
ansi database language sql november 
bad birman el abbadi dietrich joseph 
overview isis project 
technical report bibliography tr cornell university computer science department october 
bbc bernstein brodie ceri dewitt franklin garcia molina gray held hellerstein jagadish lesk maier naughton pirahesh stonebraker ullman 
asilomar report database research 
technical report msr tr microsoft research microsoft way redmond wa september 
basu charron bost toueg 
solving problems presence process crashes lossy links 
technical report tr cornell university computer science departement ithaca ny usa september 
bch chung huang rangarajan yajnik 
hot replication java rmi server objects 
proceedings th conference object oriented technologies systems coots pages santa fe new mexico usa 
usenix 
bch birman constable hayden kreitz rodeh van renesse vogels 
horus ensemble projects accomplishments limitations 
proceedings darpa information survivability conference exposition discex hilton head south carolina usa january 
fr lund guerraoui 
open consensus 
computation practice experience 
goyal hsiao 
efficient scheme providing high availability 
proceedings sigmod international conference management data pages may 
breitbart garcia molina silberschatz 
overview multidatabase transaction management 
vldb journal june 
bhg bernstein hadzilacos goodman 
concurrency control recovery database systems 
addison wesley 
bj birman joseph 
exploiting virtual synchrony distributed systems 
proceedings th acm symposium os principles pages austin tx usa november 
acm sigops acm 
bibliography bkt bal kaashoek tanenbaum 
orca language parallel programming distributed systems 
ieee transactions software engineering 
marzullo schneider toueg 
distributed systems chapter primary backup approach pages 
acm press 
addison wesley second edition july 
bo ben 
advantage free choice completely asynchronous agreement protocols 
proceedings second annual symposium principles distributed computing pages 
acm 

reliable total order broadcast crash recovery model 
phd thesis cole polytechnique rale lausanne switzerland november 
bsr bernstein shipman 
concurrency control system distributed databases sdd 
acm transactions database systems march 
bss birman schiper stephenson 
lightweight causal atomic group multicast 
acm transactions computer systems august 
bt 
babao glu toueg 
understanding non blocking atomic 
technical report ublcs laboratory computer science university bologna piazza di porta donato bologna italy january 
bt bergman 
db data base version features facilities 
white ibm april 
cap cap 
distributed systems data replication survey 
technical report ifi department computer science university rich ch rich switzerland november 
cristian strong 
atomic broadcast simple message diffusion byzantine agreement 
proceedings th conference fault tolerant computing pages june 
charron bost xavier andr schiper 
time vs space fault tolerant distributed systems 
proceedings th international workshop object oriented real time dependable systems words rome italy january 
ieee ieee computer society 
bibliography cf cristian fetzer 
timed asynchronous distributed system model 
ieee transactions parallel distributed systems june 
cha chang 
simplifying distributed database systems design broadcast network 
beatrice editor sig mod proceedings annual meeting volume pages boston massachusetts usa june 
acm special interest group management data new york ny usa 
ceri keller samarati 
classification update methods replicated databases 
technical report cs tr stanford university computer science departement may 
cht chandra hadzilacos toueg 
weakest failure detector solving consensus 
journal acm july 
cp chen pu 
structural classification integrated replica control mechanisms 
technical report cucs columbia university departement computer science new york ny 
cs cheriton skeen 
understanding limitations causally totally ordered communication 
barbara liskov editor proceedings th symposium operating systems principles volume pages asheville north carolina december 
acm press new york ny usa 

recovery mechanisms database systems chapter recovery performance atomic commit processing distributed database systems 
prentice hall edition 
ct chen towsley 
performance evaluation raid architectures 
technical report um cs departement computer science university amherst ma usa september 
ct chandra toueg 
unreliable failure detectors reliable distributed systems 
journal acm march 
cz cheriton zwaenepoel 
distributed process groups kernel 
acm transactions computer systems may 
bibliography 
agreement related problems semi passive replication totally ordered broadcast 
phd thesis cole polytechnique rale de lausanne switzerland august 
davidson garcia molina skeen 
consistency partitioned networks 
acm computing surveys september 
dm dolev malki 
transis approach high availability cluster communication 
communications acm april 
dss schiper 
semi passive replication 
proceedings th symposium reliable distributed systems srds pages west lafayette usa october 
ieee 
dahlin wang anderson patterson 
cooperative caching remote client memory improve file system performance 
proceedings symposium operating systems design implementation pages monterey california november 
usenix association 
appeared university california technical report csd 
eswaran gray lorie traiger 
notions consistency predicate locks database system 
communications acm november 
published ibm research report rj san jose ca december 
fc fu cheung 
transaction replication scheme replicated database node autonomy 
proceedings international conference large databases santiago chile 
fel felber 
corba object group service service approach object groups corba 
phd thesis cole polytechnique rale de lausanne switzerland 
flp fischer lynch paterson 
impossibility consensus faulty process 
journal acm april 
fp fr lund pedone 
continental 
proceeding th symposium reliable distributed systems pages new orleans la usa october 
ieee computer society los alamitos california usa 
bibliography rtner 
gentle failure detectors related problems 
technical report tud bs darmstadt university technology department computer science april 
gray neil shasha 
dangers replication solution 
proceedings international conference management data pages montreal canada june 
acm sigmod 
gif gifford 
weighted voting replicated data 
proceedings seventh symposium operating system principles sosp pages asilomar conference grounds pacific grove ca december 
acm new york 
gmp garcia molina 
epoch algorithms disaster recovery 
proceedings th vldb conference pages brisbane australia 
gokhale natarajan schmidt yajnik 
doors high performance fault tolerant corba 
proceedings nd international symposium distributed objects applications doa antwerp belgium september 
object management group 
gol 
discussion database replication technology 
info db may 
gol 
things update replication customer know 
proceedings acm sigmod international conference management data pages san jose ca usa may 
gr gray reuter 
transaction processing concepts techniques 
data management systems 
morgan kaufmann publishers san mateo ca usa 
gs guerraoui schiper 
genuine atomic multicast 
proceedings th international workshop distributed algorithms saarbr cken germany september 
gue guerraoui 
revisiting relationship non blocking atomic commitment consensus 
proceedings th international workshop distributed algorithms lncs pages le mont st michel france september 
springer verlag 
bibliography haa agrawal el abbadi 
database replication lazy consistent 
proceedings th symposium reliable distributed systems srds pages 
ieee computer society press october 
haa agrawal el abbadi 
performance database replication group multicast 
proceedings international symposium fault tolerant computing ftcs pages 
ieee computer society 
haa agrawal el abbadi 
multicast communication reduce deadlocks replicated databases 
proceedings th symposium reliable distributed systems srds pages germany october 
ieee computer society los alamitos california 
hadzilacos 
theory reliability database systems 
journal acm january 
hol 
replicated database recovery multicast communications 
proceedings symposium network computing applications nca pages cambridge ma usa october 
ieee 
hs schlichting 
cactus approach building configurable middleware services 
proceedings workshop dependable system middleware group communication germany october 
ht hadzilacos toueg 
fault tolerant broadcasts related problems 
mullender editor distributed systems chapter 
addison wesley second edition 
hw herlihy wing 
linearizability correctness condition concurrent objects 
acm transactions programming languages systems july 
inf informix bohannon drive menlo park california usa 
informix replication high performance solution distributing sharing information june 
jai jain 
art computer system performance analysis techniques experimental design measurement simulation modeling 
john wiley sons new york usa 
jaj jajodia 
data replication gaining popularity 
ieee pages april 
interview yuri breitbart hank korth 
bibliography jim nez paris mart nez alonso ar 
low latency non blocking commit server 
welch editor proceeedings th conference distributed computing disc volume lecture notes computer science pages lisbon portugal october 
springer verlag berlin heidelberg 
ka kemme alonso 
suite database replication protocols group communication primitives 
proceedings th international conference distributed computing systems icdcs amsterdam netherlands may 
ka kemme alonso 
transactions messages events merging group communication database system 
rd research seminar advances distributed systems madeira island portugal april 
broadcast esprit wg 
ka kemme alonso 
don lazy consistent postgres new way implement database replication 
proceedings th international conference large databases vldb cairo egypt september 
ka kemme alonso 
new approach developing implementing eager database replication protocols 
acm transactions database systems 
kb krishnakumar bernstein 
bounded ignorance technique increasing concurrency replicated system 
acm transactions database systems december 
kemme bartoli 
babao glu 
online reconfiguration replicated databases group communication 
proceedings conference dependable systems networks dsn teborg sweden june 
kei keidar 
highly available paradigm consistent object replication 
master thesis hebrew university jerusalem jerusalem israel april 
technical report cs 
kem kemme 
database replication clusters workstations 
phd thesis swiss federal institute technology rich switzerland august 

kim kim 
issues insufficiently resolved century faulttolerant distributed computing field 
proceedings th bibliography symposium reliable distributed systems pages germany october 
ieee computer society 
invited 
klw walter 
specification method transaction models data replication 
technical report humboldt universit zu berlin germany march 
kemme pedone alonso schiper 
processing transactions optimistic atomic broadcast protocols 
proceedings international conference distributed computing systems austin texas june 
ks kumar segev 
cost availability tradeoffs replicated concurrency control 
acm transactions database systems march 
kt kaashoek tanenbaum 
group communication amoeba distributed operating system 
proceedings th international conference distributed computing systems icdcs pages washington usa may 
ieee computer society press 
kt kaashoek tanenbaum 
efficient reliable group communication distributed systems 
technical report cambridge vrije universiteit amsterdam 
lam lamport 
part time parliament 
technical report system research center digital palo alto usa september 
revised version published lam 
lam lamport 
part time parliament 
acm transactions computer systems may 
ls little shrivastava 
understanding role atomic transactions group communications implementing persistent objects 
eighth international workshop persistent object systems design implementation august 
lindsay selinger gray lorie price wade 
notes distributed databases 
technical report rj ibm san jose research laboratory 
lyon 
design considerations replicated database systems disaster protection 
proceedings ieee compcon 
bibliography lyon 
tandem remote data facility 
proceedings ieee compcon 
man 
microsoft shifts focus security 
usa today january 
mes software west lane austin texas tx usa 
csim simulation engine version 
felber schiper wilhelm 
ph nix toolkit building fault tolerant distributed applications large scale 
workshop parallel distributed platforms industrial products san antonio texas usa october 
ieee 
workshop held th symposium parallel distributed processing spdp 
moser melliar smith agarwal papadopoulos 
totem fault tolerant multicast group communication system 
communications acm april 
mpr miranda pinto rodrigues 
flexible protocol kernel supporting multiple coordinated channels 
proceedings st international conference distributed computing systems icdcs pages phoenix arizona usa april 
ieee computer society 
ms maffeis schmidt 
constructing reliable distributed communication systems corba 
ieee communications magazine february 
mun munk 
db client server performance measurement series 
ibm ibm santa teresa laboratory san jose california usa august 
neu neumann 
risk digest forum risks public computers related systems 
acm committee computers public policy january 
narasimhan moser melliar smith 
enforcing determinism consistent replication multithreaded corba applications 
proceedings th ieee symposium reliable distributed systems srds pages lausanne switzerland october 
ieee 
bibliography rv 
concurrency control distributed object oriented database systems 
adbis pages st petersburg russia 
omg common object request broker architecture corba version chapter fault tolerant corba pages 
object management group avenue suite needham ma usa september 
ora oracle oracle parkway city ca 
oracle tm advanced replication november 
oracle technical white 
tamer zsu 
principles distributed database systems 
prentice hall upper saddle river new jersey usa second edition 
pcd powell ch que 
fault tolerance delta 
acm operating systems review sigops april 
ped pedone 
database state machine group communication issues 
phd thesis cole polytechnique rale de lausanne switzerland 
ped pedone 
boosting system performance optimistic distributed protocols 
computer december 
pf pedone fr lund 
fast failover protocol offthe shelf commercial databases 
proceedings th ieee symposium reliable distributed systems srds germany october 
ieee computer society 
pg pedone guerraoui 
transaction liveness replicated databases 
proceedings ieee pacific rim international symposium fault tolerant systems december 
pgm garcia molina 
reliable scheduling tmr database system 
acm transactions computer systems february 
pgm garc molina 
evaluation remote backup algorithms transaction processing systems 
acm transactions database systems september 
pgs pedone guerraoui schiper 
transaction reordering replicated databases 
proceedings th symposium reliable distributed systems srds durham north carolina usa october 
bibliography pgs pedone guerraoui schiper 
exploiting atomic broadcast replicated databases 
proceedings europar europar september 
pgs pedone guerraoui schiper 
database state machine approach 
technical report ssc cole polytechnique rale de lausanne switzerland march 
mart nez jim nez peris ar 
group transactions integrated approach transactions group communication 
workshop concurrency dependable computing newcastle tyne united kingdom june 
pol 
fault tolerant real time systems problem replica determinism volume computer science 
kluwer academic publishers boston november 
ps pedone schiper 
generic broadcast 
proceedings th international symposium distributed computing disc september 
shrivastava little 
design implementation 
technical report tr esprit basic research project broadcast october 
rfv rodrigues fonseca ver 
totally ordered multicast large scale systems 
proceedings th international conference distributed computing systems icdcs pages hong kong may 
ieee 
alonso jim nez peris mart nez 
reliable multicast expensive 
optimistic 
proceedings th workshop pisa italy october 
rr rodrigues raynal 
atomic broadcast asynchronous crash recovery distributed systems 
proceedings th international conference distributed systems icdcs pages taipei taiwan roc april 
ieee computer society los alamitos usa 
rst setia tripathi 
fault tolerant algorithm replicated data management 
ieee transactions parallel distributed systems december 
saa agrawal el abbadi 
broadcast primitives replicated databases 
proceedings th ieee international conference distributed computing systems icdcs pages amsterdam netherlands may 
ieee 
bibliography sch schneider 
implementing fault tolerant services state machine approach tutorial 
acm computing surveys december 
ske skeen 
nonblocking commit protocols 
edmund lien editor proceedings international conference management data pages ann arbor michigan usa april 
acm sigmod new york 
sr schiper raynal 
group communication transactions distributed systems 
communications acm april 
sta 
replication db oracle sybase 
database programming design 
sta 
replication db oracle sybase 
sigmod record acm special interest group management data december 
sto stonebraker 
concurrency control consistency multiple copies data distributed ingres 
ieee transactions software engineering se may 
sw weikum 
experiences building federated transaction manager corba ots 
proceedings nd workshop pages germany may 
infix sankt augustin 
tho thomas 
majority consensus approach concurrency control multiple copy databases 
acm transactions database systems june 
tp 
optimal replica control protocols exhibit symmetric operation availabilities 
proc 
int 
symp 
fault tolerant computing ftcs 
schiper 
contention aware metrics distributed algorithms comparison atomic broadcast algorithms 
proceedings th ieee international conference computer communications networks ic october 
schiper 
single environment simulate prototype distributed algorithms 
proc 
th int conf 
information networking city japan february 
bibliography van 
database replication prototype 
master thesis rijksuniversiteit groningen cole polytechnique rale de lausanne netherlands switzerland august 
van renesse birman maffeis 
horus flexible group communication system 
communications acm april 
chockler keidar dolev 
group communication specifications comprehensive study 
technical report mit lcs tr massachusetts institute technology massachusetts avenue cambridge ma usa september 
wal wang lee 
reliability issues distributed component object model dcom 
proceedings th international workshop community networking cn pages atlanta georgia usa september 
ieee ieee 
position 
wps pedone schiper 
systematic classification replicated database protocols atomic broadcast 
proceedings rd research seminar advances distributed systems pages madeira island portugal april 
broadcast esprit wg 
wps pedone schiper kemme alonso 
database replication techniques parameter classification 
proceedings th symposium reliable distributed systems srds pages germany october 
ieee computer society 
wps pedone schiper kemme alonso 
understanding replication databases distributed systems 
proceedings th international conference distributed computing systems icdcs taipei taiwan april 
ieee computer society los alamitos california 
ws wilhelm schiper 
hierarchy totally ordered multicasts 
proceedings th ieee symposium reliable distributed systems srds bad germany september 
curriculum vit born switzerland 
attended primary secondary school geneva 
time started fiddle got interested computing 
obtained rale coll ge calvin geneva 
started study computer science centre universitaire informatique university geneva 
onwards served technical assistant system administrator different sections university 
master thesis fault tolerant designs obtained diploma 
working distributed system laboratory lsr lse swiss federal institute technology research teaching assistant phd student guidance professor andr schiper 
worked teacher university applied science fribourg 
index safe see zero safe safe safe replication pc pl strict pc abort multilateral unilateral acid active backup replication optimistic active replication optimistic amoeba ansi asynchronous replication timing model writes atomic broadcast see total order broadcast atomic commitment blocking atomicity backup active copy passive bad process best effort total order broadcast black box blocking atomic commitment box black white broadcast causal total order best effort non uniform uniform fifo reliable uniform reliable uniform total order uniform atomic sim certification replication group safe channel fair loss quasi reliable reliable client server architecture cold standby commit protocol atomic see atomic commitment phase see pc phase see pc communication primitive optimistic weak concurrency control index optimistic pessimistic consensus consistency consistent lazy replication constant interaction copy backup primary correct process cpu resource crash artificial fail model recovery model recovery model total deadlock distributed delegate server delivery successful delivery unsuccessful failure detector discrete event simulation disk resource distributed operating system transaction distributed deadlock distributed locking replication dragon durability group dynamic transaction eager replication epoch failure detector perfect fg locking fifo atomic broadcast total order broadcast uniform reliable broadcast fine granularity locking replication flow control follower force write process green process group ownership group safe group safe certification replication high level replication transaction history complete hot standby manager incarnation incorrect process interaction constant linear interactive transaction ip multicast isis isolation snapshot index lan lazy replication consistent leader linear interaction load balancing local area network see lan lock manager locking phase see pl low level replication transaction manager lock master ownership message reordering level message reordering level message replay middleware model crash recovery crash recovery timed synchronous non uniform total order broadcast non voting replication termination object ownership failure detector copy equivalence serialisability safe see safe optimistic active replication communication primitive delivery ownership group master object failure detector passive backup replication peer peer architecture replication persistent objects ping point determinism serialisation primary copy replication primary backup replication process bad correct green incarnation incorrect red view yellow proxy quasi reliable channel quorum raid real time soft index red process reliable broadcast uniform reliable channel replay message replica replica control strict see strict replica control replication active optimistic asynchronous certification group safe database state machine distributed locking eager fg locking fine granularity locking group safe high level lazy low level non voting passive peer peer primary backup primary copy semi active ser state machine synchronous update weak voting resource cpu disk rpc safe see safe see safe group see group safe see group safe see safe see safe see safe zero see zero safe ser replication serialisability copy server delegate primary proxy snapshot isolation spontaneous order sql standby cold see cold standby hot see hot standby state machine replication stored procedure stored procedures strict replica control strong voting successful delivery suspicion false synchronous replication timing model termination threads phase commit protocol see pc timed asynchronous model timeless timing model total order broadcast best effort non uniform transaction distributed see distributed transaction dynamic high level index interactive low level static termination phase commit protocol see pc locking see pl safe see safe uniform atomic commitment see atomic commitment consensus fifo reliable broadcast reliable broadcast total order broadcast unilateral abort unsuccessful delivery update replication ups safe view change processes voting strong see strong voting termination weak see weak voting wait graph wan weak communication primitive weak voting white box wide area network see wan write force yellow process zero safe 
