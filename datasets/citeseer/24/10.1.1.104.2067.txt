efficient annotated terms van den brand de jong klint olivier software engineering sen sen february centrum voor wiskunde en informatica report sen issn cwi box gb amsterdam netherlands cwi national research institute mathematics computer science 
cwi part stichting mathematisch centrum smc dutch foundation promotion mathematics computer science applications 
smc sponsored netherlands organization scientific research nwo 
cwi member ercim european research consortium informatics mathematics 
copyright stichting mathematisch centrum box gb amsterdam nl kruislaan sj amsterdam nl telephone telefax efficient annotated terms mark van den brand cwi box nl gb amsterdam netherlands mark van den brand cwi nl de jong cwi box nl gb amsterdam netherlands de jong cwi nl paul klint cwi box nl gb amsterdam netherlands programming research group university amsterdam kruislaan nl sj amsterdam netherlands paul klint cwi nl pieter olivier cwi box nl gb amsterdam netherlands pieter olivier cwi nl distributed applications exchange tree data structures 
introduce data type annotated terms aterms discuss design implementation application 
comprehensive procedural interface enables creation manipulation aterms java 
aterm implementation maximal subterm sharing automatic garbage collection 
binary exchange format concise representation aterms sharing preserved allows fast exchange aterms applications 
typical application parse trees contain considerable redundant information bytes needed represent node memory bits needed represent binary format 
implementation aterms scales manipulation aterms giga byte range 
acm computing classification system 
keywords phrases binary data exchange format distributed applications garbage collection hashing maximal subterm sharing 
note appear software practice experience spe note carried project sen asf sdf cut paste operations complex data structures standard desktop software environments easily clip part spreadsheet paste text document 
exchange complex data common distributed applications complex queries transaction records complex data exchanged different parts distributed application 
compilers programming environments consist tools editors parsers optimizers code generators exchange syntax trees intermediate code 
exchange complex data structures applications achieved 
solution microsoft object linking embedding ole cha 
platform specific proprietary set primitives construct windows applications 
language specific solution java serialization interface gjs 
allows writing reading java objects sequential byte streams 
solution omg interface definition language part common object broker architecture omg define data structures language neutral way 
specific language bindings provide mapping idl data structures language specific data structures 
solutions merits really qualify looking open simple efficient concise independent solution exchange complex data structures distributed applications 
specific interested solution characteristics open independent specific hardware software platform 
simple procedural interface contain functions 
efficient operations data structures fast 
concise inside application storage data structures small possible compact representations exploiting sharing 
applications transmission data structures fast compressed representation fast encoding decoding 
transmission preserve sharing memory representation data structures 
language independent data structures created manipulated suitable programming language 
annotations applications transparently extend main data structures annotations represent non structural information 
describe data type annotated terms characteristics 
form solution implementation needs areas interactive programming environments kli distributed applications bk widely applicable 
typically want exchange process tree data structures parse trees syntax trees parse tables generated code formatted source texts 
applications involved include parsers type checkers compilers formatters editors user interfaces written variety languages 
typically parser may add annotations nodes tree describing coordinates corresponding source text formatter may add font color information editor displaying textual representation tree 
aterm data type designed represent tree data structures natural aterms internal representation data inside application exchange information applications 
function applications needed represent basic tree structure small number primitives provided aterm data type generally applicable 
include integer constants real number constants binary large data objects blobs lists aterms placeholders represent typed gaps aterms 
comprehensive set primitives operations aterms possible perform operations aterm received application converting application specific representation 
give quick overview aterms section 
discuss implementation issues section give insight performance issues section 
overview applications section overview related discussion section conclude 
aterms glance describe constructors aterm data type section operations defined section 
aterm data type data type aterms aterm int integer constant bits integer aterm 
real real constant bits real aterm 
appl function application consisting function symbol zero aterms arguments aterm 
number arguments function called arity function 
list 
placeholder placeholder term containing aterm representing type placeholder aterm 
blob blob binary large data object containing length indication byte array arbitrary possibly large binary data aterm 
list aterm pairs may associated aterm representing list pairs 
constructs int real appl list placeholder form subtypes data 
subtypes needed determining type arbitrary aterm 
depending actual implementation language represented constant pascal subclass java 
construct annotation construct possible annotate terms transparent information appendix contains definition concrete syntax aterms 
primary reason having concrete syntax able exchange aterms human readable form 
section discuss compact binary format exchange aterms format suitable processing machine 
give number examples show features textual representation aterms 
integer real constants written conventionally valid aterms 
function applications represented function name followed open parenthesis list arguments separated commas closing parenthesis 
arguments parentheses may omitted 
examples test hello world 
examples show double quotes delimit function names identifiers 
lists represented opening square bracket number list elements separated commas closing square bracket abc examples 
placeholder represented opening angular bracket followed subterm closing angular bracket 
examples int int real 
blobs concrete syntax human readable form depends actual blob content 
operations aterms operations aterms fall categories making matching aterms section reading writing aterms section annotating aterms section 
total functions provide functionality users build simple applications aterms 
refer interface level interface aterm data type 
accommodate power users aterms provide level interface contains sophisticated set data types functions 
typically generated code calls aterm primitives efficiency critical applications 
extensions useful control underlying implementation needed situations operations implemented level constructs currently upgrading aterm library support bit architectures 
transparent sense result operations independent annotations 
easy completely ignore annotations 
examples annotations include annotating parse trees positional typesetting information annotating syntax trees results type checking 
expressed concisely implemented efficiently level constructs 
level interface strict superset level interface see appendix details 
observe aterms purely functional data type destructive updates possible see section details 
making matching aterms simplicity level interface achieved match paradigm compose new aterm providing pattern filling holes pattern 
match decompose existing aterm comparing pattern decompose pattern 
patterns just aterms containing placeholders 
placeholders determine places aterms substituted matched 
example pattern int appl 
patterns appear string argument match remotely comparable format strings scanf functions operations making matching aterms aterm string aterm aterm create new term string pattern parsing aterm filling placeholders resulting term values taken 
parse fails message printed program aborted 
types arguments depend specific placeholders pattern 
instance placeholder int integer expected argument new integer aterm constructed 
aterm string aterm aterm match term pattern bind subterms match placeholders result variables 
type result variables depend placeholders 
parse pattern fails message printed program aborted 
term contains placeholders may occur resulting substitutions 
function match succeeds false 
boolean aterm aterm check aterms equal 
annotations equal 
integer aterm retrieves type aterm 
operation returns subtypes mentioned section 
reading writing aterms reasons efficiency conciseness reading writing take place forms text binary 
text format uses textual representation discussed earlier section appendix format space inefficient sharing memory representation terms lost 
binary format binary aterm format see section portable machine readable compact preserves memory sharing 
operations reading writing aterms aterm string creates new term parsing string 
parse error occurs message printed special error value returned 
aterm file creates new term parsing data file 
parse errors result message printed error value returned 
aterm file creates new term reading binary representation file 
boolean aterm file write text representation term file 
success failure 
unnecessary size explosion avoided extending textual representation mechanism labeling referring terms 

occurrence ofg labeled second occurrence refers label 
boolean aterm file write binary representation term file 
success failure 
string aterm return text representation term string 
format textual binary linear stream including files sockets pipes annotating aterms annotations pairs may attached aterm 
recall aterms completely functional data type destructive updates possible 
evident operations manipulating annotations aterm aterm aterm aterm return copy term annotation labeled changed 
annotation specified label added 
aterm aterm aterm retrieve annotation labeled term 
annotation specified label special error value returned 
aterm aterm aterm return copy term annotation labeled removed 
annotation specified label returned unchanged 
implementation requirements section mentioned main requirements openness simplicity efficiency conciseness language independence capable dealing annotations 
number issues consider great impact implementation fairly unique problem providing automatic garbage collection aterm users need deallocate aterm objects explicitly 
safe simple user 
expected lifetime terms applications short 
means garbage collection fast touch minimal amount memory locations improve caching paging performance 
total memory requirements application estimated advance 
possible allocate memory incrementally 
applications exhibit high level redundancy terms processed 
large terms significant number identical subterms 
intuitively explained fact applications process terms fixed signature limited tree depth 
amount terms processed increases plausible similarity terms increases 
typical applications percent terms arity higher 
applications annotations sparingly 
implementation impose penalty applications 
order portable efficient implementation implementation language poses special requirements garbage collection strategy considerations mind discuss maximal memory sharing terms section garbage collection section encoding terms section binary aterm format section 
implemented library java 
case issues discuss irrelevant built features java garbage collection just express low level concerns java 
maximal sharing strategy minimize memory usage simple effective create terms new exist 
term constructed exists term reused ensuring maximal sharing 
strategy fully exploits redundancy typically terms built leads maximal sharing subterms 
library functions construct terms sure shared terms returned possible 
sharing terms invisible library user 
effects maximal sharing maximal sharing terms maintained check term creation particular term exists 
check implies search existing terms fast order impose unacceptable penalty term creation 
hash function depends internal code function symbol addresses arguments quickly search function application creating 
terms stored hash table 
hash table contain terms pointers terms 
provides flexible mechanism resizing table ensures entries table equal size 
modest negligible cost term creation time hash table lookup 
fortunately get returns investment 
considerably reduced memory usage leads reduced execution time 
second gain substantially equality check terms cheap reduces operation linear number subterms compared constant operation pointer equality 
consequence approach fortunate 
terms shared creator knowing terms modified creating unwanted side effects 
means terms effectively immutable creation 
destructive updates maximally shared terms allowed 
especially list operations fact aterms immutable expensive 
responsibility user library choose algorithms minimize effect shortcoming 
searching shared subterms maximal sharing terms requires checking term creation time term exists 
search fast order ensure efficient term creation 
hash function addresses function symbol arguments function application allows quick lookup hash table find function application creating 
collisions issue hash techniques handling collisions 
simplest technique linear chaining knu 
requires pointer object hash chaining implementation implies memory overhead percent 
solutions collision resolution increase memory requirements time needed insertions deletions see knu 
linear hash chaining implementation 
direct indirect hashing issue store terms directly hash table 
storing objects directly hash table saves memory access retrieving term space needed store 
severe drawbacks approach rehash old terms rehashing means move objects memory 
implementation language moving objects memory allowed determine conservative root set allowed change pointers roots 
mean hash table grow initial size 
internal fragmentation increased empty slots hash table large object machine word 
need separate hash table term size decrease internal fragmentation 
problems linear hash chaining combined indirect hashing 
load hash table reaches certain threshold rehash larger table 
user increase initial size hash table save resizing rehashing operations 
aterm library provides facilities defining hash tables 
allows implementation fast lookup mechanism aterms 
user defined hash tables instance implement memo functions asf sdf compiler see section 
garbage collection technique 
common strategies automatic recycling unused space counting mark compact collection mark sweep collection 
case counting valid alternative takes time space hard implement mark compact garbage collection unattractive assumes objects relocated 
case identify object 
determine root set conservatively mark sweep collection discussed mark compact collection 
mark sweep garbage collection mark sweep garbage collection works phases 
phase objects heap marked dead 
second phase objects reachable known set root objects marked live 
third phase dead objects swept list free objects 
mark sweep garbage collection implemented efficiently support programmer compiler bw boe 
mark sweep collection efficient time space counting jl 
possible drawback increased memory fragmentation compared mark compact collection 
typical space overhead mark sweep garbage collection algorithm bit object count field take bytes 
reusing existing garbage collector number excellent generic garbage collectors freely available reuse existing implementation 
examined number alternatives fit needs 
boehm weiser garbage collector bw came close face number unusual circumstances render existing garbage collectors impractical hash table contains objects 
possible instruct garbage collector scan area roots 
object garbage removed hash table 
means need low level control garbage collector 
aterm data type special characteristics exploited dramatically increase performance destructive updates allowed 
garbage collection terminology means pointers old objects younger objects 
exploit current implementation characteristic generational garbage collector attractive 
majority objects memory representation bytes 
practical experience shown root pointers kept static variables generic heap 
performance increased dramatically eliminate expensive scan heap static data area root pointers 
downside require programmer explicitly supply set roots located heap static variables 
observations allow gain efficiency levels low level system hacks high level optimizations 
implementing garbage collector considering performance maintainability code uses aterm library opted version mark sweep garbage collector 
object contains single bit mark sweep algorithm indicate live marked objects 
start garbage collection cycle objects unmarked 
bit type arity header layout garbage collector tries locate mark live objects traversing terms explicitly protected programmer function scanning run time stack looking words objects 
word object transitive closure objects refers marked live 
scan run time stack causes objects referenced local variables protected garbage collected 
garbage collector conservative collector sense words stack accidentally bit pattern object 
way separate fake bit patterns real object cause objects marked live garbage 
note bit patterns stack point valid objects traversed 
bit pattern represents address valid object address followed mark corresponding object 
live objects marked single sweep heap store objects free separate lists free objects list object size 
shall see section objects consist couple machine words 
restricting maximum arity function set upper bound maximum size objects 
enables base memory management algorithms small number block sizes 
allocation objects simply matter element appropriate free list extremely cheap operation 
garbage collection yield free objects new memory blocks allocated satisfy allocation requests 
term encoding important issue implementation aterms represent data type operations performed efficiently time space 
concise encoding aterms follows 
assume machine word consists bytes 
aterm object stored machine words 
byte word called header object consists fields see field consisting bit mark flag garbage collector 
field consisting bit indicating term annotation 
field consisting bits indicate type term 
field consisting bits representing arity number pointers terms object 
field contains maximum value term function application actual arity retrieving arity function symbol see 
depending type node determined header byte word remaining bytes word contain function symbol length indication unused 
second word hashing links terms hash bucket 
type node determines exact layout contents 
shows encoding different term types describe detail 
int encoding integer term third word contains integer value 
arity integer term 
real encoding real term third fourth word contain real value represented byte ieee floating point number 
arity real term 
real appl list placeholder blob byte int header unused hash entry integer value optional annotation header unused hash entry real value optional annotation header function symbol hash entry argument argument argument optional annotation header length hash entry optional annotation header unused hash entry placeholder type optional annotation header data size hash entry data pointer optional annotation encoding different term types appl encoding remaining bytes header word represent index table containing function symbols 
words second word contain function arguments 
way function applications encoded machine words arity function application 
list encoding binary list constructor seen special function application function symbol arity 
third word points element list called field fourth word points remainder list called field 
length list stored bytes header word 
empty list represented list object empty fields length 
function application list construct second aterm construct 
memory efficient representation lists important 
due nature operations aterm lists obvious list representations array term linked list term 
experiments shown typical applications quite varying list sizes encountered 
renders array approach inferior adding deleting elements list expensive 
consequently opted linked list approach 
lists constructed binary list constructors containing element list tail list 
list operation ensure list normalized 
easy perform commonly operations list adding removing element list 
operations expensive allow destructive updates 
adding element tail list instance requires list creation operations number elements newly created list 
due uniqueness terms instance empty list time 
placeholder encoding placeholder term arity third word contains pointer placeholder type 
blob encoding length data contained blob term stored bytes header 
means upto bytes encoded single blob term 
pointer actual data stored third word 
annotations cases annotations represented extra word term object 
single annotation bit header indicates annotation 
bit set extra word allocated points term typelist represents list annotations 
aterm exchange binary aterm format efficient exchange aterms tools important 
simplest form exchange concrete syntax appendix involve printing term side parsing 
concrete syntax efficient exchange format sharing function symbols subterms expressed way 
better solution exchange representation sharing function symbols subterms expressed concisely 
raw memory dump addresses address space process meaning address space process 
order address problems developed baf binary aterm format 
writing addresses assign unique number index subterm symbol occurring term want exchange 
referring term index address 
writing term writing table order increasing indices function symbols term 
function symbol consists string representation name followed arity 
aterms written prefix order 
write function application index function symbol written 
indices arguments written 
argument consists term written index argument written continuing argument 
way subterm written exactly 
time parent term wishes refer subterm just uses subterm index 
exploiting aterm regularities sending large term containing subterms subterm indices quite large 
consequently bits needed represent indices 
considerably reduce size indices take account regularities structure terms 
empirical study shows set function symbols occur argument positions function application function symbol small 
explanation aterm applications typed data types represent 
case function applications represent objects type object represented function symbol 
type hierarchy determines types occur position object 
exploit knowledge grouping terms top function symbol 
terms function applications grouped dummy function symbols term type 
function symbol determine function symbols occur argument position 
writing table function symbols start baf file write information 
cases number function symbol occurrences small compared number terms written 
storing extra information function symbol order get better compression worthwhile 
writing argument function application start writing actual symbol argument 
symbol taken limited set function symbols symbols occur position small number represent 
function symbol write index argument term table terms function symbol index argument total term table 
example example show represented baf 
term contains function symbols mult arity arity arity zero 
grouping subterms function symbol get mult mult look function symbols occur argument position weget position mult start writing symbol information file 
write bytes mult length representation 
arity 
symbol occur argument position 
symbols index second argument position possible top symbol index 
length representation ofs 
arity ofs 
single argument different top function symbols index index 
length representation ofz 
arity ofz 
symbol information actual encoded handful bits 
note function symbol symbol table top function symbol term case mult bits need written identify function symbols possible function symbol argument position 
bit indicates term function written 
term written done 
function symbol argument ofs iss 
index term table symbols 
index symbol table symbols 
term bits needed encode term 
need encode second argument input term 
bits needed encode function symbols symbol occur second argument mult 
index term table symbols 
term written done 
value numbers exceeds bytes encode 
strings written strings improve readability 
bits needed encode 
mentioned earlier amount data needed write table function symbols start baf file cases negligible compared actual term data 
performance measurements benchmarks concise aterm representation fast baf files read written 
results highly depend actual terms base measurements collection terms cover applications encountered far 
artificial cases artificial cases constructed act borderline cases random unique randomly generated term signature fixed function symbols arities ranging arbitrary number constant symbols functions arity 
terms generated way constants unique 
terms worst case implementation regularity exploit subterms relatively high arity 
random randomly generated term signature function symbols arities ranging 
terms single constant occur shared regularities exploited subterms relatively high arity 
real cases real life cases actual applications cobol parse table generated parse table cobol including embedded sql cics 
grammar consists productions generated automaton states 
parse table contains action table non empty entries goto table non empty entries 
example data type represented aterm 
cobol system cobol system consisting programs total lines cobol source code 
parsed parse table 
parse trees constructed cobol programs represented aterms see section details 
risla library parse tree component library risla language domain specific language describing financial products adr 
component library consists lines code 
lpo linear process operator lpo describing protocol bus links gl lut 
kernel crl toolkit dg collection tools manipulation process data descriptions crl micro common representation language gp 
lpo structured process state consists assignment sequence typed data variables behaviour described condition action effect functions 
states represented aterms complex 
casl specifications collection syntax trees represented aterms casl files total number lines casl code 
details casl syntax tree representation aterms refer section 
lcc parse forest new back similar asdl back added lcc compiler han 
back maps internal format lcc compiler aterms 
aterm representation asdl representation program contain equivalent information 
back sources lcc compiler mapped aterms 
lcc compiler consists source files consisting total lines source code 
term nodes unique sharing memory bytes nodes bytes node artificial cases random unique random real cases cobol parse table cobol system risla library lpo casl specifications lcc parse forest expressions real case averages table memory usage aterms expressions simple translator developed transforms expression aterm 
translator process arbitrary collection el files containing expressions emacs source tree linux 
total number el files files contained lines code 
cases cobol system casl specifications lcc parse forest expressions set aterms combined processed aterm 
measurements performed ultra sparc mhz mb memory 
times measured user cpu time particular job 
measurements table give results memory usage sample terms columns give total number nodes term number unique nodes term sharing percentage amount memory bytes storage term average number bytes needed node 
seen figures applications sharing difference 
fully exploiting redundancies input terms store node average bytes perform operations efficiently 
worst case behaviour bytes node 
amount sharing clearly high case syntax trees case parse trees represented asfix terms 
asfix terms contain redundant information optimally shared 
amount sharing syntax trees casl lower due fact set casl specifications small specification tests feature casl language sharing expected 
expressions lowest ratio sharing expected represent ad hoc hand written lisp programs cases aterms obtained systematic translation source code 
case recurring patterns translation scheme result higher levels sharing 
shows amount sharing respect size large number cobol programs 
different sets cobol programs considered 
system consists files second files files 
concluded amount sharing increases size cobol system 
systems percentage sharing converges slightly 
find high percentage combination strong correlation size sharing remarkable analyze causes consequences detail separate 
table give results reading writing sample terms ascii text files 
columns give size text representation test term bytes average number bytes node time needed read text file average time needed read node time needed write text file average time needed write node 
average node requires bytes reading writing requires respectively 
consider random unique random cases unrepresentative averages real cases tables 
sharing percentage cobol system cobol system cobol system number lines original source code sharing large number cobol parse trees table give results reading writing baf files set sample terms 
columns give order size baf files bytes average number bytes needed node time read baf representation average read time node time write baf representation average write time node 
typically read node write note reading baf term faster writing term case ascii writing faster reading 
caused fact reading ascii representation aterm involves numerous matching operations reading baf representation done matching 
hand writing baf representation involves calculations encode sharing terms writing ascii representation involves straightforward term traversal 
table show compression baf files compares compression standard unix utility gzip 
considering set examples give figures straightforward dump term ascii text column size baf version term column percentage compression achieved column 
give results compressing ascii version term column compression achieved column 
compression factors baf 
worst case compression considerably better worst case compression baf 
gains expected gzip baf imply writing aterm textual format expensive operation looses sharing compressing 
summary measurements measurements summarized table 
memory storage bytes needed node 
baf bytes needed represent node 
observe reading baf order magnitude faster reading terms textual form 
case parse trees represented asfix cobol system risla library bytes needed represent node memory bits bytes needed represent binary format 
applications aterms applications ranging development tools domain specific languages dk factories renovation cobol programs bsv 
aterm data type basic data term ascii bytes read read write write node node node bytes artificial cases random unique random real cases cobol parse table cobol system risla library lpo casl specifications lcc parse expressions real case averages table reading writing aterms ascii text term baf bytes read read write write node node node bytes artificial cases random unique random real cases cobol parse table cobol system risla library lpo casl specifications lcc parse forest expressions real case averages table reading writing aterms baf type represent terms manipulated rewrite engines generated asf sdf compiler play central role development new asf sdf meta environment 
representing syntax trees asfix aterm data type proves powerful flexible mechanism represent syntax trees 
defining appropriate set function symbols parse trees syntax trees represented language formalism 
describe examples asfix parse tree format asf sdf section syntax tree format casl section 
asfix asfix asf sdf fixed format incarnation aterms representing asf sdf bhk dhk 
asf sdf modular algebraic specification formalism describing syntax semantics programming languages 
sdf syntax definition formalism allows definition concrete syntax language comparable bnf 
asf algebraic specification formalism allows definition term ascii baf comp 
gzip comp 
bytes bytes bytes artificial cases random unique random real cases cobol parse table cobol system risla library lpo casl specifications lcc parse forest expressions real case averages table baf memory ascii baf size node bytes read node write node table summary measurements real case averages semantics terms equations interpreted rewrite rules 
development asf sdf specifications supported integrated programming environment asf sdf meta environment kli 
asfix module term represented parse tree contains syntax rules original layout comments 
way original source text reconstructed asfix representation enabling transformation tools access transform comments source text 
asfix representation self contained grammar information needed interpret term included easily develop tools processing asfix terms consult common database grammar information 
examples tools structure editor rewrite engine 
asfix defined appropriate set function symbols representing common constructs parse tree 
function symbols include prod represents production rule appl represents applying production rule arguments represents literal sort represents sort lex represents lexical token sort represents white space attr represents single attribute 
attrs represents list attributes 
attrs represents empty list attributes 
context free syntax rules sdf necessary parse input false 
sort bool context free syntax true bool false bool bool bool bool left parse tree gives asfix representation input false 
appl prod sort bool sort bool sort bool attrs attr left appl prod true sort bool attrs true appl prod false sort bool attrs false observations parse tree 
parse tree ordinary aterm manipulated aterm utilities completely generic way 
second parse tree completely self contained depend separate grammar definition 
clear way representing parse trees contains redundant information 
maximal sharing baf essential reduce size 
measurements asfix plays role cases cobol system risla library 
annotations provided aterm data type store auxiliary information position information derived parser font color information needed structure editor 
information globally available ignored tools interested 
casl common algebraic specification language new algebraic specification formalism cl developed part cofi initiative 
general algebraic specification formalism incorporating common features existing algebraic specification languages 
addition language set tools planned supporting development casl specifications 
existing tools reused possible 
order various tools parsers editors proof checkers communicate intermediate format needed casl 
aterms selected intermediate format specialized version representing syntax trees casl designed 
contrast approach taken asfix concrete parse trees intermediate representation 
obtained defining appropriate set function symbols representing casl syntax cl defining mapping casl concrete syntax syntax 
syntax rule equivalent construct defined alternative total construct op name components total construct op name components components example total construct components function symbols op name components represent subtrees corresponding sort 
asf sdf meta environment asf sdf meta environment kli interactive development environment writing language specifications asf sdf 
new generation environment developed separate components connected bk 
description new architecture 
new meta environment provides tools parsing compilation rewriting debugging formatting 
aterms asfix play important role new meta environment parser generator vis produces parse table represented aterm 
specification asf sdf asf sdf generated asf sdf code compiler compiler equations lines lines sec sec asf sdf compiler table figures asf sdf compiler 
application time sec memory mb asf sdf compiler sharing asf sdf compiler sharing table performance maximal sharing 
parser uses parse table transforms input string parse tree represented asfix term 
parsing modules asf sdf specification stored asfix terms 
information concerning specification rewrite rules compiled exchanged asfix terms 
asf sdf compiler see section reads writes asfix terms 
asf sdf compiler asf sdf compiler compiler asf sdf 
generates ansi code depends aterm library run time environment 
terms manipulated generated code represented aterms advantage maximal subterm sharing automatic garbage collection 
optimized memory usage aterms exploited various industrial projects memory usage critical success factor 
asf sdf compiler instance applied successfully projects development domain specific language describing interest products financial domain adr renovation factory restructuring cobol code bsv 
asf sdf compiler asf sdf specification bootstrapped 
table gives figures size specification time needed compile 
table gives impression effect compiling asf sdf compiler sharing 
information compiler performance issues 
applications applications development include tool protocol verification gl 
aterms represent states state space protocol 
huge amount states necessary share states possible 
tool detection code clones legacy code 
stratego compiler 
discussion related expressions lisp intermediate representations derived form lisp 
aterms exception rule 
main improvements aterms expressions term ascii baf asdl pickle cobol parse table table sizes cobol parse table bytes aterms support arbitrary binary data blobs see section 
aterms support annotations 
aterms support maximal sharing systematic way 
aterms support concise sharing preserving exchange format exploits implicit signature terms 
aterm library provides comprehensive collection access functions match paradigm 
intermediate representations compiler frameworks exist numerous frameworks compilers programming environments provide facilities representing intermediate data 
examples centaur bcd eli cocktail ast gro suif asdl montana kar 
systems provide explicit intermediate format eli ast suif provide programmable interface intermediate data montana asdl 
lamb idl lam omg idl omg frameworks representing intermediate data tied specific compiler construction paradigm objectives similar systems mentioned 
approaches typically grammar definition syntax including attributes provide generated access functions readers writers intermediate data 
cases support exists accessing intermediate data small collection source languages 
major difference approaches aterms operate different levels abstraction 
aterms just provide lower level representation terms precisely directed acyclic graphs intermediate representations compilers specialized give higher level view intermediate data 
provide primitives representing program constructs symbol tables flow graphs derived information 
cases provide fixed format representing programs different levels abstraction ranging call graphs machine instructions 
aterms simpler general represent compiler intermediate formats 
difference compiler frameworks statically typed intermediate representation 
major advantage early error detection 
disadvantages flexibility need generate different access functions different intermediate format 
case aterms dynamic check may necessary intermediate data single generic set access functions needed 
asdl syntax definition language asdl language describing tree data structures intermediate representation language various phases compiler han 
consider asdl detail public availability fact goals asdl aterms quite similar exchange syntax trees tools aterms general sense types information unstructured binary objects annotations represented aterm 
represented grammar represented aterms asdl 
asdl baf format aterms comparable respect functionality binary representations syntax trees 
pickle functions generated asdl description application specific may efficient reading writing baf entirely generic avoids proliferation versions 
asdl aterms compared different levels low level asdl pickle versus plain aterms 
providing asdl definition aterms compare size object aterm ascii baf asdl pickle 
done table cobol parse table 
case representation baf order magnitude smaller asdl pickle 
term ascii baf asdl pickle lcc parse forest table sizes syntax trees bytes high level compare level parse trees syntax trees 
asdl typically represent syntax trees aterms represent discussed section 
meaningful comparison compare syntax trees generated lcc back aterm format ascii baf corresponding asdl 
figures table syntax trees generated lcc source files 
case baf representation times smaller asdl pickle 
note baf representation differs table caused fact table files combined baf term table file separate baf term sizes added 
xml extensible markup language xml standardized format web documents 
html xml strict distinction content presentation 
xml extended adding user defined tags parts document defining structure document enabling wellformedness checks documents 
original objectives completely different striking similarities aterms xml serve representation hierarchically structured data allow arbitrary extensions adding tags versus adding function symbols 
straightforward translation possible aterms xml 
main difference xml verbose provide simple mechanism represent sharing aterms provide baf format 
may problem web documents catalogues database records major obstacle case need exchange huge terms tools 
currently considering link aterms xml may advantageous 
data encodings described section form data encoding compress aterms exchanged tools 
course encoding data compression techniques common telecommunications 
instance asn standard gives detailed rules data encoding asn 
earlier project group graph exchange language gel kam developed 
similar goals baf baf represent acyclic directed graphs gel represent arbitrary potentially cyclic graphs 
technical approaches different 
gel uses binary encoded postfix format represent nodes graph introduces explicit labels reuse previously constructed parts graph 
baf uses prefix format augmented generated symbol tables 
final difference usage approaches 
gel separate library applications graph encoding visible programmer 
baf hand completely integrated aterm implementation standard read write functions aterms 
baf format visible programmers 
hash consing lisp success hash consing limited existence functions destructively modify list structure 
support destructive updates support kinds list structures mono copy lists maximal sharing multi copy lists maximal sharing 
destructively changing mono copy list converted multi copy list 
goto experimented lisp dialect supporting hash consing list types just sketched 
see tk overview applications 
striking observation context sml ag sharing resulted slightly increased execution speed marginal space savings 
closer inspection come methods term sharing different compared easily 
share terms immediately created costs table lookup storage needed table benefits space savings due sharing fast equality test pointer comparison 
ag sharing subterms determined garbage collection order minimize overhead table lookup term creation 
implies local terms survived garbage collection shared loosing benefits space savings fast equality test 
history terms simple programmers prefer write implementation looking existing implementation 
right happens group cooperating developers case 
version aterm library developed part coordination architecture bk 
represent data transported tools written different languages running different machines 
simultaneously developing formalism representing parse trees gb 
addition incompatible term formats various compiler projects 
observing similarities incompatible term data types triggered aterms described 
benefits twofold 
common term data type applications investments rewarded 
second mere existence common data type leads new unanticipated applications 
instance aterms representing parse tables 
stated aterms intended form open simple efficient concise independent solution exchange tree data structures distributed applications 
aterms open language independent depend specific hardware software platform 
aterms simple level interface consists functions 
aterms efficient concise shown measurements section 
aterms useful shown section 
aterm format supported binary exchange format baf provides mechanism exchange aterms concise way 
baf format maintains memory sharing terms uses minimal amount bits represent nodes case asfix terms bits needed node 
innovative aspects aterms simple procedural interface match paradigm term annotations maximal subterm sharing concise binary encoding terms completely hidden high level read write operations 
availability aterm library obtained www wins uva nl pub programming research software aterm current version library available unix including linux windows nt 
currently working bits implementation library 
acknowledgments want current users aterm library 
special jan groote input severe requirements de jonge jeroen detecting large number intricate bugs 
alexander van den porting aterm library windows nt part master thesis project joost visser providing useful information asdl writing tool pickle aterms 
pierre etienne moreau fruitful discussions subject stay amsterdam 
want anonymous referees constructive remarks 
adr arnold van deursen res 
algebraic specification language describing financial products 
wirsing editor icse workshop formal methods application software engineering pages 
ieee april 
ag appel goncalves 
hash consing garbage collection 
technical report cs tr princeton university 
allen 
anatomy lisp 
mcgraw hill 
asn information technology syntax notation asn encoding rules packed encoding rules 
technical report international telecommunication union 
itu recommendation 
bcd cl ment th 
despeyroux lang 
centaur system 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments pages 
appeared sigplan notices 
van den brand van deursen klint van der meulen 
industrial applications asf sdf 
wirsing nivat editors algebraic methodology software technology amast volume lecture notes computer science 
springer verlag 
bhk bergstra heering klint editors 
algebraic specification 
acm press addison wesley 
bk bergstra klint 
discrete time software coordination architecture 
science computer programming july 
van den brand kuipers moonen olivier 
design implementation new asf sdf meta environment 
sellink editor proceedings second international workshop theory practice algebraic specifications asf sdf workshops computing amsterdam november 
springer verlag 
van den brand klint olivier 
aterms exchanging data heterogeneous tools casl 
note 
van den brand klint olivier 
compilation memory management asf sdf 
editor compiler construction cc volume lncs pages 
van den brand klint olivier visser 
syntax trees distributed environments 
technical report university amsterdam programming research group 
preparation 
van den brand klint verhoef 
term rewriting sale 
kirchner kirchner editors proceedings international workshop rewriting logic applications volume electronic notes theoretical computer science pages 
elsevier science 
boe boehm 
space efficient conservative garbage collection 
pldi pages 
bsv van den brand sellink verhoef 
generation components software renovation factories context free grammars 
baxter quilici verhoef editors proceedings fourth working conference reverse engineering pages 
bw boehm weiser 
garbage collection uncooperative environment 
software practice experience spe 
cha chappell 
understanding activex tm ole 
microsoft press 
cl cofi ld 
casl cofi algebraic specification language summary version 
documents casl summary 
dg dams groote 
specification implementation components crl toolbox 
technical report utrecht university 
dhk van deursen heering klint editors 
language prototyping algebraic specification approach volume amast series computing 
world scientific 
dk van deursen klint 
little languages little maintenance 
journal software maintenance 
fokkink th 
walters 
arm reach compilation left linear rewrite systems minimal rewrite systems 
acm transactions programming languages systems 
gb van den brand 
algebraic specification annotated syntax trees 
technical report university amsterdam programming research group 
gray levi sloane waite 
eli complete flexible compiler construction system 
communications acm 
gjs james gosling bill joy guy steele 
java language specification 
addison wesley 
gl groote 
tutorial guide crl toolset version 
technical report cwi amsterdam 
preparation 
gp groote ponse 
syntax semantics crl 
algebra communicating processes workshops computing pages 
springer verlag 
gro 
ast generator syntax trees 
technical report gmd karlsruhe 
han hanson 
early experience asdl lcc 
software practice experience 
heering hendriks klint rekers 
syntax definition formalism sdf manual 
earlier version sigplan notices 
jl jones lins 
garbage collection algorithms automatic dynamic memory management 
wiley 
kam th 

gel graph exchange language 
technical report cs cwi amsterdam 
kar 
architecture montana open extensible programming environment incremental compiler 
proceedings acm sigsoft sixth international symposium foundations software engineering pages 
kli klint 
meta environment generating programming environments 
acm transactions software engineering methodology 
knu knuth 
art computer programming volume sorting searching 
addison wesley 
lam lamb 
idl sharing intermediate representations 
acm transactions programming languages systems 
lut 
description formal specification link layer protocol sen 
technical report cwi amsterdam 
omg omg 
common object request broker architecture specification revision 
technical report object management group 
available www omg org 
tk 
concept implementation applications 
journal information processing 
visser benaissa tolmach 
building program optimizes rewriting strategies 
international conference functional programming icfp pages 
vis visser 
syntax definition language prototyping 
phd thesis university amsterdam 
wang appel korn serra 
zephyr syntax description language 
proceedings conference domain specific languages pages 
wilson french ch wilson amarasinghe anderson tjiang shih wei liao chau wen tseng hall hennessy 
suif infrastructure research optimizing compilers 
sigplan notices 
xml extensible markup language xml 
technical report world wide web consortium 
available www org tr rec xml 
concrete syntax aterms formal definition concrete syntax aterms syntax definition formalism sdf 
note concrete syntax defined blobs humanly readable representation blobs depends type data stored blob 
level interface aterms operations described section sufficient applications 
applications need control underlying implementation need operations implemented level constructs expressed concisely implemented efficiently specialized constructs 
designed level interface strict superset level interface described section 
new datatypes introduced new operations aterms 
level interface introduces new datatypes 
auxiliary datatype afun representing function symbols subtypes aterm datatype implement different term types 
subtypes allow introduce operations valid specific term type general aterm operations described earlier 
datatype represents integer terms 
operations integer construct new integer term corresponding integer value 
integer 
datatype represents real number terms 
operations real construct new real term 
real retrieve value real term 
afun afun consists string defining function name arity indication symbol name quoted 
operations symbols afun string integer boolean construct new symbol 
symbol name arity quotation exists existing symbol returned 
new symbol created returned 
subject garbage collection order avoid long running interactive programs slowly running symbols 
string afun retrieve name symbol 
integer afun retrieve arity symbol 
boolean afun check symbol quoted 
datatype represents function applications consisting function symbol number arguments 
operations datatype afun aterm aterm family operations inclusive 
operations construct new function application function symbol arguments 
afun atermlist construct new function application function symbol list arguments afun retrieve function symbol function application 
aterm integer retrieve specific argument 
atermlist datatype represents binary list constructor 
element indices start 
list length elements operations atermlist atermlist aterm aterm family operations inclusive 
operations quickly construct small lists terms 
integer atermlist retrieve length 
aterm atermlist retrieve element list 
atermlist atermlist retrieve element list 
atermlist atermlist retrieve element list 
aterm atermlist retrieve element list 
atermlist atermlist integer frm integer retrieve portion list position boolean atermlist check list contains zero elements 
atermlist atermlist aterm insert single element start list 
atermlist atermlist aterm integer insert single element position list 
atermlist atermlist aterm append single element list 
atermlist atermlist atermlist concatenate lists integer atermlist aterm integer search element list return index location 
start searching index 
element return integer atermlist aterm integer search backwards element list return index location element 
start searching index 
element return aterm atermlist integer retrieve element position list 
atermlist atermlist aterm remove occurrence element list 
atermlist atermlist integer remove element position list 
datatype represents placeholder terms 
operations aterm construct new placeholder term 
aterm retrieve type placeholder 
datatype represents binary large object terms 
operations integer data construct new blob term size containing data 
integer retrieve size blob 
data blob retrieve data pointer stored blob 
memory management blobs done explicitly application programmer 
auxiliary level interface provides functionality create manipulate user defined hash tables 

