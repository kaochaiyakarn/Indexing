reflective middleware desk hand manuel rom fabio kon roy campbell llc core com department computer science university illinois urbana champaign kon rhc cs uiuc edu 
communication middleware simplifies construction component distributed applications 
lack flexibility construction middleware imposes limitations major concern 
applications detect changes execution environment customize underlying middleware better accommodate changes 
solve problem research reflective middleware uses techniques derived previous computational reflection add flexibility middleware 
reflective middleware exploits concept meta object protocol introduced 
approach combines ideas computational reflection object orientation 
model distinguishes base level meta level objects 
base level concerns functional aspects system meta level concerns aspects include policies mechanisms strategies 
base level reflective middleware addresses functionality application program meta level designates collections components form internal architecture middleware platform 
reflection inspect modify components change behavior middleware 
computer networks pervasive portable embedded handheld devices common ubiquitous computing allow mobile users benefit significantly plethora ubiquitous services 
ubiquitous computing characterized constant change large degree dynamism 
users interact heterogeneous systems different devices different locations different networks different quality service requirements 
share systems users 
practical terms difficult devise fixed set policies mechanisms communication security resource allocation accommodate diversity change scale 
reflective middleware offers effective flexibility highly dynamic environments 
article begins presentation previous reflective middleware 
describe vision reflective middleware enabling technologies ubiquitous computing 
analyze specific requirements ubiquitous computing imposes reflective middleware architectures 
provide description ongoing active spaces exploits dynamictao reflective corba orb universally interoperable core small innovative reflective orb 

dynamictao dynamictao reflective corba orb built extension tao take advantage extensive efforts doug schmidt colleagues modularize organize middleware software :10.1.1.13.6617
tao portable flexible extensible configurable orb complies corba standard 
tao uses strategy design pattern encapsulate different aspects orb internal engine 
configuration file specify strategies orb uses implement aspects concurrency request demultiplexing scheduling connection management 
orb startup time configuration file parsed selected strategies loaded 
tao primarily targeted static hard real time applications avionics systems 
assumes orb initially configured strategies remain place completes execution 
little support fly reconfiguration 
dynamictao extends tao support fly reconfiguration assuring orb engine kept consistent 
achieved reifying dynamictao internal structure keeping explicit representation orb internal components dynamic interactions 
reification allows orb change specific strategies having restart execution 
dynamictao reflective orb allows inspection reconfiguration internal engine 
achieves exporting interface transferring components distributed system loading unloading modules orb runtime inspecting modifying orb configuration state 
infrastructure dynamic reconfiguration servants running top orb reconfiguring non corba applications 
architecture reification dynamictao achieved collection entities known component 
component configurator holds dependencies certain component system components 
process running dynamictao orb contains component configurator instance called 
responsible maintaining instances orb servants running process 
addition instance orb contains customized component configurator called 

reifying dynamictao structure contains hooks implementations dynamictao strategies attached 
hooks mounting points specific strategy implementations available orb 
illustrates reification mechanism process containing single instance orb 
necessary individual strategies component store dependencies orb instances strategies 
may store client requests depend strategies 
information possible manage strategy reconfiguration consistently explain section 
component implementations shipped dynamically loadable libraries linked orb process runtime 
organized categories representing different aspects orb internal engine different types servant components 
dynamictao architectural framework depicted 
persistent repository 
dynamictao components stores category implementations local file system 
offers methods manipulating browsing creating deleting categories implementations category 
component implementation stored local repository dynamically loaded process runtime 
network broker receives reconfiguration requests network forwards dynamic service configurator 
contains shown supplies common operations dynamic configuration components runtime 
delegates functions specific component certain 
orb consistency goal minimal orb core running orb strategies servants dynamically updated 
supporting orb fly reconfiguration introduces important issues exist dealing static startup configuration 
changing implementation runtime implies checking possible dependencies loaded implementations category dependencies clients old implementations conflicts implementations category running orbs 
initial state new strategy may depend final state old strategy going replaced 
reconfiguration operations executed immediately execution leave state orb inconsistent 
switching strategy deleting strategy operations 
aspects controlled orb remains stable operation completes 
changing strategy implies steps 
check new strategy implementation compatible remaining implementations 
implies checking strategies running orb cases strategies category orbs 
possible changing implementation certain orb requires changing implementations remote orbs implementations part distributed protocol 
second implementation may need transfer state new implementation going replace 
consider changes strategy implementation affect client requests processed 
greatly depends category implementation 
case marshalling unmarshalling strategies example changes immediately affect subsequent request 
case concurrency strategies changing implementation may affect new clients 
marshalling unmarshalling clear example implementation compatibility orbs distributed system 
marshalling strategy client orb changed unmarshalling strategy server orb changed accordingly 

bringing reflective middleware hand ubiquitous computing defined mark weiser introduces concept time computing 
users surrounding environment digitally augmented allowing new levels interaction enhanced productivity 
software infrastructure point view keys enable continuous computing ability guarantee seamless interoperability ubiquitous computing devices 
task communication middleware 
current middleware built assuming set hardware software requirements suitable desktop computers handheld embedded devices 
communication middleware implementations com java corba big fit devices limited resources provide configuration tools allow adapting different architectures 
problem applications typically require small subset middleware functionality forced linked libraries providing entire functionality 
case corba example client program simply invokes method remote object requires client side functionality orb object request broker dynamic invocation interface static invocation interface 
unfortunately orb implementations include entire functionality single library provide separate libraries client server sides option choose specific subset functionality 
existing middleware implementations designed assist development server applications running workstations desktops 
execution patterns requirements applications normally known communication middleware platforms export functionality customized scenarios banking applications air ticket reservations 
case ubiquitous computing previous execution patterns longer apply 
nature ubiquitous computing scenarios different previous scenarios 
addition heterogeneity associated ubiquitous computing possible provide single static middleware implementation fits scenarios 
flexibility introduced reflective middleware turns elegant approach cope requirements ubiquitous computing 
analyzing requirements ubiquitous computing considering devices ubiquitous computing scenarios pdas sensors phones appliances common properties apply limited resources heterogeneity high degree dynamism 
limited resource availability varies device device 
devices handheld pdas increasingly offer powerful cpus larger amounts memory devices sensors small appliances possible cost effective add resources 
heterogeneity probably predominant properties ubiquitous computing different hardware platforms operating systems software platforms imply changes parameters byte ordering byte length standard types communication protocols 
degree dynamism ubiquitous computing exist traditional servers workstations 
pda example interact devices services different locations implies changing parameters type communication network rpc protocols security policies 
possible predict possible combinations software running pda able adapt different scenarios cope dynamism 
previous properties affect design middleware infrastructure required ubiquitous computing 
conventional middleware platforms appropriate big inflexible 
true possible customize existing middleware platforms manually particular device 
process far realistic flexible suitable coping dynamic changes execution environment 
reflective middleware presents comprehensive solution deal properties previously introduced 
possible maintain applications base level unaltered push changes middleware platform meta level offers tools modify platform behavior 
existing reflective middleware implementations appropriate mobile handheld embedded devices 
detected main problems suitable ubiquitous computing scenarios size configuration options dependence single middleware platform 
existing implementations heavy fit devices ubiquitous computing scenarios 
problem cases middleware architecture built monolithic approach imposing large memory requirements 
article describe reflective middleware architecture component technology allows achieving tiny implementations example client side corba orb palmos kb described section 
regarding configuration options existing implementations normally allow modifying concurrency policies marshaling strategies concerns 
matter reconfiguring policies associated pre established categories 
cases important modify internal architecture entire middleware engine 
meta interface exported reflective middleware allow choosing certain pre defined category implementations allow adding removing category types reorganizing internal architecture middleware engine 
property allows reconfiguration middleware point view required functionality making possible remove functionality longer needed add new functionality required 
third problem identified existing reflective middleware implementations assume single middleware platform corba com java rmi 
practical ubiquitous computing scenarios applications may different middleware platforms different systems 
reflective middleware infrastructure able reconfigure internal engine interoperate different middleware platforms 
better understand properties requirements mentioned consider simple example scenario 
user carrying handheld device enters room contains device control lights device control background music 
devices connected wireless network 
user utilize handheld device control lights turning setting intensity level current song volume level 
assume reflective middleware platform implements properties mentioned customizable size flexible configuration options middleware platform independence 
light music controllers run single instance object export functionality require server side functionality 
light controller uses corba music controller uses soap 
point information configure middleware platform devices important decide configure statically dynamically 
properties scenario requirements controller devices change located environment access pattern defined changes expected type network change 
best solution point view simplicity code size consists statically configuring middleware platform installing device 
previous requirements optimal configuration light controller corba server side minimal singlethreaded object adapter simply allows registration object time implement policy 
light controller middleware platform statically configured export soap server side functionality 
hand handheld device requires client side functionality receive request devices 
handheld device needs configuration allows interact corba object soap object 
previous devices statically configuring middleware infrastructure handheld device appropriate 
reason device highly mobile possible know priori requirements 
middleware platform running device provide tools support dynamic reconfiguration 
device enters room know controllers discovery mechanism required 
mechanism provide information controllers exported interfaces properties middleware platforms 
properties controllers middleware reconfigure middleware handheld device allowing interoperability 
reconfiguration applications running handheld device description controllers interfaces dynamically create requests 
example considered handheld middleware dynamically reconfigured include client side dynamic method invocation mechanisms corba soap 
observed example providing middleware reconfiguration tools key requirement 
additional software infrastructure associated room required discover existing devices services learn properties reconfigure changes detected 
describe infrastructure section 
example section shows reflective middleware platform customized ubiquitous computing offers tools effectively integrate heterogeneous devices cope highly dynamic behavior scenarios adapt size architecture required functionality 
universally interoperable core universally interoperable core uic reflective middleware infrastructure customizable ubiquitous computing scenarios addresses problems existing middleware platforms 
uic collection components designed follow principles introduced previous sections 
provides skeleton components 
concrete dynamically loadable components specialize components implement properties particular middleware platforms devices networks 
uic supports handheld devices permits customization skeleton statically dynamically heterogeneous devices environments 
possible configurations range minimal functionality versions minimal memory resource requirements fully functional versions 
approach differs existing solutions port existing desktop middleware platforms handheld devices 
key principles drive design uic simplicity need get 
simplicity principle requires clear easy understand decomposition uic modules 
modular design provides separation concerns encapsulates mechanisms required specific task different components 
modularity minimizes unwanted dependencies allowing easy customization 
second principle requires required functionality instance uic 
implies uic able adapt requirements device application 
existing middleware platforms contain default possible functionality application uses fraction 
approach acceptable desktops servers resources concern appropriate devices limited resources 
uic provides default minimum required functionality guarantee interoperability existing middleware platforms 
design uic functionality required easily introduced statically rebuilding uic new functionality dynamically adding new functionality run time 
rule applies functionality longer required removed 
important note customization applies implementation components exported interfaces structure skeleton 
uic defines standard skeleton structure targeted object oriented request brokers corba java rmi dcom prevents application developer changing structure meet requirements non object oriented rpc platforms rtp streaming 
component design allows customization aspect uic network transport protocols connection establishment marshaling strategies method invocation protocols method dispatching scheduling object generation parsing object registration method dispatching client interface server interface object interface attributes memory management thread strategies 
personalities uic entity specialized meet requirements particular application 
specialization defines behavior core determines type entities able specialization corba personality corba server uic core specialization personality specialization corba personality single personality single personality server 
personalities interact corba servers java rmi servers 
term personality refer particular instance uic obtained specialization 
personalities classified clientside server side depending functionality provide 
client side personality provides functionality send requests receive replies server side personality capable receiving requests sending replies 
classification mapped directly devices simply need access remote functionality devices need export functionality devices require 
uic classified single personality multi personality 
single personality uic capable interacting single middleware platform multi personality uic interact platform time 
note multi personality uic equivalent having collection single personality 
having single personality implies applications decide uic personality depending object want interact 
hand multi personality applications uic instance method invocation interface regardless type remote object 
case uic responsible automatically choosing right personality 
point view applications multi personality uic requests sent received way regardless type remote object 
configurations uic personalities configured statically dynamically 
static configurations personalities built compile time statically assembling components 
result single component personality dynamically reconfigured possibility replace personality 
main benefit configuration size personality 
dynamic configurations personalities collection dynamically loadable libraries fully reconfigured run time 
main benefit dynamic configuration ability modify architecture personalities dynamically affecting applications 
main drawback dynamic personality size core increases tools loading unloading components required component core independent dynamically loadable library 
hybrid configuration combines benefits static dynamic configurations components change linked components updated modified built independent loadable libraries 
depending number components linked size final personality significantly reduced purely dynamic configuration 
regardless configuration request reply processing speed remains constant 
benefits uic targeted allow integration handheld devices limited resource availability standard distributed object models 
result homogeneous infrastructure development applications services hides device heterogeneity 
existing solutions integrate handheld devices distributed environments proxies transform native method invocation proprietary format handheld devices 
case uic proxies required allows interoperation native middleware platforms 
service developers need provide proxy type device 
key benefit uic design 
component infrastructure facilitates development customized personalities simply re implementing set components 
example application programmer requires specialized marshaling strategy particular connection caching strategy simply re implement components re rest modifications 
standard interfaces defined uic guarantee new component seamlessly interoperate existing ones 
result design need get principle ability produce minimal personalities compatible standard middleware platforms 
size personalities range kb client side corba personality running palm os device kb client server corba personality running windows ce device 
benefit possible predict size personality trigger adaptations configure internal personality parameters size parameters 
upgrading personalities statically dynamically major benefit uic 
handheld devices involved highly dynamic environments 
ability modify personality implies possibility adapting different environments able access services information 
benefit design uic ability server objects different personalities modifying implementation server objects 
example handheld device hosting server application configured multi personality corba soap uic export server application corba soap clients 
uic core uic core specialization uic provides tools reflection 
tools allow internal architecture core allow introducing changes core 
case dynamictao section reflection applied dependencies components compose core component configurator pattern 
changes dependencies translated changes behavior core 
illustrates architecture core clearly divided parts core configuration dynamic configurator tools dynamic reconfiguration 
core configuration collection uic components define behavior core 
dynamic configurator implements reflective mechanisms stores information dependencies components 
shown dynamic configurator implemented servant object runs top current core configuration 
approach introduces main benefits allows dynamically modifying reflective mechanisms different instances dynamic configurator possible register dynamic configurator servant personality time allowing different types clients corba soap reconfigure core 
dynamic configurator servant object core configuration uic component 
uic core illustrates corba idl interface dynamic configurator 
interface typedef sequence string typedef sequence octet string short string string params void string name void void void string string string string string string void string void string 
dynamic configurator idl interface returns list components compose core configuration 
operation returns list hooks specified component components attached 
methods load components memory delete memory 
methods hook manipulation returns name component hooked specified hook 
store delete components dynamically loadable libraries device persistent storage 
performance section presents size different personalities performance personalities client server corba personality 
existing personalities fully interoperable existing middleware implementations 
corba personalities example allow sending requests corba compliant objects corba compliant objects send requests objects implemented top server side uic corba personality 
possible register uic corba objects existing corba naming services traders event services 
table contains sizes uic personalities built different platforms 
uic hybrid provide functionality described fully dynamic uic see previous section 
allows manipulating personalities standalone components 
possible add remove personalities dynamically possible reconfigure individual personalities 
possible register servant object implementation different personalities simultaneously 
size personality includes associated dynamic configurator 
customized tcp protocol implementation personalities implemented components installed 
corba static full client server standalone implementations 
personalities follow need get principle small sizes result eliminating non required functionality 
corba personalities described article export customized dynamic method invocation mechanism implement subset data types simple types structs sequences detect exception conditions raised server parse exception 
configuration motivated building applications involving handheld devices functionality required cases 
design uic possible introduce new functionality demand affecting execution existing applications 
personality sh windows palmos uic kb kb uic corba dynamic server kb kb uic dynamic server kb kb uic corba static client kb kb kb uic corba static server kb kb uic corba static full client server kb kb table 
sizes configurations uic table presents performance numbers disprove commonly held notions 
flexibility provided reflective middleware necessarily translated slower execution times 
second corba reputation slow infrastructure results clearly indicate corba efficient 
table contains performance numbers terms number requests second 
test involves corba client corba server object uic corba static full personality 
server implements method called receives long integer returns cube 
client repeatedly invokes operation customized dynamic invocation interface implemented corba personality 
client produces statistics average total round trip time remote method invocation order provide upper bound remote method invocation simple program corba client sends byte packet size packet sent corba test server tcp ip socket server reads packet process replies byte packet size packet sent corba test read client 
simple program additional computational overhead 
client server processes packets gives maximum number requests sent header sizes corba personality 
corba personality incurs number overheads network time 
create request header marshal client parameters parse header server side parameters find object call method marshal result parameters create reply header parse reply header result parameters 
table presents scenarios divided upper bound corba test case scenario uic corba server object running windows pentium ii mhz mb ram uic corba client object running windows ce jornada handheld pc sh bit processor running mhz mb ram 
second scenario devices uic corba client object runs windows device server jornada 
third scenario consists jornada handhelds hosting uic corba client hosting uic corba server 
network scenarios wireless network maximum theoretical speed mbps 
users involved experiment share wireless network results lower bound uic performance 
personalities tests optimized 
uic corba implementation introduce major overhead times clearly bounded network delay times 
average number requests second average requests second upper bound jornada pentium ii mhz corba jornada pentium ii mhz upper bound pentium ii mhz jornada corba pentium ii mhz jornada upper bound jornada jornada corba jornada jornada table 
requests second uic client server static corba personality customized dynamic invocation interface 
comparison ran test desktop computers running windows intel pentium iii processor mhz mb ram 
test ran client desktops server 
scenario network mb ethernet shared users involved experiment 
results obtained depicted table show additional test consists requests repeated times 
final result average result tests value turn average invocations 
socket connection opened request reused 
overhead corba test due rpc related functionality non existing functionality upperbound test 
average number requests second upper bound pentium iii mhz pentium iii mhz corba pentium iii mhz pentium iii mhz table 
requests second uic static client server corba personality customized dynamic invocation interface 

active spaces reflective middleware major factor enabling interoperability heterogeneous devices ubiquitous computing 
addition mechanisms supporting seamless communication described generation computing systems demands software infrastructure self configurable 
infrastructure able decide parts system adapted adaptation triggered adaptation performed 
define active space interactive programmable system composed physical devices digital services associated physical space uniformly coordinated software infrastructure populated dynamic group mobile users 
inherent complexity associated active spaces requires software infrastructure capable coordinating elements environment 
analogous functionality exported traditional operating system responsible managing collection hardware resources single computer 
needed operating system active spaces 
group university illinois developing gaia operating system active spaces 
component operating system built reflective middleware substrate 
gaia divided main blocks unified object bus gaia services gaia applications model gaia active space 
unified object bus dynamic platform independent component execution environment 
provides tools locate distribute load unload components dynamically responsible seamlessly integrating different middleware infrastructures 
services applications built top unified object bus 
gaia toolkit assist development ubiquitous computing applications 
active system capable coordinating users services devices active spaces 
achieved collection services responsible managing different aspects active space functionality discovery security location user accounts data code distribution adaptation state 
distributed objects gaia exports physical spaces heterogeneous computing infrastructure homogenous addressed manipulated 
possible develop applications run context active space context particular device 
support concept gaia defines application model inspired model view controller design pattern 
example consider active hospital 
active surgery room runs instance application uses patient model patient vital signs monitor surgeon views surgeon controller special movements hands indicate certain commands 
gaia application model automatically instantiates adapters model monitor model configured views 
result monitor displays different charts representing patient vital signs tells doctor values vital signs 
gaia provides programmatic interface manipulate active space 
idea active space object defined attributes operations 
abstraction allows manipulating space homogeneous execution environment collection heterogeneous entities 
underlying reflective middleware infrastructure provides solid base dynamically managing policies mechanisms active space 
information current status gaia choices cs uiuc edu gaia 

related research middleware identified limitations existing corba implementations led orb extensions dealing specific aspects real time group communication fault tolerance 
goal hand provide generic skeleton different kinds customizations performed reflection exist implementations small footprint corba orbs orb www com corba default asp targetted telecommunication market example optical switches general purpose orb intended appliances 
provides tools dynamic reconfiguration 
distributed multimedia research group lancaster university proposed reflective architecture generation middleware 
developed prototype python interpreted language programmer able inspect change implementation runtime 
level reflection higher dynamictao python system possible add remove methods objects classes dynamically change class object runtime 
research emphasized dynamic configurability defined open binding model allows multiple reflective levels 
contrast research concentrates simpler reflective model focusing high performance customization devices limited resources 
model reflective mechanisms included normal flow control invoked needed 
comera com extensible remote architecture provides framework microsoft com allows users modify aspects communication middleware run time 
relies custom interface exported com architecture design allows user specified components 
comera system developers customize middleware application requirements 

ubiquitous computing reality heterogeneous computing devices increasingly pervasive society 
user applications adapt different environments 
highly dynamic environments mobile computers mobile software mobile users require new paradigm software development deployment 
middleware systems ready adapt change 
ideas architecture introduced dynamictao uic provide solid base supporting safe dynamic configuration high performance distributed systems 
believe reflective approach middleware design provides agility modern applications require 
far having complete solution aspect problem preliminary results indicate moving right direction 
complete source code dynamictao obtained web site choices cs uiuc edu dynamictao 
information uic please visit www core com 

omg corba specification 
framingham ma 

nat brown distributed component object model protocol dcom 


maffeis adding group communication fault tolerance corba 
proceedings usenix conference object oriented technologies 


gordon blair philippe robin michael papathomas 
architecture generation middleware 
proceedings middleware 

lake district england 

wang comera com extensible remoting architecture 
proceedings th usenix conference object oriented technologies systems coots 


campbell reflective orbs support robust time critical distribution 
springer verlag 

roman kon campbell design implementation runtime reflection communication middleware dynamictao case proc 
icdcs workshop middleware 
austin tx 

fabio kon gordon blair roy campbell 
ifip acm middleware workshop reflective middleware 

new york 

gregor kiczales daniel bobrow 
art metaobject protocol 
mit press 

kon monitoring security dynamic configuration dynamictao reflective orb 
proceedings ifip acm international conference distributed systems platforms open distributed processing middleware 

new york springer verlag 

douglas schmidt applying patterns develop extensible orb middleware 
ieee communications magazine special issue design patterns 


gamma johnson vlissides design patterns elements object oriented software 
addison wesley 

kon campbell dependence management component distributed systems 
ieee concurrency 


weiser computer st century scientific american 



understanding soap authoritative solution 
sams 

roman campbell gaia operating system enable active spaces 
proceedings th sigops european workshop 
denmark 

kon reflective component operating system rapidly changing environments ecoop workshop reflective object oriented programming systems 
brussels belgium 

krasner pope cookbook model view controller user interface paradigm smalltalk 
object oriented programming 

timothy harrison douglas schmidt 
design performance real time corba object event service 
proceedings oopsla 
acm 

maffeis constructing reliable distributed communication systems corba 
ieee communications magazine 


maes meta level architectures reflection 
north holland 

gordon blair fabio costa hector duran 
design reflective middleware platforms 
ifip acm middleware workshop reflective middleware 


