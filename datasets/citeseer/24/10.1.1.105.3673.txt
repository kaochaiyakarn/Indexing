chord scalable peer peer lookup service internet applications ion stoica robert morris david karger frans kaashoek hari balakrishnan mit laboratory computer science chord lcs mit edu pdos lcs mit edu chord fundamental problem confronts peer peer applications efficiently locate node stores particular data item 
presents chord distributed lookup protocol addresses problem 
chord provides support just operation key maps key node 
data location easily implemented top chord associating key data item storing key data item pair node key maps 
chord adapts efficiently nodes join leave system answer queries system continuously changing 
results theoretical analysis simulations experiments show chord scalable communication cost state maintained node scaling logarithmically number chord nodes 

peer peer systems applications distributed systems centralized control hierarchical organization software running node equivalent functionality 
review features peer peer applications yields long list redundant storage permanence selection nearby servers anonymity search authentication hierarchical naming 
despite rich set features core operation peer peer systems efficient location data items 
contribution scalable protocol lookup dynamic peer peer system frequent node arrivals departures 
chord protocol supports just operation key maps key node 
depending application chord node responsible storing value associated key 
chord uses variant consistent hashing assign keys chord nodes :10.1.1.147.1879:10.1.1.147.1879
consistent hashing tends balance load node receives roughly number keys university california berkeley 
cs berkeley edu authors reverse alphabetical order 
research sponsored defense advanced research projects agency darpa space naval warfare systems center san diego contract 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigcomm august san diego california usa 
copyright acm 
involves relatively little movement keys nodes join leave system 
previous consistent hashing assumed nodes aware nodes system making impractical scale large number nodes 
contrast chord node needs routing information nodes 
routing table distributed node resolves hash function communicating nodes 
steady state node system node maintains information nodes resolves lookups messages nodes 
chord maintains routing information nodes join leave system high probability event results messages 
features distinguish chord peer topeer lookup protocols simplicity provable correctness provable performance 
chord simple routing key sequence nodes destination 
chord node requires information nodes efficient routing performance degrades gracefully information date 
important practice nodes join leave arbitrarily consistency state may hard maintain 
piece information node need correct order chord guarantee correct slow routing queries chord simple algorithm maintaining information dynamic environment 
rest structured follows 
section compares chord related 
section presents system model motivates chord protocol 
section presents base chord protocol proves properties section presents extensions handle concurrent joins failures 
section demonstrates claims chord performance simulation experiments deployed prototype 
outline items section summarize contributions section 
related chord maps keys nodes traditional name location services provide direct mapping keys values 
value address document arbitrary data item 
chord easily implement functionality storing key value pair node key maps 
reason comparison clearer rest section assumes chord service maps keys values 
dns provides host name ip address mapping :10.1.1.156.7859
chord provide service name representing key associated ip address representing value 
chord requires special servers dns relies set special root servers 
dns names structured reflect administrative boundaries chord imposes naming structure 
dns specialized task finding named hosts services chord find data objects tied particular machines 
freenet peer peer storage system chord decentralized symmetric automatically adapts hosts leave join :10.1.1.10.4919
freenet assign responsibility documents specific servers lookups take form searches cached copies 
allows freenet provide degree anonymity prevents guaranteeing retrieval existing documents providing low bounds retrieval costs 
chord provide anonymity lookup operation runs predictable time results success definitive failure 
system uses consistent hashing algorithm mapping documents nodes freenet style query routing 
result shares weaknesses freenet 
archival intermemory uses line computed tree map logical addresses machines store data 
globe system wide area location service map object identifiers locations moving objects 
globe arranges internet hierarchy geographical topological administrative domains effectively constructing static world wide search tree dns 
information object stored particular leaf domain pointer caches provide search short cuts 
globe system handles high load logical root partitioning objects multiple physical root servers hash techniques 
chord performs hash function achieve scalability involving hierarchy chord exploit network locality globe 
distributed data location protocol developed plaxton variant oceanstore closest algorithm chord protocol :10.1.1.38.1850
provides stronger guarantees chord chord guarantees queries logarithmic number hops keys balanced plaxton protocol ensures subject assumptions network topology queries travel network distance node key stored 
advantage chord substantially complicated handles concurrent node joins failures 
chord protocol similar pastry location algorithm past 
pastry prefix routing protocol differs details chord 
uses dimensional cartesian coordinate space fixed implement distributed hash table maps keys values :10.1.1.140.3129
node maintains state lookup cost contrast chord state maintained node depend network size lookup cost increases faster 
lookup times storage needs match chord designed vary varies match occur right corresponding fixed 
requires additional maintenance protocol periodically remap identifier space nodes 
chord advantage correctness robust face partially incorrect routing information 
chord routing procedure may thought onedimensional analogue grid location system 
grid relies real world geographic location information route queries chord maps nodes artificial dimensional space routing carried algorithm similar grid chord lookup service implement variety systems discussed section 
particular help avoid single points failure control systems napster possess lack scalability systems gnutella display widespread broadcasts 

system model chord simplifies design peer peer systems applications addressing difficult problems load balance chord acts distributed hash function spreading keys evenly nodes provides degree natural load balance 
decentralization chord fully distributed node important 
improves robustness chord appropriate loosely organized peer peer applications 
scalability cost chord lookup grows log number nodes large systems feasible 
parameter tuning required achieve scaling 
availability chord automatically adjusts internal tables reflect newly joined nodes node failures ensuring barring major failures underlying network node responsible key 
true system continuous state change 
flexible naming chord places constraints structure keys looks chord key space flat 
gives applications large amount flexibility map names chord keys 
chord software takes form library linked client server applications 
application interacts chord main ways 
chord provides lookup key algorithm yields ip address node responsible key 
second chord software node notifies application changes set keys node responsible 
allows application software example move corresponding values new homes new node joins 
application chord responsible providing desired authentication caching replication user friendly naming data 
chord flat key space eases implementation features 
example application authenticate data storing chord key derived cryptographic hash data 
similarly application replicate data storing distinct chord keys derived data applicationlevel identifier 
examples applications chord provide foundation cooperative mirroring outlined proposal 
imagine set software developers wishes publish distribution 
demand distribution vary dramatically popular just new release relatively unpopular releases 
efficient approach developers cooperatively mirror distributions 
ideally mirroring system balance load servers replicate cache data ensure authenticity 
system fully decentralized interests reliability natural central administration 
time shared storage nodes intermittent connectivity 
person wishes data available file system block store block store block store chord chord chord client server server structure example chord distributed storage system 
machine occasionally available offer store data return having data stored 
data name serve key identify live chord node responsible storing data item time 
issues arise cooperative mirroring application focus availability load balance 
distributed indexes support gnutella napster keyword search 
key application derived desired keywords values lists machines offering documents keywords 
large scale combinatorial search code breaking 
case keys candidate solutions problem cryptographic keys chord maps keys machines responsible testing solutions 
shows possible layered software structure cooperative mirror system 
highest layer provide interface users including user friendly naming authentication 
file system layer implement named directories files mapping operations lower level block operations 
layer block storage layer implement block operations 
take care storage caching replication blocks 
block storage layer chord identify node responsible storing block talk block storage server node read write block 

base chord protocol chord protocol specifies find locations keys new nodes join system recover failure planned departure existing nodes 
section describes simplified version protocol handle concurrent joins failures 
section describes enhancements base protocol handle concurrent joins failures 
overview heart chord provides fast distributed computation hash function mapping keys nodes responsible 
uses consistent hashing properties :10.1.1.147.1879:10.1.1.147.1879:10.1.1.147.1879
high probability hash function balances load nodes receive roughly number keys 
high probability node joins leaves network fraction keys moved different location clearly minimum necessary maintain balanced load 
successor successor successor identifier circle consisting nodes 
example key located node key node key node 
chord improves scalability consistent hashing avoiding requirement node know node 
chord node needs small amount routing information nodes 
information distributed node resolves hash function communicating nodes 
node network node maintains information nodes lookup requires messages 
chord update routing information node joins leaves network join leave requires messages 
consistent hashing consistent hash function assigns node key bit identifier base hash function sha 
node identifier chosen hashing node ip address key identifier produced hashing key 
term key refer original key image hash function meaning clear context 
similarly term node refer node identifier hash function 
identifier length large probability nodes keys hashing identifier negligible 
consistent hashing assigns keys nodes follows 
identifiers ordered identifier circle modulo key assigned node identifier equal follows identifier identifier space 
node called successor node key denoted successor identifiers represented circle numbers node clockwise 
shows identifier circle circle nodes 
successor identifier node key located node 
similarly key located node key node 
consistent hashing designed nodes enter leave network minimal disruption 
maintain consistent hashing mapping node joins network certain keys previously assigned successor assigned 
node leaves network assigned keys reassigned successor 
changes assignment keys nodes need occur 
example node join identifier capture key identifier node identifier 
results proven papers introduced consistent hashing theorem :10.1.1.147.1879:10.1.1.147.1879
set nodes keys high probability 
node responsible keys 
node joins leaves network responsibility keys changes hands joining leaving node 
consistent hashing implemented described theorem proves bound consistent hashing shows reduced arbitrarily small constant having node run virtual nodes identifier 
phrase high probability bears discussion 
simple interpretation nodes keys randomly chosen plausible non adversarial model world 
probability distribution random choices keys nodes says random choice produce unbalanced distribution 
worry adversary intentionally chooses keys hash identifier destroying load balancing property 
consistent hashing uses universal hash functions provide certain guarantees case nonrandom keys 
universal hash function chose standard sha function base hash function 
protocol deterministic claims high probability longer sense 
producing set keys collide sha seen sense inverting decrypting sha function 
believed hard 
stating theorems hold high probability claim hold standard hardness assumptions simplicity primarily presentation dispense virtual nodes 
case load node may exceed average factor high probability case standard hardness assumptions 
reason avoid virtual nodes number needed determined number nodes system may difficult determine 
course may choose priori upper bound number nodes system example postulate chord server ipv address 
case running virtual nodes physical node provide load balance 
scalable key location small amount routing information suffices implement consistent hashing distributed environment 
node need aware successor node circle 
queries identifier passed circle successor pointers encounter node succeeds identifier node query maps 
portion chord protocol maintains successor pointers ensuring lookups resolved correctly 
resolution scheme inefficient may require traversing nodes find appropriate mapping 
accelerate process chord maintains additional routing information 
additional information essential correctness achieved long successor information maintained correctly 
number bits key node identifiers 
node maintains routing table entries called finger table 
entry table node contains identity node succeeds identifier circle arithmetic modulo 
call node finger node denote finger node see table 
finger table entry includes chord identifier ip address port number relevant node 
note finger immediate successor circle convenience refer successor finger 
example shown finger table node notation definition finger mod interval finger start finger start node finger start successor node identifier circle finger node predecessor previous node identifier circle table definition variables node bit identifiers 
points successor nodes identifiers mod mod mod respectively 
successor identifier node node follows successor identifier trivially node successor node scheme important characteristics 
node stores information small number nodes knows nodes closely identifier circle nodes farther away 
second node finger table generally contain information determine successor arbitrary key 
example node know successor successor node appear node finger table 
happens node know successor key 
find node id closer node know identifier circle region 
searches finger table node id immediately precedes asks node knows id closest 
repeating process learns nodes ids closer closer 
pseudocode implements search process shown 
notation foo stands function foo invoked executed node 
remote calls variable preceded remote node identifier local variable procedure calls omit local node 
foo denotes remote procedure call node bar parentheses rpc lookup variable bar node 
find successor works finding immediate predecessor node desired identifier successor node successor identifier 
implement find predecessor explicitly implement join operation section 
node executes find predecessor contacts series nodes moving forward chord circle 
node contacts node falls successor find predecessor done returns node asks node knows closely precedes 
algorithm progress 
example consider chord ring 
suppose node wants find successor identifier belongs circular interval belongs finger interval node checks third entry finger table precedes node ask node find successor turn node infer finger table successor node return node node 
finger pointers repeatedly doubling distances circle cause iteration loop find predecessor halve distance target identifier 
intuition follows theorem finger interval finger start finger start finger interval finger start finger start finger start finger interval finger start finger start finger start finger table keys start int 
succ 
finger table keys start int 
succ 
finger table keys start int 
succ 
finger intervals associated node 
finger tables key locations net nodes keys 
theorem 
high probability standard hardness assumptions number nodes contacted find successor node network proof 
suppose node wishes resolve query successor 
node immediately precedes 
analyze number query steps reach 
recall forwards query closest predecessor finger table 
suppose node finger interval node 
interval empty node finger node interval 
distance number identifiers finger interval means distance means closer equivalently distance half distance 
distance node handling query predecessor halves step initially steps distance meaning arrived 
fact discussed assume node key identifiers random 
case number necessary high probability 
distance current query node key reduced 
expected number node identifiers landing range size high probability 
remaining steps advance node time cross entire remaining interval reach key steps 
section reporting experimental results section observe justify average lookup time 
node joins dynamic network nodes join leave time 
main challenge implementing operations preserving ability locate key network 
achieve goal chord needs preserve invariants 
node successor correctly maintained 

key node responsible 
order lookups fast desirable finger tables correct 
section shows maintain invariants single node joins 
defer discussion multiple nodes joining simultaneously section discusses handle ask node find successor find predecessor return successor ask node find predecessor successor closest preceding finger return return closest finger preceding downto finger node return finger node return pseudocode find successor node identifier 
remote procedure calls variable lookups preceded remote node 
node failure 
describing join operation summarize performance proof theorem companion technical report theorem :10.1.1.105.3673:10.1.1.105.3673:10.1.1.105.3673
high probability node joining leaving node chord network messages re establish chord routing invariants finger tables 
simplify join leave mechanisms node chord maintains predecessor pointer 
node predecessor pointer contains chord identifier ip address immediate predecessor node walk counterclockwise identifier circle 
preserve invariants stated chord perform tasks node joins network 
initialize predecessor fingers node 

update fingers predecessors existing nodes reflect addition 

notify higher layer software transfer state values associated keys node responsible 
assume new node learns identity existing chord node external mechanism 
node uses finger table keys start int 
succ 
finger table keys start int 
succ 
finger table keys start int 
succ 
finger table keys start int 
succ 
finger table keys start int 
succ 
finger table keys start int 
succ 
finger table keys start int 
succ 
finger tables key locations node joins 
finger tables key locations node leaves 
changed entries shown black unchanged gray 
initialize state add existing chord network follows 
initializing fingers predecessor node learns predecessor fingers asking look init finger table pseudocode 
naively performing find successor finger entries give runtime reduce checks finger correct finger 
hap pens finger interval contain node finger node finger start 
shown change reduces expected high probability number finger entries looked reduces time practical optimization newly joined node ask immediate neighbor copy complete finger table predecessor 
contents tables hints help find correct values tables tables similar neighbors 
shown reduce time fill finger table updating fingers existing nodes node need entered finger tables existing nodes 
example node third finger nodes second finger node 
shows pseudocode update finger table function updates existing finger tables 
node finger node precedes finger node succeeds 
node meet conditions immediate predecessor algorithm starts finger node continues walk counter clock wise direction identifier circle encounters node finger precedes 
show technical report number nodes need updated node joins network high probability :10.1.1.105.3673:10.1.1.105.3673:10.1.1.105.3673
finding updating nodes takes time 
sophisticated scheme reduce time expect implementations algorithm section 
transferring keys operation performed node joins network move responsibility keys node successor 
exactly entails depends higher layer software chord typically involve moving data associated key new node 
node successor keys previously responsibility node immediately follow define successor finger node node joins network arbitrary node network init finger table update move keys successor node network finger node predecessor initialize finger table local node arbitrary node network finger node find successor predecessor successor predecessor successor predecessor finger start finger node finger node finger node finger node find successor finger start update nodes finger tables refer find node finger find predecessor update finger table finger update finger table finger node finger node predecessor get node preceding update finger table pseudocode node join operation 
ing needs contact node transfer responsibility relevant keys 

concurrent operations failures practice chord needs deal nodes joining system concurrently nodes fail leave voluntarily 
section describes modifications basic chord algorithms described section handle situations 
stabilization join algorithm section aggressively maintains finger tables nodes network evolves 
invariant difficult maintain face concurrent joins large network separate correctness performance goals 
basic stabilization protocol keep nodes successor pointers date sufficient guarantee correctness lookups 
successor pointers verify correct finger table entries allows lookups fast correct 
joining nodes affected region chord ring lookup occurs stabilization finished exhibit behaviors 
common case finger table entries involved lookup reasonably current lookup finds correct successor steps 
second case successor pointers correct fingers inaccurate 
yields correct lookups may slower 
final case nodes affected region incorrect successor pointers keys may migrated newly joined nodes lookup may fail 
higher layer software chord notice desired data option retrying lookup pause 
pause short stabilization fixes successor pointers quickly 
stabilization scheme guarantees add nodes chord ring way preserves reachability existing nodes face concurrent joins lost reordered messages 
stabilization won correct chord system split multiple disjoint cycles single cycle loops multiple times identifier space 
pathological cases produced sequence ordinary node joins 
unclear produced network partitions recoveries intermittent failures 
produced cases detected repaired periodic sampling ring topology 
shows pseudo code joins stabilization code replaces handle concurrent joins 
node starts calls join known chord node 
function asks find immediate successor 
rest network aware 
node runs stabilize periodically newly joined nodes noticed network 
node runs stabilize asks successor successor predecessor decides successor 
case node joined system 
stabilize notifies node successor existence giving successor chance change predecessor 
successor knows closer predecessor 
simple example suppose node joins system id lies nodes 
acquire successor 
node notified acquire predecessor 
runs stabilize ask predecessor acquire successor 
notify acquire predecessor 
point predecessor successor pointers correct 
find successor periodically verify immediate successor tell successor stabilize notify thinks predecessor 
nil periodically refresh finger table entries 
random index finger finger find successor finger start pseudocode stabilization 
soon successor pointers correct calls find predecessor find successor 
newly joined nodes may cause find predecessor initially loop lookup algorithm follow successor finger pointers newly joined nodes correct predecessor reached 
eventually fix fingers adjust finger table entries eliminating need linear scans 
theorems proved technical report show problems caused concurrent joins transient :10.1.1.105.3673:10.1.1.105.3673:10.1.1.105.3673
theorems assume nodes trying communicate eventually succeed 
theorem 
node successfully resolve query able 
theorem 
time join successor pointers correct 
proofs theorems rely invariant termination argument 
invariant states node reach node successor pointers 
argue termination consider case nodes think successor 
case attempt notify eventually choose closer closer node predecessor 
point farther contacting learn better successor 
follows node progresses better better successor time 
progress eventually halt state node considered successor exactly node defines cycle set invariant ensures 
discussed adjustment fingers nodes join turns joins don substantially damage performance fingers 
node finger interval fingers joins 
distance halving argument essentially unchanged showing hops suffice reach node close query target 
new joins influence lookup getting old predecessor successor target query 
new nodes may need scanned linearly fingers accurate 
tremendous number nodes joins system number nodes old nodes small impact lookup negligible 
formally state theorem 
take stable network nodes set nodes joins network finger pointers correct successor pointers lookups take time high probability 
generally long time takes adjust fingers time takes network double size lookups continue take hops 
failures replication node fails nodes finger tables include find successor 
addition failure allowed disrupt queries progress system re stabilizing 
key step failure recovery maintaining correct successor pointers worst case find predecessor progress successors 
help achieve chord node maintains successor list nearest successors chord ring 
ordinary operation modified version stabilize routine maintains successor list 
node notices successor failed replaces live entry successor list 
point direct ordinary lookups keys failed node successor new successor 
time passes stabilize correct finger table entries successor list entries pointing failed node 
node failure stabilization completed nodes may attempt send requests failed node part find successor lookup 
ideally lookups able proceed timeout path despite failure 
cases possible 
needed list alternate nodes easily finger table entries preceding failed node 
failed node low finger table index nodes successor list available alternates 
technical report proves theorems show successor list allows lookups succeed efficient stabilization theorem :10.1.1.105.3673:10.1.1.105.3673
successor list length network initially stable node fails probability high probability find successor returns closest living successor query key 
theorem 
successor list length network initially stable node fails probability expected time execute find successor failed network intuition proofs straightforward node successors fail probability high probability node aware able forward messages closest living successor 
successor list mechanism helps higher layer software replicate data 
typical application chord store replicas data associated key nodes succeeding key 
fact chord node keeps track successors means inform higher layer software successors come go software propagate new replicas 
number keys node st th percentiles number virtual nodes st th percentiles number keys node function virtual nodes mapped real node 
network real nodes stores keys 

simulation experimental results section evaluate chord protocol simulation 
simulator uses lookup algorithm slightly older version stabilization algorithms described section 
report preliminary experimental results operational chord system running internet hosts 
protocol simulator chord protocol implemented iterative recursive style 
iterative style node resolving lookup initiates communication asks series nodes information finger tables time moving closer chord ring desired successor 
recursive style intermediate node forwards request node reaches successor 
simulator implements protocols iterative style 
load balance consider ability consistent hashing allocate keys nodes evenly 
network nodes keys distribution keys nodes tight 
consider network consisting nodes vary total number keys increments value repeat experiment times 
plots mean st th percentiles number keys node 
number keys node exhibits large variations increase linearly number keys 
example cases nodes store keys 
clarify plots probability density function pdf number keys node keys stored network 
maximum number nodes stored node case mean value 
comparison th percentile mean value 
reason variations node identifiers uniformly cover entire identifier space 
divide identifier space equal sized bins number nodes hope see node bin 
fact probability particular bin contain node large values approaches 
discussed earlier consistent hashing solves problem associating keys virtual nodes mapping multiple virtual nodes unrelated identifiers real node 
intuitively provide uniform coverage identifier space 
example allocate randomly chosen virtual nodes real node high probability number keys node st th percentiles total number keys mean st th percentiles number keys stored node density function pdf number keys node 
total number keys bins contain nodes 
note affect worst case query path length verify hypothesis perform experiment allocate virtual nodes real node 
case keys associated virtual nodes real nodes 
consider network real nodes keys 
shows st th percentiles respectively 
expected th percentile decreases st percentile increases number virtual nodes 
particular th percentile decreases mean value st percentile increases mean value 
adding virtual nodes indirection layer significantly improve load balance 
tradeoff routing table space usage increase actual node needs times space store finger tables virtual nodes 
believe increase easily accommodated prac tice 
example assuming network nodes assuming node maintain table entries 
path length performance routing protocol depends heavily length path arbitrary nodes network 
context chord define path length number nodes traversed lookup operation 
theorem high probability length path resolve query total number nodes network 
understand chord routing performance practice simulated network nodes storing keys 
varied conducted separate experiment value 
node experiment picked random set keys query system measured path length required resolve query 
plots mean st th percentiles path length function 
expected mean path length increases logarithmically number nodes st th percentiles 
plots pdf path length network nodes 
shows path length 
reason follows 
consider random node random query 
distance identifier space considered binary representation 
significant say bit pdf number keys node failed lookups fraction total node network 
probability confidence interval failed nodes fraction total fraction lookups fail function fraction nodes fail 
distance corrected node finger 
significant bit distance needs corrected finger finger followed move bit 
general number fingers need follow number ones binary representation distance node query 
distance random expect half bits ones 
simultaneous node failures experiment evaluate ability chord regain consistency large percentage nodes fail simultaneously 
consider node network stores keys randomly select fraction nodes fail 
failures occur wait network finish stabilizing measure fraction keys looked correctly 
correct lookup key finds node originally responsible key failures corresponds system stores values keys replicate values recover failures 
plots mean lookup failure rate confidence interval function 
lookup failure rate exactly 
just fraction keys expected lost due failure responsible nodes conclude significant lookup failure chord network 
example chord network partitioned equal sized halves path length st th percentiles number nodes pdf path length path length function network size 
pdf path length case node network 
failed lookups fraction total confidence interval node fail join rate second fraction lookups fail function rate time nodes fail join 
failures caused chord state inconsistency included failures due lost keys 
expect half requests fail querier target different partitions half time 
results show suggesting chord robust face multiple simultaneous node failures 
lookups stabilization lookup issued failures stabilization completed may fail reasons 
node responsible key may failed 
second nodes finger tables predecessor pointers may inconsistent due concurrent joins node failures 
section evaluates impact continuous joins failures lookups 
experiment lookup considered succeeded reaches current successor desired key 
slightly optimistic real system periods time real successor key acquired data associated key previous successor 
method allows focus chord ability perform lookups higher layer software ability maintain consistency data 
query failure result inconsistencies chord 
addition simulator retry queries query forwarded node query simply fails 
results section viewed worst case scenario query failures induced state inconsistency 
primary source inconsistencies nodes joining leaving main mechanism resolve inconsistencies stabilize protocol chord performance sensitive frequency node joins leaves versus frequency stabilization protocol invoked 
experiment key lookups generated poisson process rate second 
joins failures modeled poisson process mean arrival rate 
node runs stabilization routines randomized intervals averaging seconds routines simulator updates finger table entries invocation 
network starts nodes 
plots average failure rates confidence intervals 
node failure rate corresponds node joining leaving seconds average 
comparison recall node invokes stabilize protocol seconds 
words graph axis ranges rate failure stabilization steps rate failures stabilization step 
results averaged approximately hours simulated time 
confidence intervals computed independent runs 
results explained roughly follows 
simulation nodes meaning lookup path lengths average 
lookup fails finger path encounters failed node 
nodes fail probability finger path roughly suggest failure rate failures 
graph shows results ball park slightly worse take stabilization completely clear failed node 
experimental results section presents latency measurements obtained prototype implementation chord deployed internet 
chord nodes sites subset ron test bed united states california colorado massachusetts new york north carolina pennsylvania 
chord software runs unix uses bit keys obtained sha cryptographic hash function uses tcp communicate nodes 
chord runs iterative style 
chord nodes part experimental distributed file system section considers chord component system 
shows measured latency chord lookups range numbers nodes 
experiments number nodes larger conducted running multiple independent lookup latency ms th th th percentiles number nodes lookup latency internet prototype function total number nodes 
physical sites runs multiple independent copies chord node software 
copies chord software site 
different running virtual nodes site provide load balance intention measure implementation scales small number deployed nodes 
number nodes shown physical site issues chord lookups randomly chosen keys 
graph plots median th th percentile lookup latency 
median latency ranges ms depending number nodes 
case nodes typical lookup involves way message exchanges chord lookup final message successor node 
typical round trip delays sites milliseconds measured ping 
expected lookup time nodes milliseconds close measured median 
low th percentile latencies caused lookups keys close id space querying node query hops remain local physical site 
high th percentiles caused lookups hops follow high delay paths 
lesson lookup latency grows slowly total number nodes confirming simulation results demonstrate chord scalability 

experience prototype mentioned section improve chord design areas 
chord currently specific mechanism heal partitioned rings rings appear locally consistent stabilization procedure 
way check global consistency node periodically ask nodes chord lookup lookup yield node may partition 
detect partitions nodes know 
way obtain knowledge node know small set initial nodes 
approach nodes maintain long term memory random set nodes encountered past partition forms random sets partition include nodes partition 
malicious buggy set chord participants incorrect view chord ring 
assuming data chord locate cryptographically authenticated threat availability data authenticity 
approach detect partitions help victims realize seeing globally consistent view chord ring 
attacker target particular data item inserting node chord ring id immediately item key having node return errors asked retrieve data 
requiring checking nodes ids derived sha hash ip addresses attack harder 
messages lookup may applications chord especially message sent random internet host 
placing fingers distances powers chord easily changed place fingers distances integer powers 
scheme single routing hop decrease distance query original distance meaning hops suffice 
number fingers needed increase different approach improving lookup latency server selection 
finger table entry point nodes entry interval id ring node measure network delay nodes 
nodes generally equivalent purposes lookup node forward lookups lowest delay 
approach effective recursive chord lookups node measuring delays node forwarding lookup 

distributed peer peer applications need determine node stores data item 
chord protocol solves challenging problem decentralized manner 
offers powerful primitive key determines node responsible storing key value efficiently 
steady state node network node maintains routing information nodes resolves lookups messages nodes 
updates routing information nodes leaving joining require messages 
attractive features chord include simplicity provable correctness provable performance face concurrent node arrivals departures 
continues function correctly albeit degraded performance node information partially correct 
theoretical analysis simulations experimental results confirm chord scales number nodes recovers large numbers simultaneous node failures joins answers lookups correctly recovery 
believe chord valuable component peerto peer large scale distributed applications cooperative file sharing time shared available storage systems distributed indices document service discovery large scale distributed computing platforms 
acknowledgments frank dabek measurements chord prototype described section david andersen setting testbed measurements 

andersen resilient overlay networks 
master thesis department eecs mit may 
nms lcs mit edu projects ron 
bakker van der wijk van steen tanenbaum globe distribution network 
proc 
usenix annual conf 
freenix track san diego ca june pp 

chen goldberg gottlieb yianilos prototype implementation archival intermemory 
proceedings th acm conference digital libraries berkeley ca aug pp 

clarke distributed decentralised information storage retrieval system 
master thesis university edinburgh 
clarke sandberg wiley hong freenet distributed anonymous information storage retrieval system 
proceedings icsi workshop design issues anonymity unobservability berkeley california june 
freenet sourceforge net 
dabek kaashoek karger morris stoica balakrishnan building peer peer systems chord distributed location service 
proceedings th ieee workshop hot topics operating systems hotos viii germany may pp 

dabek kaashoek karger morris stoica wide area cooperative storage cfs 
proceedings th acm symposium operating systems principles sosp appear banff canada oct 
druschel rowstron past persistent anonymous storage peer peer networking environment 
proceedings th ieee workshop hot topics operating systems hotos germany may pp 

fips 
secure hash standard 
department commerce nist national technical information service springfield va apr 
gnutella gnutella wego com 
karger lehman leighton levine lewin panigrahy consistent hashing random trees distributed caching protocols relieving hot spots world wide web :10.1.1.147.1879:10.1.1.147.1879
proceedings th annual acm symposium theory computing el paso tx may pp 

kubiatowicz bindel chen czerwinski eaton geels gummadi rhea weatherspoon weimer wells zhao oceanstore architecture global scale persistent storage 
proceeedings ninth international conference architectural support programming languages operating systems asplos boston ma november pp 

lewin consistent hashing random trees algorithms caching distributed networks 
master thesis department eecs mit 
available mit library thesis mit edu 
li jannotti de couto karger morris scalable location service geographic ad hoc routing 
proceedings th acm international conference mobile computing networking boston massachusetts august pp 

mockapetris dunlap development domain name system :10.1.1.156.7859
proc 
acm sigcomm stanford ca pp 

motwani raghavan randomized algorithms 
cambridge university press new york ny 
napster www napster com 
smart decentralized peer peer sharing 
www com design html 
plaxton rajaraman richa accessing nearby copies replicated objects distributed environment :10.1.1.38.1850
proceedings acm spaa newport rhode island june pp 

ratnasamy francis handley karp shenker scalable content addressable network :10.1.1.140.3129
proc 
acm sigcomm san diego ca august 
stoica morris karger kaashoek balakrishnan chord scalable peer peer lookup service internet applications :10.1.1.105.3673:10.1.1.105.3673
tech 
rep tr mit lcs march 
www pdos lcs mit edu chord papers 
van steen hauck tanenbaum algorithmic design globe wide area location service 
computer journal 
