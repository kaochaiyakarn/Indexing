semantic email theory applications luke mcdowell oren etzioni alon halevy department computer science engineering university washington box seattle wa usa investigates vision semantic web carried realm email 
introduce general notion semantic email email message consists structured query update coupled corresponding explanatory text 
semantic email opens door wide range automated email mediated applications formally guaranteed properties 
particular introduces broad class semantic email processes 
example consider process sending email program committee asking attend pc dinner automatically collecting responses tallying 
define logical decision theoretic models email process modeled set updates data set specify goals certain constraints utilities 
describe set inference problems arise trying satisfy goals analyze computational tractability 
particular show logical model possible automatically infer email responses acceptable set constraints polynomial time decision theoretic model possible compute optimal message handling policy polynomial time 
addition show automatically generate explanations process actions identify cases explanations generated polynomial time 
discuss publicly available implementation semantic email outline research challenges realm 
key words semantic web satisfiability decision theoretic reasoning aggregation see www cs washington edu research semweb email publicly accessible server installation required source code available authors 
corresponding author 
tel fax email addresses cs washington edu luke mcdowell etzioni cs washington edu oren etzioni alon cs washington edu alon halevy 
preprint submitted elsevier science august semantic web envisions portion world wide web www underlying data machine understandable exploited improved querying aggregation interaction 
despite great potential vision numerous efforts growth semantic web lack incentive create content high cost doing 
content owners motivated create structured representations necessary contribute semantic web seeing immediate benefit significant efforts 
fact problem unique semantic web database knowledge base communities long recognized users shy away tools perceived benefits outweighed conceptual difficulty overhead structuring data 
users resort spreadsheets structured files just plain text 
ironically cases resultant lack data management facilities reasoning capabilities ultimately leads users road 
explores problem identifying pain point cost benefit equation associated structuring data changed dramatically 
www rich information space spend significant amounts time spend time email 
exception generic header fields associated message email messages typically semantic features 
majority email remain way argues adding semantic features email offers opportunities improved productivity performing common tasks 
establish theoretical foundations semantic email address practical challenges associated completely implemented system 
illustrate promise semantic email consider examples information dissemination simplest case suppose send talk announcement email 
suitable semantics attached email sending announcement result automatically posting announcement web calendar sending reminders day talk 
event planning imagine organizing program committee meeting want know pc members stay dinner meeting 
currently send question compile replies manually emails 
semantic email pc members provide reply way automatically interpreted compiled enabling planning scale larger numbers people 
addition days unresponsive pc members automatically reminded respond said re coming pc meeting need bothered query 
alternatively suppose organizing balanced potluck people bring appetizer entree dessert want ensure meal balanced 
semantic email help ensure potluck balanced examining replies requesting changes necessary 
report generation suppose need collect projected budget numbers large set managers 
semantic email send single email request system automatically tabulate responses possibly requiring values satisfy certain individual aggregate constraints 
system easily generate spreadsheet report integrate data sources prior budgets 
auction imagine want give away concert tickets 
send announcement semantic email system give auction tickets respondents 
tickets gone system respond requests 
examples course illustrative exhaustive 
general ways semantics streamline aspects email habitat update email message add data source web page example 
query email messages query users information 
semantics associated queries automatically answer common questions seeking phone number directions office 
process semantic email manage simple tedious processes currently handle manually 
email set handle tasks effectively accomplishing hand tedious time consuming error prone 
techniques needed support uses semantic email depend message written text user formally generated program sender 
user generated case need sophisticated methods extracting precise update query text 
cases require methods ensure sender receiver share terminologies consistent fashion 
focuses third semantic email streamline processes believe greatest promise increasing productivity users currently feel pain 
processes support common case asking people set questions collecting responses ensuring results satisfy set goals 
hardcoded email processes meeting request feature outlook invitation management contact management popular 
commercial applications limited scope validates claim user pain 
goal sketch general infrastructure semantic email processes analyze inference problems needs solve manage processes effectively guarantee outcome 
collaboration systems lotus notes domino offer scripting capabilities graphical tools implement sophisticated email processes 
systems typical workflow systems lack support reasoning data collected number participants required balance potluck ensure collected budget satisfies aggregate constraints 
addition processes constructed arbitrary pieces code lack formal properties declarative model provides 
describe properties limitations existing systems detail sections 
messages systems lack structured content rdf semantic email precluding automated processing recipient decline invitations unavailable times 
articulate implement general model semantic email processes seps 
technical contributions 
section introduces formalization semantic email processes 
formalization specifies meaning semantic email processes exposes fundamental reasoning problems semantic email manager facilitate sep creation execution 
particular key challenge decide manager direct process outcome meets originator goals 
address challenge different formal models 
section addresses challenge describing model logical seps seps demonstrating possible automatically infer email responses acceptable respect set ultimately desired constraints polynomial time 
model section describes automatically generate explanations manager interventions identifies cases explanations computed polynomial time 
second section describes model decisiontheoretic seps seps alleviates shortcomings logical model presents results complexity computing optimal policies seps 
section discusses implementation issues arise semantic email addressed system section contrasts approach related 
appendices provides proofs theorems body 
semantic email processes formalization seps serves goals 
formalization captures exact meaning semantic email processes defines 
second clarifies limitations seps providing basis study variations different expressive powers 
formalization pose reasoning problems help guide creation semantic email processes manage life cycle 
emphasize users seps expected understand formalization write specifications 
generic fig 

invocation execution sep originator typically person automated program 
originator invokes sep simple web interface need trained details seps understand rdf 
seps written trained authors create simple constraints utility functions represent goal process invoked untrained users 
semantic email system coordinates process provide formal guarantees describe 
illustrates primary components sep originator sep initiated originator typically person automated program agent 
manager originator invokes new sep sending message semantic email manager 
manager sends email messages participants handles responses requests changes necessary meet originator goals 
manager stores data related process rdf supporting data set may configured allow queries external services managers 
accomplish tasks manager may utilize external services inference engines ontology matchers semantic web applications described 
manager may shared server program run directly originator 
participants participants respond messages received process 
participant may person standalone program represent resource conference room software agent acts behalf person automatically respond requests possible deferring person 
assume email addresses uniquely determine individuals sets potential participants process 
informally speaking execution process achieved supporting data set set data updates email recipients respond 
model describe data represented set relations relational database model 
application domains get complex expect richer representation language 
enable extensions interactions semantic web applications system implements representation jena rdf storage system 
illustrate formalization running example balanced potluck originator invokes process announce potluck ask bringing appetizer entree dessert 
originator expresses set goals potluck 
example may specify number differ 
note particular problem number uses distributing persons evenly committees time slots just example 
formalization implementation seps support broader range uses 
manager seeks expedite execution process achieve originator goals 
number ways reasoning enhance manager operation predicting responses manager may able infer response participants sending requests 
instance manager employ semantic web application data source detect suggested meeting time unacceptable certain participant information calendars course schedules processes 
manager information warn originator process created serve surrogate response definitive answer received 
manager add helpful annotation request sent participant indicating time conflict 
suggested reasoning profitably employed participant agent may additional information participant schedule 
interpreting responses typically originator provide participants finite set choices appetizer entree dessert 
suitable reasoning enable substantially flexibility 
instance allow potluck participant respond value plain text formal language 
manager combination information extraction wrapper techniques ontology matching algorithms map participant response potluck ontology 
interesting outcomes mapping 
response may directly map original potluck choices cake instance dessert 
second response may map multiple choices ontology jello salad may appetizer dessert 
case manager consider response half appetizer dessert postpone decision time classify convenient 
third response may map choice may subclass food palette manager accept response exclude goal calculations 
fourth response simple form semantic negotiation complex techniques useful 
may map known ontology element food hat 
response may map known element 
cases manager may reject response notify originator 
recommending interventions reasoning assist manager directing process outcomes consistent originator goals 
instance manager detects potluck process unbalanced refuse accept certain responses request changes participants warn originator action needed 
case reasoning needed deduce outcome process current state effects possible interventions 
focus reasoning recommending interventions leaving items 
specifically provide different approaches modeling originator goals intervene 
logical model sections originator specifies set constraints data set satisfied process outcome decision theoretic model section originator provides function representing utility possible process outcomes 
consider turn discuss possible variants results fundamental reasoning tasks determine manager intervene 
logical model seps introduce model logical semantic email process sep analyze important inference problems model 
definition seps sep tuple cd parts follows participants set participants process 
note may include originator 
supporting data set set relations holds data related process 
initial contents specified originator usually set default values columns 
relation associate schema includes relation name names data types range constraints attributes 
special data type values elements set attributes may default values 
possibly distinguished attribute type means rows relation value result messages participant attribute may declared unique case participant affect single row table 
responses set possible responses originator email 
specified follows attributes set attributes affected responses participants 
set attributes include attributes 
insert update parameter specifying participants add tuples modify tuples 
recall field changes pertain particular set tuples 
single parameter specifying participants send single response 
explain section responses may rejected system 
single mean non rejected message 
messages set messages manager may direct process remind participants respond reject participant response 
constraints cd set constraints relation constraints cd specified language includes conjunction disjunction atomic predicates 
atomic predicates compare terms term set 
allow comparison predicates constant enumerated finite set 
term may constant attribute variable value specific attribute row expression combining terms arithmetic operator aggregate applied column relation subset rows satisfy equality predicate 
example example contains table named potluck columns email attribute type declared unique bringing range constraint potluck bringing coming appetizer entree dessert null 
set possible responses coming appetizer entree dessert 
addition cd contains constraint formulas similar specifying potluck balanced count bringing dessert count bringing appetizer set messages example includes initial message announcing potluck asking person bringing messages informing responder response accepted reminder responded days potluck regular messages originator reporting status responses message originator event responded 
inference seps formal model sep pose wide variety inference problems results serve assist manager operation 
section describes inference problem different variations 
core problem want address determining sep terminate acceptable state state satisfies cd 
input inference problem includes constraints cd possibly current state response participant 
output inference problem condition check determine accept discussion assume legal response values inserts satisfy range constraints columns manager respond error messages legal response received 
goal automatically determine accept current state cd 
space possible inference problems defined dimensions necessity vs possibility modal logics reasoning states system look conditions guarantee sequence responses ends desired state operator possible sequence ends desired state operator 
assumptions participants addition assuming responses legal consider assumptions participants respond message participants flexible asked change response cooperate 
type output condition extreme may want constraint cr manager checks response arrives cr specified language specify cd 
extreme may produce arbitrary procedure inputs determines accept note constraint cr inevitably weaker arbitrary algorithm inspect state particular ways 
intermediate points may consider constraints cr expressive constraint languages 
note cases successfully derive cr database triggers implement modifications indicate rejected 
simple example consider case want response sequences acceptable state assumptions participants elicit legal response interested deriving constraint cr checked response arrives 
initial state acceptable state simply setting cr cd provides sufficient condition data set states satisfy cd 
example balanced potluck accept response dessert lead having 
process accept request caused total number tickets claimed number available 
cases conservative strategy overly restrictive 
example may want continue accepting long possible achieve balanced potluck 
furthermore approach usable constraints initially satisfied responses received greatly limits types goals expressed 
leads inference problem 
ultimate satisfiability describe central result concerning inference seps 
goal find necessary sufficient conditions accepting response participant 
cut dimensions follows 
suppose data set responses accepted new response note necessarily satisfy cd accepting manager accept possible lead state satisfying cd considering temporal operator 
require acceptance condition expressed constraint language concerned efficiently verified assume defines constant number attributes bringing 
furthermore assume participants update single row 
definition ultimate satisfiability data set set constraints cd response say ultimately satisfiable exists sequence responses participants put state satisfies cd 
follows constraint language allow conjunction disjunction atomic predicates 
term predicate cd may select group rows attribute aggregate value corresponding values attribute consider aggregation functions count min max sum average 
addition define definition bounded constraints data set set constraints cd say cd bounded iff holds domain bounded predicates cd refer attributes domain size constant constant bounded predicates cd refer distinct constants aggregate cd count 
examples may described constraints satisfy constant bounded count condition domain bounded case may useful seps require complex interactions 
definition show ultimate satisfiability difficult general tractable constraints bounded theorem sep participants constraints cd 
cd may set constraints permitted language ultimate satisfiability np complete cd bounded determining ultimate satisfiability polynomial time cd 
example applying theorem balanced potluck suppose new dessert response arrives 
point inference procedure determine maximal number people may come potluck number participants minus number people replied coming check dessert response accepted people answered ultimate set dishes balanced 
similar reasoning applies processes ensure person sign spot colloquium series 
theorem proved enumerating representative states data set corresponds number potential states equivalent respect constraints 
key express constraints terms variables representing aggregates number participants response 
see appendices complete proof 
comparison related challenge reasoning possible relationships aggregate values current particular state reasoning aggregation received significant attention query optimization literature description logic literature 
body considered problem optimizing queries aggregation moving predicates query blocks reasoning query containment satisfiability queries involving grouping aggregation 
contrast result involves considering current state database determine brought state satisfies set constraints 
furthermore cd may involve grouping columns aggregations translated single block sql queries containment algorithms carry context 
best knowledge formalisms reasoning workflow temporal properties necessity possibility considered reasoning aggregation 
instance abiteboul define notion goal reachability relational transducers similar ultimate satisfiability see extensions model survey related 
various restrictions model allow decidability goal reachability np nexptime restrictions permit goals involving gation 
likewise workflow formalisms generally restricted reasoning temporal causality constraints 
formalisms potentially convert aggregation constraints temporal constraints enumerating possible data combinations may result exponential number states 
exception extend workflows include resource constraints aggregation 
constraint restricted performing single aggregation grouping express potluck constraint earlier example 
addition solution general constraint solving take exponential time worst case 
shown domain seps easily express complex aggregation constraints maintaining polynomial time inference complexity bounded constraints 
explanation generation seps executing sep utilizes rejections influence eventual outcome 
success interventions depends extent understood participants 
instance rejection sorry dates left may may elicit cooperation participant seminar scheduling sep simpler rejection sorry try particular set constraints author sep manually specify create explanations task difficult constraints interact depend considering possible responses 
consider techniques automatically generating explanations responses acceptable participant original response acceptable 
defining precisely number relevant terms 
sep current state state supporting data set responses received far 
assume number participants known eventually respond 
earlier discussion regarding necessity vs possibility allow constraint satisfaction defined different ways definition constraint satisfied state iff evaluating yields true 
definition constraint ultimately satisfiable state exists sequence responses remaining participants leads state evaluating yields true 
simplicity assume constraints cd results hold cd contains types 
acceptable responses practical information provide participant response led intervention set responses acceptable appetizer dessert welcome sorry accept requests tickets fewer 
section briefly considers calculate acceptable set 
definition acceptable set sep current state constraints cd acceptable set set legal responses satisfiable cd accepting satisfiability testing easy compute acceptable set testing small set representative responses 
situation complex theorem sep participants current state constraints cd may set constraints permitted language computing acceptable set np hard cd bounded problem polynomial time cd 
case compute acceptable set testing satisfiability small set representative values testing polynomial iff cd bounded theorem 
addition represent set ranges acceptable values explicitly listing acceptable value total time polynomial cd 
explaining interventions cases acceptable set may construct useful explanation 
instance suppose sep invites professors students meeting professors quorum persons professors students attend 
requesting change professor explaining change needed need reach required professors effective simply informing response desired please change 
clear explanation motivates request rules alternative reasons request need help reaching quorum may persuasive students help reach quorum 
section discusses generate explanations intervention identifying constraint led intervention 
discuss additional problem translating constraints natural language suitable sending participant note fairly simple explanations vs better explanation 
conceptually sep decides reject response constructing proof tree shows response prevent constraint satisfaction 
proof tree may large complex serve explanation participant 
problem investigated expert systems constraint programming description logic reasoning context semantic web 
systems assumed proof trees arbitrary complexity handled wide variety possible deduction steps 
generate useful explanations key techniques included abstracting multiple steps rewrite rules describing general principles applied specific situations customizing explanations previous utterances 
context proof trees simpler structure exploit 
particular proofs constraint satisfiability state possible states child node adds additional response parent state regular way 
consequently able summarize proof tree simple type explanation 
proof trees defined follows definition proof tree sep current state constraints cd response say proof tree rejecting iff tree root initial state root exactly child dr representing state adding cd dr non root node 
cd node dr descendants children formed adding single additional response state leaf nodes possible final states participant responded reachable dr leaf node evaluating cd state yields false 
illustrates proof tree 
accepting leads state constraint ct satisfied rejected 
likewise shows proof tree cp cq represent professor quorum constraints example described 
trying prove way constraints ultimately satisfied outcome tree fully expanded 
tree leaf final outcome satisfy constraint rejected 
define simpler explanation proof tree definition sufficient explanation sep current state constraints cd response proof tree exists rejecting say sufficient explanation rejecting iff conjunction constraints appear cd leaf node evaluating state yields false 
fig 

examples proof trees rejecting response node possible state data set node labels constraints satisfied state 
cases response rejected leaf node shaded satisfy constraint 
intuitively sufficient explanation justifies rejecting covers leaf node proof tree precludes satisfying cd 
note proof tree rejecting unique modulo ordering child nodes explanation 
instance explanation cs ct cs ct likewise valid explanation cp cq way satisfy professor quorum constraints precise explanation just cp way satisfy professor constraint 
smaller explanation compelling argued meeting example preferred 
general wish find explanation minimum size fewest conjuncts theorem sep participants current state constraints cd response cd consists finding minimum sufficient explanation rejecting polynomial time cd 
cd consists problem np hard np hard cd 
computing minimum explanation feasible intractable 
difficulty arises sources 
checking particular sufficient explanation np hard reduction ultimate satisfiability scaling seps large numbers participants difficult 
second finding minimum explanation np hard number constraints reduction set cover explanation generation complex goals challenging 
fortunately common cases simplify problem permit polynomial time solution theorem sep participants current state constraints cd response cd bounded size minimum explanation constant computing minimum explanation polynomial time cd 
theorem holds candidate explanation checked polynomial time constraints bounded restricting size means total number explanations considered polynomial number constraints 
restrictions quite reasonable 
previously mentioned bounded constraints permit wide range functionality 
likewise sep explanations useful participants contain small number constraints adequate seps meeting example 
sufficient explanation size exists system choose best explanation size maintain simple explanation approximate minimum explanation greedy algorithm fall back just providing participant acceptable set described previous section 
decision theoretic model logical model seps described supports number useful inferences theoretical practical applications 
model number shortcomings 
seps logical theories general distinctions unsatisfied outcomes 
example way seps strive nearly balanced potluck unbalanced equivalently undesirable 
second sep ignores cost actions taken pursuit goals 
instance potluck sep reject response results unsatisfiable constraints rejecting response important official may produce far worse effects slightly unbalanced potluck 
seps strong assumption participants willing change responses rejected 
instance participants meeting scheduling process may somewhat accommodating may refuse modify rejected response due commitments 
address limitations offer decision theoretic approach 
describe goal decision theoretic sep sep utility function outcome process takes consideration cost actions required achieve outcome 
addition rejecting responses decisiontheoretic model suggests participants modify choices 
instance balanced potluck uses utility function measures extent final meal selection balanced minus costs social asking participants switch responses 
formalize model examine tractability finding optimal policies 
definition seps decision theoretic sep tuple 
note components tuple correspond roughly components model seps 
participants set participants size states set possible states system 
state describes current responses received outgoing change requests sent system 
values set possible values participants choose appetizer entree dessert 
actions set actions available system sending initial message 
actions consider noop message arrives swv ask participant switch response halt enter terminal state typically permitted message received participant 
variants actions useful ask participant switch particular value additions fundamentally change model complexity results 
utilities utility executing action state potluck example swv negative utility making change suggestion halt utility final potluck balance 
transitions probability system transition state performing action state having specify probability transition computed smaller set building blocks 
instance probability participant originally respond value vw probability asked switch choice participant change response vv probability participant refuses switch 
execution process proceeds discrete steps step manager decides action take possibly noop 
outcome action uncertain manager sure participants respond 
transition function models uncertainty 
policy describes action manager take state denotes action manager take particular state optimal policy policy maximizes expected utility process 
sj aj sequence states actions sj halt 
seps special case markov decision processes mdps studied formalism situations outcome performing action governed stochastic function costs associated state transitions 
conse quently find optimal policy sep converting mdp known mdp policy solvers 
exploit special characteristics seps permit efficient solutions consider 
variations seps logical model space possible seps defined dimensions restrictions making suggestions generally manager may allowed suggest changes participants time repeatedly 
user friendly may allow manager suggestions anytime participant 
alternatively users may expected additional commitments soon sending response purchasing ingredients selected dish may require manager respond suggestion immediately receiving message additional messages processed 
assumptions participants addition assumed probabilities governing participant behavior may wish assume participants eventually respond message receive 
furthermore assume participants respond immediately suggestions receive particularly manager responds immediately original message respond suggestions anytime 
type utility functions extreme allow complex utility functions individual responses participants jay bringing dessert 
precision unnecessary 
instance potluck outcomes entree low utility regardless bringing dish 
consider impact variations complexity computing optimal policy 
computing optimal policy section examine time complexity computing optimal policy sep considering sep arbitrary utility function examine restrictions utility function permitted quantity specifically seps stochastic shortest path mdps terminal state reachable state optimal policy guaranteed exist 
incorporating additional features temporal mdps enable richer model seps scheduling meeting completed day meeting 
existing solution techniques scale number participants required semantic email 
timing suggestions computing tractable 
cases assume participants eventually respond message suggestion receive 
relax assumption representing model probability participant respond message 
theorem proved reduction qbf quantified boolean formula game theorem sep participants utility deterministic function state current action manager send bounded number suggestions participant determining pspace hard manager send unlimited number suggestions problem exptime hard corresponding problems determining expected utility exceeds constant pspace complete exptime complete respectively case arbitrary utility functions determining sep impractical large values 
conversion mdp offers little help mdp require number states exponential 
note significant limitation seps natural wish scale large numbers participants large meetings wide surveys 
calculation tractable restricting type utility function definition partitionable utility function sep expressed solely terms variables ck current action chosen manager ci number participants responded value vi state intuitively utility function partitionable matters number participants belong fixed number groups specific participants groups 
instance utility function example potluck partitionable matters evaluating current utilities current number participants responded appetizer entree dessert coming 
case simple utility function halt ca ce ca cd ce cd swv scaling constant ca ce cd numbers respectively 
note maximum utility zero 
partitionable utility function analogous count constraint language theorem 
theorem allow complex utility functions variables representing max sum underlying responses suitable restrictions functions yield polynomial time results similar described 
note simpler partitionable definition flexible support seps discussed 
particular partitionable utility function may distinguish different types people counting responses differently division participants 
technique increases effective value constant factor 
instance utility function meeting scheduling process desires number faculty members attending number students attending close possible strongly avoiding asking faculty members switch halt max sep may unlimited number suggestions utility function represented infinite horizon mdp just reachable states 
consequently sep may solved time polynomial linear programming lp alternative methods policy iteration simplex lp solvers guarantee polynomial time may faster practice due large polynomial degree approach 
furthermore restrict system send suggestion participant desirable property case computing optimal policy tractable theorem sep participants constant system permitted send suggestion participant 
determined time 
system send suggestions participant total time needed 
table summarizes results interesting cases immediate synchronous 
results rely key optimizations 
dramatically reduce number distinct states permits polynomial time 
second ensure state transition graph acyclic useful property mdps noted contexts bounding number suggestions sent participant enables find simple graph search algorithms policy iteration linear programming 
furthermore approach enables existing heuristic search algorithms exact computation remains see boutilier alternative guaranteed domain structure reduce effective number states 
restrictions description restrictions complexity arbitrary utility function manager may suggest changes time may send unlimited number suggestions participant 
manager may suggest changes time participant 
immediate manager may suggest changes immediately receiving response participant 
complexity partitionable exptime hard mdp states pspace hard time pspace hard time synchronous immediate participant pspace hard assumed respond suggestion manager receives message 
time table summary theoretical results seps 
columns show time complexity finding optimal policy sep participants 
general problem exptime hard utility function partitionable problem polynomial time 
mdp solved time guaranteed polynomial number states polynomial high degree 
adding restrictions manager may send suggestions problem tractable 
note size optimal policy finite computed execution sep may infinite 
infeasible 
consequently appropriate restrictions useful seps efficiently solved polynomial time 
explanation generation seps seps able automatically generate explanations manager interventions 
briefly consider problem context seps 
compared seps difficult sep single specific terms responsible manager suggestion term contributes process utility extent positively negatively 
note manager decides suggestion expected improvement outweigh certain cost action 
non zero costs significant difference utility state manager requested switch ssw vs manager 
seek identify terms explain difference 
particular term utility function 
un define change utility term ssw 
wish identify set un ssw terms explain change 
note compute optimal policy polynomial time compute polynomial time 
generating explanation primarily interested terms indicating switch beneficial 
consider terms greedy algorithm suffices identify explanation guaranteed minimal size set incrementally add term largest explains total change 
wish consider utility terms positive negative changes problem challenging cf klein shortliffe 
discussion compared seps primary advantages seps ability balance utility process goals vs cost additional communication participants graceful degradation goals completely satisfied 
hand need determine suitable utilities probabilities inherent drawback decision theoretic framework 
consider techniques approximate parameters 
sep depends relative value positive utilities having balanced potluck vs negative utilities cost making suggestion 
discussion exhibited number simple reasonable utility functions 
practice expect seps provide default utility functions functionality allow users modify functions adjusting parameters answering series utility elicitation questions 
second seps require probabilistic information participants respond original requests suggestions 
information determined number ways user provided process originator may able provide reliable estimates responses outside information past experience 
history alternatively system estimate probabilities examining history past processes 
dynamically adjusted addition methods system dynamically adjust probability estimates actual responses received 
number participants large relative number choices system able stabilize probability estimates majority responses received 
need provide utility probability estimates drawback seps compared seps simple techniques produce reasonable approximations 
practice choice sep sep depend target usage feasibility parameter estimation 
implementation allow originator choice 
seps currently elicit basic utility information originator see probabilities provided sep author expected participant behavior 
extending implementation support history dynamically adjusted probabilities 
implementation usability implemented complete semantic email system deployed applications 
doing faced challenges 
section describes desiderata usable semantic email system highlights challenges achieving desiderata discusses particular implementation choices 
desiderata successful argue semantic email system sep fulfill desiderata instant gratification importantly semantic email provide immediate tangible benefit users 
users expected annotate outgoing incoming mail semantic content vague benefit 
semantic email system provide users existing services yield immediately obvious benefits 
fact notion instant gratification key getting people invest structuring data motivation mangrove semantic web system 
fig 

creation semantic email process sep 
initially author authors sep template template generate associated web form 
web form originator instantiate template 
typically template authored instantiated times 
gradual adoption semantic email initiated small number early adopters semantic email profitably exchanged users limited applicability 
succeed semantic email usable participants experience software installed 
ease semantic email simple non technical person 
expect users understand rdf disrupt normal email processing require email senders recipients particular email client 
elaborate challenges implementing system achieves goals 
process creation execution translating sep theory real problems applying sep theory real problems requires enabling originator easily create sep sep model corresponds goals 
option build gui tool guides originator constructing appropriate choices messages constraints utilities process 
practically tool general build arbitrary process complex untrained users 
system construction reusable templates specific classes seps 
demonstrates approach 
initially assumed knowledge rdf semantic email authors new template editor modifying existing template 
call person sep author 
template written owl sep ontology describes possible queries constraints messages process 
instance balanced potluck template defines general balance constraints process placeholders parameters participants addresses specific choices offer imbalance permit 
enable originator provide parameters associate template simple web form prompts originator parameter 
fig 

web form initiate balanced collection process balanced potluck example 
convenience clicking submit converts form text sends result server copy originator 
originator may initiate similar process editing copy mailing directly server 
stance shows form balanced potluck 
note bottom form allows users choose executing sep strictly flexibly options sep tradeoff option 
addition originators may specify individuals mailing lists participants case form asks originator estimate total number people respond shown 
implementation provides simple tool automatically generate web forms additional owl information template 
tool generate service description template wsdl owl 
program serve originator utilizing service description template automatically invoke process directly 
untrained originator finds sep public library sep templates instantiates template filling corresponding web form yielding sep declaration owl 
originator invokes process forwarding declaration manager 
formal declaration manager executes process appropriate sep sep algorithms decide direct process appropriate message rejections suggestions facilitating responses key challenge enabling participants respond messages way convenient automatically interpreted manager 
number different solutions possible client software provide custom email client participant interface constructing legal responses automatically respond messages knows handle decline invitations friday 
client approach requires participants process install additional software conflicting gradual adoption goal complicated variety mail clients currently 
information extraction allow participants respond natural language ll bring dessert 
wrappers information extraction techniques attempt convert response offered choices 
approach promising risks having wrapper fail extract correct information 
email web forms provide participants text encoded form fill send link suitable web form response 
embedded html forms attractive unfortunately handled uniformly existing email clients 
web forms advantages chose email text forms feel fit naturally people typically handle incoming messages 
addition text forms offer simple solution works participant 
participants respond replying process message editing original form 
manager sends rejection suggestion participant message includes explanation intervention copy original form participant modify response 
earlier discussion generally assumed participants send single acceptable response 
implementation permit participants change mind sending additional responses 
logical model response accepted changing participant original response new value permits constraints satisfied response accepted coming 
decision theoretic model new response accepted may lead change suggestion modified state process 
manager deployment potentially manager program run originator personal computer part mail client 
permits easy transition authoring traditional mails invoking seps benefit direct access originator personal information calendar contacts 
providing client software participants approach requires software installation deal wide variety existing mail clients 
implementation deploys manager shared server 
server procedural approach declarative approach size reduction sep name number lines number lines declarative balanced potluck come served meeting coordination request approval auction table comparison size sep specification original procedural prototype java html vs declarative format described rdf 
declarative approach concise 
values include html rdf needed acquiring parameters originator 
receives invocations originator sends initial message participants 
participants reply mail directly server originator originator receives status summary messages server appropriate 
originator query alter process additional messages web interface 
discussion server approach easy implement meets gradual adoption ease goals requires software installation works email clients require users originators read write rdf 
addition method supports instant gratification goal providing untrained users existing useful seps immediately invoked yield tangible output form messages sent processed users behalf 
believe processing semantic email server standard email flow client facilitate adoption user concerns privacy placing potentially buggy code email client 
addition specifying sep templates declarations owl number advantages 
original version semantic email process specific procedures sep described entirely owl declaration 
greatly simplifies deployment new sep programming required authors need run server shared servers accept execute owl declarations arbitrary code 
addition declarations simpler concise corresponding specifications written procedural language see table 
furthermore authoring seps owl enables variety automated tools ensure sep declaration valid 
owl semantic email goes server personal email untouched 
course semantic email contains sensitive information security server significant 
fig 

message sent participants balanced potluck process 
bold text middle form human recipients respond bold text bottom rdql query maps textual response rdf 
specifications enable automatically composes seps accomplish complex goals 
human machine interoperability previous section highlighted semantic email messages handled human program operating behalf 
important requirement message contain human understandable portion re invited potluck oct corresponding portion 
messages sent participant approach supports gradual adoption permitting originator send message participants knowledge capabilities 
responses portion enables manager evaluate message process constraints utilities take action 
human readable component provides simple record response needed review 
implementation meet interoperability requirement combination techniques 
responses human fill included text form see converted rdf server simple mapping field unbound variable rdql query associated mes sage 
alternatively machine respond message simply answering query rdf applying inverse mapping order correctly fill human readable text form 
messages participants challenge enable manager construct textual rdf rdql portions directly sep declaration 
tension amount rdf content provided sep author template vs provided sep originator instantiating template 
specific sep templates balance people appetizer entree dessert choices easiest instantiate author specify rdf terms needed advance 
general sep templates balance people arbitrary choices reusable require substantially instantiate may require understanding rdf 
alternatively authors may provide general templates specification rdf terms choices optional enables easy template reuse fails provide semantic content automated processing participants 
current system offer highly specialized seps meeting scheduling general seps give away type item 
enabling originators easily customize general seps precise semantic terms set offered ontologies important area 
integrating non semantic messages despite advantages semantic email want create strict dichotomy email habitat 
potluck example suppose participants wants know organized transportation potluck information affects decision bring 

compose separate non semantic email originator respond semantic 
better easier solution treat kinds emails uniformly enable participant ask question replying semantic email ultimately providing semantic response thread 
implementation supports behavior supplying additional remarks field response form participant may include question comment forwarded originator 
question originator reply enabling participant respond original semantic question included form pose question 
experience semantic email system deployed may freely software installation source code deploying instances server available 
far developed simple processes functions collecting confirming declining invitation giving tickets away scheduling meetings balancing potluck 
system uses standard ontologies possible rdf calendar augmented needed local semantic email schema 
despite limited publicity semantic email server seen growing interest short time available 
instance darpa working group adopted semantic email meeting scheduling rsvp needs students semantic email schedule seminars ph 
exams semantic email organize annual database group 
furthermore number institutions expressed interest deploying copies semantic email locally sites 
merely anecdotes lend credence claim semantic email useful practical 
semantic email system integrated larger mangrove semantic web system 
provides rdf infrastructure managing email data integrating web data sources services 
instance mangrove web calendar accepts event information email web page 
addition mangrove provides semantic email rdf data source courses people support prediction responses manager discussed section 
likewise semantic email client utilize data mangrove answer common questions 
previously unknown questions answered manually user responses stored enabling automatic acquisition semantic knowledge time 
consider additional ways synergistically leverage data web email worlds mangrove 
related information lens forms enable user generate single email message semi structured content assist recipients filtering prioritizing message 
seps generalize earlier enabling users create email process consisting set interrelated messages extending information lens rule message processing support complex constraint utility reasoning information entire set messages 
consequently seps support broader range possible applications 
proposed having users semantically annotate messages improve mail search sorting filtering 
approach potentially result rich semantic content requires users invest significant annotation effort potential benefit improved searching old email primarily benefit recipient 
seps generate semantic content text email message directly simple forms provide instant gratification immediately utilizing content simple time saving email processes 
vision semantic email initially described etzioni mc 
possible uses semantic email similar existing semantic web systems cf rdf calendar group discussions 
key differentiating aspects generality different tasks ability interoperate freely naive participants polynomial time reasoning recommending interventions 
instance uses messages participants agree meeting times mcilraith describe agent travel arrangements invoking various web services modeled participants sep 
systems enable full interaction parties executing domain specific software 
instance provides web interface schedule appointment installed user user system request appointment non enabled person 
likewise mcilraith agent designed communicate specific web services humans human travel agents offer functionality 
system permits processes include user regardless capabilities 
additional critical distinction email custom protocol cf 
email provides convenient transport mechanism vast majority users known addresses additional directories needed messages sent regardless recipient performed configuration existing email clients provide useful record messages exchanged 
framework enables automated pursuit wide variety goals reasoning guaranteed polynomial time result provided systems discussed 
combination factors semantic email lightweight general approach automating tasks impractical systems 
inference web focused need explain semantic web system terms base data reasoning procedures 
contrast deal explaining sep actions terms existing responses expected impact constraints 
sense similar prior research sought explain decision theoretic advice cf horvitz 
instance klein shortliffe describe system users explanation action provided 
note focuses explaining relative impact multiple factors choice action seek simplest possible reason action chosen accepted 
relevant includes druzdzel addresses problem translating uncertain reasoning qualitative verbal explanations 
constraint satisfaction problems csps nogood reason current variable assignment satisfy constraints 
contrast explanation reason assignment satisfy constraints set possible responses 
potentially problem reduced nogood calculation direct conversion produce problem take time exponential number participants 
bounded constraints create csp variables aggregates responses specific values described section 
simpler csp exploit existing efficient solvers find candidate explanations time polynomial note applications nogoods focused developing improved constraint solving algorithms debugging constraint programs creating explanations average users 
exception jussien describe generate user friendly nogood explanations require designer explicitly model user perception problem nodes constraint hierarchy 
generalizes original vision semantic web encompass email 
introduced paradigm semantic email described broad class semantic email processes 
automated processes offer tangible productivity gains email mediated tasks currently performed manually tedious time consuming error prone manner 
semantic email opens way scaling similar tasks large numbers people manner infeasible today 
example large organizations carry surveys auctions complex meeting coordination semantic email guarantees behavior processes 
technical contributions follows 
formalization issues involved formalization explore central inference questions 
defined explored useful models specifying goals process formalizing manager process intervene 
logical model showed problem deciding response ultimately acceptable relative constraints solved polynomial time bounded constraints 
decision theoretic model addressed shortcomings logical model demonstrated appropriate restrictions enable optimal policy model computed polynomial time 
cases identified restrictions greatly improved tractability key reasoning problems enabling large number useful processes represented 
addition described automatically generate explanations manager interventions identified cases explanations computed polynomial time 
described publicly available semantic email system satisfies implementation desiderata instant gratification gradual adoption ease 
number interesting directions 
want consider interactions semantic email semantic web applications support sophisticated reasoning techniques check calendars resources help constrain number messages responses participants 
plan incorporate schema ontology mapping support flexibility responding semantic email message 
addition deployed system semantic email offers potential number interesting user studies 
instance interesting examine originators seps types popular impact seps efficiency tasks compared traditional email management users react interventions 
identified specific cases reasoning tractable opportunities studying cases framework provided modeling seps 
research supported part nsf iis darpa contract onr oren etzioni nsf ca iis itr iis alon halevy nsf graduate research microsoft endowed fellowships luke mcdowell 
jeff lin assisted server implementation 
abraham bernstein phil bernstein sandy liu matthew richardson dan weld anonymous reviewers helpful comments improving 
proof sketches logical seps section provides details proofs theorems related seps 
assume sep participants current state constraints cd cd refers constant number attributes 
proof theorem show ultimate satisfiability np complete general case 
show problem solved polynomial time constraints domain bounded constant bounded 
np complete arbitrary constraints observe ultimate satisfiability np sep response guess possible outcome consistent verify outcome satisfies constraints 
second show ultimate satisfiability np hard reduction sat 
assume boolean formula form lm li wi wi wi wij equals variable xk xk sat problem determine satisfiable assignment variables construct sep participants pn data set single table attribute value responses nil rn constraints cd vij substituted wij wij xk set vij count value rk wij xk vij count value rk construction polynomial size 
resulting participants may respond values 
constructed show sat formula satisfiable iff initially empty ultimately satisfiable cd response nil 
assignment xn satisfies final state satisfies cd follows responds nil pk responds rk xk true pk responds nil 
set corresponding xk cd true satisfied cd satisfied resultant state demonstrating ultimately satisfiable initial response nil 
alternatively ultimately satisfiable initial response nil take final state satisfies cd construct assignment xk satisfies follows participant responded value rk xk true xk false 
sat problem variables solved reduction ultimate satisfiability participants 
sat np complete ultimate satisfiability np hard polynomial time constraints domain bounded case constraints refer attributes domain size constant attributes total lh possible responses 
evaluate constraints data set distinguishes representative states different respect constraints 
particular matters number type response received aggregates responses 
number possible states number ways dividing participants lh possible responses lh choices plus response option lh lh lh determine ultimate satisfiability construct data set dr augmented response iterate possible values value inconsistent dr response type ri dr shows responses discard evaluate cd requires time linear cd particular procedure ultimately satisfiable iff consistent dr satisfies cd 
step requires linear time polynomial number iterations lh total time polynomial cd 
polynomial time constraints constant bounded case uses similar algorithm constraints domain bounded 
attribute may potentially infinite domain keep track possible states differently 
allow count aggregations may form count value vi inequality count value vi 
cd constant bounded constants vk aggregations 
constants divide domain attribute regions 
possibilities attributes response yielding total kh possible responses 
analysis number possible states representative data set kh time evaluate state linear 
assumed constants total time check ultimate satisfiability polynomial cd 
proof theorem theorem sep current state possibly constraints cd wish compute acceptable set 
consider cases cd bounded polynomial time bounded constraints determine particular response testing ultimate satisfiability iff ultimately satisfiable cd cd bounded theorem states satisfiability testing done time polynomial cd 
addition cd bounded small number possible responses cd domain bounded bounded number responses distinguishable constraints cd constant bounded discussed proof theorem 
case constant number different responses tested 
testing representative response determine entire acceptable set representing ranges acceptable values time polynomial cd 
construct entire set described theorem additional polynomial time dependence 
np hard arbitrary constraints case show computing acceptable set np hard reduction ultimate satisfiability sep participants data set constraints cd possible response ultimately satisfiable iff acceptable set 
relationship follows directly definition acceptable set reduction clearly polynomial time 
ultimate satisfiability np complete arbitrary constraints computing acceptable set np hard proof theorem sep current state constraints cd response wish compute minimum sufficient explanation rejecting theorem different results depending cd consists polynomial time size minimum sufficient explanation 
compute explanation adding testing constraint see unsatisfied new state constraint minimum explanation 
testing constraint state polynomial cd constraints total time polynomial cd 
np hard case computing minimum explanation np hard different ways 
reduction ultimate satisfiability sep cd ultimately satisfiable iff minimum explanation rejecting exist 
relationship follows definition explanation explanation exists rules way satisfying constraints reduction clearly polynomial 
determining ultimately satisfiability np complete theorem computing minimum explanation np hard second reduction set cover defined follows set family subsets sm si element contained si 
cover problem set union si contains element problem determine exists cover size smaller construct sep participants pn 
data set single table boolean attribute constraints set cd cm ci si count value rue constructing sep clearly polynomial time size set cover problem 
construction show set cover size exists iff minimum explanation rejecting response false initially empty state contains constraints 
explanation constraints minimum cover set si ci 
sufficient explanation contains special case included just handle situation participants respond 
size 
see works consider example set 
set mapped constraint 
sufficient explanation rejecting cover possible outcome sep outcomes participants respond true 
response rejected explanation cover cases choosing choosing constraint covers cases true responses 
follows exactly rules solution set cover 
likewise cover size minimum explanation rejecting initial false response conjunction constraints ci si total size 
input set cover problem reduced solving minimum explanation problem 
problem np complete number sets problem np hard number constraints cd 
combining previous result see computing minimum sufficient explanation np hard np hard cd 
proof theorem sep participants current state constraints cd response wish find minimum sufficient explanation rejecting assuming cd bounded size minimum constant cd consists know problem polynomial time cd theorem 
cd test particular explanation sufficient explanation ultimate satisfiability sufficient explanation iff cd ultimately satisfiable constraints bounded theorem states testing performed time polynomial cd 
addition minimum explanation contains terms cd restricting size means total number explanations considered polynomial cd 
compute minimal explanation testing sufficiency possible explanation size picking smallest sufficient explanation 
algorithm runs total time polynomial cd 
proof sketches decision theoretic seps section provides proofs regarding complexity computing optimal policy sep participants 
assume participant eventually send original response sends messages receive suggestion eventually respond 
convenience define notation problem determining optimal policy sep 
problem determining expected total utility exceeds constant 
proof theorem bounded suggestions case assume manager send constant messages participant 
prove case pspace complete result prove 
pspace complete show pspace 
consider tree representing possible executions root tree initial state leaf represents possible halted state 
state tree state may result manager making suggestion receiving response participant 
branching factor tree 
addition manager may ln suggestions participant may send responses tree acyclic total height ln 
consequently determine expected utility optimal policy suitable depth search tree 
utility child node discarded expected utility parent known total space needed just ln 
pspace 
second show pspace hard reduction qbf quantified boolean formula 
qbf problem specifies formula form xk yk cnf boolean formula xi yi computational problem determine true 
construct corresponding sep follows participants ak bk total participants 
states state ak bk ai bi indicate participant current response rue alse 
ai bi correspond directly xi yi formula 
say satisfied ai bi value evaluating substituting corresponding values xi yi yields true 
values rue alse 
actions noop halt swp true swp false transitions construct steps occur order choice initial state manager may perform noop wait responses halt winning strategy 
turn sends alse response 
manager may choose execute noop accepting alse suggest change case immediately agrees rue 
turn manager performs noop receives random original response rue alse 
refuses suggestions 
repeat repeat turn turn 
ak bk halt 
utilities non zero utilities follows halt quitting initial state halt rue represents infinitesimally small positive value 
note introduce serious computational difficulties 
expected utility state may maintained form addition multiplication comparison total order easily defined values 
addition appears utility function higher order values arise 
size sep polynomial reduction done polynomial time 
particular explicit representation transition utility functions possible state exponential rules allow necessary functionality encoded concisely terms current responses 
instance utility function representing possibility turn bi changes rue noop ai bi ai bi true note steps statements manager performs action noop really step manager choice 
construct transition function desired fashion force manager needed behavior setting transition probability executing action zero 
control probabilities permits ensure participants behave certain ways messages arrive certain order 
demonstrate additional result needed complete proof definition guaranteed satisfying policy sep constructed guaranteed satisfying policy policy followed manager guarantees sep terminate state satisfies 
claim guaranteed satisfying policy exists iff expected utility optimal policy greater true 
proof clearly expected utility guaranteed satisfying policy optimal policy utility large greater 
direction examining utility function see way obtain utility greater sep halt satisfied yielding reward 
outcome occurs probability total expected utility 
expected utility greater guaranteed satisfying policy exist 
show qbf formula true iff guaranteed satisfying policy exists 
sep manager choose set ai true false making suggestion ai sends response 
corresponds exists quantifications trying prove formula true choose desired value xi 
hand manager influence values bi chosen random 
manager guaranteed satisfying policy iff policy handle possible choices bi corresponds exactly quantifications yi note don depend precise values probabilities matters true false occur bi positive probability 
guaranteed satisfying policy exists iff qbf formula true 
problem pspace complete problem determining guaranteed satisfying policy pspace hard claim bounded number suggestions pspace hard 
pspace hard show pspace hard reducing 
sep construct manager may choose new initial state halt order process gain utility may choose noop case process transitions original initial state 
construction easy runs polynomial time 
original sep expected utility exceeds iff optimal policy specifies manager perform initial action noop 
follows expected utility optimal decision halt immediately utility 
pspace complete bounded number suggestions corresponding problem 
proof theorem unlimited suggestions second case assume manager may unlimited number suggestions participant 
prove case exptime complete result prove exptime hard 
exptime complete show exptime 
sep convert markov decision process mdp possible actions state state 
mdp solved techniques linear programming run time polynomial number states 
number states exponential total time exponential 
expected utility exceeds iff optimal value initial state mdp exceeds 
second show exptime hard reduction game 
game operates follows description board dnf disjunctive normal form formula set assignments boolean variables 
set variables xk belong player rest yk player 
players take turns flipping assignment variables 
game dnf formula evaluates true winner player move caused happen 
computational problem determine winning strategy player formula initial assignment variables 
loss generality assume original formula transformed corresponding initial assignment sets variables false 
instance game dnf formula construct corresponding sep follows participants ak bk total participants 
states state ak bk ai bi indicate participant current response rue alse set participants manager suggestion responded indicates message changed value ai bi correspond directly xi yi formula 
say satisfied ai bi value evaluating substituting corresponding values xi yi yields true 
values rue alse 
actions noop halt swp true swp false transitions construct steps occur order choice initial state manager may perform noop wait responses halt winning strategy 
startup participant sends response alse 
manager suggests change bi immediately respond 
turn manager chooses ai suggest change 
ai immediately agrees flipping current value ai 
satisfied halt 
turn manager performs noop receives response previous suggestion random bi flipping value bi 
manager immediately sends suggestion back bi respond 
satisfied halt 
go back turn 
utilities non zero utilities follows halt quitting initial state halt rue size sep polynomial reduction done polynomial time 
bounded suggestions case explicit transition utility functions exponential rules allow necessary cases represented concisely terms current responses 
likewise force needed manager participant behavior appropriate setting transition function 
demonstrate additional result needed complete proof definition guaranteed win policy sep constructed guaranteed win policy policy followed manager guarantees sep terminate state satisfies step turn claim guaranteed win policy exists iff expected utility optimal policy greater true 
proof analogous claim previously guaranteed satisfying policy bounded suggestions case show winning strategy exists player iff guaranteed win policy exist 
consider possible actions sep manager represents player 
initial choice step manager guaranteed win policy best halt immediately settle utility 
manager decides play choice step ai suggest change corresponds choosing xi player flip 
step corresponds player flip yi manager choice 
winning strategy player easy construct guaranteed win policy mapping xi flips ai change suggestions vice versa 
problem determining player winning strategy exptime hard problem determining guaranteed win policy exptime hard claim problem exptime hard 
exptime hard proof follows exactly form proof bounded suggestions case 
exptime complete unlimited number suggestions corresponding problem exptime hard 
proof theorem show compute optimal policy time polynomial assuming partitionable utility function manager sends suggestion participant 
formalisms different key observation underlying proof similar theorem 
create state space models number participants group specific members 
define summary state function ck ci number responses vi received suggestion pending 
dk di number responses vi received suggestion pending 
ek ei number responses vi received response suggestion 
follows notation indicates subtract variable specified value define transitions omitting details states responded sw noop noop sv vw equation represents manager requesting respondent switch response value state updated note suggestion probability 
equations handle uncertainty manager decides wait message arrive 
specifically second equation handles case message original response previously participant probability third equation handles case message response previously suggestion switch value probability sv 
time participant response counted variables received 
number possible states number ways dividing participants groups restriction send suggestion participant graph formed transition function states acyclic 
optimal policy may computed depth search graph total time 
abiteboul vianu yesha 
relational transducers electronic commerce 
pods 
burstein hobbs lassila martin mcilraith narayanan paolucci payne sycara zeng 
daml semantic markup language web services 
proceedings semantic web working symposium pages 
baader sattler 
description logics concrete domains aggregation 
european conference artificial intelligence pages 
berners lee hendler lassila 
semantic web 
scientific american may 
bertsekas 
dynamic programming optimal control 
athena scientific 
bonet geffner 
planning incomplete information heuristic search belief space 
artificial intelligence planning systems pages 
boutilier 
pomdp formulation preference elicitation problems 
aaai pages 
boutilier dearden goldszmidt 
exploiting structure policy construction 
proc 
ijcai 
boyan littman 
exact solutions time dependent mdps 
advances neural information processing systems nips pages 
carenini moore 
generating explanations context 
intelligent user interfaces pages 
cohen nutt 
rewriting aggregate queries views 
proc 
pods pages 
de la banda stuckey 
finding minimal unsatisfiable subsets 
proceedings th acm sigplan international conference principles practice declarative programming pages 
acm press 
doan domingos halevy 
reconciling schemas disparate data sources machine learning approach 
proc 
sigmod 
doan madhavan domingos halevy 
learning map ontologies semantic web 
www 
doorenbos etzioni weld 
scalable comparison shopping agent world wide web 
proceedings international conference autonomous agents 
druzdzel 
qualitative verbal explanations bayesian belief networks 
artificial intelligence simulation behaviour quarterly 
etzioni halevy levy mcdowell 
semantic email adding lightweight data manipulation capabilities email habitat 
sixth int 
workshop web databases 
fagin halpern moses vardi 
reasoning knowledge 
press 
ferreira schwabe lucena 
semantic web services 
ix brazilian symp 
hypermedia multimedia 
grumbach 
content aggregate views 
proc 
pods 
horvitz breese henrion 
decision theory expert systems artificial intelligence 
international journal approximate reasoning 
hull benedikt christophides su 
services look curtain 
pods 
johnson 
approximation algorithms combinatorial problems 
journal computer system sciences 
junker 
quickxplain conflict detection arbitrary constraint propagation algorithms 
ijcai workshop modelling solving problems constraints seattle wa usa aug 
jussien 
palm system explanation constraint programming 
proceedings techniques implementing constraint programming systems post conference workshop cp pages singapore sept 
jussien 
user friendly explanations constraint programming 
iclp th workshop logic programming environments cyprus dec 
parsia hendler golbeck 
semantic markup ontology rdf editor 
www mindswap org papers 
bacchus 
unrestricted nogood recording csp search 
principles practice constraint programming october 
klein shortliffe 
framework explaining decision theoretic advice 
artificial intelligence 
kumar finin joshi peng cost 
personal agent application semantic web 
aaai fall symposium personalized agents 
kushmerick doorenbos weld 
wrapper induction information extraction 
proc 
ijcai 
lassila swick 
resource description framework rdf model syntax specification 
www org tr rec rdf syntax 
recommendation 
levy mumick sagiv 
query optimization predicate move 
proc 
vldb pages 
littman 
probabilistic propositional planning representations complexity 
proce 
aaai 
littman dean kaelbling 
complexity solving markov decision problems 
proc 
uai 
malone turbak cohen 
intelligent systems 
comm 
acm 
mcbride 
jena implementing rdf model syntax specification 
proceedings semantic web workshop 
mcdowell etzioni gribble halevy levy verma 
mangrove ordinary people semantic web instant gratification 
second international semantic web conference october 
mcdowell etzioni levy 
semantic email 
proc 
thirteenth int 
www conference 
mcguinness borgida 
explaining subsumption description logics 
ijcai pages 
mcguinness pinheiro da silva 
infrastructure web explanations 
second international semantic web conference october 
mcilraith son zeng 
semantic web web services 
proceedings semantic web workshop 
mohan 
workflow management internet age 
www almaden ibm com mohan workflow pdf 
mukherjee kifer yang 
logic approaches workflow modeling verification 
logics emerging applications databases 
neches swartout moore 
explainable maintainable expert systems 
ijcai pages 
jussien boizumault 
relevant explanations constraint programming 
flairs sixteenth international florida artificial intelligence research society conference st florida usa may 
aaai press 
payne singh sycara 
calendar agents semantic web 
ieee intelligent systems 
pnueli 
temporal logic programs 
proc 
th annual ieee symposium foundations computer science 
puterman 
markov decision processes 
wiley inter science 
ross srivastava stuckey sudarshan 
foundations aggregation constraints 
principles practice constraint programming 
lncs 
springer verlag 
schiex verfaillie 
nogood recording fot static dynamic constraint satisfaction problems 
international journal artificial intelligence tools 
kifer 
logical framework scheduling workflows resource allocation constraints 
vldb 
stockmeyer chandra 
provably difficult combinatorial games 
siam journal computing 
swartout paris moore 
design explainable expert systems 
ieee expert 
wooldridge dickinson 
ontology approach automated negotiation 


rdf calendar workspace 
www org cal 

web ontology working group 
www org sw 

