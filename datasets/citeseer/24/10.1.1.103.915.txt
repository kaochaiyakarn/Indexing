cryptographically sound implementations typed information flow security dric fournet microsoft research msr inria joint centre fournet microsoft com language security confidentiality integrity policies conveniently specify permitted flows information different parts program diverse levels trust 
policies enable simple treatment security verified typing 
enforcement concrete systems involves delicate compilation issues 
consider cryptographic enforcement mechanisms imperative programs untrusted components 
programs may represent instance distributed systems connected untrusted network 
source programs security depends access control policy reading writing shared memory 
implementations shared memory unprotected security depends encryption signing 
build translation typed source programs policies cryptographic implementations 
establish correctness develop type system target language 
typing rules enforce correct usage cryptographic primitives active adversaries information flow viewpoint capture controlled forms robust declassification endorsement 
show type soundness variant non interference property show translation preserves typability 
rely concrete primitives hypotheses cryptography stated terms probabilistic polynomial time algorithms games 
model primitives commands target language 
develop uniform language model security ranging computational non interference probabilistic programs standard cryptographic hypotheses 
categories subject descriptors software engineering protection mechanisms specifying verifying reasoning programs specification techniques 
general terms security verification design languages 
keywords secure information flow confidentiality integrity noninterference type systems compilers probabilistic programs cryptography computational model 
copyright notice appear preprint option removed 

msr inria joint centre inria fr open challenges security reliably protect program implementations compilation abadi 
needs languages programmer specify security requirements reason simple abstractions tools produce code enforce requirements 
particular considering integrity confidentiality information verification distributed programs different aspects system implementations ranging application level information flow control cryptographic algorithms communication protocols depending adequate integrity confidentiality control cryptographic keys 
thesis cryptographic aspects left compiler 
language information flow security confidentiality integrity policies specified security labels equipped partial order describes permitted flows information denning zdancewic myers 
security labels associated program variables specify read confidentiality write integrity variable 
preservation confidentiality integrity policies expressed non interference properties guaranteeing knowledge attacker limited access variables augmented program execution 
consider cryptographic enforcement mechanisms confidentiality integrity imperative programs 
security model accounts active adversaries represented untrusted unknown parts program may change unprotected memory execution 
resulting programs may represent instance distributed systems connected untrusted network untrusted machines containing protected subsystems 
program semantics security depends read write policy accessing shared memory 
cryptographic implementation shared memory unprotected security depends encryption signing accessing shared memory 
basic example consider parties wish perform computation securely exchanging series messages untrusted network 
shared memory may write instance parentheses indicate code runs behalf respectively placeholders stand untrusted code may run 
assuming untrusted code access expect instance remains secret run 
needs securely pass needs securely pass draft setting flows information variables may involve communication untrusted channels shared memory may read modified active adversaries adequate encryption signing 
example assuming variables xe xs ye ys pass encrypted values signatures respectively second command may implemented xe xs kv xe kd ye ke ys ye ks order read wire format xe xs code verifies signature performs decryption extract local copy conversely writing code encrypts updated copy signs encrypted value 
implementation code rely confidentiality integrity shared variables wire variables xe xs ye ys 
relies adequate generation management keys verifying decrypting encrypting signing security assumptions cryptographic primitives 
rely public key signature scheme instance integrity verification key kv higher integrity confidentiality signing key ks high protect integrity keys purposes hardly dedicate keys variable need carefully control interaction 
instance code keys protecting adversary may achieve computation inserting code ye xe ys xs assume computation completes successfully adversary may insert ys code cause signature verification fail need qualify notion integrity computation 
symbolic versus computational cryptography contrast language approaches rely symbolic black box cryptography 
despite considerable successes protocol verification symbolic cryptography may dangerously protocol design especially regards indistinguishability properties information flow 
example cryptographic algorithms guarantee confidentiality keys values information leaked effectively recover encrypted payload fake signature see abadi rogaway 
standard assumptions adversary may learn keys traffic analysis potentially opening side channel key selection depends secret guard 
symbolic cryptography concrete model probabilistic polynomially bounded algorithms bitstrings standard security hypotheses ind cca ind cma 
gain precise realistic information flow result guarantee probability polynomial time adversary illegally obtains influences information negligible keys get long 
contributions 
starting imperative language information flow policies confidentiality integrity adapt simple type system non interference accommodate fail semantics runtime checks presence active attackers 

develop target language implementations rely cryptography probabilistic semantics 
conveniently express cryptographic algorithms active adversaries oracles implementation code precise setting 
recast standard cryptographic assumptions properties probabilistic programs 
order reconcile style properties classic information flow properties uniform framework reformulate non interference syntactically game coded language explicit commands programs active adversaries tests 

equip probabilistic language type system checking usage cryptography 
information viewpoint capture controlled forms declassification downgrading confidentiality levels variables encryption endorsement upgrading integrity levels variables signature verification 
regard type system tool structuring cryptographic proofs 
arguments main proofs expressed typed program transformations 
knowledge computationally sound type system cryptographic information flow handle active adversaries 

give typed translation simple language target language 
show source program typable translation typable property computational non interference probabilistic polynomialtime active adversaries 
knowledge cryptographic translation general information flow security 
limitations results apply large class protocols program translations important limitations general programming viewpoint 
example model concurrency avoid complications non determinism computational models see ad fournet 
prior types computational cryptography separately keep track key excludes key generations loops 
theorems rely global conditions programs polynomial variables initialized read assigned specific parts code 
enforce conditions typing checked independently achieved preliminary program transformations 
related laud pioneers information flow relying concrete cryptographic assumptions 
introduces computational non interference encryption model passive adversaries 
definitions generalize property active case adversaries may interfere normal execution programs covers integrity properties 
backes relates negligible information flows computational noninterference shows property preserved simulatability reactive systems 
laud vene propose type system verify computational non interference passive adversaries imperative language symmetric encryption dynamic key generation 
types precise tracking key dependencies system enable type decrypted values keys cf 
example 
similar line smith alp zar type system encryption decryption explicit keys assume single implicit key pair program leads clean type system presentation 
symbolic cryptography 
generalize non interference allow flows arise encryption 
model type system enforces secure cryptographically masked flows non deterministic semantics encryption 
laud investigates conditions cryptographically masked flows imply security computational model 
integrity active adversaries works consider interaction confidentiality integrity policies presence active adversaries 
interaction plays central role draft handling cryptographic keys 
zdancewic myers myers 
propose general definitions non interference active adversaries 
definitions close consider cryptography 
secure implementations information flow jif split zdancewic zheng compiler implements secure distributed systems mutually untrusted hosts sequential programs annotated information flow types 
implementation assumes communications private 
seen attempt implement verify cryptographic back jif split 
principle techniques applied instance type preserving transformations applying translation deal aspects distribution global control flow 
vaughan zdancewic design typed language high level dynamic pack unpack security primitives describe implementation authenticated encryption 
language uses labels combine confidentiality integrity expressed decentralized label model myers liskov 
correctness implementation proved symbolic model cryptography passive attackers observe encrypted memory execution program 
cryptographic implementations programming languages mention related computational model cryptography 
backes 
provide sound execution framework protocols idealized cryptographic library 
laud designs typed cryptographic language implements top framework 
type system keeps track key confidentiality integrity order meet hypotheses backes 
guarantee payload secrecy interpreted form computational non interference 
abadi 
rely laud language compile security typed variants pi calculus obtain payload secrecy integrity distributed implementations 
ad fournet design process calculus abstractions secure communications explicit cryptography establish computational soundness implementation trace equivalence properties 
contents section defines source language policies security properties type systems 
section defines target language security properties computational non interference explains cryptographic assumptions 
section presents cryptographic type system 
section presents type safe translation 
section concludes discusses 
additional details appear companion www msr inria inria fr projects sec cflow 

security policies non interference simple imperative language equip security policies 
recall standard notions non interference confidentiality integrity simple type system checking property 
preparation cryptographic implementation extend notions active adversaries 
simple imperative language source programs consist expressions commands grammar op 
en skip ranges variables ranges literal values bitstrings may represent integers strings booleans op ranges ary functions arithmetic string boolean operations 
completeness assume functions include standard bitwise operations values 
write write skip 
rv wv sets variables syntactically read written rv occurs expression wv command form occurs rv wv 
range memories finite functions variables values plus special term 
denote variable initialized memory 
assume occur commands 
write memory maps 
memory domain memory maps variable 
standard semantics programs formally defined special case section 
configurations range pairs command memory written plus inert configurations written just represent command termination final memory 
implicitly assume variables domain 
represent single step execution commands configurations reflexive transitive closure 
denote normal termination starting initial memory command completes final memory number steps 
non interference passive adversaries review annotate variables expressions commands security labels 
labels specify programmer security intent affect operational semantics 
labels form lattice obtained product lattices confidentiality levels lc integrity levels li 
write smallest largest elements upper bound elements label confidentiality level specifies read level variables integrity level specifies write level meaning confidential read fewer commands integral written commands 
projections yield confidentiality integrity parts label 
partial order defined iff 
refer decentralized label model myers liskov vaughan zdancewic concrete syntax setting lattices 
represent security policies functions variables security types form instantiated data type data security label 
overloading notations lift confidentiality integrity projections labels security types resp 

proceed define non interference confidentiality integrity relative policy 
definition memory indistinguishability 
set variables 
memories indistinguishable written implies 
definition non interference 
command memories 
intuitively long terminates non command leak information hidden part initial memory outside visible part final memory inside 
consider termination insensitive variant non interference 
refined cryptographic draft model going demand commands terminate polynomial time excluding termination leak 
standard definitions information flow security passive adversaries obtained definition letting set observed variables collect low confidentiality variables high integrity variables definition non interference passive case 
memory policy security label 
command preserves confidentiality preserves integrity active adversaries runtime errors terms attacker model memory indistinguishability accounts adversaries may partially observe outcome computation interfere 
generally interested non interference programs may include commands representing active adversaries 
approach largely follows robust declassification myers 
adversary command say reads variables confidentiality level equal writes variables integrity level equal rv wv rest denote security level adversary 
usual fixed may restrict attention product binary lattices confidentiality integrity just labels hl hh ll lh set lh 
point lattice examples 
hand intend develop implementations priori depend fixed 
consider programs obtained composing commands diverse levels trust including arbitrary adversaries fixed trusted commands 
write command context grammar obtained adding hole command obtained replacing occurrence ary command contexts distinct holes write command obtained instantiating holes vector commands language feature procedure calls command contexts model arbitrary commands access fixed privileged procedures called oracles cryptography fixed variables passing input output parameters 
example command represents command runs initialization code runs turn may invoke command number times 
handling runtime errors integrity run may clearly affected active adversary write low integrity variables 
consider instance command context hole stands low level code 
running command skip case command implicit flow high integrity command skip skip typically rejected type systems non interference 
approach restrictive case expect adversary able modify signed encrypted values long cryptographic implementation catch attack runtime error typically signature verification low integrity guard 
accordingly relax security definitions accept command contexts skip integral ground assigned value integrity preserved 
interpret read uninitialized variable runtime error 
example run command skip starting memory leaves uninitialized 
assume programs read variables uninitialized writable adversary 
property enforced independently instance relying static analyses discussed laud vene 
relax notion indistinguishability definition disregard observation uninitialized variables definition weak memory indistinguishability 
set variables 
memories weakly indistinguishable written implies 
adapt non interference definition account weak indistinguishability 
distinguish set variables left uninitialized initial memories 
intend set gather high integrity variables exclusively written definition weak non interference 
sets variables 
command weakly non memories 



definition weak non interference 
memory policy security label 
command weakly weakly non wv 
intuitively security property active adversaries reflects adversary may prevent normal completion command leaving uninitialized variables final memories learn eavesdropping complete runs command able affect final value defined high integrity variables 
preparation cryptographic refinements express security property command contexts holes active adversaries style close cryptographic games see bellare rogaway explicitly code initial memories adversaries observations 
definition non interference active adversaries 
memory policy security label 
command context non adversaries wv commands writing wv bb writing outside wv bb adversaries reading writing rv wv value running bb depend bb rv 
draft command gb bb represents game parameterized meta variable part bb initializes variables depending yields indistinguishable memories definition second part runs command context combination active adversaries yields memories definition final part command represents observer attempts guess value memory intuitively opponent player chooses commands wins running running 
example non interference simple lattice 
point lattice labels hl hh ll lh 
lh 
command context writes wv xll lh reads rv wv single hole 
show non adversaries check depend choice commands operate variables follows confidentiality game sets xll lh bb set depending xll lh sets xll depending xll lh sets depending lh xll integrity game sets bb set xll depending sets xll depending xll lh sets depending initialized lh 
example 
definition command context secure intermediate adversary secure instance skip bb break confidentiality game leaving lemma relates non interference passive active adversaries case command holes lemma 
command weakly non command context non active adversaries 
general case hole non interference active adversaries implies skip weakly converse may hold seen examples due explicit confidentiality flow due implicit integrity flow example 
lattice example consider context xll xll skip weakly non active adversaries integrity game define skip xll bb simple type system non interference type systems controlling information flows widely studied literature see sabelfeld myers survey 
recall standard type system establishing noninterference definition adapt establishing noninterference active adversaries definition 
resulting var op ei data op 
en data val data sube 
typing rules source expressions policy 
assign cond data data seq skip skip 
typing rules source commands policy 
check data hole 
additional typing rules source command contexts 
type system extended section account cryptographic primitives 
recall security types form just data security label 
projection types security labels 
brevity typing rules abbreviate type parameters lift security preorder labels types iff security policy typing judgments expressions written mean reads variables level 
typing judgments commands written mean secure writes variables level 
omit fixed policy typing judgments 
typing rules appear figures respectively 
write denote typability policy exists 
theorem states simple type system sound regard non interference definition proof simple induction number reduction steps 
theorem 
security policy security label 
non 
extend type system account active adversaries 
type command contexts placeholders stand adversaries supplementing rules 
rules implicitly apply fixed policy 
rule hole types placeholders adversaries rule enforce restriction definition allows adversaries placed holes 
rule check allows implicit integrity flows conditional expressions branch branch 
rule usefully applies error handling discussed section adversary controls conditional execution sound additional property draft restricts high integrity variables may write 
global syntactic property demands variable written series guaranteeing executed 
definition exclusive assignments 
set variables 

pn qi pi command context qi 
pn exclusively assign hole qi loop wv pi wv qi theorem states soundness extended type system command contexts holes representing adversaries 
theorem 
policy security label 
assume commands occur commands typed check exclusively assign non active adversaries 

target cryptographic language computational non interference add probabilistic primitives define target security property refinement definition specify cryptographic primitives hypotheses 
probabilistic language target language extends imperative language probabilistic functions ranged 

xm 
yn simplicity probabilistic functions may occur top level commands expressions remain deterministic 
rv wv 
function equipped associated parametric probability distribution 
special case deterministic function distribution gives probability output 
write coin tossing function returns probability single configurations consider distributions configurations ranged operational semantics commands markov chain hermanns set configurations written probabilistic steps induced function distributions 
formally rule stable guarantees states leaving transitions probabilities sum 
omit usual semantics expressions 
initial distribution distribution configurations weight configurations form lift initial memories distributions define transition system transition system input distributions output distributions see 
definition 
prob prob distribution transformer prob semantics probabilistic program sequence distribution transformations starting initial distribution 
di di di di transitive 
probability program terminates steps starting initial distribution pn dn 
pr probability starting initial distribution command completes final memory meets condition pr limn dn 
limit exists sum increases bounded 
polynomial time assumptions commands capture exactly algorithms coded probabilistic turing machines shared memory input output tapes 
polynomial runs commands correspond polynomial runs machines 
recast standard cryptographic assumptions games formal setting language quantifying instance polynomial time commands represent polynomial adversaries 
definitions assume initial distribution command gives weight uninitialized state assume algorithms probabilistic computable time bounded polynomials security parameter 
intuitively represents lengths keys 
order avoid passing explicitly assume read variable initialized security parameter 
assume primitive operations polynomial parameters distribution probabilistic primitive functions polynomial time polynomial program calls primitives written polynomial program includes implementation primitives 
rest distributions consider families distributions parameterized written known ensembles 
fixed domain variables initial distribution family distributions weight overload pr denote probability function parameterized 
security properties expressed terms games coded commands sample secret boolean interact adversary commands 
goal adversary commands write variable guess value adversary wins trivial adversary interested advantage wins probability adversary defined probability minus adversary may guess secret variables non zero probability including variables store cryptographic keys 
contrast definitions noninterference far expect advantage start relying cryptography 
expect advantage negligible function 
recall definition negligible functions definition negligible function 
function negligible exists nc nc computational non interference refine notions non interference account probabilities particular possibility information leaked corrupted negligible probability 
running commands run single probabilistic command picks random 
probabilistic code variant non interference passive adversaries definition similar introduced laud 
definition computational non interference 
polynomial command computationally non polynomial commands writing wv bb writing outside wv bb reading writing rv wv draft assigns stable true seqs true variable command cni advantage pr cni negligible 
true game definition probabilistically initialize variables 
runs 
attempts guess value sets accordingly 
property states memory distributions running separated adversary reads semantically property stated indistinguishability mao ensembles db defined bb db range commands bb 
case program deterministic property equivalent non interference definition adversary guesses correctly probability generalize property account active adversaries definition 
definition 
computational non interference active adversaries 
polynomial command context policy variables computationally non adversaries wv polynomial commands writing wv bb writing outside wv bb adversaries reading writing rv wv variable command cni pr cni rv pr cni advantage negligible 
game definition performs initialization definition runs tests resulting memory definition 
condition rv prevents reads possibly undefined memory 
expected definition definition coincides definition deterministic case 

probabilistic operational semantics encryption true skips skip fun 
yn 
yn cryptographic algorithms provide confidentiality asymmetric public key encryption 
represent target language probabilistic functions ge meet functional security properties 
definition encryption scheme 
plaintexts ciphertexts sets polynomially bounded bitstrings indexed 
asymmetric encryption scheme triple algorithms ge ge key generation ranges encryption ranges ciphertexts decryption ranges plaintexts ke kd ge plaintexts ke kd definition abstracts details input validation possibility decryption visibly fails ill formed inputs instance 
hand need specify bound set plaintexts going require encryption hides length plaintexts 
definition decryption encryption input outside plaintexts may fail instance input long confidentiality input preserved 
different notions security encryption 
introduced rackoff simon strongest usually considered realized decisional diffie hellman assumption 
code definition target language rely auxiliary primitive operations lists nil empty list concatenation membership test 
definition ind cca security 
consider commands ke ke log log log kd cca log nil ke kd ge encryption scheme ge provides indistinguishability adaptive chosen ciphertext attacks advantage pr cca negligible polynomial command context kd rv kd ke log wv 
definition security cca probabilistic command represents cryptographic game adversary challenged guess secret bit interacting instance encryption scheme 
command models adversary attempts guess follows perform arbitrary polynomial time computation variables excluded definition 
instance draft may include commands run algorithms ge values obtain compute including encryption key ke 
invoke encryption decryption oracles modelled commands values parameters point code 
usual presentation ind cca adversary calls encryption oracle definitions equivalent see bellare 
set variable terminate report guess value bit contrast commands access challenge bit decryption key log 
encryption oracle selects values stored encrypt depending maintains log encrypted values 
decryption oracle provides decryption value produced run game adversary wins adversary wins probability security property states adversary meets hypothesis better despite control usage key 
security definition assumes adversary provides plaintexts encryption oracle 
particular cover complex usages encryptions encrypted plaintexts may depend decryption keys 
said ind cca says confidentiality case plaintexts may depend decryption key see abadi rogaway 
situation referred key cycle need excluded typing 
simplicity introduce primitives symmetric shared key encryption definition similar adversary access encryption key 
example 
assume adversary reads lh ke 
command ke kd ge ke lh ke computationally non cni 
particular lh negligible probability ind cca encryption function probabilistic 
conversely commands ke kd ge ke lh kd ke ke kd ge ge ke cni ind cca secure encryption schemes case encryption function properly key second command key cycle ke encrypts kd ind cca give assurance encryptions decryption key third command key selection depends secret value ind cca prevent extracting comparing ke 
example confidentiality despite active adversaries 
consider commands mixing local secrets adversary data shared access keys ke kd low confidentiality variables 
pu eu hu xu kd su hu lu su ke command ke kd ge leak information xu adversary controls values eu lu xu 
command clearly protect integrity xu 
cryptographic signatures second cryptographic scheme provides integrity protection asymmetric public key signatures 
definition signature scheme 
plaintexts sets polynomially bound bitstrings indexed 
signature scheme triple algorithms gs gs key generation ranges signing ranges signature verification ranges ks kv gs plaintexts ks kv 
convenience assume deterministic test expressions conditional commands 
notions security signature schemes 
standard notion introduced goldwasser 
definition cma security 
consider commands ks log log cma ks kv gs log nil log kv signature scheme gs secure forgery adaptive chosen message attack pr cma negligible polynomial command context read ks write ks kv log 
definition command represents adversary invoke oracle command obtaining signature message read write variables may run verification algorithm access verification key kv read write variables kv log 
conversely direct access signing key ks 
game intuitively says requesting signatures wants signing oracle adversary produce pair signature message signed recorded log 

type system cryptography extend type system section probabilistic programs special rules typing usage cryptography 
rest assume fixed schemes encryption signing meet definitions sets plaintexts include encrypted signed values 
types supplement data type data section types cryptographic values 
data type safety important computational soundness inasmuch security primitives holds called properly generated keys keys 
help prevent key cycles 
grammar security types security types data data types payloads enc ke kd data types encryption sig ks kv data types signing draft gene ke ke kd kd ke kd ge encrypt ke ke enc ke decrypt enc kd kd kd data data security label key label map tags security types explained 
static key labels labels keep track keys grouped key generation commands 
labels attached types generated key pairs propagated types derived cryptographic materials 
match usage key pairs prevent key cycles prevent generating multiple signatures key tag 
tagged signatures cryptographic signatures computed hashed texts prefixed tag descriptor specializes usage signing key 
accordingly order precisely type expressions form constant tag types signing embed partial map tags usable key security type corresponding signed values 
essentially distinct key signature 
example tagged signatures 
command context ks kv gs 
typing rules probabilistic commands policy 
ks ll lh ks ll lh kv cni typable adversary read write ll ll 
hand class adversaries command context obtained erasing tags cni integrity seen adversary overwrites value signature second ones lh bb ll ll lh subtyping rely subtyping rules source type system subtyping data types just syntactic equality leave interesting subtyping 
note subtyping kd data sound general may hide key dependencies encryption cycles 
typing rules type system extends source type system figures rules commands call probabilistic functions explained 
additional rule expressions typing signature verifications rule identical rule op cryptographic data types ks ks kv kv ks kv gs sign ks ks sig ks verify kv kv kv data kv sig kv kv kv data rule generic rule typing probabilistic functions requires variables data types prevents explicit flows parameters results particular applies functions case rely cryptographic assumptions 
soundness depends fact probabilistic function side effects evaluation create correlation successive calls 
rest rules cryptography permit forms declassification encryptions flows higher lower confidentiality levels endorsement signature checks flows lower higher integrity levels 
soundness rules depends cryptographic assumptions additional conditions policies programs stated section 
hypotheses bind key types variables ks kv map tags payload types 
process label meet labels assigned variables 
sign hypotheses bind types variables ks involved signing types related sets typing guarantees associated signatures signing key key label tag intuitively care integrity sign correct values confidentiality ks adversary sign incorrect values 
records flow rule assign 
records integrity flow signing key signature value 
conversely confidentiality flow ks ignored sound inasmuch ks signing 
verify rule structure similar rule check 
soundness proof game rewritings replace commands typable verify commands typable check 
permits limited form endorsement lower integrity variable assigned higher integrity variable guard performs specific signature verification 
hypotheses check verification key type relate type tag verification type typing verification expression relies rule records ordinary flows kv condition guard enforces draft identical data types 
typing records level guarded command 
constraint confidentiality levels records implicit confidentiality flow guard assignment guarded command 
contrast normal assignment assign constraint relating integrity integrity follows dynamic verification 
integrity constraint records flow verification key gene hypotheses bind types variables ke kd key label payload type type plaintexts encrypted decrypted 
constraint imposes condition confidentiality decryption key greater equal confidentiality plaintext 
encrypt hypotheses bind types variables ke involved encryption types related describe typing assumptions encryption key ke 
label typing ke records flow ke subtyping ke 
hypothesis records integrity flow conversely constraint confidentiality flow encryption form declassification rule sound cryptographic assumptions 
decrypt hypotheses bind types variables kd involved decryption types related label records flows kd normal assignment 
stating soundness result illustrate type system commands 
example bad decrypted key 
consider command ke kd ge ge xll ke kd xll kd payload types data ke lh define follows ke ke lh kd kd hh kd hh xll enc ll enc case command insecure key kd decryption match key ke encryption 
decrypted value unspecified valid encryption key encryption unspecified easily construct algorithms ge ind cca final encryption leaks parameters command typable data types kd compatible 
problem apparent laud vene system decryption yield key types decrypted value just ordinary data remain secret irrespective distribution final encryption typable 
setting address problem order guarantee integrity confidentiality decryption 
program typable able type similar programs rely decrypted keys example encrypt sign encryption key 
consider command context ke kd ge ge ks kv gs ke ks xll xll kv lh xll lh kd example signature verification valid decrypted key 
adversary changes signature stored signature verification fails leaving uninitialized 
program typable example extended types sig enc ll ll ks ks lh ks kv ks hh kv enc lh lh enc lh enc lh 
computational soundness give additional conditions policies programs state main soundness theorem 
require integrity encryption keys high protecting confidentiality plaintexts confidentiality decryption keys high protecting integrity signed values 
constraints relate integrity confidentiality levels depending capabilities adversary 
definition robust policy 
policy encryption key type ke robust 
signing key type ks robust dom 
security type policy robust encryption signing key types robust 
statements robustness key types alternatives state protection provided key irrelevant adversary read plaintexts encryption write signed values signing second alternatives demand key sufficiently protected 
cryptographic assumptions state additional safety conditions soundness 
definition 
command context safe 
commands guarded signature verification test typed check exclusively assign reads uninitialized variables 
signing key label tag pair signing 

key label dynamic key generation 

key variable read initialized conditions needed apply cryptographic games soundness proof target type system instance guarantee integrity decrypted values 
enforced static analysis instance collecting relevant static occurrences variables forbidding signing encryption key generation loops 
condition helps deal runtime errors discussed section 
condition prevents signature replay attacks illustrated example 
rely static key label constraint shared aliases signing key 
condition prevents decryption key mismatches illustrated example 
condition recalls assumption uninitialized variables keys 
relying conditions obtain typed programs computationally non definition 
draft theorem 
security label 
policy robust 
safe polynomial time command context 
satisfies computational non interference adversaries 
proof relies series typability preserving program transformations match structure games cryptographic security assumptions definitions 
transformations eliminate cryptographic primitives static key label time 
eliminating static keypair signing verification values signed verified passed auxiliary shared high integrity variables left conditionals typable check verify 
memory protection protocol preparation program translation define protocol sharing encrypted signed memory 
typing assumptions detailed section 
inits ks kv ks kv gs ke kd ke kd ge read xe xs kd kv xe xs kv xe kd write xs xe ke ks ke xs ks xe command inits generates keys signing verification 
command generates keys encryption decryption 
command context read attempts read xe xs 
verifies presumed signature xs specifically tag verification succeeds ciphertext copied temporary variable decrypted command runs 
command silently fails 
conversely command write writes xe xs encrypting signing value 
temporary variables matter typing enable label integrity higher xe 
depending relative levels similar simpler protocols may protecting confidentiality integrity 
example key establishment 
relying protocol show hosts may dynamically establish new session keys long term keys 
assume variables prefix local readable writable variables prefix local respectively 
command context inits ke kd inits ks kv ke kd ks kv write xs xe xe tk read xe xs xe tk command line models hypothesis share correctly generated long term keys private signing key private decryption key 
third line represents session key generation local keys generated 
keys concatenated sent shared memory xe xs write command 
final line represents reception session keys type command need slight extension typing rules concatenation 
alternatively type variant command runs read write protocol executed keys ke kd ks kv 
hand optimize protocol avoiding encryption public keys ke kv 

cryptographic translation ready describe verify general cryptographic protection mechanisms shared memory 
illustrate approach provide simple translation programs rely shared memory security policies programs rely cryptography 
modelling distributed systems model distributed systems series commands source language located different hosts communicate shared memory 
untrusted shared memory may conservatively represent public network protocol stack example 
consider source systems form 
pn control flow threads statically known 
set host names 
host may successive threads may share private state host local memory 
define source systems sequences threads thread annotated unique thread identifier mapping thread identifiers hosts 
holes appear source systems translation insert translated threads 
assume set variables shared hosts require cryptographic protection 
obtain realistic distributed implementation set contain variables shared hosts possibly initialization variables 
assume occurrence variable expression correctly annotated writer thread write thread written expression gets evaluated 
thread particular variable may read written program correctly annotated 
annotations inferred checked conservative static analyses 
translation help meet requirements signatures prevent replay attacks know verification key tag read 
summary source inputs translation consist policy subset domain indicating variables protect typed correctly annotated system translation takes input systems annotated commands annotations affect source command typing erasing thread writer annotations simple type system section figures 
public key infrastructure assume public key infrastructure signature verification keys host signing key knows host verification key initialize keys running command init gs auxiliary variables translation uses naming conventions types variables 
assume variables introduced translation occur source system pairwise distinct 
source variable translation associates shared variables xe containing encrypted value xs containing signature xe 
addition thread accesses source program translation uses series local variables local copy xe local draft buffers encrypted value xv local buffer verification 
translation uses functions variables holding encryption decryption keys ke encryption key writing kd decryption key reading assume functions injective contrary subject typing constraints keys protect shared variables 
initialize variables range functions running command init kd ke ge key pair ke kd initialized just 
translating security policies translate giving types target variables security policy coincides dom maps translation variables types 
simplicity single security label unprotected shared memory encryption signing security level 
alternatively parameterize translation target security labels write set constraints satisfied order preserve typability 
host ks kh kv kh kh unique static key label host label mapping tags security types security labels subject constraints 

source types cryptography data 
xe enc kx xs sig enc kx ke ke kx kd kd kx kx static unique key label keypair ke kd key label 
thread accesses xe enc kx xv enc kx writes host constraints enc kx translating systems threads translate commands relying command definitions notations memory protocol section 
translation protects thread pi decoding shared variable syntactically read pi local memory verifications succeed running variant pi local memory committing syntactically written variable back shared encrypted memory 
thread pi composition command contexts read xv xe xs xe kd annotated variables rv pi sequence assignments xv variables xv assigned sequential composition commands write xs xe ke wv pi arrive top level translation pi pi 
pn init 
pn translated thread variable written 
ensures tag pair composed unique thread identifier variable name 
auxiliary assignments ensure local variables assigned verifications succeed guarantee exclusive assignments variables 
example 
point lattice consider translation hh threads located hosts share single key pair ke kd encryptions 
translated threads ke kd discussion translation systematically performs cryptographic operations access shared variable believe type system supports variety options selected advanced translations 
illustrated example translation may reduce cryptographic costs clustering variables level fewer larger shared variables representing messages pages distributed file system instance 
depending source labels translation may select simpler read write protocol omit encryption signing low integrity low confidentiality source variables 
expressive types cryptographic payloads translation may jointly sign values 
instance single signature suffices executing thread may typable associating constant tag series authenticated types fixed series variable writes 
reading writing high confidentiality command runs read write protocols observable 
avoid translation pre fetches variables potentially read high confidentiality guards rewrite variables potentially written high confidentiality guard 
consider instance second source thread example case added directly translated update run write protocol high confidentiality guard adversary able compare ciphertexts xe running thread infer value observing second thread updates encrypted value 
translation local value irrespective looks opaque different previous value polynomial adversary 
correctness verify absence active adversary translation functionally correct translated system terminates results source system 
translated memory includes cryptographic materials domain condition statement excludes values 
source configuration uninitialized memory defined follows host thread occurs xe xs ke kd xv xe defined uninitialized dom distribution configurations 
draft theorem functional adequacy 
correctly annotated source system memory skip dt distribution dt gives probability configurations coincides joint domain 
theorem distribution final states dt may give positive probabilities range different memories instance different keys different encrypted values memories coincide source variables outside 
obtain adequacy final values source variables copying variables outside fixed need assume polynomial run select sets plaintexts definitions include values encrypted signed run 
consider security translation assumption source system typed 
theorem typability preservation 
correctly annotated source system 

computational soundness typing theorem obtain theorem computational soundness translation 
security label source security policy dom 
pn correctly annotated source system 
pn exclusively assign robust policy computationally adversaries 

cryptographic type system verifying correct usage encryption signing schemes programs information flow security policies 
develop secure translation imperative programs share protected memory 
security defined computational non interference property active probabilistic polynomial adversaries 
extend type system translation obtain efficient implementations larger class programs instance dependent types tags signing keys extending subtyping relation supporting symmetric key cryptography 
independently interesting extend class security properties preserved cryptographic implementations instance account controlled forms endorsements source programs 
acknowledgments ricardo corin james leifer jean jacques vy andrei sabelfeld nobuko yoshida anonymous reviewers helpful comments 
mart abadi 
protection programming language translations 
th international colloquium automata languages programming volume lncs pages 
springer verlag 
mart abadi phillip rogaway 
reconciling views cryptography computational soundness formal encryption 
journal cryptology 
mart abadi ricardo corin dric fournet 
computational secrecy typing pi calculus 
volume lncs pages 
springer verlag november 
pedro ad dric fournet 
cryptographically sound implementations communicating processes extended 
rd international colloquium automata languages programming volume lncs pages 
springer verlag july 
daniel andrei sabelfeld 
flows 
proceedings th international static analysis symposium lncs seoul korea 
springer verlag 
backes pfitzmann waidner 
composable cryptographic library nested operations 
th acm conference computer communications security pages 
michael backes 
quantifying probabilistic information flow computational reactive systems 
esorics volume lncs pages 
springer verlag september 
mihir bellare phillip rogaway 
game playing technique december 
www cs ucdavis edu rogaway papers games html 
mihir bellare alexandra silvio micali 
public key encryption multi user setting security proofs improvements 
eu pages 
dorothy denning 
lattice model secure information flow 
commun 
acm 
shafi goldwasser silvio micali ronald rivest 
digital signature scheme secure adaptive chosen message attack 
siam journal computing 
holger hermanns 
interactive markov chains quest quantified quality 
springer berlin heidelberg 
laud 
secrecy types simulatable cryptographic library 
th acm conference computer communications security pages 
laud 
semantics program analysis computationally secure information flow 
th european symposium programming esop volume lncs 
springer verlag april 
laud 
computational soundness cryptographically masked flows 
proceedings th symposium principles programming languages san francisco usa 
acm press 
laud vene 
type system computationally secure information flow 
fundamentals computation theory lncs pages 
springer verlag 
mao 
modern cryptography theory practice 
prentice hall professional technical 
david 
analyse de programmes par interpr tation 
phd thesis universit paris ix dauphine 
andrew myers barbara liskov 
protecting privacy decentralized label model 
acm trans 
softw 
eng 
methodol 
andrew myers andrei sabelfeld steve zdancewic 
enforcing robust declassification qualified robustness 
journal computer security 
charles rackoff daniel simon 
non interactive zero knowledge proof knowledge chosen ciphertext attack 
crypto volume lncs pages 
springer verlag 
andrei sabelfeld andrew myers 
language information flow security 
ieee journal selected areas communications 
geoffrey smith rafael alp zar 
secure information flow random assignment encryption 
proceedings fourth acm workshop formal methods security pages 
jeffrey vaughan steve zdancewic 
cryptographic decentralized label model 
ieee symposium security privacy pages may 
steve zdancewic andrew myers 
robust declassification 
th ieee computer security foundations workshop pages 
steve zdancewic zheng nathaniel nystrom andrew myers 
secure program partitioning 
acm trans 
comput 
syst 
zheng steve chong andrew myers steve zdancewic 
replication partitioning build secure distributed systems 
th ieee symposium security privacy 
draft 
