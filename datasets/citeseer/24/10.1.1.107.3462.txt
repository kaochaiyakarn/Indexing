lectures curry howard isomorphism morten heine rensen university copenhagen urzyczyn university warsaw preface curry howard isomorphism states amazing correspondence systems formal logic encountered proof theory computational calculi type theory 
instance minimal propositional logic corresponds simply typed calculus order logic corresponds dependent types second order logic corresponds polymorphic types isomorphism aspects syntactic level formulas correspond types proofs correspond terms provability corresponds inhabitation proof normalization corresponds term reduction isomorphism 
instance old idea due brouwer kolmogorov heyting formalized kleene realizability interpretation constructive proof implication procedure transforms proofs antecedent proofs succedent curry howard isomorphism gives syntactic representations procedures 
notes give parts proof theory related aspects type theory relevant curry howard isomorphism 
outline calculi type theory build calculus notes chapter type free calculus 
derives rudimentary properties reduction including church rosser theorem 
presents kleene theorem stating recursive functions definable church theorem stating equality undecidable 
explained important part curry howard isomorphism idea constructive proof implication certain procedure 
calls elaboration meant constructive proofs chapter presents intuitionistic propositional logic 
chapter presents natural deduction formulation minimal intuitionistic propositional logic 
usual semantics terms heyting algebras terms kripke models introduced explained ii preface basis boolean algebras soundness completeness results proved 
informal proof semantics called 
chapter presents simply typed calculus fundamental properties subject reduction property church rosser property 
distinction simply typed calculus la church la curry introduced uniqueness types property fails curry system proved church system 
equivalence systems certain sense established 
chapter proves weak normalization property turing prawitz method ends schwichtenberg theorem stating numeric functions representable simply typed calculus exactly extended polynomials 
provides background material presentation curry howard isomorphism chapter appears context natural deduction minimal propositional logic typed calculus 
chapter presents formulation natural deduction proof theory literature facilitates finer distinction similar proofs 
exact correspondence natural deduction minimal propositional logic simply typed calculus 
extension product sum types discussed 
brief part proof theoretical applications weak normalization property chapter ends proof strong normalization tait girard method phrased terms saturated sets 
chapter presents variation curry howard isomorphism replaces natural deduction hilbert style proofs simply typed calculus simply typed combinatory logic 
type free combinators weak reduction church rosser property usual translations calculus combinators vice versa introduced shown preserve desired properties pertaining weak reduction reduction 
combinators types introduced translations studied setting 
hilbert style proofs introduced connection combinators types proved 
chapter ends part subsystems combinators relevance linearity play role 
having seen logics equivalently calculi types chapter studies decision problems calculi mainly type checking type reconstruction type inhabitation problem 
type reconstruction problem shown complete reduction unification reduction unification detail 
type inhabitation problem shown pspace complete reduction satisfiability problem classical second order propositional formulas 
chapter ends statman theorem stating equality typed terms non elementary 
outline iii introducing natural deduction systems hilbert style systems notes introduce chapter gentzen sequent calculus systems propositional logic 
classical intuitionistic variants introduced 
cases somewhat rare presentation taken prawitz assumptions sets sequences adopted 
intuitionistic system cut elimination theorem mentioned subformula property decidability logic inferred 
term assignment sequent calculus proofs studied 
approach terms simply typed calculus 
approach connection normal forms cut free proofs studied detail 
second approach terms intended mimic exactly rules calculus assignment prove cut elimination theorem compact way 
remaining chapters study variations curry howard isomorphism expressive type systems logics 
chapter consider elementary connections natural deduction classical propositional logic simply typed calculus control operators particular correspondence classical proof normalization reduction control operators 
kolmogorov embedding classical logic intuitionistic logic shown induce continuation passing style translation eliminates control operators 
chapter order logic 
presentation syntax quantifiers proof systems interpretations seen earlier chapters generalized order case 
chapter presents dependent types manifest calculus strong normalization property proved translation simply typed calculus 
variant la curry introduced 
translation shown term typable la curry iff typable simply typed calculus 
shows type reconstruction harder simply typed calculus type checking problem la curry turns undecidable 
result chapter shows firstorder logic encoded chapter study arithmetic 
chapter introduces peano arithmetic pa briefly recalls del theorems usual result stating exactly recursive functions represented peano arithmetic 
notion provably total recursive function introduced 
heyting arithmetic ha introduced kreisel theorem stating provable totality ha pa coincide 
kleene realizability interpretation introduced way formalizing prove consistency ha 
del system introduced proved strongly normalizing 
failure proofs property mentioned 
result stating functions definable functions provably total peano arithmetic 
del dialectica interpretation iv preface prove consistency ha prove functions provably total peano arithmetic definable chapter second order logic polymorphism 
sake simplicity second order propositional systems considered 
natural deduction heyting algebras kripke models extended new setting 
polymorphic calculus correspondence second order logic developed 
part definability data types curry version polymorphic calculus introduced wells theorem stating type reconstruction type checking undecidable mentioned 
strong normalization property proved 
chapter chapter presents cube pure type systems 
barendregt cube systems shown equivalent previous formulations means classification result 
cube pure type systems developed detail 
notes chapter provided number exercises 
recommend reader try possible 
notes answers hints provided exercises 
notes cover material sources girard lafont taylor proofs types cambridge tracts theoretical computer science 
troelstra schwichtenberg basic proof theory cambridge tracts theoretical computer science 
hindley basic simple type theory cambridge tracts theoretical computer science 
barendregt lambda calculi types pages abramsky gabbay maibaum editors handbook logic computer science volume ii oxford university press 
sources excellent supplementary reading 
notes largely self contained greater appreciation parts probably obtained readers familiar mathematical logic recursion theory complexity 
recommend textbooks basic areas mendelson mathematical logic fourth edition chapman hall london 
part quite incomplete due progress character notes 
notes jones computability complexity programming perspective mit press 
notes semester graduate ph course department computer science university copenhagen diku 
roughly chapter lecture leaving material 
notes progress conceived having proof read carefully detail 
grateful students attending course pointing numerous typos spotting actual mistakes suggesting improvements exposition 
joint possible visiting position funded university copenhagen held second author diku winter summer academic year 
may vi contents preface outline notes iv type free calculus terms 
reduction 
informal interpretation 
church rosser theorem 
expressibility undecidability 
historical remarks 
exercises 
intuitionistic logic intuitive semantics 
natural deduction 
algebraic semantics classical logic 
heyting algebras 
kripke semantics 
implicational fragment 
exercises 
simply typed calculus simply typed calculus la curry 
simply typed calculus 
church versus curry typing 
normalization 
expressibility 
exercises 
vii viii contents curry howard isomorphism natural deduction contexts 
curry howard isomorphism 
consistency normalization 
strong normalization 
historical remarks 
exercises 
proofs combinators combinatory logic 
typed combinators 
hilbert style proofs 
relevance linearity 
historical remarks 
exercises 
type checking related problems hard complete 
variants 
order unification 
type reconstruction algorithm 
eta reductions 
type inhabitation 
equality typed terms exercises sequent calculus classical sequent calculus intuitionistic sequent calculus cut elimination term assignment sequent calculus general case alternative term assignment exercises classical logic control operators classical propositional logic implicational fragment full system terms classical proofs classical proof normalization definability pairs sums embedding intuitionistic propositional logic control operators cps translations historical remarks contents ix exercises order logic syntax order logic intuitive semantics proof systems semantics exercises dependent types system rules properties dependent types la curry existential quantification correspondence order logic exercises order arithmetic del language arithmetic peano arithmetic representable provably recursive functions heyting arithmetic kleene realizability interpretation del system del dialectica interpretation exercises second order logic polymorphism propositional second order formulas semantics polymorphic lambda calculus system expressive power curry style polymorphism strong normalization second order typed calculus exercises cube pure type systems barendregt cube example derivations classification equivalence previous formulations pure type systems examples pure type systems contents properties pure type systems barendregt geuvers klop conjecture solutions hints selected exercises index chapter type free calculus calculus collection formal theories interest computer science logic 
calculus related systems combinatory logic originally proposed foundation mathematics church curry proposed systems subsequently shown inconsistent church students kleene rosser 
certain subsystem consisting terms equipped called reduction turned useful formalizing intuitive notion effective computability led church thesis stating definability appropriate formalization intuitive notion effective computability 
study subsystem proved consistent church rosser main inspiration development recursion theory 
invention physical computers came programming languages calculus proved useful tool design implementation theory programming languages 
instance calculus may considered idealized sublanguage programming languages lisp 
calculus useful expressing semantics programming languages done denotational semantics 
hindley seldin calculus combinatory logic regarded test beds study higher order programming languages techniques tried simple languages developed applied practical languages calculus called type free untyped distinguish variants types play role variants introduced chapter 

terms objects study calculus terms 
order introduce convenient introduce notion pre term 
chapter 
type free calculus 
definition 

denote infinite alphabet 
set pre terms set strings defined grammar 
example 
pre terms 
ii iii iv 
notation 
uppercase letters subscripts denote arbitrary elements lowercase letters subscripts denote arbitrary elements 
terminology 
pre term form element called variable ii pre term form called abstraction iii pre term form called application 
heavy parentheses cumbersome 
introduce standard conventions omitting parentheses introducing ambiguity 
shall conventions prohibition agreement see 

notation 
shorthands lm ii iii iv xn 
omit outermost parentheses 


shorthands concern nested applications abstractions respectively 
ones concern applications nested inside abstractions vice versa respectively 
remember shorthands think application associating left think abstractions extending far right possible 

terms abstracting number variables variable accompanied abstraction 
convenient introduce shorthand 

notation 
write xn xn special case write 

abstractions written corresponding symbol applications written simply juxtaposition 
corresponding shorthand applications 

example 
pre terms example written follows respectively ii iii iv 


conventions mentioned remainder notes 
refrain wholly partly find convenient 
instance prefer write term example 

definition 
form define set fv free variables follows 
fv fv fv fv fv fv 
fv called closed 

example 
denote distinct variables 
fv xyz ii fv iii fv 

definition 
form substitution written defined follows fv fv fv fv 
chapter 
type free calculus chosen vi minimal vi fv fv clause 

example 
ifx distinct variables certain variable yz yz 
definition 
equivalence written smallest relation closed rules ify fv pz zp zp 
example 
denote different variables 
ii iii iv 
definition 
define equivalence class define set terms 
warning 
notion pre term associated explicit distinction pre terms terms introduced standard literature 
customary call pre terms terms informally equivalent terms identified remainder notes shall exclusively concerned terms pre terms 
convenient introduce 

terms 
notation 
write remainder 
leads ambiguity pre term term 
remainder notes construed explicitly stated 
section definitions introducing notions free variables substitution terms recall far notions introduced pre terms 
definitions provide example rigorously understand definitions involving terms 

definition 
form define set fv free variables follows 
fv fv fv fv fv fv 
fv called closed 


notation really mean define fv map subsets satisfying rules fv fv fv fv fv fv 
strictly speaking demonstrate function uniqueness function existence 
uniqueness established showing functions fv fv satisfying equations term results fv fv term 
proof proceeds induction number symbols member equivalence class 
demonstrate existence consider map equivalence class picks member takes free variables 
choice member yields set variables map defined easily seen satisfy rules 
rest notes considerations left implicit 

definition 
form substitution written defined follows fv 

example 
ii chapter 
type free calculus 
reduction introduce reduction terms 

definition 
smallest relation closed rules pz zp zp term form called redex called contractum 
term normal form term notions reduction reduction considered chapter 
omit notions redex reduction 
definition 
relation multi step reduction transitive reflexive closure smallest relation closed rules 
ii relation equality transitive reflexive symmetric closure smallest relation closed rules 
warning 
notes symbol qualification express fact objects pre terms terms identical 
symbol literature equality 

example 
xx ii iii iv yz 

informal interpretation 
informal interpretation informally terms express functions applications functions pure form 
instance term intuitively denotes function maps argument identity function 
similar notation employed mathematics 
string alphabet symbols 
equivalence class objects function certain set pairs 
difference program written language mathematical function computes addition 
notation name abstracted variable significant identify term intuitively denotes function maps argument function maps argument identity function 
similar programming languages function may return function result 
related term intuitively denotes function maps argument function argument returns argument 
terms intuitively denote functions way invoke term expressed application 
term ik expresses application intuitively denotes function denotes function may function argument 
similar programming languages procedure may receive procedure argument 
mathematics usually write application function say argument say argument parentheses 
calculus write just keeping notation mind 
parentheses omitted instance term applied second expects argument applied chapter 
type free calculus intuitively denotes function denotes argument value function argument denoted term arises substituting term exactly term similar common practice mathematics get application value substituting body definition process calculating values formalized reduction 
arises replacing redex part form contractum 
instance ik relation formalizes process computing result 
identifies terms intuitively denote function 
note calculus type free formalism 
common mathematical practice insist terms denote functions certain domains natural numbers arguments drawn domains 
particular may self application term may apply term term type free nature calculus leads interesting phenomena instance term may reduce terms infinite reduction sequences 

church rosser theorem term may contain redexes parts form may instance ii ii 
church rosser theorem ii ki church rosser theorem proved states single term particular normal forms terms admit reductions term reductions zero steps 
similar fact calculate value arithmetical expression result independent order calculations 

definition 
relation satisfies diamond property exists 

lemma 
relation suppose transitive closure 
satisfies diamond property 
proof 
show induction mn implies nn nn mn nn 
property show induction nm mm mm nm mm 
relation 
transitive closure relation satisfying prp pr pr pr reflexive closure relation satisfying prp pr pr chapter 
type free calculus assume 
transitive closure 
shown find 
transitive closure 

definition 
relation defined pq 
lemma 

proof 
induction definition case proceed induction 
lemma 
satisfies diamond property exists 
proof 
induction definition lemma 

lemma 
transitive closure proof 
clearly particular 

theorem church rosser 
exists 
proof tait martin 
lemmas 

corollary 
ifm exists 
corollary 
ifm normal form 
recall relations defined earlier 

expressibility undecidability 
corollary 
normal forms 
example 


consider lambda calculus equational theory formal theory formulas form preceding example establishes consistency theory sense exists formula proved 
may weak property compared prove contradiction suitable notion contradiction ordinary logic 
note formal theories notion contradiction expressed provability implies provability formulas 
consistency equally defined prove 

expressibility undecidability informal explanation meaning terms remains explain sense reduction precisely express computation 
section show calculus seen alternative formulation recursion theory 
gives way representing numbers terms 

definition 
define times iterated application ii church numeral cn term 
example 
ii iii sz iv sz 
cn 

cn number represented inside calculus 
shows arithmetic church numerals 
chapter 
type free calculus 
proposition rosser 
proof 
ys ae cn cm cn cn cm cn ae cn cm cnm 
cn sz sz cn cm cn cm cn cm sz cn cn similar properties multiplication exponentiation left exercises 


recall intuitively denote object 
instance ii terms intuitively denote identity function 
consider terms easy calculate sz cn cn cn cn terms denote informally successor function church numerals terms equal 
shows define booleans conditionals inside calculus 

expressibility undecidability 
proposition 
define proof 
true false bpq 
true false true pq proof false similar 
define pairs calculus 

proposition 
define proof 
pq proof similar 


note pairing operator surjective 


construction easily generalized tuples mn projections 
gives way expressing recursion calculus 
chapter 
type free calculus 
theorem fixed point theorem 
fx fact term proof 
put xx xx xx xx xx xx xx xx xx xx required 

corollary 
proof 
put required 
corollary allows write recursive definitions terms may define term satisfying fixed point equation term occurs inside may terms satisfying equation equal 

example 
term expresses condition true false define successor function see 
suppose want compute calculus number smallest number greater satisfies condition 
expressed term 
expressibility undecidability example fc sc far informal terms express certain functions 
notion precise follows 

definition 
numeric function map 
ii numeric function definable nm fcn cnm 
nm 

church rosser property ii implies fact fcn cnm 
nm similar notions partial functions see 
shall show recursive functions definable 

definition 
class recursive functions smallest class numeric functions containing initial functions projections nm ni ii successor iii zero 
closed composition primitive recursion minimization composition hk recursive defined nm nm hk nm 
ii primitive recursion recursive defined nm nm nm nm nm 
chapter 
type free calculus iii minimization recursive nm nm defined follows recursive nm nm 
lemma 
initial functions definable 
proof 
xm xi necessary properties hold 

lemma 
definable functions closed composition 
proof 
definable hk definable hk defined definable nm nm hk nm xm xm hk xm easy verify 

lemma 
definable functions closed primitive recursion 
proof 
definable definable defined nm nm nm nm nm definable xm gx xn xm 
fcn cn cnm cn gcn cnm gcn cnm 
nm denotes smallest number satisfying equation 
nm 

expressibility undecidability cn 
nm cn hc 
nm cn cn cnm cn 
nm 
nm cn 
nm gcn cnm cn 
nm required property follows 

lemma 
definable functions closed minimization 
proof 
definable nm nm defined definable nm nm xm zero 
gx xm 
zero 
false true leave exercise verify required properties hold 
seen form completeness calculus 

theorem kleene 
recursive functions definable 
proof 
lemmas 
converse holds show routine argument 
similar results hold partial functions see 

definition 
bijective recursive function 
map defined vi take possible number alpha representative define 
chapter 
type free calculus 
definition 

closed ii non iii recursive recursive 

theorem curry scott 
non trivial closed 
recursive 
proof 
suppose recursive 
define exists 
zero 
contradiction 


theorem analogous rice theorem known recursion theory 
variant halting problem 
informally states formal theory equality mentioned undecidable 

corollary church 
true recursive 

corollary 
set recursive normal form 
infer results known theorem due church stating order predicate calculus undecidable 

historical remarks 
historical remarks history calculus see 
hand information may obtained rosser kleene eye witness statements curry feys book contains wealth historical information 
curry church original aims subject renewed attention see 

exercises 
exercise 
show step step application conventions notation allows express pre terms example done example 

exercise 
abbreviations correct 


xy 
yz 

xy 

exercise 
identifications correct 



exercise 
terms normal forms 



ki 
ki xx ki yy 
xx yy 

exercise 
path term finite infinite sequence 
chapter 
type free calculus term normal form called weakly normalizing just normalizing reduction paths terminate normal form 
term strongly normalizing reduction paths eventually terminate normal forms term infinite reduction paths 
terms preceding exercise weakly strongly normalizing 
cases different reduction paths lead different normal forms 

exercise 
true 

xz yz 



exercise 
prove church rosser theorem exists 
extend proof technique yield proof church rosser theorem 

exercise 
fill details proof lemma 

exercise 
fill details proof lemma 

exercise 
true 

ii ii ii 
ii ii 
iiii iii 
iiii 
exercise 
show fourth clause definition replaced 
show done satisfy diamond property 

exercise 
prove corollary 

exercise 
write terms notation normal forms church numerals 

exercises 
exercise 
prove ae satisfy equations stated proposition 

exercise 
write term bn qn 
bn ci qn qi 
exercise 
write terms pn qn pn qn qi 

exercise klop taken 
xn abbreviation xn 
show fixed point combinator holds 

exercise 
define term neg neg true false neg false true 

exercise 
define terms true odd ocm false ecm true false 

exercise 
define term pcn cn hint trick proof definable functions closed primitive recursion 
kleene got idea visit 
chapter 
type free calculus 
exercise 
define term eq 
true eq 
cn cm false 
hint fixed point theorem construct term hcn cm zero 
cn zero 
cm true false zero 
cm false cn pcm preceding exercise 
prove result construction lemma 

exercise 
define term hc cn 
exercise 
define term hc cn 
exercise 
prove corollary 
chapter intuitionistic logic classical understanding logic notion truth 
truth statement absolute independent reasoning understanding action 
statements true false regard observer 
false means true expressed non principle hold matter meaning needless say information contained claim quite limited 
take sentence example row decimal representation number 
note may happen able determine truth sentence 
forced accept cases necessarily hold 
known example follows irrational numbers xy rational 
rational number proof fact simple take take 
problem proof know possibilities right 
little information proof constructive 
examples demonstrate drawbacks classical logic give hints intuitionistic constructive logic interest 
roots constructivism mathematics reach deeply century principles intuitionistic logic usually attributed works dutch mathematician philosopher jan brouwer century 
brouwer inventor term intuitionism originally meant denote chapter 
intuitionistic logic philosophical approach foundations mathematics opposition hilbert formalism 
intuitionistic logic branch formal logic developed year 
names quoted heyting glivenko kolmogorov gentzen 
learn history motivations see chapter 

intuitive semantics order understand intuitionism forget classical platonic notion truth 
judgements statements longer predefined value statement existence proof construction statement 
rules explain informal constructive semantics propositional connectives 
rules called bhk interpretation brouwer heyting kolmogorov 
algorithmic flavor definition lead curry howard isomorphism 
construction consists construction construction construction consists number construction construction method function transforming construction construction possible construction denotes falsity 
negation best understood abbreviation implication 
assert assumption leads absurd 
follows construction method turns construction non existent object 
note equivalence holds classical logic 
note intuitionistic statement stronger just construction 

example 
consider formulas 



natural deduction 










formulas classical tautologies 
easily bhk interpretation 
instance construction formula written follows proof proof take proof 
method translate proofs proofs 
proof method obtain proof 
hand formula construction 
classical symmetry formula disappears 

natural deduction language intuitionistic propositional logic language classical propositional logic 
assume infinite set pv propositional variables define set formulas induction represented grammar pv 
basic connectives implication disjunction conjunction constant false 

convention 
connectives abbreviations 
abbreviates chapter 
intuitionistic logic abbreviates 

convention 

convention implication right associative write 

assume negation highest implication lowest priority preference 
means 
course forget outermost parentheses 
order formalize intuitionistic propositional calculus define proof system called natural deduction motivated informal semantics 

warning 
follows quite simplified presentation natural deduction convenient technical reasons adequate 
describe relationship various proofs finer detail shall consider variant system chapter 

definition 
context finite subset 
range contexts 
ii relation defined rules 
write 
iii write 
write 
iv formal proof finite tree nodes labelled pairs form written satisfying conditions root label leaves labelled axioms label father node obtained labels sons rules 
infinite define mean finite subset 
vi say theorem intuitionistic propositional calculus 

natural deduction ax intuitionistic propositional calculus proof system consists axiom scheme rules 
logical connective rules elimination rules 
rule connective tells form derived 
elimination rule describes way derive formulas 
intuitive meaning consequence assumptions 
give example proofs favourite formulas 
example 
abbreviate 
ii iii chapter 
intuitionistic logic 

note distinction relation formal proof 
properties useful 

lemma 
intuitionistic propositional logic closed weakening substitution implies denotes substitution occurrences propositional variable proof 
easy induction respect size proofs 

algebraic semantics classical logic understand better algebraic semantics intuitionistic logic classical logic 
usually semantics classical propositional formulas defined terms truth values follows 

definition 

valuation map pv map called valuation 
ii valuation define map pv max min max 
write 
iii formula valuations consider alternative semantics analogy classical connectives set theoretic operations 

definition 
afield sets nonempty family subsets closed unions intersections complement 
follows immediately field sets examples fields sets ii iii finite finite complement 

algebraic semantics classical logic 
definition 
field sets 
valuation map pv 
ii valuation define map pv write 
proposition 
approaches semantics equivalent conditions equivalent field subsets nonempty set 
tautology 
valuations proof 
suppose element 
define valuation 
prove induction formulas 
iff 
valuation seen valuation assigns propositional variables 

definition 
algebra algebraic system form associative commutative 
relation defined iff partial order boolean algebra operations glb lub operations order 
transitive reflexive anti symmetric relation 
chapter 
intuitionistic logic notion boolean algebra straightforward generalization notion field sets 
example boolean algebra algebra truth values max min generalize set semantics arbitrary boolean algebras replacing valuations field sets valuations boolean algebra obvious way 
fact boolean algebra isomorphic field sets generalization change semantics 

heyting algebras develop semantics intuitionistic propositional logic 
set propositional formulas particular may empty equivalence relation iff 
define partial order iff 
equivalence relation defined partial order consequence formulas provable addition define operations 
operations defined formulas provable 
go show operations glb lub operations relation distributivity laws 
heyting algebras satisfied 
class element provable top element 

unexpected difficulties complement operation necessarily 
best assert greatest element call pseudo complement 
negation special kind implication calls generalization 
element called relative pseudo complement respect greatest element relative pseudo complement exists denoted difficult find algebra called lindenbaum algebra wehave 
just discovered new type algebra called heyting algebra pseudo boolean algebra 

definition 
heyting algebra algebraic system form satisfies conditions associative commutative equivalent stands 
conditions amount saying distributive lattice zero relative pseudo complement defined pair elements 
particular boolean algebra heyting algebra defined prominent example heyting algebra boolean algebra algebra open sets topological space instance algebra open subsets euclidean plane 
definition 
symbol denotes distance points subset open iff subset int denotes interior union open subsets distributive lattice 
chapter 
intuitionistic logic 
proposition 
family open subsets operations set theoretic int arbitrary open sets int set theoretic complement 
heyting algebra 
proof 
exercise 
fact heyting algebra isomorphic subalgebra algebra open sets topological space 
comprehensive study algebraic semantics intuitionistic classical logic book sikorski 
see chapter 
semantics intuitionistic propositional formulas defined follows 

definition 
heyting algebra 
valuation map pv 
ii valuation define map pv usual write 
notation 
heyting algebra 
write implies 
heyting algebras say formula intuitionistically valid intuitionistic tautology 
follows completeness theorem notions theorem tautology coincide intuitionistic propositional calculus 

theorem soundness completeness 
conditions equivalent 


proof 
verify provable formulas valid heyting algebras induction proofs 
follows construction lindenbaum algebra 
suppose 
inl 
define valuation prove induction formulas 
follows contradiction 

example 
see peirce law intuitionistically valid consider algebra open subsets take space point 
note heyting algebra iff 
intuitionistic logic finite valued single finite heyting algebra equivalent 
consider formula pi pj nand 
symbol abbreviates disjunction members set 
formula valid general exercise valid heyting algebras cardinality finite heyting algebras sufficient semantics sufficiently rich infinite algebra 

theorem 

formula length valid iff valid heyting algebras cardinality 
algebra open subsets dense metric space instance algebra open subsets 
iff valid 
point limit sequence xn xn chapter 
intuitionistic logic give sketch main ideas proof curious reader 
see details 
suppose subformulas 
construct small model distributive sublattice generated elements 
lattice heyting algebra warning heyting subalgebra suitable finite algebra embedded algebra open subsets open subset algebra homomorphic image valuation finite algebra translated valuation part theorem follows intuitionistic propositional logic decidable 
upper bound obtained way double exponential space improved polynomial space help methods see 

kripke semantics introduce semantics intuitionistic propositional logic 

definition 
model defined tuple form non empty set partial order binary relation elements called states possible worlds propositional variables satisfies monotonicity condition intuition elements model represent states knowledge 
relation represents extending states gaining knowledge relation tells atomic formulas known true state 
extend relation provide meaning propositional formulas follows 

definition 
ifc kripke model iff iff iff happens 
mean note definition implies rule negation 
kripke semantics iff generalized monotonicity proof easy induction 
want show completeness kripke semantics 
transform heyting algebra kripke model 

definition 
heyting algebra nonempty subset implies implies filter proper iff proper filter prime iff implies belongs 
lemma 
proper filter exists prime filter give hint proof 
consider family filters containing ordered inclusion 
apply kuratowski zorn lemma show family maximal element 
prime filter exercise necessarily maximal proper filter 

lemma 
valuation heyting algebra kripke model iff formulas 
proof 
take set prime filters relation inclusion define iff induction prove formulas iff 
nontrivial case induction assume suppose take filter containing 
particular proper 
contradiction 
chapter 
intuitionistic logic extend prime filter containing 
induction hypothesis follows contradiction 
converse assume induction hypothesis obtain induction hypothesis conclude desired 
cases easy 
note primality essential disjunction 
having shown assume 
exist proper filter containing 
filter extends prime filter 
hand belongs filters 
theorem 
sequent provable iff kripke models condition implies 
proof 
left right part shown induction exercise 
direction assume 
previous lemma kripke model 
nice application kripke semantics 

proposition 

proof 
assume 
kripke models states 
loss generality assume elements respectively 
order union extended taken element union 
variables easy see kripke model 
addition iff formulas similar property holds 
suppose 
soundness definition monotonicity 

implicational fragment important logical implication 
meaningful study fragment propositional calculus connective implication 
true minimal logic 
natural deduction 
exercises system implicational fragment consists rules axiom scheme 

theorem 
implicational fragment intuitionistic propositional calculus complete respect kripke models provable iff kripke models condition implies 
proof 
implication left right follows soundness full natural deduction system minimal logic fragment 
proof direction assume 
define kripke model closed 
means implies 
relation inclusion holds iff propositional variables induction show claim iff implicational formulas states 
case variable immediate definition 

take 
induction hypothesis 
get induction hypothesis 
get want 
assume take 

derive means induction hypothesis 
completeness theorem important consequence conservativity full intuitionistic propositional calculus implicational fragment 

theorem 
implicational formula set implicational formulas 
derived intuitionistic propositional calculus derived implicational fragment 
proof 
easy 
note half completeness theorems need soundness full logic direction fragment 

exercises 
exercise 
find constructions formulas example find constructions formulas 
chapter 
intuitionistic logic 
exercise 
prove lemma 

exercise 
give natural deduction proofs formulas exercise 

exercise 
show relation defined boolean algebra condition iff partial order condition equivalent operations respectively upper lower bound wrt 
constants respectively bottom top element 

exercise 
show relation defined heyting algebra condition iff partial order condition equivalent operations respectively upper lower bound wrt 
constants respectively bottom top element 

exercise 
prove proposition 

exercise 
fill details proof lindenbaum algebra heyting algebra 

exercise 
complete proof completeness theorem 

exercise 
show formulas intuitionistically valid 
open subsets construct kripke models 

exercise 
show formula pi pj intuitionistically valid 

exercise 
filter maximal iff maximal proper filter 
show maximal filter prime 
show boolean algebra prime filter maximal 

exercise 
complete proof lemma 

exercises 
exercise 
complete proof theorem part 
hint choose proper induction hypothesis 

exercise 
proof theorem generalized full propositional calculus 

exercise 
state kripke model determines iff define valuation vc vc show determines propositional variables vc implies 

exercise 
classical tautology propositional variables pn 
show formula pn pn intuitionistically valid 

exercise 
prove glivenko theorem formula classical tautology iff intuitionistic tautology 

warning 
glivenko theorem extend order logic 
chapter 
intuitionistic logic chapter simply typed calculus recall chapter term functions usually considered mathematics fixed domain range 
consider function function natural numbers natural numbers integers natural numbers corresponding requirement calculus 
precise corresponding requirement type free calculus 
curry church introduced versions systems types 
systems form topic chapter 

simply typed calculus la curry simply typed calculus la curry 

definition 
denote denumerably infinite alphabet members called type variables 
set simple types set strings defined grammar denote arbitrary type variables denote arbitrary types 
omit outermost parentheses omit parentheses convention associates right 
ii set contexts set sets pairs form xn xn variables xi xj chapter 
simply typed calculus iii domain context xn defined dom xn write dom dom 
iv range context xn defined 
typability relation defined mn require dom second rule 
vi simply typed calculus triple 
distinguish system variants called simply typed calculus la curry just la curry 

example 
arbitrary types 
ii iii yz 

definition 
say type 
say 
set typable terms subset fact proper subset set terms 
subset restrictions regarding terms may applied terms 
informally type variables denote unspecified sets denotes set functions 
saying type intuitively means set functions contains particular function informally denotes 
instance informally states identity function function certain set 
context assumption elements xn certain types respectively 
type type type 
reflects intuition denotes element denotes function 
similar vein type type type 

simply typed calculus la curry 
warning 
idea types denote sets taken literally 
instance sets set functions disjoint set functions contrast different simple types single term may types version simply typed calculus 
just calculus provides foundation higher order functional programming languages lisp scheme various typed calculi provide foundation programming languages types pascal ml haskell 
typed calculi independent interest proof theory shall frequent occasion see notes 
conclude section brief review fundamental properties 
survey follows 
shows types free variables term matter choice contexts 

lemma free variables lemma 
assume 
implies ii fv dom iii dom fv 
proof 
induction derivation 
asin proof detail omit details remainder 

derivation dom context dom 
required 

derivation ends dom loss generality assume dom 
induction hypothesis 
required 

derivation ends pq pq 
induction hypothesis twice pq required 
chapter 
simply typed calculus ii iii induction derivation 
shows type term obtained depending form term 

lemma generation lemma 
implies ii mn implies 
iii implies 
proof 
induction length derivation 

definition 
substitution type type variable type written defined notation stands context 
shows type variables range types limited form polymorphism hear polymorphism 
proposition shows similarly free term variables range arbitrary terms 

proposition substitution lemma 

ii 
proof 
induction derivation generation respectively 
shows reduction preserves typing 

proposition subject reduction 

proof 
induction derivation substitution lemma generation lemma 

simply typed calculus 

similar property called subject expansion hold see exercise 

corollary 


theorem church rosser property typable terms 
suppose 
ifm exists 
proof 
church rosser property terms subject reduction property 

simply typed calculus mentioned earlier simply typed calculus introduced curry church 
precisely curry considered types combinatory logic formulation adapted calculus 
important differences systems introduced church curry 
curry system terms type free calculus typing relation selects typable terms 
instance typable 
church original system typing rules built term formation rules follows 
denote denumerable set variables 
define set simply typed terms type clauses mn set simply typed terms taken union simple types simply typed terms type 
assuming set variables partitioned disjoint sets indexed set simple types contexts decide types variables system la curry 
system la curry select typable terms larger set 
yields common formulation simply typed calculus la church 
chapter 
simply typed calculus 
definition 
set pseudo terms defined grammar set term variables set simple types 
adopt terminology notation conventions pseudo terms terms see mutatis mutandis 
ii typability relation defined mn require dom second rule 
iii simply typed calculus la church short triple 
iv say type 
say typable 

example 
arbitrary simple types 
ii iii xz yz 
formulation la church definition important difference la curry remains church system abstractions domains form curry system abstractions domain form church system writes curry system writes 
strictly speaking proceed case terms define notion pre pseudo terms define substitution equivalence adopt convention mean equivalence class see 
omit details 
chapter useful distinguish syntactically typing system la church system la curry 
chapters shall 
simply typed calculus different systems curry church represent different paradigms programming languages 
church system programmer explicitly write types variables program pascal curry approach programmer merely writes functions job compiler programming environment infer types variables ml haskell 
having introduced new set terms pseudo terms terms obliged introduce notions substitution reduction new notion 
carried briefly 
reuse notation terminology 

definition 
form define set fv variables follows 
fv fv fv fv fv fv fv called closed 

definition 
form substitution written defined follows fv 
definition 
smallest relation closed rules pz zp zp term form called redex called contractum 
term normal form term 
definition 
relation multi step reduction transitive reflexive closure ii relation equality transitive reflexive symmetric closure 
chapter 
simply typed calculus section briefly repeating development preceding subsection simply typed calculus la church 

lemma free variables lemma 

implies ii fv dom iii dom fv 
proof 
see exercises 

lemma generation lemma 
implies ii mn implies 
iii implies 
proof 
see exercises 

proposition substitution lemma 

ii 
proof 
see exercises 

proposition subject reduction 

proof 
see exercises 

theorem church rosser property 
suppose 
exists 
proof 
way obtain result repeat argument similar untyped terms subject reduction property 
method called logical relations 
properties simply typed calculus hold curry system 
note ii implies subject expansion property see 

church versus curry typing 
proposition uniqueness types 

ii 
proof 
induction 
ii church rosser property subject reduction 

easy see properties fail la curry 
instance derivations derivations structure different due different type assumptions contrast church term type exactly derivation fact uniquely encoded difference leads interesting problems curry system 
term types assigned 
single best type sense 
problems studied type inference return 
difference la curry similar systems called type assignment systems contrast la church similar systems called typed systems 

church versus curry typing simply typed calculus la curry church different feeling essentially thing going 
extent intuition correct show 
pseudo term induces type free term erasing domains abstractions 

definition 
erasure map defined follows 
chapter 
simply typed calculus erasure preserves reduction typing 
proposition erasing 

ii 
proof 
prove induction proceed induction derivation 
ii induction derivation 
conversely lift curry derivation church 

proposition lifting 
ii 
proof 
induction derivation respectively 

warning 
propositions allow derive certain properties curry style typable lambda terms analogous properties church style typed lambda terms conversely 
instance strong normalization variant easily implies strong normalization exercise 
cautious proof methods 
common mistake cf 
exercise attempt derive church rosser property church style church rosser property untyped lambda terms assume 
proposition 
church rosser property untyped lambda terms term addition subject reduction property typable desired type 
remains apply proposition obtain church style term 
explanation gap argument easily fixed fixed see pp 

remainder stating properties simply typed calculus understood result applies la curry la church explicitly stated 

normalization 
normalization section concerned la church 
simple type regarded finite binary tree alternative name finite type comes internal nodes labeled arrows leaves labeled type variables 
shall refer properties types expressing properties tree representation 
instance function defined just height corresponding tree 

definition 
define function max convenient write church style terms typable pseudo terms way types subterms displayed superscripts recall church style term typed way provided context free variables known 
labelling determined term context 
labelling part syntax just meta notation 
property non trivial property 

theorem weak normalization 
suppose 
finite reduction mn nf 
proof 
proof idea due independently turing prawitz 
define height redex 
nf define max redex number redex occurrences height 
nf define 
show induction lexicographically ordered pairs typable la church reduction normal form 

ifm nf assertion trivially true 
nf rightmost redex maximal height determine position subterm position leftmost symbol rightmost redex means redex begins right possible 
obtained reducing redex 
term may general redexes claim number redexes height smaller redex disappeared reduction may create new redexes height chapter 
simply typed calculus see note number redexes increase copying existing redexes creating new ones 
observe new redex created cases hold 
redex form 
xp 
reduces 

new redex height 
occurring context reduction creates new redex height 
case occurs context reduction creates new redex height possibility adding redexes copying 
contains free occurrence redexes multiplied reduction 
chosen rightmost redex height redexes smaller heights right 
cases induction hypothesis normal form normal form 
fact stronger property weak normalization holds infinite reduction exists 
property called strong normalization proved 
subject reduction property church rosser property strong normalization imply reduction typable term terminates normal form type normal form independent particular order reduction chosen 

expressibility saw preceding section simply typable term normal form 
fact effectively find normal form repeated reduction leftmost redex 
results hold la curry la church system 
easily simply typable terms equal just reduce terms respective normal forms compare 
results suggest difficulties representing partial recursive functions possibly total recursive functions simply typable terms shall see 
rest section concerned simply typed calculus la curry 

expressibility 
definition 
int arbitrary type variable 
numeric function definable int int int occurrences int nm fcn cnm 
nm natural investigate constructions chapter carry typed setting 
carried 

lemma 
constant projection functions definable 
proof 
see exercises 

lemma 
function sg defined sg sg definable 
proof 
see exercises 

lemma 
addition multiplication definable 
proof 
see exercises 

definition 
class extended polynomials smallest class numeric functions containing projections nm ni ii constant functions iii signum function sg sg 
closed addition multiplication addition nk nl extended polynomials nk nk ml nk ml ii multiplication extended polynomials nk ml nk ml 
theorem schwichtenberg 
definable functions exactly extended polynomials 
proof omitted 
direction follows easily said direction proved 
insist numbers uniformly represented terms type int functions definable see 
chapter 
simply typed calculus 
exercises 
exercise 
show terms type la curry 



ki 


exercise 
find terms types 
exercise 
true 

exercise 
show strong normalization la curry implies strong normalization la church conversely 

exercise 
find bug example argument warning 

exercise 
consider proof weak normalization 
assume term length including type annotations 
give rough upper bound terms function length normalizing sequence reductions obtained strategy defined proof 
function bounded exp 
done assumption height redexes bounded constant 
exp exp 
exercise 
exercise 
define rank type denoted rk follows alternatively rk rk max rk max 
rank redex rk 
define depth term denoted conditions mn max 

exercises maximum rank redex occurring show induction reduced steps term maximum rank redex occurring 
exercise 
maximum rank redex occurring previous exercise prove normal form depth exp obtained exp reduction steps 

exercise 
show constant functions projection functions definable 

exercise 
show sg definable 

exercise 
show addition multiplication definable 
chapter 
simply typed calculus chapter curry howard isomorphism having met formalism expressing effective functions calculus formalism expressing proofs natural deduction intuitionistic logic shall demonstrate amazing analogy formalisms known curry howard isomorphism 
seen hints effective functions proofs intimately related 
instance mentioned chapter bhk interpretation states proof implication construction transforms proof proof 
construction 
possible answer kind effective function 
ways answer precise 
chapter way kleene realizability interpretation 

natural deduction contexts recall chapter called natural deduction formulation intuitionistic propositional logic 
systems originally introduced gentzen 
precisely gentzen introduced kinds systems nowadays called natural deduction systems sequent calculus systems respectively 
chapter concerned kind sequent calculus systems introduced chapter 
significant studies natural deduction systems gentzen appears prawitz classical book readable 
informal way writing natural deduction proofs 
maintaining explicitly node derivation set assumptions depends context writes assumptions top derivation marker assumptions discharged implication rule 
chapter 
curry howard isomorphism style quite common proof theory literature curry howard isomorphism widely appreciated briefly review notation informally 
reason doing notation displays certain interesting problems concerning assumptions hidden formulation chapter 
consider proof tree note proof tree written upside 
leaves assumptions root proof tree demonstrates infer 
usual rule discharges assumptions 
able infer 
notationally done putting brackets assumption question called closed opposed assumptions called open note step discharges occurrences 
general step may discharge zero occurrences assumption 
step get may decide discharge occurrences open assumption step adopts readability convention assigning numbers assumptions indicates step occurrences discharged 
example sequence proof trees 

natural deduction contexts closing occurrences closing occurrences interesting note notation indicate assumption discharged allows distinguish certain similar proofs 
instance chapter 
curry howard isomorphism discharge occurrences separately different orders 
similarly different proofs 
proof discharge step single occurrence discharged discharge step zero occurrences discharged 
second proof order reversed 
order avoid confusion assumption numbers require assumptions number formula 
discharge assumptions number require assumption number occur branch node discharging occurs 
general rules constructing proof trees look follows 
instance upper left rule states proof trees roots respectively may joined single proof tree addition new root roots children 
rule states may infer implication discharging assumptions label indicated step 

natural deduction contexts shall see chapter interest proofs certain simple form 
arrives proofs arbitrary proofs means proof normalization rules eliminate detours proof 
concretely consider proof tree proof tree demonstrates derivable 
showing inferring concluding 
direct proof tree excursion note detour proof tree signified rule immediately followed corresponding elimination rule example elimination 
fact style detour elimination possible rule immediately followed corresponding elimination rule 
example consider proof tree infer 
proof formula proceeds inferring assumption 
prove assumption simply take proof replace assumption proof formula general considers proof normalization rules sym chapter 
curry howard isomorphism metric cases omitted rule states proof infer infer followed elimination infer avoid detour replace proof simply subproof 
second rule states proof assumption get proof proof inferring elimination replace proof original proof plug proof places assumption occurs 
reading third rule similar 
process eliminating proof detours kind called proof normalization proof tree detours said normal form 
similar process called cut elimination eliminates detours sequent calculus proofs proof normalization eliminates detours natural deduction proofs 
sequent calculus systems introduced chapter 
proof normalization cut elimination studied gentzen studies continued researchers importantly prawitz 
nowadays proof theory independent discipline logic 
notes shall consider natural deduction proofs style 

curry howard isomorphism 
curry howard isomorphism introduce reductions la preceding section natural deduction formulation chapter shall 
rules formulation tedious try rule 
convenient proof tree denoted dimensional expression state transformations expressions proof trees 
happens terms simply typed calculus ideal purpose shall see section 
show derivation intuitionistic propositional logic corresponds typable term la church vice versa 
precisely show implicational fragment intuitionistic propositional logic 
recall section implicational fragment subsystem connective rules 
fragment denoted ipc 
system denoted ipc plainly ipc 
take pv set propositional variables equal set type variables set propositional formulas implicational fragment intuitionistic propositional logic set simply types identical 
implicitly 

proposition curry howard isomorphism 

ii exists 
proof 
induction derivation 
ii induction derivation 


derivation consider subcases 




derivation ends induction hypothesis mn 
recall denotes range 
chapter 
curry howard isomorphism 
derivation ends consider subcases 
induction hypothesis 
weakening lemma dom 


induction hypothesis 


correspondence displays certain interesting problems natural deduction formulation chapter 
instance different derivations showing xand type 
derivations projected reflects fact natural deduction system chapter distinguish proofs assumptions discharged different orders 
viewed extension ipc certain aspects distinction elaborated 
correspondence derivations ipc extended system ipc extending simply typed calculus pairs disjoint sums 
extends language clauses 
case 
curry howard isomorphism adds typing rules reduction rules case case case intuitively product type pair projection 
type free calculus defined terms pure terms see proposition possible 
related fact define conjunction ipc terms implication contrary situation classical logic shall see 
spirit sum variant type 
sum type data type unary constructors 
compare data type integer list usually defined data type constructors ary constructor nil ary constructor cons takes number list numbers 
sum unary constructors left right injection 
case case expression tests form returns returns just functional programming language case expression testing expression nil cons ns 
uses axiom intuitionistic propositional logic reflected variables term uses elimination rule correspond applications uses rule correspond abstractions 
fact view elaborate formulation ipc terms record rules necessary apply prove type term view type proposition 
instance type signifying fact prove axiom recorded variable recorded 
short viewed logic terms serve linear representation proof trees usually chapter 
curry howard isomorphism called constructions 
constructions sense bhk interpretation construction term mof type 
different propositions construction church terms 
contrast constructions may correspond proposition 
proposition may proven different ways 
ipc may viewed different names essentially thing 
means concepts properties considered sense ipc vice versa 
mentioned terms correspond constructions ipc 
types correspond formulas type constructors sum pair connectives 
asking exists term type inhabitation corresponds asking exist construction proposition provability 
asking exists type term typability corresponds asking construction construction formula 
redex construction 
rule introduces constructor lambda pair injection construction elimination rule introduces destructor application projection case expression 
redex consists constructor immediately surrounded corresponding destructor 
redex construction represents proof tree containing application rule immediately followed application corresponding elimination rule called detour proof tree 
reduction terms corresponds normalization constructions 
term normal form corresponds construction representing proof tree normal form 
subject reduction proposition states reducing construction formula yields construction formula 
church rosser theorem states order normalization immaterial 
states managed identify essentially identical proofs identifying proofs 

curry howard isomorphism summary ipc term variable assumption term construction proof type variable propositional variable type formula type constructor connective inhabitation provability typable term construction proposition redex construction representing proof tree redundancy reduction normalization value normal construction 
example 
consider example deduction containing redundancy 
original derivation constructions complicated proof constructions construction proof tree fact contains redex reduction yields construction proof tree 
perfect correspondence reduction normalization related concepts justifies name isomorphism simply bijection fact reduction studied extensively calculus literature normalization studied independently proof theory 
discovery isomorphism worlds merged authors feel exactly correspondence reduction normalization isomorphism deepest fruitful 
point view supported fact typed calculi introduced means studying normalization logics notably girard system introduced 
system corresponds second order minimal propositional logic discussed chapter 
chapter 
curry howard isomorphism appealing illustration isomorphism appropriate section system independently invented roughly time computer science reynolds study polymorphism typed functional programming languages 
remainder notes concepts corresponding isomorphism interchangeably 
particular system preceding subsection called logic calculus depending aspects emphasized 

consistency normalization number properties regarding difficult establish directly easy establish semantical methods saw chapter 
semantical methods replaced methods involving weak normalization property 
shows ipc consistent 

proposition 

proof 
assume 

weak normalization theorem subject reduction theorem nf 
terms normal form form xn nm nn normal forms normal form 
form fv fv 
second form patently false 

strong normalization suggested application preceding section weak normalization property useful tool proof theory 
section prove strong normalization property useful 
standard method proving strong normalization typed calculi invented tait simply typed calculus generalized secondorder typed calculus girard subsequently simplified tait 
presentation follows consider section terms la curry 

definition 
sn strongly normalizing 
ii define fa 

strong normalization iii simple type define 
definition 
sn set sn saturated 
mn sn xm mn 
mn sn mn mn ii saturated 

lemma 
sn ii iii proof 
exercise 

definition 
valuation map set term variables 
valuation defined ii valuation 
xn xn fv xn 
iii valuation 
iff 
iff 
iv iff 

proposition soundness 

proof 
induction derivation 

derivation 
chapter 
curry howard isomorphism 
derivation ends mn suppose 
induction hypothesis 
required 

derivation ends suppose 
suppose 

induction hypothesis 
yn yn yn yn sn follows 


theorem 
sn 
proof 

holds sn 
reader may think proof complicated weak normalization proof preceding chapter fact feeling technical property noting proof involves quantifying sets 
fact strong normalization property difficult prove led techniques aim inferring strong normalization weak normalization see 
applications strong normalization applications obtained weak normalization theorem 
true application strong normalization weak normalization suffice 

definition 
binary relation set write mn 

satisfies cr iff implies 

historical remarks 
satisfies wcr iff implies 

satisfies sn iff infinite reduction sequence 

satisfies wn iff finite reduction sequence normal form 

proposition newman lemma 
binary relation satisfying sn 
satisfies wcr satisfies cr 
proof 
see exercises 
shows assumption strong normalization replaced weak normalization 

proposition 
binary relation satisfying wn wcr cr 
proof 
see exercises 

corollary 
typable la church assume 

proof 
see exercises 

historical remarks informal notion construction mentioned bhk interpretation formalized kleene recursive realizability interpretation proofs intuitionistic number theory interpreted numbers see notes 
proof interpreted del number partial recursive function mapping interpretation proof interpretation proof 
see curry howard isomorphism correspondence systems formal logic functional calculi types mentioned syntactic reflection interpretation 
shows certain notation system denoting certain recursive functions coincides system expressing proofs 
curry discovered provable formulas called hilbert formulation ipc coincide inhabited types combinatory logic identifies function type implication 
proof logic corresponds term functional calculus chapter 
curry howard isomorphism vice versa 
curry noted similar correspondence natural deduction formulation ipc simply typed calculus sequent calculus formulation ipc sequent calculus version simply typed calculus 
gentzen shows transform sequent calculus proof proof applications cut rule 
curry proved corresponding result sequent calculus version simply typed calculus 
formulated correspondences sequent calculus systems natural deduction systems hilbert systems terms corresponding functional calculi infer weak normalization reduction simply typed calculus called strong reduction combinatory logic 
direct relation reduction terms normalization proofs howard published 
prawitz studied reduction natural deduction proofs extensively years curry book proved weak normalization notion reduction 
howard showed reduction proof natural deduction system minimal implicational logic corresponds reduction corresponding term simply typed calculus 
extended correspondence order intuitionistic arithmetic related typed calculus 
howard correspondence weak normalization theorem give syntactic version kleene interpretation replaces recursive functions terms normal form 
instance proof reduces abstraction applied proof yields proof 
constable suggested type proposition viewed specification proof program satisfying specification 
instance sorting specified formula ordered permutation predicate logic proof formula sorting algorithm 
literature devoted methods finding efficient programs way 
curry howard isomorphism evolved invention numerous typed calculi corresponding natural deduction logics see 
names isomorphism include propositions types formula types proofs programs 

exercises 
exercise 
give derivations formulas section natural deduction style section 

exercises 
exercise 
give terms corresponding derivations exercise 
rule terms corresponding ex rule 

exercise 
prove lemma 

exercise 

prove newman lemma 
hint prove induction length longest reduction sequence implies 

prove proposition 
infer newman lemma corollary 

exercise 
prove proposition detail 

exercise 
reduction strategy map ifm nf 
informally reduction strategy selects term normal form redex reduces 
example fl reduction strategy reduces left redex 
reduction strategy normalizing weakly normalizing term nf term normal form repeated application eventually ends normal form 
classical result due curry feys states fl normalizing 
reduction strategy perpetual term strongly normalizing nf term infinite reduction repeated application yields infinite reduction sequence 
define follows 
nf pq pf nf nf fv nf fv nf usual 
denote finite possibly empty sequence terms 
chapter 
curry howard isomorphism show perpetual 
set terms part satisfies fv 
instance show wn iff sn 
hint compare weakly normalizing fl leading normal form compare strongly normalizing leading normal form 
relation fl subset elements type la curry correspond subset proofs ipc 
proofs 
chapter proofs combinators preceding chapters considered various systems calculi 
disturbing aspect systems role played bound variables especially connection substitution 
chapter consider system combinatory logic equivalent calculus certain sense bound variables 
section introduces version combinatory logic analogous type free calculus 
second section presents simply typed combinatory logic analogous simply typed calculus 
simply typed calculus corresponds natural deduction formulation intuitionistic propositional logic curry howard isomorphism combinatory logic variant calculus natural expect simply typed combinatory logic corresponds variant intuitionistic propositional logic 
variant traditionally called opposed natural deduction style introduced third section fourth section presents curry howard isomorphism hilbert style intuitionistic propositional logic combinatory logic 
fifth section studies special cases curry howard isomorphism investigating certain restrictions logic reflected restrictions functional calculus 

combinatory logic combinatory logic invented sch curry shortly church introduced lambda calculus 
idea build foundations logic formal system logical formulas handled variable free manner 
mentioned chapter systems combinatory logic calculus aimed providing foundations mathematics logic turned inconsistent due presence arbitrary fixed points see app 
chap 

may distinguish useful chapter 
proofs combinators subsystem original system combinators dealing pure functions system called combinatory logic 
objects study combinatory logic combinatory terms 

definition 
set combinatory terms defined grammar cc set variables 
notational conventions concerning parentheses lambda terms 

definition 
reduction relation combinatory terms called weak reduction defined rules fh gh fg gf gf symbol denotes smallest reflexive transitive relation containing denotes equivalence relation containing normal form combinatory term combinatory terms 
example 

kf kf term sii sii reduces 
ss ki 
fgg 
ks gh 
bbs kk 
fhg ks sk normal forms 
gives hint combinatory logic essentially simpler calculus respects 

definition 
forf set fv variables fv fv fv fv fv fv 

combinatory logic cand define substitution note bound variables need renaming substitutions 
similar church rosser property calculus 

theorem church rosser property 
proof 
see exercises 
infer corollaries similar chapter 
obvious similarity terms lambda calculus combinatory terms 
translation easy define 
just identify corresponding 
definition 
xy xyz xz yz fg 

proposition 

proof 
induction derivation 

general case implies counter example ki ki obvious translation backward define lambda abstraction bound variables 
possible methods follows 

definition 
cand define term chapter 
proofs combinators kf ifx fv fg 
shows definition abstraction behaves partly expected 

proposition 
proof 
exercise 
operator define translation follows 

definition 
mn 


natural expect dually proposition proposition prove property hold 
instance ii ii ki ki ki attempts prove induction derivation runs difficulties case problem corresponding principle fails 
chapter contain information problem 
shows translations inverses weak sense 

proposition 
proof 
exercise 

typed combinators propositions think homomorphic embedding combinatory logic lambda calculus 
follows abuse notation names terms property expressed saying basis untyped calculus 

corollary 
closed lambda term beta equal term obtained solely application 
proof 
desired term 
unfortunately embedding isomorphism 
put differently left inverse operator projection retraction 
seen statement dual proposition fails holds statement dual proposition 

example 
kk follows weak equality strong property 

typed combinators combinatory terms seen subset lambda terms inherit structure simply typed lambda calculus 
course ways 

definition 
define typability relation mn types arbitrary context 
formulation simply typed combinatory logic uses combinatory terms la church 
chapter 
proofs combinators 
definition 
define set combinatory terms la church grammar define typability relation mn path chapter derive usual properties free variables lemma version generation lemma combinatory logics types 
cases proof subject reduction proof simpler reduction entail substitutions contrast case reduction 
prove equivalence result analogous propositions 
sake brevity shall 
distinguish typing relation simply typed combinatory logic simply typed calculus shall respectively 
remainder notes clear context typing relations refer la curry la church systems connection combinatory logic calculus 
difficult see embedding preserves types 
addition true translation requires lemma 
lemma 


proof 
induction 
proposition 




proof 
induction derivation 
ii induction derivation lemma 
corollary 
simply typed version calculus combinators strong normalization property 
proof 
strong normalization simply typed calculus proposition 

hilbert style proofs 
hilbert style proofs recall chapter far formal proofs natural deduction style 
apart sequent calculus style presentation introduced style presentation logics known hilbert style 
fact traditional approach definition formal proof 
hilbert style proof system consists set axioms proof rules 
describe system implicational fragment propositional intuitionistic logic 
system proof rule called modus ponens translated english detachment rule axiom schemes 
formulas fit patterns considered axioms 
note fact infinitely axioms 
bother long effectively described 
formal proofs hilbert style systems traditionally defined sequences formulas 

definition 
formal proof formula set assumptions finite sequence formulas cases takes place axiom element obtained modus ponens 
write proof exists 
notation obeys usual conventions 

example 
proof empty set 

axiom 
axiom 
modus ponens detach 
axiom chapter 
proofs combinators 
modus ponens detach 
example 
proof 
assumption 
assumption 
modus ponens detach 
assumption 
modus ponens detach 
important property hilbert style proof systems called deduction theorem 

proposition herbrand 
iff 
proof 
proof right left requires application modus ponens weakening 
direction proceed induction size proof 
note easy proof availability deduction theorem compared having direct proof explicitly 

proposition 
iff 
proof 
right left part easy induction 
converse easy deduction theorem 
conclude hilbert style system complete sense heyting algebras kripke models 

theorem 
iff 
proof 
immediate completeness natural deduction previous proposition 


adding axioms handle connectives obtain complete hilbert style proof systems full propositional intuitionistic logic classical propositional logic 
interesting complete proof systems classical propositional calculus obtained adding axiom schemes 

relevance linearity recall defined classical logic 
version curry howard isomorphism proof systems combinatory logics 
combinatory terms la church 

proposition 

ii exists 
proof 
induction derivation 
ii induction derivation 
curry howard isomorphism case hilbert style proofs combinatory terms realized correspondence proofs church style combinatory terms 
pairs equivalent notions application modus ponens variable assumption constants axioms 
relevance linearity intuitionistic classical logic objections axiom scheme expresses rule reasoning unnecessary assumption forgotten 
rule dubious interested relevance assumptions respect 
logicians philosophers studied various variants intuitionistic logic restrictions concerning manipulation assumptions 
classical idea relevant logics dates back early hindley attributes idea moh church 
just assumptions may regarded dubious phenomenon multiple assumption may raise important doubts 
ancient logic taken account hindley fitch 
curry howard isomorphism hand easily identify corresponding fragments implicational fragment intuitionistic propositional logic characterizing lambda terms respect number occurrences bound variables scopes 
chapter 
proofs combinators 
definition 

set terms defined induction variable term application mn term iff terms abstraction term iff term fv 

set bck terms defined follows variable bck term application mn bck term iff fv fv abstraction bck term iff bck term 

term called linear iff term bck term 
course terms correspond reasoning assumption assumptions reusable 
bck terms represent idea disposable assumptions thrown away reused 
strict control assumptions exactly maintained proofs corresponding linear terms 
classes lambda terms determine fragments ipc relevant logic terms bck logic bck terms bci logic linear terms table taken formal definition logics calculi simply logics 
give traditional hilbert style formulations logics 

definition 

relevant propositional calculus hilbert style proof system modus ponens rule axiom schemes ab ac ai 

relevance linearity 
bck propositional calculus hilbert style proof system modus ponens rule axiom schemes ab ac ak 

bci propositional calculus hilbert style proof system modus ponens rule axiom schemes ab ac ai 

warning 
expression linear logic denotes system strict extension bci logic 
linear logic principle bci logic assumption exactly 
course axioms ak exactly axioms full ipc 
axioms seen types combinators see example 
xyz yz xyz 
clearly logics correspond fragments generated appropriate choices combinators 
explains abbreviations bck bci 
full untyped lambda calculus called 
justify definitions equivalent obtained appropriately restricting occurrences variables 
obvious part remember identify combinatory terms translations 

lemma 

combinators terms terms obtained applications 
combinators bck terms terms obtained applications 
combinators bci terms terms obtained applications 
embedding translates appropriate fragments appropriate fragments 
inverse translation anymore requires available 
need redefine combinatory abstraction chapter 
proofs combinators 
definition 

term define term kf fv fg fv fv fg ifx fv fv fg bf fv fv 

define translation follows mn translation properties propositions remain true 
proof note 
addition 
proposition 

term built solely combinators 
bck term built solely combinators 
linear term built solely combinators proof 
easy 
uses property fv fv 
follows translation seen embedding appropriate fragments corresponding fragment simply typed lambda calculus 
conclude summary 
theorem 
formula theorem relevant logic type term formula theorem bck logic type bck term 
formula theorem bci logic type linear term 
proof 
immediate proposition appropriate modifications propositions 

historical remarks 
historical remarks combinatory logic introduced curry early papers studied length newer books readable 
hilbert style proofs text books logic concerned proof normalization particular proof theory general 
interesting note deduction theorem provides translation natural deduction proofs hilbert style proofs abstraction operator provides translation typed combinatory terms typed terms discovered independently hilbert systems combinatory logic essentially result 
just example number results discovered independently logical systems functional calculi 
incidentally correspondence equality weak equality tight hope 
adds certain somewhat involved set rules called rules weak equality resulting relation equivalent equality sense translations preserve equality inverses 
particular extended equality combinators closed rule 
correspondence equality weak equality elegant extensional versions calculi 
precisely adds principle extensionality px fv ext similar principle ext weak equality resulting calculi equivalent sense 
adding rule ext equivalent adding called equality see chapter adding rule ext equivalent adding certain set equational axioms called 


exercises 
exercise 
find combinator fa fa 
exercise 
prove church rosser property weak reduction tait martin method chapter 
note proof combinatory logic somewhat simpler due fact non overlapping redexes remain non overlapping reduction redexes 

exercise 
prove proposition 
chapter 
proofs combinators 
exercise 
prove proposition 

exercise 
give hilbert style proof formula 

exercise 
give detailed proof deduction theorem 
proof give abstraction operator 
exercise 
describe notion reduction hilbert style proofs corresponding weak reduction combinatory terms 

exercise 
consider variant calculus combinators typed constants typing reduction rules usual addition additional constants reduction rule 
identity combinator defined typed forms available 
embedding church style combinatory logic show variant satisfies subject reduction strong normalization properties 

exercise 
consider terms xy iz iz show terms form basis lambda calculus sense corollary types choice taken complete hilbert style axiom system ipc 
hint derive formula 
exercise 
adopt solutions exercises case translation section 
chapter type checking related problems chapter discuss decision problems related simply typed lambda calculus intuitionistic propositional logic 
interested decision problems arising analysis ternary predicate curry style version simply typed lambda calculus 
definition sense type assignment system deriving judgements form including church style systems 

definition 

type checking problem decide holds context term type 

type reconstruction problem called typability problem decide term exist context type holds typable 

type inhabitation problem called type emptiness problem decide type exists closed term holds 
say non empty inhabitant 
obvious motivation consider type checking type reconstruction problems comes course programming language design especially related language ml see 
earlier results concerning problem due curry morris hindley 
see pp 
historical notes 
look type reconstruction problem point view curry howard isomorphism problem determining proof skeleton turned correct proof inserting missing formulas 
may surprising kind questions motivated proof theoretic research 
noted chapter 
type checking related problems pp 
main ideas type reconstruction algorithm traced far see fresh skeleton instantiation problem discussed relation types 
type inhabitation problem curry howard isomorphism gives immediate translation language logic 
proposition 
type inhabitation problem simply typed lambda calculus recursively equivalent validity problem implicational fragment intuitionistic propositional logic 
proof 
obvious 
proposition remains true typed languages curry howard isomorphism sense 
programmer point view type inhabitation problem seen follows empty type type assigned term means specification fulfilled program phrase 
solving type inhabitation means contexts modular programming ability rule specifications compile time 

hard complete short section recall basic notions complexity theory 
reader referred standard textbooks comprehensive discussion 

definition 
notation logspace pspace refers respectively classes languages decision problems solvable deterministic turing machines logarithmic space polynomial space polynomial time measured input size 

definition 
say language reducible language logarithmic space logspace reducible iff turing machine works logarithmic space count tapes input output tapes computes total function iff inputs languages logspace equivalent iff logspace reductions way 
decide ask cost translation shipping handling 
note logarithmic space reduction takes polynomial time notion slightly general polynomial time reduction 
old polish school 

variants 
definition 
say language hard complexity class iff language cis reducible logarithmic space 
cin addition say complete class simply complete 

variants type reconstruction problem abbreviated 
type inhabitation problem written 
notation naturally suggests related problems choose replace various parts ternary predicate question marks choose context empty 
little combinatorics shows problems 
problems completely trivial answer 
non trivial problems follows type checking type checking closed terms type checking context 
type reconstruction 
type reconstruction closed terms 
type reconstruction context inhabitation inhabitation context 
problems easily shown logspace equivalent main problems 
logspace reductions just inclusions 
problem special case problem special case problem special case 
subject exercises 
exception problem 
problems reduce logarithmic space know simple logspace reduction chapter 
type checking related problems way 
reductions exists problems turn complete 
look determining term type environment easier determining type 
impression generally wrong type reconstruction easily reducible type checking see exercise 
reduction generic works reasonable typed calculi 
quite reduction inhabitation problems pspace complete imply pspace 
know simple reduction way 

order unification general definition order unification 
follows need special case order signature fixed consist symbol binary function symbol 

definition 

order signature finite family function relation constant symbols 
function relation symbol comes designated non zero arity 
constants treated zero ary functions 
section consider algebraic signatures signatures relation symbols 

algebraic term signature just term variable constant expression form ft tn ary function symbol tn algebraic terms 
usually omit outermost parentheses 
formal definition algebraic term involves prefix application function symbols 
course tradition write binary function symbols infix style normally way 
signature infix arrow symbol 
difficult see algebraic terms signature identified simple types implicational formulas prefer 
general algebraic terms identified finite labelled trees satisfying conditions leaves labelled variables constant symbols solution henning see chapter exercise 
confuse algebraic terms lambda terms 

order unification internal nodes daughters labelled ary function symbols 

definition 

equation pair terms written 
system equations finite set equations 
variables occurring system equations called unknowns 

substitution function variables terms identity 
function extended function terms terms ft tn fs tn 
substitution solution equation meaning term 
solution system equations iff solution equations instance equation fz solution solutions equation fz constant solution 
substitution turn example solution fx time reason different solution proper subterm 
problem determining system equations solution called unification problem 
difficult see loss generality considering single equations systems equations exercise 
unification algorithm say algorithms similar ideas differ details due robinson motivated order resolution rule 
pointed hindley pp 
earlier works 
discussions unification algorithms various textbooks instance 
choose sketch version algorithm algebraic style 
need definition 

definition 

system equations solved form iff properties equations form variable variable occurs left hand side equation occur right hand side equation variable may occur left hand side 
substitution valuation algebra terms 
chapter 
type checking related problems variable occurring left hand side equation called undefined 

system equations inconsistent iff contains equation forms gu ft tq different function symbols ft tq ft tq constant symbol ary function symbol different constant symbols ft tq variable ary function symbol occurs tq 

systems equations equivalent iff solutions 
easy see inconsistent system solutions solved system solution defined follows variable undefined core robinson algorithm seen follows 
lemma 
system equations equivalent system inconsistent solved form 
addition system obtained performing finite number operations replace variable replace replace ft tn fu un 
tn un replace remove equation form 
proof 
long system solved inconsistent apply operations 
leave exercise show process terminates silly way 

type reconstruction algorithm 
corollary 
unification problem decidable 
fact algorithm optimized polynomial time exercise provided need check solution exists need write explicitly cf 
exercise 
result dwork 

theorem 
unification problem complete respect logspace reductions 
suppose system equations transformed equivalent solved system solution defined general solution solution specialization 
formally definition 

definition 
substitutions substitution defined 
say substitution instance substitution written substitution solution system principal iff equivalence holds substitutions solution iff 
proposition 
system equations solution principal 
proof 
system equations equivalent system solved form described 
principal solution 
type reconstruction algorithm show type reconstruction reduced unification 
logspace reduction easily modified problems section 
logspace reduction way main result section may stated 
theorem 
type reconstruction simply typed lambda calculus 
chapter 
type checking related problems result explicitly stated probably sc 
thesis 
proof theorem consists reductions 
type reconstruction unification 
lambda term 
choose representative bound variable occurs free bound variable bound twice 
follows representative equivalence class 
induction construction define system equations em signature consisting binary function symbol type course idea follows em solution iff typable informally pattern type 
definition 
variable em fresh type variable 
application pq fresh type variable em ep eq 
abstraction em ep difficult see construction done logarithmic space 
main property translation follows 

lemma 

exists solution em variables fv 

solution em fv 

proof 
induction respect follows typable iff em solution 
em principal solution consequence 
context 

definition 
pair consisting context domain fv type called principal pair term iff holds 
eta reductions substitution 
note condition implies 
closed case empty say principal type 
corollary 
term typable exists principal pair principal pair unique renaming type variables 
proof 
immediate proposition 

example 
principal type 
type assigned principal 
principal type church numerals 
type assigned numeral 
complete proof theorem give reduction 
give brief hint done 
reduce general case unification special arrow case exercise equation exercise 
equation consider term xy yt yt new variables terms exercise 

eta reductions hide reader confess notions reduction beta reduction considered lambda calculi 
particular eta reduction principle mx fv 
formally definition 
definition 
define relation relation satisfying fv mx pq qp qp notation expected meaning 
symbols refer reductions combining reductions 
chapter 
type checking related problems motivation notion reduction equality follows functions considered equal return equal results equal arguments 

proposition 
ext equivalence relation ext mx ext nx fv fv ext ext pq ext qp ext qp ext identical 
proof 
exercise 
note definition contain condition ext ext 
mistake property called rule follows 
take standard notion reduction want calculus functions extensional 
want able distinguish algorithms input output behaviour 
notions eta beta eta reduction equality properties beta reduction equality 
particular church rosser theorem remains true leftmost reductions normalizing typed level subject reduction strong normalization properties 
note strong normalization eta immediate eta reduction step reduces length term 
course sense church style typed terms 

definition 
define notion church style term long normal form just long normal form 
recall write informal way saying church style term type fixed context 
definition induction variable type long normal form xm mn long normal form 
long normal form long normal form 
term long normal form term normal form function variables fully applied arguments 

lemma 
church style term beta normal form exists term long normal form proof 
easy 
proof somewhat involved beta reduction 

type inhabitation 
type inhabitation section prove result statman inhabitation problem finitely typed lambda calculus pspace complete 
particular decidable 
immediate consequence provability ipc decidable pspace complete 
decidability known gentzen discuss syntactic proof chapter 
semantic methods existence finite models 
observe type inhabited exists closed church style term type 
suffices consider church style terms 
prove problem pspace 

lemma 
alternating polynomial time algorithm deterministic polynomial space algorithm determine type inhabited context 
proof 
type inhabited lemma inhabited term long normal form 
determine exists term long normal form satisfying proceed follows abstraction look satisfying 
type variable application variable sequence terms 
nondeterministically choose variable declared type 
variable reject 
accept 
answer parallel questions inhabited 
alternating recursive procedure repeated long new questions form 
note variables say declared type term replaced change type 
means type inhabited iff inhabited suffices consider contexts declared types different 
step procedure context stays expands 
number steps depth recursion exceed squared number subformulas types initially posed question 
show pspace hardness define reduction satisfiability problem classical second order propositional formulas qbf 
refer reader details problem 
polish translation 
chapter 
type checking related problems assume second order propositional formula 
loss generality may assume negation symbol occur context propositional variable 
assume bound variables different variable occurs free bound 
propositional variable occurring free bound fresh type variables 
subformula fresh type variable 
construct basis types subformula form subformula form subformula form subformula form 
zero valuation propositional variables extended type variables 
lemma proven routine induction length formulas 
details left reader 

lemma 
subformula valuation defined free variables type inhabited iff 
proof 
exercise 
lemma obtain pspace hardness reduction performed logarithmic space 
lemma implies main result section 

theorem 
inhabitation problem simply typed lambda calculus complete polynomial space 

equality typed terms 
equality typed terms observed verify typable lambda terms beta equal suffices reduce normal form 
thing overlooked complexity decision procedure depends size particular type derivations church style terms directly size pure lambda terms verified 
case simply typed lambda calculus cost type reconstruction minor fraction total cost insist possibly exponential types written 
theorem statman 
theorem statman 
problem decide church style terms type beta equal nonelementary complexity 
decision procedure takes exp steps inputs size 
recall exp exp simplest known proof result mairson 
proof original proof statman uses validity simple higher order logic intermediate step 
interesting direct coding turing machines lambda terms 

exercises 
exercise 
show problem reduces problem problem reduces problem problem reduces problem problem reduces problem logarithmic space 

exercise 
assume context consisting type assumptions form 
define terms holds 

exercise 
show problem reduces problem logarithmic space 
hint exercise 

exercise 
wrong reduction problem problem 
answer ask yz zm zt 
chapter 
type checking related problems 
exercise 
show system equations equivalent single equation 

exercise 
show size shortest possible solution system equations may exponential size system 
construct systems equations size solutions size exponential 
solution represented polynomial space 

exercise 
prove general form unification problem reduces logarithmic space unification signature consisting arrow 

exercise 
complete proof lemma 

exercise 
show examples loops unification algorithm may caused rule silly way removing restriction rule variable 

exercise 
design polynomial time algorithm decide equation solution 

exercise 
modify algorithm section obtain algorithm problem 

exercise 
prove converse principal type theorem non empty type exists closed term principal type hint technique exercise 
fact closed term type require beta reducible 

exercise 
show principal pair bck term normal form properties type variable occurs twice occurrence positive left number arrows negative 
show principal pair bck term normal form erasure church style term long normal form type 

exercise 
prove pair bck term normal form principal pair 

exercises 
exercise 
prove proposition 

exercise 
natural deduction counterpart eta reduction 

exercise 
show examples types exactly normal inhabitants number 

exercise 
prove lemma 
exercise 

ben show decidable type finite infinite number different normal inhabitants 

exercise 
type variable occurring 
prove induction inhabited type inhabited 

exercise 
statman propositional variable connective occurring classical propositional tautology 
show intuitionistically valid 
hint exercise 

exercise 
dekkers proof rule form sound ipc iff substitution valid valid 
prove rule sound implication valid 
chapter 
type checking related problems chapter sequent calculus seen different formalisms presenting systems formal logic natural deduction hilbert style 
advantages 
instance hilbert style proofs problems pertaining management assumptions natural deduction proofs easier discover informally speaking 
seen earlier classical intuitionistic propositional calculus decidable algorithm decides classically valid truth table semantics similarly algorithm decides intuitionistically valid heyting algebra semantics kripke models 
soundness completeness results result means algorithms decide provable proof systems classical intuitionistic propositional calculus respectively 
result suggests able develop decision algorithms excursion semantics able read inference rules bottom turn reading algorithms decide formulas proofs systems 
tried write actual hilbert style proof simple formula understand approach satisfactory practice 
want prove formula modus ponens rule formula chosen guessed 
bound space choice formula 
approach automatic theorem proving rule doomed failure 
problem appears natural deduction proofs modus ponens rule 
addition unpleasant chapter 
sequent calculus property hilbert style system formulas occurring proofs long know choose proofs inconvenient 
chapter introduce third kind formalism known sequent calculus presenting systems formal logic 
sequent calculus introduced gerhard gentzen introduced natural deduction 
despite similar syntax sequent calculus natural deduction quite different serve different purposes 
natural deduction highlights fundamental properties connectives elimination rule connective sequent calculus practically oriented reads rules sequent calculus bottom top rules simplify process proof construction 
elimination rules rules 
rules introduce connectives parts judgements fact rules identical rules natural deduction 
rules introducing connectives assumption parts judgements 
rules replace elimination rules natural deduction 
development sequent calculus systems successful theoretical purposes practical approaches automated theorem proving form sequent calculi relatives 
particular resolution rule seen relative 

classical sequent calculus concerned intuitionistic proof systems introduce classical version sequent calculus 
intuitionistic sequent calculus obtained classical restriction sheds light relationship equally fundamental logics 
mentioned variations definition sequent calculus systems possible systems studied prawitz app 
minimize noise relationship natural deduction 
number variants 

definition 
classical sequent pair sets formulas written right hand side empty 
proof sequent calculus tree labelled sequents way mothers daughters match proof rules 
write lc iff proof write lc iff proof rule cut 
law ja independently introduced natural deduction systems see prawitz book information origins natural deduction sequent calculus systems 
sequents empty right hand sides permitted presentations 
meaning empty right hand side right hand side consisting restriction essential 

classical sequent calculus similar conventions case natural deduction 
instance write 
axiom rules cut rule premise may regarded axiom 
remaining rules cut rule called logical rules define meaning logical connectives 
logical rules consists left right rules connective 
right rules identical rules natural deduction left rules play role elimination rules natural deduction 
cut rule left right rule 
formula cut rule called cut formula 
recognize similarity cut modus ponens 
intuitive meaning assumptions imply implies 
rules conjunction disjunction clearly reflect idea 
chapter 
sequent calculus 

order facilitate comparison natural deduction taken primitive seen earlier negation defined 
finds literature taken primitive 
case rule replaced rules derived rules system 

warning 
presentations sequent calculus sequents pairs sequences possible repetitions sets 
systems addition axiom cut rule logical rules adopt called structural rules weakening rules allow addition formulas left right contraction rules allow contraction identical formulas left right exchange rules allow changing order consecutive formulas left right 
case takes axiom form 
system occurs 
may multi sets sets sequences 
case exchange rules needed 


difficult see presence weakening rules cut written follows cut prefer presentation rules uniformity intuitionistic fragment defined section 
shows sequent calculus complete respect ordinary semantics classical logic 

proposition 
lc entailment classically valid 
particular lc iff classical tautology 
proof omitted 
gentzen proved completeness sequent calculus system proving system equivalent logical system 
purposes proof cut rule convenient 
gentzen states cut rule derived rule cut rule fact necessary completeness application cut rule eliminated proof 
results known cut elimination theorem 
shall say result context intuitionistic logic 
iff valuation satisfying formulas satisfy 
intuitionistic sequent calculus 
example 
sequent calculus proof peirce law note formulas right hand side 

example 
example uses sequents element right hand sides 
intuitionistic sequent calculus intuitionistic sequent calculus obtained classical system simple syntactic restriction 
just require formula occurs right hand side sequent 
classical rules modified exactly element empty 

definition 
sequent form single formula 
write iff sequent calculus proof intuitionistic sequents rules 
write proof rule cut 
chapter 
sequent calculus axiom rules cut shows intuitionistic natural deduction intuitionistic sequent calculus equivalent 

proposition 
iff 
proof 
prove direction induction derivation sequent 
left right direction main problem express left rules sequent calculus terms elimination rules natural deduction express cut rule terms modus ponens 

derivation derivation 

intuitionistic sequent calculus 
derivation ends induction hypothesis natural deduction derivation 
lemma 
get modus ponens 


derivation ends induction hypothesis derivations natural deduction 
lemma 
get 


derivation ends induction hypothesis derivations natural deduction 
lemma 




derivation derivation 

derivation ends induction hypothesis derivations natural deduction 


chapter 
sequent calculus remaining cases right rules trivial 
right left direction problem express elimination rules natural deduction terms left rules sequent calculus cut rule turns useful 
cases derivation consists axiom ends rule trivial 

derivation ends induction hypothesis sequent calculus derivation 
axiom left rule get 
cut rule 


derivation ends induction hypothesis sequent calculus derivations 
left rule get 
cut rule 


derivation ends induction hypothesis sequent calculus derivations 
axiom left rule 
cut rule 


derivation ends induction hypothesis sequent calculus derivation 
left rule 
cut rule 


cut elimination 
cut elimination directions proof proposition introduce detours 
left right direction express left rule say sequence rules immediately followed elimination reflected redex form inthe term corresponding proof 
general expressed left rule sequent calculus system natural deduction proof sequent occurrence rule major premise corresponding elimination rule general sequent occurrences reflected redexes term corresponding proof 
right left direction cut rule express elimination rules terms left rules 
know get rid detours natural deduction proofs transform natural deduction proof sequent occurrence rule major premise corresponding elimination rule 
corresponds fact weak normalization theorem eliminate redexes term simply typed calculus pairs sums 
theorem states cuts 

theorem cut elimination 
conditions equivalent 
proof somewhat tedious especially terms proof trees see 
postpone proof section convenient notation proofs developed 
merely reflect interesting aspects proof consider consequences theorem 
observe uniform way eliminate application cut rule fixed sequence rules equivalent cut 
cut eliminated differently depends shape cut formula way constructed cut 
addition attempt eliminate cut complex cut formula form may create new cuts seen example 
consider proof ends application cut rule form major premise leftmost rightmost single respectively 
chapter 
sequent calculus 
cut eliminate cut cost introducing new ones 
sense new cut formulas simpler 
new proof follows 
cut 
cut note example cut formula introduced just cut rules 
strategy cut elimination proof follows 
main cases cut formula introduced appropriate left right rules directly cut treated example replacing cut new simpler cuts 
cuts permuted upward cut eventually applied axiom easy case main case obtained 
requires induction parameters depths cuts complexity cut formulas 


cut elimination theorem holds classical sequent calculus conditions lc lc equivalent 

lemma subformula property 
cut free sequent calculus property formula occurring proof subformula subformula formula occurring 
proof 
induction derivation 
number consequences subformula property 
finding sequent calculus proof formula finding proof exists easier finding proof hilbert natural deduction system 
reconstruct proof similarity approach proof method weak normalization incidental 

term assignment sequent calculus building tree upward search space step limited subformulas formulas occurring stage 
process continue indefinitely number available formulas bounded eventually repeat considered sequents 

corollary gentzen 
decidable input 
consequence conservativity fragments calculus determined choice connectives 
subformula property implies cut free proof sequent mention connectives occurring sequent 
formula provable system containing rules implication conjunction 

corollary 
ipc conservative implicational fragment 
section proof disjunction property proposition 

corollary 

proof 
proof cut free 
cut free proof disjunction application rule 
proved 

term assignment sequent calculus natural deduction proofs correspond typed terms hilbert style proofs correspond typed combinators 
sequent calculus proofs correspond 
answers 
traditional see assign lambda terms sequent calculus proofs devise alternative version simply typed calculus term language different typing rules sequent calculus traditional formulation simply typed calculus natural deduction 
carried 
implicational fragment 

definition sequent calculus style 
type term language sequent calculus style la curry 
typing rules follows chapter 
sequent calculus axiom rules ym cut write derivability system cut respectively 
binary ternary version binary version refers sequent calculus formulation ipc definition ternary version refers sequent calculus style formulation 
usual system terms agrees system terms 

proposition 

ii exists 
sequent calculus system assigns types certain terms 
terms receive types usual simply typed calculus la curry 
answer instance way assign type system 
proof proposition implicitly defines translation terms typable simply typed calculus corresponding natural deduction proofs terms typable system corresponding sequent calculus proofs vice versa 
hand restrict attention terms normal form set terms typable traditional simply typed calculus coincides set terms typable sequent calculus 

proposition 
term normal form iff simply typed calculus 

term assignment sequent calculus proof 
show term normal form iff variable normal form xp normal forms 
property follows easily 
correspondence simply typed calculus natural deduction terms normal form correspond normal deductions deductions sequent time rule major premise corresponding elimination rule 
sequent calculus variant simply typed calculus terms normal form correspond cut free proofs sequent calculus 

proposition 
normal form 
proof 
obvious 
simply typable terms normal form correspond normal proofs natural deduction cut free sequent calculus proofs 
correspondence normal deductions cut free proofs note deduction may cut rule corresponding term normal form cf 
exercise substitution ym may delete term may contain redexes 
case just know typing cut rule term 


mentioned proof proposition implicitly defines translation terms typable traditional simply typed calculus corresponding natural deduction proofs terms typable system corresponding sequent calculus proofs vice versa 
said expect translations map normal forms normal forms 
case 
reason proof proposition aimed simplest possible way get natural deduction proofs sequent calculus proofs particular translated left rules sequent calculus natural deduction proofs containing detours cut rule translating elimination rules left rules 
chapter 
sequent calculus 
general case briefly show development preceding section generalized full propositional language 
recall extension la curry pairs sums case completeness extend language operator falsity rule reduction rule rule 
generalize construction proof proposition 
lemma 
term normal form iff variable xq case normal forms 
proof 
easy 

general case 
definition sequent calculus style full language 
sequent calculus style full propositional language la curry pairs sums 
typing rules definition addition case ini routine matter verify generalized version proposition holds 
generalize proposition problem 
typable lambda terms normal form correspond terms typable new system 
instance normal forms term case normal form 
type system term typable pairs sums see observe rule possibly 
way remedy problem modify term assignment cut rule cut example term typed cut rule correspondence normal proofs cut free proofs lost 
incidentally difficulty occur implication conjunction disjunction falsity 
reason elimination rules connectives different 
recall elimination rule main premise involving eliminated connective 
case implication conjunction elimination rule precisely right hand side subformula main premise 
case disjunction falsity case 
example term corresponds sequence proof steps conjunction pairing followed disjunction elimination case followed conjunction elimination projection 
due irregular behaviour disjunction elimination projection applied pair created 
case instruction chapter 
sequent calculus impossible 
stranger entered mistake due improperly closed door bad elimination girard calls quite unrelated form main premise 
solution ignore open door go 
technically alternatives mean relax existing reduction rules allow reduction elimination pairs immediately follow introduce commuting conversions reduction rules permute eliminations 
girard take second option 

definition 
pairs sums denote union reductions pairs sums see page compatible closure relation defined rules case case case case case case pn qn case case case case case case case case 
nfc denote set normal forms respect state version proposition 

proposition 
nfc iff pairs sums 
full system 
proposition 
deduction normal form 

alternative term assignment proof 
obvious 


notion reduction understood follows 
elimination followed connective ignored 
write eta rule rule looking convincing hides unpleasant surprise discovered exercise 
function types observed meaning eta rule postulate extensionality functions case eta reduction meaning object product type pair 
leads idea generalized extensionality principle object assumed canonical form 
canonical form object type variant 
suggest eta rule disjunction case 
warning 
logical symbols denote corresponding types 
similar symbols denote intersection union types quite different meaning see 
product intersection variant type set theoretic lattice union 

alternative term assignment sequent calculus systems terms preceding sections reveal interesting connections normal natural deduction proofs cut free sequent calculus proofs 
fine grained analysis cut elimination term assignment satisfactory 
problem different proofs correspond term reductions proofs exactly mirrored reductions terms 
section follow known approach see introduce explicit way assigning terms sequent calculus proofs 
shall term assignment prove cut elimination theorem 
approach term assignment appears 
chapter 
sequent calculus 
definition alternative term assignment sequent calculus 
consider language propositional formulas term language case inm inm note kinds expression form expression restricted certain forms 
inference rules system follows axiom rules ymin inm case cut ini terms pairs sums number constructors number destructors 
constructors ini build values informally speaking 
destructors case 
inspect dissect values informally speaking 
calculus pairs sums freely apply destructor 
alternative term assignment term 
main difference term language combination destructors constructors expressed explicit rule cut 
explicit intermediate results pair takes projection constructed 
functional programming various techniques eliminate intermediate data structures functional programs notably wadler deforestation 
marlow studies deforestation functional programming language similar term assignment sequent calculus proofs 
rules remove cuts sequent calculus proofs represented alternative syntax definition 

definition 
term language introduced definition introduce relation transitive reflexive compatible closure relation defined rules divided groups main cases absent constructor left term absent constructor right term 
main cases inm mi ini case xi mi absent constructor left hypothesis inm inlet case inn case zmin zmin inn absent constructor right hypothesis ini ini chapter 
sequent calculus 
definition 

define degree formula pv max 

define degree term maximal degree 
define height term height viewed tree 

lemma 
assume proof 
induction 
split cases form 
proposition 

proof 
induction lemma 

theorem gentzen 
represents cut free proof 
proof 
induction proposition 
system introduced correspond computationally speaking 
rules similar rules finds systems explicit substitution see 
interesting investigate greater detail done 

exercises 
exercises 
exercise 
give sequent calculus proofs formulas example 
prove odd numbered formulas sequents single formulas right hand sides 

exercise 
show cut free proofs numbered formulas example involve sequents formula right hand side 

exercise 
design sequent calculus allowing empty right hand sides sequents 
sense right rule 

exercise 
prove proposition 
basis proof describe algorithms translating normal deduction cut free proof conversely 

exercise 
give examples cuts assigned terms normal form term assignment section 

exercise 
show curry style variant lambda calculus subject reduction property reductions 
show eta rule subject reduction property 

exercise 
design church style calculus show subject reduction property holds calculus 

exercise 
explain difference results 

exercise 
design reasonable eta rule disjunction aiming erasing elimination pairs 


exercise 
define eta rule 

exercise 
denote term language definition cut terms form omitted 
denote set terms pairs sums 
denote typability pairs sums denote typability sense definition obvious modification cut rule accomodate change syntax cut terms 
denote reduction relation definition denote transitive reflexive closure plus reductions pairs sums 
obvious closures 
proof proposition give translations tl ta note viewed translations type free terms 
properties hold translations 
chapter 
sequent calculus 
ta 
tl 
ta ta 
tl tl 
tl ta 
ta tl happens add commuting conversion relations 
chapter classical logic control operators previous chapters encountered curry howard isomorphism various incarnations state correspondence system typed terms system formal logic 
systems formal logic constructive principle excluded middle double negation elimination principle finds classical logics 
means coincidence 
widespread consensus effect curry howard isomorphism classical logic time tim griffin discovery convinced critics classical logics offer curry howard isomorphism 
chapter introduce classical propositional logic study assign terms classical proofs system classical proof normalization 
connection classical intuitionistic logic elaborated detail 
griffin discovery chapter 

classical propositional logic implicational fragment bulk previous chapters concerned formulations intuitionistic propositional logic occasionally come classical propositional logic 
instance chapter briefly studied algebraic semantics classical logic preceding chapter introduced sequent calculus intuitionistic logic restriction classical sequent calculus right hand sides 
case natural deduction ways obtain classical propositional logic intuitionistic propositional logic 
gives way doing implicational fragment 
chapter 
classical logic control operators 

order avoid confusion lengthy remarks convenient chapter available systematic way assigning names subsets language propositions logical system typed calculi 
chapter denotes set implicational formulas language generated grammar full propositional language language generated grammar shall occasionally concerned set implicational formulas language generated similarly pure full propositional language language generated grammar follow similar naming conventions logical systems typed calculi 

definition classical propositional logic implicational fragment 
range implicational formulas 
usual denote contexts standard conventions 
natural deduction presentation implicational fragment cpc classical propositional logic defined axiom rules axiom rules 
classical propositional logic implicational fragment 
proposition 
implicational formula 
iff truth table semantics 
particular iff tautology 
proof 
proof left exercise 


small variation system obtained changing rule easy exercise see change affect set provable sequents derived original system iff derived modified system 
defined shorter way express formula hypothesis explains name double negation elimination 


cpc prove formula proved ipc implicational fragment intuitionistic propositional logic 
system contains axiom rules problem show holds derived rule cpc 
show cpc 
fact easy 
easy weakening lemma 


way define cpc consider axiom rules rules left rule called peirce law right called ex sequitur absurdity follows 
alternative consider rules words presence peirce law special case equivalent 
exercise show systems derive sequents system introduced definition 
chapter 
classical logic control operators 

case hilbert style proofs ways obtain classical logic intuitionistic logic 
instance takes absurdity primitive add axioms section principle double negation elimination 
possibility add peirce law form ex form 


takes negation primitive hilbert style system add axioms third axiom read implies contradictory assume holds case negation taken primitive simply add may bit strange suggested add exactly axiom defined terms 
point defining terms get certain extra axioms free 
instance rule corresponding axiom follow axioms double negation axiom 
similar remarks apply natural deduction systems negation taken primitive 
apart classical propositional logic intuitionistic propositional logic similar propositional logics fundamental 
show classical propositional logic maximal logic sense axiom scheme theorem classical propositional logic addition classical propositional logic render system inconsistent 
properties usually known hilbert post completeness 

full system 
full system previous section concerned implicational fragment classical propositional logic 
required obtain definition system conjunction disjunction 
approach add language connectives adopt elimination rules system section 

definition classical propositional logic 
range formulas full propositional language 
usual denote contexts standard conventions 
natural deduction presentation cpc classical propositional logic defined rules definition addition known rules 
addition change concerning implicational formulas 

proposition 
cpc cpc 
proof 
left exercise 
words full system conservative implicational fragment 
economical approach 
contrast situation intuitionistic propositional logic may define conjunction disjunction derived connectives 

definition 
abbreviate formulas respectively 


definition standard usually takes 
definition lacks double negation 
logical point view little importance classical logic pass back forth formula double negation 
abbreviations definition systematic arise special case general scheme representing data types typed calculi shall see 
chapter 
classical logic control operators states definition intended behaviour 

proposition 
implicational formula obtained replacing occurrence defining formulas definition 
iff 
proof 
completeness iff elementary calculations truth tables iff 

terms classical proofs way extend curry howard isomorphism classical propositional logic 
sense easy just add new term constructor church variant calculus double negation elimination rule 


convenient chapter available systematic way assigning names subsets language terms pairs recall denotes set terms language generated grammar mm set terms extended pairs sums ini language generated grammar ini mm ini case shall occasionally concerned set generated mm similarly language generated grammar ini mm ini case 
definition type free simply typed calculus 
term language type free calculus defined grammar mm simply typed calculus type language set 
inference system simply typed calculus arises system simply typed calculus la curry addition rule 
classical proof normalization 

church variant obvious modifications term language inference rules 
particular double negation elimination rule usual correspondence binary means derivability cpc ternary means typability simply calculus la curry 
proposition 

ii exists 
assignment double negation elimination rule extends curry howard isomorphism classical logic naive sense idea computational significance shall learn section 

classical proof normalization seen previous chapters reduction proofs important concept proof theory intuitionistic logic classical logic case certain reductions classical propositional proofs appeared literature 
gives reductions terms la church 
corresponding reductions terms la curry obtained erasing type annotations 

definition 
define relation la church smallest compatible relation containing rules yn provided fv 
denotes substitution terms defined obvious way notion compatibility taken obvious way relative set 
notation nf usual meaning 
point view reduction proofs rules decreases complexity formulas apply double negation elimination rule 
second rule may regarded form rule 
third rule reduces applications double negation elimination rule nested certain trivial way 
chapter 
classical logic control operators 
warning 
reader warned finds literature different typed calculi corresponding classical logic merely simple variations 
particular true system studied parigot see widely cited approaches 
different authors different symbols term corresponding variants double negation elimination rule parigot ong griffin murthy taken rehof rensen 


literature finds different sets reduction rules classical proofs set contains variant rules 
gives characterization normal forms reduction characterization classical proofs detours 

definition 
smallest class terms closed rule mn xn ym mn variable 

proposition 
simply typed calculus nf proof 
induction derivation 
proposition states normal proof proceeds making certain assumptions reflected variable decomposing assumptions simpler formulas elimination rules reflected applications zm mn resulting formulas applications double negation elimination rule reflected yi building result complicated formulas rules reflected abstractions xi 
shows reduction rules sufficiently strong characterization normal forms entails consistency system 

corollary 

proof 
closed strong normalization theorem proved assume normal form 
induction derivation impossible 

definability pairs sums 
definability pairs sums saw second section define conjunction disjunction classical propositional logic 
intuitively speaking level terms suggest able define pairs sums 
section show possible 
simplicity section terms la curry 
introduce extension corresponds full system cpc 

definition 
term language ini type free calculus extended pairs sums defined grammar ini mm ini case simply typed calculus extended pairs sums denoted type language set 
inference system arises addition usual rules la curry typing pairs sums 
shows define pairs sums 

definition 
define abbreviations 
xi ini yi case kq kq 
elementary calculations prove 

proposition 
ini ini term obtained expansion abbreviations preceding definition 
formula obtained replacing occurrence defining formulas definition 
simply typed calculus extended pairs sums simply calculus 

reductions pairs sums expansion preceding definition 
definition pairs standard type free calculus see chapter projection construction different normally employed type free calculus viz 
xi 
definition chapter 
classical logic control operators xi type type expects 
changing definition conjunctive types solve problem possible leads type pair dependent component surrounding projection picks 
operator solves problem means application turns type xi regardless projection calculated reaches removed second reduction rule mentioned earlier definition disjunctive formulas standard logic 
standard definition 
tries prove derived inference rules translation turns corresponding constructions injection case analysis different defining pairs projections 
specifically desired reduction rule hold derived need add extra power 
definition corresponding defined constructions motivated corresponding definition second order logic encounter chapter 

embedding intuitionistic propositional logic section shall show classical logic embedded intuitionistic logic certain sense 
translations studied kolmogorov gentzen del 

definition 
define translation implicational formulas implicational formulas aim show classically provable intuitionistically provable 
giving translation classical proofs intuitionistic proofs 
precisely translation stated terms representing proofs 
willing settle weaker notion pairs component type problem vanishes 
shows pairs components type represented simply typed calculus 

embedding intuitionistic propositional logic 
definition 
define translation terms terms shows defines embedding classical logic intuitionistic logic 

proposition 
simply typed calculus simply typed calculus 
gives proof consistency classical propositional logic classical logic inconsistent intuitionistic logic 

proposition 
classical propositional logic 
proof 
classical propositional logic intuitionistic logic intuitionistic logic contradiction 
proof gives conservativity result provable classical logic provable intuitionistic logic 
construction generalized formulas fact way prove formula form primitive recursive predicate provable classical arithmetic peano arithmetic iff provable intuitionistic arithmetic heyting arithmetic 
formulas form quite important include assertion algorithm terminates input terminating computation 
words concerns provability termination algorithms difference intuitionistic classical logic 
hand means raise objection classical logic special case classical proof converted intuitionistic formula 
conversely classical logicians claim logical strength lost restriction intuitionistic logic 
shows translation conversion conversion 

proposition 

analyzing connection detail prove 
proposition 

chapter 
classical logic control operators 
corollary 
relation strongly normalizing typable terms 
proof 
preceding proposition proposition strong normalization simply typed calculus 

control operators cps translations far revealed computational meaning section release suspension control operator 
control operators appear functional programming languages scheme call cc ml exceptions lisp catch throw 
illustrate way example control operators program efficiently concisely 
shall consider problem writing function takes binary tree integer nodes returns result multiplying node values 
course problem raises efficiency issue node value encountered 
example programs written syntactically sugared scheme sugar define mn write lambda write 
letrec write letf tint 
solution straightforward purely functional trades efficiency elegance 
suppose auxiliary functions mt testing empty tree num selecting node value root node returning left right subtrees 

example 
functional elegant inefficient version 
mt num optimize multiplying soon node value encountered 
done purely functional style means tests 
solution embodies strategy 
assume constructor ex test function ex 
ex tags marker ex ex 
tests presence tag 
furthermore assume test function zero 
reader probably agree elegance conciseness traded efficiency 

example 
functional inelegant efficient version 
mt zero 
num ex 
control operators cps translations ex 
ex 
num function return integer product tree nodes node contains value ex node contains 
may see ex tag kind exception marker propagated explicitly recursion tree 
vein view ex constructor injection function integer element sum type form int ex 
catch throw mechanism suited handle exactly kind problem exceptional value propagated 
efficiency enhanced propagation done single step jump say 
leaves relatively elegant efficient non functional version shown example program 

example 
non functional elegant efficient version 
catch 
mt zero 
num throw num interesting fact mechanism example internalized purely functional part language called cps transformation technique 
applying translation program catch throw gives 
example 
cps version 


mt zero 
num 

num non functional program written follows type free calculus 
chapter 
classical logic control operators 
mt zero 
num num denotes church fixpoint combinator abbreviates fv 
instructive verify nil nil nil mt noticing exception raised node value encountered 
may regarded control operator similar call cc scheme exceptions ml double negation embedding classical logic logic corresponds known terms control operators pure control operator free languages 

historical remarks felleisen workers studied calculi control operators untyped setting 
aim provide foundation type free functional programming control operators similarly way calculus may regarded foundation type free pure functional programming languages 
felleisen devised control calculus extension calculus carried aptly called plotkin program see study relation calculi programming languages 
griffin discovered attempt incorporate control operators world typed calculi felleisen operator typed classical double negation elimination rule 
rule lead certain difficulties typing general preserved reduction failure subject reduction defect repaired griffin called computational simulation 
murthy overcame difficulties changing type system called pseudo classical logic 
applying conservativity results classical logics corresponding minimal logics murthy showed certain class classically provable formulas realizability interpretation remains sound 
done cps translations control operator calculi pure calculi 
seminal griffin murthy numerous systems appeared connect classical logic control operators study classical logic connection curry howard isomorphism 
exercises constitutes separate field 

exercises 
exercise 
prove proposition 

exercise 

show peirce law derived special case peirce law ex 

show double negation elimination derived special case peirce law ex 

show special case peirce law ex derived double negation elimination 

exercise 
prove derived system definition iff derived system 

exercise 
implicational formula cpc consider system arises cpc adding instances substituting implicational formulas propositional variables axioms 
show 
exercise 
prove proposition 

exercise 
show cpc derive 

exercise 
rule yn reduce inside application 
aggressive variant wait application ya corresponding different rules give reduction rules constructs give corresponding rules disjunction 

exercise 
show terms la curry church rosser show terms la curry church rosser 
question terms la church 

exercise 
hold 
nf 
chapter 
classical logic control operators chapter order logic chapter extend consideration formulas quantifiers generalize proof systems interpretations seen earlier chapters order case 

syntax order logic objects investigated propositional logic compound statements built atomic statements represented propositional variables means logical connectives 
goal understand relations compound statements depending structure actual meaning atoms occurring statements 
mathematics involves reasoning individual objects statements properties objects adequately expressed propositional language 
famous syllogism example humans mortal socrates human socrates mortal 
express reasoning language formal logic need quantify individual objects humans course need predicates relations individual objects 
logical systems involving features known names predicate logic predicate calculus quantifier calculus order logic 
section describes variant order syntax 
syntax defined respect fixed order signature typically assumed finite 
recall chapter signature family function relation constant symbols fixed arity 
recall algebraic terms individual variables constants expressions form ft tn ary function symbol tn algebraic terms 
chapter 
order logic 
definition 

atomic formula expression form rt tn ary relation symbol tn algebraic terms 

set order formulas set atomic formulas individual variable 

usual abbreviate 

formula open iff contains quantifiers 

convention 
parentheses avoiding conventions propositional formulas apply order formulas 
general consensus quantifiers written 
convention common logic quantifier operator highest priority stands 
convention originated type theory quantifier scope extends right possible 
order avoid confusion extra parentheses explicit dot notation 
write 

needless say authors forget conventions 
reader warned authors got different style 

definition 

algebraic term fv stands set variables occurring 
set fv free variables formula defined induction fv rt tn fv fv tn fv fv fv fv fv fv fv fv 

sentence called closed formula formula free variables 

definition 
definition substitution term individual variable denoted respects quantifiers variable binding operators involve variable renaming 
formally 
intuitive semantics ft tn ft tn rt tn rt tn fv fv fv fv ify fv fv ify fv fv 
fresh variable 
simultaneous substitution written xn tn term xn sn yn mn zn mn zi zi mi variables ti variables yi fresh different si ti zi yi zi mi yi mi 
convention 
common convention write stress may occur 
case notation shorthand 
convention aware part syntax 
customary introduce alpha conversion order formulas 
typically alpha equivalent formulas considered different equivalent respect reasonable semantics derived reasonable proof systems 
uniformity presentation prefer allow alpha conversion defined obvious way identify alpha convertible formulas 

intuitive semantics brouwer heyting kolmogorov interpretation propositional formulas chapter extends order logic follows construction method function transforming object construction 
construction pair consisting object construction 
note bhk interpretation taken respect domain objects 
objects syntactically represented algebraic terms 
chapter 
order logic 
example 
consider formulas 


fv 
fv 

fv 



fv 



fv 

formulas classical order tautologies difficulties finding bhk interpretations 


surprise say universal quantification generalization conjunction 
sentence cats tails quite infinite conjunction statements concerning individual cat separately 
quite spirit say existential quantification generalized disjunction 
idea reflected algebraic semantics interpret quantifiers possibly infinite joins meets see definitions 
bhk interpretation hints correspondence universal quantification implication cases function construction 
analogy strong certain systems quantifiers implication just syntactic sugar 
see chapters 

proof systems main approaches natural deduction sequent calculus hilbert style extend order logic adding suitable rules axioms rules axiom schemes propositional logic 
notation obvious modification propositional case 
assume reader familiar classical order logic 
suggested textbook 

proof systems natural deduction extend system natural deduction rules introduce eliminate quantifiers fv fv reader warned rules agreed alpha conversion formulas 
modify rules alpha variant quantifier bindings 
similar modifications done proof systems follow 
sequent calculus classical sequent calculus rules quantifiers 
note symmetry quantifiers 
fv fv obtain intuitionistic sequent calculus restrict single formulas right hand sides consists single formula empty 
fv fv 
theorem cut elimination 
sequent proof cut free proof 
probably shown sikorski topological space semantics see 

corollary existence property 
exists term 
chapter 
order logic proof 
rule cut free proof 
note signature consists relation symbols terms variables implies 
hilbert style proofs difficult find different authors give identical proof systems 
choice follows 
take axioms propositional axiom schemes addition formulas form 
fv fv 


inference rules system take modus ponens generalization rule generalization requires caution corresponding side conditions rules 

definition 
formal proof formula set assumptions finite sequence formulas cases takes place axiom element obtained modus ponens fv obtained generalization 
authors course 

proof systems 
warning 
textbooks definition proof include restriction applicability generalization rule 
matter long set sentences typically assumed 
general gives different relation iff obtained binding free variables universal quantifiers placed formulas 
relation deduction theorem see hold consisting sentences 

lemma deduction theorem 
conditions equivalent 
proof 
easy 

theorem 
natural deduction sequent calculus proof system equivalent equivalent 
proof 
boring 
translations classical logic double negation translations classical intuitionistic logic extended order case 
add clauses definition kolmogorov translation chapter xt xt 
result 
theorem 
formula classical theorem iff intuitionistic theorem 
proof 
exercise classical provability reduces intuitionistic provability classical order logic undecidable obtain undecidability intuitionistic order logic consequence 

corollary 
order intuitionistic logic undecidable 
fact undecidability result holds restricted fragment order intuitionistic logic connectives function symbols 
particular need negation falsity 
chapter 
order logic 
semantics classical semantics 
assume signature consists function symbols fn relation symbols rm constant symbols ck 

definition 
model algebraic system fa ra ra ca ca ra respec tively operations relations appropriate arities distinguished elements 
convention 
typical notational conventions forget superscript identify 
may write 
think relations functions ranging set sets tuples 

definition 

term free variables vector elements length define value induction xi ai ft tn ta 

formula free variables 
define value follows rt tn ra ta tan inf sup operations inf sup constant element boolean algebra truth values 
course 
write iff write write iff 

semantics definition generalized values formulas necessarily algebra subsets certain set relations may seen functions ranging notion structure general 
go postulate values formulas arbitrary boolean algebra provided complete algebra infinite sup inf exist 
values quantified formulas defined 
show generalizations change class classically valid statements form exercise 
investigate classical logic serves illustration 
algebraic semantics obvious idea adopt approach intuitionistic logic replace complete boolean algebras complete heyting algebras 

definition 

intuitionistic structure system fa ra ra ca ca ra cai ra functions appropriate arity complete heyting algebra 
values terms formulas defined definition operations inf sup 
notation definition 
notation understood follows structures vectors 

symbol restricted class complete heyting algebras 
example complete heyting algebra algebra open sets topological space particular metric space sup set theoretic inf ai int ai 

theorem 
conditions equivalent intuitionistic order logic 
chapter 
order logic 

class algebras open sets metric spaces 
open problem class metric spaces replaced element class consisting shown exists single metric space property see 
note counterexamples 
kripke semantics alternative way relaxing definition classical semantics keep classical notion model think models possible worlds 

definition 
structure fa ra ra ca ca substructure fb rb rb cb cb iff hold rb cb extends possible world enriching domain available objects adding information known objects 
write bto express substructure 
definition 
model order logic triple form ac non empty set partial order ac structures ac ac 
formula free variables vector elements ac length define relation induction follows rt tn iff ac rt tn classically iff iff 
exercises iff iff ac iff ac 
symbol various contexts usual particular means 

theorem 
conditions equivalent 
semantics 

exercises 
exercise 
find constructions formulas example find constructions formulas 

exercise 
order formula prenex normal form iff begins sequence quantifiers followed open formula 
consider signature function symbols intuitionistic theorem prenex normal form 
show exists open formula obtained removing quantifiers replacing variables constants hint existence property corollary 

exercise 
apply exercise show prenex fragment intuitionistic order logic function free signatures decidable 
fact remains true function symbols signature fails logics equality see 

exercise 
prove order formula classically equivalent formula prenex normal form 
prove intuitionistic order logic property 

exercise 
show existence property corollary hold classical logic 
proof break case 

exercise 
prove theorem 

exercise 
arbitrary set element 
show semantics classical logic values formulas taken family subsets equivalent ordinary semantics 
sets tautologies 

exercise 
verify odd numbered formulas example intuitionistically valid numbered ones 
chapter 
order logic 
exercise 
show classical order tautologies valid intuitionistically 



exercise 
kripke model ac constant domains iff ac 
prove formula fv formula example valid models constant domains 

exercise 
prove formula formula example valid kripke models finite sets states 
chapter dependent types dependent types probably considered old idea propositions types 
explicitly dependent types various systems aimed constructing verifying formal proofs 
project automath de bruijn see 
system gained attention edinburgh logical framework lf harper honsell plotkin 
expression logical frameworks generic name various similar calculi see 
mention martin type theory 
see 
presentation dependent types follows essentially 
programmer point view dependent type depends object value 
instance may need introduce type string binary strings length type depends choice int 
operator string type integer corresponds curry howard isomorphism predicate int 
predicate called type constructor simply constructor 
course classify constructors domains leads notion kind say constructor string kind int kind types 
course reason disallow binary predicates family kinds include 
definition object type string may happen uniform may generic procedure turns int string zeros length type procedure written int string 
general type form type function applicable objects type returning object type argument 
difficult see idea general idea function type 
free behaves example 
chapter 
dependent types exactly 
presence dependent types need introduce separately 
set theoretic counterpart dependent type product 
recall indexed family sets formally function assigns set product family set 
value different argument single domain equal fixed set obtain equality corresponding previous observation versus 
logical counterpart follows implication special case universal quantification 
correct agreed identify objects type proofs 
agree way thinking applies individual objects instance integer seen proof int 

system define church style system dependent types 
calculus quantification 
unfortunately quantifiers language broad extension language simply typed lambda calculus 
sorts expressions object expressions ranged constructors ranged kinds ranged 
object constructor variables ranged respectively kind constant 
type treated special case constructor need extra syntax types 
contexts longer arbitrary sets assumptions 
order declare variable type know application legal type fits kind 
contexts defined sequences assumptions 
addition sequence declarations regarded valid context valid depends derivability certain judgements 
similar reasons constructor kind depends derivable judgements 
formed types kinds contexts formally defined rules system 
set notation 

system unfortunately stick way build kinds introduce general product operator level kinds 
understand see example 

definition 

raw expressions raw contexts raw kinds raw constructors raw lambda terms defined grammar mm 

beta reduction raw terms defined follows nm nm mn 
write respectively 
write dom set constructors object variables declared 

skip obvious definition free variables 
course binding operators lambda abstraction quantification product kinds 
omit definition substitution 

arrows abbreviations free write 
free abbreviated old implication 


order spare reader additional noise choose non standard presentation allow lambda abstractions constructors 
constructor form mn 
restriction essential long primary interest types 
dependent type normal form obeys pattern term substitution may create constructor redex 
chapter 
dependent types different sorts judgements system kind formation judgements form kinding judgements form typing judgements form 
meaning just formed kind part language 

rules kind formation rules kinding rules typing rules nm dom dom note restriction fv attached rule 
restriction unnecessary valid context case premise derived 
weakening rules weakening rules obey pattern additional assumption hurt long formed 
need explicit relaxed axioms sequential structure contexts respect 
dom dom 
properties conversion rules dom dom dom dom rules necessary terms occurring types normal forms 


note type checking trivial task language church style 
conversion rules 
verification types kinds equal may difficult checking equality simply typed lambda terms decision problem non elementary theorem 

definition 
say type context 

example 

lambda term yx zx type context consisting declarations 

example kind expressed declare variable kind consider types form yx type 
properties system church rosser strong normalization properties 
facts follow properties simply typed terms embedding described 
certain variants embedding esp forgetting map erases dependencies discovered breazu tannen ch 
paulin apparently gandy approach see 
chapter 
dependent types 
definition 
define dependency erasure map constructors 
write contexts obtained applying operation right hand sides declarations form removing declarations 

definition 
translations defined types terms terms types translated terms 
stands fixed type variable 
abusing formalism little assume fresh term variables want 
mn fresh variable fresh variable mn fresh variable 

lemma 

extension 

extension 

step 
proof 
exercise 

corollary strong normalization 
system strong normalization property 
proof 
part lemma infinite reduction starting translated infinite reduction simply typed lambda calculus 

corollary 
system church rosser property 
proof 
exercise 

dependent types la curry 
dependent types la curry 
definition 
define type erasure mapping terms pure lambda terms usual mn 
pure lambda term write iff church style term 
say pure lambda term typable iff holds 
alternative definition define type assignment system pure lambda terms corresponding note case deal different notion type types depend pure lambda terms church style terms 
follows type erasure mapping extended types kinds 
fortunately notion typable term approach simple definition see 

proposition 
curry style variant subject reduction property 
proof 
boring 
see 
come back dependency erasure map 
extend terms follows 
definition 
mn result 
lemma 

proof 
exercise 

proposition 
term typable iff simply typable 
particular type reconstruction problem decidable polynomial time 
chapter 
dependent types proof 
suppose lemma simply typed lambda calculus 
easy see 
just shown pure terms typable typable simple types 
converse obvious type reconstruction simple types 
comes surprise easy type checking 

theorem dowek 
type checking curry style version undecidable 
proof 
regret time nice proof 
recommend reading original 

existential quantification section 
system typed normally studied basic connectives 
course extension system defined way simply typed lambda calculus 
remains see lambda calculus counterpart existential quantification 
intuition suggests understood disjoint union coproduct types objects type 
objects type pairs consisting object type proof 
may syntactically written pack ato 
elimination operator type takes pair uses object type unspecified leads deduction rules pack fv note contain free restriction extend proof variable may free considered bound expression 
reduction rule sum types follows pack fine rule long get temptation making curry style calculus existential quantifiers 
look beautiful rules may 
correspondence order logic fv rules idea existential polymorphism term existential type object data abstracted encapsulated private available external manipulations 
appealing sort abstraction done implicit typing discipline 
annoying little difficulties attempts prove subject reduction property type inference system rules 
difficulties eliminated improving rules 
example idea union types cause similar problems 

example 
consider context declarations 
yz 

correspondence order logic system dependent types stronger needed provide term assignment order intuitionistic logic 
fact order logic corresponds fairly weak fragment fragment obtained restricting syntax context satisfy type variable regarded type constant representing type individuals kinds form finite number distinguished constructor variables representing relation symbols signature appropriate kinds depending arity function symbols signature represented distinguished object variables types depending arity constant symbols represented distinguished object variables type course add previous section consider universal quantification formulas 
chapter 
dependent types declarations context may form correspond individual variables 
clearly algebraic terms represented lambda terms type normal form 
formulas represented types 
strong normalization restrict attention formulas containing terms normal form 
follows inhabited formula theorem conversely 
reader invited formally define syntax firstorder fragment exercise 
summary pairs corresponding items formulas types proofs terms domain individuals type constant algebraic terms terms type relations constructors kind atomic formula tn dependent type rt tn universal formula product type proof generalization abstraction proof modus ponens application 
example 
consider hilbert style axioms section corresponds type extended existential quantification section 
types inhabited follows 
write types upper indices improve readability 

pack fv 
fv pack 

xz yz 


examples existential quantification 
apply dependency erasing translation third sixth terms obtain typed combinators 
exercises 
may look obtain familiar 
fully justified fact universal quantification generalization implication 
example little spectacular erases parameterized 
embedding order logic easily generalized various extensions 
instance sorted logic handled just allowing atomic type 
examples features order logic sorts types domains individuals functions individuals function abstraction mechanism deal lambda terms algebraic terms quantification functions permitted quantifier ranges arbitrary expressions sort proofs terms properties proofs expressed formulas 
presence quantification objects finite types means express higher order languages see 
prefer expression higher order logic quantification propositions 
adequate statement provides sorted order representation higher order logic 
issue expressibility order theories find 
observed order intuitionistic logic undecidable 
type inhabitation corresponding fragment undecidable 
shown conservative fragment follows type inhabitation system undecidable 
direct simple proof 

theorem 
type inhabitation undecidable 

exercises 
exercise 
string type binary strings length string determines record type integer boolean fields corresponding digits example take chapter 
dependent types int bool bool int bool 
define appropriate context declaring variables string record record formed type int string 

exercise 
prove lemma 
extend translation kinds define substitution lemma necessary 

exercise 
prove lemma 
prove implies 
exercise 
consider attempt prove strong normalization assume term type occurring contains lambda term 
case infinite reduction starting translated lemma infinite reduction simply typed lambda calculus 
general case follows induction step subterms including terms occurring types strongly normalizing strongly normalizing 
prove induction step observe infinite reduction starting translates sequence pure terms ni ni nj 
infinite reduction point consist exclusively reduction steps performed exclusively types 
terms occurring types obtained subterms original term strongly normalize induction hypothesis 
find bug proof 
fix 

exercise 
prove church rosser property corollary 
warning exercise 
hint apply newman lemma 

exercise 
show example terms type 
exercise 
proof technique fails church style exercise works curry style terms 
prove strong normalization curry style help dependency erasing translation 
exercise 
verify correctness example 

exercise 
define formally fragment corresponding firstorder logic fixed signature 

exercise 
consider odd numbered formulas example types appropriate extension write lambda terms inhabiting types 
necessary operators related conjunction disjunction existential quantifier 
know 

exercises 
exercise 
know types sufficient axiomatize arrow fragment propositional intuitionistic logic 
types correspond third sixth axiom section see example 
conjecture axiom 
erasing dependencies eliminated axiom system 
show conjecture wrong formula derived axiom schemes 
chapter 
dependent types chapter order arithmetic del arithmetic core mathematics 
expressing proving properties integers primary goals mathematical logic 
chapter trace curry howard correspondence back discover fundamental works kleene del works aimed proving consistency peano arithmetic 
purpose give fundamental insights constructive contents arithmetical proofs 

language arithmetic signature cf 
definition order arithmetic consists binary function symbols constant symbols symbol equality 
standard model arithmetic set integers ordinary understanding symbols structure note elements names language arithmetic 
denote term exactly copies assuming 
th denote set order sentences classically true set sentences sense section 
classical result shows limitation order logic 
theorem 
exists nonstandard model arithmetic structure th th isomorphic 
typical choice take unary function symbol successor function 
chapter 
order arithmetic del fact consequence compactness theorem see 
definitional strength order formulas standard model quite nontrivial 
say ary relation arithmetical iff exists formula free variables holds iff 
function arithmetical iff arithmetical relation 
theorem del 
theorem 
partial recursive functions particular recursive functions arithmetical 
fact partial recursive functions relations just arithmetical hierarchy 
theorem implies th undecidable 
membership set decidable 

peano arithmetic del people thought possible axiomatize th give simple set axioms sentences th consequences peano arithmetic abbreviated pa attempt 
axioms pa formulas 


peano arithmetic third items axiom schemes single axioms 
set axioms infinite recursive set theorems derivable sentences pa axiom scheme called induction scheme 
theory set sentences complete iff sentences order language 
del famous incompleteness theorem asserts pa complete theory 
statement equivalent pa th th complete 
importance del theorem holds extensions pa long effectively axiomatizable 
consequence course th 
theorem del incompleteness 
sentence pa pa proof 
proof theorem beautiful resist temptation sketch main idea express liar paradox language arithmetic 
done full imply inconsistency arithmetic weaker property 
del sentence expresses property proof pa 
formally iff pa model pa pa hand pa property proved disproved pa construction idea del numbering 
expression language gets number write formulas expressing properties expressions referring numbers 
particular write formula iff pa number formula free variable formula number say 
iff pa 
formula says proof defined iff pa 
sentence sentence false true false 
chapter 
order arithmetic del popular opinion mathematicians del theorem little practical importance 
formula diagonalization finds number theory textbooks formalized pa commonly assumed natural mathematical problem independent pa shown paris harrington see 
problem concerns finite combinatorics may considered natural 
purely arithmetical problem coded arithmetic 
addition invented purpose independent suggested actual mathematical research 
see strong normalization theorem definitely belong mathematical practice independent pa theorem obtained del older paris harrington example 
del numbers technique express consistency pa formula iff pa number sentence number sentence con formula 
con expresses consistency pa con iff pa consistent 
theorem obtained del refinement techniques proof theorem 

theorem non provability consistency 
pa consistent pa con 
prove consistency arithmetic necessarily tools outside arithmetic 

representable provably recursive functions consider properties functions stronger arithmetical 
want functions definable standard model want prove pa theory appropriate formula defines function 
definition symbol 
read exists exactly 
formally abbreviation 


definition 
say ary total function representable pa iff exists formula free variables 
representable provably recursive functions implies pa pa function strongly representable pa holds pa 
representable function fact strongly representable exercise proving implies application non 
course representable function arithmetical 
converse true stronger version theorem 
theorem del 
function representable pa recursive 
theorem implies totality recursive function proven pa excluded middle trick exercise suggests proofs necessarily constructive 
proofs required part definition constructive non uniform 
want constructive uniform proof termination arguments able compute value proof 
understand reason concerned particular algorithms extensionally understood functions 
calls finer notion provable totality 
recall kleene normal form theorem partial recursive function written tf projection second inverse pairing function tf primitive recursive 
function tf describes particular algorithm computing termination particular algorithm expressed formula form tf 
fortunately primitive recursive functions create mentioned difficulties 
proofs totality primitive recursive functions completely effective 
addition primitive recursive function uniquely defined means equational axioms 
extend language pa names defining equations primitive recursive functions wish unwanted side effects extension pa conservative 
follows assuming formula literally formula pa harmless convenient 
quotation 
chapter 
order arithmetic del 
definition 
recursive function said provably total provably recursive pa tf 
customary talk provably recursive functions deal notion provably recursive algorithm 
regarded provably total algorithms provably total 
class functions provably total pa large includes commonly considered functions complexity 
recursive functions provably total pa 
heyting arithmetic search constructive meaning classical proof totality recursive function leads course notion intuitionistic arithmetic 
heyting arithmetic ha mean formal theory axioms rules axioms rules order intuitionistic logic axioms peano arithmetic defining equations primitive recursive functions 
means ha theory language arithmetic extended new function symbols primitive recursive functions 
extension essential conservativity technically useful 
interesting properties ha 


theorem 

ha 

ha closed formula ha 
ha 

ha closed ha ha 

ha ha ha 
markov principle 
heyting arithmetic proof 
exercise 
see semantical proof kripke models 
follows part 
follows parts 
ha follows pa ha theorem ha 
case conclude ha 
note proof classical 

theorem kreisel 
recursive function provably total peano arithmetic iff provably total heyting arithmetic 
proof 
right left part immediate 
prove part 
loss generality consider case unary function 
pa tf 
pa tf 
show kolmogorov translation see chapter works arithmetic see obtain ha tf 
theorem ha tf tf 
apply markov principle theorem obtain desired result 
direct syntactic proof due friedman require power markov principle carries secondorder arithmetic 
see exercise 
proof kreisel theorem works formula form yr primitive recursive predicate 
instance may just case quantifiers redundant 
conclude result 

corollary 
consistent pa consistent 
kreisel theorem consequence classical termination proofs constructive 

example 
consider formula form yp primitive recursive seen specification input output relation program 
classical intuitionistic proof formula chapter 
order arithmetic del asserts program recursive function exists 
program computing function extracted constructive proof 
assume signature arithmetic bit added formula inhabited proof lambda term 
lambda term applied specific evaluate normal form pack ini specific value program dividing numbers 
little missing point example bit added lambda calculus 
specific axioms arithmetic notably induction scheme 
accounted extending lambda calculus primitive recursion operator 

kleene realizability interpretation bhk interpretation mentioned previous chapters relies informal notion construction kleene proposed way precise 
idea construction formula number encoding constructions subformulas formula 
instance construction conjunction number encoding pair numbers constructions respectively 
main problematic parts bhk interpretation case implication universal quantifier 
instance construction implication effective procedure maps construction construction 
having settled domain constructions natural require construction implication number encoding recursive function maps construction antecedent construction succedent 
carry detail showing formula provable intuitionistic arithmetic construction sense 

definition 
closed formula arithmetic 
circumstances realizes defined follows 

realizes atomic formula true 
realizes realizes realizes 
realizes realizes ore realizes 
realizes del number partial recursive function argument realizes realizes 
kleene realizability interpretation 
realizes formula containing free realizes 

realizes formula containing free del number general recursive function argument realizes closed formula realizable exists number realizes 
formula xk containing distinct variables xk free realizable exists general recursive function variables nk realizes nk nk 
shall prove formula provable ha realizable 
proceeding details convenient introduce notation partial recursive functions 
recall kleene normal form theorem section 
predicate tf fact uniform precisely del number partial recursive function xn ofn variables number xn 
tn xn tn certain primitive recursive predicate 
informally speaking tn states encoding encoding computation function encoded input xn 
encoding pair second component pair output 
projection extracts output number called del number abbreviate 
tn xn xn 
recall kleene theorem ary primitive recursive function ym del number ary function ym xn tuple km numbers km del number ary function km xn 
yn xm ary partial recursive function del number denote xm yn xm function ym 
xn xn denotes del number function xn ym xn denotes recursive function ym value tuple km numbers ag del number ary function km xn 
write xn xn 
chapter 
order arithmetic del tuple kn numbers xn ym xn kn km xn means functions domain results arguments inside domain 

theorem 
ha realizable 
proof 
hilbert type formulation ha amounts hilbert type formulation intuitionistic predicate calculus chapter axioms arithmetic section 
proof induction derivation ha 
requires generalized induction hypothesis sense formulas free variables 
skip proof showing example cases 
reader may find details kleene classic 

proof instance axiom define look familiar 
show realizes realize show realizes realize show realizes holds assumption 

proof instance 
corollary 
consistent 
proof 
number realizing 

corollary 
pais consistent 
proof 
immediate corollaries 
proof intuitionistically provable arithmetical statements realizers works mapping proofs realizers 
realizers numbers coding recursive functions 
similar approach identify proofs terms appropriate extension avoid passing back 
del system forth functions encoding functions 
nice example curry howard correspondence 
define extension consistency arithmetic inferred normalization normal form type 
fact occurs need dependent types perform similar construction 
done del simply typed propositional level help system 
del system seen simply typed calculus functions defined 
instance numeric functions extended polynomials defined 
section consider del system arises addition primitive types numbers booleans addition primitive recursion conditionals computing new types 
exposition follows large extent 
seen far expressible 
system conceived del prove consistency arithmetic 

definition 
del system denoted defined follows 

set types simply typed calculus additions 
int bool 
set terms simply typed calculus la curry additions 

set typing rules simply typed calculus la curry additions int int int int int bool bool bool chapter 
order arithmetic del 
set reduction rules simply typed calculus la curry additions denote union reductions 
mentioned int bool denote types integers booleans respectively 
term formation operators denote zero successor respectively imagine 
inference rules int seen rules third rule int elimination rule 
analogously constructors type int destructor type int 
similar remarks apply inference rules term formation operators bool 


study church variant study variant pairs included 
theorems show main properties simply typed calculus preserved 
particular extra expressibility come expense loosing strong normalization 

theorem 
relation church rosser 
proof 
tait martin technique 

theorem 
relation strongly normalizing 
proof 
method tait 
recall tait method applies adjustments construction assigns set terms type 
attempt formalize tait proof necessarily expressions form sets terms satisfying 
talk terms numbers enumerate possible sets terms expressions coded order arithmetic 
needs quantify sets numbers 
specifically lemma iii asserts types set saturated 
define directly write formula expressing arithmetic 
statement lemma expressed order language 
definition induction single formula expressing property 
del system member 
definition seen set postulates set unary relation variable lemma iii formalized follows types sets ifx satisfies postulates saturated 
involves quantifier 
normalization proofs simply typed calculus 
proved weak normalization simple turing prawitz technique strong normalization nontrivial technique due tait 
simple proofs strong normalization theorem 
difference simple nontrivial precise meaning simple techniques formalized arithmetic nontrivial 
case situation different 
tait proof adapted prove strong normalization simple proofs mentioned 
fact strong normalization proof system nontrivial 
see corollary 
restrict attention finitely types situation different 
longer need quantify sets need finitely explicitely defined formulas 
proof carries order arithmetic 
situation occurs particular deal single function definable term see proposition 
compute booleans 

example 
define similarly expected reductions 
reductions 
instance show typable term introduced int representation integers 
characterization normal forms gives precise interpretation 
chapter 
order arithmetic del 
proposition 
closed normal form suppose 

int 
bool 
compute integers 

example 
define number define plus plus plus plus 
definition 
function definable term 
int int 
mk mk 
easy exercise show multiplication exponential predecessor 
definable 
long typing rules new constructs base types bool int functions defined way primitive recursive 
type increases functions definable 
fact show ackermann function definable exercise 
system called system primitive recursive functionals finite type system notation higher order functions functions functions defined set integers means primitive recursion 
functionals reflects exactly point deal higher order objects 
int means int int arrows 

del dialectica interpretation 

construction related recursor iterator form typing rule reduction rules int predecessor function satisfying defined recursor iterator 
iterator define predecessor provided requires fact define recursor iterator pairing provided requires reductions form 
question arises exactly functions defined difficult see primitive recursive function definable 
difficult see recursive function definable 
suppose 
terms type int int effectively enumerated terms defines total function strong normalization 
enumerate total recursive functions argument 
function gx recursive occur sequence 
tighter upper bound 

proposition 
functions definable provably total pa proof 
function definable term term describes algorithm compute predicate tf effectively computed conversely 
proving formula tf reduces proving applications form fn strongly normalizable 
tait technique finitely types considered 
argument coded arithmetic 
see theorem class functions definable coincides class provably total functions pa 
del dialectica interpretation del introduced system vehicle prove consistency pa precisely translates formula arithmetic statement primitive recursive functionals finite type called dialectica interpretation 
original del 
sketch main ideas 
details ch 
chapter 
order arithmetic del basis method translation formula language arithmetic term type bool 
suppose atomic formula 
primitive recursive functions predicates definable define ha iff require additional information proof preserved 
primitive recursive statements treated observables 
compare realizing atomic formulas kleene approach 
complex formulas want 
ideal situation follows free variable ha iff term realizer represent proof 
note distinction syntactic translation computational contents 
life easy settle little transparent complicated 
essential idea remains 
church style extended product types simplicity 
syntactic sugar allows identify sequences types variables single types variables find convenient 

definition 

term bool fv write iff closed 

define formula expression form variables arbitrary types type bool 

write iff exists term fv 
variables definition part may product types may represent sequences variables 

definition 
formula language arithmetic define formula induction respect 
atom primitive recursive relation int int term defines relation fresh variables 
term seen parameterized free variables 
del dialectica interpretation note primitive recursive relation 
take term note quantifiers int int redundant introduced just uniformity 
assume 
xu yv int xu yv xv xv zx take int 
zx int yz 
theorem del 
ha proof 
proof induction respect proof 
omit proof ch 
proof theorem building realizer proof ha 
computational contents proof ha preserved realizer see 
consequences interpretation 

corollary 
consistent 
proof 
suppose ha 

corollary 
strong normalization theorem system statement independent pa proof 
proof sn formalizable pa contradicts theorem 
result explained follows 
del consistency proof normalization theorem part result proved pa provided go effort translating terms numbers del numbering 
del theorem consistency arithmetic arithmetic sn expressible language arithmetic help nig lemma del number term reduction paths coded del number consist steps 
chapter 
order arithmetic del follows normalization proved pa pa inconsistent 
proving normalization methods essentially transcend proof techniques formalizable pa induction natural numbers 
normalization proof simply typed calculus induction lexicographically order triples similarly proof gentzen cut elimination theorem 
inductions reduced nested inductions formalizable pa view induction lexicographically ordered tuples ordinal induction induction happens formalizable pa gentzen discovered moving larger ordinals prove cut elimination theorem arithmetic 
specifically considers induction 
ordinal reached addition multiplication exponentiation 
show functions definable functions definable transfinite recursion ordinals strictly smaller see 
shows expressive power enormous 

corollary 
functions provably total order arithmetic definable proof 
loss generality consider unary function 
assume pa tf tf definition 
recall tf primitive treated atomic formula 
translation formula removing redundant quantifiers form tf int int represents relation tf 
ha tf realizing term reduces tf 
clearly projection primitive recursive represented term 
term represents system proposition gives 
theorem 
functions definable exactly provably total pa 

come back idea mentioned example variant corresponding order arithmetic 

exercises shall argue system seen propositional counterpart calculus 
consider induction scheme int 
int 
order incorporate arithmetic sure type inhabited 
way introduce new constants types 
proof induction represented term int oftype int 
question reduction rule associated 
int specific integer 
term mnn represents proof obtained follows prove general statement int induction apply proof seen containing redundancy universal quantifier followed elimination quantifier 
avoid redundancy applying exactly times 
justifies reduction rules mn mn mn mnn 
observe happens constant dependency erasing translation type int int permutation type recursor reduction rules differ definition just order arguments 

exercises 
exercise 
show theorems derivable pa common arithmetical properties 
chapter 
order arithmetic del 
exercise 
check axiom scheme pa replaced 

exercise 
show function representable pa strongly representable conversely 
hint consider formula 



exercise 
show condition definition replaced pa implies hint consider formula 

exercise 
consider formulas exercise 
provable ha 

exercise 
prove part theorem 

exercise 
fixed formula 
formula obtained replacing atomic subformula 
show ha ha 
exercise friedman 
prove theorem exercise lemma 
hint take tf apply exercise formula tf 

exercise 
show multiplication exponentiation subtraction favourite integer functions definable 
exercise 
favourite integer functions successor function define fk apply fk exactly times 
show functions fk definable 
exercise 
ackermann function defined fx 
prove ackermann function primitive recursive 
hint show primitive recursive function fk 
exercise 
show ackermann function exercise definable 
exercise 
show functions definable function 

exercises 
exercise 
go ahead define faster growing functions definable 

exercise 
show functions definable definable easy 
schwichtenberg theorem 

exercise 
show booleans syntactic sugar class integer functions definable booleans 
chapter 
order arithmetic del chapter second order logic polymorphism say individuals objects order zero 
functions relations individuals order 
operations objects order classified order 
terminology metalanguage referring problems systems instance unification problem discussed chapter called order unification 
note unified expressions unknowns order zero unification operation terms order 
consider second order unification function unknowns 
talk order logic order predicates quantification seen operator acting individuals 
second order logic 
typically adds language variables ranging predicates sets functions quantify variables 
second order logic usually extension order logic 
presence second order quantification order features important expect properties second order logic studied simplified settings propositional second order logic 
logic obtained adding second order features directly propositional calculus 
quantifiers binding propositional variables 

propositional second order formulas extend language propositional logic second order quantifiers quantifiers propositions 
assume infinite set pv propositional variables define second order propositional formulas induction represented grammar chapter 
second order logic polymorphism ranges pv 
quantifiers meant bind propositional variables scope fv fv 
skip full definition fv leaving pleasure reader define operation substitution 
identify alpha convertible formulas 
notational conventions similar propositional order logic 
intended meaning holds possible meanings meaning holds meaning classically just possible meanings truth values 
statement classically equivalent equivalent 
property expressible quantifiers expressed 
fact function element boolean algebra defined help ordinary propositional connectives property called functional completeness extension propositional language increase expressive power 

warning 
longer true add second order quantification order classical logic quantified predicates may depend individual terms 
longer just truth values truth valued functions individuals 
intuitionistic logic finite set truth values propositional quantifiers regarded ranging infinite space predicates 
fact functional completeness kreisel show predicates non expressible propositional intuitionistic logic definable help quantifiers infinite operations 
intuitive meaning quantified expressions best explained means brouwer heyting kolmogorov interpretation 
note deal propositions expressible language 
handle predicates constructive way able refer proofs 
construction method function transforming construction proposition 
construction consists proposition construction construction 
syntactically predicates represented formulas 
class formulas quantifiers range taken full set proper subset 
choose option called full comprehension schemes valid certain cost compare pspace completeness satisfiability quantified boolean formulas np completeness ordinary propositional formulas 
follows removing quantifiers may cause exponential increase size formula 

semantics 
aware full comprehension postulate side effect called impredicativity second order logic 
meaning formula determined meanings formulas including cases equal complex 
founded hierarchy respect semantics particular proof methods induction fail 
hand assumption quantifiers range definable propositions sharp restriction compared ordinary understanding full second order classical logic warning 
constructive point view proof model ultimate criterium syntactic approach priority semantic way thinking 
see 

definition 
natural deduction 
natural deduction system second order intuitionistic propositional logic consists ordinary rules propositional connectives plus rules quantifiers fv fv notation fv union fv 
define proof systems notably sequent calculus second order propositional intuitionistic logic 
cut elimination proofs calculus obtained independently authors girard martin prawitz published book 

semantics usual algebraic approach heyting algebras historically second order kripke semantics considered 

definition 
valuation propositional variables complete heyting algebra extend arbitrary second order formulas follows chapter 
second order logic polymorphism inf sup 
valuation defined symbol obvious way deal exclusively complete algebras 
instance write say tautology iff value valuations complete heyting algebras 

theorem heyting completeness 
conditions equivalent 
proof 
omitted 
see details 
geuvers suggested reading algebraic semantics various second order higher order intuitionistic logics known geuvers cf 
albert 
kripke semantics second order propositional formulas considered authors 
various sorts models different variants logics consideration 
prawitz proved completeness theorem class beth models structures similar spirit kripke models 
gabbay showed completeness slight extension second order logic restricted class kripke models 
result adjusted sobolev gabbay axiom see longer necessary 
recommend survey results 
definition follows syntactic sugar 

definition 

second order kripke model tuple form dc non empty set partial order dc families upward closed subsets satisfying dc dc 
intuition dc family predicates meaningful state difficulty proof lindenbaum algebra second order formulas complete embedded complete way existing joins meets preserved 
dc 
semantics 
valuation assigns upward closed subsets propositional variables 
valuation admissible state iff dc propositional variables clearly valuation admissible admissible write vx valuation satisfying vx vx forcing relation defined admissible follows iff iff iff iff happens iff vx dc iff vx dc 

kripke model complete iff formula set dc admissible 
understand meaning propositional variables free understand formula 

write iff complete kripke model valuation admissible forces formulas 
completeness theorem kripke models form probably attributed sobolev 

theorem kripke completeness 
conditions equivalent 


additional axiom scheme 
fv 
classical second order tautology intuitionistic tautology 
class models corresponding propositional second order intuitionistic logic extended gabbay axiom called grzegorczyk schema obtained postulating dc equal models constant domains 


note postulate completeness kripke models reflects idea impredicativity 
guarantees range quantified variable includes definable predicate 
fact require completeness tautology schemes expressing full comprehension longer valid chapter 
second order logic polymorphism 
observe completeness replaced modified definition forcing iff formulas definition circular 
take 


tempting consider kripke models dc equal family upward closed subsets principal kripke models 
unfortunately class formulas valid principal models recursively enumerable non axiomatizable finitary way 
result due independently kremer 
course mentioned results kremer imply set second order sentences true principal models decidable recursively enumerable 
set provable sentences second order intuitionistic logic course recursively enumerable 
undecidable 

theorem 
undecidable formula proof 
proof undecidability gabbay 
proof applies logic extended gabbay axiom see extend automatically pure case 
proof completeness theorem kripke models constant domains 
sobolev filled gap allowed infer theorem essentially method 
published proof theorem 
main result implies undecidability effective translation order classical logic second order intuitionistic logic 
unfortunately quite incomprehensible 
slightly simplified arts arts dekkers resulting presentations quite complicated 
simpler syntactic proof theorem 

polymorphic lambda calculus system polymorphic lambda calculus referred system isan excellent example curry howard correspondence provides surprising evidence relationships logic computer science 
system invented twice logician jean yves girard computer scientist john reynolds 
goal 
polymorphic lambda calculus system design proof notation needed second order logic idea build type system polymorphic programming language 
results syntactic sugar essentially 
treatment system extending scope notes consult books 

definition 

second order types defined follows type variables types types type type variable type 
types coincide second order propositional formulas 

typed lambda terms church style defined type inference rules 
term variable ordinary application abstraction polymorphic abstraction written term type variable type application written term type 
intuitive meaning term may refer free type variable taken polymorphic procedure type parameter 
type application correspond call generic procedure actual type parameter 
explicit form polymorphism type parameter opposed implicit polymorphism ml 

definition type inference rules 
context finite set declarations different variables finite partial function variables types 
axiom rules usual nm rules corresponding natural deduction rules fv chapter 
second order logic polymorphism recall church style term sense context assigns types free variables 
stress fact placing informally upper index instance fact finding proper decoration free variables term expression obtain proper church style term surprisingly undecidable problem see 

convention 
previous chapters write upper indices mark types certain sub terms 
write improve readability 
clear rules universal type corresponds product construction form 
answers idea proof function translating proofs proofs 
programmer point view type polymorphic procedure 
note restriction fv rule called generalization rule corresponds type parameter local identifier 

example 
typed church style terms 
fx 


theorem curry howard isomorphism 
polymorphic lambda calculus fragment second order intuitionistic propositional logic 

corollary 
inhabitation problem polymorphic lambda calculus type closed term type undecidable 
proof 
immediate theorem 

warning 
skip detailed definition free variables substitution 
reader able write definition provided remembers free object variables terms free type variables 
occur lambda abstractions type applications 
consider substitutions form form 

expressive power binding operators terms big small lambda 
substitutions account 
note term may contain free type variables bound sorts renaming may necessary 
definition alpha conversion account sorts bindings 
binding object variable mean binding type variables 
effect substitution course context containing declaration better understand way want 

definition beta reduction 
sorts beta reduction rules object reduction type reduction 
notion reduction expected properties particular church rosser preserves types 

expressive power classical logic connectives defined means 
quantifier expressible de morgan law sufficient set operators 
case intuitionistic logic propositional order 
secondorder propositional logic opportunity appears 
get express connectives constant 
postponed definitions order accompany term notation 

definition absurdity 
define 
term assignment rule chapter 
second order logic polymorphism easy see closed term normal form assigned type 
follow strong normalization empty type 

definition conjunction product 
free 

read definition holds iff holds derived 
lambda terms related conjunction pairs projections 
define follows 
left reader check term assignment related rules natural deduction described section correct beta reduction pi implemented replaced 
note eta conversion implemented variable normal form 

definition disjunction variant 
define disjunction weakest common consequence 
holds iff common consequences hold 
formally fv fv take 
define injections case eliminator way um vm case 

expressive power reader invited check correctness rules case correctness beta reduction exercise 
discuss existential quantifier observe various data types implemented system instance type bool interpreted true false integers represented type polymorphic church numerals cn representing numbers 
generalize notion definable integer function obvious way 
clearly functions definable simple types defined system simply adding 
instance define successor function succ fx 
instance function defined follows exp 
note trick uses polymorphism essential way 
generalize represent primitive recursion 
system equational theory embedded system 
proposition 
type define term succ 
mn mn succ mnn proof 
exercise 
reader invited define representation various data types exercise 
consider existential quantifier 
need term assignment elimination rules 
possibility follows chapter 
second order logic polymorphism pack fv abstype order case existential quantification corresponds data abstraction 
existential type form seen partial type specification type private accessible user 
instance consider type push stores push pop operations defined pds 
user operate pds knowing actual type implement 
generic pds type may defined way generic pds 
beta reduction rule existential type constructors follows abstype pack 
corresponds type context actual implementation may hidden user 
existential types mitchell book 
existential quantification represented system follows 
definition 
assuming fv define 

packing unpacking terms follows pack abstype 
compare definition definition 
weakest common consequence arbitrary type 
supports understanding existential quantifier infinite disjunction 
note similarity de morgan law take obtain 
leave reader verification beta reduction correctly implemented 

curry style polymorphism 
curry style polymorphism curry style variant system defined type assignment rules pure lambda terms 
rules correspond exactly definition 
notion type context remains 
nm fv rules abstraction application simply typed curry style lambda calculus 
rules introducing eliminating universal quantifier called respectively generalization instantiation rules reflect idea implicit polymorphism universal type means possible instances type types 

definition 
erasure map terms church style system pure lambda terms defined clauses mn 

proposition 
pure lambda term church style term 
proof 
easy 
church style term seen type derivation term 
theorem follows fact beta reduction performed typable pure lambda term corresponds reduction church style term 

theorem subject reduction 
pure lambda term implies 
proof 
omitted 
chapter 
second order logic polymorphism result obvious appear look 
see consider example 
example 
correct type assignment xy eta reduction xy 
observe church style term corresponding xy example xy redex 
reason curry style system closed reductions curry style redexes correspond church style redex 


closure reductions obtained see mitchell adding system certain subtyping relation subsumption rule form 


adding existential quantification curry style version system results problem described section 
see exercise 
polymorphism assign types pure lambda terms untypable simple types 
prominent example xx 
see strongly normalizable terms typable strong normalization 
strongly normalizable terms untypable example ronchi della rocca paola giannini term zy 
zi zk xx 
essential thing find type xx applied example 
compare typable term 
long open question type reconstruction type checking problem system decidable 
shown undecidable joe wells 

theorem wells 
type reconstruction type checking second order calculus recursively equivalent undecidable 
proof 
long 
apparently idea furio honsell 

strong normalization second order typed calculus 
strong normalization second order typed calculus chapter extending proof strong normalization simply typed calculus chapter second order typed calculus la curry 
mentioned earlier standard method proving strong normalization typed calculi invented tait simply typed calculus generalized second order typed calculus girard 
presentation follows 

definition 
set type variables denoted set second order types denoted 
ii valuation map 
iii valuation define valuation defined iv valuation set defined 
lemma 
valuation proof 
similar corresponding proof 

definition 
substitution map term variables valuation ii substitution valuation iii 
proposition soundness 
chapter 
second order logic polymorphism proof 
similar proof corresponding property induction derivation 
new cases corresponding rules 
derivation ends induction hypothesis suppose show 
derivation ends 
free induction hypothesis 
suppose show 
free 
required 

theorem strong normalization 
strongly normalizing 
proof 
similar corresponding proof 
proof differs substantial way tait strong normalization proof simple types system difference formalization argument necessarily requires quantification sets sets terms 

exercises compare statement lemma lemma part iii 
noticed chapter requires quantification sets satisfying definition 
define fixed set induction 
impredicativity definition circular consider various candidates position 
gives family candidates sets quantification statement lemma equivalent quantifications families 
words proof formalized second order language arithmetic 
fact repeat del argument obtain consistency proof second order peano arithmetic way 
strong normalization system example statement independent second order peano arithmetic 
long interested strong normalization set terms involving finitely types proceed secondorder arithmetic 
case functions finite domains handled tuples sets 
algorithm integer function definable totality shown second order arithmetic 
hand dialectica interpretation generalized girard system allows derive definition function provably total second order arithmetic 
obtain result 
theorem girard 
class functions definable coincides class provably recursive functions second order peano arithmetic 

exercises 
exercise 
prove gabbay axiom holds kripke models constant domains kripke models 

exercise 
simplify definition forcing universal formulas models constant domains 
hint 

exercise 
show complete kripke models semantics defined connectives see section coincides semantics definitions 
hold non complete models 

exercise 
show type assignment rules pairs projections correct definition pi 

exercise 
show type assignment rules injections case elimination correct definition beta reduction properly implemented case ini mi xi 
chapter 
second order logic polymorphism 
exercise 
consider eta reduction rule disjunction commuting conversions definition 
correct respect definition 

exercise 
define system types words fixed finite alphabet finite binary trees lists type appropriate basic operations types 

exercise 
prove proposition 
replacing 

exercise 
show definitions abstype pack system satisfy beta reduction rule existential types 

exercise 
consider curry style calculus existential types analogous curry style calculus order existential quantification section 
show subject reduction property 

exercise 
verify correctness example 

exercise 
show terms normal form typable system 
exercise 
show xx typable system 
exercise 
show example pure lambda term typable system untypable warning example known authors term yz 
xy 
zy xxx yz xx xaa xy 

verification takes handwritten pages 

exercise 
prove xx xx untypable system fact typable terms normalized 

exercise 
prove terms zy 
zi zk xx untypable system 
exercise 
show polymorphic type assignment principal type property 
instance show xx principal type 

exercise 
assume strong normalization curry style system derive strong normalization church style system chapter cube pure type systems chapter introduce barendregt cube seen generic typed calculus instances 
seen earlier 
generalization pure type systems seen generic typed calculus infinitely typed calculi instances systems cube 
motivation study cube proceed actual definitions 
number examples illustrate various aspects cube 
argue new presentations equivalent previous presentations settle detail 
introduce pure type systems give number examples develop rudimentary theory pure type systems 
presentation follows 

previous chapters notes related typed calculi simply typed calculus system dependent types second order typed calculus 
simplest systems clearly simply typed calculus system term type short 
term may form new term expects term argument words term term 
terms may depend terms 
chapter exclusively concerned typed calculi la church 
chapter 
cube pure type systems term type short 
term may form new term expects type argument words term depends type 
terms may depend types 
system expression expecting term type argument returning type result 
expression called type constructor constructs type provided suitable arguments 
describe input output term uses types term certain type 
similarly input output constructors described kinds 
instance type kind short expressing fact constructor expects term type constructs member type 
apply expression term type get type 
type may form type constructor expects term type argument words type constructor depends term 
types may depend terms 
combination mentioned seen terms depending terms terms depending types types depending terms types depending types 
expressions 
type constructor argument type term expression kind 
fact system exists expressions may formed known 
systems arise adding type dependency terms depending terms natural study combination dependencies systems exist dependencies allowed system terms depending types types depending types allowed done 
proceeding details systems worth effort reconsider style presentation previous chapters 
calculi previous chapters forms annotation written preceding chapter 
informal meaning type 

barendregt cube abstraction different rules govern typing various forms abstraction 
instance similarly types products 
better systems single notion abstraction parametrized permitted dependencies 
exactly cube 
idea facilitates presentation systems cube connection various systems transparent 
properties various systems developed providing proofs parametric permitted dependencies prove subject reduction regardless dependencies permitted prove property systems individually 

barendregt cube introduce barendregt cube 

definition 
set sorts defined 
range sorts 
ii vs denote countably infinite set variables vs vs vs 
iii set expressions syntax ee assume familiarity subexpression relation set fv variables substitution write fv 
denote syntactic identity modulo conversion adopt usual hygiene conventions 
iv relation compatible closure rule transitive reflexive closure transitive reflexive symmetric closure respectively 
chapter 
cube pure type systems set contexts set sequences xn xn xi xj empty sequence concatenation 
write write 
dom 
vi set sof rules relation eis defined 
legal legal 
notation meaning 
axiom start weakening product application abstraction conversion vs dom vs dom fa inference rules cube vii cube consists calculi obtained different sets rules specified table 

barendregt cube rules cube 

different rules correspond dependencies mentioned earlier terms depending terms terms depending types types depending terms types depending types informally speaking terms may depend types instance xis term depending type 
crucial point may term 
contract form abstraction permitted 
cube depicted diagrammatically 
oo oo oo oo cube chapter 
cube pure type systems 
example derivations subtle details previous definition 
illustrated examples taken reader encouraged detail 

example 
derive 


member conceived type type 

variable type variables variable term variables 
fv 
abbreviation definition iii 
means may form expressions map terms type terms type terms may depend terms 
note type variable declared context typing empty context formulation 



abbreviation definition iii means 
note 
follow mere fact show derived fact 






note typing preserved particular reduction 


note weakening rule required establish 



example 
derive 

just 


understand relationship previous formulation reader realize just new way writing mis just new way writing 
example derivations means may form expressions map type term type terms may depend types 
reader may worried absence side condition free context abstraction rule secondorder generalization 
sure move generalize variable free context 
interestingly ensured fact contexts sequences may discharge rightmost assumption 
shows weakening rule necessary weakening derive elementary 




terms type 



curry howard isomorphism type proposition second order propositional logic states follows absurdity term constructive proof proposition 

example 

derive 


member conceived kind kind 
means may form expressions map types types types may depend types 










note conversion rule derive 
conversion rule allows exchange type second 
chapter 
cube pure type systems 
example 
derive 


means may form expressions map term type type types may depend terms 
view set universe propositions member map propositions predicate 

px 
view set predicate element proposition 


set binary predicate proposition 


qx 
proposition states member satisfies satisfies 
px 
px 




xa ya 

proposition states non empty set px px 
example 
derived 




derived second order definition conjunction 



uniform definition conjunction types done 
xi 



classification equivalence previous formulations 
example 
derived 

px construction requires construction expressions requires 

pxy 
proposition states asymmetric binary relation irreflexive 

example 
derived 


constructor maps predicate diagonalization presence left right requires construction requires 

constructor uniformly 

example 
derived 

px 

constructor maps type predicate negation presence sides requires requires 
requires 

classification equivalence previous formulations presentation advantages mentioned 
presentation disadvantage case simple systems presentation involves certain amount redundancy 
instance case product mentioned product rule form distinction terms types kinds abandoned cube useful understanding details various systems 
section try recover lost showing certain extent traditional formulations systems cube equivalent formulations terms cube 

show terms belonging systems cube classified notions object constructors kinds 
chapter 
cube pure type systems 
definition 
define sets objects constructors kinds follows oo ot reading objects terms constructors types kinds kinds forms dependencies terms types expressed forms abstractions forms products 
selects expressions legal 
definition proposition refers 
definition 
define sets follows 
proposition classification cube 

sets pairwise disjoint closed reduction 

exactly holds obtains similar classifications particular systems cube 
omit clauses 
omit clauses 
omit clauses ot show products 
fact form fv 

pure type systems 
pure type systems subsection introduce pure type systems barendregt geuvers nederhof 
main ideas step cube pure type systems 
takes set set sorts just 

takes relation sas set axioms single axiom 

takes relation set rules specific sets rules 
product rule generalized products need live universe range 
necessarily live sort 
definition 
type system pts triple set sorts ii sis set axioms iii set rules 
write 
definition 
pts 
vs denote countably infinite set variables vs vs vs 
ii set expressions syntax ee assume familiarity subexpression relation set fv variables substitution write fv 
denote syntactic identity modulo conversion adopt usual hygiene conventions see 
iii relation smallest compatible relation satisfying transitive reflexive closure transitive reflexive symmetric closure respectively 
notice difference side condition product rule cube product rule pure type systems see case specify sort product live 
chapter 
cube pure type systems iv set contexts set sequences xn xn xi xj empty sequence concatenation 
write write 
dom 
relation eis defined 
legal 
notation meaning 
axiom start weakening product application abstraction conversion vs dom vs dom fa pure type systems 
convention 
save notation consider remainder pts say sor understanding defined definition 

examples pure type systems 
examples pure type systems 
example 
cube consists ptss ii iii 
systems extend sort axiom rules new sort 
system hol defined ii iii 
system defined ii iii 
system defined ii iii 

example 
system defined ii iii 
section example somewhat different pure type system 

example 
system pred defined ii iii 
formulation predicate logic pts 
significance sorts follows 
chapter 
cube pure type systems 
sort sets 

sort propositions 

sort order functions sets sets 

sorts contain respectively 
sort means variables ranging function spaces 
significance rules follows 

rule allows formation implication propositions 


rule allows quantification sets 


rule allows formation order predicates 

px 
rule allows formation function spaces sets 

rule allows formation curried multi argument function spaces sets 

properties pure type systems mentioned reasons introducing cube desire facilitate proofs apply number systems time 
instance better prove subject reduction property generic way applies systems cube regardless particular set rules prove property system individually 
idea compelling case pure type systems having shown property holds pure type systems know property holds systems cube 
properties pure type systems infinitely systems number appeared independently literature 
section develop rudimentary theory pure type systems 
section denotes arbitrary pure type system 

lemma properties substitution 

ify fv 


proof 
induction 
induction 

proposition church rosser 
relation confluent 
proof 
technique tait martin see 

lemma free variables 
xn 
xn distinct 
fv fv xn 
fv ai xi proof 
induction derivation xn 
lemma start 
legal 

proof 
legal proceed induction derivation 
lemma transitivity 
legal 
xn xi ai proof 
induction derivation xn making start lemma 

lemma substitution 

substitution map extended expressions contexts usual way 
chapter 
cube pure type systems proof 
induction derivation free variables lemma properties substitution 

lemma thinning 
legal proof 
follows start lemma transitivity lemma 

lemma generation 
suppose 



ab 


fa proof 
induction derivation 
lemma correctness types 
sor proof 
induction generation substitution lemmas 

theorem subject reduction 
proof 
prove simultaneous induction derivation 

proof uses substitution lemma 

barendregt geuvers klop conjecture 
barendregt geuvers klop conjecture terminology known 

definition 
pts 
reduction path expression possibly infinite sequence 
sequence finite ends expression mn length 
definition 
pts expression 
infinite reduction path ii nf reduction path length iii sn reduction paths finite iv wn reduction nf 
elements nf sn wn normal forms strongly normalizing weakly normalizing respectively 
write 

definition 
weakly normalizing legal expressions weakly normalizing strongly normalizing legal expressions strongly normalizing 
case write wn sn respectively 

example 
systems cube strongly normalizing see 
system simplest pts strongly normalizing 
system natural extension surprisingly strongly normalizing 
result shows apparently fact fails strongly normalizing merely consequence axiom 
conclude notes mentioning open problem field problem see 

conjecture barendregt geuvers klop 
pts wn sn chapter 
cube pure type systems chapter solutions hints selected exercises solutions actual homework done henning niss henning 
henning solved apparently open problem exercise 
exercise 
lemma substitution lemma 
fv proof 
induction case remaining cases shown detail 
case fv case case loss generality may assume chapter 
solutions hints selected exercises induction hypothesis case pq 
similar preceding case 
states compatible 

lemma 
assume ii pq iii qp qp proof 
induction derivation case case induction hypothesis case 
ii iii induction definition 
lemma 

proof 
induction derivation interesting case equality follows substitution lemma free 

lemma 

proof 
induction structure case 
case 
case follows induction hypothesis compatibility 
case steps follow induction hypothesis compatibility 
proposition exercise proved 

proposition weak church rosser 
exists 
proof 
induction derivation 
case 
orm 
case done 
situation lemma 
situation similar lemma 
chapter 
solutions hints selected exercises case induction hypothesis term compatible sought term 
case pq case induction hypothesis obtain compatibility case pq compatibility consequently pq desired 
pq pq pq completes proof 
proof extend directly full church rosser property 
say relation set weakly confluent 
call confluent 
relations weakly confluent confluent 
simplest example element set oo oo relation set strongly normalizing infinite reduction sequences 
necessarily distinct elements find weakly confluent strongly normalizing relation confluent 
details proof contain 
everybody proof style lemma induction proof style lemma induction definition detail life 
having tried see details completely mechanical 
choosing level detail proof leave details reconstructed mechanically little effort reader 
contrast steps require ideas small ideas usually left 
complete proof lemma induction complete proof lemma read induction definition complete proof lemma induction definition interesting happens case case refer substitution lemma 
cases proof similar non trivial example detail omit remaining ones 
exercise 
proposition klop 
xn abbreviation term xn fixed point combinator 
proof 



required 
chapter 
solutions hints selected exercises exercise show closure weakening 
proof induction respect size proof 
proceed cases depending rule proof 
recall notation stands 
case works 
case proof consists single application axiom scheme element 
axiom 
case proof ends application 
form proven 
proofs judgements contained proof apply induction hypothesis obtain 
application derive 
case proof ends application 
formulas 
proofs shorter apply induction hypothesis obtain 
remains rule 
cases similar 
exercise axiom 
apply derive derive 

apply get twice get 
show unfold 
derive 
remains 
show 
apply times 
need 
help derive separately 
apply judgements 
remember abbreviates conjunction rule 
part proof uses uses 
derive rules 
obtain derive 
exercise show holds 
relation transitive implies antisymmetry implies follows immediately definition 
see lub assume condition shown follows hand conclude previous item antisymmetry 
exercise proof relation partial order lub similar exercise 
show 

obviously element 
prove similar way proved dual law boolean algebra 
note 
derive 
note obtain idempotency proceed similar way boolean algebra 
exercise property immediate equivalence int 
note condition equivalent left right implication observe implies int open set 
converse follows int chapter 
solutions hints selected exercises exercise valuation heyting algebra write denote 
induction respect derivations prove statement valuations arbitrary heyting algebras 
hypothesis follows special case 
instance consider case 
show recall induction hypothesis 
case distributivity law 
exercise consider counterexamples open sets 
follows convention write int 
take point 
empty full set 
open disk straight line crossing middle disk 
space intersection disk line 
value right hand side space 
take interiors complementary halves take half take 
equal value take open disk 
counterexamples kripke models 
element model element model element model happens 
element model happens 
element model forces 
exercise lines divide space disjoint angles take interiors values pi 
point belong interpretation formula 
take kripke model sets pi different 
force formula 
exercise maximal show extended proper filter 
assume 
contradiction 
exist 
assume instance set fa proper filter extending prime filter boolean algebra assume prime contradiction 
exercise argument similar part exercise 
assume maximal element assumption leads contradiction extended proper filter containing exercise need prove slightly general statement 
kripke model state condition implies 
alternative generalization remember state set kripke model 
example consider induction step rule 
assume derived assertions 

induction hypothesis 
assume case 
induction hypothesis get 
exercise induction fails case disjunction 
chapter 
solutions hints selected exercises exercise previous exercises 
assume classical tautology direction obvious valid intuitionistically 
means kripke model state 
loss generality assume determines propositional variables 
suppose determine variable take 
exercise obtain contradiction 
exercise 
lemma newman lemma 
binary relation satisfying sn 
satisfies wcr satisfies cr 
proof 
give proof case satisfies fb set finite 
case hint aimed 
see proof note 
satisfies fb sn reduction sequence length assume sn wcr 
find strongly normalizing longest reduction starting denote length reduction 
assume 
proceed induction case longest reduction length case desired term 
case assume ifn exists 
follow 
recall nig lemma states tree finitely branching node finitely children infinite infinite branch 
consider tree root labeled node labeled node labeled child labeled satisfies sn infinite branch 
arbitrarily long finite sequences tree infinite nig lemma infinite branch contradicting sn 
length desired term similarly length 
assume wcr get term 
applying induction hypothesis get term chapter 
solutions hints selected exercises induction hypothesis get term cccc cccc 
concludes proof 

proposition 
binary relation satisfying wn wcr cr 
proof 
consider mnf nnf relation ee nf nf relation church rosser reductions nf nf term nf nf reduce term normal form 
relation weak church rosser nf nf common reduct 
similarly weakly normalizing reduction nf nf 
obviously strongly normalizing infinite reduction 

corollary 
typable la curry assume 

proof 

consider 
theorem satisfies sn exercise satisfies wcr newman lemma satisfies cr church rosser set curry typable terms 
prove newman lemma case necessarily satisfy fb 
follows 
proof 
relation satisfying sn wcr 
usual normal form satisfies sn reduces normal form 
call ambiguous reduces distinct normal forms 
easy see satisfies cr ambiguous terms 
ambiguous ambiguous suppose 
reductions step distinct reductions form 
ifm choose 
ifm wcr 
assume normal form 
distinct different choose 
infinite reduction sequence contradicting sn 
ambiguous terms 
exercise possibility ks exercise easy see types assigned respectively form 
take instances formulas hilbert style axioms 
easily simplify system replacing axiom 
hilbert style proof correspond combinatory term built combinators exercise loss generality deal terms normal forms 
suppose proof propositional type variables 
corresponding combinatory term language exercise assume normal form 
chapter 
solutions hints selected exercises clearly 
proves valid tautology 
pq impossible types expressions match exercise reduce observe term free variables xn typable xn typable 
order find closed term typable ask 
exercise course proceed induction follows kt zy yx yt 
exercise author hint adopt technique exercise write lambda terms fv typable context 
fresh variable type variable occurring 
reduce problem xn problem xn 
exercise solution henning fragment henning solution containing reduction problem problem 
definition 
denote type environment form discussed exercise 
maps variables distinct type variables 
definitions 
consider problems 
reductions xn understood free variables reduction 
answer ask zm zt 
reduction 
harder part 
trivial design subterm forced primitive type 
solution product types 
simple solution obtained assume product types disposal pair projection operators 
answer ask xn xn xn xn yn 
clearly typing complicated term typable 
direction exploit existence unique principal types 
long term typable xn principal type 
principal type instances arrow types pair types conclude type variables 
furthermore yi yj equal type different type variables 
modulo renaming type variables 
implicational solution 
solution encoding types terms lemma 

ex mn men 

proof part easy 
part follows induction respect mind logspace computable exponentially bigger 
actual reduction just argument correctness 
important thing logspace computable having treeless linear definition 
chapter 
solutions hints selected exercises answer ask xn zy xy zy yn 
easy see holds typable conversely assume wrapped typable 
know typable principal pair remains shown know xi xi instance type zy yi inspection definition see case xi variable 
compound types translated types symmetric arguments 
furthermore type variables different zy yi zy yj common type isa completes reduction 
exercise take equations 
exercise non unifiable terms different flags 
represent ary operators combinations arrows flags identify operators 
exercise label subterms occurring equations keep labels unchanged steps 
variable called defined iff equation form 
occurrence left hand right hand side equation called main 
note main occurrences 
proceed induction parameters number labels number equations number main defined variables number defined variables 
application rule decreases increase parameters 
rule decreases affecting rule decreases increasing 
rule caution occurs defined variable increase parameters decrease 
finite number applications rules obtain system equations normal reasons may equations form may equations defined variables 
rules clean 
exercise acyclic graphs trees represent algebraic terms 
proceed identifying nodes graphs long contradiction loop attempt place different operation labels node nodes need identified 
exercise just add equation 
exercise take term kv inhabitant exercise 
exercise pair called semi principal iff properties mentioned exercise 
show semi principal church style bck term long normal form 
proof induction total number arrows 
assume 
form xm mn fully applied arguments 
fully applied apply induction hypothesis pair 
remaining case type variable 
variable declared type occurs twice 
xn np 
apply induction hypothesis pairs declaration 
exercise modify algorithm lemma searches inhabitants 
process may loop asking question form asked 
effectively identify loop free solutions loops 
loop caused question loop free solution answer infinite 
note similarity argument pumping lemma cf languages 
exercise assume inhabited 
prove indirectly inhabited 
assume ni 
mn nn contradiction type variables inhabited 
chapter 
solutions hints selected exercises proof inhabited inhabited induction size 
type variable type form 
inhabited induction hypothesis inhabited know 
nj nj xn xin nm 
exercise formula form classically equivalent tautology false valuation sets false 
classically valid intuitionistically valid 
means inhabited viewed type 
inhabited exercise intuitionistically valid 
exercise reduce general case case type variable 
prove consider substitution 
show formulas valid conclude need 
exercise consider term fk fk 
assigned instances type types derive 
fk fk assigned type 
exercise example term solution untyped redex erasure typed redex 
church style version term uses different exercise problem elimination rule necessarily identical premise rules 
elimination pair eliminates introduces possibly different things 
exercise canonical object type argue eta rule sense 
analogy eta rule may postulate avoided 
leads 
exercise hint right left direction proceed follows 
show 

propositional variables 
boolean valuation 
lifted formulas usual truth table semantics 
show 
prove right left direction 
exercise construction induction length quantifier prefix 
quantifier free 

constant 
apply induction hypothesis 
exercise formula finite number possible replacements existentially quantified variables constants 
verify provability prenex formula checks provability replacements provability open formulas decidable propositional case 
exercise intuitionistic case argument course follows intuitionistic order formula equivalent prenex formula intuitionistic order logic decidable previous exercise 
note apply argument needs know translation prenex normal form chapter 
solutions hints selected exercises effective assume existence prenex formula equivalent 
effectively list proofs proof prenex formula gives effective translation 
exercise consider formula unary predicate symbol constants 
clear formula form classically valid 
proof corollary breaks obvious omitted part confusion created principle contraction occurrences formula sequent treated single occurrence 
sequent calculus explicit contraction rules rule proof right contraction rule 
version sequent calculus contraction implicit rule 
premise rule may instance form classical sequent may formulas right hand side 
second rule premise classical proof easy 
exercise hint proof similar proposition 
choose transform model relations valued ordinary model defining iff 
models common domain valuation extend terms formulas usual way values formulas range 
proves induction claim iff 
note right hand side sense regarded ordinary valued valuation 
note right direction case uses fact lower bounds intersections belongs sets family belongs glb 

case arbitrary boolean algebras 
exercise algebraic counterexamples domain individuals set positive integers 
heyting algebra set open sets take atomic formulas abbreviate byp depend 
symbol wi denotes th point rational coefficients fixed order 
take wn full space rational point 
intersection sets isr rational points deleted 
set empty interior value formula xp full space 
hand complement empty value formula right hand side union empty sets 
space point bethe set points distance greater full space disk 
union equal value left hand side union sets value right hand side contain 
take open disk centered radius equal value left hand side set covers space 
value right hand side glb sets empty 
intersection point set open 
empty 
value left hand side full space glb sets empty 
value right hand side empty 

empty 
intersection sets empty interior value formula empty 
take odd complementary open halves space 
note formula propositional counterpart valid 
counterexamples kripke models hint adopt solution exercise 
chapter 
solutions hints selected exercises hint counterexample propositional version law 
model consists states ac ad 


generalize 
set states cn domain state set integers ci 
ci ci particular ci hold 
model consists states ac ad 



implies 
exercise heyting counterexample exercise 
kripke counterexample exercise 
similar exercise 

heyting counterexample exercise 
kripke counterexample exercise 


heyting counterexample exercise 
kripke counterexample consists states incomparable domain 
forcing relation consists 
exercise implication right left valid consider implication 
assume ac model 
suppose 
ait 
monotonicity follows 
exercise observe holds maximal state 
suppose finite kripke model 

take maximal state obtain 
exercise consider logic formulas form equivalent true 
axioms remain sound 
valid 
exercise induction scheme applied formula 
means show formulas provable suffices apply modus ponens twice 
formula proven help axiom generalized 
second formula easily derived consequence axiom 
instance third axiom 
prove induction generalize step easy application axiom transitivity equality 
derive 
axiom transitivity equality formalize calculation 
hint prove induction 
base main induction respect 
induction step derive 
goes induction respect 
fun 
chapter 
solutions hints selected exercises exercise suppose function representable formula 
strongly representable formula 


show pa 
implies representability follows easily 
pa 
show pa pa 
pa remains permute exercise translation ha note tf atomic formula ha 
formula equivalent ha 
ha 
exercise hint cf 
exercise 
exercise model constant domain iff 
need refer monotonicity 
exercise exercise contains little trap notion complete model refers formulas including containing 
consider kripke models language containing satisfying appropriate weaker notion completeness 
semantics formula coincide expected semantics 
consider model states constant domain forcing 
model complete respect case different model complete respect 
exercise context derive 
consider context 
derive xx 
term type 

context 
exercise think types finite binary trees leaves labeled type variables internal nodes corresponding arrows 
internal nodes labeled quantifiers 
suppose xx typable environment containing declaration 
type universal quantifiers quantifiers bind type variable occurring leftmost path type 
self application impossible 
type assigned xx form leftmost path 
observation applies copies xx results different quantifiers attempt bind variable contradiction 
exercise type assigned form instance 
rightmost path long rightmost path 
addition variables say occur rightmost path 
remain rightmost path instance depth 
type second form obtained instantiating 
begins occurrences places 
particular occurrence depth rightmost path left subtree depth rightmost path right subtree 
type fx type fx 
matter type note doubled rightmost path length 
may type term type composed positions changed just instantiating 
exercise infinite sequence church style beta reductions mi mi erases infinite sequence curry style terms mi step chapter 
solutions hints selected exercises mi mi mi mi 
case hold possible steps mi mi caused type reductions form 
steps decreases number term process terminate 
bibliography anderson belnap 
entailment 
logic relevance necessity volume princeton university press 
anderson belnap dunn 
entailment 
logic relevance necessity volume ii 
princeton university press 
arts 
embedding order predicate logic second order propositional logic 
master thesis katholieke universiteit nijmegen 
arts dekkers 
embedding order predicate logic second order propositional logic 
technical report katholieke universiteit nijmegen 
van bakel ronchi della rocca urzyczyn 
comparing cubes typed type assignment systems 
annals pure applied logic 
dezani ciancaglini de 
intersection union types syntax semantics 
information computation 
barendregt 
lambda calculus syntax semantics 
north holland second revised edition 
barendregt 
lambda calculi types 
abramsky gabbay maibaum editors handbook logic computer science volume ii pages 
oxford university press 
barendregt bunder dekkers 
completeness systems illative combinatory logic order propositional predicate calculus 
appear archive mathematische logik 
barendregt bunder dekkers 
completeness propositions types interpretation intuitionistic logic illative combinatory logic 
appear journal symbolic logic 
bibliography barwise 
handbook mathematical logic 
north holland 
berardi 
type dependence constructive mathematics 
phd thesis universita di torino 
bezem 
simple proof undecidability inhabitation journal functional programming 
rose 
preservation strong normalisation named lambda calculi explicit substitution garbage collection 
csn computer science netherlands pages 
breazu tannen 
typed pattern calculus 
logic computer science pages 
damas 
principal types stratified combinators 
technical report dcc departamento de de universidade porto 
brouwer 
van mathematische 

akad 


church 
formulation simple theory types 
journal symbolic logic 
constable 
constructive mathematics automatic program writers 
ifip congress pages ljubljana 
constable 
programs proofs synopsis 
information processing letters 
curry 
grundlagen der logik 
teil american journal mathematics lii 
curry 
grundlagen der logik 
teil ii 
american journal mathematics lii 
curry 
functionality combinatory logic 
proceedings national academy science usa 
curry feys 
combinatory logic 
north holland 
curry hindley seldin 
combinatory logic ii volume studies logic foundations mathematics 
north holland 
van dalen 
intuitionistic logic 
handbook philosophical logic volume iii pages 
reidel publ 

bibliography damas milner 
principal type schemes functional programs 
conference record annual acm sigplan sigact symposium principles programming languages pages jan 
de bruijn 
survey project automath 
seldin hindley pages 
voronkov 
decidability problems prenex fragment intuitionistic logic 
logic computer science pages 
dekkers 
inhabitation types simply typed calculus 
information computation 
dowek 
undecidability typability lambda pi calculus 
bezem groote editors typed lambda calculus applications volume lecture notes computer science pages 
springer verlag 

completeness theorem higher order intuitionistic logic 
intuitionistic proof 
editor mathematical logic applications pages 
plenum press new york 
dwork kanellakis mitchell 
sequential nature unification 
journal logic programming 
fenstad editor 
proc 
second scandinavian logic symposium 
north holland amsterdam 
fortune leivant donnell 
simple second order type structures 
journal association computing machinery 
gabbay 
nd order intuitionistic propositional calculus full comprehension 
archiv mathematische logik und 
gabbay 
semantical investigations heyting intuitionistic logic 
reidel publ 

gallier 
constructive logics part tutorial proof systems typed calculi 
theoretical computer science 
gentzen 
untersuchungen ber das logische 
mathematische zeitschrift 
bibliography geuvers 
conservativity logics typed lambda calculi 
barendregt nipkow editors types proofs programs volume lecture notes computer science pages 
springer verlag 
geuvers 
logics type systems 
phd thesis university nijmegen 
geuvers nederhof 
modular proof strong normalization calculus constructions 
journal functional programming 
giannini ronchi della rocca 
characterization typings polymorphic type discipline 
proc 
symp 
logic computer pages 
computer society press 

girard 
interpr tation fonctionelle des coupures dans arithm ordre sup 
th se tat universit paris vii 

girard 
system variable types fifteen years 
theoretical computer science 

girard lafont taylor 
proofs types volume cambridge tracts theoretical computer science 
cambridge university press 

monadic infinitary propositional logic 
reports mathematical logic 
del ber eine noch nicht ben erweiterung des 
dialectica 
english translation philos 
logic 
griffin 
formulae types notion control 
conference record annual acm sigplan sigact symposium principles programming languages pages 
acm press 

map theory 
theoretical computer science 
harper honsell plotkin 
framework defining logics 
journal association computing machinery 
herbelin 
calculus structure isomorphic gentzen style sequent calculus structure 
computer science logic volume lecture notes computer science pages 
springer verlag 
bibliography heyting 
mathematische 


springer 
hindley 
basic simple type theory volume cambridge tracts theoretical computer science 
cambridge university press 
hindley seldin 
combinators calculus 
cambridge university press 

principal types bck lambda terms 
theoretical computer science 
hopcroft ullman 
automata theory languages computation 
addison wesley 
howard 
formulae types notion construction 
seldin hindley pages 
huet plotkin 
logical frameworks 
cambridge university press 
kleene 
interpretation intuitionistic number theory 
journal symbolic logic 
kleene 
metamathematics 
van nostrand 
kleene 
origins recursive function theory 
annals history computing 
kolmogorov 
zur der logik 
mathematische zeitschrift 
kreisel 
monadic operators defined means propositional quantification intuitionistic logic 
reports mathematical logic 
kremer 
complexity propositional quantification intuitionistic logic 
journal symbolic logic 

krivine 
lambda calculus types models 
ellis horwood series computers applications 
masson ellis horwood english edition 
embedding order predicate logic fragments intuitionistic logic 
journal symbolic logic 
mairson 
simple proof theorem statman 
theoretical computer science 
bibliography marlow 
deforestation higher order functional languages 
phd thesis university glasgow 
mendelson 
mathematical logic 
brooks cole advanced books software third edition 
mendelson 
mathematical logic 
chapman hall london fourth edition 
milner 
theory type polymorphism programming 
journal computer system sciences 
mitchell 
polymorphic type inference containment 
information control 
mitchell 
foundations programming languages 
mit press cambridge 
murthy 
extracting constructive contents classical proofs 
phd thesis cornell university 
murthy 
control operators pseudo classical type systems translation 
acm sigplan workshop continuations 
petersson smith 
programming martin type theory 
oxford university press 

ong 
semantic view classical proofs type theoretic categorical denotational characterizations 
logic computer science pages 
parigot 
free deduction analysis computations classical logic 
second russian conference logic programming volume lecture notes artificial intelligence pages 
springer verlag 
parigot 
calculus algorithmic interpretation classical natural deduction 
international conference logic programming automated reasoning volume lecture notes computer science pages 
springer verlag 
parigot 
classical proofs programs 
kurt del colloquium volume lecture notes computer science pages 
springer verlag 
parigot 
strong normalization second order classical natural deduction 
logic computer science 
bibliography plotkin 
call name call value calculus 
theoretical computer science 
pottinger 
normalization homomorphic image 
annals mathematical logic 
prawitz 
natural deduction proof theoretical study 
almquist wiksell 
prawitz 
results intuitionistic logic second order quantification 
pages 
north holland amsterdam 
prawitz 
ideas results proof theory 
fenstad pages 
sikorski 
mathematics metamathematics 
warsaw 
rehof rensen 
calculus 
hagiya mitchell editors theoretical aspects computer software volume lecture notes computer science pages 
springer verlag 
reynolds 
theory type structure 
robinet editor proceedings programming symposium volume lecture notes computer science pages 
springer verlag 

classical proofs lambda calculus methods elementary proof theory 
manuscript 

bhk 
manuscript 
robinson 
machine oriented logic resolution principle 
journal association computing machinery 
rosser 
highlights history lambda calculus 
annals history computing 
schubert 
second order unification type inference polymorphism 
proc 
th acm symposium principles programming languages pages january 
schwichtenberg 
elimination higher type levels definitions primitive recursive function means transfinite recursion 
rose editor logic colloquium pages 
north holland 
bibliography schwichtenberg 
funktionen im lambda mit typen 
archiv logik 
seldin hindley editors 
curry essays combinatory logic lambda calculus formalism 
academic press limited 

non axiomatizable second order intuitionistic propositional logic 
annals pure applied logic 
sobolev 
intuitionistic propositional calculus quantifiers russian 
mat 
sssr 
rensen 
normalization calculus type theory 
phd thesis department computer science university copenhagen 
available diku rapport 
rensen 
strong normalization weak normalization typed calculi 
information computation 
statman 
intuitionistic propositional logic polynomial space complete 
theoretical computer science 
tait 
intensional interpretations functionals finite type journal symbolic logic 
tait 
realizability interpretation theory species 
parikh editor logic colloquium volume lecture notes mathematics pages 
springer verlag 
troelstra 
metamathematical investigation intuitionistic arithmetic analysis volume lecture notes mathematics 
springer verlag 
troelstra van dalen 
constructivism mathematics volume volume studies logic foundations mathematics 
north holland 
troelstra van dalen 
constructivism mathematics volume ii volume studies logic foundations mathematics 
north holland 
troelstra schwichtenberg 
basic proof theory volume cambridge tracts theoretical computer science 
cambridge university press 

lo typ lambda 
master thesis warsaw 
bibliography urzyczyn 
positive recursive type 
jek editors mathematical foundations computer science volume lecture notes computer science pages 
springer verlag 
urzyczyn 
type inhabitation typed lambda calculi syntactic approach 
de groote hindley editors typed lambda calculus applications volume lecture notes computer science pages 
springer verlag 

cut rule explicit substitutions 
manuscript 
voronkov 
proof search intuitionistic logic equality back simultaneous rigid unification 
mc slaney editors cade volume lecture notes computer science pages 
springer verlag 
wadler 
deforestation transforming programs eliminate intermediate trees 
theoretical computer science 
wadler 
curry howard isomorphism sequent calculus 
manuscript 
wells 
typability type checking second order calculus equivalent undecidable 
proc 
symp 
logic computer pages 
ieee computer society computer society press 
zucker 
correspondence cut elimination normalization 
annals mathematical logic 
