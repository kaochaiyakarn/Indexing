reverse compilation techniques cristina cifuentes bc app sc computing qut bc computing qut submitted school computing science partial ful requirements degree doctor philosophy queensland university technology july cristina cifuentes author qut permission reproduce distribute copies thesis document part 
ii statement original authorship contained thesis previously submitted degree diploma higher education institution 
best knowledge belief thesis contains material previously published written person due 
signed date queensland university technology doctor philosophy thesis examination candidate name cristina nicole cifuentes centre research concentration programming languages systems principal supervisor professor gough associate supervisor professor caelli thesis title reverse compilation techniques requirements phd regulation candidate examined 
members panel set examination recommend thesis accepted university forwarded appointed committee examination 
name signature panel chairperson principal supervisor name signature panel member name signature panel member requirements phd regulation certi ed thesis named candidate examined 
recommend behalf examination committee thesis accepted ful conditions award degree doctor philosophy 
name signature examination committee chairperson date iii reverse compilation techniques cristina cifuentes techniques writing reverse compilers decompilers thesis 
techniques compiler optimization theory applied decompilation unique way techniques published 
decompiler composed phases grouped modules dependent language machine features 
front machine dependent module parses binary program analyzes semantics instructions program generates intermediate low level representation program control ow graph subroutine 
universal decompiling machine language machine independent module analyzes low level intermediate code transforms high level representation available high level language analyzes structure control ow graph transform graphs high level control structures 
back target language dependent module generates code target language 
decompilation process involves tools load binary program memory parse disassemble program decompile analyze program generate high level language program 
process bene ts compiler library signatures recognize particular compilers library subroutines 
compiler signature recognized binary program compiler start library subroutines decompiled case routines eliminated nal target program entry point main program decompiler analysis case subroutines replaced library name 
techniques implemented prototype decompiler intel architecture running dos operating system dcc produces target programs source exe com les 
sample decompiled programs comparisons initial high level language program analysis results chapter 
chapter gives decompilation compiler point view chapter gives overview history decompilation appearance early chapter presents relations static binary code source binary program actions performed run time implement program chapter describes phases front module chapter de nes data optimization techniques analyze intermediate code transform higher representation chapter de nes control structure transformation techniques analyze structure control ow graph transform graph high level control structures chapter describes back module chapter presents decompilation tool programs chapter gives overview implementation dcc results obtained chapter gives research 
vi parts thesis published submitted international journals 
papers xix de informatica methodology decompilation cg structuring algorithm decompilation cif 
phases decompiler described chapter section front chapter initial control ow analysis phase chapter comments done dcc 
structuring algorithms control ow analysis phase chapter 
journal decompilation binary programs cg accepted publication software practice experience gives overview techniques build decompiler summaries chapters signature generator tool help decompilation process chapter section sample decompiled program dcc chapter 
papers currently consideration publication international journals 
interprocedural data flow decompilation cif submitted journal programming languages describes full optimizations performed data ow analyzer transform low level intermediate code high level representation 
structuring decompiled graphs cif submitted computer journal gives nal improved method structuring control ow graphs chapter sample decompiled program dcc chapter 
techniques thesis expand earlier described literature 
previous decompilation document register analysis required determine register arguments register return values analysis required eliminate stack related instructions push pop structuring generic set control structures 
innovative done research described chapters 
chapter sections illustrate describe di erent types optimizations transform low level intermediate code high level representation 
optimizations take account condition codes subroutine calls interprocedural analysis register spilling eliminating low level features intermediate instructions condition codes registers introducing high level concept expressions intermediate representation 
chapter sections illustrate describe algorithms structure di erent types loops conditional including multi way branch conditionals case statements 
previous area concentrated structuring loops papers attempt structure way conditional branches multi way conditional branches described literature 
thesis presents complete method structuring types structures predetermined generic set high level control structures 
criterion determining generic set control structures chapter section 
chapter describes tools decompile programs important tool signature generator section determine compiler library signatures architectures operating system share libraries dos operating system 
acknowledgments feasibility writing decompiler contemporary machine architecture raised professors john gough bill caelli early 
problem appeared provide challenge areas graph data ow theory decided pursuing phd aim determining techniques reverse compilation binary programs 
thesis answer questions asked feasible write decompiler 
iwould time resources provided anumber people computing community 
professor john gough provided discussions data ow analysis commented draft chapter thesis 
sylvia willie lent ce lab initial stages degree 
pete french provided account bsd machine england test vax decompiler available network 
je rewrote disassembler 
michael van emmerik wrote library signature generator program generated compiler library signatures pc compilers ported dcc dos environment wrote interactive user interface dcc 
cao translated chinese article decompilation english studying qut 
geo proof read chapter pointed inconsistencies suggested layout thesis 
supported australian postgraduate research award scholarship duration degree 
je michael van emmerik employed australian research council arc 

thesis written lat preparation system 
gures produced facility interactive generation gures 
vii cristina cifuentes june author acknowledges trade marks registered names proprietary terms thesis legal property respective owners 
contents decompiling decompilers problems recursive undecidability von neumann architecture self modifying code idioms virus trojan tricks architecture dependent restrictions subroutines included compiler linker phases decompiler syntax analysis semantic analysis intermediate code generation control flow graph generation data flow analysis control flow analysis code generation grouping phases context decompiler uses decompilation legal aspects decompilation done 
previous run time environment storage organization stack frame data types data handling high level languages high level language interface stack frame parameter passing symbol table data structures contents front syntax analysis finite state automaton finite state parsers separation code data semantic analysis idioms simple type propagation intermediate code generation low level intermediate code high level intermediate code control flow graph generation basic concepts basic blocks control flow graphs data flow analysis previous elimination condition codes elimination redundant loads stores types optimizations dead register elimination dead condition code elimination condition code propagation register arguments function return register register copy propagation actual parameters data type propagation procedure calls register variable elimination global data flow analysis data flow analysis de nitions taxonomy data flow problems solving data flow equations code improving optimizations dead register elimination dead condition code elimination condition code propagation register arguments function return register register copy propagation actual parameters data type propagation procedure calls register variable elimination extended register copy propagation algorithm data type propagation contents xi control flow analysis previous boolean variables code replication multilevel exit loops structures graph transformation system graph structuring structuring loops structuring conditionals control flow analysis control flow analysis de nitions relations interval theory irreducible flow graphs high level language control structures control structures classi cation control structures rd generation languages generic set control structures structured unstructured graphs loops conditionals structured graphs reducibility structuring algorithms structuring loops structuring way conditionals structuring way conditionals application order back code generation generating code basic block generating code control flow graphs case irreducible graphs decompilation tools loader signature generator library subroutine signatures compiler signature manual generation signatures library prototype generator disassembler language independent bindings postprocessor xii contents dcc loader compiler library signatures library prototypes front parser intermediate code control flow graph generator semantic analyzer disassembler universal decompiling machine data flow analysis control flow analysis back code generation results exe exe exe exe exe exe exe fibo exe crc exe results architecture instruction format instruction set program segment pre executable file format exe files com files low level high level icode mapping comments error messages displayed dcc dos interrupts bibliography list figures decompiler turing machine representation sample self modifying code sample idioms modify return address self modifying code virus self encrypting virus self generating virus architecture dependent problem phases decompiler parse tree cx cx generic constructs decompiler modules decompilation system general format binary program skeleton code hello world program stack frame stack frame size di erent data types register conventions return values return value convention register parameter passing convention unordered list representation ordered list representation hash table representation symbol table representation phases front interaction parser semantic analyzer components fsa transition diagram fsa example sample code hello world program counter example initial parser algorithm final parser algorithm interaction semantic analyzer high level subroutine prologue register variables subroutine trailer code calling convention uses pop xiv list figures calling convention uses add pascal calling convention long addition long subtraction long negation shift long variable left shift signed long variable right shift unsigned long variable right assign zero shift left bitwise negation sign determination conditional jump long conditional graphs long equality boolean conditional code long non equality boolean conditional code interaction intermediate code generator low level intermediate instructions example general representation quadruple general representation triplet interaction control flow graph generator sample directed connected graph node representation di erent types basic blocks control flow graph example basic block de nition context data flow analysis phase sample flow graph flow graph code optimization data flow analysis equations data flow problems summary live register example graph flow graph optimization dead register elimination algorithm update du chains dead condition code elimination algorithm condition code propagation algorithm bnf conditional expressions register argument algorithm function return register register copy propagation algorithm expression stack potential high level instructions de ne registers extended register copy propagation algorithm matrix addition subroutine context control flow analysis phase sample control flow graph list figures xv post tested loop pre tested loop way conditional branching single branch conditional compound conditional branch interval algorithm intervals graph derived sequence algorithm derived sequence graph canonical irreducible graph high level control structures control structures classes hierarchy classes control structures high level languages structured loops sample unstructured loops structured way conditionals structured way conditional abnormal selection path unstructured way conditionals graph grammar class structures intervals control flow graph derived sequence graphs loop structuring algorithm loops cases algorithm mark nodes belong loop induced algorithm determine type loop algorithm determine follow loop control flow graph immediate dominator information way conditional structuring algorithm compound conditional graphs subgraph intermediate instruction information compound condition structuring algorithm unstructured way subgraph abnormal exit unstructured way subgraph abnormal entry way conditional structuring algorithm unstructured graph loops cases canonical irreducible graph immediate dominator information relation code generator udm sample control flow graph data control flow analyses syntax tree instruction algorithm generate code expression tree algorithm generate code basic block control flow graph structuring information algorithm generate code loop header rooted graph algorithm generate code way rooted graph xvi list figures algorithm generate code way rooted graph algorithm generate code way call fall rooted graphs algorithm generate code control flow graph algorithm generate code call graph final code graph canonical irreducible graph structuring information decompilation system general format binary program loader algorithm partial disassembly library function signature library function signature algorithm disassembler part decompiler structure dcc decompiler main decompiler program program information record front procedure procedure record machine instructions represent icode instruction low level intermediate code low level intermediate code continued low level intermediate code continued basic block record post increment decrement conditional jump pre increment decrement conditional jump procedure universal decompiling machine back procedure bundle data structure de nition statistics continued statistics continued continued continued continued continued continued list figures xvii continued statistics control flow graph boolean assignment continued continued statistics continued continued continued continued continued statistics continued statistics continued continued continued statistics fibo fibo continued fibo fibo fibo statistics crc crc continued crc continued crc continued crc crc continued crc continued crc crc continued crc continued crc statistics xviii list figures continued statistics results tested programs register classi cation structure flags register compound opcodes second byte fields byte algorithm interpret fields byte mapping eld default segments segment override pre byte opcodes byte opcodes continued byte opcodes continued byte opcodes continued byte opcodes continued byte opcodes continued byte opcodes continued table opcodes table opcodes table opcodes table opcodes psp fields structure exe file fixed formatted area icode opcodes icode opcodes continued icode opcodes continued dos interrupts dos interrupts continued dos interrupts continued chapter decompiling writing techniques known computer community decompiler writing techniques known 
interestingly decompiler writing techniques compiler writing techniques explained thesis 
chapter introduces subject decompiling describing components decompiler environment decompilation binary program done 
decompilers decompiler program reads program written machine language source language translates equivalent program high level language target language see 
decompiler reverse compiler attempts reverse process compiler translates high level language program binary executable program 
source program machine language decompiler decompiler target program high level language basic decompiler techniques decompile binary programs wide variety machine languages diversity high level languages 
structure decompilers structure compilers similar principles techniques perform analysis programs 
rst decompilers appeared early decade compiler counterparts 
rst compilers early decompilation dealt translation scienti programs 
chapter describes history decompilation 
problems decompiler writer face theoretical practical problems writing decompiler 
problems solved heuristic methods determined completely 
due limitations decompiler performs automatic program translation source programs semi automatic program translation decompiling source programs 
di ers compiler performs automatic program translation source programs 
section looks problems involved 
recursive undecidability general theory computability tries solve decision problems problems inquire existence algorithm deciding truth falsity statements 
positive solution algorithm proof non existence algorithm needed case say problem unsolvable undecidable non computable 
unsolvable problems partially computable algorithm answers program halts loops forever 
mathematical world concept described modelled terms mathematical de nitions 
abstraction algorithm described terms called turing machine 
turing machine computing machine prints symbols linear tape nite length directions possesses nite number states performs actions speci ed means quadruples current internal con guration current symbol tape 
shows representation turing machine 
control unit read write device tape turing machine representation halting problem turing machine consists determining instantaneous description exists computation begins words trying determine halt placed initial state 
proved problem recursively unsolvable partially computable dav gl 
binary program separation data code programs allow practices self modifying code equivalent halting problem unknown general particular instruction executed consider code loop 
implies problem partially computable algorithm written data code cases 
problems von neumann architecture von neumann machines data instructions represented way memory 
means byte located memory known data instruction byte fetched memory placed register data instruction 
segmented architectures data segments hold data information code segments hold instructions data stored code segment form table case tables intel architecture instructions stored form data executed interpreting instructions 
method part modula compiler pc interprets intermediate code stack machine 
intermediate code stored data set particular procedure pointed es di gcc 
self modifying code self modifying code refers instructions preset data modi ed execution program 
memory byte location instruction modi ed program execution represent instruction data 
method years di erent purposes 
computers memory di cult run large programs 
computers maximum kb kb available time 
space constraint utilized best way 
bytes executable program reusing data locations instructions vice versa 
way memory cell held instruction time data instruction time 
instructions modi ed instructions needed executed di erent code time program executed section code 
nowadays memory limitations computers self modifying code 
writing encrypting programs virus code see section 
sample self modifying code intel architecture 
inst de nition modi ed mov instruction data bytes 
move inst treated instruction unconditional jump set 
mov memory location held executed nop instructions 
idioms code mov inst jmp offset inst db nop sample self modifying code idiom idiomatic expression sequence instructions form logical entity taken meaning derived considering primary meanings instructions 
decompiling example multiplication division powers commonly known idiom multiplication performed shifting left division performed shifting right 
idiom way long variables added 
machine word size bytes long variable bytes 
add long variables low bytes added rst followed high bytes account carry rst addition 
idioms meaning illustrated 
idioms known computer community unfortunately widely known 
virus trojan tricks shl ax add ax bp adc dx bp mul ax add dx ax bp bp sample idioms virus programs written trigger malicious code hide code means tricks 
di erent methods viruses hide malicious code including self modifying encrypting techniques 
illustrates code virus stores stack procedure 
seen segment set addresses virus code pushed stack followed return far instruction transfers control virus code 
disassembling code disassemblers far return instruction believing procedure met case 
code ax holds segment seg value seg push ax set segment seg mov ax ax holds offset seg push ax set offset seg jump virus code seg ca seg ca virus code modify return address frequently trick self modifying code modify target address set unconditional jump de ned data 
illustrates relevant code cia virus execution 
seen cont de ne data problems items respectively 
execution program modi es contents set virus code procedure return instruction jmp executed treating data instructions 
start call invoke procedure cont db opcode jmp dw mov ret cs virus virus code 
self modifying code virus virus code encrypted form decryption code performed needed 
simple encryption decryption mechanism performed xor function xors constant equivalent original byte 
way encryption performed application xor code decryption performed xoring code constant value 
virus illustrated part virus 
encrypt decrypt mov bx offset virus code get address start encrypt decrypt xor loop mov ah bx get current byte xor ah encrypt val encrypt decrypt xor mov bx ah put back got bx bx points byte cmp bx offset virus code virus size 
xor loop cycle ret self encrypting virus polymorphic mutation encrypt viruses 
idea virus sections code regularity instruction set 
illustrates encryption engine virus 
di erent key time encryption loop ax encryption done means xor instruction 
decompiling encryption engine ab mov cx ae mov ax ch encryption loop xor cs si ax si dec ah ax loop encryption loop ba self generating virus general virus programs aw machine language set self modifying code self encrypting code undocumented operating system functions 
type code hard disassemble automatically modi cations instructions data done program execution 
cases human intervention required 
architecture dependent restrictions contemporary machine architectures prefetch bu er fetch instructions processor executing instructions 
means instructions prefetched stored di erent location instructions main memory 
program uses self modifying code attempt modify instruction memory instruction prefetched modi ed memory pipeline bu er initial unmodi ed instruction executed 
example seen 
case data de nition really instruction jmp 
de nition appears modi ed previous instruction mov ax places nop instructions de nition 
mean code executed displaying hello world exiting 
running program machine share enjoy displayed 
prefetch bu er bytes de nition modi ed prefetched jump done share enjoy displayed 
type code determined normal straight line step debuggers complete emulation machine done 
subroutines included compiler linker problem decompilation great number subroutines introduced compiler number routines linked linker 
compiler include start subroutines set environment runtime support routines required 
routines normally written assembler cases higher level representation 
operating systems provide mechanism sharing libraries consequently binary programs self contained phases decompiler mov ax nop mov ax db jmp mov dx mov ah int display string int exit mov dx mov ah int display string int exit db share enjoy dh ah db hello world dh ah architecture dependent problem library routines bound binary image 
library routines written language compiler written assembler 
means binary program contains routines written programmer great number routines linked linker 
example program written display hello world compiled pc di erent subroutines binary program 
similar program written pascal compiled pc generates subroutines executable program 
routines reverse engineer normally interested just initial subroutine main program 
phases decompiler conceptually decompiler structured similar way compiler series phases transform source machine program representation 
typical phases decompiler shown 
phases represent logical organization decompiler 
practice phases grouped seen section 
point note lexical analysis scanning phase decompiler 
due simplicity machine languages tokens represented bytes bits byte 
byte possible determine byte forms start new token example byte represent opcode push ax instruction immediate constant set data location 
decompiling syntax analysis binary program syntax analyzer semantic analyzer intermediate code generator control flow graph generator data flow analyzer control flow analyzer code generator hll program phases decompiler parser syntax analyzer groups bytes source program grammatical phrases sentences source machine language 
phrases represented parse tree 
expression sub cx semantically equivalent cx 
expression represented parse tree shown 
phrases expression cx cx exp 
phrases form hierarchy nature machine language hierarchy maximum levels 
cx assignment statement identi er xxxxxxxxx identi er cx expression parse tree cx cx constant main problem encountered syntax analyzer determining data instruction 
example case table located code segment unknown decompiler table data instructions due architecture von neumann machine 
case instructions parsed phases decompiler sequentially assuming byte hold instruction 
machine dependent heuristics required order determine correct set instructions 
syntax analysis covered chapter 
semantic analysis semantic analysis phase checks source program semantic meaning groups instructions gathers type information propagates type subroutine 
binary programs produced compiler semantics machine language correct order program execute 
rarely case binary program run due errors code generated compiler 
semantic errors source program syntax analyzer parsed instruction incorrectly data parsed instructions 
order check semantic meaning group instructions idioms looked 
idioms transformed semantically equivalent instructions multiplication ax rst case addition long variables second case 
bp bp represent long variable particular subroutine dx ax holds value long variable temporarily subroutine 
registers long register subroutine needed 
type propagation newly types idiomatic expressions done graph 
example stack locations subroutine known long variable 
locations de ned independently converted de nition long variable 
statements part code subroutine asgn bp asgn bp propagation long type bp bp merge statements represents identi ers asgn bp bp semantic errors normally produced compiler generating code executable programs run advanced architecture consideration 
example say decompile binaries architecture 
new architectures architecture binary programs stored way 
di erent new architectures respect machine language registers instructions 
instruction add ebx register identi er ebx bit register old architecture 
instruction syntactically correct semantically correct machine language decompiling error needs reported 
chapter covers analysis done phase 
decompiling intermediate code generation explicit intermediate representation source program necessary decompiler analyse program 
representation easy generate source program suitable representation target language 
semantically equivalent representation illustrated section ideal purpose address code representation instruction operands 
operands identi ers machine language easily extended expressions represent high level language expressions identi er expression 
way address representation instruction expressions 
chapter describes intermediate code decompiler 
control flow graph generation control ow graph subroutine source program necessary decompiler analyse program 
representation suited determining highlevel control structures program 
eliminate intermediate jumps compiler generated due set limitations conditional jump machine language 
code code jne maximum offset allowed jne code jmp intermediate jump code final target address label target address conditional jump jne instruction limited maximum set allowed machine architecture execute conditional jump instruction intermediate jump instruction 
control ow graph conditional jump replaced nal target jump data flow analysis data ow analysis phase attempts improve intermediate code high level language expressions 
temporary registers condition ags eliminated analysis concepts available high level languages 
series intermediate language instructions asgn ax bp eh asgn bx bp ch asgn bx bx asgn ax ax bx asgn bp eh ax nal output terms high level expression asgn bp eh bp eh bp ch phases decompiler rst set instructions registers constants expressions terms identi ers maximum tree level 
analysis nal instruction stack variable identi ers bp eh bp ch expression tree levels bp eh bp eh bp ch 
temporary registers machine language calculate high level expression ax bx loading storing registers eliminated 
chapter presents algorithm perform analysis eliminate intermediate language instructions push pop 
control flow analysis control ow analyzer phase attempts structure control ow graph subroutine program generic set high level language constructs 
generic set contain control instructions available languages conditional transfers control 
language speci constructs allowed 
shows sample control ow graphs 
chapter presents algorithm structuring arbitrary control ow graphs 
code generation 


generic constructs nal phase decompiler generation target high level language code control ow graph intermediate code subroutine 
variable names selected local stack argument register variable identi ers 
subroutine names selected di erent routines program 
control structures intermediate instructions translated high level language statement 
example section local stack identi ers bp eh bp ch arbitrary names loc loc respectively instruction translated say language loc loc loc code generation covered chapter 
decompiling grouping phases decompiler phases section normally grouped implementation decompiler 
shown di erent modules distinguished front udm back 
binary program front machine dependent udm analysis back language dependent hll program decompiler modules front consists phases machine machine language dependent 
phases include lexical syntax semantic analyses intermediate code control ow graph generation 
phases produce intermediate machineindependent representation program 
udm universal decompiling machine intermediate module completely machine language independent performs core decompiling analysis 
phases included module data ow control ow analyzers 
back consists phases high level target language dependent 
module code generator 
compiler theory grouping phases mechanism compiler writers generate compilers di erent machines di erent languages 
back compiler rewritten di erent machine new compiler machine original front 
similar way new front high level language de nition written original back 
practice limitations method inherent choice intermediate code representation 
context decompiler theory grouping phases decompiler easy write di erent decompilers di erent machines languages writing di erent front ends di erent machines di erent back ends di erent target languages 
practical applications result limited generality intermediate language 
context decompiler practice programs decompiler create target highlevel language program 
general source binary programs relocation table addresses relocated program loaded memory 
task accomplished loader 
relocated absolute machine code disassembled produce assembly representation program 
disassembler help compiler library signatures eliminate disassembling compiler start code library routines 
assembler program input decompiler high level target program generated 
processing required target program converting loops loops done postprocessor 
shows steps decompilation 
user source information particularly determining library routines separation data instructions 
possible reliable automatic tools 
decompiler helper tools covered chapter 
section brie explains task 
loader relocatable machine code loader absolute machine code disassembler assembler program decompiler hll program postprocessor hll program xxxx libraries signature generator library signatures compiler signatures library bindings decompilation system library headers prototype generator library prototypes loader program loads binary program memory relocates machine code relocatable 
relocation instructions altered placed back memory 
decompiling signature generator signature generator program automatically determines compiler library signatures binary pattern uniquely identi es compiler library subroutine 
signatures attempts reverse task performed linker links library compiler start code program 
way analyzed program consist user subroutines ones user compiled initial high level language program 
example compiled program displays hello world different subroutines binary program subroutines added compiler set environment routines form part printf added linker subroutine formed part initial program 
signature generator reduces number subroutines analyze increases documentation target programs library names arbitrary subroutine names 
prototype generator prototype generator program automatically determines types arguments library subroutines type return value case functions 
prototypes derived library header les decompiler determine type arguments library subroutines number arguments 
disassembler disassembler program transforms machine language assembler language 
decompilers transform assembler programs higher representation see chapter 
cases assembler program produced disassembler written assembler compiler compiled assembler 
library bindings target language decompiler di erent original language compile binary source program generated target code library names library signatures detected program correct recompiled target language library routines language 
library bindings solves problem binding subroutines language 
postprocessor postprocessor program transforms high level language program semantically equivalent high level program written language 
example target language code uses decompilation loc loc code loc loc converted postprocessor loc loc loc code equivalent program control structures available language generic set structures decompiled decompiler 
uses decompilation decompilation tool computer professional 
major areas decompilation software maintenance security 
area decompilation recover lost inaccessible source code translate code written obsolete language newer language structure old code written unstructured way spaghetti code structured program migrate applications new hardware platform debug binary programs known bugs source code unavailable 
area decompilation tool verify object code produced compiler software critical systems compiler trusted systems check existence malicious code viruses 
legal aspects questions raised years regarding legality decompilation 
debate supporters decompilation claim fair competition possible decompilation tools opponents decompilation claim copyright decompilation currently held 
law di erent countries modi ed determine cases decompilation 
commercial software sold software agreements ban user disassembling decompiling product 
example part lotus software agreement reads may alter merge modify adapt sofware way including disassembling decompiling 
purpose thesis debate legal implications decompilation 
topic covered thesis 
chapter decompilation done 
erent attempts writing decompilers years 
due amount information lost compilation process able regenerate high level language code experimental decompilers limitations way including decompilation assembly les hou fri wor hop bri object les symbolic debugging information reu pw simpli ed highlevel language hou requirement compiler speci cation bb bb 
assembly programs helpful data information form symbolic text data segments data type declarations subroutine names subroutine entry point subroutine exit statement 
information collected symbol table decompiler need address problem separating data instructions naming variables subroutines 
object les debugging information contain program symbol table constructed compiler 
symbol table easy determine memory locations instructions certainty memory locations represent data 
general object les contain information binary les 
knowledge compiler speci cations impractical speci cations normally disclosed compiler manufacturers 
previous decompilers considered useful software tool rst 
time decompilers aid program conversion process second third generation computers way manpower spent time consuming task rewriting programs third generation machines 
decompilers portability programs documentation debugging re creation lost source code modi cation existing binaries 
decompilers reverse engineering tool capable helping user tasks checking software existence illegal code checking compiler generates right code translation binary programs machine 
noted decompilation software piracy breach copyright process incomplete general tool help develop task 
descriptions illustrate best known decompilers research performed decompiler topics individual researchers companies decompiler 
reported halstead hal donnelly decompiler produced donnelly navy decompilation done 
electronics laboratory nel 
algol type language developed nel 
decompiler produced code machine code programs di erent versions written rand computer control data computer 
proved useful converting non compiled programs detecting logic errors original high level program 
decompiler proved feasibility writing decompilers 

developed decompiler trw aid conversion process programs nd rd generation computers 
decompiler took input symbolic assembler programs ibm series produced fortran programs 
binary code chosen input language information symbolic assembler useful 
fortran standard language ran nd rd generation computers 
engineering applications algebraic algorithms type programs decompiled 
user required de ne rules recognition subroutines 
decompiler accurate manual intervention required sas 
rst decompiler assembler input programs pure binary code 
assembler programs contain useful information form names macros data instructions available binary executable programs eliminate problem separating data instructions parsing phase decompiler 
halstead 
lockheed missiles space added enhancements compiler developed navy electronics laboratory cater decompilation hal 
decompiler took input machine code ibm produced code 
proved successful decompiling instructions leaving programmer decompile 
decompiler contract customers canada hal 
halstead analyzed implementation ort required percentage correctly decompiled instructions half way approximately equal ort spent hal 
decompilers time handled straightforward cases harder cases left programmer consider 
order handle cases time required special cases decompiler time proportionately greater time required simple cases 
cobol conversion aid program 
reported set commercial decompilers developed ibm translate programs business data processing oriented cobol 
translation toone mapping manual optimization required 
size nal programs occupied times core storage original program hou 
decompiler really translation tool language 
attempt analyze program reduce number instructions generated 
ine cient code produced general 
previous hollander 
hollander phd dissertation hol describes decompiler designed formal syntax oriented metalanguage consisting cooperating sequential processes initializer scanner parser constructor generator implemented interpreter sets metarules 
decompiler de ned operations implementing interpreters 
initializer loads program converts internal representation 
scanner interacts initializer nding elds instruction interacts parser matching source code templates instructions 
parser establishes correspondence syntactic phrases source language semantic equivalents target language 
constructor generator generate code nal program 
experimental decompiler implemented translate subset ibm system assembler algol target language 
decompiler written algol compiler developed stanford university correctly programs tested 
presents novel approach decompilation means formal metalanguage main drawback precisely methodology equivalent pattern matching operation assembler instructions high level instructions 
limits amount assembler instructions decompiled instructions belong pattern need intermediate instructions di erent control ow patterns optimized code allowed 
order syntax oriented decompilers set possible patterns need tobe enumerated high level instruction di erent compiler 
approach write decompiler speci compiler speci cations compiler approach possible compiler writer willing reveal speci cations compiler 
appears hollander decompiler worked compiler speci cations algol compiler known compiler written university doing research 
set assembler instructions generated algol instruction known case 

phd dissertation hou describes clear approach borrowing concepts compiler graph optimization theory 
decompiler involves major phases partial assembly analyzer code generation 
partial assembly phase separates data instructions builds control ow graph generates intermediate representation program 
analyzer analyzes program order detect program loops eliminate unnecessary intermediate instructions 
code generator optimizes translation arithmetic expressions generates code target language 
experimental decompiler written knuth mix assembler producing pl code ibm machines 
programs tested instructions correct remaining instructions required manual intervention hh 
decompiler proved known compiler graph methods decompiler written produced high level code 
intermediate decompilation done 
representation analysis completely machine independent 
main objection methodology choice source language mix assembler greater amount information available programs simpli ed non real life assembler language 
piler system 
piler system attempts general decompiler translates large class source target language pairs help automatic translation computer programs 
piler system composed phases interpretation analysis conversion 
way di erent interpreters written di erent source machine languages di erent converters written di erent target high level languages making simple write decompilers di erent source target language pairs 
uses decompiler included documentation debugging aid evaluation code generated compiler 
interpretation source machine program loaded memory parsed converted address representation 
meant machine instruction required instructions 
analyzer determined logical structure program means data ow analysis modi ed representation intermediate representation 
program analysis available users modify errors behalf decompiler 
converter generated code target high level language bar 
piler system attempted general decompiler interpreter machine language ge honeywell computer written skeletal converters fortran cobol developed 
main ort project concentrated analyzer 
piler system rst attempt general decompiler large class source target languages 
main problem attempt general representation lower level assembler type representation 
friedman 
friedman phd dissertation describes decompiler transfer mini computer operating systems architectural class fri 
main phases described pre processor decompiler code generator compiler 
pre processor converts assembler code standard form descriptive assembler language 
decompiler takes standard assembler form analyses internal representation code generated code generator 
compiler compiles program machine code machine 
high level language program transport development developed friedman wrote compiler 
decompiler project adaptation decompiler hou 
experiments performed rst involved transport small self contained portion ibm disk monitor system microdata manual intervention required input assembler programs 
amount ort required prepare code input transport system great completed reasonable amount time second experiment previous conducted 
second experiment decompiled microdata operating system programs compiled back microdata machine code 
resultant programs re inserted operating system tested 
average input assembler instructions required manual intervention nal machine program increase number machine instructions 
dissertation rst attempt decompiling operating system code illustrates di culties faced decompiler decompiling machine dependent code 
input programs transport system require large amount ort format required system nal produced programs appear ine cient size program time execute machine instructions 

reported decompilation project consultant design system hop 
decompiler documentation tool trident submarine re control software system 
took input trident assembler programs produced programs trident high level language developed 
main stages distinguished normalization analysis expression condensation code generation 
input assembler programs normalized data areas distinguished pseudo instructions 
intermediate representation generated data analyzed 
arithmetic logical expressions built process expression condensation nally output high level language program generated matching control structures available 
project attempts document assembler programs converting highlevel language 
fact time constraints project expression condensation phase coded output programs hard read instructions required single expression 
schneider 
schneider notation specifying compilation decompilation high level languages 
de ning context free grammar compilation process describe possible address object code produced expressions assignments shows grammar inverted decompile object code original source program sw 
ambiguous compilation grammar produce optimal object code generate unambiguous decompilation grammar 
case study showed object code produced algol constructs decompiled deterministically 
part decompiler literature 
presents di erent way syntax oriented decompiler hol decompiler uses pattern matching series object instructions reconstruct original source program 
case compilation grammar needs known order invert grammar grammar 
note optimization possible de ned compilation grammar 
decompilation done 
decompilation polish code 
papers area decompilation polish code basic code literature 
problem arises connection highly interactive systems fast response required input user 
user program kept intermediate form decompiled time command issued 
algorithm translation reverse polish notation expressions bp 
second presents process decompilation step problem need convert machine code polish representation conversion polish code source form 
concentrates second step decompilation problem claims decompiling polish code basic code means context free grammar polish notation left right right left parsing scheme bp 
technique decompiler converted reverse polish code spreadsheet expressions may 
case programmers product included spreadsheet speed product storing user expressions compiled form reverse polish notation case decompile expressions user wanted see modify 
parentheses left part reverse polish notation reconstruct exact expression user input system 
word decompilation sense misuse term 
papers method re constructing original expression written basic spreadsheet expressions intermediate polish representation program 
case polish basic translators explanation arrive intermediate representation machine program 

phd dissertation hop describes step decompiler designed purposes transferability documentation 
stated decompilation process aided manual intervention external information 
input program decompiler formatted preprocessor loaded memory control ow graph program built 
nodes graph represent instruction 
constructing graph control patterns recognized instructions generate goto statement eliminated node splitting synthetic variables 
source program translated intermediate machine independent code analysis variable usage performed representation order nd expressions eliminate unnecessary variables method forward substitution 
generated intermediate instruction functions implemented represent operations supported target language comments provided 
manual intervention required prepare input data provide additional information decompiler needed translation process modi cations target program 
experimental decompiler written varian data machines decompiled assembler mol machine oriented language developed university california irvine author 
decompiler tested previous large debugger program written assembler 
generated decompiled program manually modi ed recompile machine code calls interrupt service routines self modifying code extra registers subroutine calls 
nal program better documented original assembler program 
main drawbacks research granularity control ow graph registers nal target program 
case chose build control ow graphs node instruction means size control ow graph quite large large programs gained opposed nodes basic blocks size nodes dependent number changes ow control 
case mol language allows machine registers sample code illustrated dissertation shows registers expressions arguments subroutine calls 
concept registers high level concept available high level languages wanting generate highlevel code 

describes decompilation design high level language suitable real time training device systems particular trainer aircraft wor 
operating system written assembler input language decompiler 
output language determined project design code generation implemented 
phases decompiler implemented rst phase mapped assembler intermediate language gathered statistics source program second phase generated control ow graph basic blocks classi ed instructions probable type analyzed ow order determine high level control structures 
results indicated need high level language handled bit strings supported looping conditional control structures require dynamic data structures recursion 
presents novel decompilation techniques input language machine code assembler 
simple data analysis done classifying instructions attempt analyze completely need generate high level code 
analysis control ow complete considers di erent way conditional statements 
zebra 
zebra prototype developed naval underwater systems centre attempt achieve portability assembler programs 
zebra took input subset ultra assembler called produced assembler pdp 
project described bri 
zebra decompiler composed passes lexical ow analysis pass parsed program performed control ow analysis graph basic blocks 
second pass concerned translation program intermediate form third pass simpli ed intermediate representation eliminating extraneous loads stores way described hou hh 
decompilation done 
concluded hard capture semantics program decompilation economically impractical aid transportation process 
project known technology develop decompiler assembler programs 
new concepts introduced research raised point decompilation aid solution problem tool give solutions problem correct decompiler built 
decompilation dml programs 
decompiler database code designed convert subset dml programs written procedural operations relational system query speci cation 
access path model introduced interpret semantic accesses performed program 
order determine find operations implement semantic accesses global data ow reaching analysis performed control ow graph operations matched templates 
nal graph structures remapped relational structure 
method depends logical order objects standard ordering dml statements kw 
decompiler database code proposed decompile coded application programs proposed semantic representation described ds 
induced changes requirements database management system dbms application programs written cobol dml 
decompiler cobol dml programs written analyse convert application programs model schema independent representation 
representation modi ed restructured account database changes 
language templates match key instructions cobol dml programs 
context databases decompilation viewed process grouping sequence statements represent query speci cation 
data ow analysis required stages decompiler implemented type application 
forth decompiler 
recursive forth decompiler tool scans compiled dictionary entry words primitives addresses 
decompiler considered useful tools forth toolbox hm 
decompiler implements recursive descent parser decompiled words decompiled recursive fashion 
works tool decompiler 
tool recursively scans dictionary table returns primitives addresses associated word 
software transport system 
yoo describes automatic software transport system sts moves assembler code machine 
process involves decompilation assembler program machine highlevel language compilation program machine assembler 
experimental decompiler developed intel architecture took input assembler programs produced pl programs 
recompiled pl programs cient assembler counterpart 
experimental previous sts developed develop cross compiler processor 
project encountered problems lack data type sts yoo 
sts took input assembler program machine assembler grammar machine produced assembler program machine 
input grammar parsed produced tables syntax tree parser parse input assembler program generate syntax tree ast program 
ast input decompiler performed control data ow analyses way described hollander hol friedman fri bar nally generated high level code 
highlevel language compiled machine 
new research decompilation area novel approach transportation assembler programs means grammar describing assembler instructions target architecture 
decomp 
reuter wrote decomp decompiler vax bsd took input object les symbolic information produced programs 
nature decompiler port empire game vms environment source code available 
decompiler freely available internet reu 
decomp symbol table nd entry points functions determine data program names data 
subroutines decompiled time way control ow graph basic blocks built optimised removal arcs leading intermediate unconditional branches 
control ow analysis performed graph nd high level control constructs converting control ow graph tree generic constructs 
algorithm analysis taken struct program program structures graphs produced programs structuring algorithm described baker bak 
generic constructs tree converted speci constructs code generated 
nal output programs required manual modi cations place arguments procedure argument list determine subroutine returned value function 
decompiler written man months reu 
sample programs written compiled bsd machine collaboration pete french fre provided vax bsd machine 
resulting programs compilable require hand editing 
programs correct control structures due structuring algorithm implemented right data type variables due embedded symbol table object code 
names library routines procedures user program entry point known symbol table extraneous procedures compiler start code library routines decompiled 
need data ow analysis stage vital expressions actual arguments function return value determined 
interprocedural data ow analysis eliminate hand editing required output programs 
exe 
austin code works sponsored decompiler targetted pc compatible family computers running dos operating decompilation done 
system wor 
project announced april gut tested people decided needed decompile project reached operational level gut nished gut 
beta tester release 
exe multipass decompiler consists programs 
disassembler 
converts executable les assembler produces commented assembler listing 
assembler front processor analyzes assembler le produced generates cod glb les 
thee program translates les prepared generates pseudo 
integrated environment provided 
programs decompiled exe header le de nes registers types macros 
output programs hard understand rely registers condition codes represented boolean variables 
normally machine instruction decompiled instructions perform required operation registers set condition codes required instruction 
expressions arguments subroutines determined local stack nal programs 
obvious output code data ow analysis implemented exe 
decompiler implemented control ow analysis stage looping conditional constructs available 
choice control constructs generally adequate 
case tables detected correctly 
number type procedures decompiled shows library routines compiler start code runtime support routines program decompiled 
nature routines normally low level normally written assembler 
routines hard decompile cases high level counterpart low level type code 
decompiler rst ort years decompile executable les 
results show data ow analysis heuristics code 
skip extraneous code introduced compiler detect library subroutines bene cial 
plm decompiler 
information technology division australian department defence researched decompilation defence applications maintenance obsolete code production scienti technical intelligence assessment systems hazards safety security 
described hood hoo 
techniques construction decompilers de nite clause grammars extension context free grammars prolog environment described 
prolog database store initial assembler code recognised syntactic structures grammar 
prototype decompiler intel assembler programs compiled plm compiler written prolog 
decompiler produced target programs small subset language 
de nite clause grammar report capable recognizing type structures loops static global automatic local variables simple types character integers 
graphical user interface written display assembler pseudo programs enable user assign variable names previous comments 
interface asked user entry point main program allowed select control construct recognized 
analysis performed decompiler limited recognition control structures simple data types 
analysis registers done mentioned 
automatic variables represented indexed variable represents stack 
graphical interface helps user document decompiled program means comments meaningful variable names 
analysis support optimized code 
decompiler compiler 
decompiler compiler tool takes input compiler speci cation corresponding portions object code returns code decompiler automatic way generating decompilers way yacc generate compilers bbl bb bb 
approaches described generate decompiler compiler logic functional programming approach 
approach bidirectionality logic programming languages prolog runs speci cation compiler backwards obtain decompiler bbl bb bbl 
theory correct practice approach limited implementation prolog interpreter problems strictness reversibility encountered bb bb 
approach logic approach lazy functional programming languages haskell generate cient decompiler bbl bb bbl 
non lazy functional language laziness simulated form objects lists 
decompiler produced decompiler compiler take input object code return list source codes compiled object code 
order achieve enumeration possible source codes required description arbitrary inherited attribute grammar 
proved enumeration equivalent halting problem bb bb non computable 
computable method takes attribute grammar description decides compiled code give terminating enumeration value attribute bb bb straightforward grammars 
class grammars acceptable method needs restricted produce complete enumeration non left recursive grammars 
implementation method rstly done subset language functional programming language 
decompiler grammar inherited attribute grammar took intended object code argument bb bb 
prolog decompiler described compiler speci cation 
decompiler applied clauses compiler selective ordered way problem non termination met subset source code programs returned nite list bow bow 
method imperative programming language due ine ciencies functional logic approach 
prototype object lazy lists set library functions written implement operators intermediate representation bb 
problems optimized code detected 
decompilation done 
illustrated research decompiler compilers constructed automatically set compiler speci cations object code produced clause speci cation known 
general case compiler writers disclose compiler speci cations 
customized compilers decompilers built method 
noted optimizations produced optimization stage compiler handled method real executable programs decompiled decompilers generated method described 
problem separating instructions data addressed problem determining data types variables executable program 
decompiler compilers generated automatically object code produced bya compiler known generated decompilers decompile arbitrary executable programs 
decompiling system 
decompiler takes input executable les dos environment produces programs 
input les need compiled microsoft version small memory model 
phases described recognition library functions symbolic execution recognition data types program transformation code generation 
recognition library functions intermediate language described fz 
recognition library functions microsoft done eliminate subroutines part library produce code user routines 
table library functions built decompiling system 
library function name characteristic code sequence instructions distinguish function function number instructions characteristic code method recognize function stored 
done manually decompiler writer 
symbolic execution translated machine instructions intermediate instructions represented instruction terms symbolic contents 
recognition data types done set rules collection information di erent data types analysis rules determine data type 
program transformation transforms storage calculation address expressions array addressing 
code generator transforms program structure nding control structures generates code 
decompiling system library function recognition generate readable programs 
method library recognition hand crafted ine cient versions compiler memory models compilers original programs 
recognition data types rst attempt recognize types arrays pointers structures detail 
description address expression reached intermediate code examples show quality nal programs 
alpha axp migration tools 
digital equipment designed alpha axp architecture axp team got involved project run existing vax mips code new alpha axp computers 
opted binary translator convert sequence instructions old architecture sequence instructions new architecture 
process needed fully automatic cater code created modi ed execution 
previous parts migration process de ned binary translation runtime environment 
binary translation phase took binary programs translated axp opcodes 
decompilation techniques understand underlying meaning machine instructions 
condition code usage analysis performed conditions exist alpha architecture 
code analyzed determine function return values nd bugs uninitialized variables 
mips standard library routines binary program 
case pattern matching algorithm detect routines library routines routines analysed replaced name 
idioms replaced optimal instruction sequence 
generated form axp opcodes 
new binary le new code old code 
runtime environment executes translated code acts bridge new old operating systems di erent calling standards exception handling 
built interpreter old code run old code discovered nonexistent translation time 
possible old code saved part new binary le 
binary translators written vest translate vax system axp system mx translate ultrix mips images dec osf axp images 
runtime environments translators tie respectively 
project illustrates decompilation techniques modern translation system 
proved successful large class binary programs 
programs translated programs technically infeasible translate programs privileged opcodes run superuser privileges 
source prom comparator 
tool demonstrate equivalence source code prom contents developed nuclear electric plc uk verify correct translation pl programs prom programs executed safety critical computer controlled systems pw 
stages identi ed object code les prom les disassembly object code assembler form help built source code decompilation assembler programs comparison original source code 
decompiling stage noted necessary eliminate intermediate jumps registers stack operations identify procedure arguments resolve indexes structures arrays pointers convert normal form 
order compare original program decompiled program intermediate language 
source program translated language commercial product output decompilation stage written language 
project proved practical way correctness translated code demonstrate tools create programs compiler linker optimizer behave reliably particular safety system analyzed 
project describes decompilation techniques help demonstrate equivalence high level low level code safety critical system 
decompilation decompilation done 
stage performs analysis help symbol table constructed original source program 
task simpli ed knowledge compiler high level programs 
years commercial vendor speci decompilers manufactured 
decompilers targetted decompilation binary les produced database languages 
information techniques decompile programs manufacturers 
list mentions commercial decompilers 
visual decompiler summer manufactured val 

decompiler encrypted programs 

encrypted les manufactured 
doc 
cobol decompiler system 
converts object programs cobol source programs modi ed programmer 
manufactured harman resources cob 

decompiler summer exe les manufactured ware unc 

decompiler summer executables manufactured intelligent information systems unc 

decompiler exe obj les manufactured bri 
chapter run time environment considering decompilation relations static binary code pro gram actions performed run time implement program 
representation objects binary program di ers compilers elementary data types characters reals represented equivalent data object machine xed size number bytes aggregate objects arrays strings structures represented various di erent ways 
thesis word subroutine generic word denote procedure function words certainty subroutine really subroutine returns value function subroutine return value procedure 
storage organization high level language program composed subroutines called user subroutines 
corresponding binary program composed user subroutines library routines invoked user program subroutines linked linker provide support compiler run time 
general format binary code program shown 
program starts invoking compiler start subroutines set environment compiler followed user main program subroutine invokes library routines linked linker series compiler subroutines restore state machine program termination 
start code user program including library subroutines exit code general format binary program run time environment example hello world program compiled borland turbo di erent subroutines 
start code invokes di erent subroutines set compiler environment 
user main program composed procedure 
procedure invokes printf procedure invokes di erent subroutines display formatted string 
exit code invokes subroutines restore environment exit back dos 
sample skeleton code program shown 
proc far mov dx dx group segment adr mov cs dx save vectors install default divide zero handler call calculate environment size determine amount memory needed check size stack return dos memory allocated excess set far heap program stack reset uninitialized data area install floating point emulator push cs call ds emu st prepare main arguments call call initialize window sizes call ds crt st invoke main argc argv push word ptr environ push word ptr argv push word ptr argc call main user main program flush close streams files push ax call exit endp skeleton code hello world program binary program subroutines identi ed entry address names associated subroutines unknown subroutine procedure function performing data ow analysis registers de ned subroutines 
said subroutine invokes subroutine caller invoked subroutine callee 
data types stack frame subroutine associated stack frame run time 
stack frame set parameters local variables return address caller subroutine shown 
parameters stack frame represent actual parameters particular invocation subroutine information formal parameters subroutine stored binary le 
stack mark represents return address caller control transferred caller callee nished caller frame pointer register bp intel architecture point sets stack frame 
local variables represent space allocated subroutine control transferred space available subroutine active terminated 
high memory low memory parameters stack mark local variables bp sp stack frame bp set bp set frame pointer set register bp positive sets frame pointer access parameters stack mark negative sets access local variables 
convention diagrams relating stack frame follows stack grows downwards high low memory intel architecture 
stack frame may contain elds shown 
elds languages compilers asu 
return value eld languages callee return value function back caller values returned registers ciency 
control link points stack frame caller access link points stack frame enclosing subroutine holds non local data accessible subroutine 
data types data objects normally stored contiguous memory locations 
elementary data types integers held registers operation performed 
aggregate data types arrays strings records held registers entirety size normally size register easier access pointer starting address 
run time environment return value parameters control link access link stack mark local variables stack frame sizes di erent data types architecture shown 
machine word size bits 
sizes bit bytes 
data type size bytes character integer long real long real near pointer far pointer types size di erent data types data handling high level languages aggregate data types handled di erent ways di erent compilers 
section describes di erent formats pascal fortran basic compilers mic 
array array contiguous piece memory holds items certain type 
arrays implemented memory series rows columns depending order language row major order elements multidimensional array stored row order row 
order pascal compilers 
data types column major order elements multidimensional array stored column order row order 
order fortran basic compilers 
basic compilers compile option row major order 
languages size array isknown compile time case pascal fortran 
basic allows run time declared array sizes array needs array descriptor hold size array pointer physical location memory array stored 
string string sequence characters 
di erent languages di erent representations string record format string array terminated character 
fortran format string series bytes xed memory location delimiter needed string 
pascal format common pascal compilers types strings string 
xed length string implemented fortran format 
variable length string implemented array characters holds length string rst byte array 
standard pascal string type 
basic format string implemented byte string descriptor rst bytes hold length string bytes set default data area holds string 
area assigned basic string space management routines xed location memory 
record contiguous piece memory holds related items data types 
di erent names records di erent languages struct record pascal user de ned type basic 
default pascal store structures unpacked storage word aligned byte sized objects arrays byte sized objects 
basic pascal compilers store structures packed storage 
complex numbers fortran complex data type stores oating point numbers way complex bytes represent real part bytes represent oating point number imaginary part 
complex bytes represent real part bytes imaginary part 
run time environment boolean fortran logical data type stores boolean information way logical byte holds boolean value 
logical byte holds boolean value bytes left unused 
high level language interface compilers high level languages series conventions allow mixed language programming program subroutines written language subroutines written di erent language subroutines linked program 
series conventions relate way stack frame set calling conventions invoke subroutines 
stack frame stack mark contains caller return address frame pointer 
return address varies size depending callee invoked near far call 
near calls segment referenced set current segment base address 
far calls di erent segment segment set callee stored 
byte machine word architecture near call stores bytes set caller far call stores bytes segment set caller 
register bp frame pointer contents caller frame pointer pushed stack subroutine entry restored subroutine termination 
entering subroutine register bp established frame pointer pushing address stack storing frame pointer caller stack copying current stack pointer register sp 
code architecture push bp save old copy bp mov bp sp bp frame pointer allocating local data subroutine may reserve space stack local variables 
done decrementing contents stack register sp amount 
example allocate space integer variables bytes reserved stack sub sp high level language interface preserving register values widely calling convention dos compilers demands subroutine preserve values registers si di ss ds bp 
registers callee subroutine values pushed stack restored subroutine return 
example si di subroutine code local data allocation push si push di accessing parameters parameters located positive sets frame pointer register bp 
order access parameter set bp calculated adding size stack mark plus size parameters bp parameter plus size parameter returning value functions returning value registers di erent registers size returned value 
data values byte returned register bytes returned ax register bytes returned dx ax registers shown 
data size bytes register ax dx ax low byte register conventions return values larger data values returned conventions function called callee allocate space heap return value place address dx ax 
function called pascal fortran basic caller reserves space stack segment return value pushes set address allocated space stack parameter 
set address return value bp far calls bp near calls shown 
exiting subroutine stack frame restored popping registers saved subroutine entry deallocating space reserved local variables restoring old frame pointer bp returning convention 
convention caller adjusts stack parameters pushed stack 
ret instruction needed subroutine 
run time environment parameters return value set return set old bp local variables bp parameters return value set return segment set old bp local variables return value convention bp pascal fortran basic convention callee adjusts cutting back stack required number parameter bytes 
ret instruction number bytes parameters 
example code restores registers di si stack deallocates space local variables copying bp sp restores frame pointer popping bp stack returns convention pop di restore registers pop si mov sp bp deallocate local variables pop bp restore bp ret parameter passing di erent methods pass parameters intel architecture dos operating system pascal register calling conventions 
mixtures calling conventions available operating systems architectures 
example os standard call uses ordering pass parameters callee cuts back parameters stack system calls 
calling convention caller responsible pushing parameters stack restoring callee returns 
parameters pushed right left order variable number parameters passed callee 
example function prototype void int char long caller procedure invokes procedure int bp char bp long bp symbol table assembler code produced push word ptr bp high word push word ptr bp low word push bp push word ptr bp call call function add sp restore stack note due word alignment character stored bytes stack size byte 
pascal calling convention caller responsible pushing arguments stack callee adjusts stack returning 
arguments pushed stack order arguments convention 
previous example calling produces assembler code pascal convention push word ptr bp push bp push word ptr bp high word push word ptr bp low word call call restores stack register calling convention convention push arguments stack passes registers generated code faster 
predetermined registers pass arguments subroutines di erent registers di erent argument sizes 
shows set registers borland turbo bor maximum parameters passed registers 
far pointers unions structures real numbers pushed stack 
symbol table parameter type register character dl bl integer ax dx bx long dx ax near pointer ax dx bx register parameter passing convention decompiler uses symbol table store information variables program 
binary program variables identi ed address names run time environment associated variables 
variables memory address global variables segment set access 
variables located negative set frame pointer local variables corresponding stack frame subroutine variables positive sets actual arguments subroutine 
register variables compilers ciency purposes registers considered variables initially analysis registers determines represent register variables see chapter section 
variables assigned unique names code generation explained chapter 
symbol table able provide information entry ciently handle varying number variables symbol table grows dynamically necessary desirable 
performance symbol table measured terms time taken access entry insert new item table 
data structures symbol tables represented avariety data structures 
cient expense coding 
illustrate di erences various data structures assume data items placed symbol table cs global variable bp parameter bp local variable ax register ax bp local variable unordered list unordered list linked list array data items 
items stored list rst basis available position 
array implementation presents limitation size limitations avoided linked list implementation 
access symbol table list items 
shows list built example 
ordered list bp cs bp bp ax unordered list representation ordered list easier access items list need checked determine item list 
ordered lists searched binary search provides access time log 
insertion item costly list needs remain ordered 
symbol table di variables binary program items identi ed di erent way type ordering type possible di erent types access independently 
shows ordered list representation example record determines type data item rst data types ordered list associated 
hash table global local parameter register cs bp bp ax bp ordered list representation hash table mapping xed number positions table possibly large number variables 
mapping done hashing function ned possible variables computed quickly provides uniform probability variables randomizes similar variables di erent table locations 
open hashing hash table represented xed size linked list attached array position bucket 
linked list holds di erent variables hash bucket 
shows hash table built example ordered lists record determines type variable rst hash table associated di erent variable type 
global local parameter register cs bp bp bp hash table representation ax run time environment symbol table representation decompilation combination abovementioned methods purposes decompilation 
symbol table de ned terms di erent types variables global local parameter register 
types implemented di erent way 
global variables address range large hash table implementation suited 
local variables parameters variables sets frame pointer allocated ordered way gaps stack frame implemented ordered list set register bp need stored 
registers xed number registers array indexed register number implemented array positions associated item represent registers de ned symbol table 
representation shown 
global local parameter register ax 
cs symbol table representation symbol tables widely discussed literature refer asu fj gou information symbol tables compiler point view 
chapter front front machine dependent module takes input binary source program parses program produces output control ow graph intermediate language representation program 
phases front shown 
binary program syntax analyzer semantic analyzer intermediate code generator control ow graph generator control ow graph intermediate code phases front compilers lexical analysis phase front decompiler 
lexical analyzer scanner phase groups characters input stream tokens 
specialized tools designed help automate construction scanners compilers fj 
simplicity machine language need scan input bytes recognize di erent words belong language information stored terms bytes bits byte possible determine particular byte represents opcode register set context 
syntax analyzer determines series bytes represent language description machine language 
syntax analysis syntax analyzer rst phase decompiler 
role group sequence bytes phrase sentence language 
sequence bytes checked syntactic structure string belongs language 
valid strings represented parse tree input phase semantic analyzer 
front relation syntax analyzer semantic analyzer shown 
syntax analyzer known parser 
source binary program parser parse tree symbol table semantic 
rest 
analyzer front 
interaction parser semantic analyzer syntax machine language precisely speci ed grammar 
machine languages instructions statements speci ed control structures high level languages 
general grammar provides precise notation specifying language 
main di culty decompiler parser separation code data determination bytes memory represent code ones represent data 
problem inherent neumann architecture needs addressed means heuristic methods 
syntax errors syntax errors seldom binary programs compilers generate correct code compiled program run machine 
upgrades machine architecture result new machines support predecessor machines machine instruction set new architecture extension instruction set old architecture 
case supports predecessor instruction sets 
parser written new machine instructions recognized parser result error 
hand parser written newest machine instructions recognized syntactic errors encountered 
finite state automaton finite state automaton fsa recognizer language 
takes input string answers string belongs language 
sequence symbols alphabet 
arbitrary string fsa determine string belongs language 
de nition finite state automaton mathematical model consists nite set states initial state 
syntax analysis set nal accept states alphabet input symbols function state symbol state fsa graphically represented transition diagrams 
components diagrams shown 
symbols alphabet label transitions 
error transitions explicitly represented diagram assumed non valid symbol state labels transition error state 
sx state sx initial state transition components fsa transition diagram sn accept state sn wildcard language meta language specify wildcard conditions language gou 
meta symbols 
meta symbol represents sequence zero symbols alphabet represents single symbol example fa cg 
language accepts strings starting described wildcard expression aa represented fsa way non deterministic finite state automaton fsa said non deterministic transitions state labelled symbol empty string labels transition 
cases state uniquely identi ed state symbol tuple 
deterministic finite state automaton deterministic nite state automaton dfsa fsa transitions labelled string uniquely identi es determines state state symbol tuple 
converted equivalent dfsa method subset construction 
method explained literature example refer asu gou fj details 
method construct minimum state dfsa described asu 
front finite state parsers machine language represented fsa accepts rejects arbitrary strings 
alphabet nite set hexadecimal numbers ff numbers represented string sequence bytes 
strings belong language instructions recognized particular machine language 
example fsa recognize machine instruction sub cx needs rst determine opcode sub takes bytes operands 
second byte encodes destination register operand lower bits bytes information byte bytes follow second byte bits represent byte follows second byte bytes part destination operand 
example lower bits equivalent register cx upper bits means bytes part destination operand 
byte immediate constant operand example 
fsa example shown 
af ef fsa example qs language described terms context free grammar cfg regular expressions subset context free grammars 
algorithm mechanically convert asu 
cfgs specify high level constructs inherent recursive structure machine languages recursive constructs necessary de ne terms cfgs 
separation code data entry point program function syntax analyzer parse machine instructions possible paths program 
main problem faced parser data code represented way neumann machine easy determine byte follows instruction belongs instruction represents data 
heuristic methods need order determine data code explained section 
source binary program loaded memory loader returns initial start address program memory 
address starting address complete binary program address instruction order program run 
furthermore binary program checked compiler signatures initial starting address entry point main program syntax analysis start address user written program skipping compiler start code 
illustrates sample code hello world program 
entry point returned loader cs entry point complete program including compiler start code 
entry point compiler signature analyzer cs fa start address main program 
thesis assume entry point compiler signature analyzer loss generality 
explained methods applicable cases interesting examples case 
technique generating compiler signatures detecting chapter 
proc far cs start mov dx cs mov cs dx 
start code cs call main cs exit code endp 
main proc near cs fa push bp cs fb mov bp sp cs fd mov ax cs push ax cs call printf cs pop cx cs pop bp cs ret main endp sample code hello world program horspool focused problem separation code data 
mentioned problem equivalent halting problem impossible separate data instructions von neumann architecture computes data addresses branch destination addresses execution time hm 
algorithm nd maximum set locations holding instructions 
modi cation original problem equivalent problem searching maximal set trees candidate trees bound method applied 
algorithm proved np complete 
turns dense machine instruction sets intel architecture algorithm byte combination valid machine instruction determine bounds code data reached 
simple counter example algorithm case front table stored code segment see 
indexed jump instruction cs indexes case table table de ned starting cs de treated algorithm includes valid bytes instructions 
code example equivalent push cs equivalent sub takes byte argument case result sub ax bp 
produced code wrong 
cs jmp cs de bx cs de push cs cs de sub ax bp 
counter example section presents di erent method determine code instructions binary program loaded memory 
provides heuristic methods determine special cases data sections code 
process previously mentioned process determining data code knowledge initial entry point program instruction 
instruction onwards instructions parsed sequentially path change ow control path reached 
case target address es acts new entry points memory address hold valid instruction order program continue execution 
case current path reached instructions scanned path determine bytes code data 
changes ow due jumps procedure calls 
conditional jump branches ow control target branch address followed condition true address conditional branch followed 
paths followed parser order get possibly executable code 
unconditional jump transfers ow target address unique path followed parser 
procedure call transfers control invoked procedure returns instructions procedure call parsed 
case procedure return bytes procedure call parsed certain bytes code data 
path reached procedure return instruction program met 
program normally speci ed series instructions operating system terminate current process program 
sequence instructions varies operating systems need coded speci source machine 
determining program met program nishes syntax analysis halts equivalent solving halting problem path followed necessarily path executable program follow condition branches path true program execution example programs nite loop 
example intel architecture program speci ed interrupt instructions 
di erent methods terminate program methods program segment pre commonly referred psp refer appendix information psp 
di erent ways terminating program dos 
terminate process return code int function ch 
commonly method exe les 

terminate process int 
code segment cs needs pointing psp 
method normally com les cs points psp segment 

warm boot terminate vector set psp contains int instruction 
register cs pointing psp segment 

return instruction return address placed stack program starts 
program nished returns address stack 
method cp operating system address warm boot vector stack 
initial dos com programs technique 

terminate process function int function 
register cs point psp 

terminate stay resident int 
register cs point psp 

terminate stay resident function int function 
determining procedure returns nishes halts di cult procedure self modifying code execute data code terminate instruction data 
general solution normal cases cases require step debugger tool user input solve problem 
procedure return reaches program invokes procedure reaches program procedure invokes exit 

determining procedure reached program possible emulation contents registers involved sequence instructions terminate program 
case example keeping track registers ah cs cases 
initial algorithm separation code data shown 
order keep track registers record register values 
state variable type holds current values registers current state machine 
bitmap bits memory byte store information regarding byte loaded memory represents unknown value memory location analyzed 
represents code byte 
front 
represents byte data code 
algorithm implemented recursively 
time non fall path needs followed copy current state path followed recursive call parse procedure copy state 
indirect addressing mode indirect addressing mode contents register memory location determine target address instruction uses addressing mode 
indirect addressing mode unconditional jump implement indexed case tables procedure call instructions 
main problem addressing mode contents memory changed program execution static analysis program provide right value able determine memory location modi ed 
applies register contents contents registers emulated register loop contents register wrong loops emulated 
indirect instruction intra segment segment 
case contents register memory location holds bit set address case bit address segment set 
indirect procedure calls high level languages implement pointers function invocation 
consider program typedef char func func func char func code char func code main func func main program functions func func invoked means function pointer index array functions 
disassembled code program looks cs address proc cs address proc proc proc far cs push bp 
cs cb syntax analysis procedure parse state done false 
done state inst inst check instruction parsed done true break code inst case inst opcode conditional jump state parse fall state ip inst target branch address state ip check code parsed done true unconditional jump state ip inst target branch address state ip check code parsed done true procedure call process non library procedures 
inst state ip inst parse process target procedure procedure return done true procedure move destination operand register state inst inst interrupt program interrupt done true program case procedure initial parser algorithm front proc endp proc proc far cs push bp 
cs cb proc endp main proc far cs push bp cs bec mov bp sp cs db ff call intra segment indirect call cs df ff call intra segment indirect call cs pop bp cs cb main endp function pointers replaced memory set address holds address procedure respectively 
addresses modi ed program execution checking contents memory locations provides target address function 
implementation 
target address function replaced procedure call instruction invocation normal procedure done decompiled program follows void proc code void proc code void main proc proc case statements high level languages implement multiway way branches high level construct known case statement 
construct di erent possible paths executed di erent branches 
low level machine instruction represent construct di erent methods compiler writers de ne case table 
number cases great case implemented sequence conditional jumps tests individual value transfers control code corresponding statement 
consider fragment code assembler cmp start case je lab cmp fh syntax analysis je lab cmp je lab cmp je lab cmp bh je lab jmp endcase lab 
lab 
endcase case code fragment register compared di erent byte values result equal unconditional jump performed label handles case 
register equal options program unconditionally jumps case 
compact way statement indexed table holds target label addresses corresponding statements 
table indexed indexed jump instruction 
indexing table lower upper bounds table checked erroneous indexing done 
determined index bound indexed jump instruction performed 
consider fragment code cs dcf cmp ax cs dd cs dd jmp endcase cs dd mov bx ax cs dd shl bx cs jmp word ptr cs de bx indexed jump cs de dw lab start indexed table cs de dw lab cs eoe dw lab indexed table cs lab cs lab cs endcase case 
case table de ned code segment data located immediately indexed jump target branch labels 
register ax holds index table 
register compared upper bound 
register greater rest sequence executed control transferred rst instruction case 
hand register equal front reached register bx set set table 
size word case table set labels size initial index table multiplied get correct set byte table 
done indexed jump instruction determines case table segment cs set de byte memory case 
target jump address di erent options available table 
avery similar implementation case statements table located procedure index register table register holds set table register bx fragment code cs cmp bx cs bea cs bec jmp cs bef shl bx cs bf jmp word ptr cs fb bx indexed jump cs bf jmp endcase cs bf lab cs lab cs endcase case cs fb ret procedure cs fb bf dw lab start indexed table cs fba dw lab cs fe dw lab indexed table third way implement statement case table indexed branches 
way code jumps target jump addresses checks upper bounds indexed table fragment code adjusts register indexes table branches location cs jmp cs lab 
cs lab 
cs lab 
cs dw endcase start indexed table cs ba dw lab 
cs dw lab indexed table cs syntax analysis cmp ax fh fh cs jae endcase cs fb ax bx cs fc shl bx cs fe jmp word ptr cs bx indexed jump cs endcase cs ret di erent implementation case statements means string character options opposed numbers 
consider code fragment cs db cs cs dw lab start table cs dw lab 
cs df dw lab 
cs push bp 
cs mov di cs cs mov es di es cs cs mov di ah di start string cs mov cx cx upper bound cs cs sub di bh cs shl di cs jmp word ptr cs di indexed jump cs lab 
cs ff lab 
cs ret string character options located cs 
register holds current character option checked es di points string memory compared instruction nds rst match register string pointed es di 
register di left pointing character match 
register subtracted string initial address plus indexes indexed jump table located procedure code segment 
method compact elegant 
unfortunately xed representation case statement binary code needs manually examined rst instance determine case statement implemented 
di erent compilers di erent implementations normally speci vendor compiler uses di erent representations case tables 
front determination case table heuristic method handles prede ned set generalized implementations 
implementation methods handled decompiler better output generate 
heuristic methods right preconditions need satis ed applying method indexed table met bound indexed table determined proposed heuristic method applied 
final algorithm nal algorithm data code separation shown 
algorithm algorithm expands cases indexed jumps indirect jumps calls 
semantic analysis semantic analysis phase determines meaning group machine instructions collects information individual instructions subroutine propagates information instructions subroutine 
way base data types integers long integers propagated subroutine 
relation phase syntax analyzer intermediate code generator shown 
de nition identi er ident register local variable negative set stack parameter positive set stack global variable location memory 
idioms semantic meaning series instructions idiom 
sequences instructions represent high level instruction 
de nition idiom sequence instructions logical meaning derived individual instructions 
idioms widely known compiler community series instructions perform operation unique cient way doing di erent instructions 
sections illustrate best known idioms 
subroutine idioms entering subroutine base register bp established frame pointer copying value stack pointer sp bp 
frame pointer access parameters local data stack subroutine 
sequence instructions shown 
high level language subroutine prologue sets register bp point current stack pointer optionally allocates space stack local static variables decreasing contents stack pointer sp required number bytes 
idiom represented instruction takes number bytes reserved local storage 
semantic analysis procedure parse state done false 
done state inst inst check instruction parsed done true break code inst case inst opcode conditional jump state parse fall state ip inst target branch address state ip check code parsed done true unconditional jump direct jump state ip inst target branch address state ip check code parsed done true indirect jump check case table determine bounds table 
bounds determined entries table state ip table parse continue path done true procedure call process non library procedures 
inst state direct call ip inst indirect call ip inst parse process target procedure cases procedure return move interrupt remain case procedure final parser algorithm front source binary program 
parser parse semantic 
tree analyzer symbol table intermediate code generator interaction semantic analyzer push bp mov bp sp sub sp immed enter immed high level subroutine prologue 
rest 
front 
subroutine prologue encountered pushes stack represent registers values preserved subroutine 
registers act register variables local variables current subroutine agged possibly register variables 
shows registers si di pushed stack 
push si push di register variables exit subroutine registers saved stack need popped data space allocated needs freed bp needs restored point old frame pointer subroutine returns near far return instruction 
shows sample trailer code 
calling conventions calling convention known parameter passing sequence 
convention caller pushes parameters stack reverse order appear source code right left order invokes procedure 
procedure return caller restores stack popping parameters semantic analysis pop di restore registers pop si mov sp bp restore sp pop bp restore bp ret return subroutine trailer code stack adding number parameter bytes stack pointer 
case total number bytes arguments known stored 
instruction involved restoring stack eliminated code 
calling convention passing variable number arguments callee need restore stack 
shows case pop instructions restore stack 
total number bytes computed multiplying number pops 
call proc pop reg pop reg reg ax bx cx dx proc sets call flag calling convention uses pop shows case stack restored adding number argument bytes stack 
value stored instruction restores stack eliminated analysis 
bytes arguments stack restored popping bytes stack 
due number cycles involved di erent operations pop reg instruction takes byte add sp immed instruction takes bytes 
binary code optimized space speed pop reg instruction takes cycles add sp immed instruction takes cycles 
pascal calling convention known pascal parameter passing sequence 
convention caller pushes parameters stack order appear source code left right order callee procedure invoked callee responsible adjusting stack returning 
necessary callee know parameters passed variable argument parameters 
shows convention 
front long variable operations call proc add sp immed proc immed sets call flag calling convention uses add ret immed proc immed sets call pascal flag pascal calling convention long variables stored memory consecutive memory stack locations 
variables normally identi ed simple addition subtraction operations performed 
idioms operations generally due simplicity instructions 
shows instructions involved long addition 
low parts long variable added add instruction sets carry ag ow 
high parts added taken account carry ag ow part needs added high part 
adc add carry instruction add high parts 
add ax bp adc dx bp dx ax dx ax bp bp long addition semantic analysis similar way long subtraction performed 
low parts rst subtracted sub instruction 
borrow carry ag set 
ow taken consideration subtracting high parts ow low part borrow needs subtracted source high part operand 
sbb subtract borrow instruction 
shows case 
sub ax bp sbb dx bp dx ax dx ax bp bp long subtraction negation long variable done sequence instructions high part negated low part negated nally zero subtracted borrow high part case ow negation low part 
idiom shown 
neg neg sbb long negation long shifts normally performed carry ag rotating ag high low part answer 
left shift independent sign long operand generally involves low part shifted left shl high bit low part carry ag 
high part shifted left making carry ag contains bit placed lowest bit high part answer rcl rotate carry left instruction 
idiom shown 
long right shift needs retain sign long operand di erent idioms signed unsigned long operands 
shows idiom signed long operands 
high part long operand shifted right arithmetic shift right sar instruction number treated signed number 
lower bit high part placed carry ag 
low part operand shifted right account bit carry ag rotate carry right rcr front instruction 
shl rcl shift long variable left sar rcr signed long shift signed long variable right similar way long shift right unsigned long operand done 
case high part shifted right moving lower bit carry ag 
bit shifted low part rotate carry right instruction 
see 
miscellaneous idioms shr rcr unsigned long shift unsigned long variable right widely known machine idiom assignment zero variable 
mov instruction xor variable xored result zero 
machine idiom uses fewer machine cycles bytes counterpart shown 
semantic analysis xor reg reg reg assign zero di erent machine architectures restrict number bits shifted shift instruction 
case shift instruction allows bit shifted instruction shift instructions coded shifting bits 
shows idiom 
general shift constant done di erent shift instructions 
shl reg 
times shl reg reg reg shift left bitwise negation integer word variable done shown 
idiom negates complement register subtracts borrow case ow initial negation register nally increments register get answer 
neg reg sbb reg reg reg reg reg bitwise negation front simple type propagation sign elementary data types integer easily determined type conditional jump compare operand 
technique determine sign complex elementary data types long real 
sections illustrate techniques determine word sized operand signed unsigned integer sized operand signed unsigned long 
techniques easily extended elementary data types 
propagation integers sized operand signed integer unsigned integer 
instructions deal word sized operands distinction signed unsigned operands conditional jump instructions exception 
di erent types conditional jumps relational operations example code cmp bp ah jg checks word operand bp ah greater 
code cmp bp ah ja checks word operand bp ah 
conditional jump tests unsigned word operands conditional jump tests signed word operands local variable bp ah signed integer case unsigned integer case 
information stored attribute local variable bp ah symbol table 
way operands conditional jump deal registers register determined signed unsigned integer register information propagated backwards basic block register belongs de nition register 
consider code mov ax bp ch cmp ax ja instruction operands conditional jump determined unsigned integers register ax constant unsigned integer operands 
register ax local variable information propagated backwards de nition ax 
example instruction de nes ax terms local variable bp ch local variable represents unsigned integer attribute stored symbol table entry bp ch 
set conditional jumps distinguish signed unsigned integer shown 
conditional jumps intel architecture 
semantic analysis signed conditional unsigned conditional jg ja jae jl jb sign determination conditional jump propagation long variables initial recognition long variables determined idiom analysis described section 
pair identi ers known long variable identi ers changed re ect part long variable high low part long variable 
couples instructions deal high low parts long variable merged instruction 
consider code mov dx bp mov ax bp add dx ax bp ah bp ch mov bp eh dx mov bp ax instructions merged add instruction idiom analysis leading identi ers bp ah bp ch long variable registers dx ax 
identi ers registers propagated subroutine intermediate code example bp ah done 
registers propagated basic block backward propagation register de nition forward propagation rede nition register done 
example backward propagation dx ax arrive code mov dx ax bp bp add dx ax bp ah bp ch mov bp eh dx mov bp ax merges instructions mov instruction 
merge determined local identi ers bp bp long variable information stored symbol table 
forward propagation dx ax basic block arrive code mov dx ax bp bp add dx ax bp ah bp ch mov bp eh bp dx ax merges instructions mov instruction 
case local identi ers bp eh bp determined long variable information stored symbol table propagated 
front propagation long variables conditional jumps done steps 
high low part long identi er compared identi er di erent basic blocks 
notion basic block simple sequence instructions entry exit point notion explained detail section 
consider code mov dx ax bp eh bp cmp dx bp ah jl jg cmp ax bp ch instruction registers dx ax determined long register cmp opcode instruction checking high part long register instruction checks low part long register 
analysing instructions seen dx ax equal identi er bp ah bp ch label reached label reached 
basic blocks transformed unique basic block contains condition follows mov dx ax bp eh bp cmp dx ax bp ah bp ch basic block branches label condition true branches label condition false 
presence label explicit instructions implicit edges basic block 
general long conditional branches identi ed graph structure 
shows graphs 
represent di erent conditions 
graphs represent condition 
graphs represent di erent long conditions depending instructions nodes associated graphs conditions 
graphs equality inequality long variables 
graphs translated graph conditions satis ed graphs basic block conditional node compares high parts long identi ers 
basic block conditional node instruction conditional jump edge basic block basic block conditional node instructions compare low parts long identi ers conditional jump 
graphs basic block conditional node compares high parts long identi ers 
intermediate code generation 
ssw nnn 
long conditional graphs basic block conditional node instructions compare low parts long identi ers conditional jump edge basic block shows sample code graphs equality inequality long identi ers 
code intel architecture 
node node boolean condition cmp dx hi cmp ax low jne jne cmp dx hi cmp ax low jne je long equality boolean conditional code sample code nodes graph 
code associated node represents di erent non equality boolean conditions equal greater greater equal 
similar code nodes graph represent exact boolean conditions 
code intel architecture 
intermediate code generation decompiler front translates machine language source code intermediate representation suitable analysis universal decompiling machine 
shows relation phase semantic analyzer phase front control ow graph generator 
target language independent representation retargeting di erent language feasible writing back language attaching decompiler 
front node node node boolean condition cmp dx hi jg cmp ax low jl cmp dx hi jne cmp ax low jl jb cmp dx hi jne cmp ax low jg ja cmp dx hi jl cmp ax low jg jae long non equality boolean conditional code 
intermediate 
parser semantic intermediate control code flow graph udm 
analyzer generation code generation 
symbol table interaction intermediate code generator step approach decompilation low level intermediate representation rst represent machine language program 
idiom analysis type propagation done representation generating assembler code intermediate code suitable disassembler perform high level analysis code 
representation converted high level intermediate representation suitable high level language generation 
representation needs general generate code high level language 
low level intermediate code low level intermediate representation resembles assembler language machine decompiled choice low level intermediate code possible perform semantic analysis code generate assembler programs 
intermediate code instruction complete instruction machine language 
compound machine instructions represented intermediate instruction 
example machine instruction mov bh intermediate instruction 
machine instruction followed jmp cs replaced instruction explicit register cs 
nally compound machine instructions equivalent assembler instructions rep di si 
instructions represented unique intermediate instruction rep explicit destination source registers move 
intermediate code generation mov bh jmp cs bx rep di si low level intermediate instructions example implementation low level intermediate code low level intermediate representation implemented quadruples explicit operands instruction shown 
opcode eld holds low level intermediate opcode dest eld holds destination operand identi er src src elds hold source operands instruction 
instructions source operands src eld 
opcode dest src src general representation quadruple example add bx machine instruction represented quadruple way add bx bx register bx source destination operand constant second source operand 
example push cx machine instruction represented way push sp cx hh register cx source operand register sp destination operand 
high level intermediate code address code generalized form assembler code address machine 
intermediate code suited decompiler address code linearized representation syntax tree ast program 
way complete ast program reconstructed data ow analysis 
address instruction general form op identi ers op arithmetic logic operation 
result address operand addresses front types address statements address statements similar high level language statements 
data ow analysis reconstruct ast program address instruction going represent individual identi ers expressions 
identi er viewed minimal form expression 
di erent types instructions 
asgn exp asgn instruction assigns arithmetic expression identi er expression identi er represented expression indexing array 
statement represents di erent types high level assignment instructions op identi ers op binary arithmetic operator 
op wherex identi ers op unary arithmetic operator 
identi ers 
data ow analysis arithmetic expression represents binary operation holds complete parse tree arithmetic operators identi ers 
transformation described chapter 
context subroutine returns value function considered identi er invocation returns result assigned identi er sum 

jmp unconditional jump instruction associated expression attached target destination address jump 
instruction transfers control target address 
address coded edge basic block includes instruction explicitly described part instruction 
instruction equivalent high level instruction goto target address jump 

jcond conditional jump instruction boolean expression associated determines branch taken 
boolean expression form relop identi ers relop relational operator 
statement equivalent high level statement relop goto intermediate instruction target branch address fall address address instruction part instruction coded edges basic block instruction control ow graph 

call procid actual parameters call instruction represents subroutine call 
procedure identi er procid pointer ow graph invoked procedure 
actual parameter list intermediate code generation constructed data ow analysis 
subroutine called function de nes registers hold returned value 
case instruction equivalent regs procid actual parameters 

ret return instruction determines procedure path 
return subroutine procedure function 
pseudo high level intermediate instructions intermediate instructions data ow analysis eliminated analysis 
instructions 
push push instruction places associated arithmetic expression temporary stack 

pop ident pop instruction takes expression identi er top temporary stack assigns identi er ident 
implementation high level intermediate code high level intermediate representation implemented triplets 
triplet expressions explicit instruction opcode shown 
result arg elds pointers expression minimal form identi er points symbol table 
op result arg general representation triplet assignment statement op zis represented triplet way op eld asgn opcode result eld pointer identi er turn pointer identi er symbol table arg eld pointer binary expression expression represented syntax tree pointers symbol table entries follows asgn symbol table id op id id id id id similar way conditional jump statement relop represented triplet way op eld jcond opcode result eld pointer syntax tree relational test arg eld left empty follows front id xxxx jcond symbol table id relop id id unconditional jump statement goto result arg eld 
op eld set jmp elds left empty follows jmp hh hh procedure call statement uses op eld call opcode result eld procedure name symbol table arg eld procedure arguments list arguments point symbol table follows call id symbol table id id 
id id id procedure return statement ret uses op eld ret opcode result eld identi er expression returned arg eld left empty follows ret id hh symbol table id pseudo high level instruction push stored triplet op eld push opcode arg eld identi er pushed result eld left empty follows push hh symbol table id id similar way pop instruction stored triplet op eld pop opcode result eld identi er eventually data ow analysis arg eld lled expression popped 
initially eld left empty 
triplet representation follows control flow graph generation pop id hh control flow graph generation symbol table id control ow graph generation phase constructs call graph source program control ow graph basic blocks subroutine program 
graphs analyze program universal decompiling machine udm module 
interaction phase intermediate code generator udm shown 
semantic analyzer 
basic concepts ip control flow intermediate code generator graph generator symbol table udm 
interaction control flow graph generator 
back 
section describes de nitions mathematical graph theory 
terms de ned eliminate ambiguity terminology 
de nition graph tuple set nodes set edges root graph 
edge pair nodes de nition directed graph graph directed edges ni nj direction represented nj 
de nition path nm graph represented nn isa sequence nn nm 
de nition graph 
called graph 
de nition graph connected graph 
connected graph graph nodes reached header node 
sample directed connected graph shown 
front graph representation sample directed connected graph graph represented di including incidence matrices adjacency matrices predecessor successor tables 
de nition incidence matrix graph matrix mij mij number times vertex vi edge ej incident 
de nition adjacency matrix graph matrix aij aij number edges joining vertices vi vj 
de nition predecessor successor table graph table ti ti ti list predecessor vertices vertex vi ti list successor vertices vertex vi 
example graph represented matrices incidence matrix adjacency matrix predecessor successor table basic blocks predecessor successor fv fv fv fv fv fv fv section formalize de nition basic blocks 
order characterize need de nitions program structure 
start de ning components program data instructions 
note de nition associate instructions data memory locations 
control flow graph generation de nition fi ing instructions fd data purpose research programs restricted containing self modifying code data instructions vice versa 
instruction sequence set instructions physically located memory 
de nition fi ing instructions instruction sequence ij ij ij ij consecutive memory location ij 
intermediate instructions classi ed sets purposes control ow graph generation transfer instructions ti set instructions transfer ow control address memory di erent address instruction 
instructions unconditional jumps ow control transferred target jump address 
conditional jumps ow control transferred target jump address condition true control transferred instruction sequence 
indexed jumps ow transferred target addresses 
subroutine call ow transferred invoked subroutine 
subroutine return ow control transferred subroutine invoked subroutine return instruction 
program program ends 
non transfer instructions set instructions transfer control instruction sequence instructions belong ti set 
having classi ed intermediate instructions basic block de ned terms instructions de nition basic block instruction sequence satis es conditions 
front 
ti 

rst instruction basic block 
basic block sequence instructions entry point exit point 
instruction basic block executed instructions executed 
set instructions program uniquely set non overlapping basic blocks starting program entry point 
de nition ibe instructions program entry point fb bn bn entry point control flow graphs control ow graph directed graph represents ow control program represents instructions program 
nodes graph represent basic blocks program edges represent nodes 
formally de nition control ow graph program connected directed graph satis es conditions represents basic blocks ni nj represents ow control basic block ni nj bi bi nk nk bj bj nk purpose control ow graph cfg generation basic blocks classi ed di erent types instruction basic block 
available types basic blocks way basic block instruction basic block unconditional jump 
block edge 
way basic block instruction conditional jump block edges 
way basic block instruction indexed jump 
branches located case table edges node 
control flow graph generation call basic block instruction call subroutine 
edges block instruction subroutine call subroutine returns subroutine called 
return basic block instruction procedure return program 
edges basic block 
fall basic block instruction target address branching instruction instruction label 
node seen node falls edge 
di erent types basic block represented control ow graph named nodes shown 
node named graph means type basic block irrelevant obvious context exact number edges speci ed graph 
nw way way sw call ret fall call return way ssw fall node representation di erent types basic blocks example consider fragment code push bp mov bp sp sub sp mov ax ah mov bp ax mov bp ax lea ax bp push ax call near ptr proc pop cx mov ax bp cmp ax bp jne push word ptr bp mov ax push ax call near ptr printf front pop cx pop cx mov sp bp pop bp ret mov ax bp cmp ax bp lea ax bp push ax call near ptr proc pop cx jmp code basic blocks basic block type instruction extent call fall call ret call control ow graph represents instructions shown 
onwards word graph represent control ow graph word node represent basic block stated 
implementation control ow graphs close edges node matrix representation incident adjacent matrices sparse memory ine cient matrix zero 
better implement control ow graphs predecessor successor tables existing edges graph represented relationship 
note successor needed represent complete graph predecessor stored access graph easily di erent traversals graph 
size graph unknown number nodes xed possible construct graph dynamically pointer basic block list predecessor list successors attached 
predecessors successors pointers basic block nodes way basic block represented 
representation plausible high level language allows dynamic allocation memory 
consider de nition basic block 
bb structure de nes basic block node hold number predecessor successor nodes control flow graph generation printf ret call fall call call proc control flow graph example respectively dynamically allocated array predecessor basic blocks outedges dynamically allocated array successor basic blocks 
representation graph pointer header basic block 
typedef struct bb byte nodetype type node int number edges struct bb array pointers predecessors int number edges struct bb outedges array pointers successors fields go bb typedef bb pointer basic block basic block de nition front graph optimization pass compilers generate machine code redundant unnecessary jumps form jumps jumps conditional jumps jumps jumps conditional jumps 
unnecessary jumps eliminated peephole optimization ow control 
optimization 
peephole optimization method improving performance target program examining short sequence target instructions called peephole replacing instructions shorter faster sequence instructions 
peephole small moving window target code code peephole need contiguous 
improvement peephole optimization may spawn opportunities additional improvements repeated passes code necessary 
flow control optimization method redundant jumps eliminated 
decompilation interested eliminating jumps jumps conditional jumps jumps target jump holds address target branch intermediate basic blocks removed graph 
removal jumps conditional jumps desired involves rearrangement instructions just modi cation target branch address 
jump sequence jumps label lx jump label ly instructions executed jumps jmp lx code lx jmp ly sequence replaced sequence jmp ly code lx jmp ly rst jump branches target ly label intermediate lx label 
number predecessors basic block starting lx decremented number predecessors block ly incremented re ect change edges graph 
time number predecessors basic block starting label lx zero node removed graph unreachable unnecessary rst place 
similar way unconditional jump jump sequence jz lx code lx jmp ly replaced code sequence jz ly code lx jmp ly control flow graph generation call graph call graph mathematical representation subroutines program 
node represents subroutine edge represents call subroutine 
formally de nition fp nite set procedures program 
call graph tuple set procedures ni represents pi set edges ni nj represents pi pj main procedure 
construction call graph simple invoked subroutines statically bound subroutine constants program procedure parameters procedure variables 
presence recursion introduces cycles call graph 
cient algorithm construct call graph presence procedure parameters languages recursion 
method extended support recursion explained 
method handles procedure parameters limited type procedure variables described hk 
noted method able reconstruct graphs original form compiler optimisation changed implicit call instruction unconditional jump 
cases call graph decompiler treat code subroutines invoked subroutine called implicit call instruction 
chapter data flow analysis low level intermediate code generated front assembler type repre sentation registers condition codes 
representation transformed higher level representation low level concepts high level concept expression 
transformation low level high level intermediate code done means program transformations traditionally referred optimizations 
transformations applied lowlevel intermediate code transform high level intermediate code described chapter section 
relation phase front control ow analysis phase shown 
front low level intermediate code xz data flow high level analysis symbol table intermediate code control flow analysis context data flow analysis phase 
back 
types transformations required data ow analysis phase include elimination useless instructions elimination condition codes determination register arguments function return register elimination registers intermediate instructions regeneration expressions determination actual propagation data type subroutine calls 
transformations required improve quality low level intermediate code reconstruct information lost compilation process 
case elimination useless instructions step required optimising compilers exist machine instructions perform function time example refer section 
conventional data ow analysis process collecting information way variables program summarizing form sets 
information decompiler transform improve quality intermediate code 
properties required code improving transformations including asu 
transformation preserve meaning programs 
data flow analysis 
transformation worth ort 
techniques decompilation optimization intermediate code chapter 
transformations rstly illustrated means examples algorithms provided optimization 
previous done area data ow analysis decompiler mainly due limitations placed decompilers available literature decompilation assembler source les hou fri wor bri decompilation object les symbolic debugging information reu compiler speci cation requirements build decompiler bb bow bb 
data ow analysis essential decompiling pure binary les extra information way data type 
sections summarize done area 
elimination condition codes program translates microprocessor object code behaviorally equivalent pl program described marshall electronic system simulation 
nal pl programs contained large number statements de ned ags ags referenced program 
prompted formulate optimization ag de nitions means reach algorithm dz 
method eliminated ag de nitions translation process generating pl programs de ned necessary ags condition 
method optimization ag de nitions determines ag de nitions extraneous unnecessary determines boolean conditional expression represented combined setof instructions de ne ag 
way target hll program rely concept ags real hll program 
elimination redundant loads stores method text compression hou elimination intermediate loads stores 
method works address intermediate representation program consists stages forward substitution backward substitution 
stage substitutes source operand assignment instruction subsequent instruction uses result operand result busy basic block 
stage substitutes result operand assignment instruction previous instruction assignment instruction de nes result operand source operand assignment instruction consideration 
method provided reduction instruction assembly code compiled knuth compiler 
types optimizations method expression condensation described hop combine intermediate instructions equivalent expression means forward substitution 
method speci es necessary conditions su cient conditions forward substitution variable register performed 
method variable usage analysis 
great number conditions inherent control ow graph node intermediate instruction basic blocks 
meant variables forward substituted node boundaries making process complex required 
interprocedural data ow analyses thesis de ne su cient conditions register substituted instruction including intermediate instructions push pop 
method nds expressions eliminating intermediate registers instruction de nitions determines actual parameters subroutines values returned functions eliminates pseudo high level instructions 
method initial high level intermediate representation binary program semantically equivalent low level intermediate representation transforms hll representation 
types optimizations section presents code improving transformations decompiler 
techniques implement transformations explained sections 
optimizations section example ow graph basic blocks belong main program blocks belong subroutine anlshl runtime support routine 
main program registers si di register variables agged parser possibly see chapter section 
aim optimizations eliminate low level language concepts condition codes registers intermediate instructions introduce high level concept expressions operands 
purpose noted push instructions variety today compilers 
parameter passing common instruction pushing subroutine call order speci ed calling convention 
register spilling compiler runs registers compute expression 
push pop preserve contents registers procedure calls copy values registers 
dead register elimination identi er dead point program value de nition variable 
said instruction de nes dead identi er useless eliminated removed code 
consider code basic block ax tmp di dx tmp di dx dx ax ax dx data flow analysis si di ax si dx ax ax tmp dx ax ax tmp di dx tmp di dx dx ax ax dx si ax bp bp bp bp dx ax bp bp cmp bp bp dx ax jg si ax push bp bp ax si dx dx ax ax dx push ax ax push ax call printf ret dx ax bp bp dx ax dx ax bp bp bp bp dx ax cx dx ax bp bp call anlshl bp bp dx ax jmp anlshl dx ax dx ax cx cx sample flow graph ch ret instruction de nes register ax instruction de nes register dx instruction rede nes register dx 
register dx de nition instruction instruction de nition register dx instruction dead instruction useless de nes register dx 
previous sequence instructions replaced code ax tmp di dx dx ax ax dx si ax de nition register dx instruction multiplication instruction register rede ned register ax 
instruction uses register ax types optimizations uses register dx rede nition register instruction de nition dx dead eliminated 
instruction de nes dx ax ax dead instruction useless de nes live register instruction modi ed re ect fact register ax de ned follows ax tmp di dx ax ax dx si ax dead condition code elimination similar way dead register elimination condition code dead value rede nition 
case de nition condition code useless required instruction de nes condition code useful identi ers instruction de nes dead instruction necessarily eliminated 
consider code basic block cmp bp bp dx ax cc def zf cf sf jg cc sf instruction de nes condition codes zero zf carry cf sign sf 
instruction uses sign condition code 
basic blocks condition codes carry zero rede nition de nition condition codes instruction useless eliminated 
replace information instruction hold information cmp bp bp dx ax cc def sf condition code propagation condition codes ags machine signal occurrence condition 
general machine instructions set ags ranging di erent ags set instruction fewer instructions ags ags 
dead condition code elimination excess de nitions condition codes eliminated remaining ags subsequent instructions 
consider code basic block dead condition code elimination cmp bp bp dx ax cc def sf jg cc sf instruction de nes sign ag comparing operands instruction uses ag determine rst operand previous instruction greater second operand 
instructions functionally equivalent highlevel conditional jump instruction checks operand greater second operand 
instructions replaced jcond bp bp dx ax eliminating instruction condition codes 
data flow analysis register arguments subroutines register arguments speed access arguments remove overhead placed pushing arguments stack subroutine invocation 
register arguments runtime support routines user routines compiled register calling convention available compilers 
consider code basic block cx def cx dx ax bp bp def dx ax call anlshl instruction de nes register cx instruction de nes registers dx ax instruction invokes subroutine anlshl 
rst basic block subroutine anlshl uses register cx de ning high part register register ch low part register register cl contains value register subroutine invoked 
similar way basic block uses registers dx ax de ned subroutine values registers subroutine invocation 
registers de ned subroutine de ned caller register arguments anlshl subroutine 
formal argument list subroutine modi ed re ect fact formal arguments anlshl arg dx ax arg cl subroutine registers replaced formal argument name 
function return register subroutines return value called functions 
functions usually return values registers registers caller subroutine 
consider code basic blocks dx ax bp bp def dx ax call anlshl def dx ax cl bp bp dx ax def dx ax instruction invokes subroutine anlshl 
subroutine return instruction uses registers dx ax 
registers de ned previous basic block instruction subroutine invocation instructions subroutine needs checked modi cation registers dx ax 
consider code basic block dead register elimination dx ax dx ax cx cx jcond cx recall section dx ax register arguments 
registers modi ed instruction shift left 
form part loop instruction jumps back initial instruction register cx equal zero 
loop nished ow control transfered basic block returns subroutine 
registers dx ax instruction modi ed versions registers 
think subroutine anlshl function returns registers call function anlshl instruction replaced types optimizations dx ax call anlshl def dx ax dx ax cl instruction uses registers de ned instruction register copy propagation arrive code bp bp call anlshl return instruction function anlshl instruction modi ed return registers dx ax leading code ret dx ax register copy propagation instruction intermediate de nes register value unique subsequent instruction 
machine language intermediate instructions move contents operands registers move operands instruction registers particular instruction store computed result registers local variable 
consider code basic block dx ax bp bp def dx ax dx ax dx ax bp bp def dx ax dx ax bp bp dx ax def dx ax instruction de nes long register dx ax copying contents long local variable bp 
long register instruction operand subtraction 
result placed long register copied long local variable bp instruction 
seen instruction de nes temporary long register dx ax instruction instruction rede nes register copied nal local variable instruction 
intermediate registers eliminated replacing local variable de ne instruction registers dx ax replaced long local variable bp de ned registers previous instruction dx ax bp bp bp bp instruction removed 
similar way resultant long register dx ax instruction replaced instruction leading code bp bp bp bp bp bp instruction eliminated 
nal instruction reconstruction original high level expression 
high level language expressions represented parse trees operands machine language expressions allow operands 
cases operands needs register result placed register 
nal result copied appropriate identi er local variable argument global variable 
consider code basic block elimination data flow analysis ax si def ax dx ax ax def dx ax ax tmp dx ax def tmp dx ax ax tmp di def ax tmp dx def dx ax ax dx def ax ax dx si ax def ax instruction de nes register ax copying contents integer register variable si 
register variables treated local variables registers context 
instruction uses register ax de ne register dx sign extension register ax 
instruction uses sign extended registers copy register tmp instruction dividend divide instruction 
local integer register variable di divisor result placed register ax 
result multiplication instruction uses register dx rede nes register ax 
result placed local register variable si 
seen instructions folded subsequent instruction eliminating follows instruction replaced instruction leading dx ax si instruction eliminated 
instruction replaced instruction leading tmp si instruction eliminated 
instruction replaced instruction leading ax si di instruction eliminated 
instruction replaced instruction leading ax si di dx instruction eliminated 
instruction replaced instruction leading ax si di instruction eliminated 
instruction replaced instruction leading nal code si si di nal instruction replaces previous instructions 
actual parameters actual parameters subroutine call pushed stack placed registers register arguments subroutine invoked 
arguments mapped formal argument list subroutine placed actual parameter list call instruction 
consider code basic block register copy propagation push bp bp push si push call printf types optimizations parsing formal argument list printf xed argument size bytes avariable number arguments 
calling convention procedure set instruction saved information regarding number bytes popped stack subroutine call bytes case bytes actual arguments subroutine rst bytes xed 
instruction pushes bytes stack instruction pushes bytes stack instruction pushes bytes stack total bytes required printf instance 
identi ers replaced actual argument list printf instruction reverse order due calling convention instruction pushed rst argument list 
modi cations lead code call printf si bp bp instructions eliminated 
similar way register arguments placed actual argument list invoked subroutine 
consider code basic blocks register argument function return register detection dead register elimination cl def cl dx ax bp bp def dx ax bp bp call anlshl dx ax cl instruction de ne register arguments function anlshl associated register de nitions placed function actual argument list way bp bp call anlshl bp bp eliminating instructions intermediate registers dx ax 
data type propagation procedure calls type actual arguments subroutine needs type formal arguments 
case library subroutines formal argument types known certainty types need matched actual types 
di erences formal type propagated actual argument 
consider code basic block register copy propagation detection actual parameters call printf si bp bp rst formal argument type printf string char 
strings stored machine language data constants data code segment 
strings referenced accessing desired segment set segment 
example constant rst really set string located data segment 
string type propagated rst argument string memory replaced actual argument list leading code call printf ld si bp bp arguments printf undetermined type point view formal argument list types actual arguments trusted types caller modi ed 
data flow analysis register variable elimination register copy propagation optimization nds high level expressions eliminates intermediate instructions eliminating intermediate registers computation expression seen section 
optimization applied registers left intermediate code 
remaining registers represent register variables common subexpressions compiler optimizer speed access time 
registers equivalent local variables high level program replaced new local variables corresponding subroutine uses 
consider code basic block register copy propagation si di si si di registers si di register variables procedure 
registers initialized instructions expression instruction 
rename register si loc register di loc previous code look loc loc loc loc loc registers eliminated 
applying previously explained transformations nal intermediate code shown 
global data flow analysis order perform code improving transformations intermediate code decompiler needs collect information registers condition codes program propagate information di erent basic blocks 
information collected ow analysis process solves systems equations relate information various points program 
section de nes data ow problems equations available literature refer ac asu fj information 
data flow analysis de nitions de nition aregister de ned content register modi ed assigned new value 
similar way ag de ned ed instruction 
de nition aregister register referenced value register 
similar way ag instruction 
de nition locally available de nition block bi de nition bi 
global data flow analysis loc loc loc loc loc bp bp bp bp jcond bp bp bp bp bp bp bp bp bp bp bp bp anlshl bp bp printf loc bp bp ret arg arg arg arg jcond arg flow graph code optimization arg arg ff jcond arg ret arg de nition locally upwards exposed basic block bi previously de ned 
de nition de nition basic block bi reaches basic block bj 
locally available de nition bi 

bi bj 

bi bj bk bi bj bk rede ne de nition de nition register ag basic block bi said kill de nitions register ag reach bi 
de nition de nition block bi preserved rede ned 
de nition de nitions available block bi 
locally available de nitions register ag 

de nitions register ag reaching bi 
de nition register ag upwards exposed basic block bi 
locally upwards exposed bi 

bi bk locally upwards exposed bk bj contains de nition symbol chapter represent path 
symbol de ned chapter section 
data flow analysis de nition de nition live active basic block bi 
reaches bi 
upwards exposed bi 
de nition de nition basic block bi busy called busy ifd rede ned paths bi 
de nition de nition basic block bi dead rede ned paths bi busy live 
de nition de nition chain du chain de nition instruction set instructions rede ned instructions ected 
de nition de nition chain ud chain instruction set instructions de ned statements ect 
de nition apath clear de nition path 
taxonomy problems data ow problems solved series equations uses information collected basic block propagates complete control ow graph 
information propagated ow graph procedure called intraprocedural data ow analysis information propagated procedure calls called interprocedural data ow analysis 
information registers de ned killed collected basic block form sets gen kill summarized basic block entrance exit form sets sets 
typical data ow equation basic block bi form bi gen bi bi kill bi stands information basic block bi information generated bi information entered basic block killed basic block 
summary information collected predecessor nodes graph equation form bi pred bi collects information available exit predecessor node 
data ow problem classi ed path problem information collected predecessors derived path paths need information 
path problems represented equations union predecessors successors depending problem 
similar way paths problem data ow problem speci ed equation collects information available paths current basic block successors predecessors depending type problem 
global data flow analysis de nition data ow problem said forward ow 
set computed terms set basic block 

set computed set predecessor basic blocks 
de nition data ow problem said backward ow 
set computed terms set basic block 

set computed set successor basic blocks 
classi cation data ow problems derives taxonomy shown 
forward backward ow problem path path equations de ned terms successors predecessors 
table taken fj 
forward flow backward flow bi gen bi bi kill bi bi gen bi bi kill bi path bi pred bi bi succ bi bi gen bi bi kill bi bi gen bi bi kill bi paths bi pred bi bi succ bi data flow equations data flow analysis equations data ow equations general unique solutions data ow problems minimum maximum xed point solution satis es equations interest 
finding solution done setting boundary condition initial value set header basic block forward ow problems value set exit basic block backward ow problems 
depending interpretation problem boundary condition sets initialized empty universal set possible values 
intraprocedural data ow problems solve equations subroutine account de ned subroutines 
problems ow insensitive boundary conditions set initial forward ow problems exit backward ow problems nodes 
interprocedural data ow problems solve equations subroutines program account values de ned invoked subroutines 
information ows subroutines call graph 
ow sensitive problems set boundary condition main subroutine program call graph subroutines summarize information predecessor case forward ow problems successor backward ow problems nodes call graph caller node 
section presents data ow equations solve reaching live available busy registers 
reaching register de nition analysis determines registers reach particular basic block path forward ow path equations data flow analysis de nition bi block bi set registers reach entrance tobi bi set registers reach exit bi kill bi set registers killed def bi set registers de ned bi pred bi bi header node bi def bi bi kill bi live register analysis determines register path backward ow path equations de nition bi block livein bi set registers live entrance tobi liveout bi set registers live exit bi bi set registers def bi set registers de ned liveout bi succ bi livein bi return node livein bi bi liveout bi def bi available register analysis determines registers available paths graph forward ow paths equations de nition bi block bi set registers available entrance tobi bi set registers available exit bi compute bi set registers bi computed killed kill bi set registers bi killed due assignment global data flow analysis bi pred bi bi header node bi compute bi bi kill bi busy register analysis determines registers busy paths graph backward ow paths equations de nition bi block bi set registers busy entrance tobi bi set registers busy exit bi bi set registers killed kill bi set registers killed bi succ bi bi return node bi bi bi kill bi problem nding uses register de nition du chain problem solved backward ow path problem 
similarly problem nding de nitions register ud chain problem solved forward ow path problem 
previous data ow problems summarized table 
forward flow backward flow path reach live ud chains du chains path available busy copy propagation dead data flow problems summary precise interprocedural live variable equations part code optimization link time system sw 
phase approach order remove information propagation unrelated subroutines call subroutine 
call graph nodes call node call node edge header node callee subroutine ret call node edge return node callee subroutine 
rst phase information ows normal nodes call edges return edges removed call graph 
second phase information ows normal nodes return edges call edges removed data flow analysis call graph 
phase summary information calculated rst phase 
information ows caller callee viceversa method provides precise information methods literature 
de nition presents equations precise interprocedural register analysis 
live dead register equations solved rst phase summarized subroutine call graph sets 
live register equations solved second phase equations associated phase number di erentiate livein rst phase livein second phase 
separate equations call ret call basic blocks 
initial boundary conditions live dead equations empty set 
de nition bi block call ret call livein bj set registers live phase liveout bj set registers live exit bj phase bj set registers killed entrance bj set registers killed exit bj bj set registers def bj set registers de ned livein bj set registers live phase liveout bj set registers live exit bj phase precise interprocedural live register analysis calculated follows phase liveout bi succ bi livein bi return node livein bi bi liveout bi def bi succ bi bi node bi bi def bi bi bi liveout ret call succ ret call livein livein ret call liveout ret call liveout call livein entry liveout ret call entry livein call liveout call ret call succ ret call ret call ret call call entry ret call livein entry call call global data flow analysis subroutine summary subroutine phase liveout bi livein entry entry succ bi livein bi return node main livein bi bi liveout bi def bi liveout ret call succ ret call livein livein ret call liveout ret call liveout call liveout ret call livein call liveout call def bx def dx call call main ret call ax bx ret call ret def ax dx ret def ax def cx cx live register example graph def dx example consider call graph 
program main procedure subroutines 
interprocedural live register analysis explained de nition provides summary information nodes call ret call ax ret data flow analysis phase subroutine node def livein liveout fax fax fax main fax fax fax fax fax fax fax fax bx subroutine summary subroutine fax main fax bx phase subroutine node def livein liveout fax fax fax bx fax fax fax bx fax main fax fax fax fax global data flow analysis types data ow equations solve data ow problems 
consider problem nding reaching register de nitions basic block bi de nition 
de nition reaching problem de ned terms available problem register reaches basic block register available path predecessor node current node 
problem equivalent nding set 
equation solve problem de nition 
bi block 
reach bi set reaching registers bi 
avail bi set available registers bi reach bi pred avail problem nding available registers basic block de ned terms locally available reaching de nitions see de nition 
problem equivalent nding set 
equation de nition 
bi block 
avail bi set available registers bi 
reach bi set reaching registers bi 
propagate bi set registers propagated bi 
def bi set locally available de nitions bi avail bi def bi reach bi bi de nition de nes live register problem terms reaching de nitions upwards exposed uses 
problem equivalent solving equation livein set 
equation de nition 
bi block 
live bi set live registers entrance tobi 
reach bi set reaching registers bi 
bi set registers upwards exposed live bi reach bi bi data flow analysis solving data flow equations control ow graph subroutine data ow equations solved di erent methods iterative method solution recomputed xed met interval method solution interval propagated nodes interval 
equations unique solution minimal solution taken answer 
iterative algorithms explained asu interval algorithms ac 
code improving optimizations section describes data ow information solve code improving optimizations decompiler 
aim optimizations eliminate condition codes registers exist high level languages regenerate high level expressions available decompiled program 
section initial replicated convenience 
dead register elimination register dead de ned instruction rede ned subsequent instruction 
instruction de nes dead register de nes register said instruction useless eliminated 
hand instruction de nes register instruction useful de ne dead register 
case instruction modi ed re ect fact 
dead register analysis solved de nition chains registers de nition chain states instructions de ned register instructions register register dead 
consider code basic block de nition du chains registers de ned 
note register variables du chain represent local variables temporary registers 
ax tmp di du ax dx tmp di du dx dx du dx dx ax ax dx du ax du dx si ax inspection register dx instruction de ned subsequently rede nition dead instructions 
instruction de nes register redundant eliminated 
instruction de nes register ax instruction modi ed re ect fact dx de ned instruction 
resulting code looks ax tmp di du ax dx du dx ax ax dx du ax si ax code improving optimizations si di ax si dx ax ax tmp dx ax ax tmp di dx tmp di dx dx ax ax dx si ax bp bp bp bp dx ax bp bp cmp bp bp dx ax jg push bp bp ax si dx dx ax ax dx push ax ax push ax call printf ret dx ax bp bp dx ax dx ax bp bp bp bp dx ax cx dx ax bp bp call anlshl bp bp dx ax jmp anlshl dx ax dx ax cx cx flow graph optimization ch ret algorithm nds registers dead removes code 
purposes decompilation optimization du chains du chains needs updated re ect elimination instructions instruction eliminated due dead register de nition de ned terms registers rn uses registers instruction longer exist corresponding du chains instructions de ne registers modi ed longer problem solved checking de nition chain states instructions de ne registers consider piece code basic block du ud de nition chains registers data flow analysis procedure pre du chains registers computed instructions 
post dead registers instructions eliminated basic block instruction register defined du defines register eliminate instruction modify instruction define register def def procedure dead register elimination algorithm tmp dx ax du tmp ud dx ud ax ax tmp di du ax ud tmp dx tmp di du dx ud tmp dx du dx dx ax ax dx du ax du dx ud ax ud dx si ax ud ax instruction detected redundant ud chain checked instruction de ned register involved computation dead register dx 
seen register tmp instruction de ned instruction ud tmp du chain instructions 
instruction going eliminated du chain instruction updated reach instruction leading code dead register elimination du chain update tmp dx ax du tmp ud dx ud ax ax tmp di du ax ud tmp dx du dx ax ax dx du ax ud ax ud dx si ax ud ax algorithm solves problem updating du chains doing elimination 
algorithm invoked procedure code improving optimizations instruction detected redundant removed 
note particular register empty leading dead registers recursively eliminated code 
procedure pre ud du chains registers computed instructions 
instruction eliminated 
post du chain instruction register instruction instruction ud du instruction du du du defines register eliminate instruction modify instruction define register def def procedure update du chains dead condition code elimination condition code ag dead de ned instruction rede nition 
de nition condition code side ect instruction instruction function eliminating dead ags instruction redundant instructions eliminated dead ag elimination 
analysis condition code determined dead longer necessary de ned instruction information removed instruction 
information condition codes kept instruction form sets set de ned conditions set conditions 
analysis nd condition codes dead similar dead register analysis du chains 
case need ud chains instruction eliminated 
consider code basic block du chains condition codes cmp bp bp dx ax def zf cf sf du sf du cf zf jg sf data flow analysis instruction de nes condition codes zf zero cf carry sf sign 
checking du chains conditions nd ag sf ags de nition dead 
de nition ags removed code associated instruction leading code cmp bp bp dx ax def sf du sf jg sf algorithm nds condition codes dead eliminates 
procedure pre du chains condition codes computed instructions 
post dead condition codes eliminated basic block instruction condition code def du def def procedure dead condition code elimination algorithm condition code propagation dead condition code elimination removes de nitions condition codes program 
remaining condition code de nitions subsequent instruction eliminated capturing essence condition 
problem solved means du chains ud chains condition codes way provides equivalent solution 
consider code basic block ud chains condition codes cmp bp bp dx ax def sf jg sf ud sf particular ag nd instruction de ned ag merge instructions boolean condition implicit instruction uses ag 
instruction uses ag sf implicitly checks greater boolean condition 
instruction de nes ag instruction compares rst identi er bp bp second identi er dx ax 
rst identi er greater second identi er sf set 
ags originally set instruction eliminated dead condition code elimination considered 
code improving optimizations obvious function instructions propagation condition sets sf comparing identi ers instruction uses condition eliminate instruction de nes condition generate boolean condition instruction uses condition 
example propagation sf leads code jcond bp bp dx ax eliminating ag 
condition code uses extended basic blocks de nition extended basic block sequence blocks bn bi predecessor bi bi conditional jump instruction 
flag de nition uses occur basic block programs 
standard cases ag de nition block ag extended basic block code cmp ax dx def sf zf du sf du zf jg bx sf ud sf je zf ud zf case instruction de nes ags sf zf 
sign ag instruction basic block zero ag instruction di erent basic block extended basic block 
sign condition instruction propagated instruction checks greater boolean condition instruction replaced cmp ax dx def zf du zf jcond ax dx bx je zf ud zf instruction de nes zero ag instruction instruction removed identi ers form part boolean condition need known 
analysis instruction analyzed de nition zero ag instruction propagated ag instruction generates boolean condition checks equality registers 
de nitions condition codes instruction instruction safely eliminated leading code jcond ax dx bx jcond ax dx algorithm extended propagate condition codes de ned basic blocks doing individual boolean conditions required practice unknown optimising compilers attempt track ag de nitions basic block boundaries gou 
algorithm propagates condition codes extended basic block 
boolean conditional expressions derived analysis generate expressions form described bnf 
expressions saved parse trees intermediate high level representation 
data flow analysis procedure pre dead condition code elimination performed 
sets defined flags computed instructions 
ud chains condition codes computed instructions 
post condition codes eliminated basic blocks postorder instructions order check flag flags ud def def remove set propagate identifiers instruction boolean condition instruction store repetitions 
def eliminate instruction procedure condition code propagation algorithm cond cond cond factor op factor factor register localvar literal parameter global op register arguments bnf conditional expressions register calling convention compilers speed invocation subroutine 
option available contemporary compilers compiler runtime support routines 
subroutine register arguments translate registers subroutine de ned subroutine upwards exposed uses registers subroutine 
consider code basic blocks subroutine anlshl condition code elimination code improving optimizations ch jcond cx ud ch ud cl dx ax dx ax ud dx ax instruction uses register cx completely de ned subroutine high part register ch de ned instruction low part de ned 
similar problem encountered instruction registers dx ax de ned subroutine 
information registers de ned summarized live register analysis register basic block uses 
analysis done solving intraprocedural live register equations de nition equations rst phase precise interprocedural live register analysis de nition 
performing live register analysis anlshl leads livein liveout sets basic block livein liveout fdx ax clg fdx fdx fg fg fg set livein registers summarized header basic block set register arguments subroutine dx ax cl example 
formal argument list subroutine updated re ect arguments formal arguments anlshl arg dx ax arg cl said anlshl subroutine uses registers 
general subroutine register arguments uses registers invocation subroutines call instruction said registers instruction call anlshl dx ax cl algorithm nds set register arguments subroutine 
function return register functions return results registers machine instruction states registers returned function 
function return caller uses registers returned function rede ned registers live entrance basic block follows function call 
register information propagated subroutine boundaries solved reaching live register analysis 
consider code basic blocks dx ax bp bp def dx ax call anlshl def dx ax cl bp bp dx ax def dx ax data flow analysis procedure pre intraprocedural live register analysis performed subroutine post uses set register arguments subroutine livein uses livein uses procedure register argument algorithm instruction uses registers dx ax registers de ned instruction de nition subroutine call occurs 
known subroutine procedure function safe assume de nition instruction reaching instruction 
summary information needed determine de nition reaches instruction 
performing intraprocedural reaching register analysis subroutine anlshl leads sets basic block fg dx dx dx analysis states de nitions registers cx dx ax reach subroutine set basic block 
caller subroutine uses reaching registers necessary determine registers upwards exposed successor basic block subroutine invocation 
information calculated solving interprocedural live register equations de nition second phase precise interprocedural live register analysis de nition 
information needs accurate live register analysis equations solved way register live register seen subsequent node 
livein liveout sets calculated example basic block livein liveout fg fg fg fdx fdx fg fg fg fdx ax clg fdx fdx fdx fdx fdx code improving optimizations registers reach basic block registers belong livein dx ax registers registers interest called subroutine nished registers returned function 
condition checks returned registers livein fdx general subroutine return nodes set subroutine registers reach single exit 
equation summarizes information subroutine bi bi subroutine determined function register function returns determined information propagated di erent places return instruction function instructions call function 
case return basic blocks instruction instruction modi ed return registers function returns 
example instruction basic block modi ed code ret dx ax case function invocation instruction call instruction replaced instruction takes left hand side de ned register takes function call right hand side instruction code dx ax call anlshl def dx ax dx ax cl instruction transformed asgn instruction de nes registers left hand side lhs 
algorithm determines subroutines functions return value register 
important note case library functions return register call transformed asgn instruction remains call instruction 
register copy propagation register copy propagation method de ned register assignment instruction say ax cx replaced subsequent instruction uses register register modi ed rede ned assignment ax cx modi ed 
case register ax replaced register cx uses ax replaced cx ax dead assignment instruction eliminated 
ax replaced cx ax de nition ax reaches ax assignments cx occurred instruction ax cx 
condition checked ud chains registers 
condition checked clear condition forward ow paths analysis 
consider code basic block du chains data flow analysis procedure pre interprocedural live register analysis performed 
intraprocedural reaching register definition performed 
post def set registers returned function call instruction functions modified asgn instructions 
ret instructions functions return function return registers subroutines basic blocks postorder instructions call instruction subroutine function false function far def livein succ intersect def function def def function true rhs convert asgn inst lhs def opcode asgn ret instructions function exp def propagate return register function rhs convert asgn inst lhs def opcode asgn def def registers defined procedure function return register dx ax bp bp du dx ax dx ax dx ax bp bp ud dx ax du dx ax bp bp dx ax ud dx ax ud chains instructions instruction uses registers dx ax de ned instruction 
registers rede ned instructions right hand side instruction replaced registers follows dx ax bp bp bp bp du dx ax code improving optimizations registers instruction du dx ax registers dead instruction eliminated 
similar way instruction uses registers dx ax de ned instruction 
registers rede ned instructions right hand side instruction replaced registers instruction leading bp bp bp bp bp bp registers de nition instruction registers dead instruction eliminated 
noticed example right hand side instruction replaced left hand side instruction building expressions right hand side assignment instruction 
consider example basic block dead register elimination ud chains du chains registers excluding register variables ax si du ax dx ax ax ud ax du dx ax tmp dx ax ud dx ax du tmp ax tmp di ud tmp du ax dx du dx ax ax dx ud ax ud dx du ax si ax ud ax register ax instruction replaced register variable si making de nition ax dead 
dx ax instruction replaced si instruction making de nition dx ax dead 
tmp instruction replaced si instruction making de nition tmp dead 
ax instruction replaced si di instruction making de nition ax dead 
instruction dx replaced constant instruction making de nition dx dead 
ax instruction replaced si di instruction making de nition ax dead 
register de ned instructions registers dead instructions eliminated leading nal code si si di propagating registers assignment instructions register bound de ned terms expression registers local variables arguments constants 
identi ers constants rede ned necessary check identi ers rede ned path instruction de nes register instruction uses 
necessary conditions checked register copy propagation 
uniqueness register de nition register registers rede ned translate temporary registers hold intermediate result machine 
condition checked means ud chains registers instruction 
data flow analysis 
rhs clear path identi ers expression de nes register rhs instruction satis es condition checked anx clear path instruction uses register rhs clear condition instruction uses register uniquely de ned instruction formally de ned rhs rhs rhs side instruction identi er belong rhs true de nition path false algorithm performs register copy propagation assignment instructions 
analysis registers word byte registers ax ah treated di erent registers live register analysis 
register ax de ned de nes registers ah register de ned de nes registers ax register ah 
needed uses part register high low part detected treated byte operand integer operand 
extension non assignment register usage instructions algorithm general propagate registers instructions assignments call jcond instructions 
consider code basic block condition code propagation dx ax bp bp du dx ax jcond bp bp dx ax ud dx ax instruction uses registers dx ax uniquely de ned instruction 
rhs instruction propagated registers leading elimination instruction 
nal code looks follows jcond bp bp bp bp similar way register push instruction replaced rhs instruction de nes register code basic block dead register elimination ax si du ax dx du dx ax ax dx ud dx du ax push ax ud ax applying register copy propagation algorithm arrive code push si instruction eliminated 
call instruction modi ed asgn instruction due function invoked procedure candidate register copy propagation 
consider code function return register determination code improving optimizations procedure pre dead register elimination performed 
ud chains du chains computed instructions 
post registers eliminated 
high level language expression 
basic blocks postorder instructions basic block registers instruction ud uniquely defined instruction prop true identifiers rhs compute rhs clear clear prop false prop true propagate rhs replace instruction rhs du du instruction du defines register eliminate modify instruction define register def def propagate procedure register copy propagation algorithm dx ax call anlshl ud dx ax ud cl du dx ax bp bp dx ax ud dx ax function anlshl returns value registers dx ax 
registers rst instruction basic block follows current copied nal local long variable set 
performing copy propagation leads code bp bp call anlshl eliminating instruction dx ax dead 
data flow analysis actual parameters actual parameters subroutine normally pushed stack invocation subroutine 
nested subroutine calls allowed languages arguments pushed stack represent arguments subroutines necessary determine arguments belong subroutine 
expression stack stores expressions associated push instructions 
call instruction met necessary number arguments popped stack 
consider code basic block dead register elimination register copy propagation push bp bp push si push call printf instructions push expressions associated instruction stack shown 
call printf reached information function checked determine bytes arguments function call takes case takes bytes 
expressions stack popped checking type expressions determine bytes 
rst expression integer constant takes bytes second expression integer expression takes bytes third expression long variable takes bytes total bytes needed function call 
expressions popped stack placed actual parameter list invoked subroutine calling convention subroutine 
example library function printf uses calling convention leading code call printf si bp bp instructions eliminated intermediate code placed stack 
tos si bp bp expression stack register arguments pushed stack de ned set subroutine uses 
case placing actual arguments subroutine actual argument list extension register copy propagation algorithm 
consider code basic blocks dead register elimination register argument detection cl du cl dx ax bp bp du dx ax dx ax call anlshl ud dx ax ud cl code improving optimizations instruction uses registers dx ax de ned instruction register cl de ned instruction 
uses replaced uses rhs corresponding instructions placed actual argument list anlshl order de ned formal argument list leading code dx ax call anlshl bp bp instruction eliminated de ne dead registers 
data type propagation procedure calls instantiation actual arguments formal arguments data types arguments needs veri ed di erent data types needs modi ed 
consider code basic block previous optimizations call printf si bp bp actual argument list data types integer constant integer long variable 
formal argument list printf pointer character string rst argument variable number unknown data type arguments 
information rst argument rst actual argument di erent data type 
data types library subroutines right trusted safe say actual integer constant set memory pointing character string 
checking memory location ds string integer constant replaced string 
arguments unknown formal type type caller trusted leading code call printf ld si bp bp cases type propagation include conversion integers long variable callee determined arguments long variable caller far actual argument separate integers 
register variable elimination register variables translate local variables high level language program 
registers replaced new local variable names 
name replacement done data ow analysis code generator 
example registers si di replaced local names loc loc code fragment derived part basic block loc loc loc loc loc data flow analysis extended register copy propagation algorithm optimizations register copy propagation actual parameter detection data type propagation procedure calls performed pass propagates register information instructions including arguments 
lists di erent high level instructions de ne registers 
instructions de ne registers asgn eliminated register copy propagation explained section function call translated equivalent asgn instruction eliminated register copy propagation method pop instruction addressed 
de ne asgn lhs asgn rhs call function call register arguments pop jcond ret function return registers push potential high level instructions de ne registers pop instruction de nes associated register value top stack 
pop instructions restore stack subroutine call subroutine return eliminated intermediate code idiom analysis see chapter sections remaining pop instruction get value pushed stack previous push instruction spilled value 
expressions associated push instructions pushed expression stack detection actual arguments see section pop instruction reached expression top stack associated register pop instruction converting instruction asgn instruction 
consider code matrix addition procedure spills partially computed answer stack instructions dead register elimination 
example arrays passed arguments procedure arrays pointed bp bp array operands array pointed bp resultant array 
arrays arrays integers bytes ax si ud ax dx ud dx ax ax dx ud ax bx ax ud bx bx bx bp ud bx ax di ud ax ax ax ud ax bx bx ax ud bx ax bx ud ax push ax spill ax ax si ud ax dx ud dx code improving optimizations ax ax dx ud ax bx ax ud bx bx bx bp ud bx ax di ud ax ax ax ud ax bx bx ax ud bx pop ax ud ax ax ax bx ud ax push ax spill ax ax si ud ax dx ud dx ax ax dx ud ax bx ax ud bx bx bx bp ud bx ax di ud ax ax ax ud ax bx bx ax ud bx pop ax ud ax bx ax register copy propagation instructions instruction holds contents array pointed bp set si di row column sets represented expression push si bp di expression pushed stack register ax rede ned instruction 
extended register copy propagation instruction pops expression stack modi ed asgn instruction ax si bp di ud ax instruction replaced instruction register ax spilled instruction holding addition contents arrays sets si di represented expression push si bp di si bp di expression popped instruction replacing pop asgn instruction ax si bp di si bp di register bx holds set result array sets si di 
registers instruction replaced expressions calculated instructions leading code si bp di si bp di si bp di data flow analysis note instruction de ne registers uses instruction nal sense replaced subsequent instruction 
seen rhs lhs hold expressions calculate address array 
expressions analyzed determine calculate array set arguments passed subroutine pointers arrays information propagated caller subroutine 
description nal algorithm extended register copy propagation 
data type propagation data type determination done program expressions data types arrays address computation object array 
address computation represented expression needs simpli ed order arrive high level language expression 
consider array expression section si bp di si bp di si bp di heuristic method determine integer pointer bp dimensional array set expressions compute address 
set di adjusting index di size array element type case integer set si adjusting index si size row times size array element elements row number columns array expression modi ed code bp si di bp si di bp si di type arguments modi ed array pointer integer array 
order determine bounds array heuristic intervention needed 
number elements row determined previous heuristic number rows determined array loop structure gives information regarding number rows 
consider matrix addition subroutine 
subroutine loops rows columns 
checking conditional jumps index si upper bound number rows determined 
basic block si compared greater equal loop executed array indexed assume upper bound rows 
number columns checked nding conditional jump instructions register di 
case basic block compares register register greater equal constant inner loop executed array indexed 
constant upper bound number columns 
note number known heuristics determining array address computation assume number right 
leads formal argument declaration data type propagation procedure pre dead register analysis performed 
dead condition code analysis performed 
register arguments detected 
function return registers detected 
post temporary registers removed intermediate code 

basic blocks subroutine postorder instructions registers instruction ud uniquely defined instruction case opcode asgn case opcode asgn propagate rhs rhs 
jcond push ret propagate rhs exp 
call 
case pop exp 
case opcode asgn propagate exp rhs 
jcond push ret propagate exp exp 
call exp 
case call case opcode asgn rhs push ret jcond exp call 
case case opcode push exp 
elsif opcode call invoked routine uses stack arguments pop arguments stack 
place arguments actual argument list 
propagate argument type 
procedure extended register copy propagation algorithm data flow analysis si jcond si ret di si si jcond di bp si di bp si di bp si di di di matrix addition subroutine formal arguments arg array bp arg array bp arg array bp information propagated caller subroutine 
general hard determine bounds array code optimised 
example strength reduction applied subscript calculation code motion moved part subscript calculation loop induction variable elimination replaced loop indexes previous heuristic method applied 
case decompiler leave bounds array unknown ask user solution interactive session 
chapter control flow analysis control ow graph constructed front information high level lan guage control structures loops 
graph converted structured high level language graph means structuring algorithm 
high level control structures detected graph subgraphs control structures tagged graph 
relation phase data ow analysis phase back shown 
front 
data flow unstructured control flow structured 
analysis graph analysis graph back context control flow analysis phase hll program generic set high level control structures structure graph 
set general cater di erent control structures available commonly languages asc pascal modula fortran 
structures include di erent types loops conditionals 
underlying structure graph modi ed functional semantical equivalence preserved method 
previous structuring algorithms concentrated removal goto statements control ow graphs expense new boolean variables code replication multilevel exit loops set high level structures available commonly languages 
graph transformation system aims recognition underlying control structures removal goto statements 
sections summarize done area 
boolean variables bohm bj proved program represented decomposable sequence nodes post tested loop way conditional node new boolean variables assignments variables 
cooper coo pointed new variables may original program program represented node practical point view theorem meaningless knu 
control flow analysis ashcroft manna am demonstrated goto programs converted programs new variables algorithm conversion programs new boolean variables 
conversion preserves topology original program performs computations di erent order 
williams ossher wo iterative algorithm convert loop single exit loop boolean variable counter integer variable loop 
baker zweben bz reported structuring loops new boolean variables 
structuring multiple exit loops considered control ow complexity issue measured 
williams chen wg transformations eliminate goto statements pascal programs 
gotos classi ed positioning target label level corresponding label branch structure label structure abnormal exits subroutines 
transformations required boolean variables necessary assignment test statements check value boolean 
algorithm implemented prolog pdp 
hendren eh algorithm remove goto statements programs 
method goto elimination goto movement transformations introduces new boolean variable goto 
new instructions introduced test new boolean di erent loop conditionals modi ed include new boolean 
method implemented part mccat parallelizing decompiler 
new boolean variables modi es semantics underlying program variables form part original program 
resultant program functionally equivalent original program produces results 
code replication knuth floyd kf di erent methods avoid goto statements introductions new variables 
methods recursion new procedures node splitting repeat construct 
node splitting technique replicates code nal program 
proved exist programs goto statements eliminated new procedure calls 
williams wil presents subgraphs lead unstructured graphs abnormal selection paths multiple exit loops multiple entry loops overlapping loops parallel loops 
order transform subgraphs structured graphs code duplication performed 
previous williams ossher wo algorithm replace multiple entry loops single entry loop 
method code duplication nodes reached abnormal entries loop 
baker zweben bz reported node splitting technique generate equivalent replicating nodes graph 
node splitting considered control ow complexity issue measured 
transformations convert types unstructured graphs structured equivalent graphs 
methodology node duplication function duplication 
demonstrated time overhead produced duplication nodes increased time factor path 
code replication modi es original program graph replicating code node times nal program graph functionally equivalent original program graph semantics structure modi ed 
multilevel exit loops structures baker bak algorithm structure equivalent control structures multilevel break multilevel endless loops 
graph structured previous structures 
algorithm extended irreducible graphs 
demonstrated algorithm generated formed properly nested programs goto statements nal graph jumped forward 
algorithm implemented struct program pdp running unix 
rewrite fortran programs extended fortran language control structures 
struct program reuter decomp decompiler structure graphs built object les symbol information 
sharir sha algorithm nd underlying control structures ow graph 
algorithm detected normal conditional looping constructs detected proper improper strongly connected intervals proper improper outermost intervals 
nal ow graph represented hierarchical ow structure 
ramshaw ram method eliminate goto statements programs means forward backward elimination rules 
resultant program structurally equivalent program multilevel exits endless type named loops 
algorithm port pascal version knuth tex compiler parc csl uses mesa 
languages allow goto statements outward gotos allowed mesa 
multilevel exits high level constructs available languages restricts generality structuring method number languages structured version program written 
currently rd generation languages pascal modula multilevel exits ada allows 
control flow analysis graph transformation system lic series transformation rules transform control ow graph trivial graph identifying subgraphs represent high level control structures way conditionals sequence loops loops 
rules applicable graph edge removed graph goto generated place 
transformation system proved nite church rosser transformations applied order nal answer reached 
formalized transformation system context free grammars context free grammars de ned production rules transform graph lic 
proved rooted context free grammar gg possible determine derived gg 
provided algorithm solve problem polynomial time complexity 
detection control structures means graph transformations modify semantics functionality underlying program transformation system provides method generate semantically equivalent graph 
method uses series graph transformations graph convert transform graph equivalent structured graph possible 
transformations take account graphs generated short circuit evaluation languages operands compound boolean condition necessarily evaluated generate unstructured graphs methodology 
contrast structuring algorithms thesis transform arbitrary control ow graph functional semantical equivalent ow graph structured set generic control structures available commonly high level languages goto jumps graph structured generic structures 
algorithms take account graphs generated short circuit evaluation generate unnecessary goto jumps graphs 
graph structuring structuring sample control ow graph informal way 
algorithms structure graphs explained section 
control ow graph sample program contains control structures 
intermediate code analyzed data ow analysis phase variables names 
aim structuring algorithm decompilation determine underlying control structures control ow graph predetermined set high level control structures 
graph structured prede ned set structures goto jumps 
conditions ensure functional semantical equivalence original nal graph 
graph structuring jcond loc loc jcond loc loc loc loc loc loc loc loc loc loc jcond loc loc loc loc loc jcond loc loc loc loc structuring loops printf loc loc ret loc aaa jcond loc loc loc loc loc loc loc printf loc loc jcond loc loc loc sample control flow graph graphs loops detected presence back edge edge lower node higher node 
notion lower higher formally de ned thought nodes lower higher diagram graph drawn starting top 
graph back edges 
back edges represent extent di erent loops 
type loop detected checking header node loop 
loop conditional check header node node loop tests loop executed post tested loop repeat modula 
subgraph represents loop logically transformed subgraph loop subgraph replaced node holds intermediate code instructions information type loop 
loop conditional header node determines loop executed 
node loop way node transfers control back control flow analysis start loop loc loc printf loc loc loc post tested loop header loop 
loop clearly pre tested loop loop variety languages 
subgraph loop logically transformed subgraph loop subgraph replaced node holds information loop instructions 
structuring conditionals loc loc loc start loop loc loc printf loc loc loc loc loc pre tested loop way conditional node branches control node condition loc loc true branches node 
nodes followed node words conditional branch started node nished node 
graph clearly structure logically transformed subgraph node represents basic blocks 
note instructions conditional jump belong basic block modi ed 
way conditional node transfers control node condition loc loc true transfers control node 
previous example node merged nodes transformed equivalent node edge node path node 
target branch nodes conditional node reached branch conditional way node represents single branch conditional 
subgraph transformed node condition node negated false branch single branch forms part 
graph structuring loc loc loc loc loc loc loc loc loc way conditional branching loc loc loc loc loc loc loc loc loc loc loc loc loc loc single branch conditional way conditional nodes trivially structured node considered head nishing node node considered head enter subgraph headed entry point clauses conditional branch 
structure node rst node branches subgraph headed node exit node graph structured structures 
conditional branch instruction conditions merged compound conditional way node reached condition node true condition false condition false 
node reached condition node false true path node 
means node reached condition node true condition node false nal node basic block 
nal compound condition shown transformed subgraph 
control flow analysis control flow analysis loc loc loc loc loc loc loc loc loc compound conditional branch information control structures program available control ow analysis program graph 
information collected di erent nodes graph belong loop conditional part structure 
section de nes control ow terminology available literature information refer tar tar hu hec asu 
control flow analysis de nitions de nitions de ne basic concepts control ow analysis 
de nitions directed graph 
de nition path nv nv represented nv edges nv nv ni ni 
de nition closed path cycle path nv nv 
de nition successors ni ni njg nodes reachable ni 
immediate successors ni ni nj 
de nition predecessors nj fni ni njg nodes reach nj 
immediate predecessors nj fni ni nj 
de nition anode ni back dominates anode nk ni path nk 
said ni dominates nk 
de nition anode ni immediately back dominates nk nj nj back dominates nk ni back dominates nj ni closest back dominator nk 
said ni immediate dominator nk 
de nition strongly connected region scr subgraph ns es hs ni nj ns ni nj nj ni 
control flow analysis de nition strongly connected component subgraph ns es hs strongly connected region 
strongly connected region 
de nition depth rst search dfs traversal method selects edges traverse emanating visited node unvisited edges 
dfs algorithm de nes partial ordering nodes postorder numbering nodes visit numbering starts maximum number nodes graph nishes 
chapter numbered graphs reverse postorder numbering scheme 
de nition depth rst spanning tree ow graph directed rooted ordered spanning tree ofg grown dfs algorithm 
partition edges sets 
back edges 
forward edges 
cross edges 
relations de nition set xry denotes de nition set re exive closure jx sg transitive closure rr re exive transitive closure completion xr 
de nition set nite church rosser fcr 
nite kp pr kp 

function rq rr interval theory interval graph theoretic construct de ned cocke coc widely allen control ow analysis ac data ow analysis ac 
sections summarize interval theory concepts 
control flow analysis intervals de nition node maximal single entry subgraph entry node closed paths contain unique interval node called interval head simply header node 
selecting correct set header nodes partitioned unique set disjoint intervals fi hn 
algorithm nd unique set intervals graph described 
algorithm variables set header nodes set nodes interval list intervals graph function returns immediate predecessor procedure intervals pre graph 
post intervals contained list fg 
fhg 
unprocessed fng 
repeat fm nodes added 
fm 
procedure interval algorithm example intervals dotted boxes 
graph intervals 
interval contains loop back edge 
de nition interval order de ned order nodes interval list intervals algorithm 
interval properties 
header node back dominates 

strongly connected region interval contain header node 
control flow analysis 

mm 



intervals graph 
interval order nodes processed order interval predecessors node reachable loop free paths header processed node 
de nition latching node node interval header node immediate successor 
derived sequence construction derived sequence graphs described allen intervals graph construction graphs iterative method collapses intervals nodes 
rst order graph represented second order graph collapsing interval node 
immediate predecessors collapsed node immediate predecessors original header node part interval 
immediate successors immediate non interval successors original exit nodes 
intervals computed interval algorithm graph construction process repeated limit ow graph reached 
property trivial graph single node irreducible graph 
describes algorithm 
de nition th order graph limit ow graph de ned graph constructed algorithm de nition agraph reducible th order graph trivial 
control flow analysis procedure pre graph 
post derived sequence constructed 
intervals 

repeat construction fn red 
hi ei 
procedure derived sequence algorithm construction derived sequence illustrated 
graph initial control ow graph intervals previously described 
graph represents intervals nodes 
loop unique interval 
loop represents loop extended back edge 
loops trivial graph 


jj 













derived sequence graph high level language control structures implementation considerations compute intervals graph needs de ned terms predecessors successors adjacency type graph representation 
aid extra data structures hecht optimized algorithm nd intervals hec complexity irreducible flow graphs irreducible ow graph graph th order graph trivial graph interval reduction 
irreducible ow graphs characterized existence forbidden canonical irreducible graph hu hu hec 
absence graph ow graph graph reducible 
canonical irreducible graph shown 

canonical irreducible graph theorem ow graph irreducible subgraph form canonical irreducible graph 
high level language control structures di erent high level languages di erent control structures general high level language uses di erent available control structures 
section illustrates di erent control structures gives classi cation analyses structures available commonly high level languages asc pascal modula 
control structures classi cation control structures classi ed di erent classes complexity class 
initial classi cation provided kosaraju kos determine classes reducible classes 
classi cation expanded lm hierarchy classes control structures semantical reducibility 
shows di erent control structures consideration classi cation structures 
action single basic block node action 

composition sequence structures composition 
control flow analysis 

zz action composition conditional 

pre tested loop single branch conditional 

way branch conditional post tested loop 





loop endless loop multilevel exit high level control structures 


multilevel cycle 

conditional structure form predicate structures conditional structure 

pre tested loop loop form predicate structure pre tested loop structure 

single branch conditional conditional form predicate structure single branch conditional structure 

way conditional conditional form case sn 
goto high level language control structures case predicate sn structures way conditional structure 

post tested loop loop form repeat structure predicate post tested loop structure 

loop loop form exit exit pn exit sn sn structures pn predicates loop structure 
exit statement branches loop rst statement basic block loop 

endless loop loop form loop wheres structure endless loop 

multilevel exit exit statement causes termination enclosing endless loops 

multilevel cycle cycle statement causes th enclosing endless loop re executed 

goto goto statement transfers control basic block regardless unique entrance conditions 
di erent structures control structures classi ed classes structures dijkstra 
structures extension structures 
structures bj bohm maximum number predicates loop 
ren structures re repeat maximum 
ren structures rec repeat cycle structures number levels 
structures dre repeat loops maximum number enclosing levels exit 
control flow analysis structures drec repeat cycle structures maximum number enclosing endless loops 
structures structure substructures di erent predicates 
structures formed structure 
restrictions number predicates actions transfers control goto statements allowed 
de nition structures semantical conversion input computes function 
primitive actions predicates precisely 
words new semantics variables actions predicates allowed conversion 
semantical conversion classes control structures form hierarchy shown 
classes higher hierarchy semantical conversion lower classes 
re rec dre drec gp ren 
re bj 
bj rec 
bj gp 
dre drec control structures classes hierarchy control structures rd generation languages section di erent high level languages analysed classi ed terms control structures 
selected languages variety applications including systems programming numerical scienti cal applications multipurpose applications languages modula pascal fortran ada 
high level language control structures modula wir pla allow goto statements control ow graphs generated language structured reducible 
modula type structures way conditionals way conditional case 
pre tested loop post tested loop repeat nite loop loop 
endless loop terminated exit statements statement sequence body loop 
construct simulate loop structures loop predicates structure 
exit statement terminates execution immediately enclosing endless loop statement execution resumes statement loop 
exit occurs pre tested post tested loop nested endless loop inner loop enclosing endless loop terminated exit statement equivalent statement belongs re class structures 
pascal coo strict modula sense allows goto statements 
type structures allowed way conditionals way conditional case pre tested loop post tested loop repeat endless loop simulated true condition true 
gotos simulate multilevel loops unstructured way middle structure class structures permitted language 
kr allows structured unstructured transfer control 
structures represented statements way conditional conditional switch pre tested loop post tested loop endless loop 
level exit control allowed break statements level cycle transfer control allowed continue statement contains structures re rec classes 
goto statements model structure class produce unstructured graphs allows class structures 
fortran col di erent types conditionals include way conditional arithmetic way conditional computed goto statements way conditionals goto sn 
pre tested post tested endless loops simulated statement type structures allowed fortran 
goto statements allowed producing structured unstructured transfers control allowing type structures 
ada dod allows type structures including way conditionals way conditional case pre tested loop loops endless loop loop loop 
ada allows exit statements exit named endless loops nested loops terminated instruction ren class type structure 
goto statements allowed restricted way transfer control statement enclosing sequence statements reverse 
prohibited transfer control alternatives case statement statement 
restrictions gotos simulate multilevel exits multilevel continues permit unstructured transfers control type structures built control flow analysis language 
summarizes di erent types classes structures available set distinguished languages 
pointed languages type structures plus structures belong di erent types classes 
unstructured languages allow unstructured goto case pascal fortran 
structured uses goto ada permit construction structured control ow graphs type structures simulated gotos 
language control structure classi cation modula re pascal drec fortran ada classes control structures high level languages generic set control structures order structure graph set generic control structures needs selected 
set general cater commonly structures variety languages 
review rd generation languages previous section clear languages class structures plus type structured unstructured transfer control multilevel exits gotos 
structures ren classes simulated structured transfers control goto statement 
languages allow goto languages multilevel exit multilevel continue structures goto better choice generic construct exit cycle 
desirable structure control ow graph set generic structures action composition conditional pre tested loop single branching conditional way conditional post tested loop endless loop goto words generic set control structures class structures 
structured unstructured graphs structured unstructured graphs structured control ow graph graph generated programs structures class graph decomposable subgraphs entry exits 
languages allow goto generate structured graphs gotos transfer control structured way transfer control start structure 
unstructured graphs generated unstructured transfer control goto statements transfer control middle structured graph breaks previously structured graph unstructured entry subgraph 
introduced optimization phase compiler code motion performed code moved 
loops loop strongly connected region path directed subgraph 
means back edge loop header node 
structured loop subgraph entry point back edge possibly exit points transfer control node 
structured loops include natural loops pre tested post tested loops endless loops loops 
loops shown 

pre tested loop 

post tested loop 
nite loop structured loops 


loop unstructured loop subgraph back edges entry points exit points di erent nodes 
illustrates di erent types unstructured loops loop loop entry points 
parallel loop loop back edges header node 
overlapping loops loops overlap strongly connected region 
loop loop exits di erent nodes 
control flow analysis 


parallel 
overlapping sample unstructured loops 
follow node structured unstructured loop rst node reached exit loop 
case unstructured loops node considered loop exit node rst node follows follow node loop 
conditionals structured way conditional directed subgraph way conditional header node entry point branch nodes common node reached branch nodes 
nal common node referred follow node property immediately dominated header node 
conditional branch nodes header node follow node subgraph 
conditional branch node follow node converge common node 
shows generic constructs values edges header node true false 
case true false edge leads follow node di erent graphs represent structure case graph representation unique 
similar way way conditional directed subgraph way entry header node successor nodes header node common node reached successor nodes 
common node referred follow node property dominated header node structure 
sample way conditional shown 
unstructured way conditionals way node header subgraphs entries branches header node exits branches header node 
graphs represented abnormal selection path graph shown 
known graph structure subgraph start nodes generating subgraphs 
structured unstructured graphs 



zz 
structured way conditionals qs jj sw structured way conditional graph assumes way conditional starting node abnormal entry node 
graph assumes way conditional starting node abnormal exit node 
zz zz nz zz zz zz zz zz abnormal selection path zz zz similar way unstructured way conditionals allow exits branches way header node 
shows di erent cases unstructured way graphs graph abnormal forward edge zz control flow analysis branches graph abnormal backward edge branches graph abnormal forward edge branches graph abnormal backward edge branches 
zz zz 
zz zz zz zz zz 
zz 

unstructured way conditionals structured graphs reducibility structured graph composed structured subgraphs belong class graphs generated structures 
informal demonstration prove structured graphs class reducible 
consider informal graph grammar 
production rules de ning di erent structured subgraph production rule indicates structured subgraph generated replacing node associated right hand side subgraph production 
theorem class graphs reducible 
demonstration class graphs de ned informal graph grammar 
subgraphs right hand side productions common property having entry point target point way transfers control done structured way 
theorem known graph irreducible subgraph form canonical irreducible graph see 
canonical irreducible graph composed subgraphs conditional branching graph loop 
subgraph entry point subgraph entry points graph irreducible 
productions graph grammar generate subgraphs entry point graph grammar generate irreducible graph graphs belong class reducible 
structuring algorithms decompilation aim structuring algorithm determine underlying control structures arbitrary graph converting functional semantical 
structuring algorithms zz 









hhj graph grammar class structures equivalent graph 
arbitrary graph stands control ow graph reducible irreducible structured unstructured language 
known language initial program written compiler optimizations turned goto jumps allowed case graph structured set generic high level structures 
set generic control structures section chosen structuring algorithm section 
structuring loops order structure loops loop terms graph representation needs de ned 
representation able determine extent loop provide nesting order loops 
pointed hecht hec representation means cycles ne representation loops necessarily properly nested disjoint 
strongly connected components loops coarse representation nesting order 
strongly connected regions 


control flow analysis provide unique cover graph cover entire graph 
intervals provide representation satis es abovementioned conditions loop interval nesting order provided derived sequence graphs 
zz zz 









intervals control flow graph interval hj header hj loop rooted hj back edge header node hj latching node nk hj 
consider graph graph intermediate instruction information intervals dotted lines 
intervals rooted basic block rooted node rooted node 
graph interval contains loop entirety interval contains header loop latching node interval 
intervals collapsed individual nodes intervals new graph loop intervals belong interval 
consider structuring algorithms derived sequence graphs 
graph loop nodes interval entirety 
loop represents corresponding loop nodes initial graph 
noted loops graphs initial graph reducible trivial graph derived process 
noted length derived sequence proportional maximum depth nested loops initial graph 







derived sequence graphs loop type loop pre tested post tested endless determined type header latching nodes 
nodes belong loop agged order prevent nodes belonging di erent loops loops 
methods explained sections assume procedures determine type loop mark nodes belong loop 
control ow graph interval information derived sequence graphs set intervals graphs algorithm nd loops follows header interval checked having backedge latching node belong interval 
happens loop type determined nodes belong marked 
intervals checked loops process repeated intervals checked 
potential loop header interval predecessor back edge header latching node marked belonging loop loop disregarded belongs unstructured loop 
loops generate goto jumps code generation 
algorithm goto jumps target labels determined 
complete algorithm 
algorithm nds loops appropriate nesting level innermost outermost loop 
finding nodes belong loop loop induced noted di erent loops part sample program satisfy condition loop fx yg control flow analysis procedure pre constructed 
determined 
post nodes belong loop marked 
loop header nodes information type loop latching node 
hj hm hj false loop hj true hj hj 
hj hj 
procedure loop structuring algorithm words loop formed nodes terms node numbering 
unfortunately simple determine nodes belong loop 
consider graphs loop abnormal exit di erent graph di erent type edge underlying 
seen loops forward edges back edges cross edges satisfy mentioned condition 
graph tree edge includes nodes nodes really part loop anumber nodes bound loop 
case extra condition needed satis ed nodes belong interval interval header dominates nodes interval loop loop header node dominates nodes loop 
node belongs di erent interval dominated loop header node belong loop 
words condition needs satis ed loop interval loop induced nodes belong loop satisfy conditions words node belongs loop induced belongs interval dominated order reverse postorder number greater header node lesser latching node node middle loop 
conditions simpli ed expression loop fx yg structuring algorithms 


mmmm 
tree edge cross edge forward edge back edge loops cases back edge loop back edge loops nodes loop nodes loop nodes belong interval nodes follows loop loop algorithm nds nodes belong loop induced back edge 
nodes marked setting loop head header loop 
note inner loop node marked means node belongs nested loop eld modi ed 
way nodes belong loop marked header node nested loop belong 
determining type loop type loop determined header latching nodes loop 
loop way header node determines loop executed way latching node transfers control back header node 
post tested loop characterized way latching node branches back header loop loop type header node 
endless loop way latching node transfers control back header node type header node 
types loops follows loop way latching node call header node loop post tested loop repeat loop 
loop way latching node way header node loop pre tested loop loop 
example repeat loop call header node problems saying loop really post tested loop 
problem arises control flow analysis procedure pre back edge 
post nodes belong loop marked 
fxg nodes fx yg fng procedure algorithm mark nodes belong loop induced header latching nodes way conditional nodes known branches header way node branch loop loop loop abnormal loop case post tested loop case 
necessary check nodes branches header node belong loop loop coded loop abnormal exit latching node 
gives algorithm determine type loop set constructed algorithm 
finding loop follow node loop follow node rst node reached loop terminated 
case natural loops node reached loop termination case multilevel exit loops exit node reached loop 
structuring algorithm structured natural loops loops structured real exit abnormal exits 
case endless loops exits middle loop nodes reached di erent exits 
purpose algorithm nd follow node 
pre tested loop follow node successor loop header belong loop 
similar way follow node post tested loop successor loop latching node belong loop 
endless loops follow nodes initially header latching node jump loop 
endless loop jump loop middle loop break follow node 
follow node rst node reached loop ended desirable nd closest node reached loop structuring algorithms procedure pre induces loop 
set nodes belong loop 
post type loop induced 
nodetype way nodetype post tested 
pre tested 
post tested 
way latching node nodetype way 
endless 
procedure algorithm determine type loop exit performed 
closest node smallest reverse postorder numbering closest loop numbering order 
node reached loop reached closest node greater reverse postorder numbering closest node considered follow node endless loop 
example loops follow nodes follow loop follow loop gives algorithm determine follow node loop induced set determined algorithm 
structuring way conditionals single branch conditional conditional subgraph common node onwards referred follow node property immediately dominated way header node 
control flow analysis procedure pre induces loop 
set nodes belong loop 
post follow node loop induced 
pre tested outedges outedges 
outedges 
post tested outedges outedges 
outedges 
endless loop fol max large constant way nodes outedges outedges fol fol outedges 
outedges outedges fol fol outedges 
fol max fol 
procedure algorithm determine follow subgraphs nested di erent follow nodes share common follow node 
consider graph graph intermediate instruction information immediate dominator information 
nodes numbered reverse postorder 
graph way nodes nodes 
seen loop structuring section way node belongs header latching node loop marked processed way conditional structuring belongs structure 
nodes considered analysis 
conditionals nested desirable analyze nested conditional rst outer ones 
case conditionals nodes node structuring algorithms 
hj nn node immediate dominator control flow graph immediate dominator information analyzed rst node nested subgraph headed words node greater reverse postorder numbering needs analyzed rst visited rst depth rst search traversal 
example subgraphs share common follow node node immediately dominated node inner conditional immediately dominated outer conditional node follow node conditionals 
follow node determined type conditional known checking branches way header node follow node case subgraph single branching conditional 
case nodes node analyzed rst follow node determined node takes immediate dominator 
node left list unresolved nodes nested conditional structure 
node analyzed nodes possible candidates follow node nodes reach node node taken follow node encloses number nodes subgraph largest node 
node list unresolved follow nodes marked having follow node 
seen graph conditionals properly nested goto jump code generation 
generalization example provides algorithm structure conditionals 
idea algorithm determine nodes header nodes conditionals nodes follow conditionals 
type conditional determined nding follow branches header node equivalent follow node 
inner conditionals traversed rst outer ones control flow analysis descending reverse postorder traversal performed greater smaller node number 
set unresolved conditional follow nodes kept process 
set holds way header nodes follow 
way node part header latching node loop follow node calculated node takes immediate dominator edges reached di erent paths header 
node encloses maximum number nodes selected largest number 
node way header node placed unresolved set 
follow node nodes belong set unresolved nodes set follow node just nested conditionals unstructured conditionals reach node 
complete algorithm shown 
procedure struct way pre graph 
post way conditionals marked follow node way conditionals determined 
unresolved fg nodes descending order nodetype way false follow unresolved follow unresolved unresolved fxg unresolved unresolved fmg procedure compound conditions way conditional structuring algorithm structuring graphs decompilation structure underlying constructs considered underlying intermediate instructions information 
high level languages allow short circuit evaluation compound boolean conditions conditions include 
languages generated control ow graphs conditional expressions unstructured exit performed soon conditions determined expression true false 
example expression compiled short circuit structuring algorithms evaluation expression false expression false expression evaluated 
similar way anx partially evaluated expression true 
shows di erent subgraph sets arise compound conditions 
top graphs represent logical condition consideration bottom graphs represent short circuit evaluated graphs compound condition 
aau 
jj 
sw sw 
sw ssw ne compound conditional graphs sw ny 
decompilation subgraph form short circuit evaluated graphs checked properties 
nodes way nodes 

node edge 

node unique instruction conditional jump jcond high level instruction 

nodes branch common node 
rst second fourth properties required order isomorphic subgraph bottom graphs third property required determine graph represents compound condition abnormal conditional graph 
consider subgraph intermediate instruction information 
nodes way nodes node edge node unique instruction jcond true branch node false branch reach node subgraph form 
control flow analysis jcond loc loc jcond loc loc loc loc loc loc loc printf loc loc ret aaa subgraph intermediate instruction information algorithm structure compound conditionals traversal top bottom graph rst condition compound conditional expression higher graph tested rst 
way nodes nodes checked way condition 
nodes represents high level conditional instruction jcond node entries edge node comes header way node node forms subgraphs illustrated nodes merged unique node equivalent semantic meaning compound condition depends structure subgraph node removed graph 
process repeated compound conditions compound ands process repeated header node conditionals 
nal algorithm shown 
structuring way conditionals way conditionals structured similar way way conditionals 
nodes traversed bottom top graph order nd nested way conditionals rst followed outer ones 
way node follow node determined 
node optimally edges coming successor nodes way header node immediately dominated header node 
determination follow node unstructured way conditional subgraph modi ed properties abovementioned follow node 
consider unstructured graph abnormal exit way conditional subgraph 
candidate follow nodes nodes header node immediate dominator successors node nodes candidate follow nodes 
node edges come paths header node node edges paths header node 
node paths header node reach node considered follow complete subgraph 
structuring algorithms procedure pre graph 
way way loops structured post compound conditionals structured change true change change false nodes postorder nodetype way succ succ nodetype way succ change true succ change true nodetype way succ change true succ change true procedure compound condition structuring algorithm unfortunately abnormal entries way subgraph covered method 
consider graph abnormal entry branches header way node 
case node takes node immediate dominator due abnormal entry way header node 
words follow immediate dominator common dominator edges node node 
case node performs abnormal entry subgraph needs determined order nd follow node takes immediate dominator 
complete algorithm shown 
control flow analysis 
zz 
zz node immediate dominator unstructured way subgraph abnormal exit 
zz node immediate dominator zz 
unstructured way subgraph abnormal entry application order structuring algorithms previous sections determine entry exit header follow nodes subgraphs represent high level loops way way structures 
algorithms applied random order form nite church rosser system 
consider graphs due abnormal entries exits loop subgraphs 
graph abnormal exit way subgraph complete graph belongs loop 
graph ought tobe structured loops rst back edge leading loop 
structuring way conditionals node header node way subgraph nodes subgraph rooted belong loop determined subgraph structured way subgraph abnormal exits loop 
hand graph ought structured way subgraphs rst subgraph structured way subgraph follow node 
applying loop algorithm nodes back edge belong di erent structures node belongs structure headed node node belong structure far abnormal exit structure exists loop structured 
case graph graph irreducible graph rst structuring loops structuring algorithms procedure pre graph 
post way conditionals structured follow node determined way subgraphs 
unresolved fg nodes postorder nodetype way succ fs succ follow unresolved follow unresolved unresolved fig unresolved unresolved fmg procedure way conditional structuring algorithm loop abnormal exits coming nodes way subgraph structured due abnormal exits 
hand graph structured way subgraph rst loop structured goto jump 
examples illustrate series structuring algorithms previous sections nite church rosser 
implies ordering followed structure way conditionals followed loop structuring way conditional structuring 
loops structured rst way conditionals ensure boolean condition form part pre tested post tested loops part loop header way conditional subgraph 
way conditional marked header latching node loop considered structuring 
control flow analysis zz zz case irreducible graphs zz zz unstructured graph examples far chapter deal reducible graphs 
recall section graph irreducible contains subgraph form canonical irreducible 
essence graph irreducible entries loop entries dominated common node common node dominates entrance nodes loop 
consider graphs 
graphs represent di erent classes graphs underlying edges depth rst tree graph 
seen graphs tree edge cross edge forward edge irreducible graph back edge coming loop irreducible common node dominates entries loop 
loop equivalent loop way loop back edge loop graph 
mm 


tree edge cross edge forward edge loops cases 

back edge back edge loop back edge structuring algorithms purpose decompiler structuring algorithm modify semantics functionality control ow graph node splitting structure irreducible graphs addition new nodes modi es semantics program 
desired structure graph node replication leave graph irreducible graph goto jumps 
consider graph immediate dominator information 
graph irreducible loop contained entirely interval loop structuring algorithm determines natural loops 
structuring way conditionals conditional node determined follow node node reached paths header node greater numbering node 
means graph structured way subgraph follow node natural loop 
code generation goto jumps simulate loop see chapter section 
mf 
node immediate dominator canonical irreducible graph immediate dominator information chapter back high level intermediate code generated data ow analyzer structured control ow graph generated control ow analyzer input back 
module composed code generator generates code target high level language 
relationship shown 
high level intermediate code udm structured control ow graph yh front code generator code generation symbol table relation code generator udm hll program code generator generates code prede ned target high level language 
examples language target language examples sample control ow graph chapter structuring information summarized graph 
generating code basic block data ow analysis intermediate instructions basic block high level instructions pseudo high level instructions eliminated code point 
consider control ow graph data control ow analyses 
basic block instructions basic block mapped equivalent instruction target language 
transfer control instructions jcond jmp instructions dependent structure graph belong loop conditional jump ways equivalent code generated control ow information described section section 
section illustrates code generated instructions basic block 
back asgn loc asgn loc loc jcond loc loc asgn loc loc loc jcond loc loc asgn loc loc jcond loc loc loc loc asgn loc loc loc asgn loc loc call printf loc loc ret asgn loc jcond loc asgn loc loc asgn loc loc jcond loc asgn loc loc call printf loc loc asgn loc loc sample control flow graph data control flow analyses generating code asgn instructions asgn instruction assigns identi er arithmetic expression identi er 
expressions stored decompiler syntax trees tree walker generate code 
consider rst instruction basic block asgn loc left hand side local identi er loc right hand side constant identi er 
expressions identi ers code trivially translated loc rst instruction basic block uses expression right hand side asgn loc loc loc instruction represented syntax tree right hand side instruction stored syntax tree format eld arg intermediate triplet see chapter 
tree right hand side equivalent expression loc loc code instruction loc loc loc code generation loc hhh loc loc syntax tree instruction generating code syntax tree solved recursive way type operator binary unary 
binary operators left branch tree traversed followed operator traversal right branch 
unary operators operator rst displayed followed subtree expression 
cases recursion ends identi er met leaves tree 
example expressions de ned intermediate language types expressions binary expressions expressions binary operator 
binary operators counterparts equal 

equal 
equal 
greater 
greater equal 
bitwise 
bitwise 
bitwise xor 
complement 
add 
subtract 
multiply 
divide 
modulus 
shift right 
shift left 
compound 
compound 
back unary expressions expression unary operator 
unary operators counterparts expression negation 
address 
dereference 
post pre increment 
post pre decrement 
identi ers identi er minimum type expression 
identi ers classi ed location memory registers way global variable 
local variable negative sets stack frame 
formal parameter positive set stack frame 
constant 
register 
function function name actual argument list 
algorithm generates code expression uses operator types walking tree recursively 
procedure expression pre points expression tree syntax tree 
post code expression tree pointed written 
case boolean write lhs rhs 
unary write exp 
identi er write identi 
case procedure algorithm generate code expression tree identi function returns name identi er identi er node name taken appropriate symbol table global local argument 
identi er register register uniquely named generating new local variable sequence local variables 
new variable placed subroutine local variables de nition 
code generation generating code call instructions call instruction invokes procedure list actual arguments 
list stored arg eld sequential list expressions arithmetic expressions identi ers 
name procedure displayed followed actual arguments displayed tree walker algorithm 
generating code ret instructions ret instruction returns expression identi er function 
return instruction take arguments procedure nished statement 
return expression optional 
complete algorithm generate code basic block excluding transfer instructions shown 
algorithm function indent function returns spaces depending indentation level spaces indentation level 
procedure bb integer pre bb basic block 
indentation level basic block 
post code instructions transfer instructions displayed 
high level instructions bb case asgn write indent lhs rhs 
call fa 
actual arguments append fa 
write indent fa 
ret write indent exp 
case procedure algorithm generate code basic block generating code control flow graphs information collected control ow analysis graph code generation determine order code generated graph 
consider graph structuring information 
graph graph intermediate instruction information nodes numbered reverse postorder 
generation code graph viewed problem generating code root node recursing successor nodes belong structure rooted root back 
hj node pre test post test iffollow control flow graph structuring information node continue code generation follow node structure 
recall chapter follow node rst node reached structure rst node executed structure nished 
follow nodes loops way way conditionals calculated control ow analysis phase 
transfer control nodes way fall call transfer control unique successor node follow successor termination nodes return leaves underlying depth rst search tree graph terminate generation code path 
section describes component algorithms algorithm generate code procedure 
explanation easier assume routine exists concentrate generation code particular structure routine generate code components structure 
algorithms explained algorithm 
generating code loops subgraph rooted loop header node code loop generated type loop 
regardless type loop loops structure loop header loop body loop trailer 
loop header trailer generated depending type loop loop body generated generating code subgraph rooted rst node loop body 
consider loops graph 
loop rooted node pre tested loop loop rooted node post tested loop 
code generation case pre tested loop loop condition true jcond boolean conditional node loop body executed 
branch loop false branch loop condition negated loop executed condition false 
loop body generated routine loop trailer consists loop bracket 
code generated code loop follow node generated invoking routine 
skeleton write loc indent iffollow nfollow write indent latchnode iffollow nfollow rst instruction generates code loop header second instruction generates code loop body rooted node having latching node third instruction generates code loop trailer fourth instruction generates code rest graph rooted node 
post tested loop loop condition true branch loop header node 
skeleton write indent iffollow nfollow write loc indent latchnode iffollow nfollow rst instruction generates code loop header second instruction generates code instruction root node third instruction generates code loop body rooted node ended loop latching node fourth instruction generates loop trailer fth instruction generates code remainder graph rooted node 
code generated similar way endless loops distinction may loop follow node 
normally pre tested loop header nodes instruction associated languages allow logical instructions coded physical instruction instructions header node form part loop condition 
example loop printf greater statement purposes add variable check assignment greater 
choice intermediate code allows instruction stored intermediate instruction assignment comparison form part di erent instructions shown intermediate code back asgn jcond call printf greater asgn jmp code solutions considered case preserve loop structure repeating extra instructions header basic block loop transform loop endless loop breaks loop boolean condition associated false 
example case leads code printf greater case leads code break printf greater approach generates correct code graph method replicates code normally instructions preserves structure method replicate code modi es structure original loop 
thesis method preference solution provides code easier understand solution 
generating code loop body loop follow node target node traversed code generator means node reached path goto label needs generated transfer control target code 
algorithm generates code graph rooted loop header node 
algorithm generates code assumes existence function returns inverse expression negates expression procedure generates unique label generates goto label places label appropriate position nal code 
code generation procedure bb latchnode iffollow nfollow integer pre bb pointer header basic block loop 
indentation level basic block 
latchnode number latching node enclosing loop 
iffollow number follow node enclosing structure 
nfollow number follow node enclosing way structure 
post code graph rooted bb generated 
bb true 
case bb write loop header pre tested bb 
succ bb bb write indent bb 
write indent bb 
post tested write indent 
bb 
endless write indent 
bb 
case nodetype bb return bb latchnode return 
latchnode bb bb loop basic blocks successors bb bb pre tested bb bb false latchnode bb iffollow nfollow 
traversed 
case bb write loop trailer pre tested bb 
write indent 
post tested write indent bb 
endless write indent 
case bb false continue follow bb latchnode iffollow nfollow 
bb 
procedure algorithm generate code loop header rooted graph back generating code way rooted graphs graph rooted way node form part loop conditional expression code graph generated determining node header condition 
case code generated condition followed code clause code follow subgraph 
case code generated condition followed clauses code follow node 
consider way nodes form part loop expressions nodes 
node root structure follow node node immediate successors node 
immediate successor node body clause condition node false condition needs negated code write loc loc indent latchnode nfollow write indent latchnode iffollow nfollow rst instruction generates code negated condition second instruction generates code clause subgraph rooted node follow node third instruction generates trailer instruction generates code follow subgraph rooted node 
node root structure 
case immediate successors header node equivalent follow node 
true branch reached condition true false branch reached condition false leading code write loc loc indent latchnode nfollow write indent latchnode nfollow write indent rst instruction generates code condition second instruction generates code clause third instruction generates fourth instruction generates code clause instruction generates trailer 
code follow node generated case conditional nested conditional takes follow node 
easily checked iffollow parameter speci enclosing code node generated 
similar way code generated subgraph rooted node 
case true branch leads follow node boolean condition associated negated false branch clause 
skeletal code code generation write loc loc loc loc indent latchnode nfollow write indent latchnode iffollow nfollow loops goto jumps generated certain nodes graph visited current subgraph visits 
case way node visited goto branch es generated 
way rooted subgraph follow node means branches graph lead common node branches ended return node met met 
case code generated branches path ensure recursion ended 
algorithm generates code graph rooted way node form part loop boolean expression 
generating code way rooted graphs graph rooted way node code graph generated way way header code emitted switch successor header node way option emitted case followed generation code subgraph rooted successor ended way follow node 
code successors generated way trailer generated code generated rest graph generating code graph rooted follow way header node 
generating code branches follow node way structure target node traversed goto jump generated transfer control code associated node 
algorithm generates code graph rooted way node 
generating code way fall call rooted graphs graph rooted way fall call node code basic block generated followed unique successor node 
call nodes successors successor edges points subroutine invoked instruction code generated subroutine time basis branch disregarded code generation purposes node thought unique successor 
algorithm generates code nodes unique successor node 
code generated unique follow node means graph reached path goto jump generated transfer control code associated subgraph 
complete algorithm nal algorithm generate code subroutine graph shown 
procedure takes arguments pointer basic block indentation level latching node enclosing loop follow enclosing way way conditionals 
initially basic block pointer points start subroutine graph indentation level latching back procedure write way bb latchnode iffollow nfollow integer pre bb way basic block 
indentation level 
latchnode latching node enclosing loop 
iffollow follow node enclosing way structure 
nfollow number follow node enclosing way structure 
post code tree rooted bb generated 
iffollow bb max false 
succ bb false process clause succ bb iffollow bb write sif indent bb 
succ bb latchnode iffollow bb nfollow 
empty clause negate clause write sif indent bb 
succ bb latchnode iffollow bb nfollow 
true 
succ bb 
succ bb false process clause succ bb iffollow bb write indent indent 
succ bb latchnode iffollow bb nfollow 
false write indent indent 
succ bb 
write indent 
iffollow bb false iffollow bb latchnode iffollow nfollow 
follow emit write sif indent bb 
succ bb latchnode iffollow nfollow 
write indent indent 
succ bb latchnode iffollow nfollow 
write indent 
procedure algorithm generate code way rooted graph code generation procedure bb latchnode iffollow nfollow integer pre bb way basic block 
indentation level 
latchnode number enclosing loop latching node 
iffollow number enclosing terminating node 
nfollow number enclosing way terminating node 
post code generated graph rooted bb 
write switch indent bb 
successors bb generate code branch false write case indent index 
latchnode iffollow bb 
write break indent 

bb false generate code follow node bb latchnode iffollow nfollow 
bb 
procedure algorithm generate code way rooted graph follow nodes check values set predetermined value 
follow node met code generated path procedure returns invoking procedure able handle code generation follow node 
done trailer conditional generated code follows conditional 
case loops latching node node generated path recursion ended invoked procedure handles loop trailer code generation continuation follow loop 
procedure order code generated determined call graph program 
generate code nested procedures rst followed ones invoke depth rst search ordering call graph followed marking subroutine graph traversed considered code generation 
code subroutine written generating code header subroutine followed local variables de nition body subroutine 
algorithm shows ordering generation code subroutine 
function algorithm determine subroutine library code generated library routines detected signature method chapter 
procedure writes information collected analysis back procedure write way bb latchnode iffollow nfollow integer pre bb pointer way call fall basic block 
indentation level basic block 
latchnode number latching node enclosing loop 
iffollow number follow node enclosing way structure 
nfollow number follow node enclosing way structure 
post code graph rooted bb generated 
bb 
succ bb false succ bb latchnode iffollow nfollow 
succ bb 
procedure algorithm generate code way call fall rooted graphs procedure bb latchnode iffollow nfollow integer pre bb pointer basic block 
initially points head graph 
indentation level basic block 
latchnode number latching node enclosing loop 
iffollow number follow node enclosing way structure 
nfollow number follow node enclosing way structure 
post code graph rooted bb generated 
bb iffollow nfollow bb true return 
bb true 
bb loops bb latchnode iffollow 
nodes case nodetype bb way write way bb latchnode iffollow nfollow 
way bb latchnode iffollow nfollow 
default write way bb latchnode iffollow nfollow 
case procedure algorithm generate code control flow graph code generation subroutine type arguments stack arguments register arguments high level prologue detected subroutine number arguments subroutine takes subroutine generates irreducible graph 
procedure procedure pre procedure pointer initially start node call graph 
post code written program rooted depth rst fashion 
return 
true 
successors succ dfs successors 
generate code procedure generate subroutine header write 
write void 

generate subroutine comments local variables local variable de nitions write 
generate code subroutine max max max 
low level subroutine generate assembler disassemble 
write 
procedure algorithm generate code call graph algorithms described section code generated graph 
local variables uniquely named sequential order starting making pre loc local 
back void main takes parameters 
high level language prologue code 
int loc int loc int loc int loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf loc loc final code graph case irreducible graphs pointed chapter section loops irreducible graphs structured natural loops nodes loop form part complete interval 
consider canonical irreducible ow graph structuring information 
code generation 
node iffollow canonical irreducible graph structuring information code generation code node generated rst true branch leads follow node false branch clause negating boolean condition associated node 
code clause generated followed code generated node 
node transfers control node visited code generation goto jump generated associated code node 
goto simulates loop provides unstructured structure transferring control clause 
skeletal code graph follows 
goto numbers represent basic blocks code basic block generated procedure 
chapter decompilation tools decompiler tools series programs help decompiler generate target high level language programs 
binary le loader determines binary image starts relocation information le 
binary image loaded memory possibly relocated disassembler parse binary image produce assembler form program 
parsing process bene compiler library signature recognizer determines subroutine library subroutine set prede ned signatures generated program 
way original code written user disassembled decompiled 
disassembler considered part decompiler parses binary image phase front module 
program parsed decompiled methods chapters generating target high level program 
program improve quality high level code 
shows di erent stages involved decompilation system 
relocatable machine code loader absolute machine code disassembler assembler program decompiler hll program postprocessor hll program xxxx libraries signature generator library signatures compiler signatures library bindings decompilation system library headers prototype generator library prototypes decompilation tools loader loader operating system program loads executable binary program memory su cient free memory program loaded run 
binary programs contain information amount memory required run program relocation addresses initial segment register values 
program loaded memory loader transfers control binary program setting code instruction segments 
structure binary programs di ers operating system loading program dependent operating system machine binary program runs 
simplest form binary programs contains binary image program fully linked image program loaded memory changes binary image 
com les dos operating system binary structure 
binary programs contain binary image header information determine type binary program di erent types executable programs operating system di erent operating systems run machine initial register values relocation table holds word sets start binary image need relocated address program loaded memory 
type binary le exe les dos windows 
general format binary program shown 
header relocation table binary image general format binary program algorithm load program memory follows type binary le determined systems allow di erent types binary les le binary image size memory allocated size le block memory size le allocated le loaded block memory modi cations default segment registers set 
case binary les header relocation table information header read determine memory needed load program relocation table get information set registers 
memory block size header allocated binary image le loaded memory block elements relocation table relocated memory segment registers set information header 
algorithm shown 
signature generator procedure loader name pre name name binary le 
post binary program name loaded memory 
determine type binary program 
binary image size binary le 
allocate free block memory size load le allocated memory block prede ned set 
setup default segment registers 
read header information 
size binary image header information 
allocate free block memory size load binary image allocated memory block 
relocate items relocation table memory 
setup segment registers information header 
procedure signature generator loader algorithm signature generator program automatically generates signatures input le 
signature binary pattern recognize viruses compilers library subroutines 
aim signatures decompilation undo process performed linker determine subroutines libraries compiler start code replace name case eliminate target output code case 
case operating systems share libraries bind library subroutine object code program binary image 
information subroutine name arguments stored binary program method distinguish user written subroutines impossible di erentiate subroutines 
case operating systems share library subroutines subroutine form part binary program subroutine program subroutine name stored part binary le header section 
methods section targetted operating systems share library subroutines include binary program 
signature le generated set library subroutines interface procedure called check particular subroutine parsed decompiler disassembler library signatures 
subroutine matched signatures subroutine replaced name name subroutine library marked needing analysis 
way decompilation tools number subroutines analyzed reduced better quality target high level program improved considerably subroutine calls real library names arbitrary names 
library subroutines written assembler performance reasons due low level machine accesses routines high level representation cases disassembled opposed decompiled library signature recognition method eliminates need analyze type subroutines producing better target code 
ideas section sections developed michael van emmerik working queensland university technology 
ideas expressed 
reproduced permission author 
library subroutine signatures standard library le relocatable object le implements di erent subroutines available particular language compiler 
library subroutine signature binary pattern uniquely identi es subroutine library subroutine library 
subroutines perform di erent functions signature contains complete binary pattern subroutine uniquely identify subroutine subroutine 
main problem approach size signature overhead created size 
ideal check minimum number bytes subroutine signature small possible 
great number subroutines library hard realize subroutines need bytes signature uniquely identify greater complete size small subroutines small subroutines remaining bytes need padded predetermined value order avoid running bytes belong library subroutine 
example library function cos bytes cos followed library function strcpy bytes cos form part signature bytes padded predetermined value bytes part strcpy 
rst bytes subroutine machine instructions operands determined constants sets depend address module loaded considered variant bytes di erent value library le binary program contains subroutine 
necessary wildcard variant byte locations order generate address independent signature 
consider code library routine 
call instruction set subroutine called 
called subroutines linked position set address variant 
mov instruction takes arguments constant set operand known location invariant constant 
choice wildcard value dependent assembler 
candidate hardly machine example opcode byte assembler machine 
similar considerations done padding bytes signature small 
example 
signature generator push bp bec mov bp sp push si mov si bp push si call destination pop cx bc ax ax jz mov ax operand eb jmp padding partial disassembly library function noted example function bytes image signature cut bytes due unconditional jump instruction 
done unknown bytes follow unconditional jump form part library subroutine 
general return un conditional jump met subroutine considered nished purposes library signatures remaining bytes padded 
nal signature example 
noted method small probability error di erent subroutines may starting code rst un conditional transfer control 
bec bc eb signature library function algorithm automatically generate library subroutine signatures shown 
algorithm takes arguments standard library le name output signature le size signature bytes experimentally advance 
di erent library les provided compiler vendor machines di erent memory models di erent signature le needs generated memory model 
ideal naming convention determine compiler vendor memory model signature library eliminating need extra header information saved signature le 
decompilation tools procedure lib le integer pre lib standard library le 
name output library signature le 
size signature bytes 
post le created contains library subroutine signatures 
openfile 
subroutines lib consecutive bytes sign rst bytes nbytes sign rst bytes sign 
variant bytes sign sign 
write name sign le 

procedure signature algorithm integration library signatures decompiler entry point subroutine parser instructions paths entry point 
known particular compiler compile source binary program currently analyzed parser check subroutine belongs library particular compiler 
code need parsed known subroutine invoked name subroutine 
due large number subroutines library linear search isvery ine cient checking possible signatures le 
hashing technique case better perfect hashing signatures unique subroutine library xed size 
perfect hashing information stored header library signature le parser needing determine subroutine belongs library 
compiler signature order determine library signature le binary program compiler compile original user program needs determined 
di erent binary patterns compiler start code di erent compiler vendors signature generator patterns manually examined stored signature uses wildcards way done library subroutine signatures 
di erent memory models provide di erent compiler signatures compiler di erent versions compiler di erent signatures di erent signature compiler vendor memory model compiler version stored 
naming scheme di erentiate di erent compiler signatures 
determining main program entry point loader entry compiler start code dozen subroutines set environment invoking main subroutine program main program modula program 
main entry point program compiled prede ned compiler determined manual examination start code 
compilers parameters main function argv argc pushed main function invoked hard determine main entry point 
compilers provide source code start code interest interoperability detection main entry point done way 
known determine main entry point method stored compiler signature le particular compiler 
integration compiler signatures decompiler parser analyzes instructions entry point loader interface procedure invoked check di erent compiler signatures 
procedure determines rst bytes loaded program equivalent known compiler signature compiler vendor compiler version memory model determined stored global structure 
done main entry point determined signature entry point treated starting point parser 
onwards subroutines called program checked library signature le appropriate compiler vendor compiler version memory model 
manual generation signatures automatic generation signatures ideal problem nding unique binary pattern uniquely identi es di erent subroutines library 
experimental results shown number repeated signatures standard library le varies low high 
repeated signatures due functions di erent names implementation due unconditional jumps bytes force signature cut short early 
manual method generation signatures described fz decompiling system 
library le microsoft version analyzed manual inspection function information stored function function name binary pattern complete function including variant bytes matching method determine arbitrary subroutine matches 
matching method series instructions determines xed bytes information starting set binary pattern function decompilation tools subroutines called function 
operand determined set constant bytes skipped compared bytes binary pattern variant bytes subroutine called set address subroutine tested call routine performed turn matched patterns signature 
way paths subroutine followed checked signature 
disadvantage manual generation signatures time involved generating typically library subroutines numbers increase object oriented languages 
manual generation signatures library take days week large library les 
new version compiler available signatures manually time overhead great 
automatic signature generator reduces amount time generate signatures complete library seconds minute inconvenience signatures percentage functions 
repeated functions manually checked unique signatures generated necessary 
library prototype generator library prototype generator program automatically generates information prototypes library subroutines type arguments subroutine type return value functions 
determining prototype information library subroutines helps decompiler check right type number arguments propagate type information wrongly considered type due lack information analysis 
consider code mov ax push ax call printf data ow analysis code transformed code extended register copy propagation call printf knowing type arguments printf takes constant argument considered right argument function call 
prototype information exists function function formal argument list xed pointer character string argument variable number parameters unknown type 
constant determined set data segment constant replaced set 
method provides decompiler improved code printf hello world disassembly version program improved mov ax offset push ax call printf disassembler set data segment points null terminated string 
useful decompiler library prototypes 
library signatures need library prototype le high level language standard functions language prototypes 
compiler dependent libraries require extra prototype les 
languages modula advantage header les de ne library prototypes 
prototypes easily parsed program stored le predetermined format 
languages store library prototype information libraries special parser required read les 
comment runtime support routines compiler runtime support routines subroutines compiler perform particular task 
subroutines stored library le function prototypes available user header le library compiler follow high level calling conventions 
runtime subroutines register arguments return result registers 
prototype available subroutines interest decompiler analyze order determine register argument return register 
runtime support routines distinguished library routine checking library prototypes subroutine forms part library prototype runtime routine 
routines name type argument return value unknown 
decompilation subroutines analyzed name library le name subroutine 
register arguments mapped formal arguments 
integration library prototypes decompiler type compiler compile original source program determined means compiler signatures type language compile program known appropriate library prototype le determine information library subroutines program 
parsing program subroutine determined subroutines library signature le prototype le language accessed information subroutine name stored subroutine summary information record 
process provides data ow analyzer complete certainty types arguments library subroutines types back propagated caller subroutines di erent ones prototype 
subroutine return type de ned means subroutine really function treated 
disassembler disassembler program converts source binary program target assembler program 
assembly code uses mnemonics represent machine opcodes decompilation tools machine opcodes mapped assembly mnemonic machine instructions add operands mapped add mnemonic 
disassemblers tools modify existing binary les source available clarify undocumented code recreate lost source code nd program works flu com 
years disassemblers debugging tools process determining existence virus code binary le disassembly virus selective disassembly techniques detect potential malicious code gar 
disassembler composed phases parsing binary program generation assembler code 
phase identical parsing phase decompiler see chapter section code generator produces assembler code internal representation binary program 
symbol table information stored order declare strings constants data segment 
public domain dos disassemblers zan gd cal mak sof chr perform pass binary image constructing control ow graph program 
cases parsing errors introduced assumptions memory locations considering code represent data 
disassemblers di erent dos interrupts able disassemble binary les blocks memory system les 
commercial disassemblers com perform passes binary image re ning symbol table pass assuring better distinction data code 
internal simulator resolve indexed jumps calls keeping track register contents 
cross information collected disassembler 
decompilation disassembler considered part decompiler adding extra assembler code generator phase tool generate assembler program taken source input program decompiler initial 
language independent bindings decompiler generates code particular target language written 
binary programs decompiled aid compiler library signatures produce target language programs names library routines de ned library signature le 
language binary program originally written di erent target language decompiler target program re compiled language uses library routines de ned language compiler 
consider fragment decompiled code hello pascal crlf statements invoke pascal library routines implement original pascal statement writeln hello pascal rst routine displays string second performs carriage return line feed 
words writeln library postprocessor binary program syntax analyzer semantic analyzer intermediate code generator control flow graph generator data flow analysis control flow analysis code generator hll program assembler code generator assembler program disassembler part decompiler routine pascal libraries call replaced calls crlf 
decompiled code correct target language re compiled crlf belong library routines 
previous problem solved pascal bindings libraries 
way generating previous statements call printf follows printf hello pascal iso committee sc group concerned creation standards language independent access service facilities 
de ne language independent bindings languages modula 
information library bindings placed le code generator decompiler produce target code uses target language library routines 
postprocessor quality target high level language program generated decompiler improved postprocessor phase replaces generic control structures structures 
language speci structures considered structuring analysis chapter constructs general languages 
loop implemented loop checks terminating condition 
induction variable initialized loop updated time decompilation tools loop statement 
consider code decompilation loc loc loc printf loc loc loc loop statement checks local variable loc constant 
variable initialized statement updated statement loop statement variable induction variable loop replaced loop leading code loc loc loc loc loc printf loc eliminates instructions replacing instruction 
pre post increment instructions previous code improved loc loc loc loc printf loc break statement terminates execution current loop branching control rst instruction follows loop 
consider code decompilation loc loc printf loc loc goto loc loc postprocessor instruction checks local variable loc equal goto jump executed transfers control label rst instruction loop 
transfer control equivalent removes need label goto 
loop transformed loop leading code loc loc loc printf loc loc break similar way continue statements code 
target language ada labelled loops allowed 
structured decompiler loops goto jump exits loop 
target statements goto jumps checked enclosing loop labels replaced appropriate exit statement 
general language speci construct represented generic set constructs structuring algorithm chapter section constructs replaced postprocessor strictly necessary constructs functionally equivalent 
chapter dcc cc prototype decompiler written dos operating system 
dcc initially developed decstation running ultrix ported pc architecture dos 
dcc takes input exe com les intel architecture produces target assembler programs 
decompiler built techniques described thesis chapters composed phases shown 
seen decompiler built loader disassembler postprocessing phase 
sections describe speci aspects dcc series decompiled programs section 
compiler signatures library signatures library prototypes binary program loader parser intermediate code generator control ow graph generator semantic analyzer data ow analyzer control ow analyzer code generator program assembler code generation assembler program structure dcc decompiler dcc main decompiler program shown major modules identi ed reads user options command line argv places global program options variable loader reads binary program loads memory frontend parses program building call graph udm analyses control data ow program backend generates code di erent routines call graph 
int main int argc char argv char filename binary file name call graph callgraph pointer program call graph filename argc argv read exe com file load memory loader filename parse program generate icode building call graph frontend filename callgraph universal decompiling machine process icode call graph udm callgraph generates subroutine call graph backend filename callgraph main decompiler program dos operating system uses segmented machine representation 
compilers written architecture di erent memory models tiny small medium compact large huge 
memory models derived choice bit pointers code data 
appendix provides information architecture appendix provides information psp 
chapter assumes architecture 
decompiler options dcc executed command line specifying binary le decompiled 
example decompile le test exe command entered dcc test exe command produces test le target le 
options available user get information program 
options loader produces assembler le parsing graph optimization 
produces assembler le graph optimization 
filename uses filename name output assembler le 
produces memory map program 
produces statistics number basic blocks optimization subroutine control ow graph 
verbose option displays information loaded program default register values image size basic blocks subroutine graph de ned registers instruction livein liveout de ned register sets basic block 
option displays information displayed option plus information program relocation table basic blocks control ow graph subroutine graph optimization derived sequence graphs subroutine 
text user interface dcc 
interface written michael van emmerik library 
allows user step program including subroutine calls 
right arrow follow jumps subroutine calls left arrow step back right arrow arrows move line time page page scroll page ctrl exit interactive interface 
loader dos loader operating system program called exec 
exec checks su cient available memory load program allocates block builds psp base reads program allocated memory block psp sets segment registers stack transfers control program dun 
decompiler needs control program exec program loader performs similar task written 
exe programs program header checked amount memory required location relocation table size image bytes dynamically allocated program loaded memory relocated 
com programs amount memory required calculated size le memory dynamically allocated program loaded memory format les appendix memory represented dcc array large array dynamically allocated size program image determined 
historical reasons com programs loaded set 
loader stores information relating program prog record de ned 
record stores information binary le memory map address segment set dcc program loaded address xed dependent binary program 
typedef struct int initial cs register value int initial ip register value int initial ss register value int initial sp register value flag set com program exe int relocation table entries dword pointer relocation table int number subroutines int offset main proc word segment main proc true library signatures loaded int length image bytes byte image entire program image byte map memory bitmap pointer prog program information record compiler library signatures dos operating system provide method share libraries library routines bound program image 
compiler library signatures generated compilers due reason section explains dcc 
automatic signature generator written generate library signatures standard lib les described chapter section 
length signature set bytes proved reasonable size experimental results 
wildcard byte opcode halt opcode rarely padding byte set 
library signatures generated compilers microsoft microsoft visual turbo borland 
separate library signature le triplet compiler vendor memory model compiler version 
signatures generated seconds 
automatic signature generation repeated signatures detected 
numbers varied low turbo high microsoft visual 
case routines repeated signatures 
mainly due identical representation routines di erent names 
signatures identical similar functions toupper 
case unrelated functions signature functions brk atoi 
case routines signature 
duplicates due internal front public names user 
signatures di erent names routines especially due naming convention di erent memory models routine works di erent memory models 
pascal compilers standard library les 
case borland pascal compilers library information stored tpl le information library routines prototypes 
modi ed signature generator written tpl les signatures generated turbo pascal version 
average library signature les occupy kb disk space moderate amount library routines information stored 
compiler signatures compilers generated manually stored part dcc 
signatures checked parser rst invoked 
implementation signature prototype generator due michael van emmerik working queensland university technology 
reported 
library prototypes program called written parse library header les isolate prototypes store information argument types return type le 
prototypes generated standard libraries case pascal prototype information stored part tpl library le 
prototypes generated due missing information regarding exact structure prototype information 
front front constructs call graph program parsing loaded program memory 
subroutine intermediate code control ow graph attached subroutine node call graph parsing intermediate code generation construction ow graph done pass program image 
data information stored global local symbol tables 
user requests disassembly assembler le written le extension user requested interactive interface interactive window displayed user follow program stepping instructions 
semantic analysis done followed displaying bitmap user requested 
shows code frontend procedure 
parser parser determines code reached entry point provided loader equivalent compiler signatures stored program main program determined entry point analysis 
dcc void frontend char filename call graph callgraph parse image building call graph generating icode parse callgraph transform basic block list graph callgraph check bytes data code callgraph option asm disassembly program printf dcc writing assembler file filename disassemble callgraph filename option interact interactive option display window callgraph idiom analysis callgraph remove redundancies graph callgraph option stats statistics basic blocks callgraph option asm disassembly graph compression disassemble callgraph filename option map display memory bitmap front procedure compiler signature recognized associated library signature le loaded 
parsing process ected way compiler signature 
cases code reached entry point provided loader decompiled library routine recognition done 
important point compilers set routines hard parse indirect jumps cases complete code parsed decompilation 
front entry point subroutine parser implements data instruction separation algorithm described chapter 
algorithm recursively follows paths entry point emulates loads registers possible 
subroutine call met entry address subroutine new entry point analyzed recursive way placing subroutine information call graph 
register content detect cases program interrupts relies contents registers 
programs compiler signature recognized known terminated routine executed nishing main program emulating contents registers case necessary 
parser attempt recognizing addressing 
shows de nition proc record stores information subroutine 
note parsing elds lled information lled universal decompiling machine 
typedef struct proc int label number char name meaningful name proc state state entry state flags flg combination icode procedure flags int probable 
bytes parameters args array formal arguments local id local symbol table id retval return value type functions control flow graph icode rec icode record icode records cfg pointer control flow graph cfg array pointers bbs int number basic blocks graph cfg boolean subroutine way node interprocedural live analysis dword livein registers defined dword liveout registers may successors procedure analysed proc procedure record parser followed procedure checks byte bitmap having ags data code case byte position agged data code corresponding subroutine agged potentially self modifying code 
dcc intermediate code intermediate code dcc called icode types low level high level 
low level icode mapping machine instructions assembler mnemonics ensuring icode instruction performs logical instruction 
example instruction div bx assigns ax quotient dx ax divided bx assigns dx reminder previous quotient logical instructions performed machine instruction 
icode instructions div separated di erent instructions idiv 
performs division operands performs modulus operands 
instructions registers overwritten result instruction dx ax example registers need placed temporary register instructions performed 
dcc uses register tmp temporary register 
register forward substituted instruction eliminated data ow analysis 
machine instruction translated icode instructions follows tmp dx ax tmp dx ax idiv bx ax tmp bx bx dx tmp bx dividend idiv set tmp register dx ax 
shows di erent machine instructions represented icode instruction 
example instruction 
machine instruction icode instructions meaning div cl tmp ax tmp ax idiv cl tmp cl cl ah tmp cl loop isub cx cx cx cx gotol isub cx cx cx icmp cx cx 
goto cx goto isub cx cx cx icmp cx cx 
goto cx goto cx bx tmp cx tmp cx cx bx cx bx bx tmp bx tmp machine instructions represent icode instruction front compound instructions represented di erent machine instructions perform logical string function repeat string case 
instructions represented icode instruction irep example 
machine instructions perform low level tasks input output port generated compiler whilst compiling high level language code embedded assembler code instructions high level code generate instructions 
instructions agged icode non high level subroutine instructions agged assembler generated subroutine 
instructions considered generated compilers instructions marked asterisk non high level depending register operands aaa aad aam aas cli daa das dec hlt ins int jo jp lock mov outs pop popa push sti icode instructions set icode ags associated acknowledge properties parsing instruction 
ags byte operands default word operands 
immediate constant source operand 
src source operand 
ops operands 
src source operand byte destination word 
im ops implicit operands 
im src implicit source operand 
im dst implicit destination operand 
seg immed instruction relocated segment value 
hll non high level instruction 
data code instruction modi es data 
word instruction word set address 
terminates instruction terminates program 
target instruction target jump instruction 
switch current indirect jump determines start way statement 
synthetic instruction synthetic exist binary le 
float op instruction oating point instruction 
dcc dcc implements mapping machine instructions low level means static table indexed machine instruction information associated icode de ned condition codes ags procedures determine source destination operands di erent procedures di erent operand types procedures di erent instructions 
mapping machine instructions icode instructions converts instructions icode instructions 
mapping shown 
control flow graph generator dcc implements construction control ow graph subroutine placing basic blocks list converting list proper graph 
parsing basic block instruction met basic block constructed start nish instruction indexes icode array subroutine stored 
instructions possible determine transfer control indexed jumps recognized known way structure header indirect calls said terminate basic block instructions parsed path contains instruction 
nodes called nodes dcc 
types basic blocks standard way way way fall call return nodes 
de nition record basic block shown 
information lled universal decompiling machine 
control ow graph subroutine optimized ow control optimizations remove redundant jumps jumps conditional jumps jumps 
optimizations potential removing basic blocks graph numbering graph left possible nodes removed graph 
time predecessors basic block determined placed array 
semantic analyzer dcc semantic analyzer determines idioms replaces icode instruction 
idioms checked dcc ones described chapter section grouped categories subroutine idioms calling conventions long variable operations miscellaneous idioms 
series idioms available variable pre post incremented pre post decremented 
machine code represents instructions extra register hold value pre post incremented decremented variable checked value variable 
extra register eliminated idiom transform set instructions uses pre post increment decrement operand 
case post increment decrement variable conditional jump value variable copied register variable gets incremented decremented nally register holds copy initial variable increment decrement compared identi er 
extra register eliminated post increment decrement operator available idioms checked code generated shows case 
front low level instruction machine instruction iadd fe fe fe fe fed fed ff ff ff ff ffd ffd fe fe fe fe fed ff ff ff ff ffd fc fa icmc icmp bf ff idas fe fe fe fe fec ff ff ff ff ffc idiv af ff af ff df af ff af ff af ef af ef iin ec ed fe fe fe fe fec fec ff ff ff ff ffc ffc irep ins cc cd low level intermediate code dcc low level instruction machine instruction ce cf ija ijl ijg ijs ijo eb fe fe fea fea fee fee ff ff ffa ffa ffe ffe ea fe fe fea fee ff ff ffa ffe ilds ac ad irep lods ac ad bf irep df df inop ior cf low level intermediate code continued front low level instruction machine instruction ee ef irep outs ipop ipush fe fe feb feb fef fef ff ff ffb ffb fff fff df ca cb cf isar bf ff af ef df iscas ae af ae af ae af fd fb aa ab irep aa ab isub af ef low level intermediate code continued dcc typedef struct bb byte nodetype type node int start instruction offset int finish instruction bb flags flg bb flags int high level edges edges int number edges struct bb array pointers edges int number edges union dword ip edge icode address struct bb edge pointer successor bb interval edge pointer interval outedges array pointers edges interval derived sequence construction int times header list int find intervals struct bb reaching interval header interval node interval interval corresponding interval gi live register analysis dword dword def def dword livein livein dword liveout liveout structuring analysis int preorder dfs visit node int dfs visit node int immediate dominator int iffollow follow node node way int type loop int latchnode latching node loop int back edges int node follows loop int follow node way node fields int traversed boolean traversed 
struct bb initial list link bb basic block record front mov reg var mov reg var var dec var cmp var cmp var jx label jx label jcond var jcond var post increment decrement conditional jump similar way pre increment decrement register 
variable rst incremented decremented moved register compared identi er conditional jump occurs 
case intermediate register identi ers register compare instruction 
intermediate register eliminated means pre increment decrement operator shown 
var dec var mov reg var mov reg var cmp reg cmp reg jx lab jx lab jcond var jcond var pre increment decrement conditional jump dependent idioms 
seen general format idioms series low level icode instructions replaced high level jcond instruction 
instruction agged high level instruction processed data ow analyzer 
instructions involved idioms agged representing high level instructions 
idiom recognition simple type propagation done signed integers signed bytes long variables 
propagating long variables conditionals propagation modi es control ow graph removing node graph described chapter section 
high level condition determined type graph corresponding high level jcond instruction written instruction agged high level instruction 
dcc disassembler dcc implements built disassembler generates assembler les 
assembly le contains information assembler mnemonics program code segment display information relating data 
information disassembler collected parser intermediate code phases decompiler mapping low level assembler mnemonics assembler code generator concerned output formatting 
disassembler handles subroutine time call graph graph traversed depth rst search generate assembler nested subroutines rst 
user options generating assembler les generate assembler straight parsing phase generate assembler graph optimization 
case generates assembler close possible binary image case may certain jump instructions considered redundant graph optimizer 
disassembler decompiler generating target code subroutine agged non high level subroutine assembler code generated subroutine generating subroutine header comments universal decompiling machine universal decompiling machine udm composed phases data ow analysis phase transforms low level icode optimal high level icode representation control ow analysis phase traverses graph subroutine determine bounds loops conditionals bounds code generator 
shows code udm procedure 
data flow analysis rst part data ow analysis removal condition codes 
condition codes classi ed set condition codes generated compiler set set conditions hand crafted assembler set 
condition codes available intel int ow direction interrupt enable trap sign zero auxiliary carry parity carry ags high level carry direction zero sign 
ags modi ed instructions high level ones agged non high level set analyzed condition code removal 
probable high level instructions instructions de ne ags set ranging ags de ned instruction instruction ags normally ags instruction 
dcc implements dead condition code elimination condition code propagation described chapter sections 
optimizations remove condition codes creates jcond instructions associated boolean conditional expression 
analysis overlapped initial mapping low level high level terms registers 
initial mapping explained appendix universal decompiling machine void udm call graph callgraph data flow analysis optimizations icode dataflow callgraph control flow analysis structure graphs build derived sequences subroutine callgraph option display derived sequence subroutine graph structuring structure callgraph procedure universal decompiling machine second part analysis generation summary information operands icode instructions basic blocks graph 
subroutine de nition de nition analysis done associated chains constructed instruction 
constructing chains dead register elimination performed described chapter section 
intraprocedural live register analysis performed subroutine determine register arguments subroutine 
analysis described chapter section 
live register analysis done determine registers returned functions analysis described chapter section 
dead register elimination determines purpose div machine instructions instruction quotient remainder operands 
intermediate code asgn tmp dx ax ud tmp asgn ax tmp bx ud ax asgn dx tmp bx ud dx asgn bp dx ax redefinition determines register ax rede nition de nition chain instruction empty 
de nition dead instruction eliminated eliminating division operands leading code asgn tmp dx ax ud tmp asgn dx tmp bx ud dx asgn bp dx dcc instructions instruction de nition chain need updated re ect fact register de ne dead register ud chain instruction updated example leading nal code asgn tmp dx ax ud tmp asgn dx tmp bx ud dx asgn bp dx third part analysis usage de nition chains registers perform extended register copy propagation described chapter section 
analysis removes redundant register determines high level expressions places actual parameters subroutine list propagates argument types subroutine calls 
temporary expression stack analysis eliminate intermediate pseudo high level instructions push pop 
previous example forward substitution determines initial div instruction determine modulus operands placed registers dx ax bx case asgn bp dx ax bx control flow analysis parts control ow analyzer rst part constructs derived sequence graphs subroutine call graph calculates intervals 
sequence structuring algorithm determine bounds loops nesting level loops 
derived sequence graphs built subroutine graph tested reducibility limit th order graph trivial graph subroutine irreducible 
second part analysis structuring control ow graphs program 
structuring algorithm determines bounds loops conditionals way structures bounds code generation 
loops structured means intervals nesting level determined order derived sequence graphs described chapter section 
post tested endless loops determined algorithm 
conditionals structured means reverse traversal depth rst search tree graph way nested conditionals rst 
method structuring way way conditionals described chapter sections 
method takes account compound boolean conditions removes nodes graph storing boolean conditional information nodes node 
back back composed entirety code generator 
module opens output le gives extension beta writes program header back invokes code generator 
code generated complete graph le closed 
shows code back procedure 
void backend char filename call graph callgraph file fp output file code generation open output file extension openfile fp filename wt printf dcc writing beta file filename header information fp filename process procedure time filename callgraph fp close output file fclose fp printf dcc finished writing beta file back procedure dcc implements code generator described chapter section 
program call graph traversed depth rst fashion generate code leaf subroutines rst reverse invocation order graph reducible 
subroutine code control ow graph generated structures graph bounds loops conditional structures marked graph structuring phase 
code generated recursive way twice recursion goto jump transfer control code associated anode 
registers leaves expression name code generation local variables de ned local variable de nition section instructions code generated may label associated goto jump generated code generated directly le needs stored intermediate data structure code complete subroutine generated copied target output le structure reused subroutine call graph 
data structure dcc handle subroutine declarations code called bundle 
bundle composed arrays lines subroutine declarations subroutine code 
subroutine declarations include subroutine header comments local variable de nitions 
array lines grow dynamically initial allocated array size small 
de nition bundle data structure shown 
dcc typedef struct int number lines table int number lines allocated table char str table strings typedef struct decl declarations code code bundle bundle data structure de nition comments error messages displayed dcc listed appendix results section presents series programs decompiled dcc 
original programs written compiled borland turbo dos 
programs base type variables byte integer long illustrate di erent aspects decompilation process 
programs run batch mode generating disassembly le le call graph program statistics intermediate code instructions 
statistics re ect percentage intermediate instruction reduction subroutines generated subroutines translate assembler considered statistics 
program total count level high level instructions total percentage reduction 
rst programs illustrate operations di erent base types 
original programs code variables de ned di erent type 
programs benchmark programs plum hall benchmark suite 
programs written eric raymond freely available network ray 
programs modi ed ask arguments program scanf scanning argv command line array arrays supported dcc 
programs calculate fibonacci numbers compute cyclic redundancy check crc character multiply matrixes 
program introduced show array expressions derived low level intermediate code 
exe program computes di erent operations variables displays nal result variables 
disassembly program shown decompiled program initial program 
program call graph results main printf seen disassembly program second variable placed register si rst variable placed stack ato set 
synthetic instructions generated parser idiv machine instruction instruction division case modulus 
intermediate code temporary register tmp previously explained section register eliminated data ow analysis 
operation operands instruction moved registers operation performed registers result placed back variables 
control structures program 
idioms data ow analyses reduce number intermediate instructions shown 
dcc main proc near fa push bp fb bec mov bp sp fd ec sub sp push si mov word ptr bp ffh mov si fh fe mov ax bp add ax si bf mov si ax fe mov ax bp bc sub ax si fe mov bp ax fe mov ax bp mul si fe mov bp ax bc mov ax si cwd mov tmp dx ax synthetic inst efe idiv word ptr bp mod word ptr bp synthetic inst bf mov si ax bc mov ax si cwd mov tmp dx ax synthetic inst efe idiv word ptr bp mod word ptr bp synthetic inst bf mov si dx fe mov ax bp mov cl shl ax cl fe mov bp ax bc mov ax si efe mov cl bp sar ax cl bf mov si ax push si ff fe push word ptr bp mov ax push ax ac call near ptr printf add sp pop si mov sp bp pop bp ret main endp results input file exe file type exe include dcc void main takes parameters 
high level language prologue code 
int loc int loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf loc loc dcc define type int main type printf subroutine low level high level reduction main total statistics results exe similar program di erence variables bytes integers 
disassembly program shown decompiled initial program 
program call graph main printf seen disassembly program local variables placed stack sets 
instructions program compared program machine instructions idiv take word registers operands byte registers byte registers padded sign extended form word register 
nal number high level instructions programs reduction number intermediate instructions greater program 
reached shown 
dcc main proc near fa push bp fb bec mov bp sp fd ec sub sp mov byte ptr bp ffh ff mov byte ptr bp fh fe mov bp ff add bp ff mov bp fe mov bp ff sub bp fe mov bp fe mov bp mov ah ff mov dl bp mov dh mul dx fe mov bp ff mov bp mov ah fe mov dl bp mov dh mov bx dx cwd mov tmp dx ax synthetic inst fb idiv bx mod bx synthetic inst ff mov bp ff mov bp mov ah fe mov dl bp mov dh mov bx dx cwd mov tmp dx ax synthetic inst fb idiv bx mod bx synthetic inst ff mov bp dl fe mov bp mov cl shl cl fe mov bp ff mov bp efe mov cl bp shr cl ff mov bp results ff mov bp mov ah push ax fe mov bp mov ah push ax mov ax push ax ab call near ptr printf add sp mov sp bp pop bp ret main endp continued dcc input file exe file type exe include dcc void main takes parameters 
high level language prologue code 
int loc int loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf loc loc results define type unsigned char main type printf subroutine low level high level reduction main total statistics dcc exe programs similar programs long variables 
disassembly program shown decompiled program initial program 
program call graph main printf operations performed long variables idioms run time support routines compiler 
program long addition subtraction performed idioms chapter section run time routines long multiplication division modulus left shift right shift accordingly 
run time routines long multiplication left shift right shift translatable macros access low high part variable cases 
division modulus routines assembler generated 
long variables placed stack sets see main subroutine 
main program instructions program instructions program 
increase number instructions causes rst transfer long variables registers takes instructions high low part transfered di erent registers second subroutine call instructions run time support routines 
nal decompiled main program generates number high level instructions previous programs reduction number intermediate instructions shown 
reduction number instructions due run time routines translated lot register movement arguments registers routines initially written assembler 
results proc far cmp cl jae mov bx dx shr ax cl fa sar dx cl neg cl add cl shl bx cl bc ax bx cb sub cl bc mov ax dx cwd sar ax cl cb endp proc far cmp cl jae bd mov bx ax shl ax cl shl dx cl neg cl add cl eb shr bx cl bd dx bx cb sub cl bd mov dx ax xor ax ax shl dx cl cb endp proc far cf mov cx push bp push si push di da bec mov bp sp dc bf mov di cx de mov ax bp ah mov dx bp ch mov bx bp eh dcc mov cx bp ea bc cx cx ec jne ee bd dx dx je bx bx je test di fa jne fc bd dx dx fe jns da neg dx neg ax da sbb dx cf di ch bc cx cx jns neg cx db neg bx sbb cx xor di mov bp cx mov cx push di ff xor di di xor si si shl ax rcl dx rcl si rcl di cmp di bp jb ja bf cmp si bx jb bf sub si bx sbb di bp ax loop pop bx test bx je bc mov ax si bd mov dx di eb shr bx continued results test bx je da neg dx neg ax da sbb dx pop di pop si pop bp ca mov tmp dx ax synthetic inst div bx mod bx synthetic inst test di je bc mov ax dx xor dx dx ebec jmp endp proc far xor cx cx push bp push si push di da bec mov bp sp dc bf mov di cx de mov ax bp ah mov dx bp ch mov bx bp eh mov cx bp ea bc cx cx ec jne ee bd dx dx je bx bx je test di fa jne fc bd dx dx fe jns da neg dx neg ax da sbb dx cf di ch bc cx cx continued dcc jns neg cx db neg bx sbb cx xor di mov bp cx mov cx push di ff xor di di xor si si shl ax rcl dx rcl si rcl di cmp di bp jb ja bf cmp si bx jb bf sub si bx sbb di bp ax loop pop bx test bx je bc mov ax si bd mov dx di eb shr bx test bx je da neg dx neg ax da sbb dx pop di pop si pop bp ca mov tmp dx ax synthetic inst div bx mod bx synthetic inst test di je bc mov ax dx xor dx dx ebec jmp endp continued results proc far push si mov tmp ax synthetic inst mov ax si synthetic inst mov si tmp synthetic inst mov tmp ax synthetic inst mov ax dx synthetic inst mov dx tmp synthetic inst test ax ax je ca mul bx mov tmp ax synthetic inst mov ax cx synthetic inst mov cx tmp synthetic inst cd test ax ax cf je mul si add cx ax mov tmp ax synthetic inst mov ax si synthetic inst mov si tmp synthetic inst mul bx add dx cx da pop si db cb endp main proc near fa push bp fb bec mov bp sp fd ec sub sp fa mov word ptr bp ff mov word ptr bp ffh fe mov word ptr bp fc mov word ptr bp fh fa mov dx bp mov ax bp fc add ax bp fe adc dx bp fe mov bp dx fc mov bp ax fa mov dx bp mov ax bp fc sub ax bp fe sbb dx bp fa mov bp dx continued dcc mov bp ax fa mov dx bp mov ax bp efe mov cx bp efc mov bx bp ac call far ptr fa mov bp dx mov bp ax ff fa push word ptr bp ff push word ptr bp ff fe push word ptr bp ff fc push word ptr bp ac call far ptr fe mov bp dx fc mov bp ax ff fa push word ptr bp ff push word ptr bp ff fe push word ptr bp ff fc push word ptr bp acf call far ptr fe mov bp dx fc mov bp ax fa mov dx bp mov ax bp mov cl call far ptr fa mov bp dx mov bp ax fe mov dx bp fc mov ax bp ef mov cl bp call far ptr fe mov bp dx fc mov bp ax ff fe push word ptr bp ff fc push word ptr bp aa ff fa push word ptr bp ad ff push word ptr bp mov ax push ax call near ptr printf add sp ah ba mov sp bp bc pop bp bd ret main endp continued results input file exe file type exe include dcc long long arg long arg uses register arguments arg dx ax 
arg cx bx 
runtime support routine compiler 
int loc int loc tmp loc lo arg lo arg loc loc loc loc lo arg lo arg hi arg lo arg lo arg lo arg lo arg lo arg loc lo arg lo arg hi arg hi arg loc lo arg lo arg lo arg lo arg loc hi arg hi arg lo arg loc lo arg lo arg loc loc loc arg lo arg lo arg hi arg hi arg hi arg return arg dcc long long arg long arg takes bytes parameters 
runtime support routine compiler 
routine 
assembler provided 
return value registers dx ax 
pascal calling convention 
disassembly code long long arg long arg takes bytes parameters 
runtime support routine compiler 
routine 
assembler provided 
return value registers dx ax 
pascal calling convention 
disassembly code long long arg char arg uses register arguments arg dx ax 
arg cl runtime support routine compiler 
int loc bx arg loc lo arg lo arg lo arg arg hi arg hi arg arg hi arg hi arg loc arg return arg hi arg lo arg lo arg hi arg hi arg arg return arg continued results long long arg char arg uses register arguments arg dx ax 
arg cl runtime support routine compiler 
int loc bx arg loc hi arg lo arg lo arg arg hi arg hi arg arg lo arg lo arg loc arg return arg arg hi arg lo arg lo arg arg return arg void main takes parameters 
high level language prologue code 
long loc long loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf ld ld loc loc continued dcc define type long main type printf ld ld subroutine low level high level reduction main total statistics results exe program plum hall benchmark suite benchmarks short integers 
program long variables iterate loop short integer variables execute operations 
disassembly program shown decompiled program initial program 
program call graph main scanf printf seen disassembly program long variables located stack sets integer variables located sets 
nal code integer variable loc hold result boolean expression assign corresponding variable 
boolean variable register variable register ax eliminated code analysis control ow graph similar way structuring compound conditions 
code boolean expression ax ax ax ax code boolean expression ax control flow graph boolean assignment example graph reduced graph conditions satis ed 
node way node 

nodes edge node lead common node 
nodes instruction 
instruction assigns respectively register 

node assigns register nodes local variable 
register rede nition program 
register store intermediate result boolean expression evaluation eliminated nal code assigning boolean expression dcc target variable 
transformation removes involved register nodes assigned value nodes graph 
clear boolean assignments transformed code loc loc loc code loc loc loc nal program exact decompilation original program 
transformation generated code functionally equivalent initial code structurally equivalent decompiled graph 
graph boolean assignment structured nature non implementation transformation generate unstructured code way case compound conditions unstructured graphs nature transformed structured graphs 
graph optimization nal decompiled code generated dcc produces reduction number intermediate instructions shown 
boolean assignment initial code extra instructions due temporary local variable loc case 
results main proc near fa push bp fb bec mov bp sp fd ec sub sp eh fc lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx ff fe push word ptr bp ff fc push word ptr bp mov ax push ax call near ptr printf add sp lea ax bp eh push ax mov ax push ax cc call near ptr scanf pop cx pop cx lea ax bp ch push ax mov ax push ax bf call near ptr scanf pop cx pop cx fa mov word ptr bp mov word ptr bp bd fa mov dx bp mov ax bp fe cmp dx bp mov word ptr bp ah af ef cmp word ptr bp ah add word ptr bp fa adc word ptr bp jmp synthetic inst dcc mov ax bp eh add ax bp ch add ax bp ah mov bp eh ax mov ax bp eh sar ax mov bp ch ax mov ax bp ch bb mov bx ah cwd mov tmp dx ax synthetic inst fb idiv bx mod bx synthetic inst mov bp eh dx mov ax bp ch cmp ax bp ah jne mov ax mov bp eh ax mov ax bp eh ax bp ah mov bp ch ax mov ax bp ch neg ax bc sbb ax ax ax mov bp eh ax mov ax bp eh add ax bp ah mov bp ch ax mov ax bp ch cmp ax bp ah mov ax mov bp eh ax ac ff word ptr bp ah jmp synthetic inst xor ax ax jmp synthetic inst xor ax ax jmp synthetic inst cb jg cd fc cmp ax bp ja continued results ff push word ptr bp eh ba mov ax bah db push ax dc call near ptr printf df pop cx pop cx mov sp bp pop bp ret main endp continued dcc input file exe file type exe include dcc void main takes parameters 
high level language prologue code 
int loc int loc int loc long loc long loc int loc ax scanf ld loc printf executing ld iterations loc scanf ld loc scanf ld loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf loc results benchmark short integers thomas plum plum hall machine traps overflow unsigned type execution time milliseconds average time operator major usec inner loop exactly operations define stor cl auto define type short include stdio main int ac char av stor cl type long major scanf ld major printf executing ld iterations major scanf ld scanf ld major inner loop executes selected operations printf subroutine low level high level reduction main total statistics dcc exe program plum hall benchmark suite benchmarks long variables 
program exactly exe program long variables short integers 
disassembly program shown decompiled program initial program 
program call graph main scanf printf seen disassembly program long variables located stack sets 
nal decompiled code long variables integer variable loc 
variable boolean variable hold contents boolean expression evaluation 
boolean expression evaluations seen nal code loc loc lo loc hi loc loc loc expressions transformed boolean assignment means transformation described previous section 
generated code loc loc loc code loc lo loc hi loc code loc loc loc second boolean expression checks low high part long variable ors equivalent logical negation long variable lead nal code loc loc program compared program low level instructions main program subroutine calculates modulus long variables high level language instructions high level representation main due logical negation long variable temporary boolean variable loc performs reduction instructions shown 
results proc far mov cx ef push bp ef push si ef push di ef bec mov bp sp ef bf mov di cx efa mov ax bp ah efd mov dx bp ch mov bx bp eh mov cx bp bc cx cx jne bd dx dx je bx bx je test di jne bd dx dx jns da neg dx neg ax da sbb dx cf di ch bc cx cx jns neg cx db neg bx sbb cx xor di mov bp cx mov cx push di ff xor di di xor si si shl ax rcl dx rcl si rcl di cmp di bp jb ja bf cmp si bx jb dcc bf sub si bx sbb di bp ax loop pop bx test bx je bc mov ax si bd mov dx di eb shr bx test bx je da neg dx neg ax da sbb dx pop di pop si pop bp ca mov tmp dx ax synthetic inst div bx mod bx synthetic inst test di je bc mov ax dx xor dx dx ebec jmp endp main proc near fa push bp fb bec mov bp sp fd ec sub sp fc lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx ff fe push word ptr bp ff fc push word ptr bp mov ax push ax call near ptr printf continued results add sp ec lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx fa mov word ptr bp mov word ptr bp fa mov dx bp mov ax bp fe cmp dx bp mov word ptr bp ah mov word ptr bp ch ef cmp word ptr bp ah ee mov dx bp ec mov ax bp add ax bp adc dx bp eh add ax bp ch adc dx bp ah ee mov bp dx ec mov bp ax ee mov dx bp ec mov ax bp fa sar dx rcr ax mov bp eh dx mov bp ax xor dx dx mov ax ah continued dcc push dx push ax ff push word ptr bp eh ff push word ptr bp call far ptr ee mov bp dx ec mov bp ax mov dx bp eh mov ax bp cmp dx bp ah jne cmp ax bp ch jne mov ax cwd ee mov bp dx ac ec mov bp ax af ee mov dx bp ec mov ax bp ax bp ch dx bp ah bb mov bp eh dx mov bp ax mov ax bp ax bp eh jne mov ax cwd ee mov bp dx ec mov bp ax ee mov dx bp da ec mov ax bp dd add ax bp ch adc dx bp ah mov bp eh dx mov bp ax mov dx bp eh ec mov ax bp ef cmp dx bp ah jl jg cmp ax bp ch continued results fb mov ax cwd ee mov bp dx ec mov bp ax add word ptr bp ch adc word ptr bp ah jmp synthetic inst xor ax ax jmp synthetic inst ce xor ax ax jmp synthetic inst xor ax ax jmp synthetic inst jg ef cmp word ptr bp ch ja add word ptr bp fa adc word ptr bp jmp synthetic inst jg fc cmp ax bp ja ff ee push word ptr bp ff ec push word ptr bp ba mov ax bah push ax call near ptr printf add sp mov sp bp pop bp ret main endp continued dcc input file exe file type exe include dcc long long arg long arg takes bytes parameters 
runtime support routine compiler 
routine 
assembler provided 
return value registers dx ax 
pascal calling convention 
disassembly code void main takes parameters 
high level language prologue code 
long loc long loc long loc long loc long loc int loc ax scanf ld loc printf executing ld iterations loc scanf ld loc scanf ld loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc results loc loc loc loc loc loc lo loc hi loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf loc continued dcc benchmark long integers thomas plum plum hall machine traps overflow unsigned type execution time milliseconds average time operator major usec inner loop exactly operations define type long include stdio main int ac char av type long major scanf ld major printf executing ld iterations major scanf ld scanf ld major inner loop executes selected operations printf subroutine low level high level reduction main total statistics results exe program plum hall benchmarks 
program benchmarks integer multiplication executing multiplications loop 
disassembly program shown decompiled program initial program 
program call graph main scanf printf long variables loop large number times program integer variables perform operations variables program 
seen disassembly long variables located stack sets integer variables sets register variable si 
nal code identical initial code reduction instructions achieved program seen 
dcc main proc near fa push bp fb bec mov bp sp fd ec sub sp ch push si fc lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx ff fe push word ptr bp ff fc push word ptr bp mov ax push ax call near ptr printf add sp lea ax bp ch push ax mov ax push ax call near ptr scanf pop cx pop cx lea ax bp ah push ax mov ax push ax call near ptr scanf pop cx pop cx fa mov word ptr bp mov word ptr bp aa fa mov dx bp ad mov ax bp fe cmp dx bp jl jg fc cmp ax bp ba bc ff push word ptr bp ch bf mov ax push ax call near ptr printf results pop cx pop cx pop si mov sp bp cb pop bp cc ret mov si fe cmp si ea add word ptr bp fa adc word ptr bp jmp synthetic inst mov ax bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch mul word ptr bp ch ba mov dx mul dx mov bp ch ax si jmp synthetic inst main endp continued dcc input file exe file type exe include dcc void main takes parameters 
high level language prologue code 
int loc int loc long loc long loc int loc scanf ld loc printf executing ld iterations loc scanf loc scanf loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc loc printf loc results benchmark int multiply thomas plum plum hall machine traps overflow unsigned type execution time milliseconds average time operator major usec inner loop exactly operations define stor cl auto define type int include stdio main int ac char av stor cl type long major scanf ld major printf executing ld iterations major scanf scanf major inner loop executes selected operations printf subroutine low level high level reduction main total statistics dcc exe program plum hall benchmark suite benchmarks function calls subroutine calls done time loop 
disassembly program shown decompiled program initial program 
program call graph main scanf printf proc proc proc proc procedures main program 
procedures invoke procedure fourth procedure empty 
percentage reduction number intermediate instructions high program compared previous programs expressions program normally case high level programs 
seen statistics program see empty procedure reduction procedure prologue trailer low level instructions eliminated program procedures reduction instructions procedure calls performed main program reduction instructions expressions assignments procedure 
average program low due lack assignment statements program 
results proc proc near fa push bp fb bec mov bp sp fd pop bp fe ret proc endp proc proc near ff push bp bec mov bp sp ff call near ptr proc ff call near ptr proc call near ptr proc call near ptr proc ff call near ptr proc ff call near ptr proc ff call near ptr proc ff call near ptr proc call near ptr proc call near ptr proc pop bp ret proc endp proc proc near push bp bec mov bp sp ff call near ptr proc ff call near ptr proc ff call near ptr proc call near ptr proc call near ptr proc ff call near ptr proc ff call near ptr proc ff call near ptr proc call near ptr proc call near ptr proc pop bp ret proc endp proc proc near push bp bec mov bp sp ff call near ptr proc dcc ff call near ptr proc ff call near ptr proc call near ptr proc call near ptr proc ff call near ptr proc ff call near ptr proc ff call near ptr proc call near ptr proc pop bp ret proc endp main proc near push bp bec mov bp sp ec sub sp fc lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx ff fe push word ptr bp ff fc push word ptr bp mov ax push ax call near ptr printf add sp fa mov word ptr bp mov word ptr bp fa mov dx bp mov ax bp fe cmp dx bp cea jl aa jg ac fc cmp ax bp af mov ax push ax call near ptr printf pop cx mov sp bp continued results bb pop bp bc ret call near ptr proc add word ptr bp fa adc word ptr bp jmp synthetic inst main endp continued dcc input file exe file type exe include dcc void proc takes parameters 
high level language prologue code 
void proc takes parameters 
high level language prologue code 
proc proc proc proc proc proc proc proc proc proc void proc takes parameters 
high level language prologue code 
proc proc proc proc proc proc proc results proc proc proc void proc takes parameters 
high level language prologue code 
proc proc proc proc proc proc proc proc proc void main takes parameters 
high level language prologue code 
long loc long loc scanf ld loc printf executing ld iterations loc loc loc loc proc loc loc printf finished continued dcc benchmark function calls thomas plum plum hall execution time milliseconds average time operator major usec inner loop exactly operations include stdio main int ac char av long major scanf ld major printf executing ld iterations major major executes calls printf finished subroutine low level high level reduction proc proc proc proc main total statistics results fibo exe fibo program calculates fibonacci input numbers 
computation fibonacci number done recursive function recursions 
disassembly program shown decompiled program initial program 
fibo call graph main scanf printf exit proc proc main decompiled program number instructions initial program loop represented loop 
recursive fibonacci function proc decompiled program instructions opposed instructions initial code 
extra instructions due copy argument local variable loc arg placement result register variable di erent paths di erent possible results returning value 
code functionally equivalent initial code ways 
note second recursive invocation proc actual parameter expression loc equivalent loc 
expression comes disassembly program addition local variable negative number subtraction 
seen statistics program see individual reduction number intermediate instruction 
dcc proc proc near push bp bec mov bp sp push si mov si bp fe cmp si bc mov ax si dec ax push ax call near ptr proc pop cx push ax bc mov ax si add ax push ax ff call near ptr proc pop cx bd mov dx ax pop ax add ax dx pop si pop bp ret mov ax eb jmp proc endp main proc near fa push bp fb bec mov bp sp fd ec sub sp push si push di mov ax push ax call near ptr printf pop cx fc lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx fibo results mov si fc cmp si bp ece xor ax ax push ax call near ptr exit pop cx pop di pop si mov sp bp pop bp ret mov ax push ax ee call near ptr printf pop cx fe lea ax bp push ax mov ax push ax call near ptr scanf pop cx pop cx ff fe push word ptr bp call near ptr proc pop cx bf mov di ax push di ff fe push word ptr bp mov ax push ax cc call near ptr printf add sp si jmp synthetic inst main endp fibo continued dcc input file fibo exe file type exe include dcc int proc int arg takes bytes parameters 
high level language prologue code 
calling convention 
int loc int loc ax loc arg loc loc proc loc proc loc loc return loc void main takes parameters 
high level language prologue code 
int loc int loc int loc int loc printf input number iterations scanf loc loc loc loc printf input number scanf loc loc proc loc printf fibonacci loc loc loc loc exit fibo results include stdio int main int number unsigned value fib printf input number iterations scanf printf input number scanf number value fib number printf fibonacci number value exit unsigned fib compute fibonacci number recursively int return fib fib return fibo subroutine low level high level reduction proc main total fibo statistics dcc crc exe crc program calculates cyclic redundancy check crc character message block passes resulting crc back crc functions see received character message crc correct 
disassembly program shown decompiled program initial program 
crc call graph main proc proc proc proc printf seen initial program crc functions main procedure 
decompiled version program functions main program extra functions runtime support routines support long right left shifts respectively 
routines initially written assembler translated accessing low high parts long argument 
seen statistics program see user functions reduction intermediate instructions 
functions number high level instructions compared original program 
function proc crc clear function returns zero 
function reduction intermediate instructions due overhead provided procedure prologue trailer code 
function proc crc update function calculates crc input argument ccitt recommended crc generator function 
function uses bits compute result returns lower bits function value 
decompiled version function propagates fact bits result invoked runtime routine function returns integer bits long integer code simpler homologous returns long integer 
reduction number instruction 
function proc crc finish function returns nal transmitted block 
function calls crc update function twice argument 
reduction number instructions high low level instructions transformed high level return instruction 
program invokes functions right order reduction achieved 
note integers program characters character variables characters unsigned character generates code 
intermediate instruction reduction program due runtime routines 
results proc proc near push bp bec mov bp sp xor ax ax push ax xor ax ax push ax ff push word ptr bp fff call near ptr proc pop cx pop cx push ax ff call near ptr proc mov sp bp pop bp ret proc endp proc far cmp cl jae mov bx dx shr ax cl fa sar dx cl neg cl add cl shl bx cl bc ax bx cb sub cl bc mov ax dx cwd sar ax cl cb endp proc proc near fa push bp fb bec mov bp sp fd xor ax ax pop bp ret proc endp crc dcc proc far cmp cl jae bd mov bx ax aa shl ax cl ac shl dx cl ae neg cl add cl eb shr bx cl bd dx bx cb sub cl bb bd mov dx ax bd xor ax ax bf shl dx cl cb endp proc proc near push bp bec mov bp sp ec sub sp mov ax bp cwd mov cl aa call far ptr push dx push ax mov bp cwd cwd pop bx pop cx add bx ax ca adc cx dx efc mov bp cx efa mov bp bx fe mov word ptr bp efe cmp word ptr bp cc jl fc mov dx bp fa mov ax bp ff ax ff ff dx ffh mov cl call far ptr crc continued results mov sp bp pop bp ret fc mov dx bp fa mov ax bp shl ax rcl dx fc mov bp dx fa mov bp ax fc mov dx bp fa mov ax bp ax dx bd dx ax je fc mov dx bp fa mov ax bp xor ax xor dx fc mov bp dx fa mov bp ax ff fe word ptr bp jmp synthetic inst proc endp main proc near push bp bec mov bp sp ec sub sp fd mov byte ptr bp aa dff call near ptr proc ad fa mov bp ax fd mov bp cwd push ax ff fa push word ptr bp ff call near ptr proc bb pop cx bc pop cx bd fa mov bp ax ff fa push word ptr bp call near ptr proc pop cx fa mov bp ax ca fa mov ax bp cd ff ax ff mov cl crc continued dcc shr ax cl fe mov bp fa mov bp da ff ffh dc ff mov bp df ff fa push word ptr bp mov ax push ax fc call near ptr printf pop cx ea pop cx eb cff call near ptr proc ee fa mov bp ax fd mov bp cwd push ax ff fa push word ptr bp ff call near ptr proc fc pop cx fd pop cx fe fa mov bp ax fe mov bp cwd push ax ff fa push word ptr bp fe call near ptr proc pop cx pop cx fa mov bp ax ff mov bp cwd push ax ff fa push word ptr bp fe call near ptr proc pop cx pop cx fa mov bp ax ff fa push word ptr bp mov ax ah push ax ba call near ptr printf pop cx pop cx mov sp bp pop bp ret main endp crc continued results input file crc exe file type exe include dcc int proc takes parameters 
high level language prologue code 
return long long arg char arg uses register arguments arg dx ax 
arg cl runtime support routine compiler 
int loc bx arg loc lo arg lo arg lo arg arg hi arg hi arg arg hi arg hi arg loc arg return arg hi arg lo arg lo arg hi arg hi arg arg return arg crc dcc int long arg char arg uses register arguments arg dx ax 
arg cl runtime support routine compiler 
int loc bx arg loc hi arg lo arg lo arg arg hi arg hi arg arg return lo arg loc arg return hi arg arg int proc int arg unsigned char arg takes bytes parameters 
high level language prologue code 
calling convention 
int loc long loc loc arg arg loc loc loc loc loc loc loc loc loc return loc crc continued results int proc int arg takes bytes parameters 
high level language prologue code 
calling convention 
return proc proc arg void main takes parameters 
high level language prologue code 
int loc int loc int loc int loc loc loc proc loc proc loc loc loc proc loc loc loc xff loc loc printf loc loc proc loc proc loc loc loc proc loc loc loc proc loc loc printf loc crc continued dcc crc clear function clears crc zero 
called prior start processing block received messages messages transmitted 
calling sequence short crc crc crc clear short crc clear return crc update function called character included crc messages transmitted 
function called character included crc received message crc characters received message 
resulting crc zero message correctly received 
calling sequence crc crc update crc char short crc update crc crc char short crc char crc char long short contain character processed bits crc bits 
bit test overflow cleared prevent sign bit set 
bits 
treated bit register 
long crc crc char get crc character repeat loop times bits character 
crc results shift high order bit character low order bit crc shift high order bit crc bit 
shift left bit test see old high order bit crc 
test bit old high order bit crc exclusive set exclusive crc hex produce ccitt recommended crc generator 
produce crc generator change constant 
exclusive crc hex produce crc ibm uses synchronous transmission protocols 
exclusive constant hex repeat times 
loop return crc low order bits function value 
return ffff unneeded bits 
shift result bits right crc finish function called characters block processed message transmitted 
returns calculated crc bytes transmitted characters block 
bytes taken high order byte crc second taken low order byte crc 
routine called message received 
calling sequence crc crc finish crc short crc finish crc short crc call crc update twice passing character hex time flush bits crc calculation return result value function 
return crc update crc update crc crc continued dcc sample crc functions calculates crc character message block passes resulting crc back crc functions see received character message crc correct 
main short crc calculated crc char crc char character message char places hold received crc bytes crc char define character message crc crc clear reset crc transmit new message crc crc update crc crc char update crc 
character message crc crc finish crc finish transmission calculation char crc xff extract high order crc byte char crc ff extract low order byte printf crc print results crc crc clear prepare receive message crc crc update crc crc char update crc 
character message crc crc update crc pass bytes received 
crc crc update crc crc crc update printf crc result message 
received error crc continued subroutine low level high level reduction proc proc proc main total crc statistics results program multiplies matrixes 
program incomplete sense initialize matrixes decompiled show forward substitution method chapter section able nd array expressions 
conversion expression array done dcc explained chapter section 
disassembly program shown decompiled program initial program 
call graph program follows main proc user procedures decompiled number high level instructions matrix multiplication procedure main program 
reduction number instructions due large number low level instructions involved computation array set 
disassembled version program basic block lines procedure proc instructions converted high level instructions reduction intermediate instructions 
program reduction intermediate instructions shown 
dcc proc proc near fa push bp fb bec mov bp sp fd ec sub sp push si push di xor si si fe cmp si jl pop di pop si mov sp bp pop bp ret ff xor di di ff cmp di jl si jmp synthetic inst fe mov word ptr bp efe cmp word ptr bp ca jl di jmp synthetic inst bde mov bx si shl bx shl bx shl bx add bx bp fe mov ax bp shl ax add bx ax mov ax bx push ax fe mov ax bp ba mov dx ah mul dx bd mov bx ax add bx bp bc mov ax di shl ax add bx ax pop ax results mul word ptr bx push ax bc mov ax si ba mov dx ah mul dx bd mov bx ax add bx bp bc mov ax di shl ax add bx ax pop ax add ax bx push ax bc mov ax si ba mov dx ah mul dx bd mov bx ax add bx bp bc mov ax di shl ax add bx ax pop ax mov bx ax ff fe word ptr bp jmp synthetic inst proc endp main proc near push bp bec mov bp sp ec sub sp lea ax bp push ax lea ax bp push ax lea ax bp push ax ff call near ptr proc add sp mov sp bp pop bp ret main endp continued dcc input file exe file type exe include dcc void proc int arg int arg int arg takes bytes parameters 
high level language prologue code 
calling convention 
int loc int loc int loc loc loc loc loc loc loc loc arg loc loc arg loc loc arg loc loc arg loc loc loc loc loc loc loc void main takes parameters 
high level language prologue code 
int loc int loc int loc proc loc loc loc results define define static void int int int int main int subroutine low level high level reduction proc main total statistics dcc results summary results programs previous sections 
total number low level intermediate instructions compared nal high level instructions gives reduction instructions 
reduction instructions mainly due optimizations performed data ow analysis particularly extended register copy propagation chapter section 
recognition idioms low level code reduces number instructions helps determination data types long integers 
decompiled programs number user subroutines plus runtime support routines program 
routines translatable high level representation assembler generated 
program low level high level reduction bo crc total results tested programs chapter thesis techniques reverse compilation decompilation bi nary programs provided algorithms implementation di erent phases decompiler 
methodology implemented tested prototype decompiler dcc runs dos unix 
decompilers similar principles techniques compilers 
decompiler di erent phases incorporate compiler optimization phases 
lexical analysis phase due simplicity source machine language 
syntax analysis phase parses source binary program separating code data placing data symbol table 
main di culty separation code data represented way neumann machines 
intermediate code generation phase generates low level intermediate representation program 
semantic analysis phase checks semantic meaning groups low level instructions idioms gathers type information propagates intermediate representation 
control ow graph generation phase generates control ow graph subroutine program attaches intermediate representation information nodes graph 
data ow analysis phase analyzes low level intermediate code converts high level intermediate representation available high level language 
transformation instructions eliminates low level condition codes registers introduces high level concept expression 
subroutines representable high level language agged 
structure program analyzed control ow analysis phase structures control ow graphs subroutine program 
code generation phase generates high level code high level intermediate representation structured graph subroutine 
complete decompilation program decompiler related tools loader signature generator prototype generator disassembler postprocessor 
loader loads source binary program memory signature generator generates signatures known compilers libraries required prototype generator determines formal argument types library subroutines disassembler parses program produces assembler output le decompiler signature information reduce number subroutines decompile attempt decompile library routines recognized signature loader postprocessor transforms output decompiled high level program semantically equivalent program speci control structures available target language 
practice decompiler take input binary program assembler program produce high level language output program 
literature available decompilers approach assembler source program 
thesis concentrates source binary programs far information assembler programs 
techniques described thesis general construct decompilers architectures 
phases grouped di erent modules separate machine language dependent features front machine dependent module parses source binary program produces low level intermediate representation program control ow graph subroutine universal decompiling machine machine language independent module analyzes intermediate code structure graph generates high level intermediate representation program structured graph back target language dependent module generates high level target code intermediate representation structure graph 
way decompiler di erent machine built writing new front machine decompiler di erent target high level language built writing new back target language 
approach limited practice choice low level intermediate language representation 
signi cant contributions thesis types analyses done universal decompiling machine data ow analysis control ow analysis transform low level machine intermediate code high level hll intermediate representation 
data ow analyzer describes optimization techniques compiler optimization principles eliminate low level concepts condition codes registers introduces high level concept expression 
techniques account interprocedural analysis register spilling type propagation 
control ow analyzer describes structuring algorithms determine underlying high level control structures program 
algorithms structure graph prede ned generic set control structures available commonly languages 
implementation techniques prototype decompiler dcc demonstrates feasibility techniques 
dcc decompiler dos operating system intel machine architecture generates target programs 
decompiler runs decstation unix intel machines dos 
dcc compiler library signature recognition decompile user routines possible decompiling compiler start library routines 
compiler signature determined subroutines available source binary program decompiled library compiler start routines high level language representation disassembled 
dcc provides comments subroutine command switches generate bitmap program call graph output assembler le statistics number low level high level instructions subroutine information control ow graph subroutine 
decompilation main areas computer science software maintenance security 
decompiler software maintenance recover lost inaccessible source code translate code written obsolete language newer language structure old code written unstructured way spaghetti code migrate applications new hardware platform debug binary programs known bug 
security decompiler verify binary programs correctness code produced compiler safety critical systems compiler trusted generate correct code check existence malicious code viruses 
decompilation done areas separation code data determination data types arrays records pointers 
area needs robust method determining way branch statements indexed jumps indirect subroutine calls 
area needs heuristic methods identify di erent types compound data types propagate values 
cient implementation algorithms provide faster decompiler speed decompilation concern program normally decompiled 
appendix architecture intel machine architectures consist type registers memory structure input output port organization int int 
architectures downwards compatible supports machine instructions supported architecture 
registers bit word machines classi ed di erent sets usage data pointer index control segment registers classi cation shown 
type register function data ax accumulator bx base register addressing modes cx counter dx general purpose pointer sp stack pointer bp base pointer index si source di destination control ip instruction pointer ags ags status word segment cs code segment ds data segment ss stack segment es extra segment register classi cation data general purpose registers accessed word byte registers 
register high low byte naming convention register names replace ah access high byte register register names replace anl access low byte register 
ags register special purpose register keeps track condition codes set di erent instructions 
structure register shown 
seen bits unused bits reserved intel 
memory structured array bit bytes stored little endian convention signi cant byte word stored highest memory address 
memory divided architecture direction ow carry parity auxiliary carry zero sign trap interrupt structure flags register banks segments segment linear sequence bytes memory addressed segment set pair 
input output port organization consists kb bit ports kb bit ports located separate addressing space memory space 
instruction format length instruction varies bytes 
types opcodes byte opcodes compound opcodes 
byte opcodes rst byte instruction opcode followed elds byte bytes displacement bytes data 
elds byte contains information registers immediate operands displacement data 
compound opcodes store part opcode rst byte instruction part bits second byte instruction see 
rst byte determines group table instruction belongs bit opcode second byte determines index table entries table 
remaining bits second byte elds byte 
rest instruction structured way byte opcodes lg 
opcode compound opcodes second byte byte combinations valid opcodes 
byte opcodes compound opcodes pre instructions 
complete list machine language instructions mnemonics operands section 
elds byte calculate ective address ea operand 
byte elds reg bit eld takes value register bit eld second register memory operand mod bit eld instruction format mod reg fields byte determines number displacement bytes disp register memory operand ective address instructions indexed 
structure byte shown 
algorithm interpret elds byte shown 
case mod get bytes displacement ea extra bytes disp get byte displacement disp sign extended bits get bytes displacement disp indexed treated register field algorithm interpret fields byte ea indexed indexed operands calculated eld mapped indexed register combination indexed registers shown 
value indexed register bx si bx di bp si bp di si di bp bx mapping eld architecture nal ective address calculated addition displacement disp register ther bits 
combination mod values uses default segment register addressing default segments shown 
ective address operand determined combination mod elds nal physical address calculated adding ea contents default segment register multiplied 
general rule bp register default segment isss default segment isds 
mod ds ds ds ds ds ds ss ss ss ss ss ss ds ds ds ds ds ds ds ss ss ds ds ds default segments segment override pre byte opcode permits exceptions default segment register instruction valid instruction follows 
segment determined bit eld bits pre byte 
elds take constant values illustrated 
seg segment override pre repeat pre opcodes 
opcodes repeat execution instruction register cx equal equal zero 
normally string instructions ins repeat condition string 
instruction set instruction set described terms machine opcode assembler mnemonic assembler operands instruction 
conventions describe instruction set instruction set reg bit register 
reg bit register 
mem bit memory value 
mem bit memory value 
immed bit immediate value 
immed bit immediate value 
immed bit immediate value 
bit segment register 
show byte opcodes 
compound opcodes referenced indexes table table values 
tables shown figures 
gures summaries gures described int int 
architecture machine opcode assembler mnemonic operands add reg mem reg add reg mem reg add reg reg mem add reg reg mem add immed add ax immed push es pop es reg mem reg reg mem reg reg reg mem reg reg mem immed ax immed push cs adc reg mem reg adc reg mem reg adc reg reg mem adc reg reg mem adc immed adc ax immed push ss pop ss sbb reg mem reg sbb reg mem reg sbb reg reg mem sbb reg reg mem sbb immed sbb ax immed push ds pop ds reg mem reg reg mem reg reg reg mem reg reg mem immed ax immed segment override daa byte opcodes instruction set machine opcode assembler mnemonic operands sub reg mem reg sub reg mem reg sub reg reg mem sub reg reg mem sub immed sub ax immed segment override das xor reg mem reg xor reg mem reg xor reg reg mem xor reg reg mem xor immed xor ax immed segment override aaa cmp reg mem reg cmp reg mem reg cmp reg reg mem cmp reg reg mem cmp immed cmp ax immed segment override aas ax cx dx bx sp bp si di dec ax dec cx dec dx dec bx dec sp dec bp dec si dec di byte opcodes continued architecture machine opcode assembler mnemonic operands push ax push cx push dx push bx push sp push bp push si push di pop ax pop cx pop dx pop bx pop sp pop bp pop si pop di popa bound reg mem reg push immed reg mem immed push immed reg mem immed jo immed immed jb immed immed jz immed immed immed ja immed byte opcodes continued instruction set machine opcode assembler mnemonic operands js immed jns immed jp immed immed jl immed immed immed jg immed table reg table reg table reg table reg reg test reg mem reg test reg mem reg reg reg reg reg mov reg mem reg mov reg mem reg mov reg reg mem mov reg reg mem mov reg mem lea reg reg mem mov reg mem pop reg mem nop ax cx ax dx ax bx ax sp ax bp ax si ax di cwd call immed wait byte opcodes continued architecture machine opcode assembler mnemonic operands mov mem mov ax mem mov mem mov mem ax test mem test ax mem aa ab ac ad ae af mov immed mov cl immed mov dl immed mov bl immed mov ah immed mov ch immed mov dh immed mov bh immed mov ax immed mov cx immed ba mov dx immed bb mov bx immed bc mov sp immed bd mov bp immed mov si immed bf mov di immed table reg table reg reg ret immed ret les reg mem mem lds reg mem mem mov reg mem immed mov reg mem immed byte opcodes continued instruction set machine opcode assembler mnemonic operands enter immed immed leave ca ret immed cb ret cc int cd int immed ce cf table reg table reg table reg table reg aam aad bx esc immed esc immed da esc immed db esc immed dc esc immed dd esc immed de esc immed df esc immed immed immed loop immed immed immed ax immed immed ax immed call immed jmp immed ea jmp immed eb jmp immed ec dx ed ax dx ee dx ef ax dx byte opcodes continued architecture machine opcode assembler mnemonic operands lock rep hlt cmc table reg table reg clc stc fa cli fb sti fc cld fd std fe table reg ff table reg byte opcodes continued index assembler mnemonic rol ror rcl rcr shl shr sar table opcodes instruction set index assembler mnemonic add adc sbb sub xor cmp table opcodes index assembler mnemonic test neg mul div idiv table opcodes index assembler mnemonic dec call call jmp jmp push table opcodes appendix program segment pre program segment pre psp byte block information apparently cp operating system adopted assist porting cp programs dos environment dun 
program loaded memory psp built rst bytes allocated memory block 
elds psp shown 
segment set description terminate vector interrupt transfer dos segment allocated reserved call vector function far call dos function request handler ah copy parent program termination handler vector eh copy parent control control break handler vector copy parent critical error handler vector reserved ch address rst paragraph dos environment eh reserved interrupt return far instruction reserved ch rst parameter command line ch second parameter command line command tail bu er psp fields terminate vector set psp warm boot terminate vector cp call vector function set psp basic disk operating system vector cp appendix executable file format dos operating system supports di executable les exe com les 
allows large programs multiple segments memory small programs segment kb maximum dun 
exe files exe le consists header load module shown 
le header consists bytes xed formatted area relocation table varies size 
load module fully linked image program information separate segments module dos ignores program segmented 
formatted area relocation table load module start le le structure exe file structure header formatted area shown 
size page bytes size paragraph bytes 
program image size calculated value formatted area di erence le size header size 
le size number le pages rounded size bytes page 
relocation table list pointers words load module adjusted 
words adjusted adding start segment address program loaded 
pointers table stored words relative start load module 
executable file format bytes description exe signature dh ah number bytes page number pages rounded number entries relocation table number paragraphs header bh minimum number paragraphs required data stack dh maximum number memory paragraphs fh pre relocated initial ss value initial sp value absolute value complemented checksum complement initial ip value pre relocated initial value cs relocation table set overlay number default com files fixed formatted area com le image program header equivalent load module exe le program loaded memory 
opposed exe programs com programs segment kb 
programs designed transport programs cp dos environment 
appendix low level high level icode mapping mapping low level high level shown pages fig ure 
dash high level icode column means high level counter part low level icode asterisk means low level icode forms part high level instruction idiom means icode ag set instruction considered cc means low level instruction sets condition code high level counterpart eliminated condition code propagation means low level icode instruction considered analysis 
instructions marked deal machine string instructions considered analysis performed dcc 
initial mapping low level high level expressed terms registers 
data ow analysis transforms instructions expressions temporary registers variables register variables 
low level high level icode mapping low level icode high level icode iadd asgn asgn call call cc cc icmc cc icmp cc idas asgn idiv asgn asgn asgn iin asgn irep ins jcond jcond jcond ija jcond jcond jcond icode opcodes low level high level icode mapping low level icode high level icode ijl jcond jcond jcond ijg jcond ijs jcond jcond ijo jcond cx jcond cx jmp jmp ilds asgn far pointer asgn near pointer ret asgn far pointer irep lods asgn irep asgn asgn asgn inop ior asgn irep outs ipop pop ipush push icode opcodes continued low level high level icode mapping low level icode high level icode ret ret isar asgn asgn iscas asgn cc cc irep isub asgn cc asgn uses tmp asgn icode opcodes continued appendix comments error messages displayed dcc cc displays series comments output assembler les information collected analysis subroutine 
information displayed subroutine 
comments supported dcc takes bytes parameters 
uses register arguments lists registers formal argument name 
takes parameters 
runtime support routine compiler 
high level language prologue code 
routine 
assembler provided 
return value register 
register provided 
pascal calling convention 
calling convention 
unknown calling convention 
incomplete due opcode incomplete due indirect jump indirect call procedure 
contains self modifying code 
contains coprocessor instructions 
irreducible control ow graph 
assembler subroutines commented dos kernel services interrupts fh 
appendix contains list dos interrupts supported dcc 
dcc displays di erent types errors fatal non fatal errors 
fatal errors terminate execution dcc displaying error information determine comments error messages displayed dcc happened 
non fatal errors cause dcc terminate treated warnings user 
fatal errors supported dcc invalid option usage dcc asm le dos executable new exe format supported 
open le error reading le invalid instruction location lx 
don understand instruction location lx 
instruction location lx goes loaded image 
malloc ld bytes failed 
failed nd basic block jump ld subroutine basic block synthetic jump 
failed nd basic block 
de nition condition code usage opcode non fatal errors supported dcc segment override memory operand location lx 
rep pre string instruction location lx 
conditional jump de nition supported opcode de nition supported 
de nition opcode opcode failed construct condition 
failed construct condition 
appendix dos interrupts dos kernel provides services application programs software interrupts fh 
interrupt deals character input output les records directory operations disk processes memory management network functions miscellaneous system functions function number held register ah 
lists di erent interrupts provided dos dun 
interrupts commented dcc producing disassembly subroutine 
dos interrupts interrupt function function name terminate process terminate process character input echo character output auxiliary input auxiliary output printer output direct console input output un ltered character input echo character input echo display string ah bu ered keyboard input bh check input status ch flush input bu er input dh disk reset eh select disk fh open le close le find rst le find le delete le sequential read sequential write create le rename le reserved get current disk ah set dta address bh get default drive data ch get drive data dh reserved eh reserved fh reserved reserved random read random write get le size set relative record number set interrupt vector create new psp random block read random block write dos interrupts dos interrupts interrupt function function name parse ah get date bh set date ch get time dh set time eh set verify ag fh get dta address get dos version number terminate stay resident reserved get set break ag reserved get interrupt vector get drive allocation info reserved get set country info create directory ah delete directory bh set current directory ch create le dh open le eh close le fh read le device write le device delete le set le pointer get set le attributes ioctl input output control duplicate handle redirect handle get current directory memory block release memory block ah resize memory block bh execute program exec ch terminate process return code dh get return code eh find rst le fh find le reserved reserved reserved reserved dos interrupts continued dos interrupts interrupt function function name get verify ag reserved rename le get set le date time get set allocation strategy get extended error info ah create temporary le bh create new le ch lock unlock le region dh reserved eh get machine name fh device redirection reserved reserved get psp address get lead byte table reserved get extended country info get set code page set handle count commit le reserved ah reserved bh reserved ch extended open le terminate handler address ctrl handler address critical error handler address absolute disk read absolute disk write terminate stay resident reserved reserved ah reserved bh reserved ch reserved dh reserved eh reserved fh print fh assign fh share fh append dos interrupts continued bibliography ac allen cocke 
graph theoretic constructs program control ow analysis 
technical report rc ibm thomas watson research center yorktown heights new york july 
ac allen cocke 
program data ow analysis procedure 
communications acm march 
allen 
control ow analysis 
sigplan notices july 
allen 
basis program optimization 
proc 
ifip congress pages amsterdam holland 
north holland pub allen 
interprocedural data ow analysis 
proc 
ifip congress pages amsterdam holland 
north holland pub am ashcroft manna 
translation go programs programs 
technical report stanford university department computer science 
asu aho sethi ullman 
compilers principles techniques tools 
addison wesley publishing 
asu aho sethi ullman 
compilers principles techniques tools chapter pages 
addison wesley publishing 
bak baker 
algorithm structuring 
journal acm january 
bar 
piler system computer program translation 
technical report probe consultants september 
bb bowen breuer 
decompilation techniques 
internal esprit redo project tn prg version oxford university computing laboratory road oxford ox qd march 
bb breuer bowen 
decompilation enumeration types grammars 
technical report prg tr oxford university computing laboratory road oxford ox qd 
bb breuer bowen 
decompilation enumeration types grammars 
appear transaction programming languages systems 
bb breuer bowen 
generating decompilers 
appear information software technology journal 
bibliography bbl bowen breuer lano 
redo project final report 
technical report prg tr oxford university computing laboratory road oxford ox qd december 
bbl bowen breuer lano 
compendium formal techniques software maintenance 
software engineering journal pages september 
bj bohm 
flow diagrams turing machines languages formation rules 
communications acm may 
bor borland 
borland version user guide 
borland international green hills road valley ca 
bow bowen 
programs object code logic logic programming 
giegerich graham editors code generation concepts tools techniques workshops computing pages dagstuhl germany may 
springer verlag 
bow bowen 
programs object code back logic programming compilation decompilation 
journal software maintenance research practice 
bp 
decompilation polish code basic 
di informatica october 
bp bert 
decompiling context free languages representations 
pages 
bri 
transportation assembly language software decompilation 
technical report naval underwater systems center october 
bri 
exe october 
bz baker zweben 
comparison measures control ow complexity 
ieee transactions software engineering se november 
cal 
disassembler 
public domain software 
anonymous ftp oak oakland edu md zip 
callahan carle hall kennedy 
constructing procedure call multigraph 
ieee transactions software engineering april 
cg cifuentes gough 
methodology decompilation 
proceedings xix de informatica pages buenos aires argentina august 
centro de en informatica 
bibliography cg cifuentes gough 
decompilation binary programs 
technical report faculty information technology queensland university technology brisbane australia april 
appear software practice experience 
chr christensen 
resource 
public domain software 
anonymous ftp oak oakland edu res zip 
translated larry etienne 
cif cifuentes 
structuring algorithm decompilation 
proceedings xix de informatica pages buenos aires argentina august 
centro de en informatica 
cif cifuentes 
interprocedural data ow decompilation 
technical report faculty information technology queensland university gpo box brisbane australia april 
submitted journal programming languages 
cif cifuentes 
structuring decompiled graphs 
technical report faculty information technology queensland university gpo box brisbane australia april 
submitted computer journal 
cob cobol decompiler 
midrange systems july 
coc cocke 
global common subexpression elimination 
sigplan notices july 
col perry cole 
ansi fortran iv structured programming approach 
wm brown boulevard iowa edition 
com communications 
commenting disassembler instruction set support 
communications stevens creek blvd suite san jose ca 
coo cooper 
bohm reduction ow charts 
communications acm august 
coo cooper 
standard pascal user manual 
norton fifth avenue new york edition 
dav davis 
computability unsolvability chapter pages 
mcgraw hill 
dod american national standards institute department defense washington dc usa 
manual ada programming language ansi mil std february 
ds dorsey su 
decompilation cobol dml programs purpose program conversion 
proceedings compsac 
ieee computer society sixth international computer software applications conference pages chicago usa november 
ieee 
bibliography dudley 
recursive decompiler 
forth dimensions jul aug 
dun duncan 
advanced programming 
microsoft press ne th way box redmond washington edition 
dun duncan 
encyclopedia chapter pages 
microsoft press 
dz 
de nition optimization technique code translation algorithm 
communications acm january 
eh hendren 
taming control ow structured approach eliminating goto statements 
technical report acaps technical memo school computer science mcgill university university st montreal canada september 
van emmerik 
signatures library functions executable les 
technical report faculty information technology queensland university technology gpo box brisbane australia april 
fj fischer leblanc jr crafting compiler 
benjamin cummings sand hill road menlo park california 
fj fischer leblanc jr crafting compiler chapter pages 
benjamin cummings sand hill road menlo park california 
flu 
art disassembly getting source problem object data 
micro march april 
fre french 
private communication 
email 
fri friedman 
decompilation transfer mini computer operating systems 
phd dissertation purdue university computer science august 
fz 
function recognition technique implementation decompiling system 
mini micro systems 
li 
design implementation techniques decompiling system 
mini micro systems 
gaines 
translation machine language programs 
communications acm december 
gar 
selective disassembly rst step developing virus lter 
fourth aerospace computing security appl conference pages december 
bibliography gcc gough cifuentes kolb 
experiment mixed compilation interpretation 
gupta keen editors proceedings fifteenth australian computer science conference pages university hobart australia january 
australian computer society 
gd 
version 
public domain software 
anonymous ftp oak oakland edu zip 
gl goldschlager 
computer science modern 
prentice hall international 
gou gough 
syntax analysis software tools 
addison wesley publishing reading 
gou gough 
private communication 
gut 
exe 
news item comp compilers usenet newsgroup apr 
gut 
exe 
news item comp compilers usenet newsgroup apr 
gut 
private communication 
austin code works lane austin tx dec 
hal halstead 
machine independent computer programming chapter pages 
spartan books 
hal halstead 
machine independence third generation computers 
proceedings sprint joint computer conference pages 
hal halstead 
computer program conversion 
datamation pages may 
hec hecht 
flow analysis computer programs 
elsevier north holland vanderbilt avenue new york new york 
hh halstead 
methodology machine language decompilation 
technical report rj purdue university department computer science december 
heiser hanson everett schwartz 
feedback 
data advisor june 
hk hall kennedy 
cient call graph analysis 
letters programming languages systems september 
hm horspool 
approach problem computer programs 
computer journal 
hm hills 
revisited recursive decompiler 
forth dimensions mar apr 
bibliography hol hollander 
decompilation object programs 
phd dissertation stanford university computer science january 
hoo hood 
decompiling de nite clause grammars 
technical report erl rr electronics research laboratory australia po box salisbury south australia september 
hop 
decompilation 
phd dissertation university california irvine computer science 
hou 
study decompiling machine languages high level machine independent languages 
phd dissertation purdue university computer science august 
hu hecht ullman 
flow graph reducibility 
siam journal computing june 
hu hecht ullman 
characterizations reducible ow graphs 
journal acm july 
hu hecht ullman 
simple algorithm global data ow analysis problems 
siam journal computing december 

design implementation intermediate language pc decompiler system 
mini micro systems 
int intel 
user manual 
intel bowers avenue santa clara ca 
int intel 
programmer manual 
intel bowers avenue santa clara ca 
kf knuth floyd 
notes avoiding go statements 
information processing letters 
knu knuth 
structured programming go statements 
computing surveys december 
kos kosaraju 
analysis structured programs 
journal computer system sciences 
kr kernighan ritchie 
programming language 
prentice hall englewood cli edition 
kw katz wong 
decompiling dml relational queries 
acm transactions database systems march 
lg liu gibson 
microcomputer systems family 
prentice hall international new jersey edition 
bibliography lic 
decompilation control structures means graph transformations 
proceedings international joint conference theory practice software development tapsoft berlin 
lic 
recognizing rooted context free languages polynomial time 
rozenberg ehrig kreowski editor graph grammars application computer science number lecture notes computer science pages 
springer verlag 
lm 
genealogy control structures 
communications acm november 
mak 
intelligent disassembler version 
public domain software 
anonymous ftp oak oakland edu id zip 
may may simple decompiler 
dr dobb journal pages june 
mic microsoft 
mixed language programming guide 
microsoft ne th way box redmond wa 
marshall bach richardson 
functional mapping microprocessor system simulation 
proceedings ieee microprocessor forum atlantic city apr 
ieee piscataway pp 

unravelling unstructured programs 
computer journal 
tools utilities 
dbms june 
pla programming languages systems group queensland university gpo box brisbane qld australia 
gardens point modula 
pw 
demonstrating equivalence source code prom contents 
computer language 
ram ramshaw 
eliminating go preserving program structure 
journal acm october 
ray raymond 
plum hall benchmarks 
url ftp plaza edu au usenet comp sources unix volume plum benchmarks gz 
reu reuter 
url ftp cs washington edu pub decomp tar public domain software 
reu reuter 
private communication 
email 
ryder 
constructing call graph program 
ieee transactions software engineering may 
sas 
computer program translate machine language fortran 
proceedings pages 
bibliography sites cherno kirk marks robinson 
binary translation 
communications acm february 
sha sharir 
structural analysis new approach ow analysis optimizing compilers 
computer languages 
sof rh factor software 
bubble chamber installation 
public domain software beta release 
anonymous ftp oak oakland edu bubble zip 
sw schneider 
translation grammars compilation decompilation 
bit 
sw srivastava wall 
practical system intermodule code optimization link time 
journal programming languages march 
tar tarjan 
depth rst search linear graph algorithms 
siam journal computing june 
tar tarjan 
testing ow graph reducibility 
journal computer system sciences pages september 
unc guide add ons 
data advisor august 
val slicing source code 
data advisor march 
wg williams chen 
restructuring pascal programs containing goto statements 
computer journal 
wil williams 
generating structured ow diagrams nature 
computer journal 
wir wirth 
programming modula 
springer verlag berlin heidelberg edition 
wo williams ossher 
conversion unstructured ow diagrams structured form 
computer journal 
wor 
language design decompilation 
technical report university florida december 
wor austin code works 
exe 
release 
email info acw com 
yoo yoo 
approach transportation computer software 
information processing letters september 
zan van zandt 
interactive disassembler version 
public domain software 
anonymous ftp oak oakland edu dis zip 
