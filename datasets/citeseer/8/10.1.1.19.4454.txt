tr idsia version arxiv cs ai july optimal ordered problem solver urgen schmidhuber idsia lugano switzerland juergen idsia ch www idsia ch juergen novel general optimally fast incremental way searching universal algorithm solves task sequence tasks 
optimal ordered problem solver oops continually organizes exploits previously solutions earlier tasks eciently searching space domain speci algorithms space search algorithms 
essentially extend principles optimal nonincremental universal search build incremental universal learner able improve experience 
initial bias embodied task dependent probability distribution possible program pre xes 
pre xes self delimiting executed online fashion generated 
compute probabilities possible continuations 
denote pre solving rst tasks 
may exploit previously stored solutions calling subprograms copying editing copies applying 
provide equal resources searches run parallel discovered stored 
rst search exhaustive systematically tests possible pre xes tasks 
second search focused searches pre xes start tests task safe know pre xes solve tasks searches depth rst bias optimal branches search trees program pre xes backtracking triggered sum runtimes current pre current tasks exceeds pre probability multiplied total search time far 
illustrative experiments self rst general system learns solve disk towers hanoi tasks solution size pro ting previously solved simpler tasks involving samples simple context free language 
keywords oops bias optimality incremental optimal universal search metalearning self improvement guide important sections possibly interested experiments 
sections illustrated 
frequently symbols collected table general oops related symbols table important implementation speci symbols explained appendix section 
contents basic ideas concepts overview brief optimal search universal search quickly verifiable solutions 
asymptotically fastest nonincremental problem solver 
optimal search bias optimality 
incremental search 
optimal ordered problem solver oops basic setup notation 
prerequisites multitasking prefix tracking try 
overview try 
details try 
oops finding universal solvers 
near bias optimality oops 
expect profit earlier tasks 
oops variants 
fundamental limitations oops 
example initial programming language 
experiments task specific initialization 
towers hanoi problem 
task representation domain specific primitives 
solve simpler tasks context free language 
code 
experimental results task sets 
discussion results 
physical limitations oops 
appendix example programming language data structures tapes 
primitive instructions 
basic data stack related instructions 
control related instructions 
bias shifting instructions modify search probabilities initial user defined programs examples 
basic ideas concepts overview oops simple general theoretically sound time optimal way searching universal behavior program solves problem problem sequence continually organizing managing reusing earlier acquired knowledge 
example th problem may compute th event previous events prediction nd faster way maze search solution th problem optimization 
primitives 
start initial set user de ned primitive behaviors 
primitives may assembler instructions time consuming software say theorem provers matrix operators neural network parallel architectures trajectory generators robot simulations state update procedures multiagent systems primitive represented token 
task specific prefix codes 
complex behaviors represented token sequences programs 
solve task try sequentially compose appropriate complex behavior primitive ones obeying rules user de ned initial programming language 
programs grown incrementally token token beginnings pre xes immediately executed created may modify task speci internal state memory may transfer control back previously selected tokens 
add new token program pre rst wait execution pre far explicitly requests prolongation setting appropriate signal internal state 
obtain task speci pre codes program space task programs halt solution encountered error request tokens 
current task halting program pre 
di erent task program may continue request additional tokens important novel approach 
access previous solutions 
denote pre solving rst tasks 
search may greatly pro information conveyed stored special non modi able memory shared tasks accessible example execute token sequence calls subprogram copies internal task speci memory modi es copy bit applies slightly edited copy current task 
fact knowledge embodied may access edit older 
bias 
searcher initial bias embodied initial user de ned task dependent probability distributions nite nite search space possible program pre xes 
simplest case start maximum entropy distribution tokens de ne pre probabilities products probabilities tokens 
pre continuation probabilities may depend previous tokens context sensitive fashion 
self computed continuation probabilities 
fact permit executed pre halting programs pre xes computes task dependent probability distribution possible continuations stored updated task speci internal memory 
say invoking previously frozen code rede nes probability distribution pre continuations currently tested pre may completely reshape paths search space continuations experience ignored levin hutter nonincremental optimal search methods 
may introduce signi cant problem class speci knowledge derived solutions earlier tasks 
searches 
novel oops provides equal resources near bias optimal searches see run parallel discovered stored 
rst exhaustive systematically tests possible pre xes tasks 
alternative pre xes tested current tasks parallel growing task solved remove current set pre xes fail single task discarded 
second search focused searches pre xes start tests task safe know pre xes solve tasks bias optimal backtracking 
searches oops alternative pre continuations evaluated novel practical token oriented backtracking procedure ensures near bias optimality candidate behavior gets time deserves bias 
means total time spent generating testing behavior signi cantly exceed probability times total search time far 
essentially conduct depth rst search program space branches search tree program pre xes backtracking triggered sum runtimes current pre current tasks exceeds pre probability multiplied total time far 
describe ecient implementation oops broad variety initial programming languages 
features miniature multitasking operating system tracks ects tested pre xes partially solved task sets modi cations internal states continuation probabilities able backtrack reset ects optimally ecient fashion subsequent tests alternative pre continuations 
case unknown nite task sequences typically know optimal solver tasks sequence 
unwittingly nd half total run time wasted searching alternatives 
initial bias subsequent bias shifts due bias optimal searcher expect solve th task set substantially faster oops 
byproduct optimality property gives natural precise measure bias bias shifts conceptually related solomono conceptual jump size 
example initial language 
illustrative application wrote interpreter stack universal programming language inspired forth initial primitives de ning calling recursive functions iterative loops arithmetic operations domain speci behavior 
optimal better search algorithms enabled inclusion bias shifting instructions modify conditional probabilities search options currently running program pre xes 
experiments 
rst teach oops recursion training construct samples simple context free language 
takes roughly days standard personal computer pc 
additional days exploiting aspects previously discovered universal solver oops learns universal solver disk towers hanoi problems solving instances shortest solution search 
costs moves 
previous reinforcement learners ai planners tend fail solution sizes exceeding respectively 
conclude outlook physical limitations oops 
brief optimal search section rst brie review general asymptotically optimal nonincremental search methods levin hutter introduce concept bias optimal search probabilistic bias 
point existing methods incremental search limited search spaces bias optimal 
remainder ers way overcoming 
universal search quickly verifiable solutions surprisingly books search algorithms mention simple asymptotically optimal algorithm problems quickly veri able solutions method lsearch problem universal turing machine steps average execute instruction th binary string interpreted program alphabetical list strings nds solution 
problem class unknown optimal program requires steps solve problem instance size happens th program alphabetical list lsearch levin search need steps constant factor may huge depend compare 
asymptotically fastest nonincremental problem solver hutter developed complex asymptotically optimal search algorithm de ned problems 
hutter search cleverly allocates part total search time searching space proofs provably correct candidate programs provable upper runtime bounds time focuses resources programs currently best proven time bounds 
unexpectedly manages reduce constant slowdown factor value smaller 
fact smaller arbitrary positive constant hutter personal communication 
unfortunately search proof space introduces unknown additive problem class speci constant slowdown may huge 
additive constants generally multiplicative ones types may universal search methods practically infeasible 
optimal search bias optimality real world constants matter 
cross nish line olympic dash may constant factor slower winner comfort 
constants sense universe lsearch may viewed academic exercises demonstrating notation practically irrelevant despite wide theoretical computer science 
lsearch provide inspiration practical methods optimal respect limited search space su ering small slowdown factors 
example designers planning procedures just face binary choice options depth rst breadth rst search 
greater demand storage may eventually require move data chip memory disk 
slow search factor 
straightforward solution spirit lsearch start bias technique depth rst breadth rst search parallel cause slowdown factor respect best options ignoring bit overhead parallelization 
generalizing example de ne probability distribution nite nite set programs 
represents searcher initial bias 
bias optimal searcher spend time solution candidate deserves bias de nition bias optimal searchers problem set search space solution candidates problem solution bias form conditional probability distributions candidates prede ned procedure creates tests time typically unknown advance 
searcher bias optimal maximal total search time max guaranteed solve problem solution satisfying max bias optimal 
de nition intuitive sense probable candidates get lion share total search time way precisely re ects initial bias 
example set problems quickly veri able solutions arbitrary user de ned quickly computable probability distribution programs universal turing machine program length conditioned problems lsearch bias optimal may huge precise slowdown factor depends arbitrary lexicographical order ignoring bias method near bias optimal compare solomono 
simplicity notationally suppress conditional dependencies current problem method set current time limit 
problem solved test programs maximal time spent creating running testing satis es set near bias optimality hardly ected fact value repeat certain computations previous value 
roughly half total search time spent maximal value ignoring hardware speci overhead parallelization nonessential speed ups due halting programs 
nonbinary variants solve machine learning toy problems unsolvable traditional methods 
probabilistic alternatives probabilistically chosen maximal program runtimes speed prior style outperformed traditional methods certain toy problems 
incremental search 
newell simon early attempts building general problem solver done develop heuristic machine learning algorithms solve new problems experience previous problems incrementally shifting inductive bias 
pointers learning chunking learning macros hierarchical learning learning analogy mitchell book 
relatively general attempts include program olsson simpler heuristics genetic programming gp 
logic program synthesizers program biology inspired concepts evolutionary computation genetic algorithms evolve better better computer programs 
existing gp implementations allow programs loops recursion ignoring main motivation search program space 
limited search spaces solution candidate runtime issue far bias optimal 
similarly traditional reinforcement learners general close bias optimal 
lsearch sections nonincremental sense attempt minimize constant slowdowns exploiting experience collected previous searches 
simply ignore constants asymptotic point view incremental search buy 
practical applications may ignore constants 
heuristic attempt greatly reduce experience called adaptive lsearch als compare solomono related ideas 
essentially als works follows nds program computes solution current problem probability substantially increased learning rate probabilities alternative programs decrease appropriately 
subsequent new problems adjusted variant approach able solve reinforcement learning rl tasks partially observable environments unsolvable traditional rl algorithms 
invoked als bias optimal respect adjustment hand arbitrary modi cations necessarily optimal 
may quickly distort initial bias provoke loss optimality respect initial bias exposure subsequent tasks 
contribution overcome drawback principled way 
method draws inspiration previous publications learning learn metalearning goal learn better learning algorithms human intervention compare lenat human assisted self 
particular concept incremental search improved probabilistically generated code modi es probability distribution possible code continuations incremental self success story algorithm ssa undo self generated probability modi cations long run contribute increasing learner cumulative reward time interval 
earlier meta gp algorithm designed learn better gp strategies 
combined holland principles reinforcement learning economies self referential metalearning approach 
gradient metalearning technique continuous program spaces di erentiable recurrent neural networks rnns designed favor better learning algorithms compare remarkable success hochreiter related technically improved rnn 
algorithms generally near bias optimal 
method discussed combines optimal search incremental self improvement informally proposed author previous snf applications bias optimal small practically acceptable number 
optimal ordered problem solver oops oops depends self delimiting behaviors programs beginnings executed soon generated 
programs unnecessary asymptotic optimality properties lsearch 
binary self delimiting programs studied context turing machines theory kolmogorov complexity algorithmic probability 
practical necessarily binary framework exclude long programs high probability 
subsection introduce notation 
subsection introduce practical method eciently tracking restoring ects due online execution program pre xes self generated continuation probabilities written possible initial programming languages eciently searching pre solving multiple tasks parallel code bias form previously code 
subsection describe solutions new tasks may optimally exploit knowledge conveyed solutions previous tasks search universal programs solving tasks seen far 
basic setup notation stated obvious simplify notation newly introduced variables assumed integer valued cover range implicit context 
nite countably nite alphabet fq denote set nite sequences strings empty string 
possibly variable strings 
denotes number symbols string th symbol string 
concatenation abc dac 
consider countable alphabets strings represent possible internal states computer strings represent token sequences code programs manipulating states 
focus set integers nq representing set nq instructions programming language 
rst universal programming language due odel integers practical 
nq may variable new tokens may de ned combining previous tokens just traditional programming languages allow declaration new tokens representing new procedures 
substrings states may encode programs 
symbol description variable set instructions tokens th possible token integer nq current number tokens set strings alphabet containing search space programs total current code th token code th frozen program total code starts qp pointer highest address code qp start address program pre solving tasks far frozen top frozen address grow frozen qp frozen current code bias variable set tasks ordered cyclic fashion task computation tape set possible tape symbols integers set strings alphabet de ning possible states stored tapes element variable state task stored tape th component length string equal equal ip current instruction pointer task encoded tape state variable probability distribution encoded tape part current history dependent probability selecting ip qp table symbols explain basic principles oops section 
set currently unsolved tasks 
variable denote current state task th component computation tape separate tape holding separate state task 
subsequences tapes may represent executable code convenience combine current code current state single address space introducing negative positive addresses ranging de ning content address 
dynamic task speci data represented nonpositive addresses code tasks 
particular current instruction pointer ip ip task possibly variable address ip 
furthermore encodes modi able probability distribution fp nq current values variable distribution select new instruction case ip points rst unused address right current code frozen variable address increase decrease 
chosen code bias frozen remain forever possibly empty sequence programs user frozen previous successful searches solutions previous task sets possibly completely unrelated current task set 
current goal solve tasks single program appropriately uses extends current code frozen additional freezing take place tasks solved 
near bias optimal fashion def 
solution candidate get search time deserves initial probabilistic bias program space prerequisites multitasking prefix tracking try turing machine setups lsearch assume potentially nite storage 
may largely ignore questions storage management 
practical system eciently reuse limited storage 
multitasking subsection 
recursive method try allocates time program pre xes tested multiple tasks simultaneously sum runtimes pre tested tasks exceed allocated total search time multiplied pre probability product tape dependent probabilities previously selected pre components 
overview try consider left hand side 
instruction pointers ip current tasks initialized address typically topmost code address accessing code bias common tasks task speci code fragments written tapes 
tasks keep executing instructions parallel interrupted tasks solved task instruction pointer points unused address right topmost code address 
case interpreted request code prolongation new token token probability task current state encoded distribution possible tokens 
deterministic method try systematically examines possible code extensions depth rst fashion probabilities pre xes just order runtime allocation 
interrupts backtracking previously selected tokens untested alternatives corresponding partial resets states task sets take place tasks encounters error product task dependent probabilities currently selected tokens multiplied sum runtimes tasks exceeds total search time limit allow ecient backtracking try tracks ects tested program pre xes task speci state modi cations including probability distribution changes partially solved task sets reset conditions subsequent tests alternative untested pre continuations optimally ecient fashion expensive pre tests 
programs created online executed try create impossible programs halt tokens read 
program halts task pre program halting task 
important see setup pre solved task removed current task set may continue demand tokens tries solve tasks 
details try allow eciently undo state changes global boolean variables mark initially false possible state components 
initialize time probability pointer qp frozen state including ip task speci information task names called ring tasks expression ring indicates tasks ordered cyclic fashion denotes number tasks ring global search time limit try solve tasks existing code qp discovering appropriate prolongation method boolean try qp returns true false may side ect increasing frozen prolonging frozen code frozen 
empty stack set local variables done false 
unsolved tasks time left pt instruction pointer valid ip qp instruction valid ip nq halt condition encountered error division robot bumps obstacle evaluate conditions order rst satis ed interpret execute token ip rules programming language continually increasing consumed time 
may modify including instruction pointer ip distribution code execution changes state component mark false set mark true save previous value pushing triple remove solved 
set equal task ring round robin method standard operating systems 
set done true frozen qp tasks solved new code frozen 

eciently reset modi ed mark false global mark variables needed step pop 

ip qp online request prolongation current pre new token done false untested token untried value qp set qp done try qp probability current distribution 

eciently restore changed restoring tapes states current invocation try 
restore instruction pointer ip original search distribution 
return value done 
planning terminology try conducts depth rst search program space branches search tree program pre xes modifying bunch task speci states backtracking triggered sum runtimes current pre current tasks exceeds pre probability multiplied total current time limit 
successful try solve tasks possibly increasing frozen prolonging total code case try completely restore states tasks 
wastes time recomputing previously computed results pre xes restoring unmodi ed state components marks currently irrelevant tasks tracking undoing ects pre xes essentially cost execution 
def 
bias optimality greatly ected undoing procedure lose factor ignoring hardware speci overhead costs single push pop operations computer costs measuring time distributions modi able speak self generated continuation probabilities 
variable sux frozen qp total code qp growing probability readily updated qp frozen initial state probability state task variable distribution part determine probability token moment selected 
allow probability qp depend qp intial state fairly arbitrary computable fashion 
note traditional turing machine setup yielding binary programs probability framework self generated continuation probabilities allows token selection probabilities close long programs may high probability 
example 
programming languages probability token previous token equals 
having observed lot new code execute cases rules programming language typically demand increment instruction pointer ip lead request token subsequent increment topmost code address 
observed complete expression form condition action may take long time conditional loop interpreted ip exited top address incremented asking new token 
round robin try variant keeps circling unsolved tasks executing instruction time 
alternative try variants sequentially task solved try prolong resulting task appropriately restoring previous tasks turns current task solved prolongation pre solving earlier tasks 
potential advantage round robin try quickly discover currently studied pre causes error task case discarded immediately 
nonrecursive code 
ecient iterative nonrecursive version try broad variety initial programming languages implemented local stacks single global stack save restore old contents modi ed cells tapes tasks 
oops finding universal solvers suppose ordered sequence tasks 
task may may depend solutions instance optimization context task may nd faster way maze search solution task task may just predict th symbol sequence 
instruction set contain instructions invoking calling code frozen copying code editing copies executing results 
examples instructions appendix section 
searching single program solves tasks encountered far 
th problem solve set rst tasks 
example want teach system program computes fac naturally th task training sequence compute fac 
program solves tasks may universal solver arbitrary inductively suppose solved rst tasks programs stored address frozen discovered program starting address frozen solves possibly information conveyed earlier programs 
nd program solving rst tasks oops invokes try follows set notation task rings tasks ordered cyclic fashion method oops initialize current time limit pointer qp frozen top frozen address 

set instruction pointer ip start address code solving tasks 
try qp fr exit 
means half search time assigned frozen possible prolongations thereof 

possible initialize tasks time set local variable frozen rst unused address fr set ip try qp fr set exit 
means half time assigned new programs fresh starts 

set go 
spend roughly equal time simultaneous searches 
second step exhaustive considers tasks possible pre xes programs starting topmost frozen address 
rst step focuses task pre starting address possible continuations frozen particular increase long new tasks comparatively quickly solved prolonging frozen justi ed 
code frozen altered solve tasks request additional tokens harm performance previous tasks 
know induction prolongations solve tasks tasks rst initialize invoke oops nd programs starting possibly increasing address solving tasks far possibly eventually discovering universal solver tasks sequence 
address increases th time de ned program starting old value right new value 
program may exploit calling subprogram copying state editing inserting parts executing edited variant 
near bias optimality oops oops asymptotically optimal levin sense see method near bias optimal def 

see consider program solving current task set steps current code bias frozen denote probability compare eq 
method simplicity omit obvious conditions 
bias optimal solver nd solution steps 
observe oops nd solution steps ignoring bit hardware speci overhead marking changed tape components measuring time switching tasks compare section factor lost allocating half search time prolongations code factor incremental doubling necessary know advance best value factor try resets states tasks 
method essentially ignoring hardware issues respect current task 
want ignore hardware issues currently widely computers realistically expect su er slowdown factors smaller acceptable values say 
changes bias bias shifts occur searches due freezing code solved tasks task set 
learning rate bias shifts als section oops reduce probabilities programs meaningful executable addition new consider meaningless interrupted program pre xes trying access code earlier solutions weren pre xes may suddenly successful solutions earlier tasks stored 
als acceleration potential oops bought risk unknown slowdown due nonoptimal changes underlying probability distribution heuristically chosen learning rate 
new tasks come oops remains near bias optimal respect initial bias able greatly pro subsequent code bias shifts 
advantages oops materialize probable fast solvers current task set previously code 
ideally identical frozen code 
alternatively may short uses information conveyed earlier programs stored frozen example may call earlier stored subprogram 
short fast program copies large state modi es copy just little bit obtain successfully applies clearly times faster oops general su er smaller constant slowdown factor nonincremental asymptotically optimal search precisely re ecting extent solutions successive tasks share useful mutual information set primitives copy editing 
nonincremental lsearch require online generated programs asymptotic optimality properties oops depend programs say invoking previously frozen code rede nes probability distribution pre continuations currently tested pre may completely reshape directions search space continuations experience ignored lsearch 
may introduce signi cant problem class speci knowledge derived solutions earlier tasks 
clearly advantages online search space modi cations exploited ine procedures just alphabetically list possible program candidates possibly including invalid ones self delimiting pre xes 
solve tasks collecting freezing generally harder harder identify address copy edit useful code segments earlier solutions 
consequence expect knowledge embodied certain access edit programs previously stored optimal problem solver problem current code bias frozen start address information starts ends previously frozen programs total search time frozen solving de ne degree bias frozen frozen compare solomono concept conceptual jump size 
expect profit earlier tasks 
learner pro earlier solutions 
rst naive glance possible pairs symbol strings problemsolving programs share algorithmic information 

possible combinations strings algorithmically incompressible shortest algorithm computing size shortest algorithm computing typically bit symbols means tell 
papers evolutionary computation mention free lunch theorems variations ancient insight theoretical computer science 
typically successive real world problems sampled uniform distribution large set possible problems 
tend closely related 
particular teachers usually provide sequences complex tasks similar solutions 
problem sequences humans consider interesting atypical compared arbitrary sequences de ned problems 
fact exaggeration claim entire eld computer science focused comparatively atypical problem sets exploitable regularities 
interesting problems consideration previous justi ed extent interestingness implies relatedness known 
obviously oops procedures advantageous relatedness exist 
case harm 
oops variants searching universal solver just intend solve task reduced variant oops replaces step method 
set frozen set ip try qp fr set exit 
similar oops variants nd program solves say just tasks oops variants assign half total time code prolongations thereof 
oops variants assign fractions total time second program prolongations third program prolongations may consider probabilistic oops variants speed prior style 
necessarily useful idea suppose number tasks solved single program known advance 
think oops variant works tasks parallel spending half search time programs starting half programs starting frozen tasks solved prolongation frozen usually know advance task remove current task ring freeze code generated far increasing frozen contrast try freeze programs entire current task set solved 
turns tasks solved program starting start scratch searching programs starting frozen 
unfortunately general guarantee approach early freezing converge 
fundamental limitations oops appropriate task sequence may help oops reduce slowdown factor plain experience 
single task oops invent appropriate series easier subtasks solutions frozen rst 
course oops may search general algorithm space programs execute may viewed self generated subgoal de subtask solvers 
single task incentive freeze intermediate solutions original task solved 
potential speed oops stem exploiting external information encoded ordered task sequence 
motivates name 
nal task badly chosen training sequence intermediate tasks may cost search time required solving just nal task intermediate tasks 
oops designed environments 
environments looses theoretical foundation heuristic method 
example possible oops designing optimal trajectories robot arms virtual simulations 
working real physical robot may guarantee able precisely reset required backtracking procedure try 
oops neglects source potential speed predict tasks previous ones currently spend fraction time solving predicted tasks 
optimal universal reinforcement learner hutter aixi model 
research lead marriage asymptotically optimal aixi near bias optimal oops 
example initial programming language ecient search backtracking mechanism described section designed broad variety possible programming languages possibly list oriented lisp matrix operations recurrent neural network parallel architectures 
alternatives possible 
language represented set initial tokens 
token corresponds primitive instruction 
primitive instructions computer programs manipulate tape contents composed oops complex programs result 
principle primitives large time consuming software say traditional ai planners theorem provers multiagent update procedures learning algorithms neural networks represented tapes 
instruction unique number nq numbers associated exactly instruction 
initial knowledge bias introduced writing appropriate primitives adding step procedure try see section translates instruction number back corresponding executable code particular implementation pointer function 
presently executed instruction directly ect instruction pointer ip conditional jump call function return function call ip simply incremented 
choice programming language initial primitives typically write new interpreter scratch existing 

procedure try section needs total control usually hidden inaccessible aspects storage management including garbage collection storage clean wake executed tested pre xes suboptimal 
experiments section wrote interpreter example universal programming language inspired forth praise beauty compactness programs 
appendix section describes details 
data structures tapes section manipulated primitive instructions listed sections 
section shows user may compose complex programs primitive ones insert total code user declared programs nq remain xed 
experiments experiments tell usefulness particular initial bias incorporated particular programming language particular initial instructions 
follows describe illustrative problems results obtained forth inspired language speci ed appendix section 
consulted details instructions appearing programs oops 
explaining learning system setup try identify hidden sources initial bias 
task specific initialization initial primitive instructions sections appendix user de ned complex tokens declared section 
total initial non task speci primitives 
task add task speci instructions 
experiments provide probabilistic syntax diagram de ning conditional probabilities certain tokens previous tokens 
simply start maximum entropy distribution nq tokens initializing probabilities nq setting sum nq compare section 
note instruction numbers signi cantly ect initial bias 
instruction numbers particular small ones computable short programs 
general programs consisting instructions easily computable initial arithmetic instructions section tend probable 
similarly number frozen programs grows higher addresses general harder access address computation may require longer subprograms 
experiments insert substantial prior bias assigning lowest easily computable instruction numbers task speci instructions boosting see instruction section appropriate small number compare section push data stack ds numbers task speci instructions executable part code ds 
boost simple arithmetic instructions multiply top stack element dec decrement top stack element system easily create integers probable ones 
example boosts code sequence dec returns integer 
express initial belief occasional usefulness previously useful instructions boosting 
numbers represent maximal values enforced experiments state size absolute tape cell contents number self functions self search patterns probability distributions tape pointer data stack pointers 
towers hanoi problem disks di erent sizes stacked decreasing size rst pegs 
may move peg top disk top peg disk time larger disk smaller 
goal transfer disks third peg 
remarkably fastest way solving famous problem requires moves 
problem reward goal type instance size intermediate reward achieving instance speci subgoals 
exponential growth minimal solution size problem interesting brute force methods searching raw solution space quickly fail increases 
rapidly growing solutions common short algorithm generates 
smart searchers exploit algorithmic regularities 
searching general algorithm space essential eciently allocate time algorithm tests 
oops near bias optimal incremental fashion 
untrained humans nd hard solve instances 
anderson applied traditional reinforcement learning methods able solve instances solvable moves 
langley learning production systems able solve instances solvable moves 
side note baum applied alternative reinforcement learner holland arti cial economy simpler peg blocks world problem disk may placed required number moves grows linearly number disks exponentially able replicate results 
traditional ai planning procedures chapter learn systematically explore possible move combinations absolutely necessary task speci primitives oops general instructions unnecessary 
current personal computers ai planners tend fail solve hanoi problem instances due exploding search space koehler ibm research personal communication 
oops searches program space raw solution space 
principle able solve arbitrary instances discovering problem elegant recursive solution pegs source peg auxiliary peg destination peg de ne procedure hanoi exit call hanoi move top disk call hanoi 
task representation domain specific primitives th problem solve hanoi instances instance general rule represent dynamic environment task th task tape allocating addresses peg store order sizes current disks pointer top disk isn 
represent pegs numbers respectively 
instance size push data stack ds values doing insert substantial nontrivial prior knowledge fact useful represent peg symbol know problem size advance 
task completely de ned values just useful primitive instructions added programming language section instruction assumes represented rst elements data stack ds current base pointer cs cp base section 
operates obvious fashion moving disk peg peg instruction exchanges representations combinations may create arbitrary peg patterns 
illegal moves cause current program pre halt 
success easily veri able objective achieved rst pegs empty 
solve simpler tasks context free language despite near bias optimality oops reasonable time week personal computer system able solve instances involving disks 
mean 
search time optimal searcher natural measure initial bias just means non negligible bias task set weak 
gives opportunity demonstrate oops pro incremental learning abilities 
follows rst train additional easier tasks teach recursion hoping resulting code bias shifts help solve hanoi tasks 
purpose seemingly unrelated problem class context free language input data stack ds goal place symbols auxiliary stack ds topmost elements followed 
intermediate reward achieving instance speci subgoals 
executed instruction test objective achieved 
de nition time cost test measured unit time steps section equals number considered elements ds 
example test may expensive instance size 
add instructions initial programming language instruction tod pushes ds instruction tod pushes 
total task speci instructions including hanoi instruction numbers tod tod respectively gives total initial instructions 
rst boost section small number section rst training phase th task solve problem instances undo speci boosts boost hanoi speci instruction number subsequent training phase th task solve hanoi instances code implemented dozen pages code written comments documentation multitasking storage management iterative variant round robin try section interpreter basic instructions section simple user interface complex declarations section applications problems section hanoi problems section 
current implementation considers discrete unit time steps second shelf pc ghz 
experimental results task sets roughly days oops code solving tasks 
additional days universal hanoi solver 
instructive study sequence intermediate solutions 
follows transform integer sequences discovered oops back readable programs compare instruction details section 

problem second time steps oops non general working code tod 

time solved nd instance simply prolonging previous code old unchanged start address tod grt 
code solves rst instances 

time solved rd instance prolongation tod grt bsf tod 
instruction greatly boosted probabilities subsequent instructions 

time hour solved th instance prolongation tod grt bsf tod bsf bsf 

time solved th instance prolongation tod grt bsf tod bsf bsf bsf 
code far lengthy 
solve rst instances 

time roughly days oops created tested new elegant recursive program prolongation previous new increased start address solving instances 
cheaper solve instances discovering applying new program instances far just prolonging old code instance 

program turns near optimal universal problem solver 
stack constructs argument procedure returns input argument calls instruction tod code calls decremented input argument calls tod code returns 
remaining tasks pro solver instance 
reusing current program frozen additional time steps roughly milliseconds time oops solved remaining tasks 

oops switched hanoi problem 
immediately ms time trivial code 

time day fresh somewhat bizarre code new start address cpn exec 
long search time far indicates hanoi speci bias high 

time roughly days fresh code new dec 

turns near optimal universal hanoi solver greatly pro ts code bias embodied earlier solver see discussion section 
time oops solved remaining tasks reusing program frozen 
substantially increase total time roughly 
sheer runtime discovered frozen near optimal program remaining tasks comparable previously consumed search time program due nature hanoi task recall solution takes operations instructions need executed 
note experiments traditional reinforcement learners rarely involve problems solution sizes exceed steps 
entire day search solutions tasks tested pre xes corresponding instructions costing time steps 
recall search time optimal solver natural measure initial bias 
clearly tested pre xes short halt get interrupted soon 
programs run long time example run self discovered universal hanoi solver working instance consumed steps total time 
stack iterative equivalent procedure try storage management section held elements 
discussion results nal token hanoi solution pro ts high initial probabilities greatly earlier recursive solution problem 

pre dec probability prepares foundations exploiting previous code instruction pushes dec decrements takes result argument interpreted address boosts probabilities components nd frozen program happens previously universal solver 
online bias shift greatly increases probability appear remainder online generated program 
instructions turn helpful building data stack ds double recursive procedure generated sux essentially constructs data stack ds argument procedure returns input argument decrements top input argument calls instruction code calls copy top arguments calls code calls code calls copy top arguments unnecessary argument copy returns compare standard hanoi solution 
total probability nal solution previous codes calculated follows nq boosts dec probability pre dec pre boosts probability sux 
probability complete symbol code hand probability essential hanoi speci sux just initial boosts explains quickly help solution easier problem set 
initial boosts probability similar particular setup simple recursion problem provided useful training complex hanoi recursion 
hand search universal solver problems rst instance pro solutions earlier solved tasks 
course instances pro note time spent nal token hanoi solver increasing probabilities certain instructions constructing executable code data stack time steps quickly negligible hanoi instance size grows 
particular application time spent executing code constructing 
note continue solve hanoi tasks 
execution time required solve instances optimal solver greatly exceeds search time required nding solver 
matter oops starts hanoi solver rst discover initial search time solver negligible anyway 
di erent initial bias yield di erent results 
set zero initial probabilities initial instructions unnecessary problem classes solve tasks quickly possibly expense obtaining initial programming language 
point experimental section nd reasonable initial bias particular problems illustrate general functionality rst general near bias optimal incremental learner 
research may focus devising particularly compact particularly reasonable sets initial codes particularly broad practical applicability 
may turn useful initial languages traditional programming languages similar forth section handful primitive instructions massively parallel cellular automata nonlinear operations matrix data structures recurrent neural network research 
example principles oops create non gradient near bias optimal variant hochreiter successful recurrent network 
interest study probabilistic speed prior oops variants devise applications oops methods components universal reinforcement learners hutter asymptotically optimal aixi model environments reactions control signals sampled computable probability distributions 
physical limitations oops due generality optimality properties oops scale large problems essentially fashion raising question physical limitations 
give preliminary answer rst observe decade computers roughly times faster cost re ecting moore empirical law rst formulated 
decades computation encounter fundamental heating problems associated high density computing 
remarkably oops naturally implemented reversible computing strategies completely resets state modi cations due programs tests 
naively extrapolate moore law century oops hit bremermann limit approximately operations second bits ultimate laptop kg mass liter volume 
clearly bremermann limit constrains maximal conceptual jump size problem 
example prior code bias derived solutions previous problems minute sun sized oops roughly kg able solve additional problem requires nding additional bit program say steps runtime 
centuries oops fail new problems require additional bit programs type speed light greatly limits acquisition additional mass function quadratic time 
comparatively modest hardware speed factor expected years appears quite promising oops systems 
example token language experiments section learn scratch day solve disk hanoi problem moves need boosting task speci instructions incremental search instances additional training sequences easier tasks 
comparable speed ups achievable earlier distributing oops large computer networks 
acknowledgments ray solomono marcus hutter sepp hochreiter bakker alex graves douglas eck viktor giovanni andrea useful discussions helpful comments drafts koehler sharing insights concerning ai planning procedures philip koopman jr granting permission reprint quote section 
hutter frequently mentioned funded author snf uni cation universal inductive inference sequential decision theory 
anderson 
learning problem solving multilayer connectionist systems 
phd thesis university massachusetts dept comp 
inf 
sci 
banzhaf nordin keller 
genetic programming 
morgan kaufmann publishers san francisco ca usa 
baum 
model mind economy agents 
machine learning 
bennett 
thermodynamics computation review 
international journal theoretical physics 
bishop 
neural networks pattern recognition 
oxford university press 
bremermann 
minimum energy requirements information transfer computing 
international journal theoretical physics 
chaitin 
theory program size formally identical information theory 
journal acm 
cramer 
representation adaptive generation simple sequential programs 
grefenstette editor proceedings international conference genetic algorithms applications carnegie mellon university july hillsdale nj 
lawrence erlbaum associates 
deville lau 
logic program synthesis 
journal logic programming 
fredkin 
conservative logic 
international journal theoretical physics 
odel 
uber formal der principia mathematica und systeme ur mathematik und physik 
green 
application theorem proving problem solving 
walker norton editors proceedings st international joint conference arti cial intelligence ijcai pages 
morgan kaufmann 
hochreiter younger 
learning learn gradient descent 
lecture notes comp 
sci 
proc 
intl 
conf 
arti cial neural networks icann pages 
springer berlin heidelberg 
holland 
adaptation natural arti cial systems 
university michigan press ann arbor 
holland 
properties bucket brigade 
proceedings international conference genetic algorithms 
lawrence erlbaum hillsdale nj 
hutter 
universal theory arti cial intelligence algorithmic probability sequential decisions 
proceedings th european conference machine learning ecml tr idsia cs ai 
hutter 
fastest shortest algorithm de ned problems 
international journal foundations computer science 
hutter 
self optimizing pareto optimal policies general environments bayes mixtures 
kivinen sloan editors proceedings th annual conference computational learning theory colt lecture notes arti cial intelligence pages sydney australia 
springer 
koopman jr stack computers new wave 
www 
cs cmu edu koopman stack computers index html 
kaelbling littman moore 
reinforcement learning survey 
journal ai research 
koehler nebel ho mann dimopoulos 
extending planning graphs adl subset 
steel editor proceedings th european conference planning volume lnai pages 
springer 
kolmogorov 
approaches quantitative de nition information 
problems information transmission 
hutter schmidhuber 
market reinforcement learning partially observable worlds 
proceedings international conference arti cial neural networks icann idsia cs ai 
langley 
learning search weak methods domain speci heuristics 
cognitive science 
lenat 
theory formation heuristic search 
machine learning 
levin 
universal sequential search problems 
problems information transmission 
levin 
laws information aspects foundation probability theory 
problems information transmission 
li vit anyi 
kolmogorov complexity applications nd edition 
springer 
lloyd 
ultimate physical limits computation 
nature 
mitchell 
machine learning 
mcgraw hill 
moore leach 
forth language interactive computing 
www com 
newell simon 
gps program simulates human thought 
feigenbaum feldman editors computers thought pages 
mcgraw hill new york 
olsson 
inductive functional programming incremental program transformation 
arti cial intelligence 
rechenberg 
evolutionsstrategie optimierung technischer systeme nach prinzipien der biologischen evolution 
dissertation 
published holzboog 
rosenbloom laird newell 
soar papers 
mit press 
russell norvig 
arti cial intelligence modern approach 
prentice hall englewood cli nj 
schmidhuber 
evolutionary principles self referential learning 
diploma thesis institut ur informatik technische universit unchen 
schmidhuber 
self referential weight matrix 
proceedings international conference arti cial neural networks amsterdam pages 
springer 
schmidhuber 
discovering solutions low kolmogorov complexity high generalization capability 
prieditis russell editors machine learning proceedings twelfth international conference pages 
morgan kaufmann publishers san francisco ca 
schmidhuber 
discovering neural nets low kolmogorov complexity high generalization capability 
neural networks 
schmidhuber 
algorithmic theories 
technical report idsia quant ph idsia lugano switzerland 
schmidhuber 
general methods search reinforcement learning 
application snf 
schmidhuber 
exploring predictable 
ghosh editors advances evolutionary computing 
kluwer 
press 
schmidhuber 
hierarchies generalized kolmogorov complexities universal measures computable limit 
international journal foundations computer science 
press 
schmidhuber 
speed prior new simplicity measure yielding near optimal computable predictions 
kivinen sloan editors proceedings th annual conference computational learning theory colt lecture notes arti cial intelligence pages 
springer sydney australia 
schmidhuber zhao schraudolph 
reinforcement learning policies 
thrun pratt editors learning learn pages 
kluwer 
schmidhuber zhao wiering 
shifting inductive bias success story algorithm adaptive levin search incremental self improvement 
machine learning 
schwefel 
numerische optimierung von computer modellen 
dissertation 
published birkh auser basel 
solomono formal theory inductive inference 
part information control 
solomono application algorithmic probability problems arti cial intelligence 
kanal lemmer editors uncertainty arti cial intelligence pages 
elsevier science publishers 
solomono system incremental learning algorithmic probability 
proceedings sixth israeli conference arti cial intelligence computer vision pattern recognition pages 
tel aviv israel 

program stacking technique 
information processing japan information processing society japan 
turing 
computable numbers application entscheidungsproblem 
proceedings london mathematical society series 
ulam 
random processes transformations 
proceedings international congress mathematics volume pages 
shift bias inductive concept learning 
michalski carbonell mitchell editors machine learning volume pages 
morgan kaufmann los altos ca 
von neumann 
theory self reproducing automata 
university press il 
waldinger lee 
step automatic program writing 
walker norton editors proceedings st international joint conference arti cial intelligence ijcai pages 
morgan kaufmann 
wiering schmidhuber 
solving pomdps levin search eira 
saitta editor machine learning proceedings thirteenth international conference pages 
morgan kaufmann publishers san francisco ca 
wolpert macready 
free lunch theorems search 
ieee transactions evolutionary computation 
zuse 
raum 
friedrich vieweg sohn braunschweig 
symbol description ds data stack holding arguments functions possibly edited code dp stack pointer ds ds auxiliary data stack dp stack pointer ds cs call stack runtime stack handle function calls cp stack pointer cs cs cp ip current function call instruction pointer ip cs cp ip cs cp base current base pointer ds right current input arguments cs cp number return values expected top ds cs cp base fns stack currently available self functions stack pointer fns fns code start address code self function fns number input arguments self function fns number return values self function pats stack search patterns probability distributions stack pointer pats pointer current search pattern pats th numerator current search pattern sum denominator current probability sum table frequently implementation speci symbols relating data structures particular forth inspired programming language section 
necessary understanding basic principles oops 
appendix example programming language oops seeded wide variety programming languages 
experiments wrote interpreter stack universal programming language inspired forth 
provide initial instructions de ning calling recursive functions iterative loops arithmetic operations domain speci behavior 
optimal better search algorithms enabled bias shifting instructions modify conditional probabilities search options currently running self delimiting programs 
sections explains basic data structures sections de ne basic primitive instructions section shows compose complex programs primitive ones explains user may insert total code data structures tapes tape contains various stack data structures represented sequences integers 
stack xs introduced stands character string reminiscent stack type frequently mentioned stack pointer xp xp located address axp initialized 
th element xs denoted xs 
simplicity omit tape indices tape 
data stack ds ds short omitting task index storing function arguments 
corresponding stack pointer dp dp 

auxiliary data stack ds 

runtime stack cs handling possibly recursive functions 
pointer cp initialized main program 
th entry cp contains variables instruction pointer cs ip simply cs ip omitting task index initialized start address code procedure pointer cs base pointing ds right values considered input arguments number cs return values ds cs base ds dp expected top ds returned 
cs cp refers topmost entry containing current instruction pointer ip cs cp ip 

stack fns entries describing self functions 
entry function fn contains integer variables start address fn code number input arguments expected fn top ds number output values returned 

stack pats search patterns 
pats stands probability distribution search options instruction candidates 
represented nq integers nq sum eciency reasons 
ip hits current search address history dependent probability th possible instruction candidate value ip sum tape represented variable indicating current search pattern 

binary quote ag determining instructions pointed ip get executed just quoted pushed ds 

variable holding index tape task 

stack integer arrays having name address size implemented mentioned sake completeness 

additional problem speci dynamic data structures problem speci data represent changes environment 
example environment towers hanoi problem described section 
primitive instructions tokens appear solutions oops experiments section 
list completeness sake provide example way seeding oops initial set behaviors 
subsections instruction form inst expects arguments top data stack ds replaces return values adjusting dp accordingly form inst instructions arguments 
illegal instruction cause currently considered program pre halt 
particular illegal set variables stack pointers instruction pointers values outside ranges pop empty stacks divide zero call nonexistent function cpu time measurements pcs turned unreliable de ned realistic time scales 
de nition instructions listed cost exactly unit time step 
consume time instructions making copies strings length cpn cost time steps instructions nd accessing priori unknown number tape cells instructions modifying probabilities priori unknown number instructions 
basic data stack related instructions 
arithmetic 
return constants respectively returns dec returns returns add returns sub returns mul returns div returns smallest integer returns costs unit time steps 

boolean 
operand eq returns 
analogously geq greater equal grt greater 
operand returns 
analogously 
operand returns 
simple stack manipulators 
del decrements dp clear sets dp dp ds returns dp sets dp ip ds returns cs cp ip base returns cs cp base returns ds dp tod pushes ds dp ds decrements dp returns integer name self function return number requested inputs outputs respectively decrements returning old value xmn exchanges th th elements ds measured stack top ex works xmn exchanges th th elements current base ds cs cp base returns ds dp outb returns ds cs cp base th element base pointer inn copies ds dp ds dp copies ds dp ds cs cp base 

pushing code 
instruction pushes ds sequence start address th frozen program user de ned frozen oops program nal token 
inserts th frozen program ds cs cp base increases dp program size 
useful copying editing previously frozen code 

editing strings stack 
instruction cpn copies topmost ds entries top ds increasing dp works cpn copies ds entries ds cs cp base top ds increasing dp copies ds entries starting ds cs cp base ds cs cp base cells appropriately increasing dp necessary ins inserts ds entries ds cs cp base ds cs cp base appropriately increasing dp deletes ds entries ds cs cp base appropriately decreasing dp nd returns stack index topmost entry ds matching ndb index rst ds entry base ds cs cp base matching instructions edit stack contents may interpreted executable code 
control related instructions call callable code increments cp results new topmost entry 
functions execute functions include 
instruction def de nes new integer function name rst name plus increments 
new fns entry associate name function expected numbers input arguments return values function start address cs cp ip right address currently interpreted token def 

instruction dof calls views function name looks address input number output number increments cp lets cs cp base point right topmost elements arguments ds cs cp base cs cp base ds contents corresponding previous instance viewed arguments sets cs cp sets cs cp ip equal address calling 
ret causes current function call return sequence cs cp topmost values ds copied starts ds right ds cs cp base replacing input arguments dp adjusted accordingly cp decremented transferring control ip previous entry copying dp change takes place ectively return entire stack contents ds cs cp base 
instruction rt calls ret conditional return 

calls th frozen program user de ned frozen oops stored frozen assuming somewhat arbitrarily zero inputs outputs 

instruction jmp val sets cs cp ip equal provided val exceeds zero conditional jump useful iterative loops pip sets cs cp ip useful de ning iterative loops manipulating instruction pointer sets current instruction pointer cs cp ip equal address ds cs cp base interpreting stack contents ds cs cp base code executed 

bsf uses cs usual way call code starting ds cs cp base usual code executed return address instruction right bsf exec interprets number instruction executes 

ips binary ag quote ag stored address lag tape lag 
semantics code quoted executed 
precisely instructions appearing th odd st executed instruction numbers sequentially pushed data stack ds 
instruction nop may structure programs 
context instructions bsf quote reprinted friendly permission philip koopman jr interesting proposal stack machine program execution put forth 
examined con icting virtues pitfalls self modifying code 
self modifying code ecient universally software professionals risky 
self modifying code corrupts contents program programmer count instruction generated compiler assembler correct full course program run 
idea allows self modifying code pitfalls 
simply suggests run time stack store modi ed program segments execution 
code generated application program executed run time corrupt program memory 
code executed thrown away simply popping stack 
techniques common today may eventually nd important application 
instructions introduced exactly doing suggested 
remarkably turn useful experiments section 
bias shifting instructions modify search probabilities concept online generated probabilistic programs self referential instructions modify probabilities instructions executed implemented earlier 
primitives 
increases current probability incrementing sum 
analogously decrement 
illegal set probabilities zero keep search options 
delete argument ds decreasing dp 

sequentially goes instructions th self discovered frozen program time instruction recognized gets boosted numerator denominator sum increased nq 
speci useful seen experiments section 

stores current search pattern pat incrementing copying sequence pat pat decrements returning old value 
sets de ning distribution search current task 
idea give system opportunity de ne fairly arbitrary distributions possible search options switch useful ones needed computational context implement conditional probabilities tokens computational history 
course explicitly implement tape represented conditional probabilities tokens previous tokens token sequences tape encoded modi able probabilistic syntax diagram de ning modi able grams 
may facilitate act ignoring certain meaningless program pre xes search 
implementation system create represent conditional dependencies invoking appropriate subprograms including sequences instructions 
initial user defined programs examples isn times smaller isn forth 
charles moore user declare initial possibly recursive programs composing tokens described 
programs sequentially written starting address 
declare new token program write decl name body name textual name code 
textual names interest user system immediately translates new name smallest integer nq gets associated topmost unused code address nq incremented 
argument denotes code number expected arguments top data stack ds denotes number return values body string names previously de ned instructions possibly new name allow cross recursion 
interpreter comes user de ned token simply calls code starting body rst token code executed interpreter returns address token cs 
quite similar case self functions de ned system compare instruction def section 
samples user de ned tokens programs composed primitive instructions de ned 
declarations omit argument lists instructions 

decl mul mul mul mul dec ret declares program arguments computing constant returning top data stack ds 

decl dec mul mul mul ret declares pops values ds returns 
decl fac ex rt del dec fac mul ret declares recursive function fac returns returns fac 

decl fac def ex rt del dec dof mul ret declares fac de nes self recursive code functionally equivalent fac calls calling self function completely de ned 
fac computes fac new fac function 

declarations useful de ning executing recursive procedures return values expect inputs currently stack ds call decreasing problem sizes 
rst pushes auxiliary stack ds number return values zero measures number inputs ds pushes ds quotes pushes ds de nition procedure returns topmost input decrements quotes call de ned function procedure 
quote code making fresh copy inputs de ned code expected top ds 
quotes code returning grabs ds numbers values uses bsf call code generated far stack ds input parameters applying code possibly located deep ds copy inputs pushed top ds 
decl tod dec tod def rt dec cpn ret decl dof cpn ret decl ret ex bsf ret 
entire language integer sequences obvious distinction data programs 
illustrative example demonstrates functional programming easy decl def outb ex rt del dec dof outb ret outb declares tail recursion scheme functional argument 
suppose data stack ds holds values val current base pointer 
create function returns val applies argument function represented arguments result calling argument function value 
example code fragment uses implement version fac mul ret 
assuming ds rst quotes constant return value terminal case function mul applies 
primitives section collectively embody universal programming language computationally powerful odel forth ada fact small fraction primitives sucient universality 
higher level programming languages incrementally built initial low level forth language 
fully understand program may need know instruction got number 
sake completeness permit precise re implementation include full list tod tod bsf add mul sub div dec ndb insn def dof ret rt neg eq grt clear del ex jmp inn cpn xmn outb inb ip ds pip dp ds tod exec nop 
frozen ip ip ip instruction base pointer data stack numerator denominator numerator numerator nq probabilities current qp return values inputs return values data stack currently tested prolongation hanoi peg hanoi peg hanoi peg start address pointer ip function solutions previously solved task sets tapes current tasks ds ds cs cs fns fns fns cs pats pats fns environment ds dp ds ds ds dp cp task pats storage snapshot oops application 
left general picture section 
right language speci details particular forth programming language sections 
left current code ranges addresses qp includes previously frozen programs unsolved tasks require tapes lower left addresses 
instruction pointers ip ip point code ip code nd tape 
say ip points right topmost address qp probability instruction qp determined current probability distribution possible tokens 
oops spends equal time programs starting pre frozen tested task programs solve previous tasks induction programs starting frozen tested tasks 
right details single tape 
space alternative self probability distributions represented nq numerators common denominator 
pointer determines distribution token request 
stack fns self function de nitions pointer code start address numbers input arguments return values expected data stack ds stack pointer dp 
dynamic runtime stack cs handles function calls 
top entry holds current instruction pointer ip current base pointer ds arguments call 
space auxiliary stack ds representing modi able aspects environment 
see text details 

