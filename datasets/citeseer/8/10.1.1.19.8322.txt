template meta programming haskell tim sheard ogi school science engineering oregon health science university sheard cse ogi edu simon peyton jones microsoft research simonpj microsoft com propose new extension purely functional programming language haskell supports compile time meta programming 
purpose system support algorithmic construction programs compile time 
ability generate code compile time allows programmer implement features polytypic programs macro expansion user directed optimization inlining generation supporting data structures functions existing data structures functions 
design implemented glasgow haskell compiler ghc 
categories subject descriptors software programming languages general terms languages design keywords meta programming templates compile time program optimizations similar poetry written published commercial compilers 
hard economic reality interesting optimizations narrow audience justify cost 
alternative allow programmers define compile time optimizations 
happened accidentally albeit imperfectly 
obvious functional programmers committee realize templates functional language evaluated compile time 

haskell workshop oct pittsburgh robinson provocative identifies templates major albeit accidental success language design 
despite extremely baroque nature template meta programming templates fascinating ways extend dreams language designers 
surprisingly view fact templates functional programs functional programmers slow capitalize success flurry run time metaprogramming done compile time metaprogramming 
scheme community notable exception discuss section 
design compile time meta programming extension haskell strongly typed language 
purpose extension allow programmers compute parts program write seamlessly conveniently 
extension viewed template system haskell la type safe macro system 
new contributions describe quasi quotation mechanism language binders precisely described translation monadic computation 
allows operator purely functional language haskell sections 
staged type checking algorithm routines type checking compile time computations 
staging useful supports code generators written ordinary programs need dependent types 
language expressive simple dependent types secure run time computations hand written computed type checked executed section 
reification programmer written components supported computed parts program analyze structure user written parts 
particularly useful building boilerplate code derived data type declarations sections 
addition original contributions synthesized previous coherent system provides new capabilities 
include representation code ordinary algebraic datatype possible haskell existing mechanisms case analysis observe structure code allowing programmer write code manipulation programs code generation programs sections 
augmented quotation monad encapsulates meta programming features fresh name generation program reification error reporting 
monadic library syntax operators built top algebraic datatypes quotation monad 
provides easy interface meta programming parts system sections section 
quasi quote mechanism built top monadic library 
template haskell extends meta level operations static scoping static type checking object level code fragments built quasi quote mechanism sections 
static scoping type checking automatically extend code fragments built algebraic datatype representation programmed user sections 
reification facilities quotation monad allows programmer compile time query compiler internal data structures asking questions line number source file current position 
useful error reporting kind type constructor 
section 
meta program produce group declarations including data type class instance declarations expression section 
basic idea example illustrate mean metaprogramming 
consider writing printf function haskell 
write printf error line msg line define printf haskell printf type depends complicated way value argument see ingenious alternative 
template haskell define printf type safe report error compile time msg line type string int respectively efficient control string interpreted compile time user definable fixed number compiler extensions 
write call template haskell printf error line msg line says evaluate compile time call printf returns haskell expression spliced place call compilation original expression proceed 
term splice splice printf 
returns code error line show lambda abstraction type checked applied msg line 
example interactive session illustrate prompt printf error line bad var char error bad var line note template haskell followed open parenthesis alphabetic character special syntactic form 
means applied splice means ordinary infix application function just ordinary haskell 
situation similar means different function printf executed compile time program produces program result meta program 
template haskell user define printf printf string expr printf gen parse type printf says transforms format string haskell expression type expr 
auxiliary function parse breaks format string tractable list format specifiers data format string parse string format example parse returns parse executed compile time perfectly ordinary haskell function leave definition exercise 
function gen interesting 
give code gen assuming exactly format specifier gen format expr gen show gen gen lift results gen constructed quasi quote notation templates template haskell 
quasi quotations user interface representing haskell programs constructed placing quasi quote brackets ordinary haskell concrete syntax fragments 
function lift string expr lifts string expr type producing expr executed evaluate lifts argument 
say lift section matters interesting want gen recursive deal arbitrary list format specifiers 
give auxiliary parameter expression representing string prefix result adjust call printf accordingly printf string expr printf gen parse gen format expr expr gen gen xs gen xs show gen xs gen xs gen xs gen xs lift inside quotations splice annotation means evaluate quasi quoted code constructed gen called 
recursive calls gen run compile time result spliced enclosing quasi quoted expression 
argument type expr 
second argument recursive call gen accumulating parameter type expr quasi quoted expression 
notice arguments recursive calls gen refer object variables bound outer quasi quotes 
occurrences static scope binding occurrence static scoping extends template mechanism 
templates 
write programs high level languages programs shorter concise easier maintain easier think 
low level details data layout memory allocation abstracted compiler programmer longer concerns details 
time expert knowledge embedded compiler compiler job manner superior users manage 
programmer knows particular details compiler 
compiler couldn deal details economic reasons just doesn 
limit number features compiler writer put compiler 
solution construct compiler manner ordinary users teach new tricks 
rationale template haskell easy programmers teach compiler certain class tricks 
compilers 
manipulate programs 
making easy users manipulate programs easy manipulations compiler manipulations creates powerful new tool 
envision template haskell programmers things 
conditional compilation extremely useful compiling single program different platforms different debugging options different configuration 
crude approach preprocessor cpp compilers haskell support directly mechanism part programming language better 
program reification enables programs inspect structure 
example generate function data structure data type declaration structure 
algorithmic program construction allows programmer construct programs algorithm describes construct program simpler program 
generic functions map show prime examples compile time specialized programs printf code compiled specialized compile time constants 
abstractions transcend abstraction mechanisms accessible language 
examples include introducing higher order operators order language compile time macros implementing integer indexed functions zip zip strongly typed language 
optimizations may teach compiler domain specific optimizations algebraic laws lining opportunities 
template haskell functions execute compile time written language functions execute run time haskell 
choice sharp contrast existing systems example cpp language define template meta programs written entirely type system 
big advantage approach existing libraries programming skills directly arguably disadvantage explicit annotations necessary specify bits code execute 
consequence programmer may erroneously write nonterminating function executes compile time 
case compiler fail terminate regard programming error avoidable divergence run time 
rest flesh details design 
shall see sections turns simple quasi quote splice notation introduced far 
flexible construction starts template haskell long discovers quasi quote splice express full range meta programming opportunities want 
haskell built functions selecting components pair fst snd 
want select component triple write hand case template haskell write sel 
write sel 
sel int int expr sel case 
uh oh 
write ordinary haskell pattern case expression depends quasi quote notation broken need way construct haskell syntax trees directly sel int int expr sel lam pvar var alt alt match alt pat rhs pat patt pat map pvar rhs expr rhs var 

string show code syntax construction functions construct expressions patterns 
list types concrete examples 
syntax patterns pvar string patt patt patt pcon string patt patt fork patt syntax expressions var string expr tup expr expr app expr expr expr lam patt expr expr expr match expr case patt expr match xs code sel verbose printf uses explicit constructors expressions implicit ones 
exchange code construction fundamentally flexible sel shows 
template haskell provides full family functions lam pvar documented appendix styles mixed freely 
example write sel sel int int expr sel alt alt pat rhs pat map pvar rhs var 
show illustrate idea suppose want ary zip function call look bs cs bs cs lists int expr generates code ary zip 
start write int expr zp zp zp int expr expr meta function generates local binding zip zip 
body binding dots 
generated auxiliary meta function defined 
function defined zip example paragraph recursive 
name function doesn really matter result escapes scope 
expression returned 
name function passed generates body properly scoped 
size zipping function parameter 
useful see generates particular understanding works 
applied object variable var ff generates value expr type 
pretty printing value concrete syntax get case xs xs xs ff xs xs xs note parameter var ff ends function arms case 
user level function opposed auxiliary function applied obtain full 
note name bound variable zp passed parameter ends recursive call 
zp case xs xs xs zp xs xs xs zp function operates generating bunch patterns xs xs xs bunch expressions variables bound patterns 
generating patterns pattern variable associated expressions expression variable common function string int patt expr ns show map pvar ns map var ns pvar pvar var var function construct lists matching patterns expressions 
assemble pieces lambda abstraction body case analysis lambda abstracted variables 
int expr expr name lam tup exs xs xs xs tup exs apps name zipwith copies con quasi quotation mechanism patterns function apps idiom worth abstracting function application function multiple arguments 
apps expr expr apps apps zs apps zs message section 
works quasi quote notation simple convenient secure understands haskell static scoping type rules 
quasi quote usually want generate code sequences indeterminate length 
template haskell syntax construction functions app lam allow programmer drop convenient expressive notation necessary 
declarations reification haskell may add deriving clause data type declaration data tip fork deriving eq deriving eq clause instructs compiler generate boilerplate code allow values type compared equality 
mechanism works handful built type classes eq ord ix want instances classes write hand 
tiresome wrote drift pre processor haskell allows programmer specify code generation algorithm algorithm generate boilerplate code data types 
done poly algorithms execution specified structure type 
template haskell works fully integrated version drift 
example data tip fork splice code shows new features seen reification declaration splicing 
reification involves making internal representation available data structure compile time computations 
reification covered detail section 
declaration splicing construct splice 
may appear declaration group needed seen 
expression expected 
splice instructs compiler run enclosed code compile time splice resulting declaration group place splice call splicing generate declarations 
example generated single instance declaration essential aside syntax splice terse declaration context 
particular application deriving general generate class data type value declarations 
generating declarations expressions useful purposes deriving code data types 
consider ary zip function discussed section 
time write bs cs fresh copy way zip generated 
may precisely programmer wants say may want generate single top level zip function zip want generate zip functions 
write splice understanding zip zip 
zip brought scope 
quasi quotes scoping quotation monad ordinary haskell statically scoped template haskell 
example consider meta function cross 
cross expr expr expr cross executing cross var var expect var var inadvertently captured local object variables inside quasi quotes cross definition 
case 
prompt cross var var displaying top level term type expr quasi quote notation renames get expected result 
static scoping works ordinary haskell quasi quotes lift behavior object level 
unfortunately syntax construction functions lam var tup behave way 
consider cross lam pvar pvar tup app var app var applying cross results inadvertent capture 
prompt cross var var displaying top level term type expr program generators written notation appears syntax construction functions inadequate expressing static scoping appears trouble need way generate fresh names 
turn 
secrets revealed correct rendering cross template haskell quasi quote cross expr expr expr cross ft gt return lam pvar pvar tup app ft var app gt var example reveal secrets type expr synonym monadic type exp true declarations type expr exp type decl dec code returned cross represented ordinary haskell algebraic datatypes 
fact algebraic data types example exp expressions constructors lam tup app pat patterns constructors pvar monad quotation monad 
supports usual monadic operations bind return fail notation gensym operation gensym string string generate expr returned cross haskell monadic notation 
generate fresh name monadic gensym build expression return 
notice perform monad giving ft gt type exp type exp internal 
see avoid pain section 
summarize template haskell layers representation object programs order increasing convenience decreasing power bottom layer parts 
ordinary algebraic data types represent haskell program fragments section 
second quotation monad encapsulates notion generating fresh names failure input output section 
library syntax construction functions tup app lift corresponding algebraic data type constructors tup app quotation monad level providing convenient way access bottom layer section 
quasi quote notation introduced section convenient seen important metaprograms express 
revisit notation section show built top previous layers 
programmer freely mix layers simply convenient interfaces 
discuss detail layers code representation 
leave detailed discussion quasi quotes section 
datatypes code object programs data haskell represents data structures algebraic datatypes natural template haskell represent haskell object programs algebraic datatype 
particular data types template haskell appendix highlights include algebraic datatypes represent expressions exp declarations dec patterns pat types typ 
additional data types represent syntactic elements haskell guarded definitions body expressions comprehensions statement arithmetic sequences 
comments freely appendix illustrate algebraic datatypes concrete syntax examples 
tried data types complete simple 
modelled haskell concrete surface syntax write haskell programs able algebraic constructor functions represent 
advantage algebraic approach object program representations just ordinary data particular analysed haskell case expression pattern matching 
disadvantages approach verbosity construct representation program requires considerably effort required construct program little support semantic features object language scoping typing 
syntax construction functions syntax construction functions section stand revealed monadic variants corresponding data type constructor 
example types data type constructor app monadic counterpart remember expr exp app exp exp exp app expr expr expr arguments app computations arguments app data values 
app convenience function simply performs argument computations building result app expr expr expr app convenience worth 
example version cross cross expr expr expr cross lam pvar pvar tup app var app var monadic versions constructors build result avoid having bind ft gt hand cross 
lam app tup 
general nomenclature character type name expr monadic version character algebraic data type exp 
lower cased function app monadic version upper cased data constructor app expr decl monadic computational versions underlying concrete type corresponding types patterns patt types type simply synonyms underlying data type type patt pat type type typ constructors lower case name clash haskell keywords case data class instance convention lower case names initial letter type lete doe 
reason need gensym constructing patterns types 
look cross 
point gensym ing inside pattern variables scope body lambda 
provide type synonyms patt type lower case constructors pvar programmers consistent set lower case working computational setting formation exp dec computational upper case working algebraic datatype setting 
syntax construction functions ordinary haskell library readily extended programmer 
seen example definition apps section possible 
example consider common pattern wish generate code scope newly generated pattern don care names variables pattern don clash existing names 
approach gensym new variables construct pattern expression hand cross 
alternative clone pattern fell generate new variable time cross vf lam tup app vf app vf function patt string expr patt alpha renames pattern 
returns new pattern function maps names variables original pattern exprs names variables alpha renamed pattern 
easy write recursion pattern 
scheme mixed quasi quote notation 
cross vf lam vf vf quasi quote notation patterns mentioned passing section 
supply quasi quote notation declarations types 
course renaming happens automatically quasi quotation 
explain detail section 
typing template haskell template haskell strongly typed milner sense welltyped program go wrong run time 
traditionally strongly typed program type checked compiled executed situation template haskell little complicated 
example consider example printf error line readily type checked form type spliced expression depends complicated way value string argument 
template haskell type checking takes place stages type check body splice case printf error line expr 
compile execute splice result place call 
example program error line show type check resulting program just programmer written program place 
type checking intimately interleaved compile time execution 
template haskell compile time meta system 
metalevel operators brackets splices reification appear code generated 
example illegal 
restrictions 
example definition illegal inside quotation 
says evaluate compile time splice value known called 
common staging error 
enforce restrictions break static checking part compiling process states 
compiling state normal compilation 
meta operators compiler state 
compiler enters state bracket compiling code inside quasi quotes 
compiler enters state splicing encounters expression escape inside quasi quoting brackets 
example consider int expr foo definition statically checked state call foo typed state call typed state addition states count levels starting state incrementing processing quasi quotes decrementing processing inside splice 
levels distinguish top level splice splice inside quasi quotes 
example call statically checked state level checked state level 
states legal transitions reflected 
transitions diagram indicate error transitions 
tempting think states merged case 
transitions state imply compile time computation require complicated static checking including computation 
transitions states 
rules diagram enforced weaving type checker 
formal typing judgments type checker embody transition diagram supplying cases legal states 
study rules detail 
expressions rules expressions simpler just simplifications established rules metaml 
type judgment rules expressions takes conventional form environment mapping variables types binding states expression type 
state describes state type checker level described 
reify reify splice 
typing states template haskell rule bracket says states expression type exp regardless type notice type checked new state increment level 
reflects legal transitions emphasizes bracket typing rule listed states 
type checking term detects internal type inconsistencies right away example true rejected immediately 
represents interesting design compromise meta functions including code fragments generate statically checked guarantee produce typed code completed splices re checked 
believe new approach typing metaprograms 
approach catches errors early possible avoids need dependent types completely type safe 
notice rule quasi quotes state quasi quotes nested multi stage languages metaml 
rule explains type check splice inside state 
type exp tells type expression evaluate unspecified problem soundness expression splice sits type checked 
precisely happens rule deals splicing state expression type checked evaluated give new expression expression type checked scratch state just programmer written place 
rules lam var deal staging 
environment contains assumptions form records type level bound rule lam 
think environment finite function 
variable level check binding level rule var 
declarations gives rules typing declarations judgments form decl states expressions expr bracket exp exp exp dec lam var declarations decl decl fun 

dec splice splice 
typing rules template haskell environment declarations checked mini environment gives types variables bound decl rules quite conventional example rule fun explains type function definitions 
rule splicing interesting follows pattern splicing expressions 
type check spliced expression run typecheck declarations returns 
ability generate group declarations fundamental usefulness raises interesting complication resolve lexical scoping program types splicing done 
example program valid 
splice foo zip fee fie valid splice brings zip scope expect doesn 
similar remarks naturally apply instance declaration produced function section 
module contains splices may obvious order expand 
tackle complication assuming programmer intends splices expanded top bottom 
precisely single haskell declaration bind variables 
type check group declarations 
follow procedure group declarations follows 
splice 
splice 
splice 
splice declarations ones indicated explicitly group 
ordinary haskell declarations 
perform conventional dependency analysis followed type checking group 
free variables scope 
environment established type check expand splice 
type check result expanding splice 
augmented environment established type check ordinary group 
algorithm implements judgment declaration lists rule splice 
restrictions declaration splicing notice rule splice assumes state level 
permit declaration splice state 
example permit int expr splice int decl 
type checking run computation known run know binds sensibly type check body 
possible give type checking body result call type checked logical line thought give typechecking body quasi quote expression 
doing sound defer type errors definition site meta function call site 
choice pending experience err side earlier error detection 
want effect get dropping lower level int expr lete tup var var fact currently restrict splice top level declaration haskell data class instance declarations 
reason restriction concerns usability technical complexity 
declaration splices introduce unspecified new bindings may clear variable occurs original program bound 
situation similar haskell existing import statements bring scope unspecified collection bindings 
restricting splice top level worthwhile gain occurrence see lexically enclosing binding binding 
top level splice hide top level binding import haskell permit definitions value top level 
contrast nested splice hide enclosing binding 
think top level splice kind programmable import statement 
quotation monad revisited far quotation monad generate fresh names 
useful purposes discuss section 
reification reification template haskell way allowing programmer query state compiler internal symbol tables 
example programmer may write module data tip fork rept decl rept type length int string construct returns computation type decl dec representing type declaration performed computation rept writing rept obtain dec data constr tip tvar constr fork tapp tcon name tvar tapp tcon name tvar write mean unambiguously defined module say original name 
original names part syntax haskell necessary describe implement meta programming correctly 
say original names section 
similar way gives data structure represents value declaration similarly classes 
reification provides general way get compile time information 
construct length returns computation type type typ representing compiler knowledge type library function length 
similarly tells fixity argument useful figuring print 
returns computation type string represents location source file occurred 
reify returns computation combined computations compile time 
reification language construct function say map xs example 
important reification returns result quotation monad 
example consider definition assertion function assert expr bool assert error assert fail notice comment giving type expression generated assert static type system metaml nicer 
invoke assert find xs assert assert splice expanded get find xs error assert fail line foo hs vital course captures location splice site assert definition site precisely achieve making return computation 
take idea making assert behaviour depend command line argument analogous cpp command mechanism defining symbols expr bool mb mb assert assume reification function string string returns command line option specified string defined value 
go 
clear reification allowed 
example useful restrict type constructors classes variables function declared top level current module just type constructors declared data declarations imported modules 
may useful support additional kinds reification making compiler symbol table information available 
failure compile time meta program may fail programmer error 
example expect fail sense produce ary zip function arguments 
errors sort due inappropriate bogus implementation meta program meta programmer needs way cleanly report error 
place quotation monad useful 
case write int expr 
fail standard monadic fail operator class monad type instance fail string compiler catch errors reported fail gracefully report occured 
input output meta program may require access input output facilities 
example may want write splice foo xml generate haskell data type declaration corresponding xml schema stored file foo xml boilerplate haskell functions data type 
easily provide way performing arbitrary input output quotation monad io naturally power open abuse merely compiling malicious program delete entire file store 
compromise positions possible including ruling allowing limited set benign operations file reading 
policy choice technical consider 
printing code far produced code order splice module compiled 
want write programs generate haskell program put file compiling 
happy parser generator example existing program follows paradigm 
pedagogic reasons extremely convenient display code generated just compile 
libraries provided exp dec instances class show 
instance show exp instance show dec 
display code constructed computational framework supply function io compile run program main output case produced 
notice absence splicing 
sel defined section 
implementing far treated monad abstractly easy implement 
just io monad augmented environment newtype env io environment contains mutable location serve name supply gensym 
source location top level splice invoked evaluation 
compiler symbol table support implementation 
command line switches support 
things course readily added 
quasi quotes lexical scoping introduced quasi quote notation informally time pay direct attention 
quasi quote notation convenient shorthand representing haskell programs lexically scoped 
precisely occurrence variable bound value lexically scope occurrence site original source program template expansion 
obvious sounding property lisp community calls hygienic macros 
meta programming setting nearly easy implement think 
quasi quote notation implemented top quotation monad section saw variables bound inside quasi quotes renamed avoid inadvertent capture cross example 
variables bound outside quasi quotes 
cross stage persistence possible splice expand expression contains names scope splice occurs need take care happens 
consider contrived example module swap swap consider call module module foo import swap true foo splice expand 
expand swap module foo plain swap bind boolean value defined foo swap defined module splice expand swap haskell qualified name notation swap scope foo imported foo name space import 
expand splice swap original name swap 
original names discussed section context representations returned reify 
solve similar problem 
part code representations unambiguously refer global top level variables may hidden scopes representations may 
extension haskell template haskell uses implement static scoping meta programming extensions accessible ordinary part haskell 
example write map 
ability include generated code value variable exists compile time special name cross stage persistence requires care implement correctly 
just seen happens top level variables swap nested variables require different treatment 
particular consider status variable free quotation swap 
swap top level binding module type known module compiled 
way give original name value vary call 
cross stage persistence kind variable qualitatively different requires turning arbitrary values code 
example compiler executes call passes value return data structure type exp app var swap tup lit int lit int code lift value exp show happens quasi quotes translated away int int expr return app var swap take advantage haskell existing type class mechanism 
lift overloaded function defined type class lift class lift lift expr instances lift allow programmer explain lift types choice expr 
example ones provided part template haskell instance lift int lift lit int instance lift lift lift lift tup lift lift advantage type classes way requires slight change typing judgment var 
stage inside quasi quotes variable bound outside quasi quotes top level type checker inject type constraint lift type 
omitted mention type constraints real system course 
summarize lexical scoping means free variables swap top level quasi quote right hand side definition statically bound closure 
need scope application site inside module foo case quite different value name may scope 
terribly surprising simply lexical scoping action precisely behaviour expect ordinary function swap dynamic scoping occasionally programmer may want dynamic scoping strategy generated code 
template haskell express dynamic scoping var swap splice site expand swap swap bind swap scope splice site regardless scope definition 
behaviour useful template haskell clearly flagged string quoted variable name var swap 
un quoted variables lexically scoped 
open question power desirable 
easily removed making var take gensym return type string 
implementing quasi quote quasi quote notation explained terms original names syntax constructor functions gensym return lift operation 
think translation process term quasi quotes term 
translation precise expressing translation ordinary haskell function 
skeleton handle constructors pat exp illustrate process omit interest brevity 
main function tre translates expression inside tre exp exp argument environment type ignore couple paragraphs 
term exp call tre cl construct term exp evaluates example compiler translates body swap executing translation function tre arguments tre cl app var swap var result call exp app app var app app var var str swap app var lift var printed concrete syntax app var swap lift expect quasi quoted swap expand quasi quotes translated app var swap lift environment cl tells tre treat swap differently 
capturing translation process haskell function write tre cl app app app var app trans trans tre cl cond app app app var cond trans trans trans tre cl 
simple pattern capture tre cl app rep app tres cl tre cl cond rep cond tres cl tres exp exp tres cl es map tre cl es rep string exp exp rep xs apps var xs apps apps xs apps app xs return environment cl 
section discovered variables need treated differently depending bound 
environment records information tre decide translate variable occurrences type string data orig lifted bound variable follows tre exp exp tre cl var case cl bound rep var var lifted rep lift var orig mod rep var str mod tre cl lit int rep lit rep int tre cl app rep app tres cl tre cl tup es rep tup tres cl es tre cl lam ps ss lam ss xs ps lam rep lam xs tre cl tre cl esc copy tre cl br error nested brackets allowed tres exp exp tres cl es map tre cl es copy exp exp copy cl var var copy cl lit lit copy cl app app copy cl copy cl copy cl lam ps lam ps copy cl copy cl br tre cl trp pat statement pat exp dec pat trp pvar rep gensym str rep pvar var trp rep lit trp ps ss rep qs ss qs ps trp pcon ps ss rep pcon str qs ss qs ps trp var pat statement pat exp dec pat ps concat ss qs ss qs unzip map trp ps 
quasi quote translation function 
orig means bound top level module original name 
lifted means bound outside quasi quotes top level 
translation function generate call lift type checker ensure type class lift 
bound means bound inside quasi quotes alpha renamed 
cases reflected directly case var tre 
need auxiliary function trp translate patterns trp pat statement pat exp dec pat part pair returned trp list statements representing gensym bindings generated translation 
second part pair pat representing alpha renamed pattern 
example translating pattern variable get binding statement result pvar 
trp hand look lam case tre 
lambda expression wish generate local binding preserves scope quoted lambda 
lam pvar pvar app var var bindings renamed patterns pvar pvar bound meta variables ss xs call ps assembled body app var var generated recursive call tre new expression returned 
interesting case esc case 
consider example term translation tre translates follows tup lam pvar var lam pvar pvar pvar app app var var notice body splice transcribed literally translated code 
copy function 
looking copy interesting case reach nested quasi quotation just resort back tre 
example code transformer quasi quoted term nested quotations escape translates lam pvar tup var lit int related templates elaborate meta programming facility known templates 
basic idea static compile time computation takes place entirely type system 
template class considered function arguments types integers factorial 
returns type extract integer result returning struct selecting conventionally named member factorial ret 
type system rich construct manipulate arbitrary data structures lists trees type system computations control object level code generated 
widely recognized type system computation language simply extraordinarily baroque functional language full ad hoc coding tricks conventions 
fact templates widely strong evidence need thing barriers considerable 
believe template haskell takes principled approach task 
particular static computation language dynamic language new programming idiom required 
think idea course lisp community doing years discuss 
scheme macros lisp community taken template meta programming seriously years modern scheme systems support elaborate towers language extensions entirely macros 
early designs suffered badly name capture problem problem solved evolution hygienic macros dybvig hieb bruggeman excellent self contained summary state art 
differences vocabulary world view combined subtlety material quite difficult give clear picture differences scheme approach 
immediately obvious difference template haskell statically typed expansion 
scheme macro expanders sort static type system reports staging errors 
pervasive ways scheme system powerful tractable 
scheme admits new binding forms 
consider macro call foo suitably defined macro foo require argument variable name scopes second argument 
example call foo expand lambda complexity scheme macros arises ability define new binding forms way 
template haskell 
foo var hand clear occurrence var lexically scoped source program 
declaration splice splice bind variables declaration splices occur top level outside situation tractable 
scheme macros special binding form define syntax call site syntactic baggage 
macro call identified observing token function position bound define syntax 
template haskell special syntax definition site template functions just ordinary haskell functions splice required call site 
interesting trade 
template haskell macros completely higher order class function passed arguments returned results partially applied constructed anonymous lambdas 
scheme macros pretty order called name 
bawden discussed class macros 
scheme admits side effects complicates 
mutable value instantiated 
move compile time run time 
shared 

haskell free complications 
metaml derivatives goals metaml template haskell differ significantly lessons learned building metaml influenced template haskell design 
important features migrated metaml template haskell include template quasi quote notation means constructing object programs 
type safety 
program fragment executed context type checked type checking constructed program fragments happens compile time 
static scoping object variables including alpha renaming bound object variables avoid inadvertent capture 
cross stage persistence 
free object variables representing run time functions mentioned object code fragments correctly bound scope code created 
metaml significant difference template haskell metaml 
differences follow different assumptions meta programming systems 
assumptions design template haskell differ strongly metaml 
users compute portions program writing pay run time overhead 
assumption exactly stages compile time run time 
metaml code built executed run time 
template haskell code meant compiled meta computation happens compile time 
code represented algebraic datatype amenable inspection case analysis 
appears odds static scoping quasi quotation mechanisms shown accomplished interesting way monads 
statically type checked checking delayed possible moment strategy just time type checking 
allows powerful meta programs written resorting dependent types 
hand written code data representing obtained manipulation 
run time function data type definition reified data structure representation obtained inspected compile time functions 
quasi quotes metaml indicate boundary stages execution 
brackets run metaml akin quote eval scheme 
template haskell brackets indicate boundary compile time execution run time execution 
main breakthroughs type system metaml quasi quotes respect scoping typing 
metaml code generating program type correct programs generates 
property crucial generation step happens run time late start reporting type errors 
security comes price metaml express useful programs 
example printf example section typed metaml type call printf depends value string argument 
way address problem dependent type system approach distinct disadvantages 
start programmer burden writing function transforms format string type type system complicated explain 
template haskell second stage may give rise type errors occur compile time situation serious run time code generation 
contribution current development semantics quasi quotes monadic computations 
allows exist pure language side effects 
process generating fresh names encapsulated monad quasi quotes referentially transparent 
caml caml staged ml implementation built top caml system 
metaml run time code generation system 
metaml compiler interpreter generating compiled byte code run time 
demonstrated impressive performance gains staged programs counterparts 
translation quasi quotes manner preserves scoping structure quoted expression implemented caml 
proposal add compile time macros ml language 
demonstrates macros implement new binding constructs precise semantics staged programs macros strongly typed 
allows new local binders 
supports generative macros 
macros limited constructing new code combining code fragments analyze code fragments 
dynamic typing approach just time type checking roots earlier study dynamic typing staged type inference 
template haskell typing code fragments split stages 
template haskell code type checked top level splice points splice state 
code type checked splice points 
addition code construction splice point type checking run time activities significant effort placed reducing run time overhead type checking 
implementation small prototype read template haskell perform compile time execution 
scaling prototype full implementation embodying template haskell extension glasgow haskell compiler ghc 
ghc implementation fully supports separate compilation 
compiling module functions defined modules earlier executed compile time 
reason execute function defined compiler need compile function functions calls way executable code type checking parts 
compile time function invoked compiler finds previously compiled executable dynamically links modules packages imports running compiler 
module consisting completely meta functions need linked executable built final link step ghc clever 
design represents progress 
hope provide working implementation driven directly experiences real users 
avenues know want 
important exception reifying data type definitions said little user defined code manipulation optimization advertised goals ll get 
know confusing error messages template haskell may arise code programmer see 
possible display code 
wants get earlier type security additional documentation saying expr type int metaml type expect add parameterised code types expr int expr indicate type statically known 
templates scheme macros lighter weight syntax calling macro programmer may need aware macro involved 
interesting trade discussed briefly section 
lot said reducing syntactic baggage call site speculative ideas inferring splice annotations 
acknowledgments particularly matthew flatt long conversations explored relationship template haskell scheme macros errors comparison remain 
magnus carlsson fergus henderson tony hoare dick kieburtz simon marlow emir haskell workshop referees helpful comments drafts 
students class cse fundamentals staged computation winter participated lively discussions uses staging especially bill howe final project motivated tim sheard 
described supported nsf ccr murdock charitable trust department defense 

modern design 
addison wesley 
bawden 
class macros types 
th acm symposium principles programming languages popl pages boston jan 
acm 
taha huang leroy 
type safe multi stage language 
technical report computer science department yale university 
clinger rees 
macros 
th acm symposium principles programming languages popl pages 
acm jan 
danvy 
functional unparsing 
journal functional programming nov 
de wit 
technical overview generic haskell 
master thesis inf scr department information computing sciences utrecht university 
dybvig hieb bruggeman 
syntactic abstraction scheme 
lisp symbolic computation 
ganz sabry taha 
macros multistage computations type safe generative binding macros 
proceedings acm sigplan international conference functional programming icfp new york september 
acm press 
hinze peyton jones 
derivable type classes 
hutton editor proceedings haskell workshop montreal number tr technical reports sept 
kohlbecker friedman felleisen duba 
hygienic macro expansion 
acm symposium lisp functional programming pages 
acm 
pitman 
special forms lisp 
acm symposium lisp functional programming pages 
acm 
robinson 
impact economics compiler optimization 
proceedings acm java grande conference stanford pages 
acm june 
sheard 
accomplishments research challenges metaprogramming 
taha editor proceedings workshop semantics applications implementation program generation volume lncs pages berlin september 
springer verlag 
invited talk 
sheard benaissa martel 
multistage programming metaml 
pacific software research center oregon graduate institute nd edition 
available cse ogi edu sheard papers manual ps 
shields sheard peyton jones 
dynamic typing staged type inference 
th acm symposium principles programming languages popl pages san diego jan 
acm 
taha sheard 
multi stage programming explicit annotations 
acm sigplan symposium partial evaluation semantics program manipulation pepm volume sigplan notices pages 
acm amsterdam june 

type sensitive preprocessor haskell 
glasgow workshop functional programming 
library monadic syntax operators monad instance monad gensym string string io io type synonyms 
letter algebraic letter monadic type expr exp type patt pat type decl dec type type typ type mat match pat exp dec type match patt expr decl type cls clause pat exp dec type clause patt expr decl type stm statement pat exp dec type stmt statement patt expr decl lowercase patterns pvar pvar pcon pcon lowercase expressions var return var con return con lit return lit app lam ps lam lam tup es es doe ss ss comp ss ss xs ys es es cond return cond lete ds ds return ds ms return case ms helper functions types stmt pattern expr decl stmt pat exp dec zs fail parallel comprehensions ds ds return ds ss sequence map ss body expr body exp normal guarded ps ps return guarded ps matchc match pattern expr decl match pat exp dec matchc ds return ds useful functions map pvar ns map var ns ns show apps expr expr apps apps zs apps zs normal matchc algebraic datatype representation haskell module data lit int int char char data pat lit pvar string pat pcon string pat data pat string pat type match body case pat body decs type clause body body decs data exp var string con string data lit lit app exp exp lam pat exp tup exp cond exp exp exp dec exp case exp match pat exp dec case statement pat exp dec comp statement pat exp dec exp 
exp data body guarded ds normal ds data statement print statement data 



data dec fun string clause pat exp dec decs val pat body exp dec decs data string string constr string data deriving class typ typ dec class eq eq ds instance typ typ dec instance show show ds proto name typ length int data constr constr string typ data tag tuple int arrow list name string deriving eq tree data typ tvar string tcon tag tapp typ typ left things implicit parameters sections complicated literals default declarations 
