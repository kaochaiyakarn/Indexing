quantifying complexity superscalar processors palacharla norman jouppi james smith computer sciences department university wisconsin madison madison wi usa cs wisc edu western research laboratory digital equipment palo alto ca usa jouppi pa dec com department ece university wisconsin madison madison wi usa jes ece wisc edu delay pipeline structures superscalar processors studied determine potential limiting clock cycle times designs 
generic superscalar pipeline defined 
specific areas register renaming instruction window wakeup selection logic operand bypassing analyzed 
modeled spice simulated feature sizes performance results trends expressed terms issue width window size 
analysis indicates window wakeup select logic operand bypass logic critical 
current trend microprocessor industry increasingly complex order microarchitectures 
intention exploit larger amounts instruction level parallelism 
important tradeoff 
complex hardware tends limit clock speed microarchitecture lengthening critical paths 
performance proportional clock speed theta instructions cycle need study techniques maximize product push limits term independently 
interested exploring complexity effective microarchitectures 
optimize product complexity measured clock cycle effectiveness instructions cycle 
emphasized complexity variously quantified terms number transistors die area clock speed cycle time power dissipated measure complexity critical path piece logic longest critical path pipeline stages determines clock speed 
definition complexity semi independent absolute number transistors required implement structure die area occupied structure affect wire lengths may turn affect critical path 
relatively straightforward measure effectiveness microarchitecture trace driven simulation clock cycles 
simulations count clock cycles provide instructions cycle fairly straightforward manner 
complexity microarchitecture difficult determine accurate require full implementation specific technology 
needed fairly straightforward measures possibly relative measures complexity fairly early stage design process 
methods allow determination complexity effectiveness 
report represents effort direction 
section describe portions microarchitecture tend complexity grows increasing instruction level parallelism 
focus instruction dispatch issue logic data bypass logic 
analyze potential critical paths structures develop models quantifying delays 
study ways delays vary microarchitectural parameters window size number waiting instructions ready instructions selected issue issue width number instructions issued cycle 
study impact technology trends smaller feature sizes 
addition delays important consideration structures 
delay structure relatively large increase complexity design structure pipelined operation structure spread multiple 
affect effectiveness reducing instructions cycle increasing latencies functional operations increasing penalty mispredicted branches instruction cache misses pipeline re filled cases 
study critical structures identify certain operations atomic performed single cycle dependent instructions execute consecutive cycles 
delay analysis shows logic associated issue window superscalar processor key limiter clock speed move wider issue widths larger windows advanced technologies wire delays dominate delay 
split issue window logic basic functions wakeup selection 
time instruction ready complete tag result broadcast waiting instructions window update dependence information 
broadcast determination instruction dependences resolved constitutes wakeup function 
selection function required select maximum ready instructions cycle window instructions number functional units microarchitecture 
order able execute dependent instructions back back consecutive cycles wakeup selection function completed single cycle 
furthermore wakeup function involves broadcasting result tags set wires span window 
advanced technologies wire delays increasingly dominate total delay delay wakeup logic bottleneck 
structure potentially limit clock speed especially technologies bypass logic 
bypass wires bypass operand values increase length number functional units increased 
wire delays ultimately dominate force architects choose favor decentralized microarchitectures 
rest report organized follows 
section describes sources complexity baseline microarchitecture 
section describes methodology study critical structures identified section 
section discusses technology trends wires important gates feature sizes shrink 
section presents detailed analysis structures shows delays vary microarchitectural parameters technology parameters 
section discusses results structures 
section 
sources complexity delving specific sources complexity describe baseline superscalar model assume study 
list discuss basic structures primary sources complexity 
show basic structures form current implementations implementations appear different superficially 
hand realize impossible capture possible microarchitectures single model results provide obvious limitations 
hope provide fairly straightforward model typical current superscalar processors suggest techniques similar extended advanced models developed 
fetch decode rename select wakeup window register file bypass data fetch decode dcache reg read wakeup select rename insert bypass execute access reg write commit issue baseline superscalar model shows baseline model associated pipeline 
fetch unit fetches multiple instructions cycle instruction cache 
branches encountered fetch unit predicted 
instruction fetch instructions decoded register operands renamed 
register renaming involves mapping logical register operands instruction appropriate physical registers 
step eliminates write read write write conflicts converting instructions single assignment form 
renamed instructions dispatched issue window wait source operands appropriate functional unit available 
soon condition satisfied instruction issued executes functional units 
operand values instruction fetched register file bypassed earlier instructions pipeline 
data cache provides low latency access memory operands loads stores 
basic structures mentioned earlier probably best way identify primary sources complexity microarchitecture implement microarchitecture specific technology 
extremely time consuming costly 
approach identify structures delay function issue window size issue width 
select additional study develop relatively simple delay models applied straightforward manner relying detailed design 
example include register renaming logic list structures delay depends issue width way 
number read ports rename table theta iw number read operands instruction iw issue width 
example assuming operand instructions way machine require read ports rename table way machine require read ports 
hand include functional units delay independent issue width window size 
addition criterion decision study particular structure number considerations 
primarily interested dispatch issue related structures structures form core microarchitecture largely determine amount parallelism exploited 
second structures tend rely broadcast operations long wires delays scale logic intensive structures technologies smaller feature sizes 
third cases delay structures may potentially grow quadratically issue width 
believe structures potential cycle time determinants wide issue designs advanced technologies 
list structures consider ffl register rename logic register rename logic translate logical register designators physical register designators 
translation accomplished accessing map table logical register designator index 
instruction renamed follows 
physical registers corresponding operand registers read map table 
instruction produces result logical destination register assigned physical register pool free registers map table updated reflect new mapping 
addition reading mappings map table rename logic detect true dependencies instructions renamed parallel 
involves comparing logical source register logical destination register earlier instructions current rename group 
dependence check logic responsible performing task 
discussion obvious delay rename logic function issue width issue width determines number ports map table width dependence check logic 
ffl wakeup logic logic part issue window responsible waking instructions waiting issue window source operands available 
instruction issued execution tag corresponding result broadcast instructions window 
instruction window compares tag source operand tags 
source operands instruction available instruction flagged ready execution 
delay wakeup logic function window size issue width 
window size determines fanout broadcast larger window size greater length wires broadcasting 
similarly increasing issue width increases delay wakeup logic size window entry increases issue width 
ffl selection logic selection logic part issue window responsible selecting instructions execution pool ready instructions 
instruction said ready source operands available 
typical policy selection logic oldest ready 
delay logic function window size number functional units selection policy 
ffl data bypass logic data bypass logic responsible bypassing operand values instructions completed execution written results register file subsequent instructions 
bypass logic implemented set wires called result wires carry result bypassed values source possible destinations 
muxes called operand muxes select appropriate result gate operand ports functional units 
delay logic function number functional units depth pipeline 
delay bypass logic depends length result wires load wires 
increasing number functional units increases length result wires 
increases fan operand muxes 
making pipeline deeper increase number sources number result wires 
increases fan operand muxes 
important pieces logic consider report delay function dispatch issue width 
ffl register file register file provides low latency access register operands 
access time register file function number physical registers number read write ports 
farkas study access time register file varies number registers number ports 
studied include 
ffl caches instruction data caches provide low latency access instructions memory operands respectively 
order provide necessary load store bandwidth superscalar processor cache duplicated 
access time cache function size cache associativity cache 
wada jouppi developed detailed models estimate access time cache size associativity 
studied consider cache logic report 
ffl instruction fetch logic instruction caches discussed 
important parts fetch logic complexity varies instruction dispatch issue width 
instruction issue widths grow size single basic block necessary predict multiple branches cycle 
non contiguous blocks instructions fetched instruction cache compacted contiguous block prior renaming 
logic required operations described detail rotenberg smith 
delay models remain developed 
important chose consider 
point real designs may structures listed may influence delay critical path 
realistic aim study analyze detail important ones reported literature 
believe basic techniques applied 
current implementations structures identified context baseline superscalar model shown 
mips hp pa dec implementations model 
structures identified apply processors 
bypass data decode fetch rename register file buffer reorder wakeup select window fetch decode rename reg read rob read insert select wakeup execute bypass commit reg write dcache access dispatch reservation station model hand intel pentium pro powerpc hal sparc reservation station model shown 
main differences models 
baseline model register values speculative non speculative reside physical register file 
reservation station model reorder buffer holds speculative values register file holds committed non speculative data 
second operand values broadcast window entries baseline model tags broadcast data values go physical register file 
reservation station model completing instructions broadcast operand values reservation station 
issuing instructions read operand values reservation station 
point noted basic structures identified earlier reservation station model critical baseline model 
notable difference reservation station model smaller physical register file equal number architected registers 
point noted basic structures identified earlier reservation station model critical baseline model 
notable difference reservation station model smaller physical register file equal number architected registers demand bandwidth ports register file baseline model case operands come reorder buffer reservation station 
discussion potential sources complexity context baseline superscalar model order pointed critical structures identified apply inorder processors 
example dependence check bypass logic order superscalar processors 
methodology studied structure phases 
phase selected representative cmos circuit structure 
done studying designs published literature mainly proceedings international solid state circuits conference collaborating engineers digital equipment 
cases possible design preliminary study designs select promising 
case register renaming study simulate different schemes performance similar 
second phase implemented circuit optimized circuit speed 
hspice circuit simulator simulate circuits 
static logic 
situations dynamic logic helped boosting performance significantly dynamic logic 
example wakeup logic dynamic input gate comparisons static gate 
number optimizations applied improve speed circuits 
transistors circuit manually sized delay improved 
second applied logic optimizations twolevel decomposition reduce fan requirements 
avoided static gates fan greater 
third cases modify transistor ordering shorten critical path 
optimization sites pointed individual circuits described 
order simulate effect wire added appropriate nodes hspice model circuit 
computed calculating length wires layout circuit values metal metal resistance parasitic capacitance metal wires unit length 
study effect reducing feature size delays structures simulated circuits different feature sizes respectively 
process parameters symbol represents iw issue width window size nv reg number virtual registers number physical registers nv number bits virtual register designators number bits physical register designators metal resistance metal wire unit length metal capacitance metal wire unit length table terminology cmos process taken 
parameters jouppi study cache access times 
process parameters proprietary information extrapolation come process parameters technologies 
process parameters process parameters process parameters literature inputs 
process parameters assumed technologies listed appendix layouts technologies obtained appropriately shrinking layout technology 
basic rc circuit analysis develop simple analytical models captured dependence delays microarchitectural parameters issue width window size 
compared relationships predicted hspice simulations predicted model 
majority cases models accurate relationships 
caveats methodology address issue assumed circuits reflect real circuits structures 
basing circuits designs published microprocessor vendors believe assumed circuits close real circuits 
practice circuit tricks employed optimize critical path speed 
believe relative delay times different configurations accurate absolute delay times 
mainly interested finding trends delays structures vary microarchitectural parameters window size issue width delays scale feature size reduced believe results valid 
terminology table defines common terms report 
remaining terms defined introduced 
technology trends feature sizes mos devices steadily decreasing 
trend smaller devices continue decade 
section briefly discuss effect shrinking feature sizes circuit delays 
effect scaling feature sizes circuit performance active area research 
interested illustrating trends section 
circuit delays consist logic delays wire delays 
logic delays delays resulting gates driving gates 
delay decoder consists nand gates feeding gates example logic delay 
wire delays delays resulting driving values wires 
logic delays delay logic gate written delay gate cl theta cl load capacitance output gate supply voltage average charging discharging current 
function saturation drain current devices forming gate 
feature size reduced supply voltage scaled keep power consumption manageable levels 
voltages scaled arbitrarily follow different scaling curve feature sizes 
devices scaling factor feature sizes scaling factor supply voltages cl scale factors respectively 
gate delay scales factor gate delays decrease uniformly feature size reduced 
wire delays length wire intrinsic rc delay wire theta metal theta metal theta metal metal resistance parasitic capacitance metal wires respectively length wire 
factor introduced order approximation delay distributed rc line rc assume resistance capacitance distributed uniformly length wire 
order study impact shrinking feature sizes wire delays analyze resistance metal parasitic capacitance metal metal wires vary feature size 
simple model bohr estimate metal metal scale feature size 
note quantities unit length measures 
metal ae width thickness metal fringe parallel ffl ffl thickness width ffl ffl width thickness width width wire thickness thickness wire ae metal ffl ffl constants 
average metal thickness remained constant generations width decreasing proportion feature size 
technology scaling factor scaling factor metal metal capacitance consists components fringe capacitance parallel plate capacitance 
fringe capacitance result capacitance side walls adjacent wires capacitance side walls wires substrate 
parallel plate capacitance result capacitance bottom wall wires substrate 
assuming thickness remains constant seen equation metal fringe component dominant component move smaller feature sizes 
authors show features sizes reduced coupling capacitance responsible increasingly larger fraction total capacitance 
example show feature sizes coupling capacitance contributes total capacitance 
order accentuate effect wire delays able identify effects assume metal capacitance largely determined fringe capacitance scaling factor metal scaling factors equation wire delay compute scaling factor wire delays scaling factor theta theta note length scales local interconnects 
study interested local interconnects 
true global interconnects clock length depends die size 
feature sizes reduced wire delays remain constant 
coupled fact logic delays decrease uniformly feature size implies wire delays dominate logic delays 
reality situation aggravated reasons 
wires reduce length perfectly factor 
second global wires clock increase length due bigger dies possible generation 
mcfarland flynn studied various scaling schemes local interconnects conclude quasi ideal scaling scheme closely tracks deep technologies 
quasi ideal scaling performs ideal scaling horizontal dimensions scales thickness slowly 
rc delay unit length scaling model theta theta 
comparison scaling model rc delay unit length model overestimates rc delay compared quasi ideal model mcfarland flynn order emphasize wire delays study effects 
complexity analysis section discuss critical pipeline structures detail 
presentation structure organized follows 
describe logical function implemented structure 
possible schemes implementing structure describe schemes detail 
analyze delay structure terms microarchitectural parameters issue width window size simple delay models 
hspice results identify trends results discuss results conform delay analysis performed earlier 
register rename logic register rename logic translate logical register designators physical register designators 
logically accomplished accessing map table logical register designator index 
multiple instructions multiple register operands need renamed cycle map table multi ported 
example wide issue machine read operands write operand instruction requires read ports write ports mapping table 
high level block diagram rename logic shown 
map table holds current logical physical mappings 
addition map table dependence check logic required detect cases logical register renamed written earlier instruction current group instructions renamed 
example shown 
dependence check logic detects dependences sets output muxes appropriate physical register designators generated 
shadow table checkpoint old mappings processor quickly recover precise state branch mispredictions rename operation map table updated reflect new logical physical mappings created result registers written current rename group 
map table shadow table check logic slice mux dependence physical reg designator register rename logic mechanism recover exceptions branch 
occur frequently checkpoint space limited assume checkpointing predicted branches 
exceptions recovered unwinding reorder buffer 
structure mapping checkpointing functions rename logic implemented ways 
schemes called ram scheme cam scheme described 
ram scheme ram scheme implemented mips map table register file entry contains physical register mapped logical register designator index table 
number entries map table equal number logical registers 
single cell table shown 
shift register cell checkpointing old mappings 
access stack bitlines read port write port sense amplifier decoder write back shadow mapping cell register shift map table cell map table works register file 
bits physical register designators stored cross coupled inverters cell 
read operation starts logical register designator applied decoder 
decoder decodes logical register designator raises word lines 
triggers bit line changes sensed sense amplifier appropriate output generated 
bit lines improve speed read operations 
single ended read write ports minimize increase width cell number ports increased width cell determines length time taken drive 
mappings checkpointed copying current contents cell shift register 
recovery performed writing bit appropriate shift register cell back main cell 
cam scheme alternative scheme register renaming uses cam content addressable memory store current mappings 
scheme implemented hal sparc dec 
number entries cam equal number physical registers 
entry contains fields 
field stores logical register designator mapped physical register represented entry 
second field contains valid bit set current mapping valid 
valid bit required single logical register map physical register 
mapping changed logical register designator written entry corresponding free physical register valid bit entry set 
time valid bit mapping previous mapping located associative search cleared 
rename operation scheme proceeds follows 
cam associatively searched logical register designator 
match valid bit set read enable word line corresponding cam entry activated 
encoder rom encode read enable word lines physical register physical register designator 
old mappings checkpointed storing valid bits cam checkpoint ram 
recover exception valid bits corresponding old mapping loaded cam checkpoint ram 
hal design old mappings saved 
cam scheme scalable ram scheme number cam entries equal number physical registers tends increase issue width order support large number physical registers cam appropriately 
hand ram scheme number entries map table independent number physical registers 
cam scheme advantage respect checkpointing 
order checkpoint cam scheme valid bits saved 
easily implemented having ram adjacent column valid bits cam 
words dimensions individual cam cells independent number checkpoints 
hand ram scheme width individual cells function number checkpoints number determines length shift register cell 

add sub sub free regs 
add sub sub free regs renaming 
mux priority encoder renaming example dependence check logic dependence check logic shown proceeds parallel map table access 
farkas shown significant performance physical registers required wide issue machine physical registers required wide issue machine 
logical register designator renamed compared destination register designators logical earlier instructions current rename group 
match tag corresponding physical register assigned earlier instruction tag read map table 
example case shown instruction operand register mapped 
case match tag corresponding latest dynamic order match 
implemented dependence check logic issue widths 
issue widths delay dependence check logic delay map table check hidden map table access 
delay analysis implemented ram scheme cam scheme 
performance schemes comparable design space explored 
keep analysis short discuss ram scheme 
critical path rename logic time takes bits physical register designator output logical register designator applied address decoder 
delay critical path consists components time taken decode logical register designator time taken drive wordline time taken access stack pull bitline low time taken sense amplifier detect change bitline produce corresponding output 
time taken output map table pass output mux ignored small compared rest rename logic importantly control input mux available advance dependence check logic faster map table 
delay delay decode bitline components analyzed 
decoder delay structure decoder shown 
improve speed decoding 
bit field generates lines fed row decode gates 
gates input nand gates row decode gates input gates 
fan nand gates determined number bits logical register designator 
output nand gates connected input gates lines 
length lines theta iw theta wordline spacing theta nv reg height single cell excluding iw issue width wordline spacing spacing number logical registers 
factor equation results assumption operand instructions read operands write operand read write ports 
assumptions ports write port read ports required cell logical register designator bits wordline row wordline driver logical register designator bits 
req ceq row decode gate input gate nand gates lines row decoder structure instruction renamed 
iw wide issue machine total theta iw required cell 
decoder delay time takes decode logical register designator time takes output gate rise input nand gate applied 
decoder delay written decode nand nand fall delay nand gate rise delay gate 
equivalent circuit nand gate shown nand theta eq theta eq eq consists components resistance nand pull metal resistance line connecting nand gate gates 
eq theta theta metal note divided resistance line order approximation delay distributed rc line rc assume resistance capacitance distributed evenly length wire 
eq consists components diffusion capacitance nand gate gate capacitance gate metal capacitance line connecting line connecting nand gate gate 
eq theta metal substituting equations decoder delay simplifying get decode theta iw theta iw constants 
quadratic component results intrinsic rc delay lines connecting nand gates gates 
design space technologies explored quadratic component small relative components 
delay decoder linearly dependent issue width 
wordline delay wordline delay defined time taken turn access transistors denoted connected wordline logical register designator decoded 
circuit shown wordline delay sum fall delay inverter rise delay wordline driver 
equivalent circuit wordline driver shown wordline driver delay written theta theta effective resistance pull transistor driver resistance wordline amount capacitance wordline 
total capacitance wordline consists components gate capacitance access transistors metal capacitance wordline wire 
resistance wordline determined length wordline 
symbolically theta iw theta bitline spacing theta width theta theta gamman theta metal theta theta metal number bits physical register designator gamman gate capacitance access transistor cell width single ram cell excluding bitlines bitline spacing spacing bitlines maximum number shadow mappings checkpointed width width single bit shift register cell 
factoring equations wordline delay equation simplifying get theta iw theta iw constants 
quadratic component results intrinsic rc delay wordline wire quadratic component small relative components 
wordline delay linearly dependent issue width 
wordline driver 
word cell cells decoder word vdd gate wordline structure bitline delay bitline delay defined time wordline going high turning access transistor bitline going low reaching voltage value dd threshold voltage sense amplifier 
time takes access stack discharge bitline 
equivalent circuit shown see magnitude delay bitline theta bitline theta bitline effective resistance access stack pass transistors series bitline resistance bitline bitline capacitance bitline 
bitline capacitance consists components diffusion capacitance access transistors connected bitline metal capacitance bitline 
resistance bitline determined length bitline 
symbolically theta iw theta wordline spacing theta bitline theta gamman theta metal bitline theta theta metal nv reg number logical registers gamman diffusion capacitance access transistor connects bitline height single ram cell excluding wordline spacing spacing 
factoring equations delay equation simplifying get bitline theta iw theta iw 
access stack wordline precharge sense amplifier bitline rows sense amplifier input bitline structure constants 
quadratic component small relative components 
bitline delay linearly dependent issue width 
sense amplifier delay wada sense amplifier 
wada sense amplifier amplifies voltage difference theta dd assumed single ended read lines tied inputs sense amplifier voltage ref structural constitution sense amplifier independent issue width delay varied issue width 
delay function slope input 
input bitline voltage delay sense amplifier function bitline delay 
turn delay sense amplifier function issue width 
delay analysis delay register rename logic summarized equation delay theta iw theta iw constants 
quadratic component relatively small rename delay linear function issue width design space explored 
hspice results shows delay rename logic varies issue width number instructions renamed cycle technologies 
graph shows breakup delay components discussed previous section 
detailed results various configurations technologies shown tabular form appendix number observations graph 
total delay increases linearly issue width technologies 
conformance analysis previous section 
components show linear increase issue width 
increase bitline delay larger increase wordline delay issue width increased bitlines longer design 
bitline length proportional number logical registers cases wordline length proportional width physical register designator design space explored 
rename delay ps sense amp delay bitline delay wordline delay decoder delay rename delay important observation graph relative increase wordline delay bitline delay total delay issue width worsens feature size reduced 
example issue width increased percentage increase bitline delay shoots feature size reduced 
occurs logic delays various components reduced proportion feature size presence wire delays wordline bitline components cause wordline bitline components fall slower rate 
words wire delays wordline bitline structures increasingly important feature sizes reduced 
wakeup logic wakeup logic responsible updating source dependencies instructions issue window waiting source operands available 
illustrates wakeup logic 
time result produced tag associated result broadcast instructions issue window 
instruction compares tag tags source operands 
match operand marked available setting flag 
operands instruction available set instruction ready execute rdy flag set indicate 
issue window cam content addressable memory array holding instruction entry 
buffers shown top drive result tags tag issue width 
entry cam theta comparators compare results tags operand tags entry 
logic ors comparator outputs sets flags 
inst tag 
opd opd opd opd wakeup logic cam structure shows single cell cam array 
cell shown detail compares single bit operand tag corresponding bit result tag 
operand tag bit stored ram cell 
corresponding bit result tag driven tag lines 
match line high 
mismatch operand tag bit result tag bit match line pulled low stacks 
example tag data pull stack left turned pulls match line low 
pull stacks constitute comparators shown 
match line extends bits tag mismatch bit positions pull low 
words match line remains high result tag matches operand tag 
operation repeated result tags having multiple tag match lines shown 
match signals ored produce ready signal 
observations drawn 
match lines issue width 
increasing issue width increases height cam row 
second increasing issue width increases number inputs block 

rdy tag data data tag 
ram cell match pd pd pull stack cam cell delay analysis match lines high default value ready signal high 
delay critical path time takes mismatch single bit position pull ready signal low 
delay consists components time taken buffers drive tag bits time taken pull stack corresponding bit position mismatch pull match line low time taken individual match signals 
symbolically delay components analyzed 
tag drive time tag drive circuit shown 
time taken drive tags depends length tag lines 
length tag lines iw theta spacing theta height single cam cell excluding spacing spacing number window entries 
equivalent circuit shown time taken drive tags theta theta assume pull stack turned interested worst case delay 
precise height associated pull stacks 
resistance pull tag driver metal resistance tag line total capacitance tag line 
theta theta metal consists components metal capacitance determined length tag line gate capacitances comparators diffusion capacitance tag driver 
theta metal theta gate capacitance pass transistor pd comparator pull stack diffusion capacitance tag driver 
result tag window entries tag line comparator tag driver vdd pup pd tag drive structure substituting equations delay equation simplifying get theta iw theta theta iw theta iw theta note fixed size tag driver studies 
tag driver sized largest configuration 
reality increase tag drive time window size higher 
equation shows tag drive time increases window size issue width 
issue width total delay quadratic function window size 
weighting factor quadratic term function issue width 
weighting factor significant issue widths 
window size tag drive time quadratic function issue width 
current technologies longer quadratic component relatively small tag drive time largely linear function issue width 
feature size reduced quadratic component increases significance 
quadratic component results intrinsic rc delay tag lines 
reality issue width window size simultaneously increased larger window required finding independent instructions 
believe tag drive time significant designs wider issue widths bigger windows smaller feature sizes 
tag match time time taken pull stacks pull match line low 
equivalent circuit shown theta theta effective resistance pull stack metal resistance match line total capacitance match line 
computed theta theta metal length match line iw theta spacing theta width cam cell excluding tag lines spacing increase width cam cell extra port tag wires added 
consists components diffusion capacitances pull stacks connected match line metal capacitance match line gate capacitance inverter match line 
theta theta gammap theta metal width physical register designators gammap diffusion capacitance pass transistor marked pd pull stacks connected match line gate capacitance inverter match line 
substituting equations delay equation simplifying get theta iw theta iw quadratic component relatively small tag match time linear function issue width 
drawback model tag match time model dependence match time slope tag line signal tag drive delay 
results section show result dependence tag match time function window size 
words larger windows result slower result tags comparators window entries increasing compare time 
match time time taken individual match lines produce ready signal 
number match vdd precharge tag bit cell data 
match cells pd match tag match structure lines issue width magnitude delay term direct function issue width 
shows logic result widths 
input nand stacks followed gate faster input nand gate 
delay gate quadratic function fan write delay theta iw theta iw design space explored issue widths quadratic component relatively small 
delay delay wakeup logic summarized equation similar tag drive time includes relations exhibited tag match time match time 
delay theta iw theta theta iw theta iw theta hspice results shows delay wakeup logic varies window size issue width technology 
expected delay increases window size issue width increased 
quadratic dependence total delay window size results quadratic increase tag drive time discussed previous section 
effect clearly visible issue width significant smaller issue widths 
issue width greater impact delay window size increasing issue width increases components delay 
hand increasing window size tag drive time small extent tag match time 
results show delay increases match match match match match match rdy rdy rdy match match match match match match match match logic oring individual match signals going way way going way way window size instructions 
reality increase delay going worse order sustain wider issue width larger window required find independent instructions 
similar curves technologies 
detailed results various configurations technologies shown tabular form appendix shows detailed breakdown total delay various window sizes way processor technology 
tag drive time increases rapidly window size 
example tag drive time increases factor window size increased 
quadratic dependence tag drive time window size illustrated graph 
tag match time increases window size 
pointed earlier effect taken account model model take consideration slope input signals determined case tag drive delay 
graph shows time taken match signals depends issue width independent window size 
shows effect reducing feature sizes various components wakeup delay way processor 
tag drive tag match delays scale match delay 
expected tag drive tag match delays include wire delays match delay consists logic delays 
quantitatively fraction total delay contributed tag drive delay increases feature size reduced 
shows performance broadcast operation crucial technologies 
simulation results window size limited maximum instructions larger windows intrinsic rc delay tag lines increases significantly 
discussed previously intrinsic rc delay proportional square window size 
implementing larger windows banking shown 
banking helps alleviate intrinsic rc wakeup delay ps window size way way way wakeup logic delay technology delay reducing length tag lines 
example way banking shown improve intrinsic rc delay factor 
time pointed banking introduce extra delay due extra inverter stages introduced extension tag lines 
selection logic selection logic responsible selecting instructions execution pool ready instructions issue window 
form selection logic required reasons 
number ready instructions issue window greater number functional units available 
example way machine entry issue window ready instructions 
second instructions executed subset functional units 
example integer multiplier multiply instructions steered functional unit 
inputs selection logic request req signals instruction issue window 
request signal instruction raised operands instruction available 
discussed previous section wakeup logic responsible raising req signals 
outputs selection logic signals request signal 
receipt signal associated instruction issued functional unit issue window entry occupied freed selection policy decide requesting instructions granted functional unit 
example selection policy oldest ready ready instruction occurs earliest program order granted functional unit 
butler patt studied various policies scheduling ready instructions performance largely independent selection policy 
example hp designs example hp pa entry freed instruction committed result value part architectural state 
window size wakeup delay ps match delay tag match delay tag drive delay wakeup delay versus window size way machine technology pa uses selection policy location instruction window 
assume selection policy study 
structure assumed structure selection logic shown 
selection logic select single instruction execution functional unit 
modifications scheme handling multiple functional units discussed section 
selection logic consists tree arbiters 
arbiter cell shown functions follows 
enable input high signal corresponding highest priority active input raised 
example enable req req req req raised assuming priority reduces go input req input req 
enable input low signals set low 
cases signals high 
output signal raised input req signals high 
selection logic works phases 
phase request signals propagated tree 
cell raises signal input request signals high 
turn raises input request signal parent arbiter cell 
root cell input request signals high instructions ready 
root cell functional unit children raising outputs 
initiates second phase 
phase signal propagated tree instruction selected 
level signal propagated subtree contains selected instruction 
enable signal root cell high functional unit ready execute instruction 
example single cycle alus enable signal permanently tied high 
selection policy implemented assumed structure static strictly location instruction issue window 
leftmost entries window highest priority 
oldest feature size wakeup delay ps match delay tag match delay tag drive delay wakeup delay versus feature size way entry window processor bank bank tag banking wakeup logic ready policy implemented scheme compacting issue window left time instructions issued inserting new instructions right 
ensures instructions occur earlier program order occupy leftmost entries window higher priority instructions 
possible complexity resulting compaction degrade performance 
analyze complexity compacting study 
handling multiple functional units multiple functional units type selection logic shown comprises number blocks type studied previous section stacked series 
request signals block derived requests previous block masking request granted previous resource 
enable enable enable enable enable req req req subtrees enable root cell enable req priority encoder issue window arbiter cell req req req req enable priority encoder selection logic alternative scheme extend arbiter cells request signals encode number resources requested granted respectively 
believe considerably slow arbiter cells perform worse stacked design 
stacked design feasible alternative functional units resulting delay significant 
alternative option statically partition window entries functional units 
example mips window partitioned sets called integer queue floating point queue address queue 
instructions integer queue monitored execution integer functional units 
similarly hp pa window partitioned alu queue mem queue 
alu queue buffers integer floating point req req fu arbiter fu arbiter handling multiple functional units instructions 
instructions alu queue monitored execution integer functional units floating point functional units 
mem queue buffers load store instructions 
instruction mem queue monitored execution load store units 
delay analysis delay selection logic time takes generate signal request signal raised 
equal sum terms time taken request signal propagate root tree time taken signal propagate root selected instruction 
symbolically delay gamma theta root gamma theta log height selection tree time taken request signal propagate arbiter cell root delay output root cell time taken signal propagate arbiter cell 
selection delay written delay theta log constants 
equations see delay selection logic proportional height tree delay arbiter cells 
delay logarithmic relationship window size 
increasing issue width increase selection delay stacked scheme described previous section handle multiple functional units 
rest discussion assume single functional unit scheduled stacking 
delay stacked design easily computed multiplying delay results stacking depth 
way improve delay selection logic increase radix selection tree 
see shortly increases delay single arbiter cell delay worse 
arbiter logic circuit generating signal shown 
signal raised input request signals active 
circuit implementing function consists dynamic gate followed inverter 
dynamic gate chosen static gate speed reasons 
circuit operates follows 
node high 
input request signals go high corresponding pull downs pull node low 
inverter turn raises signal high 
value delay equation delay circuit 
priority encoder arbiter cell responsible generating signals 
logic equations signals req enable req req enable enable enable precompute priority enable req req req req req req req precharge precharge arbiter logic req req req enable req req req req enable example high cell enabled input requests req req low req high 
request signals cell root cell available advance enable signal level implementation evaluating signals 
example circuit evaluating shown 
stage evaluates signal node assuming enable signal high 
second stage signal anded enable produce signal 
level decomposition chosen removes logic critical path 
optimization apply root cell root cell request signals arrive enable signal 
selection policy selection logic embedded equations outputs arbiter cell 
example design assumes static priority req having highest priority 
implementing alternative policy require appropriate modifications equations 
designer careful selecting policy complex policy increase delay selection logic slowing individual arbiter cells 
increasing number inputs arbiter cell slows logic priority encoder logic 
logic slows load capacitance contributed diffusion capacitance pull downs increases linearly number inputs 
priority logic slows delay logic compute priority increases due higher fan 
optimal number inputs case 
selection logic mips described input arbiter cells 
hspice results window size selection delay ps propagation delay root delay request propagation delay selection delay versus window size shows delay selection logic various window sizes technologies assuming single functional unit scheduled 
delay broken components discussed earlier 
graph see technology delay increases window size increased instructions instructions 
increase delay middle term delay equation delay root cell independent window size 
logarithmic dependence selection delay window size seen graph 
detailed results tabular form appendix various components total delay scale feature size reduced 
surprising delays logic delays 
pointed selection delays optimistic consider wires circuit especially case request signals originate cam entries instructions reside 
hand possible minimize effect wire delays ready signals stored smaller compact array 
data bypass logic data bypass logic responsible bypassing result values subsequent instructions instructions completed execution written results register file 
hardware datapaths control added purpose form bypass logic 
number bypasses required determined depth pipeline issue width microarchitecture 
pointed iw issue width result producing stage fully bypassed design ready flags discussed wakeup logic section 
require theta iw theta bypass paths assuming input functional units 
words number bypass paths grows quadratically issue width 
current trend deeper pipelines wider degree issue multiplies number bypass paths bypass logic critical 
bypass logic consists components datapath control 
datapath comprises busses called result busses broadcast bypass values source possible destinations 
sources bypass values functional units cache ports 
buffers drive bypass values result busses 
addition result busses datapath comprises operand muxes 
operand muxes required gate appropriate result operand busses 
fan operand muxes greater number result busses 
extra input mux case reading operand register file 
control logic responsible controlling operand muxes 
control logic compares tag result value tag source value required functional unit 
match mux control set result value driven appropriate operand bus 
key factor determines speed bypass logic delay result wires transmit bypassed values 
control adds delay analysis ignore control delay small fraction total delay 
move smaller feature sizes wire delays resulting result wires responsible significant fraction total delay 
structure commonly structure bypass logic shown 
shows bit slice datapath 
functional units marked fu fu 
consider bit slice fu 
gets operand bits opd opd operand wires 
result bit driven res result wire result driver 
buffers drive result bits operand wires result wires 
buffers implement muxes shown 
example order bypass result functional unit fu left input functional unit fu driver marked switched 
driver connects res wire opd wire 
case bypasses activated operand bits placed operand wires register file read ports result bits written register file addition bypassed 
delay bypass logic largely determined time takes driver output functional unit drive result value corresponding result wires 
turn depends length result wires 
seen length wires function layout 
layout length result wires determined height functional units register file 
alternative layouts discussed results section 
reservation station microarchitecture intel pentium pro operand bits come data field reservation station entry 
fu fu regfile mux mux mux wires res res res res opd opd opd opd fu fu result bypass logic delay analysis discussed delay bypass logic approximated wire delay result wires 
considering wires distributed rc lines delay delay theta metal theta theta metal theta theta theta metal theta metal length bypass wires 
equation see issue width increased length result wires increase causes bypass delay grow quadratically issue width 
increasing depth pipeline increases delay bypass logic follows 
increasing depth increases fan operand muxes connected result wire 
turn increases amount capacitance charged discharged result wire diffusion capacitance buffers operand muxes adds capacitance wires 
component delay captured simple model 
expect component delay relatively significant feature size reduced 
results table shows typical heights functional units 
lengths estimated data papers describing specific implementations functional units 
example height complete alu half feature size 
complete alu referred alu gen comprises adder shifter logic unit 
similarly height simple alu simple alu functional unit height description adder bit adder shifter bit barrel shifter logic unit performs logical operations complete alu alu gen comprises adder shifter logic unit simple alu alu simple comprises adder logic unit load store unit comprises adder effective address calculation table functional unit heights referred alu simple contains adder logic unit shifter 
load store unit referred unit consists adder computing effective addresses 
table total length result wires way machine alu gen alu simple units calculated follows 
length ile height alu gen height alu simple height theta height theta calculations take consideration height integer multiplier divider units usually placed result wires extend 
ignored height rows muxes drivers functional units 
register file height computed formula height theta wordline spacing theta theta iw theta iw total number ports iw wide machine assuming single ended read ports single ended write port required instruction number physical registers height individual ram cell excluding wordline spacing extension height cell wordline added similar calculations computed wire delays hypothetical way way machines 
note wire delays remain constant technologies scaling model assumed study 
table shows results 
observations table 
wire delay way machine clock period current technologies feature sizes true technologies 
second wire delay way machine significant potentially degrade clock speed current technologies 
alternative layouts way way calculations 
issue functional unit fu height register file wire delay width mix height length ps alu gen alu simple alu gen alu simple table result wire delays way way processor results previous section assume particular layout functional units placed side register file 
mentioned length result wires function layout 
study alternative layouts order reduce bypass delays 
shows alternative layouts 
alternative functional units placed side register file 
case bypass wires extend register file 
length operand wires originating register file increase relative stretching register file access time 
organization disadvantage sense amplifiers register file distributed sides 
lead increase width register file increase register file access time 
regfile fu fu fu regfile fu fu fu fu regfile fu single cycle bypass cycle bypass alternative layouts bypassing long term consider clustered organizations shown alternative 
cluster copy register file 
bypasses cluster complete single cycle inter cluster bypasses take cycles 
scheme implemented dec 
hardware compiler ensure inter cluster bypasses occur infrequently 
addition mitigating delay bypass logic organization advantage faster register files fewer ports register file 
technique improve bypass performance incomplete bypass network 
incomplete bypass network frequently issue window rename wakeup selection bypass width size delay ps delay ps delay ps table delay results technology bypass paths provided interlocks remaining situations 
performance technique terms cycle counts studied detail ahuja 
technique reduce fan operand muxes clear technique reduce length result wires 
delay results pipelining issues results way way microarchitecture technology shown table 
results technology shown appendix way machine window logic wakeup select greatest delay structures considered determines critical path delay 
register rename delay comes faster delay window logic 
bypass delay relatively small case 
results similar way machine assume bypass logic eliminated critical path clustering 
example way machine implemented way clusters single cycle bypasses cluster multi cycle cycle bypasses clusters 
cases delay window logic largest window logic crucial structure list structures studied 
delay critical structures analyzed detail 
addition delay important consideration structures 
delay structure relatively large eliminated critical path pipelined operation spread multiple 
example designs spread floating point operations multiple cycles 
pipelining improve performance facilitating faster clock result number side effects degrade performance 
extra stages introduced deeper pipelining front increase penalty mispredicted branches 
penalty instruction cache misses increase result extra re filled 
time accurate branch prediction alleviate problems certain extent 
performance improvement achieved result deeper pipelining faster clock surpasses performance degradation caused extra stages pipelining attractive option 
current trend microprocessor industry deeper pipelining 
example pipeline intel pentium pro dec pipeline 
general subject effect pipelining depth performance focus number studies 
took different approach study 
studied feasibility pipelining wakeup exec wakeup wakeup select select exec exec select bubble add sub 
critical structures identified atomic operations implemented structures 
define operation atomic operation completed single cycle order execute dependent instructions consecutive cycles 
obvious example atomic operation simple alu operation integer add logical 
alu operation spread multiple dependent instructions execute consecutive cycles resulting pipeline bubbles result serious performance degradation especially programs limited parallelism 
atomic operations pipelined performance reasons believe latency atomic operations ultimately limit degree pipelining 
delays atomic operations crucial determine complexity microarchitecture 
ffl register renaming register rename logic pipelined spreading dependency checking map table access multiple 
easy see dependency checking pipelined obvious map table access pipelined 
schemes pipelining rams employed pipeline map table access 
addition order ensure rename group sees map table updates performed previous rename groups updates bypassed map table updates visible writes table complete 
think design complicated register renaming pipelined 
pointed attempting pipeline renaming number tricks reduce latency 
map table duplicated reduce number ports copy table 
second instructions operands instructions rename group common operands port requirements map table reduced little effect performance 
ffl wakeup selection wakeup select constitute atomic operation 
spread multiple dependent instructions execute consecutive cycles shown 
add sub instructions executed back back result select stage feed wakeup stage 
resulting pipeline bubbles seriously degrade performance especially programs limited parallelism 
wakeup select constitute atomic operation accomplished single cycle 
ffl data bypassing data bypassing example atomic operation 
order dependent operations execute consecutive cycles bypass value available dependent instruction cycle 
results earlier show feasible way machine delay bypass logic case relatively small 
wide issue machines width greater form clustering required feasible 
ffl register file access techniques pipeline ram employed pipeline register file 
tullsen studied effect spreading register read 
single thread performance degraded due increase branch mispredict penalty 
mentioned pipelining register file architects reduce latency duplicating register file 
copy register file half number read ports original register file 
technique dec 
case copies integer register file 
ffl cache access cache access pipelined number ways 
scheme implemented dec reads tags data cycle performs hit detection operation second cycle 
second aggressive scheme pipeline tag ram data ram 
pipelining cache facilitate faster clock degrade performance increasing load latency 
believe current order microarchitectures tolerate extra cycle latency minimize increase cycle count 
related trade size data instruction caches accessed single cycle bigger cache service misses 
discussion shows employ deeper pipelines enable ultra fast clocks window logic wakeup selection going critical structure 
report analyzed delay critical structures superscalar processors 
structures critical sense delay function issue width wire delays delay structures determine cycle time designs advanced technologies 
studied delays varied issue width window size 
studied delays scale feature sizes shrink wire delays prominent 
results show logic associated managing dispatch window superscalar processor critical structure move wider issue larger windows advanced technologies wire delays dominate 
functions implemented window logic broadcast result tags waiting instructions window 
delay operation determined delay wires span issue window 
delay operation increases quadratically window size issue width 
operation scale move larger windows wider issue widths advanced technologies wire delays dominate 
furthermore order able execute dependent instructions consecutive cycles back back delay window logic wakeup delay selection delay cycle 
addition window logic second structure needs careful consideration especially technologies data bypass logic 
length result wires broadcast bypass values increases linearly issue width delay data bypass logic increases quadratically issue width 
believe wire delays force architects consider clustered microarchitectures employed dec 
ahuja clark rogers 
performance impact incomplete bypassing processor pipelines 
proceedings th annual international symposium microarchitecture november 
simmons ike 
port ns word register file 
ieee international sold state circuits conference digest technical papers pages february 
semiconductor industry association 
national technology roadmap semiconductors 
mark bohr 
interconnect scaling real limiter high performance 
international electron devices meeting technical digest pages 
butler patt 
investigation performance various dynamic scheduling techniques 
proceedings th annual international symposium microarchitecture pages december 
chappell 
ns cycle ns access kb cmos ecl sram 
ieee international sold state circuits conference digest technical papers pages february 
marvin 
design powerpc risc microprocessor december 
tutorial talk th annual international symposium microarchitecture 
design ion implanted small physical dimensions 
ieee journal solid state circuits sc 
mhz dual issue cmos microprocessor 
ieee journal solid state circuits 
flynn 
optimal pipelining 
journal parallel distributed computing 
keith farkas norman jouppi paul chow 
register file design considerations dynamically scheduled processors 
proceedings second ieee symposium high performance computer architecture february 

hal reveals sparc processor 
microprocessor report march 

intel uses decoupled superscalar design 
microprocessor report february 
hwang fisher 
ns cmos adder multiple output domino logic 
ieee international sold state circuits conference digest technical papers pages february 
inoue um ns dynamic adder non precharge multiplexers reduced precharge voltage techniques 
symposium vlsi circuits digest technical papers pages june 
mark johnson norman jouppi 
transistor model synthetic um cmos process may 
class notes stanford university ee 

jouppi david wall 
available instruction level parallelism superscalar machines 
proceedings third international conference architectural support programming languages operating systems april 
jim keller 
superscalar alpha processor order execution october 
th annual microprocessor forum san jose california 
ashok kumar 
hp pa risc cpu high performance order processor 
proceedings hot chips viii pages august 
smith 
optimal pipelining supercomputers 
proceedings th annual international symposium computer architecture june 
mcfarland michael flynn 
limits scaling 
technical report csl tr revised stanford university november 
meta software hspice user manual june 
robert proebsting 
speed enhancement technique cmos circuits january 
united states patent 
jan rabaey 
digital integrated circuits design perspective 
prentice hall electronics vlsi series 
nakagawa 
oh moll 
scaling scheme interconnect deep processes 
technical report hpl hewlett packard laboratories july 
eric rotenberg steve bennet smith 
trace cache low latency approach high bandwidth instruction fetching 
proccedings th annual international symposium microarchitecture december 
smith 
implementing precise interrupts pipelined processors 
ieee transactions computers may 
suzuki ns double pass transistor logic 
ieee journal solid state circuits november 
dean tullsen exploiting choice instruction fetch issue implementable simultaneous multithreading processor 
proceedings rd annual international symposium computer architecture pages may 
mhz superscalar risc processor circuit design issues 
ieee international sold state circuits conference digest technical papers pages february 
wada suresh rajan steven 
analytical access time model chip cache memories 
ieee journal solid state circuits august 
neil 
principles cmos vlsi design 
addison wesley second edition 
steven norman jouppi 
enhanced access cycle time model chip caches 
technical report dec western research laboratory july 

mips superscalar microprocessor 
ieee micro april 
technology parameters hspice level models simulate synthetic cmos technologies table 
table gives metal resistance capacitance values assumed technologies 
parameter tox uo gamma vmax theta eta kappa phi nfs xj cj mj pb delta ld rsh vdd table spice parameters hspice level model technology metal metal omega ff table metal resistance capacitance delay results issue decoder wordline drive bitline sense amp total width delay ps delay ps delay ps delay ps delay ps technology technology technology table breakdown rename delay window tag drive tag match match total size delay ps delay ps delay ps delay ps issue width issue width issue width table breakdown wakeup delay technology window tag drive tag match match total size delay ps delay ps delay ps delay ps issue width issue width issue width table breakdown wakeup delay technology window tag drive tag match match total size delay ps delay ps delay ps delay ps issue width issue width issue width table breakdown wakeup delay technology window size ps root ps ps total delay ps technology technology technology table breakdown selection delay issue window rename wakeup selection bypass width size delay ps delay ps delay ps table delay results technology issue window rename wakeup selection bypass width size delay ps delay ps delay ps table technology 
