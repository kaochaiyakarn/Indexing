extended static checking java cormac flanagan rustan leino mark lillibridge greg nelson james saxe raymie stata compaq systems research center lytton ave palo alto ca usa software development maintenance costly endeavors 
cost reduced software defects detected earlier development cycle 
introduces extended static checker java esc java experimental compile time program checker finds common programming errors 
checker powered verification condition generation automatic techniques 
provides programmers simple annotation language programmer design decisions expressed formally 
esc java examines annotated software warns inconsistencies design decisions recorded annotations actual code warns potential runtime errors code 
gives overview checker architecture annotation language describes experience applying checker tens thousands lines java programs 
categories subject descriptors software engineering requirements specifications software engineering program verification general terms design documentation verification keywords compile time program checking 
decade group systems research center built experimented realizations new program checking technology call extended current address microsoft research microsoft way redmond wa 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
pldi june berlin germany 
copyright acm 
coverage type checking extended static checking program verification decidability ceiling effort static checkers plotted dimensions coverage effort scale 
static checking esc static checking performed running program extended esc catches errors caught conventional static checkers type checkers 
esc uses automatic theorem prover reason semantics programs allows esc give static warnings errors caught runtime modern programming languages null dereferences array bounds errors type cast errors 
warns synchronization errors concurrent programs race conditions deadlocks 
esc allows programmer record design decisions annotation language issues warnings program violates design decisions 
extended static checker esc modula described :10.1.1.152.4499
provides overview second checker esc java 
goal give complete description esc java give overview includes citations complete descriptions particular aspects checker 
static checking improve software productivity cost correcting error reduced detected early 
compares esc static checkers important dimensions degree error coverage obtained running tool cost running tool 
upper right corner full functional program verification theoretically catches errors extremely expensive 
lower left corner static checking techniques widely require modest effort catch limited class errors conventional type checkers type checker tools lint 
corners exercise magnetic programming researchers suggest middle diagram promising position esc hope produce cost effective tool catching errors type system lint tool cost full functional program verification 
horizontal line labeled decidability ceiling reflects known fact static detection errors engineering importance including array bounds errors null dereferences undecidable 
aim catch errors engineering experience targets choice type errors corrected kinds programs occur undecidability proofs rarely occur practice 
value checker needs handle simple cases call attention remaining hard cases focus manual code review 
distinguishing feature esc modula esc java perform modular checking operate piece program time necessary source program order run checker 
case piece single routine method constructor 
automatic checker manual checking code reviews modular checking checking scales 
consequently consider modular checking essential requirement 
cost modular checking annotations needed provide specifications routines called routine checked 
argue absence automatic checker manual checking depends annotations typically form english comments machine checkable easily get synch source code life program 
complicated predicate logic specifications required full functional verification esc annotations straightforward statements programmer design decisions 
excited prospect esc classroom may help notoriously difficult job teaching students write comments esc practical tool gives error messages form missing comment inaccurate comment 
attributes ideal static checker program errors checker report error called soundness mathematical logicians reported error genuine error false alarm called completeness mathematical logicians 
extended static checking take attributes requirement 
competing technologies manual code reviews testing sound complete 
certainly false alarms undesirable winnowing warnings find real errors added cost running tool certainly soundness desirable missed error lost opportunity checker useful insisting checker meet ideal mistaken engineering grounds checker finds errors cost running studying output checker cost effective success 
achieve cost effective tool requires making engineering trade offs variety factors including missed errors unsoundness spurious warnings incompleteness annotation overhead performance 
major novelty esc java compared esc modula esc java simpler annotation language 
important innovation contributing simplicity class bag int size int elements valid elements size bag int input size input length elements new int size system input elements size int int min integer max value int int size elements min min elements size elements elements size return min original version bag java 
object invariant annotation construct described 
simpler annotation language fact esc java targets popular programming language allowed get user experience esc java esc modula 
turn led engineer number improvements usability checker example execution trace information warning messages 

example esc java simplest way impart feeling esc java example detail 
shows small skeleton class integer bags aka multisets 
class provides operations bag may constructed array integers smallest element bag may extracted 
invoke checker user invokes just java compiler compiler command line bag java 
response seconds mhz pentium pro pc esc java produces warnings bag java warning possible null dereference null size input length bag java warning possible null dereference null elements min bag java warning array index possibly large elements min bag java warning possible null dereference null elements elements size bag java warning possible negative array index elements elements size warnings complaint bag constructor may dereference null called null argument 
reasonable responses constructor called null producing empty bag forbid calling constructor null 
example assume user chooses second response 
traditionally involve adding english comment constructor may called null hoping programmers writing code uses bag obey requirement 
esc java user inserts line checker readable comment called annotation expressing requires input null sign start java comment tells esc java esc java annotation 
annotation tells checker constructor precondition input null 
esc java checks routine assumes routine preconditions hold entry call site esc java issues warning verify preconditions called routine 
bag users annotation provides documentation lets esc java check bag correctly 
second fourth warnings complain different execution paths method may dereference null called field elements null 
warnings may spurious constructor sets elements non null value initially assign elements 
note elements private field client code subclasses may modify 
warnings arguably spurious elements declared private bag cause warned errors 
unfortunately detecting requires examining code bag sure assignment null elements esc java checks methods isolation 
annoying case realistic cases determining code assigns null elements difficult human reader warnings serve useful purpose missing useful documentation 
specify design decision elements nonnull user annotates declaration elements line non null int elements 
esc java generates warning appears code may assign null field declared non null checks constructors initialize fields non null values 
parameters may declared non null example adding line user changed line bag non null int input recommend users non null possible easier type specialized form easier verify produce precise warning messages 
remaining warnings complain possible subscript errors 
checker worried code set size bad value 
need object invariant invariant size size elements length object invariant property programmer intends hold routine boundary initialized instance class 
checker attempt prove size field correct bag initially constructed calling method preserves correctness 
checker able invariant reason subscript errors occur size field incorrect entry 
having changes user checker check possible errors 
surprise 
checker complains possible subscript errors warnings fact lines 
looking closely warning line user recalls java arrays indexed changes int size int size warning size may negative line 
know size called 
called bag empty 
size line decrement statement previous line 
oops 
user inserts guard assignment fix things size elements elements size running checker yields new warning fails reestablish object invariant bag java warning possible violation object invariant associated declaration bag java line col invariant size size elements length possibly relevant items counterexample context refers object invariant broken 
warning parts 
says invariant may broken method 
second says invariant involved 
third says object invariant may broken bag 
programmer acted statement just inserted needs protect decrement size size size elements elements size rerunning checker yields warnings 
means checker unable find potential errors necessarily program bug free 

architecture esc java second extended static checker developed systems research center 
architecture similar earlier checker targeted modula language :10.1.1.152.4499:10.1.1.152.4499
traditional compilers esc java architecture best thought pipeline data processing stages see 
describe stage turn 
front 
esc java front acts similarly normal java compiler parses type checks esc java annotations java source code 
background predicate universal background predicate annotated java program front syntax trees translator asts guarded commands vc generator gcs verification conditions theorem prover vcs prover results postprocessor output user basic steps esc java operation 
front produces syntax trees asts type specific background predicate class routines checked 
type specific background predicate formula order logic encoding information types fields routines class 
example type specific background predicate final class client final class include conjunct 
translator 
stage translates routine body checked simple language dijkstra guarded commands gcs 
esc java guarded command language includes commands form assert boolean expression 
execution guarded command said go wrong control reaches form assert false 
ideally body routine translate guarded command potential execution starts state satisfying background predicate class goes wrong way invoked state satisfying specified preconditions behave erroneously example dereferencing null terminating state violates specified postconditions 
practice translation incomplete unsound holds 
mention sources inaccuracy translation 
extensive discussion incompleteness unsoundness esc java see appendix esc java user manual 
modular checking 
accordance principle modular checking esc java produces guarded command routine translates routine call specification implementation called routine 
consequently resulting nondeterministic guarded command may able go wrong ways involving behaviors called routines permitted specification occur actual implementations 
course modular checking advantage correct respect specifications routines calls continue behave correctly implementations replaced overridden long new implementations continue meet specifications 
overflow 
model arithmetic overflow allowing checker consider cases adding positive integers getting negative sum leads spurious warnings 
loops 
precise semantics loops defined weakest fixpoints predicate transformers unfortunately fixpoints merely uncomputable difficult compute practical cases 
esc java approximates semantics loops unrolling fixed number times replacing remaining iterations code terminates producing error 
misses errors occur iterations loop 
command line options user control amount loop unrolling substitute sound alternative translation loops relies user supply explicit loop invariants 
default unroll loops half times half refers additional execution loop guard esc java front see section produced plausibly interesting new warning took longer doubled time produced new non spurious warnings 
expert users difficulty providing correct sufficiently strong loop invariants 
vc generator 
stage generates verification conditions vcs guarded command 
vc guarded command predicate order logic holds precisely program states execution command go wrong 
computation vc similar computation weakest precondition esc java vc generation includes optimizations avoid exponential blow inherent naive weakest precondition computation 
esc modula guarded commands intermediate stage deriving vcs directly asts 
esc java goes step factoring software complexity vc generation sugared form gc language shown intermediate stage asts basic gc language input vc generator 
initial step translating asts sugared gcs bulky tedious incorporating java specific details need written 
desugaring step final vc generation step simpler easily rewritten explore different soundness incompleteness tradeoffs possible performance improvements 
discussion see 
theorem prover 
routine stage invokes automatic theorem prover simplify conjecture bpt vcr vcr vc bpt type specific background predicate class defined universal background predicate encodes general facts semantics java example subtype relation reflexive antisymmetric transitive array types subtypes java lang object 
subject translation limitations discussed conjecture valid iff routine errors 
complete background predicate simple object oriented language see 
postprocessor 
final stage theorem prover output producing warnings prover unable prove verification conditions 
simplify originally designed esc modula evolved esc java properties aid postprocessor constructing user sensible warning messages just marking routine possibly erroneous 
counterexample contexts labels 
fails find proof conjecture simplify normally finds reports counterexample contexts counterexample context conjunction conditions collectively imply negation conjecture shown prover mutually inconsistent 
input simplify include positive negative labels subformulas 
label effect subformula logical value counterexample includes positive labels true subformulas negative labels false subformulas deemed heuristically relevant counterexample 
carrying information source code locations various stages processing esc java able label runtime check sufficient information produce detailed warning including type error location 
example postprocessor generates warning example section label null neq input null vc bag constructor 
esc modula esc java attaches labels pieces vc correspond error conditions pieces vc correspond execution particular fragments source code labels construct execution trace indicating possible dynamic path potential error 
multiple counterexample contexts 
routine may able fail multiple interesting ways different counterexample may required demonstrate failure occur 
modified simplify generate multiple counterexample contexts conjecture possible 
allows generate multiple warnings routine 
simplify keeps track labels reported counterexample contexts uses information keep generating multiple counterexamples turn similar warning messages 
time counterexample limits 
limit time simplify spends routine minutes default number counterexample contexts simplify may produce default 
limit exceeded esc java issues caution user indicating routine fully checked 
counterexample limit safeguards possibility esc java issue flood apparently distinct warnings arising single underlying problem program 
incompleteness 
esc java vcs formulas theory includes order predicate calculus semi decidable procedure proves valid formulas loops forever invalid ones 
allowing simplify report counterexample effort shown inconsistent able produce counterexamples time allotted 
spurious counterexamples lead spurious warnings 
simplify guaranteed bug free incorporates intentional lead missed warnings 

annotation language largest difference esc java esc modula lies annotation language 
section describe main features esc java annotation language 
full annotation language described esc java user manual 
general design considerations important design decision annotation language java possible 
major advantages esc java easier learn encouraging time annotations readable non esc java users increasing value primary documentation 
approximation annotations appear java declarations modifiers statements enclosed java comments sign 
expressions contained annotations side effect free java expressions additional keywords functions 
syntactic issues lie deeper design problems annotations include mean 
ideally annotations capture significant programmer design decisions succinctly 
equally important difficulty design annotation language users required document properties tedious specify don significantly enable detection important software errors 
annotation language shaped collaborative effort gary leavens java modeling language jml esc java annotation language similar feasible 
goals esc java jml different jml intended allow full specification programs esc java intended light weight specification 
differences languages remain syntactic semantic 
programs annotated esc java annotations amenable processing tools targeting jml vice versa programmers learn language little trouble picking 
data abstraction vs object invariants specification language esc modula included general data abstraction 
variables declared including object fields unknown compiler purposes specification language 
exact meaning variable representation declaration specifies value variable function variables concrete 
general data abstraction powerful 
esc modula verifications generally stylized way call state validity paradigm 
paradigm variables declared fields object type valid state 
idea valid means object satisfies internal validity invariant type state represents state object full functional correctness verification specifications write state typical esc modula verification little said appears modifies list operations change concrete variables part representation declared means abstraction dependency 
contrast state esc modula checking depends heavily valid operations object valid precondition initialization operations valid postcondition operations destroy validity operation close file valid modifies list indicating guaranteed preserve validity 
uses valid enforce protocol client type client call proper initialization operation object may continue object object validity compromised 
representation declaration valid defines meaning validity concrete terms 
declaration typically placed implementation required 
verifying implementation operation type precondition valid translated concrete terms usual process data abstraction representation scope 
occurrences valid specifications enforce proper behavior part client representation invisible client representation matters implementation client 
general data abstraction reasonable complicated pages 
mindful principle perfection achieved left add left remove decided leave data abstraction esc java 
esc modula data abstraction exclusively state validity paradigm 
esc java object invariants provide checking provided variable valid valid state paradigm 
checking provided variable state find real errors 
esc java support ghost fields see section known checker compiler 
ghost fields substitute fields fields change automatically representation changes ghost fields updated explicit assignment consider case concrete mimic situation ghost field explicit ghost assignment set changes 
adding object invariant provide protection error update inadvertently omitted 
requires considerably annotation variable approach 
practical manifestation remarks variable state validity paradigm advantage object invariants ability accurately specify methods destroy validity 
close methods source false alarms esc java principle avoided soundly introducing ghost field valid updating close init methods common simply suppress warnings provides checking error invalid object passed method requires validity 
spite remarks previous paragraphs judgment retrospect decision remove variables introduce object invariants ghost variables successful step goal producing cost effective engineering tool 
routine specifications routine specifications contain parts requires modifies ensures precondition exceptional postcondition exception type boolean specification expressions modifies list list lvalues 
result refers value returned 
refers exception thrown 
expression form old refers value expression pre state 
modifies list specifies fields routine may modify 
implicit list routine allowed modify fields objects allocated start routine invocation 
call site esc java assumes variables indicated modifies list changed call 
esc java check implementation obeys modifies list 
unsoundness motivated follows writing variables routine may modify impossible variables may scope may reside subclasses written 
fundamental problem solved data abstraction esc modula 
costs omitting data abstraction esc java unable general check modifies lists 
variety approaches checking tool take respect modifies lists esc modula took theoretically sound approach cost complexity annotation language 
esc java takes extreme modifies lists assumed correctly programmer tool uses check 
suggests theoretically sound solutions may feasible practical checker imposing restrictions programming model 
overriding methods inherit specifications methods override 
users may strengthen ensures sound 
strengthening precondition extending modifies list sound 
esc java provide data abstraction prudent allow unsound modifies lets users express design decisions variables method override may modify corresponding checking sound 
compelled add requires deemed probable programmer error programmers design programs sound strengthen preconditions subclasses 
due lack abstraction features allow requires special case described user manual 
addition single inheritance subclassing java features multiple inheritance interfaces 
sound way combine multiple inherited specifications method take mathematical join lattice conjunctive predicate transformers done jml 
approach leads problems explain pre postcondition violations warning messages 
esc java uses simpler unsound approach union specification parts inherited overridden methods 
object invariants designing mechanically checkable object invariant system complicated task 
space reasons discuss briefly important issues involved 
operation boundaries 
conceptually object invariants object may broken operation question arises consider operation 
simplest approach largely adopted consider routine separate operation 
particular consider subroutines called routine part operation means routine restore invariants broken may call subroutines 
exception users may mark methods modifier helper methods considered part operation routine calling 
achieved inlining calls helpers goes modular checking 
annotation useful cases expensive excessively 
invariant enforcement 
practice enforcing invariants operation boundaries strict method call harmless function square root invariant broken 
called code expect invariants hold usually safe allow subroutine calls long code called indirectly reach object invariants broken 
property locally checkable unwieldy amount annotation esc java checks invariants call sites arguments static fields 
heuristic disallows calls error passing invalid object argument allows calls square root okay 
invariant placement 
entire program may available possible get effect checking invariants adopting restrictions invariants declared 
roughly invariant mentioning field visible usually means invariant declared class declares understanding restrictions needed esc java enforce 
constructors 
require satisfy invariants case constructor terminates exceptionally unsound rare case copy survives constructor termination 
ghost fields esc java lack data abstraction simplifies annotation language checker reduces expressiveness annotation language 
useful describe behavior class terms additional state java program leaves implicit 
purpose esc java provides ghost fields ordinary fields java compiler see 
ghost fields specify behavior dependent state object variables suitable 
example usage protocol hasmoreelements methods enumeration class expressed terms boolean ghost field denoting condition elements available 
common ghost fields esc java absence generic types parametric polymorphism java 
example class vector introduce ghost field ghost public type special type type esc java denotes type java types 
ghost field class vector specified 
example methods adding retrieving element vector specified follows requires typeof obj public void addelement object obj ensures typeof result public object elementat int index client vector set ghost field esc java set annotation vector 
example vector new vector set type string creates vector 
escape hatches designed esc java annotation language checking common programmer design decisions easily expressed 
situations arise convincing checker correctness design requires powerful annotation features checking provided 
situations needs escape hatches get strictness static checking system 
esc java nowarn annotation suppresses selected warnings source line appears 
esc java nowarn command line switch turns selected warnings entire program allowing users customize degree checking 
turn warnings violations pre conditions post conditions object invariants order check program consistent user specified protocol see example 
precise escape hatch statement annotation assume causes esc java blindly assume condition holds program point checking 
uses assume nowarn focused targets manual code reviews 
simple properties routine null depend complex properties routines calls 
cases judicious escape hatches save users specification creep tends upper right corner 
performance esc java checks routine invoking automatic theorem prover simplify 
theorem proving expensive undecidable worst case potential problem esc java slow interactive 
put considerable effort spent esc modula project improving performance theorem prover encoding background predicates form plays strengths routine percentage checked time limit size routines min mins total percentage routines various sizes java front benchmark checked routine time limit 
theorem prover generating vcs form amenable efficient proving 
combined result various optimizations performance esc java sufficient majority cases 
applied esc java variety programs report performance esc java largest programs esc java java front 
program contain lines code kloc routines 
illustrates performance esc java program mhz alpha processor 
routines categorized size lines code 
category shows number routines category percentage routines checked particular routine time limit 
results show routines fairly small lines esc java check great majority routines seconds 
performance esc java satisfactory small number particularly complex routines 
routine routines program esc java unable verify default minute time limit 

experience section describes experience applying esc java variety programs 
programs include java front portions web crawler mercator assortment smaller programs 
annotation overhead esc java annotation checker relies programmer provide annotations giving lightweight specifications routine 
costs esc java overhead writing necessary annotations 
cases annotations straightforward document basic design decisions example method argument null integer variable valid index particular array 
experience annotating mercator indicates roughly annotations required lines code 
illustrates number kinds annotations required programs 
programs annotations inserted program written iterative process program annotated inspection program code rough understanding behavior annotation type annotations kloc mercator non null invariant requires ensures modifies assume nowarn total number kinds annotations required benchmarks 
initial set annotations subsequently refined feedback produced esc java checking annotated program 
typically programmer annotate lines code hour existing unannotated program 
overhead expensive larger programs obstacle esc java catch defects large unannotated programs 
possible esc java selected modules necessary annotate routines called modules 
investigating annotation inference techniques help reduce annotation burden legacy code 
writing annotations program developed better strategy esc java write appropriate annotations run checker early possible development cycle writing method class 
manner esc java potential catch errors earlier testing catch errors entire program appropriate test harness written 
catching errors earlier cheaper fix suggest esc java manner may reduce software development costs addition increasing program reliability 
subsections illustrate esc java ability find software defects proven difficult catch testing 
mercator authors web crawler mercator allan heydon marc najork esc java check portions mercator 
heydon najork involved esc java project experience may typical average esc java users 
heydon najork annotated checked packages mercator containing kloc roughly hours 
esc java caught previously undetected bug hash table implementation 
hash table array pointing secondary array values hash code 
possible entry main array null 
checkpointing code writes hash table disk failed check null pointer main array 
defect show testing hash table checkpointed heavily loaded entries main array non null 
defect may missed code review especially design decision entries main array may null documented 
esc java requires explicating design decisions detect defects decisions respected 
lillibridge spent weeks annotating esc java front time measured lines 
process half dozen previously undetected errors 
lillibridge assessed errors having worth weeks discover benefit annotations just started 
time run esc java checking changes revealing additional half dozen errors detected shortly introduced 
ll describe particularly interesting experience 
leino performed major piece surgery complicated class correlates source code locations positions input stream 
finishing edits leino ran compiler launched esc java sources logged day 
morning regression suite passed running esc java new front simple programs caused crash 
spending hours pinpointing error leino wondered esc java detected 
forgotten check esc java output starting debug 
esc java error failure establish precondition stream marked esc java output revealed error different call site 
case esc java output saved hours tracking problem 
entire run esc java taken minutes minutes applied file containing errors 
correcting errors tricky leino able insert annotations run esc java check understanding various state changes program 
draw experience 
keeping machine checkable design decisions program provides payoff code maintenance valuable cost maintenance easily outweigh cost initial code development 
second errors esc java detected violations design decisions easily extracted code 
include protocol designs call routine streams marked 
esc java provides flexible powerful framework checking protocol errors 
fact may consider esc java mode checks violations user supplied annotations crashes language catch runtime 
user experience esc java available download research compaq 
com src esc 
year received emails users stream questions increase 
heard success stories esc java errors code times surprising authors code 
users pulled magnetic upper right corner attempted esc java perform full functional correctness verification 
way surprised run difficulties caused simplify engineered automatic complete 
believe learning give put assume annotation lead costeffective esc 

related closest related esc java previous extended static checking esc modula :10.1.1.152.4499
research esc modula summarized answering affirmatively question extended static checker find bugs automatic esc java focused questions simple annotation language checker cost effective 
targeting different popular language esc java incorporates innovations esc modula including greater similarity source annotation languages object invariants data abstraction execution traces multiple warnings method timeouts generation suggestions respond warnings described different treatments loops multi stage translation guarded commands different vc generation guarded commands differently chosen engineering trade offs comprehensive user manual variety new annotations including helper variety internal improvements 
believe produced tool simpler price missing errors esc modula 
perspective building esc modula esc java see 
goal decades old providing programming language features write information strictly needed compilation 
earliest serious attempt know euclid included constructs express example pre postconditions procedures 
motivation enable programs verified formal language semantics reach machine checkable maturity 
pre postconditions assertions checked runtime 
newer widely language spirit object oriented language eiffel pre postconditions object invariants checked runtime 
language progress vault promising ideas include type features take step preventing certain kinds resource management programming errors 
research area related extended static checking refinement types 
refinement type essentially restricted form object invariant 
refinement types investigated functional programming languages xi pfenning done imperative languages 
compile time techniques finding errors programs 
esc approach uses programmer supplied annotations documenting design decisions techniques gone direction completely eliminating annotation overhead extent annotations supplied 
difference esc techniques build modular checking start typically applied entire program 
mention techniques symbolic execution underlying technique successful bug finding tool prefix programs 
procedure prefix synthesizes set execution paths called model 
models reason calls process somewhat modular fixpoints models approximated iteratively recursive mutually recursive calls 
prefix gets ad hoc constraint solver theorem prover underlying logic 
annotation language due scheme associating weight warning surely due large number possible errors users sort warnings weight easily ignoring relevant warnings 
interpretation established technique uses heuristics iteratively build model program 
absence errors program implies absence errors program 
interpretation applied successfully applications including space rocket controllers 
symbolic model checking technique success finding hardware design errors software checking community 
popular idea predicate abstraction reason infinite state program finite state system model checked 
intriguing system idea including automatic engine incrementally inferring predicates abstraction slam 
tools verify properties software systems finite state models bandera java pathfinder 
addition techniques tools useful program development 
example lclint tool part environment building linux 
tools focused checking particular kinds errors concurrency errors mention see esc modula report reports experience extended static checking finding concurrency errors mentions pieces related field :10.1.1.152.4499
engler shows surprisingly effective technique finding errors heuristic scan irregularities program source code 
going bug finding tools tools geared full verification programs 
systems remained academic labs applied small textbook programs verification specific algorithms systems applied actual safety critical programs 
successful example system construct part metro subway system paris 
example tool perfect developer object oriented language escher 
escher systems restrict programming language various extents require manual guidance underlying theorem provers 
big brother esc java annotation language java modeling language jml allows fuller specifications java programs 
mentioned section collaboration designers jml tried smooth gratuitous differences specification languages making esc java subset jml 
loop tool translates jml annotated java verification conditions input theorem prover pvs 
relation jml loop esc java described detail short 
similarities tools asset specifying checking javacard interface electronic purse application 
similarities allowed jml esc java concert teaching software engineering course kansas state university 
mention intriguing built top esc java 
michael ernst investigated dynamic inference program invariants 
inference produce esc java annotations 
annotation inference system esc java houdini uses esc java subroutine inferring annotations 

past years esc java check variety programs including moderately large systems mercator 
experience esc java developers users supports thesis esc java detect real significant software defects 
addition performance esc java sufficient interactive complex methods 
esc java design incorporates trade soundness usefulness cases sacrifices soundness reduce annotation cost improve performance 
examples unsound features include loop unrolling partial enforcement object invariants 
large experience supports limited unsoundness technique clearly reduces cost checker believe number bugs missed due features small 
ongoing research continues tackle significant sources unsoundness including loops loop invariant inference modifies lists 
esc java annotation language java uses object invariants opposed esc modula data abstraction 
design decisions helped keep annotation language intuitive 
object invariants somewhat expressive data abstraction limitation appear cause problems practice 
despite esc java success finding real errors feedback users suggests tool reached desired level cost effectiveness 
particular users complain annotation burden perceived heavy excessive warnings non bugs particularly unannotated partially annotated programs 
users retroactively annotated checked existing programs esc java support development project life cycle 
point uncertain lifetime software project esc java cost effective tool mainstream programmers 
certainly experience past years esc java support development encouraging possible esc java useful highly disciplined programming teams 
hopeful additional research reducing spurious warnings lowering perceived annotation burden example annotation inference statically houdini dynamically daikon may yield extended static checking tool add significant value process engineering software 
believe esc java suitable classroom setting resource reinforcing lessons modularity design verification 

acknowledgments todd millstein research intern compaq src implemented reporting execution traces esc java output 
caroline tice rajeev joshi lent helping hands programming porting 
additionally re grateful allan heydon marc najork esc java users shared experiences tool feedback 

ball rajamani 
automatically validating temporal safety properties interfaces 
dwyer editor proc 
th spin workshop volume lncs pages 
springer may 
burch symbolic model checking states 
information computation 
bush pincus 
static analyzer finding dynamic programming errors 
sp june 
cata huisman 
formal specification electronic purse case study 
proc 
formal methods europe fme 
springer verlag 
appear 
corbett bandera extracting finite state models java source code 
proc 
nd icse june 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
th popl pages 
acm 
deline hndrich 
enforcing high level protocols low level software 
proc 
pldi pages 
detlefs leino nelson andj saxe :10.1.1.152.4499
extended static checking 
research report compaq src dec 
detlefs nelson andj saxe prover program checking 
research report compaq src 
preparation 
dijkstra 
discipline programming 
prentice hall englewood cliffs nj 
dwyer hatcliff howell 
cis software specification 
kansas state univ dept comp 
inf 
sciences spring 
engler bugs deviant behavior general approach inferring errors systems code 
proc 
th sosp pages 
acm 
ernst dynamically discovering program invariants support program evolution 
proc 
icse pages 
acm 
escher technologies getting started perfect 
available www com 
evans guttag horning tan 
lclint tool specifications check code 
editor proc 
nd sigsoft fse pages 
acm 
flanagan joshi leino 
annotation inference modular checkers 
inf 
process 
lett feb 
flanagan leino 
houdini annotation assistant esc java 
oliveira zave editors fme formal methods increasing software productivity volume lncs pages 
springer mar 
flanagan qadeer 
predicate abstraction software verification 
proc 
th popl page appear 
acm jan 
flanagan saxe 
avoiding exponential explosion generating compact verification conditions 
proc 
th popl pages 
acm 
graf sa di 
construction state graphs pvs 
grumberg editor proc 
th cav volume lncs pages 
springer 
heydon najork 
mercator scalable extensible web crawler 
world wide web dec 
hoare 
proof correctness data representations 
acta inf 
johnson 
lint program checker 
comp 
sci 
tech 
rep bell laboratories 
lampson horning london mitchell popek 
report programming language euclid 
technical report csl xerox parc oct 
leavens baker ruby 
preliminary design jml behavioral interface specification language java 
technical report dept comp 
sci iowa state univ july 
leavens leino poll ruby jacobs 
jml notations tools supporting detailed design java 
oopsla companion pages 
acm 
leino 
object oriented programming language axiomatic semantics 
fool 
leino 
data groups specifying modification extended state 
proc 
oopsla pages 
acm 
leino 
applications extended static checking 
cousot editor th intl 
static analysis symp volume lncs pages 
springer july 
leino 
extended static checking year perspective 
wilhelm editor informatics years back years ahead volume lncs pages 
springer jan 
leino 
joining specification statements 
theoretical comp 
sci mar 
leino nelson 
data abstraction information hiding 
research report compaq src nov 
leino nelson saxe 
esc java user manual 
tech 
note compaq src oct 
leino poetzsch heffter zhou 
data groups specify check side effects 
proc 
pldi 
leino saxe stata 
checking java programs guarded commands 
jacobs editor formal techniques java programs tech 
report 
hagen may 
leino stata 
checking object invariants 
tech 
note dec src jan 
meyer 
object oriented software construction 
series computer science 
prentice hall intl 
millstein 
informative esc java warning messages 
mason editor selected src summer intern reports tech 
note 
compaq src 
ller poetzsch heffter leavens 
modular specification frame properties jml 
technical report dept comp 
sci iowa state univ feb 
appear concurrency practice experience 
nimmer ernst 
automatic generation checking program specifications 
technical report mit lab computer science aug 
owre rajan rushby shankar srivas 
pvs combining specification proof checking model checking 
alur henzinger editors proc 
th cav volume lncs pages 
springer 
poll van den berg jacobs 
specification javacard api jml 
ferrer chan watson editors fourth smart card research advanced application conference pages 
kluwer acad 
publ 
sterling 
static data race analysis tool 
proc 
winter usenix conf pages 
usenix assoc jan 
turin deutsch gonthier 
la des programmes ariane 
pour la science jan 
french 
van den berg jacobs 
loop compiler java jml 
proc 
tacas volume lncs pages 
springer 
visser havelund brat park 
model checking programs 
international conference automated software engineering sept 
wing 
tiered approach specifying programs 
phd thesis mit laboratory computer science may 
available mit lcs tech 
report 

software engineering addison wesley 
xi 
imperative programming dependent types 
proc 
th lics pages june 
xi pfenning 
dependent types practical programming 
proc 
th popl pages 
acm jan 
