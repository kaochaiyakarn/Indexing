resolution versus search strategies sat rish rina dechter information computer science university california irvine ics uci edu dechter ics uci edu compares popular strategies solving propositional satis ability backtracking search resolution analyzes complexity directional resolution algorithm dr function width problem graph 
empirical evaluation con rms theoretical prediction showing low problems dr cient greatly outperforming backtracking davis putnam logemann loveland procedure dp 
emphasize properties dr extend tree clustering algorithm facilitates query answering 
propose hybrid algorithms combine advantages dr dp 
algorithms control parameters bound complexity resolution allow time space trade adjusted problem structure user computational resources 
empirical studies demonstrate advantages hybrid schemes 
keywords propositional satis ability backtracking search resolution computational complexity knowledge compilation empirical studies 
partially supported nsf iri 
propositional satis ability sat prototypical example np complete problem np complete problem reducible sat polynomial time 
practical applications planning scheduling diagnosis formulated propositional satis ability nding algorithms average performance focus extensive research years 
consider complete sat algorithms determine satis ability opposed incomplete local search techniques 
widely complete techniques backtracking search davis putnam procedure resolution directional resolution 
compare approaches theoretically empirically suggesting ways combining ective hybrid algorithms 
davis putnam resolution algorithm deciding propositional satis ability davis putnam algorithm 
proved restricted amount resolution performed ordering propositions propositional theory su cient deciding satis ability 
algorithm received limited attention analyses performance emphasized worst case exponential behavior overlooking virtues 
quickly overshadowed davis putnam procedure introduced davis logemann loveland 
proposed minor syntactic modi cation original algorithm resolution rule replaced splitting rule order avoid exponential memory explosion 
modi cation changed nature algorithm transformed backtracking scheme 
propositional satis ability quotes backtracking version 
refer original davis putnam algorithm dp resolution resolution dr modi cation dp backtracking called dpll sat community 
evaluation substantial empirical component 
common approach empirical sat community test algorithms randomly generated problems uniform random sat 
benchmarks fail simulate realistic problems 
hand real life benchmarks available instance instance basis knowledge underlying distributions empirical results hard generalize 
alternative random problem generators inspired properties realistic domains 
example illustrates unit commitment problem scheduling set power generating units hours 
state unit time similar approach known ordered resolution viewed sophisticated rst order version directional resolution 
clique clique unit min time min time example temporal chain unit commitment problem units hours 
speci ed value boolean variable xit minimum time constraints specify long unit stay particular state switched 
corresponding constraint graph embedded chain cliques clique includes variables number time slices determined time constraints 
clique chain structures common temporal domains possess markov property independent past 
example structured domain circuit diagnosis 
shown circuit diagnosis benchmarks embedded tree cliques clique sizes substantially smaller number variables 
general imagine variety real life domains having structure captured tree embeddings random problem generators 
empirical studies sat algorithms con rm previous results dr ine cient dealing unstructured uniform random problems 
structured problems ask tree embeddings having bounded induced width directional resolution outperforms dp backtracking orders magnitude 
induced width denoted graph parameter describes size largest clique created problem interaction graph inference 
show worst case time space complexity exp number variables 
identify tractable problem classes re ned syntactic parameter called diversity 
induced width smaller number propositional variables dr worst case bound generally better exp worst case time bound dp 
practice dp backtracking best complete sat algorithms worst case time average time space output backtracking exp solution resolution exp better worst case worst case exp knowledge compilation comparison backtracking resolution 
available cient worst case bound 
demonstrates great discrepancies execution time knuth encountering rare exceptionally hard problems 
studies suggest empirical performance backtracking algorithms modeled long tail exponential family distributions lognormal weibull 
average complexity algorithm dr hand close worst case 
important note space complexity dr space exponential di erence addition deciding satis ability nding solution model directional resolution generates equivalent theory allows nding model linear time nding models time linear number models viewed knowledge compilation algorithm 
complementary characteristics backtracking resolution call hybrid algorithms 
hybrid schemes control parameters restrict amount resolution bounding resolvent size preprocessing phase dynamically search 
parameters allow time space trade adjusted problem structure computational resources 
empirical studies demonstrate advantages exible hybrid schemes extremes backtracking resolution 
extension includes new results 
tree clustering algorithm query processing extends dr analyzed 
bounded directional resolution bdr approach proposed subjected extensive empirical tests include randomly gener ated problems dimacs benchmarks 
new hybrid algorithm dcdr introduced evaluated empirically problems 
rest organized follows 
section provides necessary de nitions 
section describes directional resolution dr version original davis putnam algorithm expressed bucket elimination framework 
section discusses complexity dr identi es tractable classes 
extension dr tree clustering scheme section section focuses dp backtracking 
empirical comparison dr dp section 
section introduces hybrid schemes bdr dp dcdr empirically evaluates ectiveness 
related discussed sections 
proofs theorems appendix de nition preliminaries denote propositional variables propositions uppercase letters propositional literals propositions negations asp letters disjunctions literals clauses letters greek alphabet instance clause 
denote clause fp rg 
clause clause literal 
clause positive contains positive literals negative contains negative literals 
notation shorthand refers clause literals appear clause subsumed clause literals include literals 
clause tautology proposition clause includes theory conjunctive normal form cnf represented set tg denoting conjunction clauses cnf theory contains clauses length 
propositional cnf theory de ned set variables qn called simply theory 
set models theory set truth assignments variables satisfy 
clause entailed denoted true models 
propositional satis ability problem sat decide cnf theory model 
sat problem de ned cnfs called sat problem 
structure propositional theory described graph 
interaction graph propositional theory denoted undirected graph contains node propositional variable edge pair nodes correspond variables appearing clause 
example interaction graph theory shown 
commonly approach satis ability testing resolution op resolution interaction graph theory ect resolution graph 
eration 
resolution clauses results clause called resolvent eliminating variable interaction graph theory processed resolution augmented new edges re ecting added resolvents 
example resolution variable generates new clause graph resulting theory edge nodes shown 
resolution unit clause called unit resolution 
unit propagation algorithm applies unit resolution cnf theory new clauses deduced 
propositional satis ability special case constraint satisfaction problem csp 
csp de ned constraint network fx xng set variables associated set nite domains fdi set constraints fc cmg 
constraint ci relation ri di di de ned subset variables si fxi xi constraint network associated undirected constraint graph nodes correspond variables nodes connected participate constraint 
constraint satisfaction problem csp nd value assignment variables called solution consistent constraints 
assignment exists network inconsistent 
constraint network binary constraint de ned variables 
directional resolution dr dp resolution ordering resolution algorithm described follows 
arbitrary ordering propositional variables assign clause index highest literal ordering 
resolution applied clauses having index highest literal 
result restriction systematic elimination literals set clauses candidates directional resolution dr input cnf theory qn 
output decision satis able 
directional extension eo equivalent 

initialize generate partition clauses bucket contains clauses highest literal qi 

unit clause unit resolution resolve qi qi 
empty return unsatis able add bucket highest variable 

return satis able eo 
algorithm directional resolution dr 
resolution 
original dp resolution includes additional steps forcing unit resolution possible assigning values positive negative variables 
positive negative variable variable appears positively negatively theory assigning avariable value true false equivalent deleting relevant clauses theory 
intermediate steps introduced basic steps eliminating highest indexed variable deleting subsumed clauses 
albeit focus ordered elimination step refer auxiliary steps necessary 
interested deciding satis ability set clauses accumulated process constituting equivalent theory useful computational features 
algorithm directional resolution dr core dp resolution 
algorithm described notion buckets de ne ordered partitioning clauses follows 
ordering qn variables clauses containing qi contain symbol higher ordering placed 
algorithm processes buckets reverse order qn 
processing involves resolving qi possible pairs clauses bucket 
resolvent added bucket highest variable qj clearly 
note bucket contains unit clause qi qi unit resolutions performed 
clearly useful dynamic order heuristic included current implementation processes bucket unit clause 
output theory nd model eo input directional extension eo qn 
output model 

qi value qi consistent assignment qi clauses 

return qn 
algorithm nd model 
eo called directional extension shown davis putnam algorithm nds satisfying assignment theory exists 
theorem algorithm dr sound complete 
model theory easily consulting eo simple procedure nd model 
formally theorem model generation eo satis able theory procedure nd model generates model backtrack free time 
example input theory ordering theory partitioned buckets processed directional resolution reverse order resolving variable produces new clause placed 
resolving produces clause placed 
resolving produces clause placed 
directional resolution terminates resolution performed 
output non empty directional extension eo 
directional extension available model generation begins 
clauses bucket rst variable ordering assigned value 
clause implies clause implies clause illustration selected arbitrary ordering cient 
variable ordering heuristics discussed section 
bucket bucket bucket bucket bucket knowledge compilation model generation input directional extension trace algorithm dr theory ordering 
current assignments implies 
assigned value clauses bucket satis ed previous assignments 
stated theorem directional extension model generated linear time 
eo compiled determining entailment single literal requires checking bucket literal rst 
literal appears unit clause entailed entailed negation added appropriate bucket algorithm resumes bucket 
empty clause generated literal entailed 
entailment queries discussed section 
complexity tractability clearly ectiveness algorithm dr depends size output theory eo 
theorem complexity theory ordering time complexity algorithm dr number variables 
size directional extension complexity directional resolution worst case exponential number variables 
identi able cases size eo bounded yielding tractable problem classes 
order variable processing particularly signi cant ect size directional extension 
consider examples example ordering clauses initially placed bucket 
applying dr reverse ordering get bucket bucket bucket contrast directional extension ordering identical input theory bucket contains clause 
example consider theory directional extensions ordering eo eo respectively 
example variable appears clauses 
potentially generate new clauses resolved processed appears rst ordering 
shows interactions variables ect performance algorithm consulted producing preferred orderings 
example hand symbols type interaction appearing clauses 
appears positive clauses bucket resolved processed rst 
subsequently appear negatively remaining theory add new clauses 
inspired examples provide connection algorithm complexity parameters topological parameter called induced width syntactic parameter called diversity 
induced width section show size directional extension complexity directional resolution estimated graph parameter called induced width 
noted dr creates new clauses correspond new edges resulting interaction graph say dr induces new edges 
illustrates performance directional resolution theory ordering showing time interaction graph eo dashed lines correspond induced edges 
resolving creates clause corresponds new edge bucket bucket bucket bucket bucket directional input extension width induced width ect algorithm dr interaction graph theory ordering 
nodes resolving creates clause induces new edge general processing bucket variable produces resolvents connect variables mentioned bucket 
concepts induced graph induced width de ned re ect changes 
de nition graph ordering nodes parent set xi set nodes connected xi precede xi size parent set called width xi relative 
width graph denoted wo maximum width variables 
induced graph denoted io obtained follows going connect neighbors xi preceding ordering 
induced width denoted width io induced width minimum induced width ordering 
example induced graph io contains original bold induced dashed edges 
width induced width width induced width 
maximum width width maximum induced width induced width 
case width induced width graph coincide 
general induced width graph signi cantly larger width 
note ect ordering induced width interaction graph theory orderings 
example graph directional extension eo coincides induced ordered graph input theory graph io 
generally lemma theory ordering eo subgraph io 
parents node xi induced graph correspond variables mentioned 
induced width node estimate size bucket follows lemma theory ordering qn parents induced graph bucket variable qi eo contains clauses 
derive bound complexity directional resolution properties problem interaction graph 
theorem complexity dr theory ordering variables time complexity algorithm dr size eo clauses induced width interaction graph corollary theories having bounded ordering tractable 

demonstrates ect variable ordering induced width consequently complexity dr applied theory 
dr generates new interaction graph example clauses length ordering binary clause generated ordering 
nding ordering yields smallest induced width np hard heuristic orderings currently available continue explored :10.1.1.40.1018
furthermore class graphs known trees recognized exp time 
de nition trees 
clique size complete graph nodes tree 

tree de ned xi tree xi generated selecting clique size connecting xi node clique 
corollary interaction graph theory having variables subgraph tree space complexity algorithm dr size eo iso time complexity 
important tractable classes trees series parallel networks 
classes recognized polynomial linear quadratic time 
example consider theory de ned variables fa ang 
clause ai ai ai de ned clauses ai ai ai ai ai de ned interaction graph shown 
reader verify graph tree induced width original ordering 
theorem size directional extension exceed 
sat note algorithm dr tractable cnf theories cnfs closed resolution resolvents size number clauses size bounded case unordered resolution tractable yielding complexity 
theorem cnf theory directional extension eo ordering size generated ino time 
obviously dr best algorithm solving sat sat solved linear time 
note dr compiles theory produces model linear time 
shown case models generated output linear time 
graphical ect unit resolution resolution unit clause deletes opposite literal relevant clauses 
equivalent assigning value variable unit resolution generates clauses variables connected graph add new edges 
diversity concept induced width leads loose upper bound number clauses recorded dr example clauses generated dr eliminating subsumption tautologies bucket computed bound 
consider clauses order bucket processed clause added positive clauses nodes connected induced graph 
subsection introduce new parameter called diversity provides tighter bound number resolution operations bucket 
diversity fact proposition resolved appears positively negatively di erent clauses 
de nition diversity theory ordering denote number times qi appears positively negatively 
diversity qi relative div qi de ned diversity ordering div largest diversity vari ables relative diversity theory div minimal diversity orderings 
concept diversity yields new tractable classes 
example ordering having zero diversity algorithm dr adds clauses regardless induced width 
example easy see ordering diversity induced width 
theorem zero diversity theories tractable dr zero diversity theory having variables clauses 
zero diversity ordering time 
dr takes linear time 
proof follows immediately theorem see subsection 
zero diversity theories generalize notion causal theories de ned general constraint networks multivalued relations 
de nition theories causal ordering propositional variables bucket contains single clause 
consequently ordering zero diversity 
clearly theory non zero diversity better place zero diversity variables ordering processed rst 
pure literal rule original davis putnam resolution algorithm requires processing rst positive negative zero diversity clauses 
parameter real interest diversity directional extension eo diversity 
de nition induced diversity induced diversity ordering div diversity induced diversity theory div minimal induced diversity orderings 
div bounds number clauses generated bucket size eo bounded div 
problem computing div generally polynomial restricted cases 
case class zero diversity theories mentioned div div 
case class theories having div 
note easily create examples high having div 
theorem theory de ned variables qn symbol qi appears negatively positively appears exactly clauses div tractable 
ordering heuristics previously noted nding minimum induced width ordering known np hard 
similar result demonstrated minimum induced diversity orderings 
corresponding suboptimal non induced min width min diversity heuristic min diversity 
choose symbol having smallest diversity put th position 
algorithm min diversity 
min width 
initialize 

choose symbol having smallest degree put th position 

fqg 
algorithm min width 
orderings provide relatively low induced width induced diversity 
min width min diversity orderings computed polynomial time simple greedy algorithm shown figures 
theorem algorithm min diversity generates minimal diversity ordering theory time number variables number clauses input theory 
min width algorithm similar min diversity step select variable smallest degree current interaction graph :10.1.1.40.1018
selected variable placed th ordering deleted graph 
modi cation min width ordering called min degree connects neighbors selected variable current interaction graph variable deleted 
empirical studies demonstrate min degree heuristic usually yields lower orderings induced width heuristic 
heuristics ties broken randomly 
commonly ordering heuristics cardinality heuristic 
details see :10.1.1.40.1018
min degree 
initialize 

choose symbol having smallest degree put th position 

connect neighbors 
fqg 
algorithm min degree 
max cardinality 
choose symbol connected maximum number previously ordered nodes put th position 
algorithm max cardinality 
directional resolution tree clustering section discuss knowledge compilation aspects directional resolution relate tree clustering general preprocessing technique commonly constraint belief networks 
stated theorem input theory variable ordering algorithm dr produces directional extension allows model generation linear time 
entailment queries restricted small xed subset variables orderings initiated queried variables preferred cases subset directional extension needs processed 
complexity case exp min jcj computed induced graph truncated variables queries expected uniformly distributed variables querying variables implies addition unit clauses edges incident queried variables deleted reducing induced width 
generate compiled theory symmetrical regard variables 
accomplished tree clustering compilation scheme constraint networks 
cnf theories special types constraint networks tree clustering immediately applicable 
algorithm compiles propositional theory join tree relations partial models de ned cliques variables interact tree manner 
join tree allows query processing linear time 
tree clustering algorithm propositional theories described variant generates join tree clauses tree models 
tree clustering input cnf theory interaction graph ordering output join tree representation models tcm 
graph operations 
apply triangulation go yielding chordal graph gh io 

ct maximal cliques gh indexed highest nodes 

ci connect ci cj cj shares largest set variables ci 
resulting graph called join tree 
assign clause clique contains atoms yielding ci 
model generation 
clique ci compute mi set models 

apply arc consistency join tree models ci cj adjacent delete mi model agree model mj set common variables 

return fm tree structure 
model tree clustering tc 
rst steps tree clustering tc applied interaction graph theory transforming chordal graph graph chordal cycle length chord edge non sequential nodes cycle 
procedure called triangulation processes nodes order variables going node rst connecting edges earlier neighbors node 
result induced graph maximal cliques serve nodes resulting structure called join tree 
size largest clique triangulated induced graph equals 
steps algorithm complete join tree construction connecting various cliques tree structure 
tree cliques identi ed clause placed clique contains variables step yielding subtheories clique ci 
step models mi computed replace 
step arc consistency enforced tree models details see 
theory algorithm generates tree partial models denoted tcm 
shown join tree yields tractable representation 
satis ability model generation variety queries done linear polynomial time theorem 
theory tcm generated algorithm tc satis able mi tcm empty 
veri ed linear time resulting join tree 

deciding literal ci consistent done linear time columns relation mi de ned 
entailment clause determined ino log time bounds number models clique 
done temporary elimination submodels disagree relevant cliques reapplying arcconsistency 
tree clustering algorithm clique nal output join tree associated subtheory clauses set models desirable properties compiled representation maintained 
show compiled subtheories generated successive applications dr ordering dictated join tree structure 
resulting algorithm clause tree clustering ctc outputs clause join tree denoted tcc 
rst steps structuring join tree associating clique cnf subtheories step remain unchanged 
directional resolution applied resulting tree cliques twice leaves root vice versa 
dr modi ed bucket associated clique single variable 
clique processed full unordered resolution relative variables cliques 
generated clauses copied neighboring clique 

ct tree ordering cliques generated breadth rst traversal clique tree rooted 
clique rooted tree de nes parent set child cliques 
cliques processed reverse order ctc input cnf theory interaction graph ordering output clause join tree representation 
compute skeleton join tree steps 

place clause clique contains literals 
ct breadth rst search ordering clique tree starts root 
theories ct respectively 

res close resolution put copy resolvents de ned variables shared ci cj cj earlier clique cj 

res ci put copy resolvents de ned variables ci shares clique cj cj 

return tcc tg set clauses de ned clique tree structure 
algorithm clause tree clustering ctc 
processing clique ci subtheory possible resolvents variables ci added 
resolvents de ned variables shared ci parent cl copied placed cl second phase works similarly opposite direction root leaves 
case resolvents generated clique ci de ned variables shared child clique cj copied cj applying full resolution theories having jcj variables time space exponential jcj get theorem complexity ctc time space exp induced width ordered graph generating join tree structure 
example consider theory order directional resolution adds clauses 
join tree structure relative ordering obtained selecting maximal cliques ordered induced graph see 
get edc bcd abc 
step places clause clique clause clauses 
resulting set clauses clique note duplication resolvents avoided simple indexing scheme 
directional resolution abc tree clustering theory tree clusterings 
cde bcd processing tree clustering 
boldface clauses clique added processing 
clause generated backward phase 
root clique resolution generates clause added clique 
processing generates clause added 
processing generates clause 
signi cant property compiled sub theories clique ci denoted contains prime implicates de ned variables ci 
implies entailment queries involving variables contained single clique ci answered linear time scanning clauses clauses contained clique processed exp time 
prove claim rst show clause join tree contains directional extensions orderings consistent tree structure 
ability generate model backtrack free facilitated directional extensions guarantees existence clique restricted prime implicates 
provide formal account claims 
de nition prime implicate theory clause 
de nition cnf theory subset variables 
denote prime set prime implicates prime set prime implicates de ned variables show compiled clausal tree tcc contains directional extension variety orderings 
lemma theory tcc clause join tree clique exist ordering start internal ordering variables eo tcc 
lemma prove theorem theorem theory tcc clause join tree clique prime tcc 
consider theory 
focusing clique see prime implicates 
having prime implicates clique semantic syntactic value 
semantically means information related variables ci available inside compiled theory rest information irrelevant 
syntactic level know explicit representation information 
theorem conclude corollary theory join tree properties hold 
theory satis able tcc contain empty clause 

tcc entailment clause variables contained single clique decided linear time 
entailment arbitrary clause decided ino exp time space 

checking new clause consistent done linear time example shown compiled sub theory associated clique determine entails assess contained contained conclude entailed 
determine consistent wemust see entails negation literal 
clause inconsistent 
include literals entailed consistent 
dp input cnf theory 
output decision satis able 

unit propagate 
empty clause generated return false 
variables assigned return true 

unassigned variable 
return dp 
dp backtracking search tree ordering cnf theory cg davis putnam procedure 
backtracking search dp backtracking search processes variables order instantiating variable value consistent previous assignments 
value situation called dead algorithm backtracks previous variable selects alternative assignment 
consistent assignment algorithm backtracks 
algorithm explores search tree depth rst manner nds solution concludes solution exists 
example search tree shown 
tree traversed deciding satis ability propositional theory cg 
tree nodes correspond variables tree branches correspond di erent assignments 
dead nodes crossed 
theory obviously inconsistent 
various advanced backtracking algorithms solving csps improve basic scheme smart variable value ordering heuristics 
cient backtracking mechanisms constraint propagation arc consistency forward checking learning recording constraints available 
davis putnam procedure dp shown backtracking search algorithm deciding propositional satis ability combined unit propagation 
various branching heuristics augmenting basic version dp proposed 
worst case time complexity backtracking algorithms exponential frequency nodes search space empirical distribution number nodes explored algorithm bj dvo backjumping dynamic variable ordering instances inconsistent random binary csps having variables domain size constraint density probability constraint variables tightness fraction prohibited value pairs constraint 
number variables space complexity linear 
average time complexity dp depends distribution instances lower worst case bound 
usually average performance ected rare exceptionally hard instances 
exponential family empirical distributions lognormal weibull proposed studies summarize observations concise way 
atypical distribution number explored search tree nodes shown 
distribution shown inconsistent problems 
turns consistent inconsistent csps produce di erent types distributions details see 
example theory chain structure subtheories variables tree structure 
dp versus dr empirical evaluation section empirical comparison dp dr di erent types cnf theories including uniform random problems random chains trees benchmark problems second dimacs challenge algorithms implemented tested sun sparc stations 
machines having di erent performance sun sparc ultra specify machine set experiments 
reported runtime measured seconds 
algorithm dr implemented discussed section 
followed dp xed variable ordering dead ends occur see theorem 
algorithm dp implemented dynamic variable ordering heuristic tableau state art backtracking algorithm sat 
heuristic called literal clause heuristic suggests instantiating variable cause largest number unit propagations approximated number literal clauses variable appears 
augmented algorithm signi cantly outperforms dp heuristic 
random problem generators test algorithms problems di erent structures random problem generators 
uniform cnfs generator uses input number variables number clauses number literals clause clause generated randomly choosing variables determining sign literal positive negative probability majority experiments 
check clause uniqueness large identical clauses generated 
available ftp dimacs rutgers edu pub challenge sat benchmarks volume cnf 
second generator chains creates sequence independent uniform cnf theories called subtheories connects pair successive cliques cnf clause containing variables consecutive subtheories chain see 
generator parameters number cliques number variables clique number clauses clique cliques size variables subgraph tree 
tree generator generates tree cliques having nodes size intersection neighboring cliques see 
number cliques number clauses clique tree generator produces clique size clauses generates cliques selecting randomly existing clique variables adding new variables generating clauses new clique 
tree embedded tree induced width bounded note trees conventional trees 
results expected uniform random cnfs having large complexity dr grew exponentially problem density performance dp better 
small problems having variables demonstrate exponential behavior dr see 
larger problems dr ran memory 
proceed extensive experiments case exponential behavior dr uniform cnfs known 
behavior algorithms chain problems completely di erent 
dr far cient dp seen table summarizing results cnf chain problems contain subtheories having variables clauses additional cnf clauses connect subtheories chain min diversity ordering instance 
induced width problems small average directional resolution solved problems quite easily 
dp backtracking encountered rare extremely hard problems contributed average complexity 
table lists results selected hard instances table number dead ends exceeds 
similar results obtained chain problems di erent variable orderings 
example graphs experiments min width input orderings 
observe min width ordering may signi cantly improve performance shows results algorithms bdr dp backjumping discussed 
table dr versus dp cnf chains having subtheories variables clauses subtheory total variables clauses 
instances row 
columns show percentage satis able instances time deadends dp time number new clauses dr size largest clause induced width md min diversity ordering 
experiments performed sun workstation 
num dp dr sat time dead time number size cls ends new max clauses clause table dr dp hard chains number dead ends larger 
chain subtheories variables total variables 
experiments performed sun workstation 
num sat dp dr time dead time cls ends time dp vs dr uniform random sat variables clauses experiments point dp dr number clauses cnf chains subtheories variables experiments point bdr dp bound dr backjumping dp backtracking number clauses uniform random cnfs chain cnfs dp versus dr uniform random cnfs dp dr bdr dp backjumping cnf chains sun 
dp relative input ordering compare 
prevent backtracking encountering rare extremely hard instances 
table presents histograms demonstrating dp chains details 
histograms show cases frequency easy problems deadends decreased frequency hard problems deadends increased increasing number cliques increasing number clauses clique 
empirical studies required investigate possible phase transition phenomenon chains done uniform random cnfs 
experiments nearly cnf chain problems di cult dp unsatis able 
plausible explanation inconsistent chain theories mayhave unsatis able subtheory ordering 
subtheories satis able dp try re instantiate variables satis able subtheories encounters dead 
shows example chain satis able theories unsatis able theory close ordering 
min diversity min width orderings preclude situation 
enhanced backtracking schemes capable exploiting structure preventing useless re instantiations 
experiments backjumping con rm cpu time log scale cpu time log scale cnf chains subtheories variables experiments point dp backtracking dr clauses subtheory cnf chains subtheories variables experiments point dp backtracking dr clauses subtheory input ordering min width ordering dr dp cnf chains di erent orderings sun 
table histograms number deadends log scale dp chains having subtheories de ned variables clauses 
column presents results instances row de nes range entry frequency instances total yield range deadends 
experiments performed sun ultra 
deadends cpu time log scale sat sat sat sat sat inconsistent chain problem naive backtracking ine cient encountering inconsistent subproblem variable ordering 
table dp versus tableau variable uniform random cnfs min degree ordering 
instances row 
experiments ran sun sparc ultra 
cls tableau dp dp sat time time de variables variables substantially outperforms dp chain instances see 
behavior dp dr trees similar chains discussed context hybrid algorithms 
comparing di erent dp implementations may raise question highly optimized dp implementation cient representative backtracking sat algorithms 
answer question comparing dp executable code tableau 
results variable uniform random cnf problems table 
min degree initial ordering consulted dynamic ordering algorithms tableau dp tie breaking situations 
cases tableau times faster dp dp faster comparable tableau 
chains behavior pattern tableau similar dp 
table compares runtime histograms dp tableau chain problems showing table histograms dp tableau runtimes log scale chains having instances column 
row de nes runtime range entry frequency instances range 
experiments performed sun ultra 
time tableau runtime histogram dp runtime histogram algorithms encountering rare hard problems tableau usually encountered hard problems frequently dp 
problem instances hard dp easy tableau vice versa 
tableau cient implementation di erence change key distinctions backtracking resolution approaches 
experiments implementation dp combining search resolution complementary properties dp dr suggest combining hybrid scheme note algorithm dp includes limited amount resolution form unit propagation 
general parameterized schemes integrating bounded resolution search 
hybrid scheme bdr dp performs bounded resolution prior search scheme called dcdr uses dynamically search 
bounded directional resolution bdr input cnf theory qn bound output decision satis able 
bounded directional extension 

initialize generate partition clauses bucket contains clauses highest literal qi 

resolve qi qi 
empty return unsatis able contains propositions add bucket highest variable 
return 
algorithm bounded directional resolution bdr 
algorithm bdr dp resolution operation helps detecting inconsistent subproblems prevent dp unnecessary backtracking 
resolution costly 
way limiting complexity resolution bound size recorded resolvents 
yields incomplete algorithm bounded directional resolution bounds number variables resolvent 
algorithm coincides dr resolvents variables recorded 
bounds size directional extension complexity algorithm 
time space complexity bdr exp 
algorithm sound incomplete 
algorithm bdr followed dp named bdr dp clearly bdr dp coincides dp bdr dp coincides dr resolvent recorded 
empirical evaluation bdr dp tested bdr dp di erent values uniform cnfs chains trees dimacs benchmarks 
cases bdr dp achieved optimal performance having source code dp allowed control experiments bounding number deadends having executable code tableau 
note dp uses literal clauses dynamic variable ordering heuristic 
table dp versus bdr dp uniform random cnfs variables clauses positive literal probability 
induced width min width ordering varies 
row presents average values instances sun sparc 
num dp bdr dp bdr dp bdr dp time dead bdr dp dead new bdr dp dead new bdr dp dead new cls ends time time ends cls time time ends cls time time ends cls intermediate values performance uniform cnfs results bdr dp class uniform random cnfs table 
shows average time number deadends dp average bdr time dp time number deadends preprocessing average number new clauses added bdr 
alternative summary data comparing dp bdr dp time 
demonstrates increase number clauses corresponding reduction number deadends 
new clauses generated 
graphs dp bdr dp practically coincide 
incrementing results orders magnitude increase number generated clauses number deadends decreases shown 
results suggest bdr dp cost ective problem see 
slightly faster dp bdr dp bdr dp coincides dp problem set signi cantly faster bdr dp 
table shows bdr takes second run bdr takes seconds generates clauses 
observe dp runs slightly faster applied bdr 
interestingly time dp doubles fewer deadends encountered 
example table problem set clauses dp takes average seconds preprocessing bdr takes seconds 
explained signi cant increase number clauses need consulted dp increases dp performance worsen time complexity preprocessing grows exponentially table presents additional results problems having variables note average decrease number deadends monotonic problems time bdr dp time uniform random problems variables clauses instances point clauses dp bdr dp bdr dp bdr dp deadends bdr dp deadends uniform random problems variables clauses instances point clauses dp bdr dp bdr dp bdr dp new clauses added new clauses added bdr uniform random problems variables clauses instances point bdr input clauses time deadends new clauses bdr dp class uniform random cnf problems 
variables clauses 
induced width min width ordering varies 
data point corresponds instances 
note plots dp bdr dp coincide white circle plot bdr dp overlaps black circle plot dp 
table dp versus bdr dp uniform cnfs variables clauses positive literal probability 
row presents mean values experiments 
num dp bdr dp bdr dp time dead bdr dp dead new bdr dp dead new cls ends time time ends cls time time ends cls bdr bdr table dp versus bdr dp uniform random cnfs point variables clauses variables clauses variables clauses 
induced width computed min width ordering 
results rst rows summarize experiments row represents experiments 
vars cls dp bdr dp time dead bdr dp dead new ends time time ends cls observe ect bdr pronounced larger theories 
table compare results classes uniform cnf problems phase transition region 
improvement marginal variable problems seconds dp seconds bdr dp pronounced variable problems seconds variable problems seconds 
cases average speed 
tentative empirical optimal parameter bdr dp uniform random cnfs 
performance chains trees experiments chains showed bdr dp easily solved instances hard dp 
fact performance bdr dp chains comparable dr backjumping see 
experimenting trees varying number clauses clique discovered exceptionally hard problems dp 
results trees trees table 
experiments terminated dp exceeded dead ends seconds 
happened trees trees 
shows scatter diagram comparing dp bdr dp time data set additional experiments trees having cliques total instances 
case cnf chains observed majority exceptionally hard problems unsatis able 
xed small number cliques having clauses dp average deadends bdr dp yields deadends bdr dp yields deadends 
may occur dp uses dynamic variable ordering 
bdr dp time log scale trees experiments dp backtracking time dp bdr dp trees 
instances set parameters total instances instance point 
table bdr dp dp termination dead ends trees 
experiments row 
dp bdr dp number time dead bdr dp bdr number sat ends time time dead new ends clauses tree total vars cls tree total vars cls time seconds trees time bound bdr dp bdr bdr dp deadends trees deadends bound time deadends new clauses new clauses trees new clauses bdr dp instances trees md termination deadends 
average time number dead ends number new clauses plotted functions parameter note plot bdr dp practically coincides plot dp dp 
large hard instances dp appeared frequently 
behavior bdr dp function structured bounded theories demonstrated figures 
experiments min degree ordering yielded smaller average denoted md input ordering min width ordering min cardinality ordering see details 
shows results trees presents results trees trees trees 
point represents average instances 
observed relatively low trees preprocessing time increasing bdr coincides dr high trees preprocessing time grows quickly increasing 
dp time bdr usually decreases monotonically total time bdr dp optimal intermediate values observe trees bdr dp cient trees trees optimal parameters respectively 
trees values provide best performance 
bound bdr dp dp dr tableau dimacs benchmarks tested dp tableau dr bdr dp benchmark problems second dimacs challenge 
results table quite time seconds trees time bound bdr dp bdr bdr dp time seconds trees time trees time bound bdr dp bdr bdr dp time seconds bdr dp bdr dp bound trees md trees md trees md bdr dp classes tree problems trees md trees trees termination deadends 
instances problem class 
average time number dead ends number new clauses plotted functions parameter interesting benchmark problems relatively hard dp tableau low solved dr second dubois dubois 
hand problems having high induced width bf intractable dr expected 
algorithm bdr dp better pure dp dr example solving benchmark aim took seconds tableau seconds dp dr ran memory bdr dp took seconds reduced number dp deadends 
preprocessing bdr took seconds problem backtrack free 
note induced width problem relatively high 
interestingly dimacs problems ssa bf preprocessing bdr worsened performance dp 
similar phenomenon observed rare cases trees 
bdr dp intermediate values cost ective dp dr unstructured random uniform cnfs bdr dp comparable dp chains comparable dr intermediate trees bdr dp outperforms table tableau dp dr bdr dp second dimacs challenge benchmarks 
experiments performed sun sparc workstation 
problem tableau dp dead dr bdr dp bdr dp time time ends time time dead new time dead new ends cls ends cls aim dubois dubois ssa bf dr dp 
believe transition uniform problems sharp intermediate levels preprocessing may provide re ned trade algorithm dcdr ect conditioning interaction graph theory second method combining dp dr consider uses resolution dynamically search 
propose class hybrid algorithms select set conditioning variables called cutset instantiating variables results width theory tractable dr hybrids run dp cutset variables dr remaining ones combining virtues approaches 
dr generalization cycle cutset algorithm proposed transforms interaction graph theory tree 
exploit low structure produce output theory facilitates model generation space allowing average time dp 
description hybrid algorithms uses new notation introduced 
instantiation set variables denoted 
theory conditioned assignment called conditional theory relative toi denoted 
ect conditioning deletion variables interaction graph 
conditional interaction graph respect denoted obtained interaction graph deleting nodes incident edges 
conditional width conditional induced width theory relative toi denoted respectively width induced width interaction graph 
example shows interaction graph theory ordering having width induced width 
conditioning yields conditional theories ordered interaction graphs shown 
clearly wo theory wo theory 
note deleting incident edges interaction graph assignment may delete edges removes edge clause satis ed 
conditioning variables selected advance statically algorithm execution dynamically 
experiments focused dynamic version dynamic conditioning dr dcdr superior static 
algorithm dcdr guarantees induced width variables resolved bounded consistent partial assignment set variables algorithm performs resolution remaining variables having variables algorithm selects variable attempts assign value consistent 
idea dcdr demonstrated theory assume run dcdr 
variable initially connected variables 
result resolution done conditioning variable selected 
assume selected 
assignment adds unit clause causes unit resolution produces new clause 
assignment produces clause 
original clauses shown left partitioning buckets 
new clauses shown right corresponding search tree branches 
branch get conditional theory bucket bucket bucket bucket bucket elimination input dcdr conditioning trace dcdr theory 
degrees variables corresponding conditional interaction graph proceed resolution 
select perform resolution bucket record resolvent 
resolution creates clause 
point algorithm terminates returning assignment conditional directional extension 
alternative branch ofa results conditional theory variable connected variables resolution possible 
conditioning yields conditional theory conditional theory 
cases algorithm terminates returning assignment tob corresponding conditional directional extension 
algorithm dcdr takes input propositional theory parameter bounding size resolvents 
unit propagation performed rst lines 
inconsistency discovered dcdr proceeds primary activity choosing resolution conditioning 
variable connected variables current interaction graph conditioned current assignment dcdr resolves steps 
selects unassigned variable step adds cutset step continues recursively conditional theory unassigned variable selected dynamic variable ordering heuristic dp 
theory prove inconsistent algorithm switches conditional theory positive negative assignments inconsistent algorithm backtracks previously assigned variable 
returns previous level recursion corresponding state discarding resolvents added previous assignment 
algorithm nd consistent partial assignment decides theory inconsistent returns empty cutset empty directional extension 
returns assignment cutset conditional directional extension eo variable ordering dynamically constructed algorithm 
clearly conditional induced width interaction graph respect assignment bounded theorem dcdr soundness completeness algorithm dcdr sound complete satis ability 
theory satis able model consistent output assignment generated backtrack free ino time ordering computed dynamically dcdr 
theorem dcdr complexity time complexity algorithm dcdr jcj largest cutset conditioned algorithm log 
space complexity 
parameter control trade search resolution 
wo ordering dcdr algorithm coincides dr having time space complexity exponential 
easy show ordering generated dcdr case conditioning yields min degree ordering 
min degree ordering guaranteed dcdr coincides dr wo algorithm coincides dp 
intermediate values allow trading space time 
increases algorithm requires space time see 
guaranteed worst case time improvement dr shown size smallest cycle cutset set nodes breaks cycles interaction graph leaving tree forest smallest induced dcdr input cnf theory variables bound output decision satis able 
assignment conditioning variables conditional directional extension eo 

unit propagate false return false 
unit 
variables process return true 
degree current graph 
resolve 
empty clause generated 
add resolvents theory 
return false 
fqg 
select variable fqg 
fqg 
return dcdr dcdr 
algorithm dcdr 
width obey relation jcj 
corresponding cutset cb left side inequality exponent determines complexity dcdr theorem 
practice backtracking search rarely demonstrates worst case performance average complexity dcdr superior worst case bound con rmed experiments 
algorithm dcdr uses literal clause ordering heuristic selecting conditioning variables dp 
random tie breaking selecting resolution variables 
empirical evaluation dcdr performance dcdr function tested problem instances satis able region phase transition region 
results di erent di erent problem structures summarized figures 
presents results uniform cnfs having variables clauses 
figures focus trees trees respectively 
plotted average time time time log scale time dcdr uniform cnfs variables clauses experiments point bound bound dcdr time dcdr trees cliques clauses clique experiments point dcdr time dcdr trees cliques clauses cliques experiment point dcdr time bound dead ends dead ends dead ends dcdr uniform cnfs variables clauses experiments point bound dead ends uniform cnfs dcdr trees cliques clauses clique experiments point bound trees dead ends dcdr trees cliques clauses clique experiment point bound trees dead ends clauses clauses dcdr uniform cnfs variables clauses experiments point clauses added theory total new clauses bound dcdr trees cliques clauses clique experiments point bound clauses added theory total new clauses dcdr trees cliques clauses clique experiment point clauses added theory total new clauses bound dcdr di erent classes cnf problems 
average time number dead ends number new clauses plotted functions parameter clauses number dead ends number new clauses generated functions bound plot total number generated clauses number clauses added output theory excluding tautologies subsumed clauses 
expected performance dcdr depends induced width theories 
observed di erent patterns problems having large uniform cnfs phase transition region see time complexity dcdr similar dp small 
increases cpu time grows exponentially 
apparently decline number dead ends slow relative exponential growth total number generated clauses 
number new clauses added theory grows slowly 
consequently nal conditional directional extensions manageable sizes 
obtained similar results experimenting uniform theories having variables clauses 
dr equivalent dcdr equal greater theories having small induced width dcdr coincides dr small values demonstrates behavior trees cliques clauses clique induced width 
time total number clauses generated number new clauses added theory change 
small values ciency dcdr worse dcdr equivalent due overhead incurred extra clause generation accurate explanation required 
trees having larger size cliques intermediate values yielded better performance extremes 
dcdr ine cient structured problems large induced width pure dr costly time space wise 
trees optimal values appear 
summarizes results dcdr dcdr dcdr classes problems 
intermediate bound coste ective extremes 
describes average number resolved variables indicates algorithm potential knowledge compilation 
variables resolved resulting conditional directional extension encodes larger portion models sharing assignment cutset variables 
time dcdr different problem structures dcdr dcdr dcdr uniform cnfs trees trees problem types relative performance dcdr di erent types problems 
related directional resolution belongs family elimination algorithms rst analyzed optimization tasks dynamic programming constraint satisfaction belief networks 
fact dr viewed adaptation constraint satisfaction algorithm adaptive consistency propositional satis ability project join operation relational constraints replaced resolution clauses 
analogy bounded resolution related bounded consistency enforcing algorithms arc path consistency bounded directional resolution bdr parallels directional consistency 
resolved variables dcdr uniform cnfs variables clauses experiments point resolved variables bound resolved variables dcdr trees cliques clauses clique experiments point resolved variables bound resolved variables dcdr trees cliques clauses clique experiment point resolved variables bound dcdr number resolved variables di erent problems 
contributions transferring constraint satisfaction techniques propositional framework 
success constraint processing attributed techniques combining search limited forms constraint propagation forward checking mac constraint logic programming motivated hybrid algorithms 
sat community popular form combining constraint propagation search unit propagation dp 
extends idea 
hybrid algorithm bdr dp initially proposed corresponds applying directional consistency prior backtracking search constraint processing 
approach empirically evaluated constraint problems 
experiments restricted small relatively easy problems limited amount preprocessing cost ective 
experiments bdr dp suggest results preliminary idea preprocessing search viable investigated 
second hybrid algorithm dcdr proposed rst generalizes approach constraint satisfaction static variable ordering 
idea alternating search bounded resolution suggested evaluated independently van gelder generalization unit resolution known limited resolution proposed 
operation requires operands resolvent literals 
hybrid algorithm proposed computes closure applies limited resolution iteratively eliminates subsumed clauses branching steps dp backtracking 
algorithm augmented branching heuristics tested combination called cl algorithm demonstrated superiority especially larger problems 
algorithm dcdr computes subset closure branching steps study impact ectiveness hybrid algorithms di erent problem structures focus xed relationship clausal tree clustering directional resolutions extends known relationship variable elimination tree clustering compilation scheme constraint satisfaction extended probabilistic frameworks 
dcdr performs resolution variables connected variables size resolvents bounded resolve variables having degree higher conditional interaction graph resolutions produce clauses size larger summary compares popular approaches solving propositional satis ability backtracking search resolution proposes parameterized hybrid algorithms 
analyze complexity original resolution davis putnam algorithm called directional resolution dr function induced width theory interaction graph 
parameter called diversity provides additional re nement tractable classes 
empirical studies con rm previous results showing uniform random problems dr ine cient 
structured problems tree embeddings having bounded induced width directional resolution outperforms popular backtracking davis putnam logemann loveland procedure dp 
emphasize knowledge compilation aspects directional resolution procedure tree clustering 
show generates prime implicates restricted cliques clique tree 
parameterized hybrid schemes bdr dp dcdr allow exible combination backtracking search directional resolution 
schemes parameter bounds size resolvents recorded 
rst scheme bdr dp uses bounded directional resolution bdr preprocessing step recording new clauses size 
ect bound studied empirically uniform structured problems observing bdr dp frequently achieves optimal performance intermediate levels outperforming dr dp 
believe transition sharp intermediate levels preprocessing provide better trade encouraging results obtained bdr dp dimacs benchmark hybrid algorithm easily solves problems hard dr dp 
second hybrid scheme uses bounded resolution search 
bound algorithm dcdr instantiates dynamically selected subset conditioning variables induced width resulting conditional theory size resolvents recorded exceed dcdr coincides dp resulting ordering coincides directional resolution 
intermediate dcdr shown outperform extremes intermediate problem classes 
schemes selecting bound resolvent size allows exible scheme adapted problem structure computational resources 
current rule thumb dcdr small large relying search large small exploiting resolution intermediate bound intermediate additional experiments necessary demonstrate spectrum optimal hybrids relative problem structures 
arnborg corneil 
complexity nding embedding tree 
journal siam algebraic discrete methods 
bayardo miranker 
complexity analysis space bound learning algorithms constraint satisfaction problem 
proceedings thirteenth national conference onarti cial intelligence aaai pages 
bayardo schrag 
csp look back techniques solve real world sat instances 
proceedings aaai pages 
becker geiger 
su ciently fast algorithm nding close optimal trees 
uncertainty ai uai pages 
ben eliyahu dechter 
default reasoning classical logic 
arti cial intelligence 

dynamic programming 
academic press new york 
cheeseman kanefsky taylor 
really hard problems 
proceedings international joint conference onarti cial intelligence pages 
cook 
complexity theorem proving procedures 
proceedings rd annual acm symposium theory computing pages 
crawford auton 
experimental results crossover point satis ability problems 
proceedings eleventh national conference onarti cial intelligence pages 
crawford baker 
experimental results application satis ability algorithms scheduling problems 
proceedings aaai seattle wa pages 
davis logemann loveland 
machine program theorem proving 
communications acm 
davis putnam 
computing procedure quanti cation theory 
journal association computing machinery 
dechter 
enhancement schemes constraint processing backjumping learning cutset decomposition 
arti cial intelligence 
dechter :10.1.1.40.1018
constraint networks 
encyclopedia arti cial intelligence pages 
john wiley sons nd edition 
dechter 
bucket elimination unifying framework probabilistic inference algorithms 
uncertainty arti cial intelligence uai pages 
dechter 
topological parameters time space tradeo uncertainty arti cial intelligence uai pages 
dechter itai 
finding solutions nd 
uci technical report 
proceedings workshop tractable reasoning aaai 
dechter meiri 
experimental evaluation preprocessing techniques constraint satisfaction problems 
international joint conference onarti cial intelligence pages 
dechter meiri 
experimental evaluation preprocessing algorithms constraint satisfaction problems 
arti cial intelligence 
dechter pearl 
network heuristics constraint satisfaction problems 
arti cial intelligence 
dechter pearl 
tree clustering constraint networks 
arti cial intelligence pages 
dechter pearl 
directed constraint networks relational framework causal models 
proceedings twelfth international joint conference arti cial intelligence ijcai sidney australia pages 
dechter rish 
directional resolution davis putnam procedure revisited 
proceedings kr 
dechter van beek 
local global relational consistency 
theoretical computer science pages 
del val 
new method consequence nding compilation restricted languages 
proceedings aaai 
itai shamir 
complexity timetable multi commodity ow 
siam journal computing 
el dechter 
diagnosing tree decomposable circuits 
international joint conference cial intelligence ijcai pages montreal canada august 
el dechter 
evaluation structural parameters probabilistic reasoning results benchmark circuits 
uai pages portland oregon august 
franco paul 
probabilistic analysis davis putnam procedure solving satis ability problem 
discrete appl 
math 
freuder 
synthesizing constraint expressions 
communication acm 
frost dechter 
dead driven learning 
aaai proceedings twelfth national conference onarti cial intelligence pages 
frost rish vila 
summarizing csp hardness continuous probability distributions 
proc 
national conference onarti cial intelligence aaai pages 
frost 
algorithms heuristics constraint satisfaction problems 
technical report phd thesis information computer science university california irvine california 
daniel frost rina dechter 
search best constraint satisfaction search 
proceedings twelfth national conference onarti cial intelligence 
galil 
complexity regular resolution davis putnam procedure 
theoretical computer science 
gaschnig 
general backtrack algorithm eliminates redundant tests 
proceedings international joint conference onarti cial intelligence page 
gaschnig 
performance measurement analysis certain search algorithms 
technical report cmu cs carnegie mellon university 
van gelder tsuji 
satis ability testing reasoning guessing 
david johnson michael trick editors cliques coloring satis ability 

davis putnam resolution versus unrestricted resolution 
annals mathematics arti cial intelligence 
goldberg purdom brown 
average time analysis simpli ed davis putnam procedures 
information processing letters 
haralick elliott 
increasing tree search ciency constraint satisfaction problems 
arti cial intelligence 
hooker vinay 
branching rules satis ability 
international symposium arti cial intelligence mathematics fort lauderdale florida 
ja ar lassez 
constraint logic programming survey 
journal logic programming 
jeroslow wang 
solving propositional satis ability problems 
annals mathematics arti cial intelligence 
dechter 
gsat local consistency 
proceedings ijcai pages 
kautz selman 
pushing envelope planning propositional logic stochastic search 
proceedings aaai 
lauritzen spiegelhalter 
local computation probabilities graphical structures application expert systems 
journal royal statistical society series 
mackworth 
consistency networks relations 
arti cial intelligence 
david mitchell bart selman hector levesque 
hard easy distributions sat problems 
proceedings tenth national conference onarti cial intelligence pages 
prosser 
hybrid algorithms constraint satisfaction problems 
computational intelligence 
patrick prosser 
bm bj 
proceedings ninth conference arti cial intelligence applications pages 
rish 
cient reasoning graphical models 
phd thesis 
rish dechter 
guess think 
hybrid algorithms sat extended 
proceedings international conference principles practice constraint programming cp 
rish frost 
statistical analysis backtracking inconsistent csps 
proceedings international conference principles practice constraint programming cp 
robertson seymour 
graph minor 
xiii 
disjoint paths problem 
combinatorial theory series 
sabin freuder 
contradicting conventional wisdom constraint satisfaction 
ecai pages amsterdam 
seidel 
new method solving constraint satisfaction problems 
proceedings seventh international joint conference onarti cial intelligence ijcai vancouver canada pages 
selman kautz cohen 
noise strategies improving local search 
proceedings aaai pages 
bart selman hector levesque david mitchell 
new method solving hard satis ability problems 
proceedings tenth national conference onarti cial intelligence pages 
barbara smith dyer 
locating phase transition binary constraint satisfaction problems 
arti cial intelligence 
tarjan yannakakis 
simple linear time algorithms test graphs test acyclicity selectively reduce acyclic hypergraphs 
siam journal computation 
appendix proofs theorem model generation eo satis able theory procedure nd model generates model backtrack free time 
proof suppose model generation process backtrack free 
suppose exists truth assignment qi rst variables ordering qn satis es clauses buckets qi extended qi falsifying clauses 
clauses bucket qi satis ed simultaneously assignment qi 
clearly qi appears negatively clause positively 
consequently processed dr resolved resulting clause reside clause allow partial model qi contradicts assumption 
model generation backtrack free takes time consulting buckets 
theorem complexity cnf theory ordering time complexity algorithm dr number variables 
proof buckets containing clauses output directional extension 
number resolution operations bucket exceed number possible pairs clauses quadratic size bucket 
yields complexity 
lemma cnf theory ordering eo subgraph io 
proof proof induction variables ordering qn 
induction hypothesis edges qi eo appear io 
claim clearly true qn 
assume claim true qn qi show assumption implies qi qj edge eo belongs io 
cases qi qj initially appeared clause connected io clause containing variables added directional resolution 
second case clause obtained processing bucket qt 
qi qj appeared bucket qt connected qt eo induction hypothesis connected qt io 
qi qj parents qt connected io 
lemma theory ordering qn qi parents induced graph bucket variable qi eo contains clauses 
proof clause bucket qi possibilities parent appears appears appears qi appears positively negatively di erent clauses bucket 
theorem complexity dr theory ordering variables time complexity algorithm dr size eo clauses induced width interaction graph proof result follows lemmas 
interaction graph eo isa subgraph io lemma size theories having io interaction graph bounded lemma 
time complexity algorithm dr bounded size largest bucket 
lemma 
time complexity iso 
theorem theory de ned variables qn symbol qi appears negatively positively appears exactly clauses div tractable 
proof proof induction number variables 
satis es select variable diversity put ordering 
zero diversity case clause added 
diversity case clause added processing bucket 
assume clause added bucket qj 
single sign symbol remain 
diversity bucket zero 
clauses containing qj bucket qn current bucket qj processing qn contain clauses 
diversity 
assume processing qn qi induced diversity show processing qi leave diversity 
theorem algorithm min diversity generates minimal diversity ordering theory 
time complexity number variables number clauses input theory 
proof ordering generated algorithm qi diversity equals diversity ordering 
qi pushed diversity increase 
pushed replaced avariable diversity equal higher diversity 
computing diversity takes time algorithm checks variables order select smallest diversity ofn steps 
yields total complexity 
lemma theory tcc clause join tree clique exist ordering start ordering variables eo tcc 
proof join tree structure created order processing cliques leaves root dependent identity root clique 
processing applied direction resulting join tree invariant particular rooted tree selected 
consequently assume clique root processed backwards phase dr tc 
oc tree ordering cliques starts possible ordering variables consistent oc 
variables cliques ordered oc appear easy see directional resolution applied reversed order generates subset resolvents created backwards phase dr tc oc 
eo 
theorem theory clause join tree 
clique prime tcc 
proof consider arbitrary clique prime tcc 
want 
exists prime implicate de ned subset derived dr tc 
assume root join tree computed dr tc 
ordering consistent rooted tree starts variables lemma follows directional extension eo contained tcc model ordering generated backtrack free manner consulting eo theorem 
prevent model generation assigning available subsuming clauses exist 
assignment leads deadend contradicting backtrack free property directional extension 
corollary theory ordering properties hold 
theory satis able tcc contain empty clause 

tcc entailment clause variables contained single clique decided linear time 

entailment clause decided ino exp time maximal clique size 

checking new clause consistent done time linear proof 
empty clause encountered theory satis able vice versa 

entailment clause variables contained clique ci decided scanning compiled clause subsuming exists entailed 

entailment arbitrary clause checked placing negation literal largest index clique contains corresponding variable repeating rst pass dr tc join tree 
clause entailed empty clause generated may take exp time 

consistency clause decided entailment negated literals 
consistent theory entails negated literals entailment negated literal decided linear time 
theorem dcdr soundness completeness algorithm dcdr sound complete satis ability 
theory satis able model consistent output assignment generated backtrack free time ordering computed dynamically dcdr 
proof assignment dcdr equivalent applying dr theory ordering theorem follows model backtrack free manner time 
theorem dcdr complexity time complexity algorithm dcdr jcj largest cutset instantiated algorithm log 
space complexity 
proof cutset assignment time space complexity resolution steps dcdr bounded see theorem 
worst case backtracking involves enumerating possible instantiations cutset variables jcj time jcj space total time jcj jcj largest cutset instantiated algorithm log 
total space complexity iso jcj 

