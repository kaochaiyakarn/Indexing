program synthesis formal requirements specifications apts elizabeth leonard leonard itd nrl navy mil heitmeyer heitmeyer itd nrl navy mil naval research laboratory code washington dc usa 
formal specifications software systems extremely useful rigorously analyzed verified validated giving high confidence specification captures desired behavior 
transfer confidence actual source code implementation formal link needed specification implementation 
generating implementation directly specification provides link 
program transformation system paige apts useful developing source code generator 
describes case study apts produce code generators construct source code requirements specification scr software cost reduction tabular notation 
study different code generation strategies explored 
strategy uses rewrite rules transform parse tree scr specification parse tree corresponding code 
second strategy associates relation node specification parse tree 
member relation acts attribute holding code corresponding tree associated node root tree entire program member relation 
describes code generators supported apts synthesize code example scr requirements specifications learned apts implementations 
keywords code generation code synthesis apts scr requirements specifications formal specifications program transformation 
developing complex software operational specification system required behavior extremely useful 
specification formally verified show critical properties satisfied validated simulation show intended system behavior captured 
additionally specifications contain detail programs errors easier find specifications programs specifications easier understand programming language code 
develop confidence specification correct 
unfortunately high assurance correctness specification mean implementation system correct implementation usually separately developed formal link specification 
confidence correctness actual code achieved testing confidence research funded office naval research 
fl kluwer academic publishers 
printed netherlands 
tex leonard heitmeyer tests 
way transfer high confidence specification implementation automatically generate implementation code specification eliminating errors introduced hand coding 
program transformation system cai paige apts extremely useful developing automatic code generator 
apts implemented setl improved version paige earlier system 
apts includes syntax analyzer relational database transformation engine 
syntax analyzer uses grammar parse specification 
relational database accumulates information specification needed code generation 
code generated relational database transformation engine 
apts includes optimization techniques finite differencing technique optimizing code replacing frequently repeated calculations expensive incremental updates 
cai paige apts implement translators setl sq describes case study apts generate code requirements specifications scr software cost reduction tabular notation 
apts code generation strategies implemented 
strategy relational database relational database transformation engine 
scr formal method specifying required behavior software systems 
scr toolset provides user friendly interface writing requirements specifications tabular format number analysis tools including consistency checker simulator model checker theorem prover invariant generator :10.1.1.17.6363
toolset specification displayed collection tables 
context free grammar underlying communication medium different tools 
applying scr tools user develop high confidence specification correct statement required system behavior 
scr method successfully organizations industry government bell laboratories lockheed naval research laboratory ontario hydro rockwell aviation develop analyze specifications practical systems including flight control systems weapons systems space systems cryptographic devices 
scr tools lockheed martin test case generator detect critical error described cause failure software controlling landing procedures mars polar lander 
tex program synthesis apts step developing high assurance systems scr synthesize generate code scr specifications 
describes initial step goal uses apts explore possible strategies code generation scr requirements specifications 
strategy uses rewrite rules transform code source language target language code 
source language experiments scr specification language target language transformations modify parse tree requirements specification replacing node containing scr code new node containing corresponding code 
second strategy treats code generated synthesized attribute parse tree scr specification 
relation developed associates target language code node parse tree source language program 
relational model code associated node formed combining code node children additional code specific node result stored relation 
strategies auxiliary information example variable dependencies stored relations 
frequently node parse tree key relation 
cases relations analogous attributes attribute grammar 
code synthesizers implemented components apts described 
apts relational database store attribute information advantages traditional attribute grammars 
apts information passed directly node node pattern matching relational database attribute grammar information flow path tree 
attribute grammar augmented auxiliary data structures hold inherited attributes lookup relational database apts integral part system holding attribute information 
apts allows relations defined domains nodes parse tree 
example tree domain allows attribute information assigned nodes representing term 
tree relation assign attribute value occurrences variable time 
contrast traditional attribute grammar information passed tree 
study apts flexible framework allowed experiment different code generation strategies 
approaches required information scr specification able reuse large portion generator implementation second 
similar experiments conducted systems refine tex leonard heitmeyer synthesizer generator rely attribute grammars suffer restrictions information flow absence built auxiliary data structures described 
additional advantage apts synthesizer generator program transformations apts automatic interactive synthesizer generator may conditioned information stored relations 
primary advantage apts systems built optimization capabilities 
apts finite differencing capabilities current implementations plan apply optimizations specifications augmenting apts code generators apts finite differencing engine 
organized follows 
section reviews apts scr describes code generated scr specifications 
section describes detail strategies generating code described strategy rewrite rules second accumulating relation approach 
section describes results applying code generators scr requirements specification cryptographic device 
compares strategies discusses learned implementing apts 
section discusses related 
section presents describes plans 

background 
apts grammar apts syntax analyzer builds parse trees input files 
node parse tree forms root subtree corresponding scr syntax portion specification 
grammar specify scr apts similar grammar described appendix places form grammar apts modified allow convenient transformational processing 
example variable declarations grammar defined grammar rule var decls id id type initially init val 
syntax allowed apts implementations pair grammar rules 
type initially id id tex program synthesis apts change apts relational database rewrite rules need refer identifier list individually 
cases alternate form grammar easier 
relational database built set inference rules 
rules usually consist parts pattern match portion parse tree set conditions logical combinations relations new member relation added database result portion stating new member add relation database 
pattern matching variables names apts dot correlate portions pattern matching condition relations appearing rule condition result portions correlate information contained different relations rule 
example rule states expression composed subexpressions separated parse tree subexpressions members relation matched expression denoted loc added relation match expr 
loc relations predicates arguments taken possible domains 
frequently nodes parse tree serve keys relations 
relations may viewed attributes parse tree 
restrictions relations condition inference rule relation synthesized inherited attributes defined apts terms relations 
relation implementation need parse tree attribute 
example scr specifications value variable may depend current value variable 
execution corresponding code values variables updated order respects dependencies 
dependency information necessary code generation 
implementations dependency relation variables implemented relation defined pairs strings variable names 
relations apts grouped transcripts 
execute transcript inference engine partially instantiates applicable rules transcript nondeterministically tries complete rules instantiated 
apts allows user defined setl routines add relations database 
user specifies interface apts setl routine stating relations routine receives input relations produce execution 
scr code generators setl routine calculate order tex leonard heitmeyer variables updated information dependency relation 
addition relational database code generator rewrite rules uses apts transformation engine 
uses set rewrite rules transform parse tree replacing scr language constructs corresponding code 
rewrite rules match pattern tree conditions rule met tree transformed replacement tree 
example rule equal states expression consisting subexpressions separated parse tree piece tree rewritten style replaced 
rewrite rules read matching piece parse tree conditions met matched part parse tree replaced tree inside rewrite 
equal match expr true 
rewrite expr apts rewrite rules collected groups called closures 
closure applied parse tree transformation engine works bottom tree nondeterministically applying rules closure tree rules applied 
implementation apply closures certain order guarantee certain rules applied 

scr specifications originally formulated document requirements flight program navy aircraft scr requirements method designed detect correct errors requirements phase software development :10.1.1.17.6363
scr required behavior software system defined terms monitored controlled variables represent quantities system environment system monitors controls 
set assumptions describes constraints imposed monitored controlled quantities physical laws system environment relation monitored controlled variables describes system required change values controlled quantities response changes values monitored quantities 
set assertions describes properties security safety properties specification expected satisfy 
specify required behavior software system practical efficient manner requirements document introduced kinds predicates conditions events kinds auxiliary tex program synthesis apts variables mode classes terms 
conditions events defined terms system state system state function maps state variable monitored controlled auxiliary variable type correct value 
condition predicate defined single system state event predicate defined system states denotes change values state variables states 
event occurs evaluates true pair consecutive states 
monitored event occurs value monitored variable changes 
conditioned event form occurs event occurs condition true specified condition true 
mode class may viewed state machine states called modes transitions triggered events 
term state variable defined terms monitored variables mode classes terms 
mode classes terms capture history changes occurred values monitored variables help specification concise 
scr specifications include kinds tables condition tables event tables 
defines value dependent variable controlled auxiliary variable means mathematical function 
usually condition table defines variable function mode condition event table defines variable function mode event 
purpose scr requirements model provide precise semantics notation scr requirements specifications :10.1.1.17.6363
model defines conditioned event conditions unprimed denotes old state primed denotes new state 
model defines functions derived scr tables 
scr model software system sigma represented state machine sigma set states initial state set set monitored events transform describing allowed state transitions 
compute new state transform composes functions derived condition event tables 
defined circular dependencies allowed definitions new state variable values 
achieve model requires new state dependencies dependencies new values state variables partial order state variables 
scr specification represented collection tables underlying communication medium scr tools context free grammar 
appendix contains grammar tex leonard heitmeyer scr 
grammar focuses basic syntax constructs omitting precedence rules needed unambiguous parsing 
grammar similar grammars apts implementations parse scr specifications 
grammars contain modifications including precedence rules necessary unambiguous parsing 
syntax language best illustrated example 
specification simplified version control system safety injection sis nuclear power plant 
line numbers part actual specification 
included ease 
sis system monitors water pressure pressure low system injects reactor core 
monitored variables specification lines 
represents actual value water pressure 
monitored variables switches switch overrides safety injection switch resets system blockage 
assumption specification water pressure change units time lines 
mode class possible values toolow permitted high associates pressure appropriate range lines time system modes 
term variable lines true safety injection blocked false 
specification contains controlled variable injection represents switch indicating safety injection lines 
value dependent variable defined table function 
event tables define value mode class lines term variable lines 
condition table defines value controlled variable injection lines 
tabular format function definitions lines appendix spec type definitions enum enum toolow permitted high integer constant definitions low integer convention names monitored variables controlled variables terms mode classes mc 
names user defined types names types associated mode classes type 
tex program synthesis apts permit integer monitored variables initially initially controlled variables initially term variables boolean initially false mode classes initially toolow assumptions assertions function definitions var case toolow ev low 
permitted permitted ev permit 
high low 
toolow high ev permit 
permitted esac var ev high 
true high high high 
false var case toolow tex leonard heitmeyer 

fi permitted high false 
true 
fi esac 
code generated scr specifications scr specification contains sections 
code generated section 
additionally code needed drive reactive program 
practice code replaced device driver software system 
section describes code generated scr specification 
format code generated part grammar file apts 
synthesizers produce code closely related scr specification 
correspondence specification code easy observe 
pieces code generated specification 
generated code file file pointers infile outfile associated input output files drive reactive program 
included input output routines boolean values represented internally integer constants false true 
scr specification corresponding code contains header file 
header file exactly specification generated apts 
file contains definitions formats reading writing strings integers 
example string output format macro defined define 
defining format routines header file generated apts necessary apts treats special character appear relations rewrite rules 
file contains definitions generated code 
example boolean integer defined additional names type int false true defined corresponding code values operators 
definitions strictly necessary included code resemble scr specification 
tex program synthesis apts type definitions 
scr support enumerated types 
scr allows overloading value names enumerated types 
handle soundly encoding simply prepend type name enumerated value 
example value enumerated type scr specification transformed type definition 
type definitions range declarations enum typedef enum enumerated type requires special input output routines convert value names specification corresponding value names code vice versa 
user defined range types scr counterpart generated code name range type alias integer check function created correspond range type 
time variable range type assigned value corresponding check function called ensure value specified range 
sis example contains range type range 
code corresponding range type 
define int void char name int value value value printf value range printf name constant definitions 
generated code scr constant definition straightforward rearrangement scr definition 
code generated constant definitions sis example 
constant definitions const integer low const integer permit variable declarations 
scr specification represents value variable old state represents value new state 
refer old new values variable generated code represents variable scr specification variables prime initial values defined constants 
name constants scr specifications initial value dependent variable derived initial values variables variable depends 
tex leonard heitmeyer constructed prepending init val name variable declaration 
example initial value named init val 
code corresponding declaration monitored variables 
variable declarations may transformed code similar way 
monitored variables const const assumptions assertions 
scr assumptions assertions predicates describing relationships variables 
logical formulas may refer old new state values variables full range logical operators 
event expressions may appear predicates expanded definition 
assumption assertion specification transformed evaluation function returns true predicate true false 
additionally functions check assumptions check assertions call functions produce error message predicate false generated assumptions assertions scr specification 
violation assumption indicates input obey assumed environmental constraints 
assertion violated specification satisfy property expected satisfy 
sis example evaluation function generated assumption function check assumptions calls evaluation function 
assertions sis function check assertions generated 
assumptions boolean evala return void evala false printf violated assertions tex program synthesis apts function definitions 
stated section dependent variable scr specification associated function 
function defined condition event table describing variable value updated monitored variable changes 
scr table function code contains corresponding update function successful branches assign newly calculated value primed version variable 
branch scr case statement condition table statement conditioned value primed version mode class variable 
scr statement transformed statement 
update function corresponding condition table injection 
note code generated false branch line table injection tables transformed code similar way 
void fprintf outfile fprintf outfile true fprintf outfile execution code 
addition generating code specification generate code executes specified state machine 
entry false table defining injection see table iii appendix artifact tabular format 
means injection equal mode high permitted correspond dead code 
tex leonard heitmeyer generated code simulates input output text files 
input file lists monitored events specified name monitored variable value assigned variable 
execution model similar execution model scr systems translation scr promela language spin model checker bharadwaj heitmeyer described pseudocode follows 
open files 
state initialize new state variables check assumptions assertions infile contains monitored event 
state state copy new state variables old state variables update new state variable corresponding monitored event update new state dependent variables dependency order check assumptions assertions close files 
separate functions generated performing initialization copying variables updating dependent variables 
note dependent variables updated order consistent partial order describing new state dependencies discussed section 
previously generated check assumptions check assertions functions called main routine 
scr specifications generate similar main routine differences names update functions dependent variables updating monitored variables response monitored events 

generating code scr specifications section describes implementation strategies code generation 
strategies relations generation code 
section describes relations 
sections describe strategies rewrite rules second accumulating relations 
tex program synthesis apts 
relations common strategies generate code scr specification code generator extensive apts relational database 
relations defined compute store information needed generate code 
implementations relations rules conditioned relations holding node 
relations appear negated conditions rules need fully calculated rules contain negations applied 
accomplish relations organized groups called transcripts calculated pass 
transcripts executed order respects dependencies relations group relations group 
code generation strategies require similar information stored variable dependencies information types expressions pieces code need calculated stored nodes code generated 
strategies need information variable dependencies 
order dependent variables updated depends new state dependencies 
dependency information calculated scr toolset converted apts relation depend 
sis example rules depend follows true 
depend true 
depend true 
depend true 
depend true 
depend true 
depend rules read depends depends 
relation passed setl routine constructs topological sort variables respect dependency constraints 
results setl routine stored relation holds ordering variables 
relations check input specification valid scr specification 
relations necessary parsing grammar expressions events predicates condensed category 
relations mark nodes containing separate types expression 
example member relation high 
additional relation conversion currently done hand easy automate 
tex leonard heitmeyer marks nodes containing primes 
relation includes 
information relations checks done determine expressions including primes events predicates allowed scr language 
relations store information needed generate code 
example variable generated code corresponding primed variable 
relational database relation associated variable specification holds name primed version variable 
match true 
concat prime str match 
concat prime str apts relational database rules match specific construct parse tree case list variables part declaration 
recall apts pattern matching variables names dot 
rule list form identifier followed comma list identifiers convert node string prepend string prime associate resulting string tree 
relation trees strings meaning string associated instance identifier tree just instance node matched rule 
elements list assigned prime names repeated applications rules 
rule handles multiple element lists single element lists 
second rule match condition states 
match condition match number elements 
second rule wish match single element 
condition rightmost child variable ensures second rule triggered single element list 
list multiple elements right child variable 
actual identifier child node associated new string 
note matching complex patterns rule apts able associate pattern matching variables children matched node leftmost child pattern consists just single pattern matching variable second rule pattern matching variable associated matched node children case tex program synthesis apts child 
necessary refer child second rule 
enumerated type variables relations hold names relevant input output routines described section 
relation marks nodes containing obviously dead code branches labeled false true false 
sis example branch false 
line marked dead code rule 
code generated branches 
rule loc refers node matched pattern matching portion rule 
match false 
true 
loc relations hold pieces code 
done code needs calculated point parse tree generated tree 
code functions generated earlier phases relational database creation passed transformation engine calculation code accumulating relation 
example code functions execute specification placed generated code 
functions contain code variable specification code calculated variable declarations portion parse tree variables listed 
example value list values enumerated type requires code reading writing value previously described conversion names specification names code 
example relation contain pair composed variable value code strcmp return valid input return code stored relations input output routines generated node parse tree entire type definition occurs value occurs 

code generation rewrite rules generation code scr specification apts rewrite rules performed steps 
grammar created combines language specification form corresponding code 
second relations defined capture information specification 
set transformations defined replaces scr specification corresponding code 
transformation code generator uses grammar combines form acceptable scr specification form tex leonard heitmeyer code corresponding specification 
combined grammar transformation tree combination scr code valid program 
design decision 
transformation apts check parse tree remains valid combined grammar strictly required apts 
grammar gives parse tree nodes alternate general structure language specific structure 
example consider general structure rule grammar corresponding language specific rules case id esac node denoting case statement event table case ev child node denoting scr event table case statement scr case ev node denoting code corresponding event table case statement case ev 
scr event table case statement delimited keywords case esac includes name identifier value branches conditioned 
defined terms general structure node case branch evs denotes branches case statement 
node defined terms case branch evs turn defined terms language specific nodes denoting branches 
parse tree initially created scr specification contains general structure nodes alternating scr structure nodes 
transformation process scr nodes replaced nodes times transformation valid parse tree 
input scr specification parsed grammar relational database inference engine called 
addition relations described preceding section code generator needs new relation checking input valid scr specification 
necessary layered nature grammar allows input file containing mix scr code accepted apts syntactically valid 
check scr nodes alternation general structure nodes 
input specification parsed necessary relations calculated scr specification transformed code 
translation done stages order stages matters transformations change parse tree may cause matches transformations fail 
tex program synthesis apts stage transformation eliminates dead code specification 
dead code line sis example removed rewrite rule 
match condition matches lists statements member statement second member list statements 
recall node corresponding line added relation building relational database condition true 
complete list replaced parse tree second component eliminating dead code branch 
match 
rewrite second step replaces enumerated values appearing constant definitions variable declarations new type specific names 
example rule replaces toolow line sis example type toolow 
relation newname contains type specific name associated identifier 
enum match initially newname 
rewrite initially third stage transformation converts scr language code 
example rule replaces type definition line sis example corresponding code section 
relation contains name range checking function variable match integer 
rewrite define int void char name int value value value printf value range printf name step complete enumerated values remaining expressions replaced type specific counterparts 
event operators replaced equivalent logical expressions 
primed expression replaced name corresponding primed variable expression variable 
primed expression enumerated value integer prime eliminated 
rewrite rules perform transformations 
equal match expr true 
rewrite expr tex leonard heitmeyer event match expr true 
rewrite expr prime match expr 
rewrite expr prime match expr true 
rewrite expr prime match expr isint const 
rewrite expr rule replaces scr expression equivalent expression 
example scr event expression code generated follows 
node containing expression rewritten equal rule 
event expression transformed 
prime prime place prime correct location rewriting expression 
prime expression rewritten prime 

code generation accumulating relation alternative form code generation relies solely relations 
transforming source code target language target language code accumulated relation 
approach keeps languages separate preserves original parse tree 
negative side requires great deal additional calculation relations 
relations method transformation method additional relations hold generated code relation calculate primed version expression 
purely relational framework keeps grammars scr separate parse tree contains productions scr language constructs 
need alternating style parse tree transformation code generation 
additionally need relation checks input specification pure scr mix scr 
grammars scr separated input accepted parser valid specification scr grammar 
longer combined scr grammar grammar included apts grammar specification structure code kept accumulating relation 
framework additional relations perform done transformations approach 
relation prime calculate primed version expression tex program synthesis apts primed form needed code generation available 
rules calculating prime 
rule states prime identifier corresponding primed identifier stored relation 
second states prime integer constant just integer constant 
third rule states prime equality expression involving values equality expression primes values 
note inference rule scr replaced match expr 
prime loc expr match expr isint const 
prime loc expr match expr prime prime 
prime loc expr generated code held relations 
execution code developed relations previously described 
code generated rewrite rules transformational approach approach placed relation 
node accumulating relation stores code corresponding portion scr specification represented subtree rooted node 
code determined structure tree node code associated node children 
code entire program associated root tree 
relational database rules listed perform functions rewrite rules enum described section 
rule eliminates dead code rewrite rule keeping code matched node code associated pattern variable second rule uses name enumerated value code generated expressions equivalent value including variable declarations handled transformation code generator rewrite rule enum 
third relational database rule handles situation rewrite rule associating scr range type definition corresponding code relation code 
match loc 
tex leonard heitmeyer loc match expr newname 
loc expr match integer 
loc define int void char name int value value value printf value range printf name rules generating code event expressions simpler expressions 
rules state variables integers scr specification changed code 
third rule calculates code expression checks equivalence expressions combining previously calculated code subexpressions 
rule calculates code true event converting equivalent logical expression 
note rule assumes code corresponding prime value expression calculated stored 
match expr 
loc expr match expr isint 
loc expr match expr 
loc expr match expr prime 
loc expr consider example 
relational database rules earlier relation prime calculate relations code prime subcomponents 
example rules prime prime prime code code basis determine values relation prime prime code 
calculate value code full expression code prime 
tex program synthesis apts 
discussion scr specification transformation strategies generate exactly code 
sis example generated lines code transformation strategy required minutes relation strategy required minutes 
generators generate code scr requirements specification cryptographic device 
specification contains variables function definitions lines long 
translation scr tabular specification scr grammar apts done hand translation automated 
second example code generator rewrite rules required approximately hours generate lines code 
generator accumulated code relation required far longer hours 
observed version rewrite rules spent time building relational database 
clearly speedup apts relational database inference engine greatly improve execution times code generators 
purposes apts useful tool exploring strategies contained means implement relational transformation approaches 
clearly time needed generate code apts currently great apts construct production quality system 
paige planned number improvements apts estimated improve translation rate factor 
improvements included translating setl code apts expected speedup factor partial evaluation convert apts interpreters compilers expected speedup factor 
improvements times generating code sis seconds minutes cryptographic device minutes hours 
transformation approach generates code quickly apts relation strategy straightforward 
rewrite rules easily understood relate directly inference rules relation strategy necessary execution ordering rewrite rules intuitive 
important note purely transformational strategy impossible code needed calculated point parse tree generated different point tree 
generator rewrite rules done placing code re execution times sun ultra ultrasparc ii mhz cpus gb memory running solaris 
tex leonard heitmeyer lation relational database passing transformational engine 
changing target language language modifying code generated require approximately amount generators 
relations strategies refer scr specification change 
code generators grammar apts require modification 
transformation strategy language structures interleaved grammar replaced language structures new target language 
strategy translation strategy interleaved grammar changing grammar easier 
new language need interleaved scr grammar simply added grammar file place grammar 
transformations accumulating relation modified 
cases actual conditions rules rewrite inference remain 
changes result rewrite rule value stored accumulating relation 
noted code generated incomplete specifications 
particular code generated partial specifications dependent variables defined table function 
code generated function definition independent code generated function definition possible generate code separately function specification 
variable declarations type definitions constant definitions variables types constants table need included partial specification order code properly generated table 
generated code performs 
code communications device processed input file monitored events second 
hand written code generated code compared scr toolset simulator produces java code simulate behavior state machine defined specification 
code runs faster simulator java code fair comparison difficult 
java code generally slower code simulator uses gui interface slowing running time 
simulator advantage code optimized update variable variables depends changed 
major contribution paige research finite differencing 
apts manual states apts contains techniques optimizing generated code 
tex program synthesis apts niques apts documented 
preliminary code generated scr specifications optimized done 
serious source inefficiency generated code new input requires update variable program 
obvious way reduce inefficiency scr simulator variable dependencies computed automatically scr toolset determine variables potentially change value input variable changes value eliminate updates remaining variables 
information invariants may optimize variable updates 
ways reduce inefficiency identify parts specification lead dead code redundant code omit code generation parts 
implementations currently eliminate obviously dead code branches labeled false 
state invariants constructed algorithms described identify parts specification lead dead code redundant code 
example shows true high state invariant sis specification 
invariant implies change true false high old state 
disjunct line sis specification high ignored produces dead code 
similarly specification automobile cruise control system automatically generated state invariants inactive 
event lever const inactive brake may replaced equivalent event lever const inactive brake 

related generating code specifications new idea 
apts translators setl sq translate specifications high level languages apts meta refine kids design translators high level declarative specifications executable programs 
commercial tools generate code specifications 
example statemate generates ada code statechart specifications generates ada code lustre 
code generator specifications written rsml discussed 
imperative code generated specifications frp event driven functional reactive tex leonard heitmeyer programming transformations applied optimize code 
scr frp variables change value response events 
interest expressed translating frp scr 
strategies share similarities previous code generation methods 
store additional information relations 
relations defined nodes parse tree making relations similar attributes attribute grammar systems synthesizer generator 
attribute grammar relational approach treats target code synthesized attribute parse tree specification 
apts rewrite rules generate code similar cai paige apts translate setl sq translations rewrite rules generate code just implementation 
difference theirs apts built finite differencing dominated convergence optimizations 
transformational strategy similar hats transformational programming system tree rewriting rules 
hats transformational strategy rewrite rules modify actual tree hold changed code require transformations produce valid trees 
condition rewrite rules matching patterns trees 
difference apts transformational strategy allows relations hold additional information conditions matching rewrite rules 
difference hats approach hats may problem specific transformations transformational system currently support 
systems twig iburg produce code generators modify parse tree 
apts passes parse tree code generator generators making passes parse tree 
pass finds set minimal cost patterns cover tree 
second pass executes semantic actions associated patterns 
twig iburg replace code tree target language code transformational system 
pattern matched code associated pattern generated file tree reduced rewrite rule pattern 
process repeated tree reduced 
noted section code generated code generators uses execution model similar execution model scr systems translation scr promela 
sets variables old state values new state tex program synthesis apts values 
encode function tables conditional statements target language execute code functions order determined dependency relationship variables 
difference promela translation uses nondeterministic choice implement branches table impossible significant difference result possibly different semantics conditions branches table required disjoint requirement verified consistency checker scr toolset :10.1.1.17.6363

described experiments developing code generators apts 
different strategies generate code scr requirements implemented 
strategy transforms parse tree specification language parse tree target language accumulates generated code relation associated nodes specification language parse tree 
apts implementations generate code perform significant amount analysis generating code 
apts currently slow part production quality system implementing improvements paige suggested lead system uses relational database rewrite rules generate code acceptable speed 
plan study problem certifying generated code correct possibly translation validation 
apply optimizations described section scr specifications 
wish acknowledge bob paige apts system assistance provided apts 
bob provided version scr grammar apts answered questions system 
initial scr grammar done ramesh bharadwaj 
discussions archer useful development grammar 
algorithms constructing invariants scr specifications idea invariants identify parts specification lead redundant dead code due ralph jeffords 
anonymous reviewers colleagues archer tex leonard heitmeyer ralph jeffords helpful comments drafts annie liu scott stoller helpful discussions 

aho ganapathi tjiang code generation tree matching dynamic programming 
acm transactions programming languages systems 

archer tame pvs strategies special purpose theorem proving 
annals mathematics artificial intelligence 

bharadwaj heitmeyer model checking complete requirements specifications abstraction 
automated software engineering 

bharadwaj sims salsa combining constraint solvers bdds automatic invariant checking 
proc 
tools algorithms construction analysis systems tacas 
berlin 

blackburn applying test automation framework mars lander monitor 
lockheed martin joint symposium 

cai paige program derivation fixed point computation 
science computer programming 

cai paige increased productivity algorithm implementation 
proceedings acm sigsoft software engineering notes 

courtois 
parnas documentation safety critical software 
proc 
th int conf 
softw 
eng 
icse 
baltimore md pp 


easterbrook lutz covington hamilton experiences lightweight formal methods requirements modeling 
ieee transactions software engineering 

kirby jr shah sutton experience applying core method lockheed 
proc 
th annual conf 
computer assurance compass 
gaithersburg md 
fraser hanson proebsting engineering simple efficient code generator generator 
acm letters programming languages systems 

halbwachs raymond generating efficient code data flow programs 
third intern 
symposium programming language implementation logic programming 
passau germany 

harel statemate working environment development complex reactive systems 
ieee trans 
softw 
eng 
se 

heimdahl keenan generating code hierarchical state requirements 
proc 
ieee international symposium requirements engineering 

heitmeyer software cost reduction 
ed encyclopedia software engineering 
new york ny john wiley sons second edition 
tex program synthesis apts 
heitmeyer kirby labaw archer bharadwaj abstraction model checking detect safety violations requirements specifications 
ieee trans 
softw 
eng 


heitmeyer kirby jr labaw bharadwaj scr toolset specifying analyzing software requirements 
proc 
computer aided verification th annual conf 
cav 
vancouver canada 

heitmeyer jeffords labaw automated consistency checking requirements specifications 
acm transactions software engineering methodology 

parnas shore software requirements aircraft 
technical report nrl wash dc 

parnas utter documentation software design medium 
bell system tech 


jeffords heitmeyer automatic generation state invariants requirements specifications 
proc 
sixth acm sigsoft symp 
foundations software engineering 

jeffords 
personal communication 

jeffords 
personal communication 

jeffords heitmeyer algorithm strengthening state invariants generated requirements specifications 
proc 
fifth ieee international symposium requirements engineering 

kirby jr archer heitmeyer scr practical approach building high assurance system 
proceedings th annual computer security applications conference acsac 

knuth semantics context free languages 
mathematical systems theory 

lalonde regular right part grammars parsers 
communications acm 

lowry meta synthesis efficient domain specific program synthesis systems 
automated software engineering 

meyers white software requirements methodology tool study technology transfer 
technical report aerospace ny 

miller specifying mode logic flight guidance system core scr 
proc 
nd acm workshop formal methods software practice 

paige programming invariants 
ieee software 

paige symbolic finite differencing part 
jones ed proc 
esop lncs 

paige apts external specification manual rough draft 
unpublished manuscript available www cs nyu edu 

paige viewing program transformation system 
proc 
joint th int conf 
programming language implementation logic programming th int conf 
algebraic logic programming alp 
lncs 

parnas madey assessment safety critical software nuclear power plants 
nuclear safety 
tex leonard heitmeyer 
pnueli siegel translation validation 
international conference tools algorithms construction analysis systems tacas 
pp 

lncs 

reasoning systems refine user guide version 

reps teitelbaum synthesizer generator system constructing language editors 
new york ny springer verlag 

smith kids semiautomatic program development system 
ieee transactions software engineering 

snyder setl programming language 
technical report courant institute new york university 

wan taha hudak event driven frp 
proc 
fourth international symposium practical aspects declarative languages padl 

winter kapur berg refinement derivation train controllers 
winter bhattacharya eds high integrity software 
norwell ma kluwer academic publishers chapt 
pp 

appendix simple grammar scr grammar scr section variation bharadwaj sims 
rules form regular right part grammar 
discussed section rules replaced equivalent bnf grammar rules grammars apts 
grammar rules boldface type indicate tokens language 
italics denotes nonterminals 
delta delta delta represents occurrences inside parentheses 
similarly delta delta delta means occurrences inside parentheses 
instances parentheses read actual occurrences parentheses language tokens 
vertical bar denote choice 
formally scr specification begins keyword spec identifier name specification line example 
followed sections specification 
spec spec id type defs constant defs var declarations assumptions assertions function defs type definitions 
users define types scr 
kinds type definitions allowed integer range list enumerated values 
addition user defined types built types integers booleans 
tex program synthesis apts type defs type definitions id ud type ud type integer sint sint enum id id type id built type built type integer boolean sis example section contains user defined types lines 
constants 
constants defined setting identifier equal expression declaring type 
constant defs constant definitions id expr type integer constants sis example low permit lines 
variables 
categories variable declarations corresponding types variables scr specifications monitored controlled term mode classes 
variable initial value placed declaration signifying initial value specified 
var declarations monitored variables var decls controlled variables var decls term variables var decls mode classes var decls var decls id id type initially init val init val expr variable declarations sis example appear lines 
assumptions 
variable declarations followed section containing assumptions environment 
assumption name defined predicate 
predicates may contain events expressions involving states 
state expression may new value variable denoted old value syntax assertions syntax assumptions 
tex leonard heitmeyer assumptions assumptions id predicate assertions assertions id predicate predicate event bool expr prime predicate logical op predicate predicate sis example contains assumption assertions 
sections lines 
function definitions 
function definition section contains functions update values variables 
complete specification function dependent variable 
types tables exist specifying update functions condition tables event tables 
start new table indicated keyword var followed name variable table defines 
variable name comes punctuation indicating variable defined condition table event table 
moded condition tables injection lines expressed case statement 
identifier keyword case name mode class variable 
followed set branch statements begins list identifiers modes mode class variable 
semantics selects branch containing mode current value mode class variable named case statement 
statement corresponding branch executed 
statement contains pairs boolean expressions expressions joined arrow 
gamma 
means boolean expression evaluates true variable assigned value expression event tables defined similarly condition tables see lines 
difference place statements event tables event statements 
event statement contains pairs events state expressions joined arrow 
semantics ev gamma 
event ev evaluates true variable assigned value expression events evaluates true value variable changed 
event condition tables defined 
form table branch moded table 
variable update function defined event table lines 
tex program synthesis apts function defs function definitions funct def funct def var id cond tab event tab cond tab case stmt case case id case branch esac case branch id id stmt stmt bool expr gamma 
expr fi event tab case ev ev stmt case ev case id case branch ev esac case branch ev id id ev stmt ev stmt ev gamma 
expr prime events 
basic types events true value expression changes false true 
evaluates boolean expression old state new state false old state true new state true 
false 
similarly event true value boolean expression changes true false 
event true value expression old state different value new state 
notice expression just boolean value 
basic events combined operators form conditional events 
conditional event true basic event true boolean expression true 
similar boolean expression allowed include primed variables 
logical combinations events allowed 
special event presence event table indicates particular situation occur 
basic event bool expr bool expr expr cond event basic event bool expr basic event bool expr prime event basic event cond event event logical op event event tex leonard heitmeyer expressions 
categories expressions state expressions describe values variables single state state expressions may include values variables old new states 
category expressions divided types type result return arithmetic enumerated boolean 
arithmetic expressions include signed integers identifiers arithmetic type standard binary operations arithmetic expressions unary plus minus operations 
enumerated expressions just identifiers having enumerated type 
includes possible values enumerated type 
boolean expressions consist true false identifiers boolean type standard logical operations applied boolean expressions 
boolean expressions include equality checks pairs boolean expressions pairs enumerated expressions 
basic arithmetic relational operators allowed boolean expressions 
arith expr sint id arith expr arith op arith expr arith expr arith expr arith expr enum expr id bool expr bool id bool expr bool expr logical op bool expr bool expr bool expr bool expr enum expr enum expr arith expr rel op arith expr expr bool expr arith expr enum expr grammar state expressions similar state expressions 
difference primed identifiers referring tex program synthesis apts new state value identifier allowed expressions 
arith expr prime id arith expr arith expr prime arith op arith expr prime arith expr prime arith expr prime arith expr prime enum expr prime id enum expr bool expr prime id bool expr bool expr prime bool expr prime logical op bool expr prime arith expr prime rel op arith expr prime bool expr prime enum expr prime enum expr prime bool expr prime bool expr prime expr prime bool expr prime arith expr prime enum expr prime lexical categories productions basic lexical categories 
signed integers boolean values true false defined standard relational arithmetic operators 
note logical operators written jj respectively 
rel op logical op arith op gamma bool true false digit int digit sint int int alpha 

char alpha digit id alpha char tex leonard heitmeyer specifying simple control system scr appendix contains tabular forms function definitions safety injection system sis example section 
mode class see lines sis example defined mode transition table special class event table shown table table mode transition table 
old mode event new mode toolow low permitted permitted permit high permitted low toolow high permit permitted term defined event table see lines example 
corresponding tabular form shown table ii 
table ii 
event table 
modeless events high high high high true false controlled variable injection defined moded condition table see lines 
table iii shows tabular form definition 
table iii 
condition table injection 
mode conditions high permitted true false toolow injection tex 
