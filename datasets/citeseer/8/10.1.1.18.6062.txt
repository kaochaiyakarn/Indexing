ontology oriented design programming mark musen stanford medical informatics stanford university stanford california usa musen stanford edu construction conventional software intelligent systems developers continue seek higher level abstractions aid conceptual modeling assist implementation maintenance 
years artificial intelligence community placed considerable attention notion explicit ontologies shared conceptualizations application areas define salient concepts relationships concepts 
ontologies joined defined problem solving methods provide convenient formalisms modeling implementing solutions application tasks 
chapter reviews motivation seeking high level abstractions summarizes successes building systems reusable domain ontologies problem solving methods 
environment software execution moves individual workstations internet large casting new software applications terms high level abstractions may complex systems easier build easier maintain 

search reusable abstractions field artificial intelligence ai contributed great deal conventional software engineering 
example couched framework knowledge acquisition expert systems led interviewing strategies methods systems analysis modeling techniques influential broadly area requirements engineering 
conceptual modeling techniques pioneered early workers ai standard elements industrial software design 
object oriented programming major strides forward researchers developed host practical frame knowledge representation systems entered mainstream software engineering ai researchers created extensions lisp language support data encapsulation message passing 
myriad tools computer assisted software engineering case unified modeling language uml pervasive object oriented programming languages java owe heritage early ai 
time countless algorithms techniques search optimization probabilistic reasoning signal understanding translated ai research laboratories software libraries developers day build thousands mundane computer programs 
despite great tradition translation ideas ai conventional software engineering workers ai history getting trouble recognizing central importance software ai enterprise 
developers knowledge systems contributed techniques requirements engineering community attempted scale 
ai developers claimed construction electronic knowledge bases knowledge engineering software engineering 
years ignored rapid advances software engineering place parallel build large scale knowledge systems 
workers software engineering struggled complexities large scale systems developers ai believed large knowledge systems constructed simply adding modular statements disordered collection production rules characterized knowledge systems time 
failure ai systems developed meet requirements allow maintainability time function view na view systems engineering 
eventual emergence formal methodologies construction knowledge systems kads occurred direct response problems 
contemporaneously software engineering community 
time computer programs scores authors began write software crisis prevents reliable maintainable software developed time budget 
conventional software frequently fails meet requirements 
software meets current requirements insufficiently malleable adapt changing organizational demands 
development new software applications routinely requires programming scratch large amounts error prone source code 
brooks argued single silver bullet fix software crisis technologically suggests intrinsically creative processes software engineering critically dependent unique abilities creative people perform processes 
clear essential element software engineering addressed technological perspective involves management complexity 
earliest days structured programming recurrent theme software engineering concerned appropriate abstraction encapsulation procedures data 
developers turn reuse software components potential way perpetual software crisis 
belief libraries software components offer modular composable building blocks large application programs 
building blocks allow developers view software abstractly 
building blocks ostensibly tested debugged 
goal construct software de novo select appropriate components libraries glue fashion 
vision component software development compelling leaves uncertainty regarding exactly right kinds components reuse 
krueger thoughtful review software reuse identifies ways developers reapply different kinds software abstractions 
alternatives include high level high level languages design code scavenging subroutine libraries design patterns application generators automatic programming 
case goal overcome complexity appropriate abstractions minimize cognitive distance way developer thinks problem solved language available specifying solution 
krueger enumerates variety forms software reuse different levels abstraction far away familiar examples software reuse applications programmers involved predefined libraries explicit subroutines 
developers turned subroutine libraries fill defined gaps program code 
libraries semantics subroutine parameter clear 
meaning function library common background knowledge shared developers consumers software elements 
assumptions subroutine readily enumerated 
despite clear success reuse libraries level abstraction provided individual software components obviously modest 
software engineers continue look reusable components encompassing scope routines calculate sine cosine angles user interface widgets users 
past decade notion design patterns wildly popular software developers 
design patterns provide descriptions program solutions suitable particular problems particular contexts 
provide frameworks software engineers structure program code offering standard structures ease design maintenance large software systems 
subroutine libraries design patterns address large scale issues program design 
unfortunately design patterns inspire implementations 
provide reusable program code obviate need careful testing debugging 
original kads methodology identified akin design patterns modeling expertise knowledge systems 
authors kads suggested interpretation models common tasks diagnosis planning guide conceptual modeling domain knowledge frame implementation knowledge base 
kads provided library interpretation models assumed developers able apply inference patterns designing conceptual models nascent knowledge systems 
design patterns software engineers build conventional computer programs interpretation models executable way provided scaffolding implement working system 
theme knowledge systems community past decade develop means reuse large scale software components building intelligent systems 
interpretation models design patterns reusable components operational dimension provides working code 
elements mathematical subroutine libraries components large scale provide algorithms automating complete tasks 
components domain ontologies provide characterization concepts relationships application area problem solving methods offer algorithms achieving solutions stereotypical tasks 
turning large scale reusable components workers ai believe mitigated software crisis plagues construction intelligent systems 
chapter examines abstractions build knowledge systems speculates similar abstractions may useful development conventional software applications 

moving rules discussing current component architectures knowledge systems important acknowledge architectures appreciated outside academic circles 
despite range modern development technologies tools surveyed volume computer scientists think knowledge systems terms rule approaches popularized 
continued widespread availability generic shells constructing rule systems ops clips reinforces notion 
majority knowledge systems continue built rule frameworks known limitations scalability maintainability systems researchers began identify nearly soon rule systems developed 
practice explicit ontologies problem solving methods build modern knowledge systems overcomes limitations traditional rule architectures 
clancey credited demonstrating early limitations constructing knowledge systems simply collections production rules 
careful analyses mycin knowledge base showed developers system rule base construct production rules interact arcane ways order coerce system demonstrate desired problemsolving behavior 
example sequencing clauses left hand side rule needed considered carefully changing order conditions radically change way program gather process information case consideration 
members mycin project documented programming practices explicitly knowledge base builders carefully tinker ordering rule clauses order achieve necessary system performance 
subsequent developers seemingly innocent changes rule base surprising changes system program solving behavior result 
official claim rules mycin independent modular clear developers needed view production rules elements high level programming language 
developers intentionally created dependencies various rules knowledge base order effect desired problem solving behavior 
rules rule systems generally annotated classified organized purpose individual rules relationships difficult determine direct inspection knowledge base 
experience industry confirms construction large software systems unorganized collections production rules problematic enterprise 
large commercial rule systems xcon provided convincing demonstrations knowledge technology unmanageable imposition considerable additional structure knowledge base 
subsequent decades substantial develop improved design methodologies knowledge systems specifically emphasized techniques manage complexity clarify way knowledge problem solving 

reusable ontologies workers ai came accept general concepts application domain represented independently problem solvers ultimately automate tasks domain knowledge applied 
chandrasekaran colleagues cautioned distinctions developers application domain necessarily determined problemsolving requirements certain foundational concepts emerge salient cursory analysis new application domain 
foundational concepts represented separate editable data structures corresponding enumeration concepts reused build different kinds knowledge bases 
point view fundamental original kads methodology knowledge engineering encouraged developers build models clear distinction foundational domain concepts inferences problem solving procedures applied concepts 
current parlance enumerations domain concepts relationships concepts referred domain ontologies 
ontology provides domain discourse understandable developers computers build knowledge bases containing detailed descriptions particular application areas 
example understood ontology categorization yahoo 
provides users searching internet 
yahoo 
ontology defines broad categories entries world wide web 
users understand ontology apply locate concepts define interests yahoo 
search engine process ontology uses locate corresponding web pages 
relationships concepts yahoo 
ontology generally taxonomic primarily class subclass relationships 
ontology include part relationships general goal simply provide enumeration searchable concept descriptions 
clear engineering machine processable ontologies major business companies promoting access complex information sources heart electronic commerce applications 
studer colleagues suggest expanding ontologies drive web applications soon developing standalone software systems 
notion reusable ontologies increasingly important developers intelligent systems 
just modern database systems driven conceptual schemas define classes entities database stores specific data modern knowledge systems incorporate central component knowledge bases model classes domain related entities problem solving takes place 
ontology defines relevant concepts attributes concepts may generally silent regarding specific values attributes assumed particular instances concepts 
descriptions instances concepts generally appear contents knowledge bases derived particular ontology 
course developers construct ontology considerable regarding instances ultimately need represented 
consideration potential instances informs developer conceptualization classes need included ontology ontology defined developers encode instances terms classes relationships ontology dictates 
ontologies models single correct way define ontology 
different perspectives modeler take domain alternative perspectives may need captured simultaneously 
example medical ontologies drugs categorized basis physiological function basis chemical structure 
medical ontologies may wish include relationship diseases causative agents ontologies may ontologies may wish include relationship diseases clinical manifestations ontologies may 
ontologies represent convenient ways characterizing set concepts relationships application area 
capture absolute platonic truths exist world 
merits particular ontology measured terms ontology supports development application programs designed easy developers reuse ontology build new applications 
shadbolt colleagues discuss detail explosive interest reusable ontologies years 
developers seeking create libraries ontologies capture set core concepts needed model different application areas paving way reuse previously developed ontologies new systems 
developers see ontologies means providing canonical description concepts allow integration multiple information sources particularly individual information sources adopt idiosyncratic ways referring concept 
builders intelligent systems ontologies provide structure domain knowledge bases allows coherent views relevant concepts relationships concepts 
knowledge base extension applicable ontology ontology provides roadmap classes concepts comprise knowledge base 
just schema provides organizing framework database ontology provides framework domain knowledge base 
specific ontologies rarely reusable toto application provide considerable guidance developers wish create new systems domain 

problem solving methods concomitant increasing interest domain ontologies apparent investigators recurring problem solving strategies emerge behaviors rule systems 
clancey proposed heuristic classification clearly defined inference pattern identified known systems mycin 
performing heuristic classification problem solver start primitive case data enduser input system patient white blood cell count cells cubic millimeter abstracted data general descriptors patient compromised host 
heuristics link abstractions general candidate solutions compromised hosts caused organisms additional knowledge refine general solutions specific classifications patient infected coli 
mycin feature abstraction create generalizations input data heuristic match identify classes possible organisms suggested patient characteristics solution refinement reduce set possible organisms small number pathogens 
hand feature abstraction translate numerical measurements pulmonary physiological parameters patient lung function heuristic match identify possible pulmonary diseases associated functional states 
solution refinement allow program narrow set possible diseases considering additional information patient 
systems different purposes mycin heuristic classification common problem solving paradigm 
clancey analysis showed heuristic classification defined problem solving approach developers happened create variety disparate decision support systems 
modern knowledge systems continue heuristic classification basis intelligent behavior 
time clancey studying heuristic classification chandrasekaran group ohio state university identified recurring problem solving strategies knowledge systems building 
chandrasekaran referred stereotypical problem solving behaviors generic tasks 
john mcdermott group carnegie mellon university noting set problem solving methods provided control structure number knowledge systems built non medical areas 
investigators demonstrated intelligent systems highly regular mechanisms sequencing certain classes inferences 
domain independent problem solving strategies provided standard ways addressing certain kinds application tasks 
original developers knowledge systems thought regularities explicitly number welldefined generic strategies emerging analysis diverse automated problem solvers addressed associated application tasks 
generic strategies referred problem solving methods nearly workers knowledgebased systems community 
problem solving methods provide structure building intelligent systems 
designer come understand domain knowledge needed solve application task terms predefined problem solving method clear element domain knowledge ultimately contribute problemsolving behavior system 
designing heuristic classifier example developer identify readily primitive inference production rule perform feature abstraction case data heuristic matching case descriptions possible solution solution refinement specific classifications 
heuristic classification model unifying framework relate elements domain knowledge developer acquire 
problem solving method basis conceptual modeling design time limits roles domain knowledge play problem solving particular knowledge roles feature abstraction heuristic match defined method 
knowledge roles problem solving methods clear domain knowledge needed solve task automated method method roles need filled method clarify purpose piece elicited knowledge 
system builders examine knowledge base knowing role proposition plays problem solving helps understand assumptions associated piece knowledge 
developers enter new knowledge knowledge base added propositions explicitly fill role roles problem solving method entered knowledge fill role propositions necessarily superfluous task automated 
far described problem solving methods conceptually stereotypical procedures 
associated piece program code implements relevant algorithm problem solving method abstraction useful conceptual modeling method building block programmer implement working system 
developers method conceptually help model domain knowledge need acquire build decision support system 
conceptual analysis system builders knowledge roles problem solving method categorize kinds domain knowledge need elicit building initial ontology 
operational form problem solving method implement particular knowledge system 
ultimately problem solving method functions element mathematical subroutine library provides reusable piece software facilitates implementation required computer program 
literature describes dozens reusable problem solving methods defined tasks fault diagnosis constraint satisfaction skeletal planning bayesian classification 
methodologies building intelligent systems common kads emphasize descriptions problem solving methods primarily conceptual modeling approaches prot expect provide libraries implemented problem solving methods contribute program code system development 
problem solving methods provide enormous degree procedural abstraction allowing developers treat complex algorithms black boxes architectures provided prot ksm allow developers compose problemsolving methods aggregations methods solve particularly complex tasks 
interactions problem solving methods reminiscent communication takes agents agent oriented systems 
autonomous agents encapsulate problem solving knowledge domain knowledge problem solving methods purely procedural processing knowledge bases external procedural code 
developing intelligent systems include separate domain ontologies problem solving methods primary concern involves linking concepts represented domain ontology corresponding referents problem solving method ultimately allow method operate relevant domain concepts 

putting pieces ontology typically contain instances concepts view knowledge base instantiation extension ontology 
knowledge base comprises filled concept descriptions enumerating details particular application built 
domain ontology knowledge acquisition systems prot allow straightforward entry corresponding knowledge base 
prot system permits developers create domain ontology simple editing system 
prot uses domain ontology create programmatically user interface subject matter experts enter detailed content knowledge required populate knowledge base 
tools generated prot browse update knowledge base necessary provided overarching domain ontology remains constant 
ontology change may necessary generate new knowledge entry tools capture corresponding changes concepts relationships ontology 
course generating tools automatically prot considerably convenient having reprogram tools hand 
construction knowledge bases intelligent systems tools prot considerably easier entering production rules data structures traditional knowledge base editor 
domain ontology establishes terms entry content knowledge 
structure ontology translates directly windows forms widgets graphical user interface organizes domain knowledge acquires presents knowledge coherent manner understandable user understand distinctions original ontology 
laboratory demonstrated utility prot approach building maintaining wide variety complex knowledge bases 
modern knowledge engineering building intelligent systems construed encoding production rules creation specific knowledge representations 
process viewed design assembly domain ontologies knowledge bases instantiate ontologies domain independent problemsolving methods 
task automated challenge identify construct appropriate problem solving method link problem solver ontology defines relevant concepts application area 
emphasis shifted writing isolated production rules creation libraries potentially reusable ontologies problem solving methods 
goal transform system development matter selecting modifying assembling previously tested debugged components require programming new application scratch 
hope components quite high level abstraction assembly components take place easily cases software reuse 
laboratory taken general purpose constraint satisfaction problem solving method known propose revise associated method number different domain ontologies build variety intelligent systems 
propose revise method operates ontology elevator parts building codes engineering constraints automates task designing elevators new buildings 
propose revise operates ontology describes molecular components coli ribosome kinds constraints experimental data place location molecular components threedimensional space automates task determining plausible conformations ribosome 
similarly developed appropriate ontologies propose address tasks monitoring patients receiving mechanical ventilation planning therapy patients aids 
building application programs propose revise problem solving method completely reusable 
challenge case identifying generic data propose revise method operates related specific concepts different domain ontologies 
general knowledge systems community turned building systems reusable problem solving methods domain ontologies principal challenge define best way glue components 
approach taken prot project defined different types mappings provide necessary relations concepts described domain ontology input output requirements generic problem solving method 
systems built prot create explicit objects link data elements problem solving method operates particular concepts domain ontology 
example mappings relate concept restrictions drugs defined domain ontology hiv therapy concept constraints propose revise method 
current concentrates refining ontology kinds mappings 
mappings ontology provides structure relating domain ontologies problem solving methods guiding process principal kinds components brought software system 
ontology allows developers classify mappings involve complete class definitions combination class attributes mappings apply specified class include subclasses inheritance tree mappings determined statically time system construction dynamically run time degree mappings involve functional transformation source values 
establishing characteristics apply mapping system builders completely specify information needed relate domain ontologies problemsolving methods operate ontologies 
workers prot project believe maximal flexibility achieved declarative mappings relate problem solving methods domain ontologies 
developers common kads methodology commitment manner ontologies problem solving methods brought actual implementation 
researchers fensel motta suggest may efficient modify problem solving method directly means adapter facilitate interoperation domain ontology 
considerable unanimity domain ontologies generic problemsolving methods provide right kinds abstractions building intelligent component systems agreement optimal way individual components communicate 
problem linking domain ontologies reusable problem solving methods remains active area research knowledge systems community 
principal challenge permit developers combine domain ontologies problem solving methods coherent architecture having perform considerable programming glue pieces 
apparent advantages component approach lost cost reusing problem solving methods domain ontologies suddenly appears assembly stage 

discussion years workers field conventional software engineering anticipated time complex systems built rapidly bringing reusable software components 
general goals software reuse remained elusive knowledge systems community achieved increasing success reusing domain ontologies problem solving methods craft new applications 
laboratory reuse propose revise method construct different user systems provides clear demonstration modular software components reapplied construct programs variety applications 
actual reuse program code remains difficult problem conventional software engineering considerable interest identification reuse design patterns help developers structure software solutions 
design patterns object oriented programming provide exemplars facilitate conceptual modeling implementation software systems commonly recurring programming constructs data types 
reusable domain ontologies problem solving methods investigated knowledge systems community allow direct reuse previously tested solutions construction new software 
domain ontologies problem solving methods provide framework conceptual analysis design actual program code incorporated wholesale new applications 
distinct domain ontologies problem solving methods contrasts sharply traditional object oriented architectures program code form methods interleaved representation domain model form class instance objects 
standard object systems facilitate specialization program code basis distinctions domain model method polymorphism clearly identify data structures closely related control structures operate data 
properties traditional object oriented systems malleable programmers adapt software evolving requirements 
degree fuzziness regarding semantics encoded objects 
object oriented languages advantage making relatively straightforward developers graft new functionality existing program code 
tight linkage class hierarchies constitute domain model program code embodied objects methods difficult analyst view element independently 
traditional program impossible consider control flow relationships separately data structures comprise object hierarchy 
impossible view data model distracted associated program code 
development intelligent systems separate domain ontologies reusable problem solving methods particularly justified ontologies methods reused build new derivative applications 
additional front engineering costs required design components reuse amortized subsequent development efforts 
approach particularly attractive developers anticipate unusual requirements software maintenance 
need significant program revisions may result domain models domainspecific facts evolve time 
situation incorporation declarative domain ontologies domain dependent information explicit accessible easily editable minimizing difficulty updating system 
high degree software maintenance may necessary developers design new algorithms achieve better performance encapsulating algorithm problemsolving method allows systems engineers plug new control strategies having alter domain ontology knowledge base 
course mappings domain ontology new problem solving method need changed 
compelling examples successful reuse domain ontologies problem solving methods 
practice limitations components 
quite clear distinctions developers application area depend heavily developers imagine domain knowledge problem solving 
diagnostic task solved heuristic classification example different domain knowledge required task solved bayesian reasoning 
chandrasekaran group identified interdependency interaction problem 
uncommon previously defined domain ontologies require modification new purposes 
similarly complex domain tasks may difficult construe terms simple stereotypical problem solving procedures 
case automate different aspects medical therapy example necessary enhance capabilities standard reusable problem solving method invoking additional domain specific problem solvers changes standard problem solver 
fine tuning problem solving methods far easier programming method scratch clear developers reached stage routinely construct complex software systems simply assembling plug play components 
despite difficulties components ontologies reusable problem solving methods offer promise making software artifacts easier build easier understand easier maintain time 
advantages occur domain ontologies problem solving methods provide means view intelligent system high level abstraction separates enumeration domain concepts way concepts problemsolving 
course developers rule systems contended separated declarative knowledge form rules procedural knowledge form inference engines process rules 
unfortunately inference engines rule systems special purpose programs operate specific data structures production rules 
rules hand implicitly may encode considerable control flow information 
modern architectures problem solving methods procedures operate predefined data structures procedures operate ontologies 
maintaining perspective relating domain ontologies defined problem solvers offers basis effective conceptual modeling system implementation components appropriate level abstraction 
chapter highlighted reusable ontologies problem solving methods build intelligent systems conventional nature 
evidenced book demands internet programming increase importance reusable abstractions described 
world wide web consortium promoting resource description framework rdf standard means annotate web pages machine processable domain knowledge 
knowledge bases ontologies encoded rdf rdf schema promise interact internet problem solvers ways greatly expand scope commonly view knowledge system intelligent systems promise ubiquitously fabric world wide web 
software engineering community seeks scalable solutions problem developing systems highly dynamic distributed environment large grained abstractions domain ontologies reusable problem solving methods inevitably important components web software systems 
may software crisis sort researchers responding kinds abstractions may intelligent computer systems kinds easier build important easier maintain requirements domain knowledge evolve 
acknowledgments supported lm united states national library medicine contracts supported defense advanced research projects agency 
prot system ontology editing knowledge acquisition may freely downloaded web site open source license agreement www smi stanford edu projects protege 
kidd ed knowledge acquisition expert systems 
plenum new york 
brodie mylopoulos schmidt eds conceptual modeling perspectives artificial intelligence databases programming languages 
springer verlag new york 
stefik bobrow object oriented programming themes variations 
ai magazine 
schreiber wielinga breuker eds 
kads principled approach knowledge system development academic press london 
brooks mythical man month 
addison wesley reading ma 
brooks silver bullet essence accidents software engineering 
ieee computer 
software engineering reusable components 
springer verlag berlin 
krueger software reuse 
acm computing surveys 
norman cognitive engineering 
norman draper eds user centered system design pp 
laurence erlbaum hillsdale nj 
gamma design patterns elements reusable object oriented software 
addison wesley reading ma 
breuker model driven knowledge acquisition interpretation models deliverable ai esprit project 
musen dimensions knowledge sharing reuse 
computers biomedical research 
musen schreiber architectures intelligent systems reusable components 
artificial intelligence medicine 
shadbolt hara ontologies knowledge acquisition 
eds 
knowledge engineering agent technology 
ios press amsterdam volume 
mcdermott preliminary steps taxonomy problem solving methods 
marcus ed automatic knowledge acquisition expert systems 
kluwer academic publishers boston pp 

studer situation perspective knowledge engineering 

eds knowledge engineering agent technology 
ios press amsterdam volume 
duda shortliffe expert systems research 
science 
mcdermott revisited years 
ai magazine 
clancey epistemology rule expert system framework explanation 
artificial intelligence 
buchanan shortliffe uncertainty evidential support 
rule expert systems mycin experiments stanford heuristic programming project 
addison wesley reading ma 
rime preliminary knowledge acquisition tool 
marcus ed automatic knowledge acquisition expert systems 
kluwer academic publishers boston pp 

bylander chandrasekaran generic tasks knowledge reasoning right level abstraction knowledge acquisition 
gaines eds knowledge acquisition knowledge systems 
academic press london pp 

guarino formal ontology conceptual analysis knowledge representation 
international journal human computer studies 
guarino understanding building ontologies 
international journal human computer studies 
gruber translation approach portable ontology specifications 
knowledge acquisition 
arens knoblock shen query reformation dynamic information integration 
journal intelligent information systems integrating artificial intelligence database technologies 
clancey heuristic classification 
artificial intelligence 
expert system interpretation pulmonary function data 
computers biomedical research 
chandrasekaran task structure analysis knowledge modeling 
communications acm 
fensel essence problem solving methods making assumptions gain efficiency 
international journal human computer studies 
eriksson task modeling reusable problem solving methods 
artificial intelligence 
mole knowledge acquisition tool 
international journal man machine studies 
marcus mcdermott salt knowledge acquisition language propose revise systems 
artificial intelligence 
tu episodic skeletal plan refinement temporal data 
communications acm 
schreiber knowledge engineering management commonkads methodology 
mit press cambridge massachusetts 
van de velde eds commonkads library expertise modeling 
ios press amsterdam 
musen component support building knowledge acquisition systems 
proceedings conference intelligent information processing iip ifip sixteenth world computer congress wcc beijing china august pp 

grosso knowledge modeling millennium design evolution prot 
proceedings twelfth knowledge acquisition knowledge systems workshop 
banff alberta canada october 
gil explicit representations problem solving strategies support knowledge acquisition 
national conference artificial intelligence 
mit press portland 
musen tu problem solving models generation task specific knowledge acquisition tools 
ed knowledge oriented software design elsevier amsterdam pp 

molina knowledge modelling tools agent systems experience ksm 
eds 
knowledge engineering agent technology 
ios press amsterdam volume 
demazeau systems development societies agents 
eds 
knowledge engineering agent technology 
ios press amsterdam volume 
eriksson puerta musen generation knowledge acquisition tools domain ontologies 
international journal human computer studies 
shahar semiautomated entry clinical temporal abstraction knowledge 
journal american medical informatics association 
reusable ontologies knowledge acquisition tools performance systems prot ii solutions sisyphus 
international journal human computer studies 
gennari altman musen reuse prot ii elevators 
ssr acm sigsoft symposium software reusability seattle wa 
park musen vm prot study software reuse 
mccray scherrer eds medinfo seoul south korea ios press amsterdam pp 

smith park musen therapy planning constraint satisfaction computer therapy advisor management hiv 
chute ed amia annual fall symposium 
orlando fl pp 
gennari mapping domains methods support reuse 
international journal human computer studies 
park musen mappings reuse knowledge systems 
roy ed industrial knowledge management 
micro level approach springer verlag london press 
fensel motta structured development protein solving methods 
th banff knowledge acquisition knowledge systems workshop banff alberta canada 
tu musen episodic refinement episodic skeletal plan refinement 
international journal human computer studies 
world wide web consortium resource description framework rdf online www org rdf 
