journal artificial intelligence research submitted published knowledge compilation map adnan darwiche darwiche cs ucla edu computer science department university california los angeles los angeles ca usa pierre marquis marquis univ fr universite lens cedex france propose perspective knowledge compilation calls analyzing di erent compilation approaches key dimensions succinctness target compilation language class queries transformations language supports polytime 
provide knowledge compilation map analyzes large number existing target compilation languages succinctness polytime transformations queries 
argue analysis necessary placing new compilation approaches context existing ones 
go classical flat target compilation languages cnf dnf consider richer nested class directed acyclic graphs obdds show include relatively large number target compilation languages 

knowledge compilation emerged key direction research dealing computational intractability general propositional reasoning darwiche cadoli donini marquis sas khardon roth selman kautz schrag marquis del val dechter rish reiter de kleer :10.1.1.33.965:10.1.1.33.965
direction propositional theory compiled line target language line answer large number queries polytime 
key motivation knowledge compilation push computational overhead line phase amortized line queries 
knowledge compilation serve important purposes 
example target compilation languages associated algorithms simple allowing develop line reasoning systems simple software hardware platforms 
simplicity algorithms operate compiled languages help streamlining ort algorithmic design single task generating smallest compiled representations possible turns main computational bottleneck compilation approaches 
key aspects knowledge compilation approach succinctness target language propositional theory compiled class queries answered polytime compiled representation class transformations applied representation polytime 
ai literature far focused target compilation languages variations dnf cnf formulas horn theories prime implicates 
focused clausal entailment queries little discussion tractable transformations compiled theories 
goal provide broad perspective knowledge compilation considering relatively large number target compilation languages analyzing succinctness class queries transformations admit polytime 
ai access foundation morgan kaufmann publishers 
rights reserved 
darwiche marquis focusing classical flat target compilation languages cnf dnf consider richer nested class representing propositional sentences directed acyclic graphs refer nnf 
identify number target compilation languages ai formal verification computer science literature show special cases nnf 
class list extra conditions need imposed nnf obtain specific class identify set queries transformations class supports polytime 
provide cross rankings di erent subsets nnf succinctness polytime operations support 
main contribution map deciding target compilation language suitable particular application 
specifically propose starts identifying set queries transformations needed application choosing succinct language supports operations polytime 
structured follows 
start formally defining nnf language section list number conditions nnf give rise variety target compilation languages 
study succinctness languages section provide cross ranking compares measure 
consider number queries applications section compare di erent target compilation languages tractability respect queries 
section dedicated class transformations applications tractability respect di erent target compilation languages 
close section concluding remarks 
proofs theorems delegated appendix 
nnf language consider dozen languages subsets nnf language defined formally follows darwiche :10.1.1.33.965:10.1.1.33.965
definition ps denumerable set propositional variables 
sentence rooted directed acyclic graph dag leaf node labeled true false ps internal node labeled arbitrarily children 
size sentence denoted number dag edges 
height maximum number edges root leaf dag 
depicts sentence nnf represents odd parity function omit variables ps confusion anticipated 
propositional sentence represented sentence nnf nnf language complete 
important distinguish representation language target compilation language 
representation language expect humans read write ease 
language cnf popular representation language language horn clauses especially expressed rules form 
hand target compilation language need suitable human specification interpretation tractable permit non trivial number polytime queries transformations 
consider number target compilation languages qualify representation languages perspective suitable humans construct interpret 
consider number representation languages qualify target compilation languages 
formal characterization representation languages outside scope 
language qualify target compilation language require permits polytime clausal entailment test 
note polytime consistency test su cient consistency test theory justify compilation 
definition nnf 
appears proposing target compilation languages ai literature usually implicit requirement proposed language representation language 
shall see powerful target compilation languages suitable humans specify interpret directly 
knowledge compilation map decomposability determinism smoothness sentence nnf 
size height 
qualify target compilation language np papadimitriou subsets :10.1.1.32.420
define number subsets obtained imposing conditions nnf 
distinguish key subsets nnf flat nested subsets 
consider flat subsets result imposing combinations properties flatness height sentence 
sentence flat 
simple disjunction children node leaves share variables node clause 
simple conjunction children node leaves share variables node term 
sentence satisfies property 
definition language nnf subset nnf satisfying flatness 
language cnf subset nnf satisfying simple disjunction 
language dnf subset nnf satisfying simple conjunction 
cnf permit polytime clausal entailment test np qualify target compilation language 
dual dnf 
subset cnf prime implicates quite influential computer science definition language pi subset cnf clause entailed sentence subsumed clause appears sentence clause sentence subsumed 
dual pi prime implicants ip defined 
definition language ip subset dnf term entailing sentence subsumes term appears sentence term sentence subsumed term 
representing set prime implicates propositional theory compact way allowing exponential number prime implicates represented polynomial space certain cases see example trie representation de kleer representation simon del val implicit representation proposed madre coudert 
representations di erent language pi sense necessarily support queries transformations darwiche marquis report tables 
exhibit di erent succinctness relationships ones report table 
horn theories renamable horn theories represent target compilation subset cnf consider restrict attention complete languages require propositional sentence logically equivalent element consider nested subsets nnf language impose restriction height sentence 
subsets result imposing conditions decomposability determinism smoothness decision ordering 
start defining properties 
node nnf vars denotes set variables label descendants node nnf sentence rooted vars defined vars 
decomposability darwiche :10.1.1.33.965:10.1.1.33.965:10.1.1.33.965
nnf satisfies property conjunction nnf conjuncts share variables 

children node vars vars consider node marked 
node children contains variables second contains variables node decomposable children share variables 
node decomposable nnf decomposable 
determinism darwiche nnf satisfies property disjunction nnf disjuncts logically contradictory 

children node false consider node marked children corresponding sub sentences conjunction sub sentences logically contradictory 
node deterministic nodes 
nnf deterministic 
smoothness darwiche nnf satisfies property disjunction nnf disjunct mentions variables 

children node vars vars consider marked node 
node children mentions variables node smooth nodes 
nnf smooth 
hard ensure decomposability 
hard ensure determinism preserving decomposability 
sentence nnf smoothed polytime preserving decomposability determinism 
preserving flatness may blow size nnf 
smoothness important complexity viewpoint flatness 
properties decomposability determinism smoothness lead number interesting subsets nnf 
definition language dnnf subset nnf satisfying decomposability nnf subset satisfying determinism nnf subset satisfying smoothness dnnf subset satisfying decomposability determinism sd dnnf subset satisfying decomposability determinism smoothness 
note dnf strict subset dnnf darwiche :10.1.1.33.965:10.1.1.33.965
decision property comes literature binary decision diagrams bryant :10.1.1.1.5124
definition decision decision node nnf sentence labeled true false node having form variable decision nodes 
case dvar denotes variable definition language bdd set nnf sentences root sentence decision node 
knowledge compilation map true false left sentence bdd language 
right corresponding binary decision diagram 
nnf sentence belongs bdd subset 
bdd language corresponds binary decision diagrams bdds known formal verification literature bryant :10.1.1.1.5124
binary decision diagrams depicted compact notation labels true false denoted respectively decision node denoted bdd sentence left corresponds binary decision diagram right 
obviously nnf sentence satisfies decision property deterministic 
bdd subset nnf 
show bdd qualify target compilation language np subset 
definition fbdd intersection dnnf bdd 
sentence fbdd decomposable satisfies decision property 
fbdd language corresponds free binary decision diagrams known formal verification 
fbdd usually defined bdd satisfies read property path root leaf variable appear 
known read branching programs theory literature 
imposing read property bdd equivalent imposing decomposability property corresponding bdd sentence 
influential subset bdd language obtained imposing ordering property definition ordering total ordering variables ps 
language obdd subset fbdd satisfying property nodes ancestor node dvar dvar 
definition language obdd union obdd languages 
obdd language corresponds known ordered binary decision diagrams obdds bryant :10.1.1.1.5124
final language definition follows definition mods subset dnf sentence satisfies determinism smoothness 
darwiche marquis sentence language mods 
nnf nnf nnf nnf sd dnnf dnnf ce dnnf va im ct eq 
cnf dnf ip pi ce eq se va im eq se bdd fbdd eq 
obdd se mods eq se va im obdd eq set dag languages considered 
edge means proper subset subset list polytime queries supported subset ancestors see section 
depicts sentence mods 
show mods tractable nnf subset shall consider obdd 
surprising syntax sentence mods immediately recover sentence models 
languages discussed far depicted arrows denote set inclusion 
table lists acronyms languages descriptions 
table lists key language properties discussed section short description 

succinctness compiled theories discussed dozen subsets nnf language 
subsets known studied extensively computer science literature 
dnnf darwiche dnnf darwiche relatively new 
question subset adopt particular application 
argue depends knowledge compilation map acronym description nnf negation normal form dnnf decomposable negation normal form nnf deterministic negation normal form nnf smooth negation normal form nnf flat negation normal form dnnf deterministic decomposable negation normal form sd dnnf smooth deterministic decomposable negation normal form bdd binary decision diagram fbdd free binary decision diagram obdd ordered binary decision diagram obdd ordered binary decision diagram order dnf disjunctive normal form cnf conjunctive normal form pi prime implicates ip prime implicants mods models table language acronyms 
property short description flatness height nnf simple disjunction disjunction clause literals share variables simple conjunction conjunction term literals share variables decomposability conjuncts share variables determinism disjuncts logically disjoint smoothness disjuncts mention set variables decision node form true false variable decision nodes ordering decision variables appear order path nnf table language properties 
darwiche marquis key properties language succinctness class tractable queries supports class tractable transformations admits 
goal sections construct map place di erent subsets nnf language criteria 
map serve guide system designers choosing target compilation language suitable application 
provides example paradigm studying evaluating target compilation languages 
start study succinctness section kautz papadimitriou selman 
definition succinctness subsets nnf 
succinct denoted exists polynomial sentence exists equivalent sentence 
sizes respectively 
stress require exists function computes polytime require exists 
proofs appendix contain specific algorithms computing certain cases 
relation clearly reflexive transitive pre ordering 
define relation proposition results table hold 
occurrence cell row column table means fragment row succinct fragment column occurrence means succinct provided polynomial hierarchy collapse case 
presence question mark reflects ignorance succinct summarizes results proposition terms directed acyclic graph 
classical result knowledge compilation states possible compile propositional formula data structure entail set clauses clausal entailment decided time polynomial size np poly selman kautz cadoli donini 
assumption implies collapse polynomial hierarchy second level karp lipton considered 
classical result knowledge compilation proofs proposition explains parts conditioned polynomial hierarchy collapsing 
excluded subsets bdd nnf nnf nnf table qualify target compilation languages see section 
kept nnf cnf importance 
consider depicts table graphically 
exception nnf cnf languages depicted qualify target compilation languages 
exception language pi dnnf succinct target compilation languages know pi succinct dnnf know dnnf succinct pi 
dnnf mods succinctness ordering target compilation languages dnnf dnnf fbdd obdd obdd mods 
dnnf obtained imposing decomposability nnf dnnf adding determinism fbdd adding decision obdd obdd adding ordering total ordering ps case specific second case 
adding properties reduces language succinctness assuming polynomial hierarchy collapse 
important fact stress adding smoothness dnnf ect succinctness sd dnnf dnnf languages equally succinct 
interesting compare 
general notion space ciency model preservation reductions exists cadoli donini schaerf need full generality 
knowledge compilation map nnf dnnf dnnf sd dnnf fbdd obdd obdd dnf cnf pi ip mods nnf dnnf dnnf sd dnnf fbdd obdd obdd dnf cnf pi ip mods table succinctness target compilation languages 
means result holds polynomial hierarchy collapses 
nnf dnnf cnf dnnf dnf pi fbdd obdd ip mods sd dnnf obdd edge indicates strictly succinct indicates equally succinct dotted arrows indicate unknown relationships instance dotted arrow dnnf pi means know dnnf succinct pi 
edges conditioned polynomial hierarchy collapsing see table 
sd dnnf succinct influential fbdd obdd obdd languages mods tractable language 
sd dnnf mods smooth deterministic decomposable 
mods flat obtains decomposability stronger condition simple conjunction 
sd dnnf viewed result relaxing mods flatness simple conjunction conditions maintaining decomposability determinism smoothness 
relaxing conditions moves language levels succinctness hierarchy compromises polytime test sentential entailment possibly equivalence show section 
darwiche marquis 
querying compiled theory evaluating suitability target compilation language particular application succinctness language balanced set queries transformations supports polytime 
consider section number queries returns valuable information propositional theory identify target compilation languages provide polytime algorithms answering queries 
restrict attention existence polytime algorithms answering queries algorithms 
interested reader referred darwiche bryant algorithms proofs theorems appendix :10.1.1.1.5124
queries consider tests consistency validity implicates clausal entailment implicants equivalence sentential entailment 
consider counting enumerating theory models see table 
consider computing probability propositional sentence assuming variables probabilistically independent 
subsets consider done polytime models counted polytime 
denotes subset language nnf 
definition va satisfies va exists polytime algorithm maps formula consistent valid 
main applications compiling theory enhance ciency answering clausal entailment queries definition ce satisfies ce exists polytime algorithm maps formula clause nnf holds 
key application clausal entailment testing equivalence 
specifically suppose design expressed set clauses specification expressed set clauses want test design specification equivalent 
compiling targets support polytime clausal entailment test test equivalence polytime 
equivalent number target compilation languages shall consider support direct polytime equivalent test definition eq se satisfies eq se exists polytime algorithm maps pair formulas holds 
note sentential entailment se stronger clausal entailment equivalence 
language satisfies se satisfies ce eq 
completeness consider dual ce definition im satisfies im exists polytime algorithm maps formula term nnf holds 
consider counting enumerating models definition ct satisfies ct exists polytime algorithm maps formula nonnegative integer represents number models binary notation 
definition satisfies exists polynomial algorithm outputs models arbitrary formula time size number models variables occurring 
knowledge compilation map notation query polytime consistency check va polytime validity check ce polytime clausal entailment check im polytime implicant check eq polytime equivalence check se polytime sentential entailment check ct polytime model counting polytime model enumeration table notations queries 
va ce im eq se ct nnf dnnf nnf nnf nnf dnnf sd dnnf bdd fbdd obdd obdd dnf cnf pi ip mods table subsets nnf language corresponding polytime queries 
means satisfies means satisfy np 
table summarizes queries interested acronyms 
proposition states know availability polytime algorithms answering queries respect languages introduced section 
proposition results table hold 
results proposition summarized 
draw number results 
nnf nnf nnf nnf bdd fall equivalence class support polytime queries cnf satisfies va im qualifies target compilation language case 
remaining languages support polytime tests consistency clausal entailment 
simply imposing smoothness nnf determinism nnf flatness nnf decision bdd nnf language lead tractability respect queries consider properties significant isolation 
decomposability dnnf exception leads immediately polytime tests consistency clausal entailment polytime algorithm model enumeration 
darwiche marquis recall succinctness ordering dnnf dnnf fbdd obdd obdd mods 
adding decomposability dnnf obtain polytime tests consistency clausal entailment addition polytime model enumeration algorithm 
adding determinism decomposability dnnf obtain polytime tests validity implicant model counting quite significant 
clear combination decomposability determinism leads polytime test equivalence 
adding decision property top decomposability determinism fbdd appear increase tractability respect queries lead reducing language succinctness shown 
hand adding ordering property top decomposability determinism decision leads polytime tests equivalence obdd obdd sentential entailment provided ordering fixed obdd 
succinctness ordering nnf dnnf dnf ip mods note dnnf obtained imposing decomposability nnf dnf obtained imposing flatness simple conjunction stronger decomposability 
interesting dnf succinct dnnf support polytime queries see 
addition smoothness determinism top flatness simple conjunction mods leads additional polytime queries including equivalence entailment tests 
close section noting determinism appears necessary su cient polytime model counting deterministic languages dnnf sd dnnf fbdd obdd obdd mods support polytime counting 
polytime counting implies polytime test validity opposite true 

transforming compiled theory query operation returns information theory changing 
transformation hand operation returns modified theory operated queries 
applications require combination transformations queries 
definition subset nnf 
satisfies exists polytime algorithm maps finite set formulas 
formula logically equivalent 


definition subset nnf 
satisfies exists polytime algorithm maps formula formula logically equivalent 
language satisfies properties say closed corresponding operator 
closure logical connectives important key reasons 
implications compilers constructed target language 
example clause easily compiled language closure conjunction implies compiling cnf sentence easy 
second implications class polytime queries supported target language language satisfies closed negation conjunction satisfy se test refutation theorem test inconsistent 
similarly language satisfies va closed negation disjunction satisfy se deduction theorem 

deciding equivalence sentences fbdd dnnf sd dnnf easily shown conp 
proof conp hardness deterministic polytime algorithms deciding problems 
case quite equivalence problem fbdd intensively studied algorithm sight 
note equivalence sentences fbdd decided probabilistically polytime blum chandra wegman similarly sentences dnnf darwiche huang 

flatness simple conjunction smoothness obtain determinism simply removing duplicated terms 
knowledge compilation map important stress languages closed logical operator number operands bounded constant 
refer bounded closure 
definition bc bc subset nnf 
satisfies bc bc exists polytime algorithm maps pair formulas formula logically equivalent 
turn important transformation definition conditioning darwiche propositional formula consistent term :10.1.1.33.965
conditioning noted formula obtained replacing variable true resp 
false resp 
positive resp 
negative literal 
definition cd subset nnf 
satisfies cd exists polytime algorithm maps formula consistent term formula logically equivalent 
conditioning number applications corresponds restriction literature boolean functions 
main application conditioning due theorem says consistent consistent darwiche 
language satisfies cd satisfy ce 
conditioning plays key role building compilers enforce decomposability 
sentences decomposable belong dnnf conjunction necessarily decomposable sentences may share variables 
conditioning ensure decomposability case equivalent term covering variables shared note decomposable mention variables 
previous proposition generalization multiple variables known shannon expansion literature boolean functions 
basis compiling cnf dnnf darwiche :10.1.1.33.965:10.1.1.33.965
critical transformation shall consider forgetting referred marginalization elimination middle terms boole definition forgetting propositional formula subset variables ps 
forgetting denoted formula mention variable formula mention variable precisely 
forget variables remove maintaining information captures complement note unique logical equivalence 
definition fo sfo subset nnf 
satisfies fo exists polytime algorithm maps formula subset variables ps formula equivalent 
property holds singleton say satisfies sfo 
forgetting important transformation allows focus project theory set variables 
example know variables appear entailment queries forget variables compiled theory maintaining ability answer queries correctly 
application forgetting counting enumerating instantiations variables consistent theory 
query answered counting enumerating models complement forgetting applications planning diagnosis belief revision 
instance satplan framework darwiche marquis notation transformation cd polytime conditioning fo polytime forgetting sfo polytime singleton forgetting polytime conjunction bc polytime bounded conjunction polytime disjunction bc polytime bounded disjunction polytime negation table notations transformations 
cd fo sfo bc bc nnf dnnf nnf nnf nnf 
dnnf sd dnnf bdd fbdd obdd obdd 
dnf cnf pi 
ip 
mods 
table subsets nnf language polytime transformations 
means satisfies means satisfy means satisfy np compiling away fluents actions amounts forgetting variables 
model diagnosis compiling away variable abnormality ones remove piece information required compute conflicts diagnoses system darwiche 
forgetting design update operators valuable properties 
table summarizes transformations interested acronyms 
proposition states know tractability transformations respect identified target compilation languages 
proposition results table hold 
draw number observations regarding table 
languages consider satisfy cd lend cient application conditioning transformation 
forgetting multiple variables dnnf dnf pi mods permit polytime 
important stress fbdd obdd obdd permits polytime forgetting multiple variables 
noticeable applications obdd planning called symbolic model checking approach planning traverso depend crucially knowledge compilation map operation forgetting may suitable language satisfies fo case 
note obdd obdd allow forgetting single variable polytime fbdd allow 
dnnf similar fbdd satisfies fo sfo 
interesting observe target compilation languages closed conjunction 
number closed bounded conjunction including obdd dnf ip mods 
disjunction target compilation languages closed disjunction dnnf dnf 
obdd pi languages closed bounded disjunction 
dnnf fbdd obdd languages closed 
target compilation languages closed negation fbdd obdd obdd known dnnf sd dnnf closed operation 
note dnnf fbdd support set polytime queries equivalence checking unknown indistinguishable viewpoint 
di erence languages table closure fbdd negation significant light closure conjunction disjunction 
note dnnf succinct fbdd 
obdd target compilation language closed negation bounded conjunction bounded disjunction 
closure plays important role compiling propositional theories obdd basis state art compilers purpose bryant :10.1.1.1.5124

main contribution methodology analyzing propositional compilation approaches key dimensions succinctness target compilation language class queries transformations supports polytime 
second main contribution comprehensive analysis proposed methodology dozen languages produced knowledge compilation map cross ranks languages succinctness polytime queries transformations support 
map allows system designers informed decisions target compilation language class queries transformations decided application interest designer chooses succinct target compilation language supports operations polytime 
key contribution uniform treatment applied diverse target compilation languages showing subsets nnf language 
specifically identified number simple meaningful properties including decomposability determinism decision flatness showed combinations properties give rise di erent target compilation languages 
studied subsets include known languages pi influential ai obdd influential formal verification cnf dnf quite influential computer science 
subsets include relatively new languages dnnf dnnf appear represent interesting new balances language succinctness query transformation tractability 
acknowledgments revised extended version perspective knowledge compilation proceedings th international joint conference artificial intelligence ijcai pp 

wish alvaro del val mark hopkins jerome lang anonymous reviewers suggestions comments ingo wegener help issues discussed 
done second author visiting researcher computer science department ucla 
author partly darwiche marquis supported nsf iis muri 
second author partly supported iut de lens universite nord pas de region tact tic project european community feder program 
appendix proofs simplify proofs main propositions identified number lemmas list 
proofs lemmas direct include completeness 
lemma sentence dnnf translated equivalent sentence sd dnnf polytime 
proof 
node dnnf sentence 
suppose smooth vars 
consider sentence obtained replacing node vars 
equivalent smooth 
computed time polynomial size satisfies decomposability determinism 
lemma sentence fbdd translated equivalent sentence fbdd nnf polytime 
proof sentence fbdd node 
replace variable preserving equivalence decision property 
long variable appear ancestor decomposability preserved resulting sentence fbdd 
note ancestor respect binary decision diagram notation see left 
suppose node 
suppose node smooth 
appears vars vars way 
decomposable ancestor case ancestor impossible decomposability 
replace preserving equivalence decision decomposability 
repeating process smooth preserving necessary properties 
note node need repeat process vars vars vars vars times 
smoothing operation performed polytime 
lemma subset nnf satisfies cd satisfies proof sentence test inconsistent done polytime 
return empty set models 
construct decision tree representation models 
ordering variables 
vars start tree consisting single root node 
repeat leaf node corresponds consistent term consistent add child consistent add child 
key points test test performed time polynomial size satisfies cd 
knowledge compilation map test test succeed consistent 
number tests performed mn number leaf nodes final decision tree bounded number models number variables 
lemma subset nnf satisfies cd satisfies ce 
proof test sentence entails non valid clause su ces test inconsistent darwiche 
lemma sentences share variables 
valid valid valid 
proof valid inconsistent 
share variables inconsistent inconsistent true valid valid 
lemma sentence dnnf clause 
sentence dnnf equivalent constructed polytime size 
proof 
literals appear clause 
equivalent clause dnnf constructed polytime size 
term equivalent 
equivalent 
sentence dnnf constructed polytime size 
lemma subset nnf satisfies va cd satisfies im 
proof test consistent term entails sentence su ces test valid 
sentence equivalent 
share variables disjunction valid valid valid lemma 
valid consistent 
constructed polytime language satisfies cd validity tested polytime language satisfies va lemma cnf dnf formula translated equivalent sentence bdd polytime 
proof straightforward convert clause term equivalent sentence bdd 
order generate bdd sentence corresponding conjunction resp 
disjunction bdd sentences su cient replace sink resp 
sink root 
lemma subset nnf satisfies eq satisfies va proof true false belong nnf subset 
inconsistent equivalent false 
valid equivalent true 
lemma subset nnf satisfies se satisfies eq va proof sentences equivalent eq implies va lemma 
darwiche marquis lemma sentence dnnf clause 
validity tested time polynomial size 
proof construct polytime lemma check validity done polytime 
lemma propositional formula consistent term equivalent vars 
proof loss generality assume disjunctively interpreted set models vars 
conditioning leads removing model projecting remaining models variable removed 
conjoining leads exactly forgetting variable resulting formula leads exactly lang marquis 
lemma sentence nnf converted equivalent sentence polynomial time cnf dnf 
proof consider cases sentence 
root node node 
case turned cnf sentence polynomial time simply ensuring node clause disjunction literals share variables 
node 
flat root node child root children leaves 
easily ensure clause follows edge leaf edge valid replace edge root edge root true 
edge leaf node keep edges delete rest 

root node 
turned dnf sentence dual way 

root leaf node 
cnf sentence 
lemma prime implicant resp 
essential prime implicant sentence prime implicate resp 
essential prime implicate 
proof folklore result immediate definitions 
proof proposition proof proposition broken steps 
step prove number succinctness relationships di erent languages apply transitivity succinctness relation infer relationships 
associated step proof table knowledge compilation map nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table mark relationships proved step don show marks table 
table follows immediately language inclusions reported 
table prove dnf pi cnf ip slightly generalizes results dnf cnf cnf dnf 
consider cnf formula 
formula prime implicates form clause essential prime implicate 
negation prime implicants form easy consequence lemma 
quine early quine know number essential prime implicants resp 
prime implicates formula lower bound number terms resp 
clauses dnf resp 
cnf representation representation include essential prime 
essential prime implicants 
easily shown induction literal occurring occurs ii set prime implicants clause set literals occurring logical equivalence iii distribution property prime implicants see dual proposition marquis states ip max pi pi pi ip pi ip logical equivalence 
subsequently essential prime implicates cf 
lemma 
accordingly obtain dnf pi cnf ip 
obtain pi ip ip pi 
known dnf formulas exponentially prime implicants see proof proposition show ip satisfy sfo 
negations cnf 
note nnf satisfies negation cnf sentence resp 
dnf sentence turned dnf resp 
cnf linear time 

prime implicant resp 
prime implicate essential disjunction resp 
conjunction prime implicants resp 
prime implicates equivalent 

correctness dual quine consensus algorithm computing prime implicants quine ensures clause subsumed clause performed negated variables 
darwiche marquis nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table formulas having exponentially prime implicates 
subsequently ip dnf pi cnf 
remaining results table follow transitivity 
table parity function linear size obdd representations bryant exponential size cnf dnf representations :10.1.1.1.5124
reason essential prime implicants resp 
essential prime implicates number essential prime implicants resp 
essential prime implicates formula lower bound size dnf resp 
cnf representation 
easily shows cnf obdd dnf obdd 
remaining results table follow language inclusions reported 
table shown darwiche sentence dnnf exponential fbdd representations 
accordingly fbdd dnnf 
shown obdd fbdd 
easy show obdd obdd instance formula obdd representation size polynomial satisfies obdd representation size exponential provided 
remaining results table follow language inclusions reported 
table means polynomial hierarchy ph collapses 
results table follow existence knowledge compilation functions clausal entailment implies collapse polynomial hierarchy ph selman kautz cadoli donini 
dnnf cnf sentence cnf exists equivalent sentence dnnf 
test clause entailed polytime testing clause entailed 
proves existence knowledge compilation functions clausal entailment leading collapse polynomial hierarchy ph 
true dnnf sd dnnf languages support polytime clausal entailment test see proposition 
table wegener theorem pp 
family variable boolean functions pointed 
provided interpretation variables represents vertices digraph arc digraph knowledge compilation map nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table digraph represented contains clique special kind parameter family 
shown certain values depending fbdd representation exponential size 
shown cubic number prime implicants 
shows fbdd ip fbdd dnf 
fbdd satisfies see proposition case polynomial size fbdd 
cubic number prime implicates obtain fbdd pi fbdd cnf 
remaining results table follow fbdd obdd obdd table assume dnnf dnf holds 
consequence sentence dnf compiled equivalent dnnf sentence polynomial size 
checking clause entailed cnf sentence equivalent checking dnf sentence valid 
checking valid dnnf sentence clause achieved polynomial time lemma 
compilation 
sentence fbdd negated polytime yield sentence fbdd 
nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table darwiche marquis nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf nnf dnnf dnnf fbdd obdd obdd dnf cnf pi ip mods sd dnnf table cnf sentence allowing clausal entailment achieved polynomial time 
existence cnf sentence implies collapse polynomial hierarchy selman kautz cadoli donini 
obtain dnnf dnf 
consequence dnnf dnnf 
dnnf sentence turned polynomial time equivalent sd dnnf sentence lemma sd dnnf dnnf 
dnnf sd dnnf obtain sd dnnf dnf sd dnnf dnnf sd dnnf fbdd sd dnnf obdd sd dnnf obdd fbdd sd dnnf obdd sd dnnf dnf sd dnnf cnf sd dnnf pi sd dnnf ip sd dnnf 
table show mods succinct pi ip sd dnnf obdd 
consider formula represented pi ip sd dnnf obdd formulas size polynomial represented mods formula size polynomial models vars 
known old quine algorithm generating prime implicants mods representation propositional formula runs time polynomial number models wegener 
shows ip mods 
cnf obdd obvious decision tree shannon tree respects total ordering vars generated polynomial time mods representation 
decision tree leaves number models vars 
accordingly leaves vars 
set paths root tree leaf read cnf representation obtain cnf mods 
hand reducing decision tree derive corresponding obdd done polynomial time follows obdd representation generated mods representation 
obdd mods 
remaining results table follow language inclusions reported 
proof proposition proof proposition broken twelve steps 
step prove number results 
associated step proof table mark results proved step 
table step includes results declared proposition 
table classical cnf dnf formula translated straightforward way equivalent nnf sentence tree structure polytime 
nnf sentence translated equivalent nnf sentence polytime lemma 
np hard resp 
va conp hard classical cnf resp 
dnf sentences inclusion various nnf subsets reported obtain table 
table se implies va lemma 
ct implies va im implies va valid term ce implies inconsistent clause obtain table 
knowledge compilation map va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table darwiche marquis va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table table sentence consistent resp 
valid model resp 
models vars 
number models number edges outgoing node mods representation 
accordingly va ct achieved polynomial time mods formula gives table 
table dnnf satisfies ce darwiche ce implies mods dnf dnnf ip dnf sd dnnf dnnf dnnf obtain table 
table results cd imply ce lemma 
cd va imply im lemma 
cd imply lemma 
considered nnf subsets cd cf 
proposition 
nnf subset satisfy satisfy known fbdd satisfies va ct obdd satisfies addition eq bryant :10.1.1.119.326
holds inconsistent obdd satisfies bc cf 
proposition obdd satisfies se 
knowledge compilation map va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table obviously query concerning obdd equivalent corresponding query concerning obdd provided dag brought play 
results conclude obdd satisfies va ct fragment satisfies cd satisfies ce im addition 
satisfies eq see theorem theobald satisfy se np 
known checking consistency obdd formulas di erent variable orderings np complete lemma theobald 
obdd satisfies consistent checking sentential entailment obdd formulas conp complete 
results lead table 
table known im satisfied classical cnf formulas pi order check non valid clause implied consistent term su cient test share literal 
cnf pi known satisfy va obtain table 
table sentence cnf dnf turned equivalent sentence bdd polytime lemma 
cnf dnf cell implies corresponding bdd cell 
similarly bdd nnf bdd cell implies corresponding nnf cell 
leads table 
table eq implies va lemma va cell implies corresponding eq cell 
leads table 
table definition pi satisfies ce ip satisfies im 
pi cnf ip dnf implies pi ip satisfy se 
se implies eq pi ip satisfy eq equivalent formulas share prime implicates prime implicants forms canonical ones provided representative equivalence class considered darwiche marquis va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table knowledge compilation map va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table 
pi satisfies ce satisfies satisfies cd cf 
proposition satisfies lemma 
models counting problem monotone krom formulas conjunctions clauses containing literals positive literals complete roth :10.1.1.55.8139
formulas easily turned prime implicates form polynomial time marquis pi satisfy ct negation formula prime implicates form formula prime implicants form cf 
lemma number models vars vars minus number models vars necessarily ip satisfy ct imply ip satisfies va leading table 
table proof proposition shown prime implicants computed polytime mods representation 
immediate consequence ip satisfies im eq se obtain mods satisfies im eq se leading table 
table dnnf satisfies ct darwiche satisfies va satisfies cd proposition satisfies im lemma 
sd dnnf dnnf results follow sd dnnf 
obtain table 
table known determining conjunction fbdd formulas consistent np complete fbdd satisfies inconsistent reduce consistency test entailment test 
fbdd satisfy se 
fbdd dnnf dnnf satisfy se 
dnnf translated equivalent sd dnnf sentence polytime lemma sd dnnf satisfy se 
leads final table 
darwiche marquis va ce im eq ct se nnf dnnf nnf dnnf bdd fbdd obdd obdd dnf cnf pi ip mods nnf nnf sd dnnf table proof proposition proof proposition broken steps 
step corresponds transformations prove results pertaining transformation 
cd 
show language satisfies cd want show sentence consistent term construct polytime sentence belongs equivalent 
nnf nnf cnf dnf 
property trivially satisfied languages belongs languages replacing literals boolean constant results sentence language 
case dnf resp 
cnf inconsistent terms valid clauses may result conditioning removed easily polynomial time 
dnnf 
su cient prove conditioning preserves decomposability 
propositional sentences consistent term share variables share variables vars vars vars vars 
nnf dnnf 
nnf dnnf satisfy cd su cient prove conditioning preserves determinism propositional formulas consistent term false false 
false term false 
implies false 
consistent share variable case inconsistent 
equivalent state false 
nnf sd dnnf 
nnf satisfies cd conditioning preserves decomposability determinism show conditioning preserves smoothness 
follows immediately propositional sentences consistent term vars vars vars vars 
bdd fbdd obdd obdd known bdd satisfies cd conditioning operation binary decision diagrams known restrict operation bryant :10.1.1.1.5124
condition sentence bdd consistent term replace node labeled variable children sign variable 
resulting sentence bdd equivalent 
applies fbdd obdd obdd pi 
prime implicates computed polytime prime implicates form term see proposition marquis 
knowledge compilation map pi satisfies fo see prime implicates vars computed polytime 
exactly prime implicates lemma 
ip 
formula prime implicants form 
clear formula dnf formula equivalent 
claim formula obtained keeping logically weakest terms prime implicants formula equivalent 
removing terms clearly truth preserving 
generating requires entailment tests terms tests easily achieved polynomial time obtain ip satisfies cd 
prove prime implicants form 
pair di erent terms compared logical entailment correctness quine consensus algorithm generating prime implicants shows su cient prove consensus terms inconsistent entails term 
recall consensus dnf formulas resolution cnf formulas 
prime implicants form consensus terms inconsistent entails term 
happens terms prime implicants conditioned 
containing negation literal removed remaining ones shortened removing literal 
pair terms consensus consensus conditioning create new consensus 
remains prove unproductive consensus terms rendered productive conditioning 
formally prime implicates resp 
appear resp 

consensus assume survived conditioning means consistent 
especially belongs belongs 
accordingly consensus 
construction consensus equivalent equivalent 
inconsistent inconsistent done 
assume exists prime implicant holds 
necessarily preserved conditioning 
contain negation literal literal literal literal survived conditioning 
holds necessarily 
completes proof 
mods 
direct consequence lemma fact mods satisfies bc fo see 
fo 
dnnf dnf 
known dnnf satisfies fo darwiche 
known dnf satisfies fo lang 
nnf nnf nnf nnf bdd cnf 
sentence cnf 
show previous languages satisfies fo test consistency polytime 
cnf satisfy see proposition follows previous languages satisfy fo np 
note belong nnf nnf 
turned sentence bdd polytime lemma sentence nnf polytime see proof lemma 
turned sentence nnf polytime bdd nnf 
suppose previous languages call satisfy fo 
test consistency polytime follows convert sentence polytime shown 
compute vars done polytime assumption 
darwiche marquis test validity vars done polytime sentence contains variables check sentence evaluates true 
note definition forgetting implies sentence consistent vars valid completes proof 
dnnf sd dnnf 
follows immediately languages satisfies sfo np see 
ip 
follows immediately ip satisfy sfo 
fbdd obdd obdd show fbdd resp 
obdd obdd satisfies fo sentence dnf exist equivalent sentence fbdd resp 
obdd obdd size polynomial size 
contradicts fact fbdd resp 
obdd obdd dnf see table 
dnf consisting terms convert terms equivalent fbdd resp 
obdd obdd sentences 
polytime 

set variables belong ps 
construct new set variables ps ps 

case obdd obdd assume new variables earlier variables ps ordering 
consider sentence 
respect variables ps inductively defined 

clearly fbdd resp 
obdd obdd sentence equivalent computed time polynomial input size 

fbdd resp 
obdd obdd satisfies fo convert dnf sentence equivalent fbdd resp 
obdd obdd size polynomial size dnf 
impossible general 
pi 
known prime implicates exactly prime implicates contain variable see proposition marquis 
prime implicates computed time polynomial input size prime implicates form 
mods 
mods formula subset ps formula obtained removing leaf node corresponding incoming edges labeled literal mods representation easy consequence propositions lang 
see polytime operation forgetting dnnf defined darwiche applies mods mods dnnf easily modified guarantees output mods input mods 
sfo 
dnnf dnf pi mods 
immediate fact languages satisfies fo see 
nnf nnf nnf nnf bdd obdd cnf 
direct fact holds fact fragments satisfies cd bc 
obdd 
direct fact obdd sentence considered transformation obdd satisfies sfo 
dnnf sd dnnf fbdd 
fbdd formulas 
variable included vars vars 
formula fbdd knowledge compilation map formula decomposability decision preserved construction 
equivalent fbdd satisfy sfo satisfy bc case np see 
drawn dnnf 
fbdd dnnf satisfy sfo np 
dnnf formula turned polynomial time equivalent sd dnnf formula obtain sd dnnf satisfy sfo np 
ip 
show number prime implicants exponentially greater number prime implicants 
dnf formula mk primes implicants chandra markowsky 
formula 
obtained removing term occurrence equivalent see lang 
mk prime implicants term prime implicant converse holds term maximal logical entailment consensus terms inconsistent 
completes proof 
nnf nnf nnf cnf 
property trivially satisfied languages determinism smoothness concerned nodes 

belong languages 
bdd 
known conjunction bdds easily computed connecting sink root see proof lemma 
size resulting bdd just sum sizes respective bdds 
accordingly repeat operation times time polynomial input size 
nnf 
direct fact nnf satisfy bc 
fbdd obdd obdd dnf pi ip 
straightforward convert clause equivalent formula languages polynomial time 
proof proposition show specific cnf formulas turned equivalent fbdd resp 
obdd obdd dnf pi ip formulas polynomial space see tables 
conversion accomplished polynomial time 
implies fbdd obdd obdd dnf pi ip satisfies dnnf dnnf sd dnnf 
direct fact languages satisfy bc np 
mods 
models vars 
models mods representation size polynomial input size 
bc 
darwiche marquis nnf nnf nnf bdd cnf 
immediate languages satisfy see 
dnnf dnnf sd dnnf fbdd obdd 
checking conjunction obdd formulas di erent variable orderings np complete see lemma theobald 
obdd satisfies satisfy bc np 
obdd fbdd dnnf dnnf dnnf dnnf satisfy satisfy bc np 
dnnf formula turned polynomial time equivalent smoothed dnnf formula sd dnnf satisfies case sd dnnf satisfy bc np 
obdd known fact bryant :10.1.1.1.5124
nnf 
cnf formula dnf formula 
essential prime implicants essential prime implicates see proof proposition table 
duality essential prime implicants essential prime implicates 
nnf formulas 
lemma know nnf formula turned polynomial time cnf formula dnf formula 
nnf satisfy bc nnf formula computed time polynomial input size 
cnf formula equivalent dnf formula equivalent computed polytime 
impossible essential prime implicates essential prime implicants 
cnf resp 
dnf formula equivalent size exponential 
note case nnf formulas consideration turned polynomial time cnf formulas dnf formulas nnf formula equivalent computed time polynomial input size obvious cnf formulas considered item proof shows achieved dnf formulas considered 
dnf mods 
sentences languages construct sentence equivalent simply conjunctions term term removing redundant literals resulting terms removing inconsistent terms result 
disjunction resulting terms sentence equivalent computed polynomial time 
pi 

sentence prime implicate prime implicates 
prime implicates chandra markowsky 
ip 
ip set prime implicants 
ip max ip ip logical equivalence 
see dual proposition marquis 
knowledge compilation map nnf nnf dnnf dnf 
property trivially satisfied languages decomposability concerned nodes nnf formula turned polynomial time equivalent smoothed nnf formula 
nnf bdd 
direct consequence fact nnf bdd satisfies especially known disjunction bdds easily computed connecting sink root see proof lemma 
size resulting bdd just sum sizes respective bdds 
accordingly repeat operation times time polynomial input size 
nnf 
nnf satisfy satisfies satisfy due de morgan laws 
fbdd obdd obdd cnf pi ip mods 
straightforward convert term equivalent formula previous languages polynomial time 
proof proposition show specific dnf formulas turned equivalent fbdd resp 
obdd obdd cnf pi ip mods formulas polynomial space see tables 
conversion accomplished polynomial time 
implies fbdd obdd obdd cnf pi ip mods satisfies dnnf sd dnnf 
immediate form fact classes satisfies bc np see 
bc 
nnf nnf dnnf nnf bdd dnf 
immediate languages satisfies obdd known fact bryant :10.1.1.1.5124
obdd fbdd dnnf sd dnnf 
checking conjunction obdd formulas di erent variable orderings np complete see lemma theobald 
inconsistent valid 
obdd satisfies obdd formula equivalent resp 
computed time polynomial resp 

obdd fbdd dnnf resulting formulas fbdd dnnf formulas 
obdd resp 
fbdd dnnf satisfy bc obdd resp 
fbdd dnnf formula equivalent computed time polynomial 
dnnf satisfies va impossible np 
dnnf formula turned polynomial time equivalent sd dnnf formula sd dnnf satisfy bc np 
nnf 
nnf satisfy bc satisfies satisfy bc due de morgan laws 
cnf 
cnf sentences construct cnf sentence equivalent simply disjunctions clause clause removing redundant literals inside resulting clauses removing valid clause result 
conjunction resulting clauses cnf sentence equivalent computed polynomial time 
pi 
pi set prime implicates sentence 
pi min pi pi 
see proposition marquis 
darwiche marquis ip 

sentence prime implicant prime implicants 
prime implicants chandra markowsky 
mods 
sentence model vars model vars 
models vars vars 
nnf nnf nnf bdd fbdd obdd obdd property obviously satisfied nnf 
nnf satisfies nnf formula turned polynomial time equivalent nnf formula 
nnf satisfies applying de morgan laws nnf formula results nnf formula 
forms bdds su cient switch labels sinks achieve negation bryant :10.1.1.1.5124
cnf 
negation dnf formula cnf formula computed polynomial time cnf satisfy possible turn dnf formula equivalent cnf formula polynomial time involution negation 
know possible polynomial space cnf dnf see proof proposition 
cnf satisfy dnf 
dual proof just just replace cnf dnf vice versa 
pi 
formula prime implicates form see proof proposition table 
formula exponentially prime implicants just negations prime implicates exponentially prime implicates case pi satisfies ip 
just take dual proof prime implicates case 
formula prime implicants form 
formula exponentially prime implicates just negations prime implicants exponentially prime implicants case ip satisfies dnnf 
negation cnf formula computed polynomial time dnf formula dnnf formula 
dnnf satisfy possible turn cnf formula equivalent dnnf involution negation 
dnnf satisfies np 
nnf 
procedure negating nnf sentence traverse nodes dag visiting children node visit node 
visiting node construct negation follows true negation false 
false negation true 

negation 

node representing negation 
negation 

node representing negation node representing conjunction 
return negation root nnf 
implement steps visit node children construct nodes edges 
procedure complexity 
mark hopkins pointed procedure 

assume node resp 
node children removed replaced unique child false resp 
true children 
simplification process equivalence preserving achieved time linear size input dag 
knowledge compilation map linear size original nnf 
easy check result equivalent negation nnf sentence nnf 
sd dnnf dnnf 
unknown 
mods 
model negation models 
mods satisfy giunchiglia traverso 

planning model checking decision procedure ar 
proceedings th european conference planning ecp pp 

blum chandra wegman 

equivalence free boolean graphs decided probabilistically polynomial time 
information processing letters 
boole 

investigation laws thought 
walton london 
marquis sas 

tractable cover compilations 
proc 
th international joint conference artificial intelligence ijcai pp 
nagoya 
bryant 

graph algorithms boolean function manipulation 
ieee transactions computers 
bryant 

symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys 
cadoli donini 

survey knowledge compilation 
ai communications 
printed 
cadoli donini schaerf 

comparing space ciency propositional knowledge representation formalisms 
proc 
rd international conference knowledge representation reasoning kr pp 

chandra markowsky 

number prime implicants 
discrete mathematics 
darwiche 

compiling knowledge decomposable negation normal form 
proceedings international joint conference artificial intelligence ijcai pp 

morgan kaufmann california 
darwiche 

decomposable negation normal form 
journal acm 
darwiche 

tractability counting theory models application belief revision truth maintenance 
journal applied non classical logics 
darwiche huang 

testing equivalence probabilistically 
tech 
rep computer science department ucla los angeles ca 
de kleer 

improved incremental algorithm generating prime implicates 
proc 
th national conference artificial intelligence aaai pp 
san jose california 
dechter rish 

directional resolution davis putnam procedure revisited 
proceedings fourth international conference principles knowledge representation reasoning kr pp 
bonn 
del val 

tractable databases propositional unit resolution complete compilation 
proceedings international conference principles knowledge representation reasoning kr pp 

morgan kaufmann publishers san mateo california 
darwiche marquis 

cient analysis manipulation obdds extended 
ieee transactions computers 


complexity analysis manipulation boolean functions terms decision diagrams 
information processing letters 
kautz papadimitriou selman 

comparative linguistics knowledge representation 
proc 
th international joint conference artificial intelligence ijcai pp 
montreal 


propositional belief base update minimal change 
artificial intelligence 
karp lipton 

connections non uniform uniform complexity classes 
proc 
th acm symposium theory computing stoc pp 

khardon roth 

learning reason 
journal acm 
lang marquis 

propositional independence part formula variable independence forgetting 
submitted 
madre coudert 

new method compute prime essential prime implicants boolean functions 
advanced research vlsi parallel systems proceedings brown mit conference pp 

marquis 

consequence finding algorithms vol 
handbook defeasible reasoning uncertainty management systems algorithms uncertain defeasible reasoning 
kluwer academic publishers 
marquis 

knowledge compilation theory prime implicates 
proc 
international joint conference artificial intelligence ijcai pp 

morgan kaufmann publishers san mateo california 
theobald 

algorithms data structures vlsi design obdd foundations applications 
springer 
papadimitriou 

computational complexity 
addison wesley 
quine 

way simplify truth functions 
american mathematical monthly 
quine 

cores prime implicants truth functions 
american mathematical monthly 
reiter de kleer 

foundations assumption truth maintenance systems preliminary report 
proceedings fifth national conference artificial intelligence aaai pp 

roth 

hardness approximate reasoning 
artificial intelligence 
schrag 

compilation critically constrained knowledge bases 
proc 
th national conference artificial intelligence aaai pp 
portland 
selman kautz 

knowledge compilation theory approximation 
journal association computing machinery 
simon del val 

cient consequence finding 
proc 
th international joint conference artificial intelligence ijcai pp 
seattle wa 
wegener 

complexity boolean functions 
wiley teubner stuttgart 

