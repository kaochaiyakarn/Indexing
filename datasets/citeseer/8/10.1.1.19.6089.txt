combinators layered software architectures martijn schrage johan jeuring doaitse swierstra institute information computing sciences utrecht university technical report uu cs www cs uu nl combinators layered software architectures martijn schrage johan jeuring doaitse swierstra july define domain specific embedded language haskell describe layered software architectures editors 
typed programming language describe architecture type correctness components guaranteed type checker language 
furthermore architecture description system part implementation system implementation comply architecture 
functional programming language haskell give domain specific embedded language describing layered editor architectures 
term editor broad sense 
text editors html editors known examples spread sheets mail agents preferences screens applications graphical user interfaces regarded editors 
haskell functional language strong support abstraction 
describing architecture actual programming language possible verify types components architecture provides framework implementing system described architecture 
haskell architecture program system instantiated providing implementations components 
survey architecture description languages adls medvidovic taylor identify essential components architecture description description interface components description connectors description architectural configuration 
claim focus conceptual architecture explicit treatment connectors class entities differentiate adl programming languages 
higher order typed hot functional programming languages haskell clean ml offer describing main components architecture treating components class entities 
furthermore abstraction description architecture focused conceptual architecture details left actual components 
higher order typed functional languages offer excellent possibilities embedding domain specific languages 
embedding domain specific language facilitates reuse syntax semantics implementation code software tools look feel 
give haskell describing layered editor architectures 
records contain functions describe components architecture 
connectors combinators configurations programs functions consist combinators components 
requirements describing architectures slightly different requirements familiar applications parsers pretty printers write programs contain applications combinators usually subject frequent change 
architecture description hand typically small static entity changes architecture involve changes components system 
consequence concise syntax combinator expressions highest importance 
difference concerns efficiency combinators 
ordinary programs constructed typically contain applications combinators evaluation combinators forms substantial part running time 
contrast combinators architecture description glue connects main components system 
running time system expected taken components combinators 
efficiency combinators major concern 
wrapping unwrapping values combinators problem improves transparency architecture 
give implementation models layered architectures 
introduce simple example layered editor architecture explore main components modeled haskell 
proceed connect components 
section connection straightforward little abstraction 
section basis develop combinator implementation uses nested cartesian products 
section set combinators employ form state hiding improve previous set 
section develops small generic library building architecture specific combinators section 
section contains short description architecture editor combinators designed section presents 
simple editor section introduce simple layered architecture editor sections illustrate architecture description methods 
system doc upd translate doc upd translate doc pres gest pres gest pres cycles edit process 
upd translate described architecture editor user edit presentation document 
architecture editor simple contains typical features layered architectures discussed 
edit process main loop simple editor consists phases gest 
compute rendering presentation document presentation phase 
show presentation user 
receive edit gesture user 
translate edit gesture document update translation phase 
compute updated document contains schematic representation edit process 
boxes represents complete edit cycle 
emphasis put presentation translation phases phases 
phases represented dotted arrows bottom phase represented dotted arrows top 
layers shows detailed view single edit cycle 
focus presentation translation phases phase phase 
presentation translation functions call translate compositions number subfunctions similar layered editor 
presentation document computed number intermediate data structures increasingly concrete edit operation document computed edit operations intermediate data structures 
subfunctions translate grouped pairwise horizontal layers 
reason grouping subfunctions subfunction layer parameters result subfunction immediately left 
refer subfunctions layer functions 
doc upd translate translate pres gest layered edit cycle 
look see values go left right values go 
values go horizontal direction computed functions corresponding layer necessarily edit cycle 
vertical direction parameter layer function hand result function neighboring layer layer function gets vertical parameter function translate layer function gets translate function 
composing layers vertical results layer passed parameters layer 
outermost vertical parameter parameter combined layer outermost vertical result result combined layer 
single layer shows data flow single layer 
somewhat complex horizontal parameters translate results 
state result 
data flow simplification data flow layered editor local state 
maps high level data structure doc low level data structure pres 
state parameter contains state local layer described 
translate function works opposite direction maps edit operation gest pres data structure edit operation upd doc data structure 
pres returns value mapping 
encode information required translate order map gest upd 
example information table pointing information relates objects pres origin doc 
gest may edit operation local state translate state parameter 
case state result performing update local state 
case state equal state 
doc upd state mapping translate layer haskell pres gest single layer 
state sections explore possibilities implementing layered architecture described previous section functional language haskell 
typed programming language describing architecture ensures types components correct 
furthermore architecture description language equal implementation language architecture description executable framework system described 
certainty types architecture description correct types implementation correct 
hand separate architecture description language architecture implemented programming language type checked proven correct 
extra translation step possibly lead errors 
aspects modeling layered architecture haskell building blocks layer functions connections building blocks 
layer functions simply modeled haskell functions put record model layer 
connecting layer functions complicated 
alternatives sections give precise types layer functions 
order clearly distinguish horizontal vertical parameters write type layer function form 
see layer function takes ore horizontal arguments single vertical argument returns single vertical result tupled ore horizontal results 
introduce type synonym layer functions type 
type layer record contains layer functions translate 
types layer functions follow directly 
attempt definition simple 
names type selector functions contain introduce slightly different type simple rest 
data simple state mapping doc pres gest upd simple state doc mapping pres translate mapping state gest state upd strictly speaking simple type type constructor inconvenient supply type parameters time type mentioned denote type constructor remainder text 
formally refering type type constructor parameters mean type fresh type variables ai field names record translate names field selection functions 
layer simple value layer denotes function layer 
simple type parameterized types appear signatures layer functions 
simplify horizontal connection layer functions prefer data type horizontal result type rd type parameter layer function matches horizontal argument type st type parameter layer function 
implies horizontal result type horizontal argument translate horizontal result translate type horizontal argument 
shows data flow layer functions new type simple data simple state mapping doc pres gest upd simple state doc mapping state pres translate mapping state gest state upd section type simple 
simple 
conversions types trivial give 
reason give simple appropriate type component programmer view 
contains exactly function types expect components simple returns state parameter done connecting easier 
building blocks established need way connect 
show connection methods 
explicitly connect parameters results hand working transparent solution 
subsequently introduce elegant methods 
methods specific simple simple data types method derive small library layers arbitrary number layer functions 
state doc mapping state mapping state upd translate pres gest data flow layer 
state method explicitly connecting components components editor modeled layers get working implementation need realize data flow connecting components 
document fed layers starting top layer yielding presentation bottom similarly edit gesture fed bottom layer yielding document update top 
layers records contain functions straightforward way tying explicitly write selection application functions layers 
show giving example edit loop editor consists layers layer layer layer type simple 
data flow layer functions shown 
corresponding haskell code edit loop layer layer layer states doc loop states doc loop state state state doc phase compute presentation mapping pres layer state doc mapping pres layer state pres mapping pres layer state pres pres phase gest phase phase compute document update state gest translate layer mapping state gest state gest translate layer mapping state gest state update translate layer mapping state gest doc update doc phase loop state state state doc doc update state mapping translate pres layer gest state mapping translate pres layer gest state mapping translate layer pres gest data flow layers 
state state state phases simple edit cycle previous section directly visible code 
note translate selector functions layer denotes function layer 
functions left unspecified want focus connection layer functions 
function main calls correct parameters 
main layer layer layer states doc layer layer layer states doc functions provide initial values states doc left unspecified 
layers editor arguments main function 
editor instantiated applying function main simple values implement different layers 
type system verifies implemented layer functions correct type signatures 
disadvantage implementation edit loop sketched section patterns data flow transparent 
fact mapping parameters horizontal parameters presentation vertical parameter immediately clear program code 
patterns upward downward vertical parameters standard explicitly application increasing chance errors decreasing transparency 
number layers hard coded implementation 
system extended extra layer variables renamed 
type appearing layers distinct type checker catches mistakes parameters results type type checker detect problem example equally typed variables swapped 
try find way connecting layers 
method nested cartesian products section create abstraction horizontal vertical data flow patterns edit loop previous section 
number combinators allow compose layers having give applications layer functions layers call layer function composed layer 
main loop previous section implies translate phase written function application 
combinators data flow explicit 
direction vertical parameter apparent choice combinator way argument threaded function applications case previous section 

fn 
horizontal parameters nested cartesian products 
similar way function composition operator compose functions develop combine combinator takes layers returns combined layer 
layer functions combined layer compositions layer functions layers combined 
method described section functions combined layer takes vertical argument returns vertical result takes collection horizontal arguments layer returns collection horizontal results layer 
composition combinator takes care distributing horizontal arguments corresponding layers collects horizontal results 
combined layer provides layer functions type 
parameters stand types collections horizontal parameters results 
sketches data flow combined layer 
layer function downward vertical parameter shown 
types horizontal parameters typically collections represented lists 
restriction holds horizontal results 
want able determine compile time collection contains right number elements 
tuple cartesian product suitable task disadvantage components accessed compositional way 
nested cartesian product consisting tuples represent horizontal parameters results 
example nested cartesian product containing elements valid examples 
nested cartesian products equal type structure elements equal positions equal types 
access elements product compositional way pattern matching top level product 
example rest 
nested cartesian products different structure different type combinators section right associative way products form en 
define combinators composing layer functions 
need combinators ways layer functions composed depending direction vertical parameter 
upward vertical parameter passes bottom layer top layer downward vertical parameter passes top layer 
combinators 
shows data flow combinators 
combinator composes layers feeding intermediate vertical result establishing downward data flow 
time horizontal parameters taken horizontal parameter combined layer tuple horizontal result combined layer formed tupling horizontal results arg res arg res upper lower arg upper arg res lower res similar way define combinator combining layer functions translate vertical parameter goes upward 
show type 
res arg arg res combining layers define combinator combine simple layers 
type simple simple matching horizontal parameter types simple connection easier 
need define new data type combined layers 
composition layer functions layer function put compositions layer functions simple record 
definition simple horizontal parameter layer function type state result type mapping state 
contrast composed layer horizontal parameter arg res res arg res arg res arg collection states result collection mapping state tuples 
specify collection types type signature simply single type variables types 
type general version simple specify exact structure horizontal parameters 
parameter states represents nested cartesian product state values parameter represents nested cartesian product mapping state tuples 
data states doc pres gest upd states doc pres gest states upd trivial function lift takes layer type simple returns layer 
lift simple lift simple simple translate simple combine combinator defined appropriate compose combinator layer functions 
combine combine upper lower upper lower upper lower simple editor main editor loop previous section reads layers states doc loop states doc loop states doc compute presentation pres layers states doc pres gest compute document update update states layers gest doc update doc loop states doc main function previous section tuple layers combined layers passed 
main layer layer layer state state state doc layers lift layer combine lift layer combine lift layer layers state state state doc nested cartesian products solution compositional approach previous section lot data flow hidden main loop automatically passing results layer 
horizontal parameters passed way composite layer visible main loop conceptually belong 
consequently type composite layer parameterized types appearing layers leading huge type signatures 
show approach horizontal parameters stay layer visible main editor loop 
method direct parameter passing previous section horizontal results computed evaluation layer function returned explicitly passed arguments layer function 
layer functions developed section horizontal results returned explicitly 
layer function returned horizontal results applied 
consequence main editor loop transparent type composed layers simpler type variables horizontal parameters longer explicitly visible 
illustrate direct parameter passing method example 
recall main loop simple editor encoded nested cartesian products method contains code 
pres layers states doc 
states update translate layers gest 
direct parameter passing method contain 
pres doc 
update gest 
words combined layer function application returns result combined layer function 
horizontal parameters completely hidden main loop 
code shown entirely accurate turns pattern matching required gives general idea 
note order layer functions evaluated enforced layer model 
possible evaluate 
type definitions type layer needs structure doc pres gest upd doc pres gest upd 
unfortunately type declaration type layer doc pres gest upd layer haskell allow recursive type synonyms 
newtype declaration disadvantage values type wrapped constructor functions 
encode type dividing computation steps step layer function 
number steps equal number layer functions statement layer layer functions amounts step layer 
term number layer functions layer number steps layer 
step define separate type 
types mutually recursive 
types vertical parameters may different layer step types parameterized types vertical parameters 
simple layer type get newtype presstep doc pres gest upd presstep doc pres transstep gest upd doc pres newtype transstep gest upd doc pres transstep gest upd presstep doc pres gest upd type layer doc pres gest upd presstep doc pres gest upd section give definition step types 
definitions clearly show mutually recursive structure types 
separate type layer functions possible newtype declaration encapsulates layer functions newtype layer doc pres gest upd layer doc pres gest upd layer doc pres gest upd prefer mutually recursive types symmetric single layer type 
values wrapped constructors unwrapped 
wrapping unwrapping occurs step case mutually recursive types edit cycle case single type encapsulating layer functions 
doing step leads elegant combinators 
define combinators constructing combining layer values 
combinator lift takes simple layer record layer functions converts direct parameter passing layer type layer 
combine layers type layer define combinator combine 
combinators section specific simple type 
section define library construct lift combine arbitrary layers 
lift combinator lift takes layer type simple returns layer value lift simple state mapping doc pres gest upd state layer doc pres gest upd lift layer state presstep state presstep state presstep doc mapping state pres layer state doc pres transstep mapping state transstep mapping state transstep gest state upd translate layer mapping state gest upd presstep state layer parameter lift gets second parameter state initial value horizontal state parameter layer 
data flow pattern horizontal parameters encoded entirely definition lift 
state type visible result lift horizontal state passed lifted layer longer visible outside layer lift combinator takes care passing horizontal parameters layer functions edit cycle 
state hiding helps keep architecture description transparent horizontal parameters play le anymore layers connected 
combine lift instantiate layer values type layer doc pres gest upd 
combine layers define combinator combine type combine layer high med layer med low layer high low order parameters type combine bit odd 
reason order type pair parameters specifies argument type second type specifies result type 
composed pres function created applying pres function layer high med high argument applying pres function second layer med low result 
trans function different direction trans function second layer applied argument trans function layer applied result 
implementation combine just plumbing get parameters right places 
direction vertical parameters encoded definition combine 
pres direction downward function upper layer applied trans upward function lower layer applied 
combine layer high med layer med low layer high low combine presstep presstep presstep upr presstep lwr presstep high med upr high low lwr med low transstep transstep transstep upr transstep lwr transstep lwr upr presstep simple editor edit loop simple editor longer horizontal parameters 
furthermore combined layer called layers reflect step computation 
doc pres transstep doc pres gesture update presstep gesture doc update doc doc main function combined layer created lifting layers initial states combine put 
main layer layer layer state state state doc presstep lift layer state combine lift layer state combine lift layer state doc direct parameter passing model hides data flow horizontal parameters main loop system 
furthermore types horizontal parameters intermediate vertical parameters hidden type composed layer similar way type intermediate result composition functions hidden type composition result horizontal vertical data flow transparent 
developing library architecture descriptions section develop small meta combinator library implementing direct parameter passing lift combine combinators layered architectures arbitrary number layer functions 
combinators library meta combinators build lift combine combinators 
combinators previous section just case layered architecture layer layer functions steps 
lift combine straightforward write code duplicated small errors easily 
general description writing lift combine hand better small library meta combinators building 
advantage meta combinator library direction vertical data flow expressed meta combinator name reflects direction explicitly encoding direction steps combine function 
sections analyze data type definitions required layer arbitrary number layer functions 
derive meta combinators lift combine 
looking definitions lift combine previous section see consist parts step layer 
functions define local function layer functions layer 
lift combine simple layer type local functions called presstep transstep 
method derivation meta combinators start local function gradually factorize step specific aspects 
process left function applied step specific aspects behaviour local function started 
function step specific anymore get behaviour step functions 
function meta combinator build instances combinator architectures arbitrary numbers steps 
lift local function similar steps combine variations exist depending direction vertical parameter 
consequently meta combinator derived lift combine get meta combinators steps upward parameters steps downward parameters 
type definitions order extend direct parameter passing method layers arbitrary number steps investigate data types step 
turns possible give general type definition haskell step definitions layers arbitrary numbers steps 
reason number type variables depends number steps 
give simple method defining data types number steps layer 
take step data types simple section rename variables get newtype step step step newtype step step step pattern righthand side captured type synonym step individual step types somewhat simpler type step furthermore write data type definitions records order get selector function type 
selector functions definition combine 
newtype step step step step step newtype step step step step step layer layer functions steps need mutually recursive step data types 
step parameters 
newtype step step step step newtype step step step step newtype step step step step written simpler type step newtype step step step step step newtype step step step step step newtype step step step step step clearly type definitions step layers similar type definitions step layers 
number parameters type depends number steps possible give haskell type synonym step 
settle general description construct type synonym 
layer layer functions type parameters 
parameters named rn reflect pair parameters ai vertical argument second ri vertical result type step rn rn individual step data types defined newtype step rn step step step step rn newtype step rn step step step step rn 
newtype rn step step rn general step type synonym possible implementor construct appropriate step type definition step data types 
language dependent types cayenne general type step defined 
derivation lift develop meta combinator lift function 
code lift layers steps 
code section variables renamed emphasize data flow patterns meaning individual steps 
local functions presstep transstep renamed step step 
furthermore presstep state renamed mapping state renamed 
similarly transstep mapping state renamed state renamed 
vertical parameters results local functions renamed 
derivation affect type rename type variables 
resulting function show purpose clear original clear data flow local functions similar 
lift simple state mapping doc pres gest upd state layer doc pres gest upd lift simple state step state step presstep simple step step transstep translate simple step definitions local functions step step contain mutually recursive 
take mutual recursion definitions supplying step parameter function 
drop state param step gets step param 
step step 
infinite definition lift simple step step step observation lift simple step correct parameters pass lift simple parameter step yielding finite definition lift simple state step step lift simple state step presstep simple step transstep translate simple turn elegant definition steps 
drop state parameter lefthand righthand sides line rewrite function application composition get lift simple step step lift simple result lift layer function step step applied result combinator fix fix capture recursion pattern yielding lift simple fix step step step presstep simple step transstep translate simple applications constructors presstep transstep layer functions translate local functions equal 
eliminate constructors layer functions passing parameters pack local functions 
step step function give function new name meta combinator building lift functions 
new definition lift definition local function anymore 
final version meta combinator 
section define type class contains pack function final get pack parameter slightly different type type constraint 
lift simple state mapping doc pres gest upd state layer doc pres gest upd lift simple fix presstep simple transstep translate simple varg vres nstep step varg vres nstep step pack pack works layers arbitrary numbers steps definition depend number steps layer derivation starts definition lift layers layer functions 
case steps local step functions containing contains function 
perform steps step lift step lift 
sketch process 
renaming variables explicit recursion removed local function definitions passing step parameter lift look lift layer state step step 
lift layer state 
written composition lift layer step lift layer 
fix capture recursion lift layer fix step 
constructor layer functions passed parameters local step functions calls local functions calls 
assume constructors layer functions final definition lift lift layer fix step layer 
layer create lift combinator layer arbitrary number layer functions 
derivation combine derivation meta combinators combine largely similar derivation lift 
start original definition combine layers steps see section renamed variables 
local functions renamed step step 
renamed 
names vertical parameters results presstep low med high appropriate transstep renamed low med high 
combine layer high med layer med low layer high low combine step step presstep upr presstep lwr presstep high med upr high low lwr med low step step transstep upr transstep lwr transstep low med lwr low high upr med high step explicit mutual recursion local functions removed passing step parameter 
combine step step combine step nextstep presstep upr presstep lwr presstep high med upr high low lwr med low nextstep step nextstep transstep upr transstep lwr transstep low med lwr low high upr med high nextstep analogously lift fix combinator explicit recursion 
combine fix step step step nextstep presstep upr presstep lwr presstep high med upr high low lwr med low nextstep step nextstep transstep upr transstep lwr transstep low med lwr low high upr med high nextstep constructors local functions appear righthand side patterns lefthand side straightforward factorize constructors definition 
righthand side occurrences pass constructor argument pack local function similar done lift 
constructors appear lefthand side local functions 
parameter pattern matching pass selector function unpack 
pattern matching unpack function unpack arguments local functions 
unfortunately selector function arguments different types haskell allows monomorphic applications function arguments 
universally quantified type quantify parameters types number parameters determined 
selector function passed twice 
unpack functions unpack upr lwr parameters 
constructor pack function unpack functions put tuple 
section show elegant approach uses type class pack unpack functions 
assume selector functions presstep transstep defined declaring presstep transstep types records method shown section 
combine fix step presstep presstep presstep step transstep transstep transstep step pack nextstep upr lwr pack high med upr high low lwr med low nextstep step pack nextstep upr lwr pack low med lwr low high upr med high nextstep case lift step functions directions vertical parameters step step different 
meta combinator get 
step specific information factorized functions arbitrary steps 
combine layer high med layer med low layer high low combine fix presstep presstep presstep transstep transstep transstep pack nextstep upr lwr pack high med upr high low lwr med low nextstep pack nextstep upr lwr pack low med lwr low high upr med high nextstep meta combinators depend number steps build combine layers arbitrary number layer functions 
type class pack unpack previous subsections define meta combinators functions lift combine 
explicit constructor appearances removed meta combinators functions function argument packing result combine function arguments unpack layer arguments 
unpack function layer arguments passed twice function arguments different type 
section construct type class pack contains pack unpack functions step data types 
type class eliminates need explicitly passing pack unpack functions meta combinators 
consequently unpack function need passed twice anymore 
take look types pack unpack parameters meta combinators 
types pack unpack functions structure combinators matter meta combinator look exception unpack parameter 
take look pack nextstep upr lwr pack 
type pack 
result function step type presstep transstep simple case argument function tuple step value 
rename parameters type pack general arg res nstep step 
unpack function look structure unpack functions 
type 
function takes step value returns function type tuple step type 
analogously pack rename type variables unpack step arg res nstep 
shot type class pack unpack class pack step arg res nstep pack arg res nstep step unpack step arg res nstep definition complete 
order see look new type pack pack pack type ambiguous type variables appear constraint actual type function 
type inference algorithm determine values types application 
problem arises combine step meta combinators type variables constraint appear type 
resolve ambiguity adding functional dependency step arg res step arg res class declaration 
meta combinators build lift combine combinators constraints types meta combinators consequences types combinators 
precisely combinator definition meta combinator applied step layer step constraints appear type combinators 
types combinators refer intermediate steps types ambiguous 
example look type lift simple lift pack step doc pres nstep pack nstep gest upd step simple state mapping doc pres gest upd state step pack constraints refer nstep occur type function 
ambiguity types resolved adding functional dependency type class definition stating step uniquely determined current step step nstep 
final functional dependency step arg res nstep 
straightforward see functional dependencies hold 
instances pack form type constructor step type nextstep 
instance pack 
nextstep 
dependency states types nextstep uniquely determined 
true appear 
furthermore step unique step step type variables step type nextstep determined 
instances pack conflict functional dependency 
class definition class pack step arg res nstep step arg res nstep pack arg res nstep step unpack step arg res nstep type class meta combinators change slightly 
show changes definition 
meta combinators undergo similar changes shown section 
function loses tuple parameter pack unpack functions replaced unpack 
addition type constraint added type 
pack pack pack nextstep upr lwr pack high med unpack upr high low unpack lwr med low nextstep type constraint see type class approach solves double unpack parameter problem 
pack constraints type 
state parameter types instances pack constraint states result type instance pack 
see constraints arise unpack upr lwr arguments types constraint comes pack 
implementation means dictionaries passed occurrences unpack come different dictionaries 
words type system takes care passing double unpack functions 
type class small drawback 
due monomorphism restriction haskell allows function overloaded type defined parameters lefthand side definition 

xn 

xn 
explicit type signature 
due type class inferred types lift combine overloaded 
combine parameters lefthand side definition needs rewritten needs type signature 
type combine complex order parameters depends direction layer functions inconvenient give type signature 
type signature architecture source desired compiler asked type pasted source 
eliminate need explicit type signature combine explicitly add upper lower layer parameters definition 
simple combine combine upper lower fix upper lower general description construction combine section 
fix fix class pack step arg res nstep step arg res nstep pack arg res nstep step unpack step arg res nstep pack step varg vres nstep varg vres nstep step pack pack pack pack nextstep upr lwr pack high med unpack upr high low unpack lwr med low nextstep pack pack pack nextstep upr lwr pack low med unpack lwr low high unpack upr med high nextstep final meta combinators lift combine final library contains final definitions meta combinators pack type class fix combinator 
order describe implement architecture number definitions necessary depend number layer functions included library 
give general description definitions 
general general case consider layered architecture layers layer functions 
record type contains layer functions 
type number type variables 
hi variables types appear horizontal parameters layer ai ri types vertical arguments result 
horizontal type variables need equal types horizontal parameters layer 
see example type simple 
horizontal type variables mapping state horizontal parameters layer state mapping state 
result number horizontal type variables necessarily equal number layer functions types horizontal arguments results types denoted 
data hm rn 



rn define step type synonym captures explicit function type rotation parameters subsequent data definitions type step rn rn step mutually recursive data definitions steps straightforward 
definition contains definition contains step step 
note write type definition haskell record syntax define selector functions 
newtype step rn step step step step rn newtype step rn step step step step rn 
newtype rn step step step rn type synonym layer introduced type step type layer step types instances pack instance declarations form instance rn rn pack unpack thing left define lift combine combinators 
lift combinator need apply layer functions compose steps apply fix composition 
lift hm rn layer rn lift fix 
combine combinator composition meta combinators fix applied 
choice layer function determined direction vertical data flow layer 
note upper lower arguments added monomorphism restriction 
type combine general definition explained 
combine layer 
layer 
layer combine upper lower fix 
upper lower general type definition combine order type variables depends direction layer functions 
pair type variables ai ri layer ai ri types arguments result dependency 
th layer function downward layer 
layer 
layer 
layer function upward layer 
layer 
layer 
computing type hand compiler asked type pasted source 
concludes definitions necessary able describe architecture 
simple editor example application library give definitions required implementing simple editor architecture 
recall data type containing layer functions data simple state mapping doc pres gest upd simple state doc mapping state pres translate mapping state gest state upd simple editor layer contains layer functions need define step data types corresponding pack unpack functions 
define step type synonym step data types 
layer layer functions number type variables 
type step newtype presstep doc pres gest upd presstep presstep step transstep doc pres gest upd newtype transstep gest upd doc pres transstep transstep step presstep gest upd doc pres pair steps instance pack instance pack presstep transstep pack presstep unpack presstep instance pack transstep presstep pack transstep unpack transstep definitions lift combine trivial lift simple fix simple translate simple combine fix definitions main functions section reproduced 
simplicity definitions lift combine combinators leads question possible define generic lift combine combinators type class contains step specific aspects 
eliminate need explicitly define combinators 
sufficient define step data types instances type class 
possible define type class turns te useful 
generic combinator takes argument certain step type contains recursive call step type 
recursive call type constraint step document evaluation layer enriched document presentation layer presentation arrangement layer arrangement rendering layer rendering layers example instance wrap hold step 
recursive call generates constraint step constraint hold step step 
result type combinator explicitly give type constraints step types 
means type combinator depends number steps want encode number steps library 
simpler approach constructing lift combine explicitly 
meta combinator library advantages direct parameter passing solution section time easier describe specific architecture 
meta combinators data flow clearer reduces chance errors specification 
editor motivation haskell describe editor architectures come project 
generic incremental xml editor developed utrecht university 
editor parameterized presentation sheet specifies document 
furthermore parameterized computation sheet specifies derived values chapter numbers table contents 
user see edit final presentation document 
mapping document presentation stepwise process translation edit commands presentation updates document layered architecture 
schematically shows layers 
shows layers sur rounded rectangles data values arise process mapping document presentation 
edit actions incremental updates shown 
document top architecture mapped rendering bottom shown user 
evaluator takes document computation sheet produces enriched document document derived values 
similarly presenter takes enriched document presentation sheet computes presentation 
point presentation contain absolute layout elements presentation positioned relative absolute size 
absolute coordinates computed 
maps presentation arrangement absolute positioning elements presentation 
takes care hyphenation line page breaking 
arrangement rendered bitmap renderer 
prototype editor implemented architecture combinators previous section 
module contains architecture description actual part implementation prototype 
combinators possible specify layered editor architectures concise transparent way 
small number definitions layered architecture described 
combinators tested actual architecture heap profiled ensure memory leaks 
furthermore architecture description language embedded implementation language architecture system forms part implementation system 
translations adl implementation language required implementation guaranteed comply architecture 
combinator language tailored specific kind architectures layered editors 
term editor broad sense including spreadsheets mail agents research explore possibilities haskell describe kinds architectures 
area research concerns dynamic aspects architecture constraints invariants data described possible verified 
augustsson 
cayenne language dependent types 
proceedings icfp acm sigplan notices 
pp 

hudak 
modular domain specific languages tools 
international conference software reuse mark jones 
type classes functional dependencies 
proceedings th european symposium programming sop number lncs berlin germany march 
springer verlag 
medvidovic taylor 
classification comparison framework software architecture description languages 
ieee transactions software engineering 

peyton jones hughes 
haskell non strict purely functional language 
february 
www haskell org schrage jeuring swierstra meertens 
layered software architectures editors preparation schrage jeuring swierstra meertens 
generic incremental xml editor 
www cs uu nl research projects 
