approach fast arrays haskell preliminary version manuel chakravarty gabriele keller university new south wales school computer science engineering sydney australia cse unsw edu au array centric algorithms computational science engineering especially dynamic irregular data structures coded elegantly purely functional style 
challenge compared imperative array languages performance 
lecture notes discuss shortcomings haskell standard arrays respect alternative approach decouples array list processing program transformation generic programming 
particular array library type analysis achieve unboxing attening data structures equational array fusion array combinators compiler driven rewrite rules 
range advanced language extensions haskell multi parameter type classes functional dependencies rewrite rules unboxed values locally state computations 
motivation start simple dot product vectors 
haskell standard array library de ne function nicely type vector array int float 
vector vector float 
sum indices unfortunately elegance comes considerable price 
graphs running time dependence length input vectors 
gures running code ghz gnu linux compiled elements ms 
running time ms computing dot product haskell ghc optimisation level 
elements code needs vector element slow ghz machine 
suspicion easily veri ed timing corresponding function float float float int int float sum sum return sum runs approximately times faster 
remainder lecture notes rstly look reasons huge performance di erence secondly propose slightly di erent approach array programming avoids inherent standard haskell approach thirdly discuss optimising implementation scheme new form array programs 
particular presentation includes detailed treatment array library type analysis aka generic programming achieve unboxing attening data structures 
library optimises array traversals way ghc rewrite rules 
come 
haskell code dot product slow 
section study increasingly sophisticated functions arrays demonstrate shortcomings haskell standard arrays 
vector dot product lists slow looking expression sum indices properties stand operations involved list operations create super uous intermediate structure list produced list comprehension consumed sum 
suspicion properties main culprits easily veri ed measuring running time explicitly wad version dot product 
loop loop acc acc loop acc snd bounds optimisation leads dramatic improvement explicit loop factor faster original haskell code 
hand news means optimise quite ectively haskell 
hand prefer compiler automatically perform conversion comprehension loop code 
summary lesson learnt studying dot product implementation clearly lists drive array computations highly detrimental performance 
story see discussion benchmark 
matrix vector multiplication boxing slow look slightly complicated function dot product matrix vector multiplication av ij convenient slow list interface arrays type matrix array int int float mvm matrix vector vector mvm sum snd bounds case dot product partially avoid intermediate lists explicit loop mvm 
precisely transform inner list comprehension application sum loop dot product easily remove outer list comprehension create result array haskell forces go list comprehension explicit inner loop accumulator size matrix ms 
running time ms matrix vector multiplication haskell list 
proves limiting mvm range square matrices graphs running time function mvm version displayed version inner list comprehension replaced explicit loop 
version explicit loop clearly superior signi cant factor dot product benchmark 
comparison running time corresponding function reveals list haskell code better optimising inner loop far sucient 
brief matrix code runs times faster comprehension haskell code times faster haskell code uses explicit loop inner list comprehension 
part derive parametricity haskell arrays representation regardless element type 
arrays primitive values integer oating point numbers boxed element representation 
ects performance negatively reasons code needs larger number memory accesses cache utilisation worse 
addition boxed arrays lazy increases number memory accesses reduces cache utilisation branch prediction harder cpu 
ghc libraries provide extended implementation standard array interface supports unboxed arrays basic types 
modify version mvm explicit loop unboxed arrays running time reduced approximately 
signi cant improvement factor performance code 
data constructor module data array unboxed ghc upward 
mvm runst ma newarray ma ma int float int st ma return ma loop ma loop acc acc loop acc 
optimised matrix vector multiplication st monad contributor remaining gap lack inlining critical function libraries ghc 
gain factor forcing inlining function 
replacing outer loop call state loop ghc mutable arrays provided st monad gain factor avoid list interface disable bounds checking haskell code st monad brings factor performance code 
news 
bad news resulting code displayed readable code 
summary infer soon new arrays constructed unboxed arrays preferred best performance 
combine stateful programming style array construction get performance expense code clarity 
sparse matrix vector multiplication nesting slow interestingly applications tricky handle plain code st monad unboxed arrays 
example application multiplication sparse matrix vector 
popular representation sparse matrices called compressed sparse row format der 
format represents sparse row array column index value pairs pair represents non zero element sparse matrix 
array sparse rows implements sparse matrix 
type array int int float column index value type array int see ghc interfaces data array data array st st monad contained pl 
example consider matrix compressed array representation numbers represent actual non zero values matrix highlighted array representation 
denote multiplication sparse matrix dense vector resulting dense vector follows haskell standard arrays smvm vector vector smvm sm vec bnds sum vec col col elems row products row row elems sm bnds bounds sm code nice lacking performance 
trouble clear unboxed arrays improve code 
ghc provides unboxed arrays primitive element types oating point integer numbers 
sparse matrix representation uses array pairs array arrays pairs 
straight forward idea represent array pairs pair arrays 
clear handle nested arrays eciently 
case dense matrices avoid array arrays choosing array dimensional index domain 
sparse matrices dicult nd ecient representation 
section see solve problem separating actual matrix elements structure dense matrix 
summary draw previous discussion rstly irregular nested array structures dicult represent eciently simple arrays secondly irregular nested structures hit limitations imperative languages 
irregular structures able provide serious advantage conventional array languages 
parallel arrays flattening transformation message far beauty performance 
hand standard haskell arrays combination list comprehensions list combinators enable elegant slow formulations array algorithms 
hand unboxed arrays st monad enable fast inelegant implementations 
rest lecture notes explore approach reconciling beauty performance simultaneously optimising nested structures needed represent sparse matrices 
optimal convenience set program transformations discussed automated compiler 
current implementation partial means transformations need performed manually 
alternative array notation discussion previous section prompts consider alternative array interface 
semantic point unboxed boxed arrays leads change 
arrays longer lazy parallel evaluation semantics elements computed soon needed 
call new form arrays parallel arrays 
want entirely avoid reliance list operations drop parametrisation index domain favour simple integer indexes 
assume type array int array comprehensions follows bnds elems quali ers treated similarly bnds depends size list produced list comprehension 
overview transformations implementation scheme describe key components 
code code transformed facilitates processing entire arrays sweep 
collective array operations enable compiler generate code similar structure loop code discuss transformation detail section 

structure attening saw previous section boxed arrays expensive 
need nd method transforms arrays structured types alternative representation unboxed arrays 
call representation transformation 
discuss basic ideas transformation section illustrate implementation technique example smvm 
fact arrays suited parallel implementation cover aspect lecture notes 
de nitions 
vn function de nition expressions constant variable 
en ary application local binding case selection 
grammar simple functional language 
array fusion avoid super uous intermediate structures improve cache performance consecutive array traversals amalgamated 
artifact previous transformation multitude simple array operations 
executing lead extremely poor cache behaviour large number intermediate structures 
array fusion discussed section 
addition need optimise special cases common operations better general transformation rules due knowledge algebraic properties functions 
lecture notes discuss treatment special cases detail illustrate basic ideas discussing implementation smvm 
code essential idea code lift code operates individual elements code process entire arrays bulk 
approach take introduced bs ck 
explain core idea example simple functional language way performed manually 
grammar language 
top level function de nitions array comprehensions multiple generators lter expression 
substituted zipp respectively 
partial applications local functions 
may restrictive simpli es presentation transformation signi cantly 
function occurs directly indirectly array comprehension need generate variant scheme expr original de nition lift expr version assume primitive operation versions provided 
example adds elements arrays pairwise lifting function essence means map array case function multiple arguments zip arguments map function result 
step replace array comprehension lifted version body expression comprehension bind array expression generator variable lift second argument lift list variables call context 
transformation function lift operates syntax oriented described 
constant values 
lifted expression lift consists constant value array generated length arrays names stored list variables passed second argument lift const replicatep const variables 
distinguish cases 
firstly variable may bound generator parameter function case name variable list leave secondly free body array comprehension treated constant value lift var vs var vs var replicatep var bindings 
lifting bindings straight forward 
interesting bit include variable name bound variable argument list 
lift vs lift vs lift vs function application 
distinguish cases depending function 
case replace function variant lift arguments 
case far interesting central idea attening transformation need look closely 
second pretend dealing list operations 
said earlier function mapping function array 
lifting function mapping mapped function 
know lists true function list xs concat map map xs map concat xs consider function segment extracts structure nested list applies structure second argument map length ys map length xs segment xs concat xs xs map length xs map length map map xs simplify equation segment xs concat map map xs segment xs map concat xs map map segment xs map concat xs implications problem 
function strip arguments nesting level apply function segment result lift 
vs lift vs 
lift vs 
lift vs caveat 
transformation introduces operations sure ecient 
see choosing appropriate representation nested array possible operations operate constant time 
conditionals 
lift conditional determine array element branch belongs pack arrays accordingly 
function bool returns ag array length argument array contains true position corresponds value type false positions array returns inverse array 
array values branches combined single array lift case vs lift vs ags ags lift ags vs lift ags vs ags sparse matrix vector multiplication rules transform smvm program ecient code 
notation sparse matrix vector multiplication looks follows type int float type type vector float smvm vector vector smvm sm vec snd cx vec fst cx cx row row sm start lifting inner array comprehension rst vec cx row array lift snd row vec fst row row lift snd row row lift vec fst row row application snd row lift vec row lift fst row row application variables free snd row replicatep vec row fst row successfully removed array comprehension functions 
serious problem code 
expression replicatep vec row produces element row complete copy vec de nitely want 
previously mentioned optimisation rules come play 
index operation lifted applied replicated source array replaced operation replicatep xs inds inds xs inds applying lifted operation replicated value simple replicatep xs inds inds inds xs inds rst rule allows simplify expression snd row vec fst row quite nished point remove outer array comprehension 
inner expression lifting expression introduce number operations 
abbreviate xs xs furthermore encounter followed immediately omit xs id lift snd sm vec fst sm sm applying second optimisation sm snd sm vec fst sm resulting code translated single nested loop unboxed arrays 
achieve compiler fuse permutation multiplication summation 
section details achieved 
array representation mentioned collection oriented array operations particular lifted operations executed eciently array structures 
attening transformation decomposes complex data structures structure information separated primitive data values stored structure 
exact rules transformation discussed section 
array unit type values represented simply length contain information 
representation arrays primitive types straight forward represent pair unboxed array primitive type length stored explicitly arrays pairs pairs arrays equal length 
arrays stored nested pair ag array indicating side sum array element belongs exactly ag array returns pair arrays containing actual values 
length arrays length original array ag array 
nested arrays represented array containing data array containing sizes subarrays 
called segment descriptor discussion code mentioned essential atten implemented linear complexity 
representation straight forward simply means drop case attach provided structural information traversing structure 
similarly necessary handling lifted case example look nested array pairs model sparse matrices represented 
notation type type int float type nested array represented pair consisting segment descriptor representation type fact segment descriptor contains eciency reasons information just lengths sub arrays sake simplicity assume simple array unboxed integers turn array pairs represented pair type int float 
matrix previously example correspond structure simpli ed segment descriptor position values subarray values non zero elements consists arrays primitive element type 
representation transformation parallel arrays performance array codes need minimise pointers arrays 
words possible want store unboxed data arrays 
quite straight forward arrays basic types involved arrays structured types including nested arrays 
consequence want choose concrete representation array dependence type elements 
parallel arrays polytypic type generic programming type constructor concrete representation depends type argument called type indexed type polytypic type 
choice representation type naturally ects implementation functions operating type 
functions concrete implementation depends type argument called type index functions polytypic functions 
way concepts generic programming achieves extra generality value type level 
harper morrisett hm implementing polymorphism way intensional type analysis realise type indexed types functions typecase construct type value expressions choose number alternatives basis type argument 
case type argument element type array 
hinze hin suggests alternative implementation scheme compile time specialisation polytypic functions types partly related dictionary passing implementation haskell type classes 
elimination pointers array elements constitutes representation transformation denote de ning array type 
type indexed type ck 
type indexed type inspects type index element type parallel array way typecase concrete representation dependent concrete structure type index 
unit int fint float unboxed primitive array sel 
polytypic de nition parallel arrays words usually regard parametric type constructors free functions types 
contrast typecase allows de ne type constructors implement sophisticated mapping 
polytypic de nitions usually include cases range elementary type constructors particular unit type basic types char int float binary products binary sums function space constructor case parallel array constructor 
needs considered nested arrays 
displays polytypic de nition parallel arrays selects concrete array representation dependence element type 
unit type constructors representing units products sums generic de nitions 
unit arrays simply represented length 
arrays pairs represented pairs arrays 
arrays sums get extra selector component sel determines element attened subarrays data resides 
nested arrays represented segment descriptor attened array 
polytypic types multi parameter type classes aiming implementation haskell question arises may implement representation transformation encoded polytypic array de nition haskell 
need de ne basic operations parallel arrays type indexed functions adapt behaviour representation type dependence type index 
heavy weight solution extend language typecase example done tilt compiler tmc implement compile time specialised polytypic functions types done generic haskell system cl 
cheney hinze ch demonstrated polytypic functions implemented haskell extended existential types encoding representation types value level type classes infer representation types user de ned data types 
exible general approach generic programming comes expense extra runtime costs presence existential types preempts central optimisations performed compiler ghc 
alternative implementation haskell ghc data generics module 
way slight language extension proposed hp 
proposal current form comes number limitations unsuitable purposes 
particular multi parameter type classes supported generic types kind 
pointed multi parameter type classes combination functional dependencies jon coerced implementing forms type indexed types 
generally approach limitations rstly works type constructors kinds secondly marshalling user de ned data types product sum representation polytypic de nitions manually coded instances 
rst restriction ect parallel arrays belong polytypic types de ned multi parameter type classes see subsection second restriction extent 
explore encoding type indexed data types way multi parameter type classes functional dependencies 
start discussing concrete type mapping needed implement parallel arrays 
look general approach overcome mentioned limitation encoding type indexed types type classes 
concrete implementation type mapping type indexed data types implemented binary type classes relate type index representation type 
words de ne type indexed type ti kind type index ti introduce type class class ti 
type class ti essentially denotes mapping types types encodes type dependent representation transformation 
mapping populated instance declarations class 
precisely de ning equation ti hti type indexed type de ne class instance instance ti elementary operations type indexed type ti bound type indexed functions implemented methods class ti scheme implement 
type class class parray arr arr arr parray arr bijection element types array representation type arr type elements 
general terms type index arr representation polytypic array type type index 
dependence representation type type array elements captured functional dependency arr scheme illustrated previously ti interestingly need establish functional dependency opposite direction arr serious implications generality de nition parray shall return reasons functional dependency implications subsection 
class declaration need representation types associate corresponding element types way instance declarations 
example unit values suces store length array values anyway newtype int length unit array instance parray unit instance declaration corresponds rst equation 
arrays products de ned follows data array pairs pair arrays instance parray parray barr parray barr represent arrays basic types need type unboxed arrays basic types 
assume existence type constructor may parametrised range basic types int denotes arrays unboxed integer values 
de ne case basic types newtype instance parray int int completing set required instances step back moment consider elementary operations need de ne class methods parray immutable versus mutable arrays seen section optimal performance array codes need implemented way mutable arrays st monad 
goal de ne parray array algorithms de ned terms parray inlining similar optimisations expand st monad code 
user level interface library purely functional 
may mutable arrays internally convert immutable arrays fully de ned returned user level code 
array producing operations proceed follows 
allocate mutable array sucient size 
uae int runst ma ll ma ma ll ma ll ll return ma ll 
typical mutable arrays de ne immutable array 
populate mutable array elements loop executes st monad 

coerce fully de ned mutable array immutable array 
provided immutable array altered anymore step coerce type copying array 
strategy implementing immutable mutable arrays discussed detail peyton jones launchbury pl 
constrain just example 
code de nes function produces unboxed array size elements initialised value 
understand details need look interface unboxed arrays 
de nes data type immutable unboxed arrays element type mutable unboxed arrays state type needed mutable structures st monad 
type constraint unboxed arrays contain basic types implemented type class uae stands unboxed array element 
immutable arrays basic operations uae int uae int obtain array length extract elements 
mutable arrays uae int uae int st uae int st uae int st create new arrays index update 
convert mutable immutable arrays type parr arr 
arr type arr 
arr class parray arr arr arr parr arr int yield length parallel array segmented number segments parr arr int extract element immutable parallel array parr arr int int parr arr extract slice immutable parallel array int st arr allocate mutable parallel array segmented arr int st update element mutable parallel array segmented arr int st parr arr convert mutable immutable parallel array 
de nition parallel array class uae int st second argument provides length immutable array 
may shorter length mutable array originally allocated 
generalising type mapping mutable arrays need handle mutable immutable arrays need rethink instance declarations parray provided section 
newtype instance parray proposed parray class restricted immutable arrays de ne structurally identical class including instance declarations mutable arrays 
elegant solution de nition parray instances type constructors base arrays 
words regard parray arr bijection element types array constructors arr 
array constructors get base array constructor kind 
argument produce concrete array representation 
introduces type synonyms parr simplify generalised array constructors 
contains complete class de nition parray including elementary functions class 
previous explanations base arrays functions self explanatory 
new function extracts subarray start index length immutable array 
instance declaration unit reads newtype ua 
int instance parray unit reasons uniformity parametrised base array type 
interesting case products data ua 
ua ua instance parray parray barr parray barr base array type passed component arrays 
case primitive arrays applies base array type 
instances provided types uae newtype ua 
ua instance parray char char instance parray int int segmented arrays outlined section represent nested arrays array plus extra structure segment descriptor encodes partitioning array subarrays 
concrete representation instance follows data arr ua 
ua arr ua instance parray arr parray parr arr arr adding embedding projection pairs encoding polytypic arrays type classes provide instances elementary type constructors products sums 
obviously sucient arrays user de ned data types despite earlier claim algebraic data types represented combination elementary type constructors 
fact situation worse previous de nition class parray impossible array representation isomorphic element types 
words represent unit way 
see consider functional dependencies class parray arr arr arr assert mapping element types array representation types 
element type needs distinct array representation 
tempting drop dependency arr obtain additional exibility 
unfortunately invalidates recursive instance de nitions parray left exercise explore problems arise dropping arr fortunately gain exibility di erent route 
idea regard element type parray merely representation type actual element type 
relate actual element type representation type type class de nes called embedding projection pair ep short pair functions map elements actual representation type back 
class ep actual type representation type 
note functional dependency actual concrete type 
implies actual type uniquely de ne representation type 
functional dependency opposite direction single representation type represent actual types 
particular simplest cases instance ep unit unit id id instance ep unit unit unit equipped ep parray wide range element types combining type classes ep parray arr may read actual element type represented representation types turn uniquely maps array representation arr words ep convert user level data types canonical representations product sum types 
arrays de ned canonical representation 
array fusion far discussed third transformation listed section 
array programs expressed means collective array combinators tendency produce intermediate arrays produced operation immediately consumed operation 
example version smvm section essentially constitutes stage pipeline array traversals 
stages implemented decomposition complex computations pipeline stages code readable limits performance 
intermediate arrays consume resources cache locality negatively ected 
ck introduce approach equational array fusion ghc rewrite rules pht :10.1.1.27.3139
revise basic ideas approach 
loops exists plethora array combinators attempt consider fusion possible pairs combinators lead unmanageable number transformation rules 
similar case list fusion deforestation need small set elementary combinators serve building blocks build foldr list case glp 
remains de ne fusion elementary combinators 
inlining takes care remaining combinators 
build foldr lists need array constructing array consuming function 
constructor replicatep parray arr int parr arr generates array length elements initialised value 
array consuming function involved 
foldr lists require function describe mapping operations reductions 
needs able deal running accumulator 
functionality integrated generalised loop combinator loopp parray arr parray arr acc 
acc mapping folding elements acc initial accumulator value parr arr consumed array 
parr arr acc versatility loopp clear considering implementation mapping reduction 
de nition gure demonstrates loopp implement complex generators combined replicatep particular combinator loopp replicatep may appear wasteful due intermediate array generated replicatep representation transformation section assigns arrays unit type concrete de nition 
unit arrays simply represented length array created replicatep unit represented plain number 
may regard loop counter loopp fusion rules denote rewrite rules follows namei exp 
exp mapp parray arr parray arr parr arr parr arr mapp fst loopp 
unit just unit parray arr parr arr snd loopp 
parray arr parr arr arr fst loopp 
just enum parray arr parr arr fst loopp 
succ just replicatep unit 
standard combinators terms loopp free variables rules 
rules read replace occurrence exp exp rst simplest fusion rule encodes optimisation strongly related discussion implementation discussed previous subsection 
transform occurence replicatep followed loopp modi ed loopp replicatep combination replicatep produces unit array ectively eliminates overhead intermediate array 
replicatep mf start loopp mf start replicatep 
loopp acc mf acc start replicatep unit fusion consecutive loops involved 
requires combine mutator function rst argument loopp 
achieved rule loopp mf start mf start arr loopp mf start loopp mf start arr 
mf acc acc case mf acc acc 
acc acc acc just case mf acc acc res 
acc acc res loopp mf start start arr accumulator combined loop maintains components original loops product sequences mutators 
function drops accumulator result corresponds rst loop 
arr acc acc 
arr acc arr acc acc arr acc rules needed handle loops separated zipp details see ck :10.1.1.27.3139
examples nal version lecture notes contain examples library including performance evaluations 
moment gures obtained previous version parray library ck :10.1.1.27.3139
related nal version lecture notes contain reading proper comparison approach existing techniques 
bs guy blelloch gary 
compiling collection oriented languages massively parallel computers 
journal parallel distributed computing 
ch james cheney ralf hinze 
poor man dynamics generics 
manuel chakravarty editor proceedings acm sigplan haskell workshop 
acm press 
ck manuel chakravarty gabriele keller 
types nested data parallel programming 
philip wadler editor proceedings fifth acm sigplan international conference functional programming icfp pages 
acm press 
ck manuel chakravarty gabriele keller :10.1.1.27.3139
functional array fusion 
xavier leroy editor proceedings sixth acm sigplan international conference functional programming icfp pages 
acm press 
cl dave clarke andres oh 
generic haskell speci cally 
proceedings ifip wg working conference generic programming 
der du reid 
direct methods sparse matrices 
oxford science publications 
glp andrew gill john launchbury simon peyton jones 
short cut deforestation 
arvind editor functional programming computer architecture pages 
acm 
hin ralf hinze 
generalizing generalized tries 
journal functional programming 
appear 
ralf hinze johan jeuring andres oh 
type indexed datatypes 
proceedings th mathematics program construction conference 
springer verlag 
hm robert harper greg morrisett 
compiling polymorphism intensional type analysis 
nd acm sigplan sigact symposium principles programming languages pages 
acm press 
hp ralf hinze simon peyton jones 
derivable type classes 
graham hutton editor proceedings acm sigplan haskell workshop volume electronic notes theoretical computer science 
elsevier science 
jon mark jones 
type classes functional dependencies 
proceedings th european symposium programming esop number lecture notes computer science 
springer verlag 
pht simon peyton jones tony hoare andrew tolmach 
playing rules rewriting practical optimisation technique 
proceedings acm sigplan haskell workshop 
pl simon peyton jones john launchbury 
state haskell 
lisp symbolic computation 
tmc tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
sigplan conference programming language design implementation 
wad wadler 
deforestation 
proceedings european symposium programming number lncs 
