exact aggregate solutions type markov processes introduce new methodology exact analysis type markov processes 
methodology uses basic known results markov chains exploiting structure repetitive portion chain recasting problem computation solution finite linear system 
methodology allows calculation aggregate probability finite set classes states state space appropriately defined 
allows computation set measures interest system queue length higher moments 
proposed methodology exact 
detailed experiments illustrate methodology numerically stable cases yield significantly expensive solutions compared methods shown detailed time space complexity analysis 
keywords type processes aggregation matrix analytic method markov chains 

decades considerable effort put development matrix analytic techniques exact analysis general frequently encountered class queuing models 
models embedded markov chains dimensional generalizations elementary gi queues intersection quasi birth death qbd processes 
gi queues model systems interarrival service times characterized respectively general distributions simple exponentials modeling tool choice modern computer communication systems 
consequence considerable effort placed development efficient methodologies analysis 
supported national science foundation eia ccr aci 
alma smirni department computer science college william mary williamsburg va mail cs wm edu class models analyzed type markov chains includes important class queues arrival process batch markovian arrival process 
special cases include phase type renewal processes erlang hyperexponential processes non renewal processes markov modulated poisson process mmpp 
importance lies ability effective powerful traffic models simple poisson process batch poisson process effectively capture dependence correlation salient characteristics internet traffic 
focus solving type markov chains 
defines various classes infinite state markov chains repetitive structure state space par boundary states sets states correspond repetitive portion chain 
class type markov chains infinitesimal generator qm upper block hessenberg form matrix analytic methods proposed solution 
key matrix analytic solution computation auxiliary matrix called traditional solution methodologies type processes compute stationary probability vector recursive function iterative algorithm determine 
distinctively classic techniques solving type processes recast problem solving finite linear system unknowns number states boundary portion process number states repetitive levels state space able obtain exact results 
proposed methodology uses basic known results markov chains 
assuming state space partitioned sets evaluating probability distribution states calculate aggregate probability distribution classes states appropriately defined see 
computation aggregate probability distribution classes exact 
furthermore aggregate probability distribution provide means calculating variety measures interest including expected queue length higher moments 
aggregation infinite finite number states 
contributions theoretical practical 
theoretical side propose new methodology solution type processes requires solution finite linear system equations 
system equations derived principles 
new methodology propose uses partially existing matrix analytic methodologies computation matrix distinct difference classic matrix analytic methodologies new approach simple steps computation stationary probability vector 
practical side methodology results significantly efficient solutions traditional methods 
detailed big complexity analysis proposed method best known methods illustrates superiority new methodology 
illustrate benefits providing detailed experimental comparisons best known methods set realistic examples 
additional important issue arises related numerical stability method 
system linear equations derive solve ill conditioned danger proposing method numerically unstable 
address issue conducted detailed experimental analysis 
experiments consistently provide strong indications method numerically stable 
presents new method exact analysis type processes 
stated goals outline outline matrix analytic methods solution type processes section new methodology detailed time storage complexity analysis solution type processes section experimentally compare efficiency best known methods set realistic examples see section conduct detailed experiments illustrate numerical stability methodology section summarize findings report proposed methodology efficiency section 
note approach spirit exact solution limited class qbd type markov chains distinct contrast works method require restriction form chain repeating pattern applied type chain 

background assume continuous time markov chains ctmcs refer infinitesimal generator discussion applies just discrete time markov chains 
defines various classes infinite state markov chains repetitive structure 
cases state space partitioned boundary states sets states stationary probability vectors states 
class type markov chains infinitesimal generator qm block partitioned qm 
letters describe local forward backward transition rates respectively relation set states matrices related solution type processes algorithms exist 
algorithms compute matrix solution equation lg 
matrix stochastic process recurrent irreducible important probabilistic interpretation entry ing expresses conditional probability process entering state starts state page matrix obtained solving iteratively eq 
advances show computation efficient displacement structures representation type processes means qbd processes 
efficient algorithm computation cyclic reduction algorithm 
calculation stationary probability vector recursive ramaswami formula numerically stable entails additions multiplications ramaswami formula defines recursive relation stationary probability vectors letting matrices defined follows probabilistic interpretation ctmcs 
subtractions type formulas possibility numerical instability 
definition normalization condition unique vector obtained solving system linear equations symbol indicates discard column corresponding matrix added column representing normalization condition 
known iteratively compute stopping accumulated probability mass close 
point measures interest computed 
relation straightforward computation measures interest requires generation stationary probability vector 
gives improved version ramaswami formula 
known eq stationary probability vector computed matrix generating functions associated triangular toeplitz matrices matrix generating functions computed efficiently fast fourier transforms fft 
outline algorithm follows zy pi 
matrices defined follows 


constant defines matrices computed 
representation matrix upper block triangular toeplitz matrix matrix lower block triangular toeplitz matrix 

aggregate introduce aggregated technique computes aggregated stationary probabilities classes states 
block partitioning infinitesimal generator shown eq defines block partitioning stationary probability vector 
toeplitz matrix equal elements diagonals facilitating special methods analysis 
ir ir 
rewrite matrix equality qm theorem 
ergodic ctmc infinitesimal generator qm having structure shown eq stationary probability vector 
system linear equations ir defined follows admits unique solution proof 
show solution eq verifying satisfies matrix equations corresponding sets columns define 
equation normalization constraint 
ii second set equations line eq 
iii third set equations derived second line eq solution compute explicitly rewrite expressed terms 
substituting equation obtain 
compute sum ramaswami recursive formula eq obtain 
matrices determined definitions eq 
definition matrix eq follows summing equations eq multiplying obtain sum results 
substituting eq eq obtain third set equations function 
iv set equations obtained summing remaining lines eq expressed function equation rewritten 
steps iv showed vector probabilities satisfies eqs 
solution eq 
show solution unique 
prove rank showing rows linearly independent 
process infinitesimal generator qm ergodic know vector set vectors corresponding columns qm linearly independent 
note multiplying block column infinitesimal generator qm matrix get block column linear combination columns selected block column 
proof multiplication block 

gi gi gi gi blocks column vectors prove linear independence 
columns powers matrix columns infinitesimal generator 
show blocks column vectors proof 
blocks labeled original block columns qm 
block obtained summing blocks obtained multiplying block columns th power matrix summing define matrix defined eq upper blocks argue rank matrix ism obtained respectively linear combination blocks blocks columns generate recall qm infinitesimal generator defect rank exactly 
substituting columns column obtain rank 
stress step solution type process computation matrix approach assume available computed efficient iterative method cyclic reduction algorithm explicitly obtained 
computing measures interest type processes consider problem obtaining stationary measures interest computed 
consider measures expressed expected reward rate reward rate state example compute expected queue length steady state represents system states customers queue compute second moment queue length solution approach obtains rewrite 
show compute summation explicitly values 
reward rate state polynomial degree arbitrary coefficients jk 
definition illustrates set measures interest compute includes moment probability vector long reward rate th state set polynomial coefficients 
compute follows problem reduced computation jl show computed recursively starting simply multiplying equations eq second line appropriate factor results summing equations parts obtain def 
def rewritten kl kl exchanging order summations obtain kl isolating case outermost summation obtain kl lf linear system form right hand side expression computed vectors rank isn 
true infinitesimal generator rank system determined 
drop columns resulting obtain additional equation flow balance equations multiplying appropriate factor introduce notation 
sum lines eq obtain def fc def fc steps analogous just performed obtain eq written defined kl fc fc note matrix full rank 
true generator rank unique stationary probability vector satisfying 
vector satisfy ensure process positive drift ergodic shows possibly obtained linear combination columns matrix defined eq full rank 
compute eqs 
solving linear system unknowns course 
example consider compute measures moment queue length 
case jf conclude observing sequences nicer relation geometric treatment section modified appropriately simplify different sums introduced give closed form formulas 
general case considered measures infinite 
example sequences summable decrease moments order higher queue length exist infinite 
practical point view store finite set matrices sequences sums type finite 
time storage complexity section detailed comparison aggregate solution type processes method outlined section 
complexity analysis accuracy notation 
analysis denotes time complexity solving linear system described nonzero entries denotes number nonzero entries matrix general case taken mean respectively 
practically store infinite number matrices store matrices type matrices accurately capture behavior system 
furthermore matrix analytic method reach necessary accuracy necessary compute block vectors stationary probability vector 
outline required steps method analyze computation storage complexity step computation expected queue length process summarize discussion table analysis aggregate computation aggregate stationary probability vector compute sums form sparsity depends directly sparsity 
compute sums form solution system linear equations 
storage requirements computation store sums store probability vectors computation expected queue length compute solution sparse system linear equations 
analysis matrix analytic solution computation stationary probability vector methodologies require computation include cost complexity analysis 
different sums considered computed stored memory computation completed 
computation complexity storage complexity storage computation probability vector aggregate pn sn log mn matrix analytic mn sn computation moment measure aggregate matrix analytic table computational storage complexity aggregate matrix analytic methods computation probability vector aggregate matrix analytic moment 
note fast fft version ramaswami recursive formula comparison 
compute sums form 
computation inverses additional multiplications full matrices 
solution system linear equations 
pn sn log fast version ramaswami recursive formula compute vectors stationary probability vector 
storage requirements computation store sums form storing matrix system linear equation 
store store vectors 
computation expected queue length compute queue length concluding analysis point aggregate solution efficient approach computation storage wise 
comparison matrix analytic solution entails steps easier implement 
need generate stationary probability vector complexity analysis term appear aggregate comparison value times higher 
furthermore aggregate solution introduce matrix inversion matrix multiplication sparsity original process preserved resulting significant savings respect computation storage 
emphasize fact sparsity key preserving sparsity original process methods 
special cases sparse single column matrix single column matrix 
cases sums form preserve sparsity original process reduce computation storage cost 

computational efficiency previous section argue notation computational storage efficiency aggregate 
numerical evidence supporting fact aggregate efficient approach 
comparisons classic ramaswami formula fast ramaswami formula efficient known algorithm solving type processes 
implementation cyclic reduction computation required solution algorithms 
code fast ramaswami formula available personal communication 
implemented aggregate method classic ramaswami formula experiments conducted mhz sun enterprise server gb memory 
chain selected experiments represents general queue 
recall practice possible store infinite number matrices 
storing entries pare sufficient threshold close zero practical implementation 
illustrated previous section computation time depend size parameters number stored matrices parameter define infinitesimal generator parameter affects computation time number vector probabilities computed normalization condition reached sufficient numerical threshold 
experiments vary parameters case queue provide timing results computation stationary vector classic ramaswami implementation fast fft implementation computation aggregate 
provide timings computation queue length methods 
results 
experiment considers queue relatively small case 
timings code available www dm unipi ric html 
point timing results take consideration computation methods cpu time sec log scale cpu time sec log scale stationary probability vector matrices aggregate ramaswami fft ramaswami queue length matrices aggregate ramaswami fft ramaswami stationary probability vector matrices cpu time sec log scale aggregate ramaswami fft ramaswami queue length matrices cpu time sec log scale aggregate ramaswami fft ramaswami stationary probability vector matrices cpu time sec log scale cpu time sec log scale aggregate ramaswami fft ramaswami queue length matrices aggregate ramaswami fft ramaswami execution time seconds aggregate classic implementation ramaswami formula fast fft implementation ramaswami formula 
upper row illustrates timings computation stationary probability vector lower row computation queue length 
algorithms shown function depicts computation cost probability vector illustrates computation cost queue length 
observe axis log scale 
note value affect execution time matrix analytic approaches affect aggregate 
expected computation stationary vector superior classic ramaswami formula behavior persists increase see figures 
aggregate consistently outperforms methods plus performance insensitive see figures figures 
figures illustrate computation cost queue length algorithms various values note implementations ramaswami formula cost classic formula computation queue length weight appropriately sum probability vector computed 
figures confirm cost solving small system linear equations aggregate requires computations queue length cases preferable classic methods 
linear system increases small classic methods may offer better performance 

numerical stability algorithm proposed section results finite system linear equations solved numerical methods 
linear system result matrix additions subtractions multiplications numerical stability examined 
presence linear system matrices analytic examination numerical stability easily feasible 
section argue experimentation aggregate numerically stable compare stability behavior ramaswami recursive formula 
ramaswami recursive formula computation steady state probability vector type process consists matrix additions non negative matrices computations known numerically stable focus stability method solve original problem stability problem 
measured condition number conditioning depends specific instance problem method 
stability method input determined follows small perturbation input conditioning problem input norms corresponding vector spaces limit discussion infinity maximum norm 
states stable algorithm gives nearly right answer nearly right question 
words change input stable algorithm small obtain output perturbed constant factor corresponding amount 
follow definition examine experimentally stability aggregate versus ramaswami formula 
output aggregate scheme probability vector elements denoted belongs domain method choice elements input matrices 
output ramaswami probability vector elements denoted 
note ramaswami original output post processed produce aggregate probabilities produces 
run sets experiments conditioned instance problem ill conditioned instance 
performed steps opt compare aggregate fast formula ffts may source numerical instabilities 
perturbation solution input perturbation perturbation solution solution difference input perturbation aggregate matrix analytic experiment number experiment number aggregate matrix analytic perturbation solution input perturbation perturbation solution solution difference input perturbation aggregate matrix analytic experiment number experiment number aggregate matrix analytic numerical behavior algorithms conditioned input 
graphics plot aggregate ramaswami recursive formula different perturbation magnitudes distinct experiments 
graphics illustrate perturbation magnitudes distinct experiments 

select ctmc solve aggregate ramaswami formula check closeness results 

perturb input selected ctmc small random numbers 
select different perturbation magnitudes solve ctmc perturbed input 

repeat perturbation experiment times different sets random perturbation values magnitude range achieve statistical accuracy 

calculate perturbation output randomly perturbed input aggregate solutions considering base case output obtained aggregate solve ctmc perturbation input experiment calculate set perturbed solutions ramaswami formula base case solution obtained ramaswami formula un perturbed input experiment 
calculate absolute difference solution obtained aggregate ramaswami formula experiment experiments selected ctmc models bursty hyper exponential server burst sizes ranging top 
dimension matrices matrices dimensions respectively 
corresponding matrix process matrices full consider case representative 
experiments conducted pentium iii bit double precision arithmetic machine precision 
set experiments considers conditioned input matrices values elements differ orders magnitude 
illustrates behavior aggregate ramaswami formula conditioned input distinct experiments 
experiment corresponds different magnitude range 
shows perturbation solution experiments aggregate ramaswami formula magnitude range observe lines aggregate ramaswami formula lines indistinguishable level 
proximity solutions better illustrated difference solutions obtained different methods plotted range 
methods equal numerical purposes 
illustrates perturbation solution methods range experiments degree perturbation solution conditioning conducted large number stability experiments due space restrictions experiments 
note experiments produce consistent results section 
experiment section run different problem orders magnitude consistently illustrates methods agree machine precision 
regardless magnitude input perturbation differences solutions consistently range turn worse conditioned problem elements various input matrices vary significantly 
ctmc previous set experiments entries input matrices vary magnitude largest element range smallest range increasing stiffness problem possibility numerical error increases 
perturb input random values ranges results 
perturbation input matrices values level introduces perturbation solution range higher perturbation solution conditioned case compare figures 
point lines top corresponding aggregate ramaswami output respectively 
differences solutions obtained methods experiments range 
comparing results conditioned case note increase difference solutions small clearly perturbation value 
illustrates perturbation solutions perturbation inputs range comparing results observe conditioning problem increases 
degree perturbation remains constant experiments order magnitude consistently experiments 
difference solutions methods case input perturbation ranges 
differences range experiment depicted 
results figures show methods aggregate ramaswami formula behave similarly different numerical scenarios 
nearly input obtain cases nearly output argue stability ramaswami recursive formula re confirmed 
experiments illustrate aggregate ramaswami recursive formula agreement 

concluding remarks new aggregate approach exact solution type processes 
exposition focuses computing efficiently exact probabilities boundary states process aggregate probability classes states corresponding specific partitioning remaining infinite portion state space 
method compute probability distribution states provides information mathematically exact computation wide variety markov reward functions expected queue length higher moments 
values results obtained 
choose extreme cases 
detailed analysis computation storage complexity method 
conclude aggregate requires simple steps provide significant savings respect computation storage compared traditional matrix analytic 
gains direct outcome fact methodology aggregate approach produces output 
proposed aggregate methodology solution processes results simpler easy implement algorithm comparing matrix analytic 
method classic ones implemented mamsolver tool available community issue arises area numerical solutions markov chains method numerical stability 
numerical stability algorithms solution processes focus hardly investigated 
provide strong experimental indications methodology stable 
examining theoretically numerical stability methodology subject 
acknowledgments special go contributions earlier stages andreas guided numerical stability discussion analysis 
beatrice providing implementation ramaswami recursive formula guy invaluable feedback mark insightful discussions 
anonymous referees comments improved presentation 


displacement structure solving non skip free type markov chains 
alfa chakravarthy editors advances matrix analytic methods stochastic models pages notable publications nj 
ramaswami 
analyzing paradigms role block structure computing matrix taylor editors advances algorithmic methods stochastic models pages notable publications nj 
smirni 
aggregation solution method type processes 
plateau stewart silva editors numerical solution markov chains pages 
de zaragoza zaragoza spain 
smirni 
efficient technique analysis qbd processes aggregation 
performance evaluation vol pages 

modeling multiple ip traffic streams rate limits 
proceedings www cs wm edu mamsolver 
perturbation solution input perturbation perturbation solution experiment number aggregate matrix analytic perturbation solution input perturbation solution difference input perturbation solution difference input perturbation aggregate matrix analytic experiment number perturbation solution aggregate matrix analytic experiment number aggregate matrix analytic experiment number numerical behavior algorithms ill conditioned input 
graphics plot aggregate ramaswami recursive formula different perturbation magnitudes distinct experiments 
graphics illustrate perturbation magnitudes distinct experiments 
th international teletraffic congress brazil dec 
ramaswami 
matrix geometric methods stochastic modeling 
asa siam series statistics applied probability 
siam philadelphia pa 

improved fft version ramaswami formula 
comm 
statist 
stochastic models vol 
pages 

solving type markov chains advances applications 
comm 
statist 
stochastic models vol pages 
nelson 
probability stochastic processes queueing theory 
springer verlag 

matrix geometric solutions stochastic models 
johns hopkins university press baltimore md 

structured stochastic matrices type applications 
marcel dekker new york ny 
nielsen 
modelling long range dependent heavy tailed phenomena matrix analytic methods 
advances matrix analytic methods stochastic models taylor eds 
notable publications pages 
ramaswami 
general class markov processes explicit matrix geometric solutions 
spektrum vol 
pages aug 
ramaswami 
stable recursion steady state vector markov chains type 
commun 
statist stochastic models vol 
pages 
ramaswami wang 
hybrid analysis simulation atm performance application quality service cbr traffic 
telecommunication systems vol 
pages 
smirni 
mamsolver matrix analytic methods tools appear th international conference modeling techniques tools computer communication systems performance evaluation london uk april 

yu liu zhang matrix analytic analysis map ph queue fitted web server data 
appear th conference matrix analytic methods adelaide australia july 

matrix analytic methods applications results software tools 
taylor editors advances matrix analytic methods stochastic models notable publications nj 
trefethen bau iii 
numerical linear algebra 
siam philadelphia 
