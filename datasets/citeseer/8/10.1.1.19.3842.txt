dynamic analysis collecting data program runs 
raw traces tend voluminous unstructured directly visualization understanding 
address problem phases phase selects subsets data compacts second phase encodes data attempt infer structure 
major compaction selection techniques include gprof style depth call sequences selection class compaction time intervals encoding execution directed acyclic graph 
structure inference techniques include run length encoding contextfree grammar encoding building finite state automata 
keywords software understand program tracing dynamic program analysis motivation software understanding requires inferring behavior software systems 
static techniques analyzing program code dynamic techniques running program collecting data runs analyzing resultant data 
dynamic case inherent tradeoffs concerning amount collected data types analyses performed overhead collection 
regard frameworks suitable dynamic analysis having parts 
bottom layer closest program suite tools gathering information program executes 
middle layer selects relevant portions data compacts analyzes effectively building model 
top layer closest user displays models 
process building framework 
part described briefly review section 
bulk discusses encoding program executions steven reiss brown university computer science department providence ri usa spr er cs brown edu middle layer tools 
envision top layer having capabilities previous tools enhanced abilities specifying meaningful visualizations demand task arises 
purpose middle layer build models collected data 
reasons build model impossible visualize raw data volume complexity second model automatically check properties traces 
want models useful tasks summarizing parts program execution 
summaries allow show execution multiple levels detail helping user navigate 
modeling class behavior 
track outside calls methods invoked objects specific class 
suite programs class correctly abstractions generated execution analysis model class 
modeling library usage 
view library object track external calls 
allow build model correct library usage test users library model 
detecting unusual events 
model program behavior able find events conform model 
events significant represent exceptional conditions 
example program executes sequence synchronization steps time occasionally executes alternate sequence denotes potential problem 
checking existing models 
model aspects behavior system say specifications process able efficiently check model produced traces conforming original 
see opportunity building models design patterns verifying program implements correctly 
especially useful behavioral patterns hard specify 
performance analysis 
want able annotate models performance information 
existing performance tools doing fixed limited model 
prof simple function invocation model gprof digram model 
visualization 
want models fit exploration graphical means 
visualization environment leave user separate data noise 
course noise particular application useful essential models rich hint user focus 
hand include model volume 
describe provides framework necessary addressing problems trace data 
important aspects research 
framework separates collection analysis encoding data 
framework provides flexibility needed address wide range problems described 

specific data selection techniques address problems 

specific encoding techniques facilitate different types analysis combined various selection techniques 
significance research lies specific techniques ability combine various ways application combination broad range problems 
remainder organized follows section describes data trace tools currently generate 
different data compaction selection approaches described section 
section describes different sequence encoding techniques utilize approaches 
note techniques approaches described section 
section discusses results various encodings commenting degree compaction accuracy 
conclude discussion impact extensions currently planning 
trace data part framework collects data running program 
suite tools traces binary executables java programs 
binary tracers tuned prohibit working executables produced say pascal java native compiler 
table summarizes tracing data 
tracer binaries wolf patches executable inserting hooks entry exit routine 
instruments basic blocks keep count instructions executed function invocation 
entry exit hooks generate trace file thread program 
call record emitted including called address calling address argument call 
determine object method calls size memory allocation thread thread related activities synchronization object synchronization call 
return record includes address function called return value 
addition trace files contain periodic records recording thread run time real time clock number instructions executed thread 
records thread output separate file 
second tracer development doing minimal emitting called address argument function calls piggybacking count intervening function returns function call 
java programs different tool uses standard java profiling interface jvmpi produce multiple trace files thread 
files contain records method entry exit object allocation deallocation thread creation termination monitor synchronization activity 
trace files contain records thread run time real time 
reason trace file thread cases avoids synchronizing calls synchronized 
get effect back program outputs unified trace file dictionary file maps identifiers function addresses binaries object identifiers java trace file meaningful symbols 
data recording fairly high level amount data large long running system immense 
resultant trace data files contain gigabyte data seconds execution seconds java execution minimal tracer reduces factor 
imposes certain requirements efficiency tools deal files 
primarily creates need compaction selection techniques describe section 
data compaction selection data compaction selection techniques range lossless transformations aggregation 
trace data basically dynamic call tree 
tree includes node routine invocation edge invocation invocations directly generates 
tree augmented time information run time real time instructions spent call memory usage infor 
common java function entry function id argument object id java function exit function id object allocate free object id thread start run time execution time thread real time accumulated real time 
lock pthread synchronization object create destroy wait test unlock lock id memory allocate free address size instruction count instructions executed thread 
java class load unload class id gc start number non garbage objects total non garbage object space total object space monitor enter exit object id monitor wait object id timeout table trace record summary mation size number allocations done call 
discussion compaction selection schemes talking encoding sequences calls events strings combining various encodings 
degree compaction depends largely particular structures operations choose purpose 
example represent sequence calls string run length encoded string represent sequence automaton combine nodes collapsed strings combining automata example union 
different approaches described section 
effectiveness combination compaction choice representation described section 
string compaction simplest way representing dynamic call tree string 
example function calls function function represent abc course ambiguous string result calling calling returning 
need insert markers return cases follows ab abc 
note thread control generates string 
output string encoding execution tree sequence encoded strings thread 
java thread names allow threads similar names grouped encoding purposes 
strings apply techniques section 
class selection applications modeling behavior class parts trace irrelevant 
interested constitutes typical class need number applications class correctly 
trace applications isolate calls methods particular class class hierarchy group object 
interested inner workings class monitor methods object invokes interested external interface forego 
grouping calls object need track argument calls methods pointer largely system dependent behavior norm 
pointer interesting argument constructor uninteresting argument destructor 
similar approach provide models usage library package entity 
easy principle difficulty practice comes attempting define meant single library entity 
trick objects general case 
example consider library file interface 
file accessible program pointer file data structure 
specific address interesting returned function fopen 
argument function fprintf fscanf fourth fread fwrite 
need specify return value fopen linked argument fprintf fourth argument fread 
top specification difficulty harder trace program need emit records arguments 
approach interpose library exactly extra step selecting arguments 
standard unix prof tool provides useful performance data grouping calls single routine single node collecting statistics node 
gprof accumulates statistics calling pairs inadequate 
trace data provide simple level generalization 
create level call encoding look call stack start call 
create includes call top items call stack point 
tuple accumulate statistics collected trace data computing sums averaging sum squares computing standard deviation 
interval compaction way compacting data consider program trace chunks 
break execution small interval visualization set intervals example simple analysis intervals highlight system doing point 
currently define system doing distinct ways providing different analyses intervals 
concentrates calls interval combining class 
multithreaded applications keeps track time spent waiting class 
model produce overview visualization shown 
second interval analysis looks allocations class basis 
interval records number size allocations objects class thread 
provide high level visualization allocation behavior system combined call interval analysis provide additional details behavior system 
dag compaction effective way compact dynamic call tree transform directed acyclic graph dag 
dag built traversing tree postorder fashion collapsing nodes identical strings calls 
string appears exactly dag 
algorithm compact tree follows 
post order fashion nodes tree construct string consisting function node opening parenthesis encoding strings children maintaining order closing parenthesis 

compute signature string hashing 

node dag node containing resulting string 

create node create arc nodes containing tree node children strings retaining order 
don keep strings strings representation sequence operation replace concatenation way defining unambiguously head sequence parentheses 
building dag need merge performance statistics associated individual nodes 
keeping dag node count number original nodes sums statistic original nodes sum squares statistic original nodes 
lets provide averages standard deviations dag node 
compaction generally quite effective execution repetitive nature dag allows repetitions collapsed single node 
dealing multiple threads start forest call trees apply algorithm trees simultaneously starting empty dag time 
construct single dag represents threads control 
individual threads represented root nodes resultant graph 
sequence encodings effectiveness compaction techniques relies representation sequences items 
approaches representations 
provide exact representation sequence possibly compressed 
second provide lossy representation represents original sequence sequences 
example detect repetitions sequence ignore counts say ba bc regular expression notation ba bc 
kind approximation sequences particularly useful attempting identify similarities case attempting encode group related sequences single encoding 
compaction techniques previous section approach 
example compacting tree dag nodes dag describe families call sequences 
example take case function calls function loop 
classical string representation mapped different dag node depending number iterations loop 
say run length encoding scheme ignores counts mapped node 
cases approximation better understanding visualization 
framework allows variety sequence encoding techniques 
include approximations exact encodings 
vary simple complex 
correct depend particular compaction selection scheme specific understanding task 
run length encoding simplest approach provide encoding find immediate repetitions replace count followed item repeated 
string encoded 
fast quite effective terms compression 
run length encoding algorithm takes parameter indicating longest repetition expressed exactly 
repetition size longer look 
sequence encoded 
grammar encoding alternative simple run length encoding finds immediate repetitions find common subsequences encode string grammar subsequence represented rule 
natural extension rle encoding 
approach sequitur algorithm 
algorithm builds context free grammar representing original string 
ensures pair adjacent symbols appear grammar rule 
algorithm works looking successive new digram formed duplicates existing adding new rule 
process needs applied recursively nonterminals replace rules need eliminated number uses falls 
standard sequitur algorithm provides exact encoding single sequence 
implementation algorithm provides encoding groups sequences 
done building global table variables 
sequence encoded separately 
sequence encoding complete nonterminals merged global variable table unique right hand side variable appears 
final encodings terms global variables 
example consider string 
encoded ar ddr subsequence bcd isolated sequence encoded rules 
basic sequitur algorithm job finding common subsequences encoding efficiently 
produces grammar compact rule meaningful 
hand best job handling repetitions needs log rules encode sequence identical symbols encoding bs take account balanced strings strings number calls returns handle alternation 
modified basic algorithm basic ways 
find immediate repetitions represent run length encoding 
done post processing step 
rule processed nonterminals processed 
instance nonterminal right hand side rule replaced newly computed expansion algorithm run length encoding new right hand side 
rule bcd longer needed yields grammar bcd logical representation original sequence repetition shown explicitly 
approach combined run length encoding repetitions represented lets rules merged 
representation sequence sequitur run length encoding cutoff bcd second modification sequitur designed produce balanced rules 
useful simple string compaction section 
dissertation nevill manning notes sequitur restricted create rules contain closing symbols opening ones 
done considering unbalanced 
resultant grammar start produce balanced rules 
modification algorithm ensures generated rules balanced 
done post processing 
start restricting grammar generated rules completely balanced rule starts open bracket directly nested rule contains open brackets close brackets 
neville manning balancing algorithm 
encoding rules modification 
time encounter unbalanced non terminal expand place 
rules final grammar longer subsequences appear 
resultant grammar balanced rules 
finite state automata encoding way provide alternation repetition encoding finite state automata accept sequence 
vary accuracy precision encoding different means constructing automaton 
extreme build chain automaton accepts sequence 
extreme build single state automaton accepts self arcs possible input symbol 
naturally approaches useful 
want automaton intuition sort sequence possible 
words automaton reveal structure sequence 
automaton represents multiple sequences collective structure revealed 
significant previous inferring finite state automata input sequences 
concentrated positive negative examples providing set inputs valid sequences set inputs 
previous looked interactive models inference procedure able ask user particular input valid 
approaches practical types sequences looking 
ways sequences special 
path example automata reflect internal flow graph single procedure 
encode loops conditional branches pure sequential flow 
provides direction 
applications automata describe methods class clear cut 
way classes designed result fairly structured flow diagram 
order take advantage presumed structure sequence provide reasonably high degree abstraction building automata developed new algorithm inferring automaton sequences 
basic fsa construction algorithm algorithm constructs deterministic fsas property sequence symbols start state 
formalize little definitions hopcroft ullman 
deterministic finite state automaton defined set states input alphabet initial state transition function addition define string length element extended definition allows second argument word single symbols 
formally specific purposes define element 
achieve extending strings sequence length special symbol 
say state tail iff exists state iff starting possible see sequence call relation tail 
algorithm maintains invariants determinism unique mapping tails states tail tail 
basic algorithm maps tail state 
states tail common merged 
merging states recursive process states merged outgoing arcs symbol target states arcs merged 
process affect possible tails state 
number potential additions need considered adds arc grows size input alphabet 
prohibitive building large automaton 
ignore associations building automaton merge states associations post processing step 
final postprocessing step classical minimization fsa 
example algorithm output sequence shown 
handling self loops basic algorithm reasonably finding appropriate automaton 
fails detect sequences single token 
consider input sequence 
automaton generated basic algorithm consist states single transition 
states algorithm adds transition symbol 
want generate automaton self loop indicates repetition requires simple modifications algorithm 
occurs building automaton 
current state input current token creating new state create self loop 
sufficient create self loops repetitive input sequences 
consider result applying modified algorithm example shown 
self loop input state created determinism 
ds state 
takes new state 
get second sequence new check fires self loop created 
shown 
sequence bcd associated state 
self loop state require merged 
result shown 
second modification bit complex 
self loops tend cause spurious state merging 
consider automaton part 
states potential successor string ddd 
general state self loop input state transition state input merged 
behavior want 
changed postprocessing step situations initial instance causes transition state representing loop part loop 
experience various encoding approaches variety program traces java 
programs generated traces include solves problem finding hamiltonian examples self loops path graph induced knight moves chessboard 
written 
simulate motion pendulum magnetic field 
written java 
onsets engine sets board game 
core program builds valid logic formulas set characters 
written 
optimizing compiler small subset java 
written 
webserver main function finding alternate meanings words elaborate web searches 
raw trace data ranges size megabyte simple program implementing knight tour gigabytes test commercial java system handles web requests 
tried various encodings traces 
evaluate quality results done spot checks trace detailed analysis knight tour example 
encodings evaluated ways 
goals various encodings especially dag call encodings provide concise version trace data 
cases measure amount compaction encoding provides 
note absolute measure 
program repetitive condensed encoding independent encoding technique 
note giving information doing encodings 
encodings typically look dynamic call graph 
ignore memory management synchronization information trace 
discard information individual objects 
experience encode quarter original trace data 
note raw trace files quite dense contain packed binary data encoded output files text files containing xml data 
compression results various encodings seen table 
abb bbb bbc bcd cdd ddd grammar encodings grow size trace fsa encodings grow number functions program 
grammars tend grow larger fsas 
dangerous definite assertions sizes models 
second way evaluating encodings especially automata ones see resultant automata reflect intuitive behavior system 
purpose spot checked routines knight tour example classes java program classes standard library see corresponding automata looked 
example 
spot checks automata generated correspond quite expect code 
thing evaluated generating encodings determine values parameter automata 
cases looked value collapsed states value difference resultant automata 
cases automata change 
come examples require arbitrary find right intuition value compromise 
related tracing programs done number different ways 
essentially program emit records state 
modify program code generate trace data 
approach taken data visualization systems balsa polka 
approach works goal algorithm animation tracing part finished program 
second approach modify executable 
done compile time gprof finished executable 
apart system eel takes approach 
lastly run executable tracing environment jvm modified jvm 
significant encoding call tree 
essentially algorithm jerding incorporate steps keep encoding phase 
approaches lose information process 
dbc sample run fsa inducing algorithm jerding focus class selection 
prof gprof kept statistics function invocations pairs respectively 
try derive automaton usage classes effectively discovering path expressions 
kind result akin ernst notkin trying discover data invariants program 
sequitur compress basic block trace data larus 
neville manning reports gaines focused discovering control flow albeit absolute value program counter 
discovering fsas positive examples long history 
general impossible discover correct minimal fsa 
impossible probably approximately correct model 
algorithm closest cook wolf difference collapse nodes iff includes tails 
constraint stricter bigger fsas 
research described represents step system afford broad basis understand visualizing dynamic behavior large complex systems 
current efforts involve extending basis variety ways 
area trace data collection working extensions reduce size trace files impact tracing program execution 
working interface specifying trace records interesting outputting 
incorporating minimal tracing section larger framework 
addition implementing variety minor extensions trace collection system effectively multiple process distributed systems 
working developing incorporating additional selection compaction techniques 
looking involve generating sequences memory events allocations memory compaction involving moving objects garbage collector frees garbage collections generating sequences reflect library arbitrary program abstraction 
program name functions raw trace size dag grammar dag fsa string grammar string fsa onsets working developing additional encoding techniques 
sequence encodings investigating probabilistic models hidden markov models approximate fsas 
probabilistic models flexible known train 
capable various things fsa segregation program trace phases 
hand tune lot parameters properly learning process optimization procedure resulting model gets stuck local optima meaningful 
ammons ball larus 
exploiting hardware performance counters flow context sensitive profiling 
sigplan conference programming language design implementation pages 
brown sedgewick 
interesting events 
stasko chapter pages 
campbell habermann 
specification process scheduling path expressions 
lecture notes computer science 
springer verlag 
cook wolf 
discovering models software processes event data 
acm transactions software engineering methodology july 
de pauw 
visualizing patterns solving memory leaks java 
proceedings th european conference object oriented programming lisbon portugal june 
ernst cockrell griswold notkin 
dynamically discovering program invariants support program evolution 
proceedings st international conference software engineering pages 
acm press may 
gaines 
behaviour structure transformations uncertainty 
international journal man machine studies 
table compression achieved encodings 
gamma helm johnson vlissides 
design patterns 
addison wesley reading ma 
graham kessler mckusick 
gprof call graph execution profiler 
proceedings sigplan symposium compiler construction pages 
acm acm 
hopcroft ullman 
automata theory languages computation 
addison wesley 
jerding stasko ball 
visualizing interactions program executions 
proceedings international conference software engineering boston ma usa may 
larus 
program paths 
proceedings acm sigplan conference programming language design implementation pages 
larus schnarr 
eel machine independent executable editing 
proceedings acm sig plan conference programming language design implementation pldi pages la jolla california june 
nevill manning 
inferring sequential structure 
phd thesis university waikato new zealand may 
reiss 
software visualization desert environment 
acm sigplan notices july 
reiss 
working patterns code 
proceedings rd hawaii international conference system sciences jan 
reiss 
generating java trace data 
proceedings acm java grande san francisco ca june 
acm press 
stasko 
smooth continuous animation algorithms processes 
stasko chapter pages 
boolean sol sq heur integer sol row number column number sol return true num moves legal moves heur new num moves legal moves sq heur null sq sol return true delete heur num moves legal moves sol row number column number return false delete new case fsa algorithm discovers control flow stasko domingue brown price editors 
software visualization programming multimedia experience 
press feb 

practical experience limitations gprof 
software practice experience apr 
whaley 
portable sampling profiler java virtual machines 
proceedings acm java grande conference san francisco ca june 
acm press 
