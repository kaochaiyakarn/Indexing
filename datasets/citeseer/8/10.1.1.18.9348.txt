generalizing hindley milner type inference algorithms hage doaitse swierstra institute information computing sciences utrecht university technical report uu cs www cs uu nl generalizing hindley milner type inference algorithms hage doaitse swierstra jur doaitse cs uu nl july type inferencing standard algorithms yields uninformative error messages 
times consequence bias inherent algorithms 
method developed collect constraints program solve possibly influence heuristic 
show soundness completeness algorithm 
algorithms turn deterministic instances method giving correctness respect hindley milner typing rules free 
show algorithm flexible naturally allows generation multiple messages 
type systems indispensable modern higher order polymorphic languages 
important contribution popularity haskell ml advanced type system enables detection ill typed expressions compile time 
modern language processors type inference techniques derived algorithm proposed milner mil unification types 
error messages compilers interpreters hard interpret programmer productivity hampered 
programmers new language discouraged 
unfortunately straightforward change unification systems produce clear type error messages 
serious problem type conflicts detected far away site error 
problem location inconsistency detected influenced order types unified 
unification type systems bias report type conflicts near program 
left right bias caused way unification substitution 
mca proposes modification substitutions unified bias removed 
consider program true false false algorithm described detail lee yi ly report expression true compatible type int 
advice report novice user change true integer resulting type error inst 
information computing sci univ utrecht box tb utrecht netherlands occurrence false error 
algorithm report argument function int expected 
help finding exactly wrong 
approach type inferencing remedy shortcoming 
method set constraints types generated expression 
constraints typically generated locally describe global properties 
separation constraint generation specification analysis constraint resolution implementation standard field research aik 
longer forced solve constraints generated system necessarily left right bias order constraints solved arbitrary 
sulzmann describe different approach express hindley milner type system constraint form 
heuristics remove inconsistencies final set constraints viewed way heuristics determine order constraints solved 
give example heuristic inspired approach johnson walz wj 
larger part concentrates formally describing method proving correct 
indicate understood deterministic instances general method 
papers algorithms capture information deductive steps type inference algorithm construct better explanation type conflict wan bs db mca 
tracing reason deduction similar collecting constraints types 
section explain construct type graph collected constraints 
techniques proposed store type information graph cho 
systems handle polymorphism 
graph mca contain expressions polymorphic instances declaration obtained duplicating parts graph 
approach result computing type expression exponentially times 
organised follows 
section expression type language give standard hindley milner type inference rules algorithm section 
section give bottom type inference rules collecting type constraints show solved 
proving soundness completeness algorithm section give examples heuristics deciding constraints removed order constraint set consistent section 
summarize findings indicate research shall go 
preliminaries introduce small polymorphic functional language core popular languages haskell ml 
expression keep things simple recursive declarations construct permitted 
words scope variable declared expression limited body include definition part 
deliberately restrict small expression language extensions recursion patterns explicit type definitions added straightforward way 
expressions serve example contain literals 
literal value constant type true type bool type int 
syntax types type schemes type int bool string type scheme type type variable type constant function type 
basic representation types easily extended include types lists user defined data types 
extensions touch essence inference algorithms 
type scheme type number type variables polymorphic type variables bound universal quantifier 
type variables implicit order type scheme order important 
reason may view vector set need arises 
set free type variables type denoted freevars simply consists type variables 
additionally freevars freevars 
substitution usually denoted mapping type variables types 
set type variables write 
substitution applied type variables domain substitution remain unchanged 
consequently empty substitution written behaves way similar identity function 
usual substitution replaces free type variables quantified type variables type scheme affected substitution 
assume substitutions idempotent implies 
instance bool considered invalid substitution 
substitution transformed equivalent idempotent substitution fulfils occur check see bn 
purposes substitutions pass occur check defined equal error substitution denoted 
define equal error type denote 
composition substitution followed substitution written substitution 
equals composition equals 
type environment usually denoted maps variables corresponding type schemes provides context type inferencing takes place 
denote type environment variable removed domain def lift notion free type variables environments union set free type variables occurring type schemes range 
environment equal 
generalizing type respect type environment entails quantification type variables free occur generalize def freevars freevars literature generalization referred determining closure type 
fact different notations dm ly express hm hm hm hm hm hm hm generalize hm hm hindley milner type inference rules var hm app hm abs hm hm 
instantiation type scheme obtained replacement quantified type variables fresh type variables instantiate def fresh atype generic instance type scheme exists substitution freevars syntactically equal 
types mgu returns general unifier substitution 
definition holds unifier 
note types unified mgu 
hindley milner type inference rules damas milner dm set inference rules shown 
exactly rule language constructs expression language 
rules deal judgements form hm expressing expression assigned type type environment 
may exist multiple types validate assertion 
fortunately exactly type scheme valid types generic instances referred principle type scheme expression 
instance identity function principle type scheme assigned types bool bool 
rules provide easy framework construct proof certain type assigned expression classify type invalid expression suggest approach find valid judgement 
literature algorithms discussed compute principle type scheme expression type environment 
best known algorithm bottom algorithm shown 
correctness algorithm respect type inference rules proven dm 
second implementation hindley milner type system folklore top algorithm named algorithm property stops earlier ill typed expression 
earlier means visited fewer expression substitution type instantiate fresh mgu fresh generalize algorithm nodes syntax tree refer amount done 
proof property correctness ly 
type inference algorithms primarily designed find principle type scheme expression detect ill typed expressions 
result reported error message associated location strongly depend order type inference algorithm unifies types 
combining error sites lead informative messages 
general analysis contradicting sites provides better insight origin type error 
section introduce new set typing rules allows global type inferencing providing flexibility 
type inferencing constraints section discuss type inference algorithm differs algorithm aspects 
set constraints types collected constructing substitution 
postponing unification types paves way global approach type inferencing allowing finely tuned method choosing invalidating constraints 
second difference absence type environment type inferencing takes place 
assumption set record type variables assigned occurrences free variables 
bottom construction constraint set assumption set compositional computation follows shape syntax tree 
type constraints constraint set usually denoted multiset type constraints 
introduce forms type constraints constraint equality constraint reflects unified stage type inferencing process 
sorts constraints cope bu var bu bu bu bu bu bu bu bu bu bottom type inference rules app bu abs bu bu polymorphism introduced expressions 
explicit instance constraint states generic instance 
constraint convenient know type scheme start type inferencing expression 
general polymorphic type declaration expression unknown inferred instantiated 
overcome problem introduce implicit instance constraint expresses instance type scheme obtained generalizing type respect set monomorphic type variables quantifying polymorphic type variables 
bottom type inference rules bottom type inference rules henceforth abbreviated bottom rules deal judgements form bu 
assumption set records type variables assigned free variables contrary standard type environment hindley milner inference rules multiple different assumptions variable 
rules allow flexibility coping unbound identifiers 
advantages property discussed nikhil nik bernstein ber 
inference rule variable straightforward fresh type variable introduced returned type 
assume time infinitely fresh type variables available 
fact assigned variable recorded assumption set 
constraint set empty 
new type variable introduced represent type application expressions 
equality constraint ensures domain range type expression match type second expression respectively 
furthermore collected constraints subexpressions passed unchanged assumption sets merged 
fresh inference rule lambda abstraction represents type lambda bound variable 
equality constraint generated type variable assumption set associated variable bound lambda 
assumptions concern variable removed assumption set 
id abs app var var var var id id top computation monomorphic sets unsurprisingly expression introduces polymorphism brings difficulties 
inferring type expression implies specific order types subexpressions computed 
order reflected hindley milner inference rules inferred type declaration generalized added type environment type body inferred 
implicit instance constraint generated variable body bound 
order set constraints implicit instance constraint requires constraints solved solvable 
section discuss necessary 
implicit instance constraint depends context declaration 
particular depends monomorphic type variables unbound variables 
node syntax tree set monomorphic type variables compute monomorphic sets single top computation sufficient 
arbitrary expression set contains exactly type variables introduced lambda abstraction higher level syntax tree 
left distribution implicit bottom rules 
confine example 
example consider expression id id id depicted syntax tree expression indicated top computation monomorphic sets 
type variable introduced variable lambda abstraction rooted marked node tree 
type declaration id polymorphic type monomorphic 
follows fact set monomorphic type variables empty outer contains inner 
example illustrate application typing rules consider type inferencing problem expression true variable introduced lambda abstraction occurrences body monomorphic type 
introduced assigned monomorphic type application literal true requires function type bool syntax tree determines bottom rules applied 
results deduction tree var bu bu true bool lit app var bu bu var bu bu bu bu constraint sets bool set root tree contains constraints implicit instance constraints type variable assigned lambda bound variable monomorphic 
solving type constraints generation constraint set substitution constructed satisfies constraint set 
satisfaction constraint substitution defined follows satisfies def satisfies def generalize sm satisfies def substitution types equality constraint syntactically equal 
instance general unifier chosen satisfy equality constraint 
implicit instance constraint substitution applied types set monomorphic type variables 
example section shall clear substitution applied 
substitution applied type type scheme explicit instance constraint quantified type variables type scheme untouched substitution 
general generalize sm equal generalize implicit explicit instance constraints really different semantics 
note types abs satisfies satisfies satisfies satisfies freevars satisfies satisfies generalize sm properties show equality constraint written instance constraint type 
properties hold generic instance type type generalize freevars equals types 
property justified fact substitution idempotent follows generalize sm equal generalize sm 
applied constraint set substitution simply applied types type schemes 
implicit instance constraints note fact substitution applied sets monomorphic type variables def sm define type variables constraint set active 
def freevars freevars def freevars freevars freevars def freevars freevars function returns substitution satisfies set constraints 
shall explain detail algorithm assumes constraint set contains constraint solved 
particular contains implicit instance constraints condition fulfilled 
solve constraints substitution solve solve solve sc mgu solve solve generalize freevars solve solve instantiate example consider constraints collected example 
show substitution constructed set 
solve bool solve bool bool solve bool bool solve bool bool solve bool bool solve bool bool solve bool bool solve bool bool solve bool bool bool bool bool notice sets monomorphic type variables modified substitution constructed 
applying substitution results bool general type expression 
substitution applied monomorphic sets implicit instance constraints incorrect type returned 
recursive definition solve consists basic case empty constraint set empty substitution returned transformation types constraints 
solve assume ordering constraints 
condition accompanying implicit instance constraint imposes certain ordering constraints involve type variables occurring right hand side handled implicit instance constraint handled 
intuitively means inferring body ought finished inferring types definitions body 
discussed example incorrect solve constraint handling semantics quite different 
side condition prevents happening insisting active anymore 
case solved 
possible constraint set implicit instance constraints depend way 
simple example active 
case algorithm blocks constraint solved set constraints empty 
note empty substitution satisfies itis difficult see constraint sets generated bottom rules kind circularity impossible lemma set constraints generated bottom rules 
execution solve non empty constraint set passed solve contains constraint solved 
proof equality constraints explicit instance constraints solve 
consider expressions gave rise implicit instance constraints solve 
expressions solve implicit instance constraints belonging outermost leftmost expression 
holds reason bottom rules introduce disjoint sets type variables disjoint trees particular definition body way type variables get related type variable introduced higher tree 
type variable necessarily monomorphic set monomorphic type variables point 
method solving instance constraints introduces new constraints type 
easy show solving constraint measure function andn number implicit instance constraints explicit instance constraints equality constraints respectively strictly decreases respect lexicographic order 
lemma function solve terminates inputs 
correctness algorithm solve lemma solve returns substitution constraint set constraint satisfied substitution 
substitution general substitution type variable renaming 
solve bool bool bool bool bool bool bool bool partially ordered set substitutions proof empty substitution general unifier satisfies empty constraint set 
restrict equality explicit instance constraints solve returns general substitution satisfies constraint set general unifier solve equality constraints fact function composition combine separate substitutions apply remaining constraints continue solving process 
furthermore properties hold satisfies satisfies satisfies satisfies second tricky part problem concerns solving implicit instance constraints 
show solving constraint interfere solving constraints 
consider situation freevars 
words implicit instance constraint solvable 
claim solve freevars generalize 
reason exists exists right hand side implicit instance constraint part corresponding monomorphic set 
words continues inactive implicit instance constraints containing solved 
follows mapped anymore constraint set 
please note type variables inactive elements freevars active 
general property valid generalization freevars dom generalize generalize sm consequently soon condition implicit instance constraint met transform explicit instance constraint 
example consider quasi order substitutions defined baader nipkow bn denotes 
say general 
substitutions considered equal renaming type variables 
instance 
order describes complete lattice substitutions element empty substitution greatest element special case represents error substitution 
consider constraints bool 
notation introduced label constraints 
part complete lattice substitutions various substitutions arise solving constraints order 
note part question forms complete sublattice 
type inference algorithm algorithm solve proven correct 
section give algorithm easily compared cases type inferencing takes place context type environment variables paired type scheme 
effect obtained constructing extra set constraints type environment assumption set pass solve set constraints collected bottom rules 
purpose definition lifted sets definition restrict type environment type scheme variable definition general required 
example id id andlet id 
equal 
note constraint semantically equal 
properties derived definition 
properties express distributes union 
property states irrelevant sets occurrence variable removed 
property lifts property sets 
ingredients algorithm compute type expression type environment 
bu dom dom report undefined variables exist solve return inferred type returns substitution gives signature 
advantage substitution reveals types expressions assigned fresh type variable bottom rules 
distinction type variables introduced applying inference rules monomorphic type variables occur initial type environment substitution change types 
choice rule apply solve nondeterministic just proved possible ways solving constraints result general substitution satisfies constraints 
interested comparing algorithms show fact deterministic instances 
moment restrict show constraint generated bottom rules mapped node syntax tree solve 
similar done fact done algorithm defined ly 
consider bottom rules 
case var bu trivial constraints generated 
applications equality constraint generated application node solved node means unification subexpressions note performs unifications postorder 
consider lambda abstraction lambda bottom algorithm generates equality constraint occurrence solves constraints lambda node moment reaches occurrences passes constraints variables means type environment 
constraints generated lambda node mapped occurrence bound identifier belong 
similar lambda abstraction pass implicit instance constraints generated defined expression uses body 
easy see finished inferencing definition condition implicit instance constraints generated fulfilled 
line reasoning similar lemma 
having mapped constraints bottom algorithm possibly nodes tree postorder traversal done resolve constraints order encounters may assume implicit instance constraints solved directly convert explicit instance constraints equality constraints unification 
result theorem algorithm deterministic instance 
soundness completeness section consider soundness completeness algorithm respect hindley milner inference rules 
start lemma relation value type environment node syntax tree hand types sm satisfies collected constraints 
lemma monomorphic type variables type environment typable expression hm bu corresponding deduction trees 
substitution satisfies unifies types corresponding nodes deduction trees 
corresponding nodes holds freevars freevars sm 
proof simplify proof assume shadowing occurs straightforward rename variables 
example transformed 
root syntax tree choose contains exactly free type variables 
pair deduction rules hindley milner type rule corresponding bottom deduction rule preserves invariant 
variable case case function application trivial 
lambda abstraction set monomorphic type variables extended fresh type variable introduced abs bu 
equals set free type variables ands 
removal type alter set free type variables allow shadowing 
expression type environment type declaration inferred unchanged set monomorphic type variables 
type environment body extended closure type declaration 
type scheme introduce free type variables freevars freevars generalize 
prove combination bottom rules algorithm sound show succeeds hm derived 
proof properties solve bottom typing rules 
alternative detailed proof theorem appendix theorem soundness bu dom dom holds hm 
proof judgement bu applying bottom rules expression including ill typed expressions 
assumption set contains pair free occurrence variable consequently type environment provide type variable ensured condition dom dom 
condition satisfies obvious expect typing hindley milner rules collected constraints satisfied 
third constraint ensures variables obtained type consistent types type environment 
condition restricts combinations holds 
clearly choosing bool aand valid choice 
theorem proved induction structure expression 
base case induction variable judgement bu derived 
empty constraint set impose restriction substitution 
defined domain assumption set 
substitution satisfy implies generic instance 
result judgement hm derivable 
inductive cases application lambda abstraction expressions 
subexpression induction hypothesis states bu valid 
words subexpression decorated assumption set constraint set type bottom rules 
secondly induction hypothesis expresses pairs meet condition imposed theorem type derived hindley milner inference rules expression type environment 
strategy construct proof remaining inductive cases follows 
firstly introduce arbitrary substitution type environment assume conditions hold 
secondly fulfil conditions subexpressions substitution possibly different type environment 
planning required choose right 
hindley milner judgement obtained subexpression 
thirdly combine judgements apply corresponding hindley milner inference rule get desired judgement 
expression hand function applied argument assume bu bu 
follows app bu bu holds 
consider substitution type environment satisfies dom 
general true satisfies satisfies subset result satisfies 
addition dom dom induction acquire judgement hm 
similar way hm obtained 
satisfy constraint syntactically equal 
observation conclude hm holds completes proof case expression application 
decorating body lambda abstraction bottom algorithm results judgement bu 
applying appropriate rule justifies bu 
consider dom dom satisfies 
assumption implies dom dom holds 
satisfies constraints types associated equivalent applying substitution 
words types introduced variables bound lambda abstraction unified 
satisfies notice monomorphic type right equal 
merging environments property yields satisfied induction get hm implies hm 
judgement bu inferred assuming declaration body expression judgements bu bu respectively 
consider substitutions type environments fulfil conditions 
induction get hm 
essential step prove rule sound observe satisfies generalize 
holds satisfies lemma generalizing type respect free type variables generalization respect free type variables sm 
induction get generalize hm hm concluded 
shown satisfiable constraint set implies existence hindley milner derivation result type 
turn complementary result prove completeness method successful hindley milner derivation method infer type general type derived hindley milner rules 
appendix detailed proof theorem 
theorem completeness hm bu exists proof consider collection typed expressions type environment 
expression construct derivation tree type root tree instance unique principle type scheme expression 
decorating expression bottom rules obtain judgement bu types independent derived hindley milner substitution satisfies constraint applied proof substitution bridges gap fact principal type scheme necessarily case hindley milner derivation 
proof proceeds induction structure expressions 
induction hypothesis somewhat stronger statement theorem 
condition satisfies fact satisfies sa words allowed modify 
third condition similarly simplifies proof 
expression single variable substitution satisfies conditions constructed straightforward way 
choose fresh type variable assigned bottom rules type returned hindley milner rules instance type scheme provided clearly satisfies empty constraint set satisfies 
substitution application constructed composing substitutions subexpressions additionally map fresh type variable range function type derived function expression 
domains substitutions independent type variables mentioned subtrees disjoint 
fresh type variable bottom rule lambda abstractions unify type variables assigned occurrences abstracted variable scope lambda 
substitution maps type variable type assigned variable extend 
type variables substitution obtained induction 
satisfies satisfies 
sufficient combine substitutions obtained declaration body fresh type variables introduced 
interesting condition verify composed substitution check satisfies created implicit instance constraints 
induction hypothesis results satisfies generalize body declaration 
generalizing equivalent lemma get satisfies generalize sm 
applying property results satisfaction conclude hm derivable returns general type expression type environment 
bool bool term graph bool bool unbiased constraint solving section nondeterministic algorithm solve set constraints constructed inference rules 
order constraints solved determines location type error detected reported 
process type inferencing dependency result bias 
section discuss alternative approach solve set type constraints bias 
method construction type graph inspired path graphs described port por 
construction type graph start replacing explicit instance constraints equality constraints 
type scheme instantiated results new type variables constraint set 
similar algorithm solve implicit instance constraint imposes condition dealt 
postpone discussing constraints handled graph 
consider solving set equality constraints 
type occurs equality constraint added directed term graph 
vertex corresponds subterm type constraint set 
composed type outgoing edge labelled vertex represents th subterm 
instance vertex represents function type outgoing edges 
occurrences type variable constraint set share vertex 
depicts term graph bool bool 
addition term graph second graph constructed set vertices identifies equivalence classes types 
undirected graph sub terms unified 
equality constraint edge added vertices correspond types constraint 
types equivalence class corresponding vertices connected 
equivalence composed types propagates equality subterms 
result add derived implied edges subterms pairwise fashion 
example constraint bool enforces equality bool 
add derived edge vertex vertex bool similar 
derived edge trace constraints responsible inclusion 
note adding edge result connection equivalence classes lead insertion derived edges 
bool bool bool bool bool bool bool bool int int int int int int int examples type graph example consider ill typed expression mentioned true false false extending expression language typing rules support conditionals results assignment type expression constraints int int int bool bool bool bool int shows equivalence classes constraint set indicated shaded areas 
graph combines term graph path graph contains kinds edges 
directed edges part term graph labelled child number 
second solid edges initial equalities correspond equality constraints set 
edges annotated constraint number constraint number appears exactly 
derived equalities depicted dashed lines 
instance edge type variable type constant bool result function types put equivalence class constraint 
equivalence classes connected components considering initial derived edges path graph 
discuss algorithm deal implicit instance constraints 
deal constraint free type variables occur type variables quantified fixed equivalence class consistent equivalence class going change handling remaining constraints 
implicit instance constraint replaced explicit instance constraint generalize sm substitution maps type variable representative equivalence class 
equivalence class contains composed type representative class 
type variables chosen represent 
type graph constructed unsatisfiable constraint sets 
contributes advantage graph unification algorithm solve traditional algorithms constraint set solved bias result imposed order unifications removed completely 
inconsistency show ways 
obvious case different type constructors equivalence class bool int 
error path path connects incompatible types equivalence class 
case topological ordering equality classes respect directed edges term graph indicates infinite type 
directed edge vertices equivalence class erroneous 
consider ill typed expression xx constraint set 
graph constraint set shown reveals infinite type 
heuristics report inconsistencies constraint error path removed restore consistency equality graph 
heuristics select edges removed graph produce appropriate error message 
traditional algorithms report unification error detected type graph allows reports possibly independent errors 
list number heuristics report inconsistency 
select ordering constraints report location type inferencer detects inconsistency 
example error paths 
constraint orders associated algorithms report respectively constraints complete error path 
removing break error path reflected fact replacing true branch value type int suggested error message remove type error 
wanted continue solving ordered constraints detecting reporting inconsistency 
approach johnson walz wj select type equation constraint set source error counting number occurrences type constructor equivalence class 
assign removal cost weight constraint compute maximal consistent set constraints total removal cost minimal 
paths compatible type constructors preserved possible 
expression reported type error message location expects program modified 
consequently replacing expression remove type inconsistency general type example represented conditional 
wan bs db deductive steps maintained interpreted construct sensible error message 
precisely constraints mentioned error paths contribute ill typedness expression claim information required analyses captured type graph 
mca describes different graph store information 
yang jun claims conflicting sites reported single location 
incorporate approach type graph requires tracing origin type constructor 
described method collecting constraints type inferencing shown solve 
proved method sound complete respect inference rules hindley milner 
important aspect method encompasses known algorithms corresponding certain orders collected constraints solved 
illustration combining heuristics generating suitable error messages constraint collecting bottom rules showed type graph constructed expression 
type graph generate multiple independent error reports sense optimal 
main formal algorithm proven correct investigate quality corresponding reported errors various heuristics 
plan including type inference algorithms haskell compiler developed group 
compiler includes large subset haskell excludes type classes shall mainly courses teach haskell novice functional programmers 
result hope obtain variety programs reflecting kind type errors novice functional programmers 
point investigation resources necessary implementing heuristic 
ideal situation user choose resources may spent finding error messages 
interested extending language 
important extension type system type constructor classes provide way overload functions 
type synonyms reported error messages increase understanding introduces new problems type system 
aik aiken 
set constraint program analysis 
science computer programming pages 
ber karen bernstein 
debugging type errors full version 
technical report state university new york stony brook november 
technical report 
bn baader nipkow 
term rewriting 
cambridge university press cambridge uk 
bs 
explaining type errors polymorphic languages 
acm letters programming languages volume pages december 
cho venkatesh 
diagnosis ill typed programs 
citeseer nj nec com diagnosis html 
db duggan bent 
explaining type inference 
science computer programming pages 
dm damas milner 
principal type schemes functional programs 
principles programming languages popl pages 
venkatesh 
correcting errors curry system 
vinay 
eds proc 
th conf 
foundations software technology theoretical computer science lncs vol 
springer verlag pages 
jun yang jun explaining type errors finding sources type conflicts 
greg michaelson phil hans wolfgang loidl editors trends functional programming pages 
intellect books 
ly lee yi 
proofs folklore polymorphic type inference algorithm 
acm programming languages systems july 
ly lee yi 
generalization hybrid polymorphic type inference algorithms 
proceedings asian workshop programming languages systems pages national university singapore singapore december 
mca bruce 
unification substitutions type inference 
kevin hammond anthony davie chris clack editors implementation functional languages ifl london uk volume lncs pages 
springer verlag september 
mca 
generalising techniques type debugging 
phil trinder greg michaelson hans wolfgang loidl editors trends functional programming pages 
intellect books march 
mil robin milner 
theory type polymorphism programming 
journal computer system sciences 
nik nikhil 
practical polymorphism 

jouannaud editor functional programming languages computer architecture pages 
springer verlag berlin de 
por graeme port 
simple approach finding cause non 
robert kowalski kenneth bowen editors proceedings fifth international conference symposium logic programming pages 
mit press 
martin sulzmann martin ller christoph zenger 
hindley milner style type systems constraint form 
research report university south australia school computer information science july 
wan wand 
finding source type errors 
th annual acm symp 
principles prog 
languages pages january 
wj walz johnson 
maximum flow approach anomaly isolation unification incremental type inference 
conference record th annual acm symposium principles programming languages pages st petersburg fl january 
soundness detailed proof theorem claim bottom type inference rules sound respect hindley milner rules 
give cases proof induction structure expressions 
variable consider bottom type inference rule bu var bu choose 
dom dom 
satisfies 
satisfies holds 
satisfies 

hm var hm application consider bottom type inference rule bu bu bu choose 
dom dom 
satisfies 
satisfies app bu holds 
dom dom 
satisfies 
satisfies property 
hm induction 
satisfies 

hm 
dom dom 
satisfies 
satisfies property 
hm induction 
hm app hm lambda consider bottom type inference rule bu bu choose 
dom dom 
satisfies 
satisfies abs bu holds 
dom dom 
satisfies 
satisfies property 
satisfies 
satisfies property 
satisfies property 
hm induction 
hm 
hm abs hm 
hm expression consider bottom type inference rule bu bu bu choose 
dom dom 
satisfies 
satisfies bu holds 
dom dom 
satisfies 
satisfies property 
hm induction 
dom dom generalize 
satisfies 
satisfies property 
satisfies 
satisfies generalize sm property 
satisfies generalize lemma 
satisfies generalize 
satisfies generalize property 
generalize hm induction 
generalize hm 
hm hm completeness detailed proof theorem claim bottom type inference rules complete respect hindley milner rules 
give cases proof induction structure expressions 
variable consider hindley milner type inference rule hm var hm assume 
holds 
bu var bu 
choose 
satisfies 


satisfies 
satisfies 
proof completed application consider hindley milner type inference rule hm hm app hm hm induction results 
bu satisfies satisfies 
bu satisfies satisfies holds 
bu app bu 
choose 
satisfies property 


satisfies 
satisfies 
proof completed lambda consider hindley milner type inference rule hm hm abs hm induction results 
bu satisfies satisfies ands holds 
bu abs bu 
choose 
satisfies property 
satisfies 
satisfies property 
satisfies property 
satisfies 
satisfies 
proof completed expression consider hindley milner type inference rule hm generalize hm hm hm induction results 
bu satisfies satisfies 
bu satisfies satisfies generalize holds 
bu 
choose bu 
satisfies property 
satisfies generalize 
satisfies property generalize 
satisfies generalize sm 
satisfies lemma 
satisfies property 
proof completed 
