automatic pool allocation disjoint data structures presents analysis technique novel program transformation enable powerful optimizations entire linked data structures 
fully automatic transformation converts ordinary programs pool aka region allocation heap data structures 
transformation relies efficient link time interprocedural analysis identify disjoint data structures program check data structures accessed type safe manner construct disjoint data structure graph describes connectivity pattern structures 
preliminary experimental results showing data structure analysis pool allocation effective set pointer intensive programs olden benchmark suite 
illustrate optimizations enabled techniques describe novel pointer compression transformation briefly discuss optimization possibilities linked data structures 

pointer intensive programs difficult challenge modern processor architectures memory hierarchies 
typical heap data structures produce access patterns worse locality dense arrays accessed regular pattern linear system address space 
furthermore addresses accesses difficult predict making prefetching difficult apply 
traditional optimizations generally focused optimizing individual data objects access patterns generally neglected take macroscopic approach analyzes transforms entire logical data structures 
high level optimizations generally limited runtime techniques clustering profile driven layout optimization cache conscious garbage collectors 
developed macroscopic approach optimizing linked data structures enable sophisticated compile time transformations entire data structures unsafe languages sponsored nsf career award number eia supported part nsf operating systems compilers program number ccr equipment donation hewlett packard 
chris lattner vikram adve university illinois urbana champaign lattner cs uiuc edu describes technique introducing fully automatic pool allocation heap allocated data structures general programs 
pool allocation manually programmers increase program performance pool allocators efficient general purpose allocators resulting allocation patterns better memory locality 
fully automatic pool allocation provides benefits provides compiler basis performing new transformations optimize entire logical data structures discussed 
pool allocation commonly applied manual optimization aware previous compiler automatically introduces pool allocation general programs programs malloc free 
existing techniques automatic pool allocation primarily runtime techniques heuristics segregate objects pools size type predicted lifetimes 
closest example uses profiling identify allocations short lifetimes places fixed size regions 
techniques generally take consideration connectivity allocated nodes provide basis new compile time transformations language support manual region allocation proposed macroscopic compile time transformations requires manually inserted annotations direct 
key automatic pool allocation transformation identifying logically disconnected data structures interconnection properties assign disjoint data structures different memory pools 
analysis described section identify logically disjoint data structures compute representation call disjoint data structure graph 
analysis construct graphs similar previous heap connection analysis shape analysis differs key ways discussed detail section :10.1.1.152.1240
perform data structure analysis subsequent transformations entirely link time compilation framework called llvm described briefly subsection 
link time appropriate place data structure analysis fundamentally interprocedural 
disjoint data structure graphs computed program transformed pool allocation described section 
transformation applied logical data structures accessed type safe manner 
graph data structure contains multiple different node types separate pool node type pool contains homogeneous objects necessary significantly speed allocation deallocation memory pool 
runtime system uses pool descriptors record rele called region allocation 
static compiler static compiler llvm llvm files llvm llvm libraries native optimizing linker vant bookkeeping information including connectivity linked pools 
compiler inserts code allocate destroy pool descriptors logical data structure instance root function entirely contains lifetime data structure 
compiler rewrites allocation deletion operations data structure allocate free heap objects appropriate pools 
entire memory pool pool descriptors released back system point data structure contains longer accessible exit root function 
section presents experimental results effectiveness data structure analysis pool allocation transformations 
disjoint data structure analysis combined automatic pool allocation enable sophisticated optimizations linked data structures compiler information allocation patterns locality properties nodes allocated pools 
briefly describe optimizations section including novel automatic pointer compression transformation evaluating transformations scope 
pointer compression technique addresses key problem bit architectures pointer intensive data structures pay significant penalty terms memory size cache efficiency memory bandwidth bit pointers 
transformation propose transparently safely replaces bit pointers logical pool allocated structure smaller bit offsets pool dynamically changes pointer sizes rewrites pool contents data structure grows 
goals implement evaluate pointer size compression optimizations enabled automatic pool allocation 
llvm compilation system implemented llvm compilation system 
llvm low level virtual machine compilation system designed support high level optimizations link time runtime offline compilation 
key idea llvm rich virtual instruction set raw machine code code representation manipulated link time optimizer code generator 
llvm instruction set uses low level risc operations provides rich information operands including extensive language independent type information dataflow information static single assignment form 
llvm compilation strategy depicted example function corresponding llvm assembly code shown 
llvm instruction set types low level represent programs source language enabling arbitrary source level compilers generate llvm object code machine code 
linked llvm code provides important information program machine code exe exe llvm native offline runtime optimizer profile trace info llvm system architecture compilation process optimized code host machine profile trace info type dataflow information 
important interprocedural optimization convenient link time source level compilation require significant changes development process complete nearly complete application source code available 
traditional compilation strategies manipulate low level machine code link time difficult perform high level analyses transformations due lack high level information 
written llvm backend gcc currently allows compilation llvm support near 
llvm infrastructure includes standard scalar optimization passes optimizing linker 
optimizing linker links different llvm object code files libraries compiled llvm object code performs interprocedural optimizations resulting program generates native machine code sparc architecture 
currently developing runtime offline optimizers shown diagram 
analysis transformations described implemented llvm optimizing linker 

data structure analysis automatic pool allocation requires program analysis exposes allocation pattern program connectivity graph allocated memory objects indicates transformation provably safe perform 
additionally analysis fundamentally interprocedural efficiently computable automatic pool allocation feasible practice 
data structure analysis graph representation solving problems 
implementation data structure analysis algorithm implemented context llvm system easily adaptable systems similar analysis capabilities 
data structure analysis directly applicable static link time compilers java bytecode microsoft common language runtime clr rich high level bytecode representations necessary analysis information extracted 
key analysis information follows ssa form assume low level code representation infinite set virtual registers load store architecture memory locations accessed load store operations 
virtual registers assumed ssa form memory locations 
assume fact commercial compilers export static compiler internal representation order enable sophisticated optimizations 
contrast llvm provides simpler elegant solution arbitrary compilers enabling sophisticated high level optimizations 
source code struct patient 
typedef struct list struct list forward struct patient patient struct list back list void list list struct patient pt list null list null list list list forward list list malloc sizeof list list patient pt list forward null list back forward list impossible take address ssa virtual register 
ssa form essential simplifies analysis register values killed allows efficient identification uses values 
identification memory objects assume compiler distinguish types memory objects heap objects allocated malloc stack objects allocated alloca global variables functions identify declared types object 
type information assume ssa variables memory objects associated type 
type system needs distinguish primitive types integer floating point pointers structures user defined aggregates arrays 
memory objects structure array types store malloc operations possible types 
ssa variables primitive pointer type 
safety information analysis requires way distinguish type safe type unsafe usage data values 
llvm operations including memory load store operations follow strict type rules illegal add integer floating point number perform arithmetic pointer type 
llvm includes instruction convert types adding integer float cast operations violate type safety underlying data values 
specific form instruction casting pointer type single way type unsafe operations performed llvm 
mechanism sufficient implement arbitrary unsafe code violations type safety trivial detect 
disjoint data structure graph disjoint data structure graph simply data structure graph primary representation access patterns function library program 
node graph represents typed ssa register memory object allocated program multiple objects type 
node represented node type described program type memory object llvm assembly code patient type 
list type list patient list void list list patient pt bb cond list list null br bool cond label bb label bb bb list phi list list bb list bb list load list list uint cond list list null br bool cond label bb label bb bb phi list list bb null bb list malloc list store patient pt list list uint store list null list list uint store list list list uint store list list list uint ret void function corresponding llvm assembly code set fields 
node contains field primitive pointer value contained object including fields nested structures 
array represented node single field analysis track individual array elements 
note ordinary pointer variable represented graph node single field uniformity 
edge graph connects pointer field node source field field node target field 
target edge represented node field index pair 
pointer field may edges multiple targets edges represent may point information 
practice pointer field usually single outgoing edge node merging technique described section 
finished analysis graph function defined shown 
construction running example explain data structure graph 
patient pt list list list new list shadow patient list list list list data structure graph list list data structure graph shows graphical notation illustrate analysis results 
graphs dark rounded objects represent actual memory objects exist program lighter objects represent scalar values function elliptical scalar values indicate incoming arguments 
pointer fields list type reflected directly data structure graph fields list memory object 
distinct node types distinguish different kinds objects 
new node represents memory allocated heap operation 

alloca node represents memory allocated stack current function instruction address automatic variable available 

global node represents memory occupied global variable 

function node represents function memory 
nodes serve targets function pointers 

call node represents call function 
contains field holding pointers node plus fields holding pointers formal arguments 

shadow node represents memory know exists don know allocated 

cast node represents memory non typesafe manner 

scalar node represent ssa registers pointer type current function 
nodes single field holds set memory objects scalar pointer may point 
assume impossible take address ssa register may edges pointing scalar nodes 
purposes analysis alloca new nodes treated identically referred allocation nodes 
global function nodes treated identically functions bodies global objects pointer fields 
shadow nodes special nodes represent cases memory allocated outside scope analysis referenced current function 
don know kind memory global variable allocation assign concrete node node 
data structure graph computed directly llvm source 
key goal analysis construct data structure graph function program identifying distinct logical data structures visible function 
pool allocation transformations important separate disjoint data structures distinct logical data structures conservatively merging 
reason analysis contextsensitive 
strengths analysis include identification disjoint data structures small analysis time concise summarization important information unified handling heap stack allocations clear splitting analysis intra inter procedural analyses 
splitting analysis different stages allows intraprocedural portion analysis performed separately module requiring interprocedural portion executed link time 
section describes intraprocedural analysis build initial version data structure graph procedure 
section describes interprocedural analysis compute interprocedural closure graph 
intraprocedural analysis algorithm intraprocedural graph computation phase flow insensitive analysis builds data structure graph requiring code functions available 
result algorithm data structure graph returned pointer set 
returned pointer set track pointers values may returned function computing interprocedural closure graph 
graph construction algorithm composed distinct phases node discovery phase worklist processing phase graph simplification phase 
analyses performed directly llvm code representation making extensive type information provided 
analysis flow insensitive ssa form inherently provides degree flow sensitivity reduces occurrence spurious edges graph 
node discovery phase node discovery phase performs single pass function processed creating nodes graph 
specifically generates node appropriate type function call allocation stack heap global variable referenced 
creates cast nodes represent unsafe pointer conversions scalar nodes ssa pointer registers 
shadow nodes created values point unknown values incoming pointer values return value function calls return pointers 
worklist processing phase add new shadow nodes edges graph nodes types come node discovery phase 
nodes generated ssa variables point new nodes example list variable outgoing edges updated uses ssa variables put worklist 
graph computed node discovery phase shown 
note fields allocated nodes outgoing edges scalar values list list list list new list list list shadow list patient pt shadow patient list list list graph node discovery list list worklist currently contains cond list list store instructions list pt 
worklist processing entry worklist processing phase algorithm node discovery phase created data structure nodes non shadow nodes shadow nodes function graph 
worklist contains instructions function ssa values corresponding nodes 
worklist processing consists popping instruction worklist adding edges data structure graph putting instructions worklist refer fields updated operations needed updating single scalar variable structure field captured functions described instruction remove instruction process describe effects primitive may worklist giving syntax operation short pseudocode update description 
addition instructions may calls pointer comparison operations worklist affect data structure graph ignored 
instructions processed follows field advance address structure field implemented simply advancing source pointers point new field 
pointers represented node field index pairs function simply increments portion pointer input set 
analysis ignores array subscripts effectively treating entire arrays single element 
conservative allows compact representation implementation difficulties 
storing pointer memory object adds edges emanating node fields pointed new type loading pointer memory updates scalar include contents field memory 
outgoing edge fields loading synthesize shadow node add edge field new shadow node 
ensures load instruction node point important sure edges lost graph 
ramifications technique discussed example 
ssa instruction merges values due control flow 
simply union pointer sets 
call func processing function call simply updates call node keep track accurate pointer sets passed parameters 
interprocedural closure stage described section 
cause worklist entries modified 
return adds nodes pointed return set function 
function returns set pointer values stored scalar node specified variable 
function updates scalar node corresponding specified variable include pointers set specified second argument 
causes scalar node change uses ssa scalar added worklist reprocessing graph simplification algorithm run scalar edges add uses add uses worklist edges add add new edges graph merge nodes section function identical updates fields memory objects pointed argument 
fields change loads refering structures added worklist graph simplification algorithm run 
example processing cond instruction op list instructions list instruction added worklist edge list shadow list node added 
processing list instruction load shadow node synthesized resulting graph shown additionally list instruction reinserted worklist 
shows data structure graph processing instructions list 
list list new list list list list list shadow list shadow list list list patient pt list shadow patient graph worklist steps point worklist contains list list store instructions list pt 
clearly uncontrolled creation shadow nodes lead infinite recursion processing list cause shadow node created due load empty field shadow node created iteration cause shadow nodes created ad infinitum 
prevent infinite recursion ensure data structure graph remains compact possible graph simplification algorithm merge nodes graph indistinguishable 
graph simplification algorithm list shadow nodes indistinguishable merged 
nodes considered indistinguishable llvm type node type shadow node field data structure graph points nodes 
nodes merged resulting node contains union edges original nodes preventing edges getting dropped graph 
additionally pointers original node get updated point new merged node similar approaches taken analyses :10.1.1.152.1240:10.1.1.11.3368
intuition heuristic pointer contains edges different nodes stores loads pointer cause effects edges added graph scalars updated field contents happen nodes time 
node eventually contain contents merged 
case list scalar points shadow nodes compatible llvm node type 
merging nodes causes edges connecting nodes self loop providing information connectivity 
important note summarization graph lose information 
example merging nodes lose information list points node 
dealing potentially infinite structures infinite time space resources perform form summarization 
practice information loss little importance data structure analysis 
results pointer analysis shown steensgaard algorithm significantly precise approaches uses similar merging technique 
difference attempting extract data structure connectivity information aliasing information 
pool allocation benefits graphs merged possible long disjoint structures merged 
shows data structure graph merging nodes processing store instructions add outgoing edges new node remaining shadow node 
patient pt shadow patient list list new list shadow list list list list list list graph node merging list list processing store function causes edge new node added shadow node 
field points indistinguishable nodes new node shadow node nodes merged yielding finished graph shown 
merging behavior important part analysis adding extra edges example introduced conservative heuristics graphs cause shrink size 
interprocedural closure algorithm local analysis graph limited usefulness program transformation interesting data structures passed functions construct manipulate example see 
interprocedural information impossible transform functions called functions may data structure ways reflected local data structure graph 
indicate function calls involved call nodes introduced local data structure graph shown 
data structure graphs called functions available call nodes eliminated replaced analysis information called function graph 
interprocedural closure algorithm process resolving call nodes graphs represent interprocedural information called functions caller function graphs 
general call node call instruction represents may able call multiple functions indirect call 
analysis handles simple uniform way 
functions considered global objects represented node data structure graph nodes field indicates functions called call node 
common case call single function directly may call shadow function function pointer passed current function may contain edges multiple functions indirect call 
graph node haven resolved function inline node resolve argument shadow nodes call parameters param resolve returned value union returned pointers unknown node points set edges add interprocedural closure algorithm interprocedural closure algorithm defined operates looping call nodes specified graph inlining called function graph place call node 
uses function resolve argument shadow nodes actual parameters passed 
analysis handles indirect call nodes repeatedly inlining called function graphs function called particular call node 
called function returns pointer return value set inlined function graph eliminate shadow node generated call node 
core interprocedural closure algorithm inline function 
graph inliner copies nodes graph specified function graph preserving edges nodes 
scalar nand alloca nodes inlined function discarded incident edges removed graph values represent scope referenced 
return value set set argument nodes inlined graph returned pair 
result inlining function call memoized avoid infinite recursion inlining recursive functions 
possible simply inline intraprocedural datastructure graph function inliner prefers inline interprocedural graph specified function available 
scenario graph unavailable inlining function call mutually recursive function case intraprocedural graph selected avoid infinite recursion 
get effect calculate interprocedural closure graphs postorder traversal call graph 
function merges node set nodes referenced pointer value eliminate shadow nodes 
function takes node argument set pointer values resolve 
node argument node captures return value call pointer argument inlined function resolved 
function operates algorithm merge node sets eliminating shadow nodes inserted node discovery phase 
example show interprocedural closure algorithm consider function void unsigned list malloc sizeof list list malloc sizeof list unsigned populate lists malloc sizeof patient malloc sizeof patient lists source function example function calls 
purposes discussion assume data structure graph graph 
case nodes intraprocedural data structure graph may resolved actual graphs correspond 
patient reg new patient call new list list call fn fn call new list list patient reg new patient graph inlining function graph call results patient list nodes resolve incoming arguments function 
graph inlined simplified see section merges existing shadow patient node patient node allocated function 
second call inlined identical manner producing finished graph shown 
patient reg fn list call new list new patient list new list new patient patient reg graph resolved calls example shows critical aspects algorithm differentiates existing 
incremental allowing programs analyzed brought 
case function translation unit allowing graph partially resolved compilation 
presumably function graph resolved link time 
second important property algorithm preserves disjoint data structures 
example disjoint linked lists conservatively merged just built function function allocates nodes list 
property important pool allocation means accurately allocate data structures pools 
list new list new patient patient reg list new list new patient graph patient reg third important property data structure graph function small including nodes reachable current function 
example assume function empty function resolve graph shown 
case know lifetime lists bounded lifetime function escape function 
consider function calls function lists reachable main graph call resolved 
reason nodes eliminated reflecting fact main exposed internal data structures 

automatic pool allocation researchers illustrated value pool allocating data structures fully automatic transformation challenging problem :10.1.1.23.5498:10.1.1.1.3704
describe simple algorithm automatic pool allocation programs uses data structure graph ensure safety transformation 
runtime support designed simple pool allocation runtime library external functions data type pool descriptor 
transform program pass pool descriptors functions allocate free nodes pool 
way pool descriptor available needed 
pool allocator assumes memory pool consists uniformly sized objects allocate multiple consecutive objects needed arrays 
pool allocating complex data structure example main data structure power benchmark shown data structure node graph allocated different pool memory 
simple heuristic groups memory objects type works tree nodes linked lists heavily recursive structures 
power benchmark example memory pools corresponding level heterogeneous tree structure level linked list nodes 
addition bookkeeping information pool allocator runtime pool descriptors augmented include pointers pool descriptors data structure form root reg new root new lateral new branch new leaf data structure graph root pool lateral pool branch pool leaf pool pool descriptor graph main data structure benchmark ing graph isomorphic data structure graph runtime including backedges forward edges 
benchmark graph shown 
graph runtime locate memory blocks allocated data structure traversing pool descriptors data structure inspecting bit cell pool 
information useful variety transformations example pointer compression algorithm described section 
identifying candidate data structures order pool allocate data structure detect bounds lifetime data structure allocate delete pools determine safe data structure 
data structure analysis graph purposes 
data structure graph detect data structures lifetimes bound function lifetime allowing allocate pool entry function deallocate exit function 
identify candidates scanning functions program function graph contains data structures function inspecting functions interprocedural data structure graph go 
lifetime data structure contained current function data structure subgraph unreachable edges due scalar pointer map globals point structure returned current function 
escape analysis similar points escape analysis conservative effective heuristic data structure lifetime 
refer function lifetime bounds lifetime data structure root function root subtree call graph needs modified handle pool allocation 
program function escapes candidate identification algorithm safe convert data structure pool allocation prove know allocation deletion points nodes data structure program data structure non typesafe way 
ensure analyzed relevant portions program accesses data structure contain unsafe operations simple traversal graph looking nodes 
portion program outside scope analysis unsafe operation pool allocation performed 
algorithm shown 
transforming function bodies data structure identified pool allocated root function modified allocate pool descriptors representing various nodes subgraph 
insert code stack allocate pool descriptor code initialize pool descriptor entry function code destroy pool descriptor bookkeeping information associated memory pool exit nodes function 
pools created body root function functions calls data structure transformed calls free instructions 
pool descriptor passed called functions available eventual calls 
algorithm shown 
function function instruction instructions elseif datastructure function transformation algorithm transformation loops worklist functions process transforming function worklist empty 
initially worklist seeded root function expanded call untransformed function encountered 
body function transformed rules malloc operations referring pool allocated data structure changed calls library functions 
function calls take pointer data structure argument return pointer part data structure modified pass pool descriptor data structure called function 
function processed put transformation worklist 
transformed function allocates memory pools data structure node disjoint data structures 
function transformed similarly 
problem modifying functions way possible cause exponential code growth functions cloned transformed 
example benchmark name loc primary data structure analysis time graph size primary 
ds size binary tree em lists arrays perimeter quad tree power hierarchy lists binary tree tsp tree matrix matrices table preliminary results olden benchmarks void unsigned pd pd pd pd list unsigned pd sizeof list pd sizeof list pd sizeof patient pd sizeof patient list pd list pd populate lists pa pd pd pa pd pd pa pd pd pd pd pd pd source pool client pool allocates linked list client copies code required 
practice implementation chooses pool allocate data structure functions refer data structure called pool allocated data structures 
note functions allocate free nodes call functions data structure need modified algorithm 

preliminary results fully implemented disjoint logical data structure analysis automatic pool allocation transformation llvm system 
performs fully automatic pool allocation data structure graphs including rewriting structure fields scalar variables pool allocation deallocation 
supports allocation structure heterogeneous nodes multiple pools 
tested transformations programs olden benchmark suite collection programs pointer prefetching studies 
preliminary results programs 
unfortunately codes relatively small allocates single large recursive data structure 
benchmarks cover full spectrum difficult issues including pointer intensive linked structures dynamic stack allocation pointers functions global variable heavy recursion 
aim test techniques benchmarks including spec benchmarks 
table shows results olden programs simple matrix multiply routine function operating matrices 
table shows compilation time benchmark including time data structure analysis pool allocation times nearly negligible benchmarks quite small 
programs compiler correctly able identify logical data structure top level program 
cases lower level functions tree allocate process disjoint subsets logical structures compiler correctly proves subsets disjoint reflected table 
interprocedural graphs computed toplevel function main relatively large nodes due calls external function printf global format strings passed calls 
primary data structure benchmark nodes nodes node benchmarks 
structure benchmark heterogeneous node types shown compiler correctly identifies linkages structures allocates separate pools noted previously 
order demonstrate capabilities compiler modified benchmarks follows 
potentially difficult usage pattern programs may allocate different structures repeatedly extract nodes structure insert 
structures reasonable candidates separate pool allocation 
test compiler case wrote simple code creates trees initializes values nodes trees loop traverses trees moving nodes 
compiler correctly able prove instances disjoint allocate trees separate pools 

applications primary benefit automatic pool allocation provides compiler basis performing aggressive data structure transformations entire linked data structures safely transparently 
transformations data structure graph knowledge pool allocation analyze optimize accesses data structures program compile time control layout data pools compile time runtime 
briefly discuss transformations describing pointer compression detail needed implement evaluate optimizations 
pointer compression small fraction data structures modern applications addressable objects significant fraction objects 
pointer intensive data structures bit architecture inefficient memory consequently memory bandwidth cache capacity 
example tree structure child pointers bytes data require bytes memory 
replacing bit pointers bit ones reduce memory consumption bit pointers reduce factor 
logical data structure analysis automatic pool allocation transformation possible replace pointers smaller index values pool 
simple transformation fixed bit indices generate runtime error single logical structure uses separate objects runtime 
rare potential errors may transformation unacceptable large applications 
robust aggressive strategy dynamically grow index sizes needed relocating pool rewriting indexes runtime 
strategy allow smaller bit offsets initially grow bit bit offsets needed 
major potential challenges transformation 
storage size pointer variable change runtime field offsets structures containing pointers longer compile time constants 
requires additional level indirection addressing structure fields potentially cause high runtime overhead major challenge achieving net benefits pointer compression 
second challenge object dynamically rewritten offsets grow size 
note happen times single logical data structure 
choose limit bit pointers reason 
describe basic transformation discuss briefly address challenges 
pointer size transformation logical data structure automatic pool allocation legal described previously potential candidate pointer compression transformation 
additional restriction impose pointers objects type may compressed objects type pool allocated necessarily pool 
ensures code dereference pointers 
assume objects single pool homogeneous different node types heterogeneous structures allocated different pools 
may possible objectoriented languages inheritance pool entries multiple gcd static sizes types pool 
homogeneous logical structure node type pool previous analyses identified static variables scalar variables structure fields array elements hold pointers nodes structure fields node 
variable type type recursive pool pool pointer simply change type variable hold index pool compile time integers size indices defaults bits 
pointer variable outside pool type replaced pair variables index ptr pointer carry information required decode indices 
transformation applies formal parameters type pool descriptor pointers passed indices function calls returns 
index size changed runtime simple transformations sufficient 
enable dynamic size changes complex runtime support address arithmetic needed 
pool descriptor augmented include array offsets field access number fields offsets clearly overheads access sequence overwhelm benefits transformation 
section describes optimizations crucial strategy practical 
section describes updated runtime pointer size change 
optimizing pointer dereferences propose optimizations performed compiletime achieve efficient structure field addressing presence dynamically changing field sizes 
accesses type type safe safely reorder fields move non pointer fields come pointer fields 
guarantees offsets non pointer fields pointer field compile time constants involve additional overhead ordinary pool accesses require terms address expression 
result accesses non pointer fields flat structures pointer structure zero overhead dynamic pointer compression 
second key optimization move field access calculations loops regions call graph allocate deallocate structure nodes 
pool allocation transformation identifies program points occur 
dynamic pointer size changes pool detects expanded index range grows addressable current index size rewrite locations contain indices pool objects simply traversing objects known types 
operation suffices pool contains pools easy find pointers pools containing 
pool descriptors updated record new offsets fields types contain pointers pool 
improved prefetching strategies major challenges optimizing accesses linked data structures effectively hide memory latencies prefetching 
key difficulty predict objects referenced explicitly loading chain pointer values called pointer chasing problem 
variety solutions proposed add history pointer structure node record allocation order expected traversal order linked data structures 
history pointers schedule prefetches objects expected accessed execution 
automatic pool allocation pointer compression transformations enable potentially valuable improvement prefetching strategies 
creation order prefetching history pointers key history pointer prefetching schemes previously proposed creation order prefetching history pointers record order nodes linked structure created runtime prefetch nodes order 
luk mowry suggested variant scheme call data linearization prefetching require history pointers relies placing consecutively created objects data structure consecutively memory remapping allocation describe compiler 
fact automatic pool transformation exactly needed implement scheme perform creation order prefetching adding history pointers data structures 
particular memory successively allocated objects pool allocated consecutive memory locations traversals linked data structure prefetch values accesses ahead arbitrary needing history pointers 
structures linkages modified initial allocation compiler easily detect previous analyses structures created repeatedly traversed order 
history pointer prefetching near zero memory overhead traversal order structure may match creation order history pointers kind order capture information expected traversal order 
pointer size transformation possible history pointer prefetching nearly zero memory overhead relative original application simply space saved data structure recording history pointers 
software history pointer schemes require compiler add extra pointer fields pointer data structure fields hold pointers elements data structure 
extra pointers stored current compressed format point time 
furthermore schemes know require extra pointer pointer original structure 
pointer compression schemes guarantee factor reduction memory usage pointer 
previous facts imply add history pointers compressed structure completely free memory overhead negligible space pool descriptors 
aware existing software schemes perform history pointer prefetching memory overhead 
automatic small scale parallelization small scale parallelism increasingly important key architectural trends including widespread multiprocessor servers processors emergence processors simultaneous multithreading chip multiprocessing fine grain explicitly parallel architecture epic itanium processor family 
techniques proposed potentially enable extract small degrees relatively coarse grain parallelism ordinary programs 
particular compiler proves logical data structures disjoint cross follows updates structures performed parallel computations structure values 
different style parallelism extracted parallelization strategies programs tree data structures 
strategies focus data parallelism computations data structure set structures obtain parallelism computations different structures 
yield small degrees parallelism parallelism may fact suited emerging systems described 

related rich literature pointer analysis techniques shape analysis data structures programs 
disjoint data structure analysis similar previous computing heap approximations path matrices static shape graphs heap storage 
key difference previous analyses previous approaches flow sensitive compute heap approximation shape graphs program point 
contrast compute single summary graph entire procedure 
means analysis 
significantly simpler interprocedural strategy previous papers generally perform dataflow analysis full interprocedural control flow graph iterative analysis call graph 
contrast build call graph interprocedural control flow graph 
handle direct indirect function calls simply additional memory objects summary graphs inline summary graph callee call site achieve simple powerful context sensitive analysis linear number call sites call edges program 
context sensitive pointer analysis techniques compute path graph approximation pointer reachability properties pointer variables heap objects :10.1.1.43.4867
techniques generally identify logically disjoint data structures probably extended 
example techniques single name represent heap objects particular allocation point 
compute alias relationships different pointer variables store approach attempt derive model heap storage :10.1.1.43.4867
cases algorithms probably extended fairly straightforward manner identify disjoint heap data structures 
believe automatic pool allocation transformation proposed algorithm programs containing explicit uses malloc free manage heap memory 
noted pool allocation widely applied manual technique 
language support developed simplifying allocation program annotations checking correctness pool usage enriched type systems 
previous automatically identifying regions memory ml type safe functional language side effects 
analysis sole primary means releasing dynamically allocated memory back system 
simplify problem execution scopes identify regions collections objects unreachable scope consider arbitrary region lifetimes 
contrast primary goal automatic pool allocation means enabling compiler optimizations linked data structures 
consequently key difference automatically introduce pool allocation wider range necessarily heap data structures including long lived structures arbitrary lifetimes type safe usage 
furthermore correctly handle programs rely explicit malloc free operations 
analysis information eliminate explicit data structure nodes choose 
allow program free objects pool release memory pool back system data structure unreachable 
broad class conservative program transformations attempt give better locality programs changing placement allocations memory 
contrast techniques approach uses exact assignment allocated objects pools 
approximate assignment algorithms provide locality properties seeking lack exact assignment unsuitable host aggressive transformations pointer compression 
knowledge previously published safe automatic compression pointer variables 
novel fact believe analysis linear size program reasonable assumptions structure fields nested structure types proving requires 
optimization enabled automatic pool allocation 
similar system described uses programmer annotations identify integers usually small pointers usually contain small offset current object 
requires program provide safety analysis hardware support efficiently access detect cases underlying values exceed allocated ranges 

novel transformation converts ordinary programs pool memory allocation 
transformation relies link time interprocedural analysis identify disjoint logical data structures program check data structures accessed type safe manner 
context sensitive interprocedural analysis simple quite efficient small summary graphs propagated procedures interprocedural information propagated callees callers function pointers handled uniformly memory pointers analysis analysis flow insensitive 
disjoint data structure analysis combined automatic pool allocation enable sophisticated macroscopic optimizations linked data structures 
described novel automatic pointer compression transformation briefly discussed optimization possibilities enabled 
key goal ongoing implement evaluate optimizations 

ayers de jong peyton schooler 
scalable cross module optimization 
acm sigplan notices 
zorn 
lifetime predictors improve memory allocation performance 
proc 
sigplan conf 
programming language design implementation pages albuquerque new june 
burke torczon 
interprocedural optimization eliminating unnecessary recompilation 
acm transactions programming languages systems toplas 
mckinley 
data flow analysis software prefetching linked data structures java 
international conference parallel architectures compilation techniques barcelona spain sept 

cheng mei hwu 
modular interprocedural pointer analysis access paths design implementation 
sigplan conference programming language design implementation pages vancouver british columbia canada june 
chilimbi davidson larus 
cache conscious structure definition 
sigplan conference programming language design implementation pages 
chilimbi larus 
generational garbage collection implement cache conscious data placement 
acm sigplan notices 

xl fortran ways boost performance 
white 
courts 
improving locality garbage collecting memory management system 
communications acm 
crary walker morrisett 
typed memory management calculus capabilities 
conference record popl th acm sigplan sigact symposium principles programming languages san antonio texas pages new york ny 
emami ghiya hendren 
context sensitive interprocedural points analysis presence function pointers 
sigplan conference programming language design implementation pages orlando fl june 
fern ndez 
simple effective link time optimization modula programs 
acm sigplan notices 
gay aiken 
language support regions 
proc 
sigplan conf 
programming language design implementation pages snowbird ut june 
ghiya hendren 
tree dag cyclic graph 
shape analysis heap directed pointers symposium principles programming languages pages 
grunwald zorn 
efficient synthesized memory allocators 
software practice experience 
elsman tofte 
combining region inference garbage collection 
sigplan conference programming language design implementation berlin germany june 
hendren nicolau 
parallelizing programs recursive data structures 
ieee transactions parallel distributed system pages 
larus hilfinger 
detecting conflicts structure accesses 
sigplan conference programming language design implementation pages july 
luk mowry 
compiler prefetching recursive data structures 
proceedings eighth international conference architectural support programming languages operating systems asplos vii boston usa oct 
rinard 
commutativity analysis new analysis technique parallelizing compilers 
acm transactions programming languages systems toplas 
roth sohi 
effective jump pointer prefetching linked data structures 
proceedings th annual international symposium computer architecture pages may 
sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
acm transactions programming languages systems jan 
seidl zorn 
segregating heap objects behavior lifetime 
proceedings eighth international conference architectural support programming languages operating systems pages 
acm press 
steensgaard 
points analysis linear time 
symposium principles programming languages pages january 
tofte birkedal 
region inference algorithm 
acm transactions programming languages systems 
tofte 
talpin 
region memory management 
information computation pages feb 
truong 
improving cache behavior dynamically allocated data structures 
proceedings international conference parallel architectures compilation techniques pact pages oct 
tullsen eggers emer levy lo 
exploiting choice instruction fetch issue implementable simultaneous multithreading processor 
proceedings rd annual international symposium computer architecture pages may 
vivien rinard 
pointer escape analysis 
sigplan conference programming language design implementation pages snowbird ut june 
wilhelm sagiv reps shape analysis 
proceedings cc th int 
conf 
compiler construction berlin ger mar apr 
wilson lam moher 
effective static graph reorganization improve locality garbage collected systems 
proceedings conference programming language design implementation pages 
acm press 
zhang gupta 
data compression transformations dynamically allocated data structures 
international conference compiler construction cc apr 
