mat tiny virtual machine sensor networks philip levis david culler pal culler cs berkeley edu computer science division intel research berkeley university california intel berkeley california berkeley california composed tens thousands tiny devices limited resources motes sensor networks subject novel systems problems constraints 
large number motes sensor network means failing nodes networks easy 
feasible method recharge motes energy precious resource 
deployed network reprogrammable physically unreachable reprogramming significant energy cost 
mat tiny communication centric virtual machine designed sensor networks 
mat high level interface allows complex programs short bytes reducing energy cost transmitting new programs 
code broken small capsules instructions self replicate network 
packet sending reception capsules enable deployment ad hoc routing data aggregation algorithms 
mat concise high level program representation simplifies programming allows large networks frequently reprogrammed energy efficient manner addition safe execution environment suggests virtual machines provide user kernel boundary motes hardware protection mechanisms 

wireless sensor networks pose novel problems system management programming 
networks hundreds thousands nodes limited energy individual resources reprogrammable response changing needs 
spectrum emerges simple parameter adjustments uploading complete binary images 
network bandwidth limited network activity large energy draw concise way represent wide range programs needed 
virtual machine natural way achieve characteristics sensor networks large numbers require approach distinct prior vm architectures 
traditionally virtual machines focused virtualizing real hardware intermediate program representation bytecode interpretation 
technique design goals advantages drawbacks 
generally focused traditional uniprocessor multiprocessor environments dealt bringing bytecode interpreters small consumer devices solution design hardware natively runs vm instruction set 
virtual machines tiny devices proposed de sign goals focused byte code verification online compilation 
sensor networks domain characterized resources orders magnitude smaller current virtual machines require 
example current sensor network nodes motes kb instruction memory kb ram virtual machine targets devices memory budget kb kb 
energy critical resource especially terms communication sending single bit consume energy executing instructions 
hardware software boundary individual mote currently topic open research :10.1.1.117.697
sensor networks distinct computing domains ways similarities parallel architectures distributed systems notably composed separate processing elements communicate 
course important differences opposed reliable message passing system parallel architectures sensor networks lossy irregular wireless networks 
content routing naming sensor networks examined bandwidth conservation borrows ideas active networks 
general approach active networks allow mechanisms arbitrary computation network 
growing interest data aggregation mechanism making precious sensor network bandwidth problem easily investigated active sensor network 
incremental code migration achieved xml motes lack ram store simple xml elements 
basic question sensor networks programmed remains largely unanswered 
spectrum exists minor application adjustments tweaking constants uploading entire programs binary images 
achieved tiny rpc mechanism handful packets requires sending kilobytes data high energy cost 
experience shown sensor network applications composed common set services sub systems combined different ways 
system allows compositions concisely described packets provide flexibility reprogramming transmission costs parameter tweaking 
establish wide range sensor network applica mote small particle dust motes hung slant sunlight anne tyler 
tions composed small set high level primitives built mat byte code interpreter run motes 
capsules instructions fit packet forward network 
complex programs ad hoc routing layer composed capsules represented bytes 
mat allows wide range programs installed network quickly little network traffic conserving energy 
show common class frequently reprogrammed systems energy cost cpu overhead bytecode interpreter outweighed energy savings transmitting concise program representations 
sections sensor networks tinyos operating system designed specifically sensor networks sections clear set requirements emerge mote reprogramming system 
section describes design structure implementation mat 
section evaluates system behavior performance 
section discuss evaluations mat draw 
full mat instruction set implementation beacon ad hoc routing algorithm included appendix 

sensor networks progression moore law led design manufacture small sensing computers communicate wireless network :10.1.1.117.697
research industry indicate motes networks hundreds thousands 
sensor networks distinct traditional computing domains 
design assumes embedded common environments corn field bathroom dedicated ones server room office 
mean time failure combined large numbers leads routine failure network easy interrupting operation 
compared infrastructure mobile systems power scarce valuable 
easily recharge laptop handheld recharging thousands motes finding 
difficult 
communication sensor networks precious computing domains 
sending single bit data consume energy executing instructions 
disparity led investigation passive networking systems 
additionally power cost producing sensor data orders magnitude lower cost transmitting rate production kbit sec mote far greater communicated network 
led investigation content specific routing network data aggregation centralized control data collection inefficient wasteful 
deployed motes easily collected reprogramming require physical contact 
able re task network analysis techniques environmental conditions evolve desirable 
example process deploying sensor network monitor storm mat mah tay mat tea beverage consumed mainly argentina uruguay southern brazil 
leaves perennial tree ilex mat 
name mat derives word means cup vessel drinking 
great duck island coast maine 
deploying motes involves placing possible nesting sites birds nest disturbing reach mote infeasible 
able monitor birds closely inches continuous periods biological research scientists unsure exactly frequency want network sense ability reprogram invaluable 
experiences working civil engineers similar issues programming 
monitoring building structures embedded motes expensive tasks earthquake damage assessment fast simple 
network useful wide variety tasks water damage detection sound propagation testing 
tasks anticipated installing software deployment time impossible additionally network embedded building motes unreachable feasibly 
able reprogram network quickly useful issues data aggregation adaptive query processing dynamically installing aggregation functions provide flexible system predefined set aggregates 
examining sample cases habitat monitoring building instrumentation query processing clear flexible rapid powerful reprogramming mechanism needed 
computation inexpensive comparison communication abundant 
example latest generation motes designed mica platform mhz bit processor 
individual mote perform large computations rapidly performed distributed manner 
scarcity ram network bandwidth inhibits algorithms depend global state ad hoc routing algorithms designed mobile computers 

tinyos tinyos operating system designed specifically sensor networks :10.1.1.117.697
combined family wireless sensor devices tinyos currently research platform institutions 
examining sensor network challenges limitations tinyos produces set requirements flexible concise sensor network programming model 
hardware rene mica mote hardware platforms rene mica currently available general development 
rene older correspondingly smaller resources 
complete family tinyos motes summarized table 
mica supports kbit communication radio rene limited kbit mica radio put kbit mode backwards compatibility 
mote platforms harvard architectures separate instruction data memory 
installing new binary code requires reset take effect 
change behavior tinyos program state transition program storm petrel genus 
habitat open ocean oceanic islands 
nests built burrows colonies oceanic islands 
mating hatching return open ocean 
mote type rene rene dot mica date microcontroller type ls atmega atmega prog 
mem 
kb ram kb nonvolatile storage chip lc db connection type spi size kb default power source type li alk li alk size cr xaa cr xaa capacity mah communication radio rfm tr rate kbps modulation type ook ook ask table family berkeley tinyos motes receives type packet start reading light data temperature modify source code recompile tinyos image place entire new image mote 
software architecture tinyos program composed graph software components 
component level tinyos computational abstractions commands events tasks 
commands call component graph example telling network component send packet 
events calls component graph example signaling packet sent 
traditional os perspective commands analagous events analagous upcalls 
tasks long running computations preempted events 
command event enqueue task perform computation immediately return 
tinyos schedules tasks fifo basis runs task completion task run preempt short 
task queue overflow new tasks posted 
tinyos supports high concurrency split phase non blocking execution 
command event blocks 
completion long lasting operations sending byte radio indicated issuing event send byte done 
non blocking operation allows form high concurrency distinct threaded model operations components interleaved fine granularity 
asynchronous behavior ultimately powered hardware interrupts 
tinyos provides high parallelism efficiency constrained somewhat tricky programming interface 
interface badly suited non expert programmers biologists civil engineers working deploy networks 
simpler programming model allows novice programmers express desired behavior worrying timing asynchrony greatly improve usefulness tinyos sensor networks 
tinyos networking active messages top level tinyos packet abstraction active message :10.1.1.23.716
characteristics abstraction important define capabilities systems built top 
am packets unreliable data link protocol tinyos networking stack handles media access control single hop communication motes 
higher layer protocols network transport built top am interface 
am packets sent specific mote addressed bit id broadcast address 
tinyos provides namespace types active messages associated different software handler 
am types allow multiple network data protocols operate concurrently conflict 
am layer provides abstraction bit am group allows logically separate sensor networks physically mutually invisible run application 
system requirements looking sensor network challenges limitations tinyos hardware set clear requirements emerge effective sensor network programming system 
small fit rene mica hardware targeting cutting edge mica users expressive able write wide range applications concise applications short conserve network bandwidth resilient applications crash mote efficient energy efficient sensing communication tailorable support efficient specialized operations simple programming entire network situ fast autonomous 

mat mat bytecode interpreter runs tinyos 
single tinyos component sits top system components including sensors network stack nonvolatile storage logger 
code broken capsules instructions single byte long larger programs composed multiple capsules 
addition bytecodes capsules contain identifying version information 
mat stacks operand stack return address stack 
instructions operate solely operand stack instructions control program flow embedded operands 
execution contexts run concurrently instruction granularity 
mat capsules forward network single instruction 
mat provides built ad hoc routing algorithm send instruction mechanisms writing new ones instruction 
designed mat run mica rene hardware platforms 
means mat subcomponents fit kb ram kb instruction memory 
outlines code data size breakdowns tinyos components mat mote 
architecture instruction set communication model mat vm architecture allows program send message single instruction sent message caller perspective automatically routed destination 
arrival packet automatically enqueues task process 
approach bytes mat code footprint vm mat network logger hardware boot scheduler bytes mat data footprint component code bytes data bytes vm mat network logger hardware boot scheduler total vm mat network logger mat component breakdown subroutines gets sets code clock events send receive operand pc stack mate return stack mat context hardware boot scheduler mat architecture execution model capsules contexts stacks strong similarities active messages machine :10.1.1.23.716
course important differences example reliably routing processors routes unreliable multihop wireless network 
tiny amount ram forces motes constrained storage model mat buffer messages tasks freely machine 
mat instructions hide asynchrony race conditions tinyos programming 
example send instruction issued mat calls command ad hoc routing component send packet 
mat suspends context message send complete event received point resumes execution 
doing mat need manage message buffers capsule resume network component done buffer 
similarly sense instruction issued mat requests data sensor tinyos component suspends context component returns data event 
synchronous model application level programming simpler far prone bugs dealing asynchronous event notifications 
additionally mat efficiently uses resources provided tinyos split phase operation mat behalf calling context allowing tinyos put cpu sleep freely 
mat stack architecture 
chose allow concise instruction set instructions specify operands exist operand stack 
classes mat instructions basic class class 
shows instruction formats class 
basic instructions include operations basic instruction class instruction argument class instruction argument mat instruction formats arithmetic halting activating leds mote 
instructions access memory structures messaging system message headers messaging layer state executed message send receive contexts 
class instructions pushc push constant branch equal zero 
class class instructions operand embedded instruction class bit index argument class bit unsigned value argument 
instructions usr reserved users define 
default ops 
class sensor network applications require specific processing outside capabilities mat complex data filter user instructions allow efficient domain specific instructions 
mat structured implementing instructions easy 
build specially tailored version mat efficient support common complex operations 
mat execution contexts illustrated correspond events clock timers message receptions message send requests 
inheriting languages forth context stacks operand stack return address stack 
instructions handling data subroutine calls 
operand stack maximum depth call stack maximum depth 
adequate programs written 
clock operand stack persists executions invocation left sensor reading top stack available invocation 
easy way implement internal clock timers section demonstrates 
clock capsule installed value zero pushed operand stack 
receive send contexts expect message received data send top stacks execution stacks persist invocations 
operands types values sensor readings messages 
instructions operate certain types 
example instruction expects value top operand stack 
instructions polymorphic 
example add instruction add combination types different results 
adding messages results appending data second operand operand 
adding value message appends value message data payload 
adding sensor reading value results sensor reading type increased value adding sensor readings different types light humidity just returns operand 
sensor readings turned values cast instruction 
single shared variable contexts word heap 
accessed sets gets instructions 
allows separate contexts communicate shared state timers 
experience far shown adequate unclear pushc push operand stack add add stored counter copy copy new counter value pushc take bottom bits copy set leds bits halt mat cnt leds shows bottom bits counter mote leds heap size feasible long term 
size easily increased having sets gets specify additional operand state address heap 
find situation necessary decided 
code capsules execution mat programs broken capsules instructions 
limit allows capsule fit single tinyos packet 
making capsule reception atomic mat need buffer partial capsules conserves ram 
code capsule includes type version information 
mat defines types code capsules message send capsules message receive capsules timer capsules subroutine capsules 
subroutine capsules allow programs complex fits single capsule 
applications invoke return subroutines call return instructions 
names subroutines keep mat ram requirements small current implementation 
mat begins execution response event timer going packet received packet sent 
events capsule execution context 
control jumps instruction capsule executes reaches halt instruction 
contexts run concurrently 
instruction executed tinyos task allows execution interleave instruction granularity 
additionally underlying tinyos components operate concurrently mat instruction processing 
subroutine called return address capsule instruction number pushed return address stack control jumps instruction subroutine 
subroutine returns pops address return stack jumps appropriate instruction 
packet receive clock capsules execute response external events contrast packet send capsule executes response instruction 
probably execute number mat instructions addition sending packet lengthy operation 
issued mat copies message buffer send context operand stack schedules send context run 
message copied calling context resume execution 
send context executes concurrently calling context preparing packet sending 
frees calling context handle subsequent events case receive context important 
constrained addressing modes mat instructions ensure context access state separate context 
push pop operand return value stack bound checks prevent overrun underrun 
single shared variable heap addressing pushc push operand stack sense read sensor light copy copy sensor reading gets get previous sent reading inv invert previous reading add current previous sent value pushc add curr prev jump send copy copy sensor reading inv invert current gets get previous reading add previous current pushc add curr prev jump send halt copy pc jump point sets set shared var current reading push message operand stack clear clear message payload add add reading message payload send send message halt mat program read light data send packet reading change problem 
unrecognized instructions result simple ops 
bounds checked way contexts share state gets sets 
capsules worst clog network packets case newer capsule inevitably heard 
providing constrained execution environment providing high level abstractions services network layer mat ensures resilient buggy malicious capsules 
simple mat programs mat program maintains counter increments clock tick 
bottom bits counter displayed mote leds 
counter kept value persists top stack invocations 
program alternatively implemented gets sets modify shared variable 
code simplest tinyos applications cnt leds implemented bytes 
mat program reads light sensor clock tick 
sensor value differs sent value amount example program sends data mat built ad hoc routing system 
program bytes long fitting single capsule 
code infection capsule sent packet contains type subroutines clock receive send version number 
mat receives version capsule specified type currently mat installs 
capsule transmitted motes forw instruction broadcasts issuing capsule network neighbors install 
motes issue forw execute capsule forwarding capsule local neighbors 
version information motes simple quick split long split rand sense call log send swap pots logr son mat instruction overhead classes new code ignore older capsules receive 
time new code disseminate logical network virus needs install single mote execute capsule 
correspondingly mote able run different version program threat reprogramming logically separate network 
versioning implemented bit counter allows single network long time centuries rapid reprogramming rates seconds 
capsule forward installed capsules forward instruction 
useful desired program composed capsules temporary clock capsule forwards capsule installed component capsule installed forwarded 
entire network installed capsules clock capsule replaced program drive application 

evaluation test expressiveness behavior performance mat implemented ad hoc routing algorithm measured rate instruction issue quantified cpu overhead measured network infection rates different capsule forwarding probabilities 
ad hoc routing ad hoc networking critical system issue sensor networks 
transient nature sensor networks means packet routing adaptive effectively collecting data network requires ad hoc routing algorithm 
ad hoc routing protocol included standard tinyos release implemented lines re implemented slightly simpler version mat demonstrate mat expressive provide similar functionality native tinyos code 
additionally dynamically installed network demonstrating mat transforms sensor networks active networks 
includes routing information packet transmits am broadcast 
messages forwarded root tree connected pc processing storage 
snooping traffic motes hear packets sent motes find suitable routing tree parent 
packet contains fields address source mote address destination mote hopcount source 
hopcount tree root zero 
motes try minimize hopcount tree 
maximum hopcount prevents disconnected graphs sending packets perpetual cycles 
parent heard interval mote chooses new parent 
complete mat code packet format frame format included appendix native tinyos version maintains table possible parents mat version keeps track 
gets get counter get buffer clear clear buffer add append count send send packet pushc sets clear counter gets jump point pushc add sets increment counter pushc branch average 
loop executions mat ips loops mat simple loop ips calculation operation mat clock cycles native clock cycles cost simple rand quick split sense long split mat bytecodes vs native code instruction issue rate instructions sending packet take time 
contains rough breakdown cost classes mat instructions 
instructions add merely manipulate operand stack minimal additional processing 
second class instructions call commands components mat 
tinyos commands return quickly calling function obviously cpu cost 
classes instructions perform split phase tinyos operations instructions include cost tinyos event handler plus latency command corresponding event 
sense short order microseconds 
send forw involves packet sent takes roughly milliseconds kbit radio 
determine cost issuing instruction mat wrote program executes tight loop instructions seconds 
code clears previous count sends packet containing count instructions 
mat normally sole control processor running 
example tinyos network stack handles interrupts khz find packet start symbols khz reading writing data 
measure mat raw performance turned tinyos radio running mat timing loop 
loop counts calculated number mat instructions executed second 
instruction loop simple add branch push constant 
ips calculated executing loop measures approximate mat overhead imposed instruction opposed overhead calling components split phase operations 
average mat ips instructions second just 
precisely quantify overhead mat places native code compiled small operations native mote code compared cost native mat implementations 
obviously mat instructions impose higher overhead encapsulate high binary mat application size bytes install time capsules instructions sens rfm gdi comm test application installation costs level tinyos constructs efficient perform simple arithmetic operations nearly 
comparative instruction costs 
selected instruction cost classes rand sense send 
mat implementation native instruction count logical words packet send 
logical operation takes cycles random involves popping operands pushing contrast random pushes single operand 
approximately third mat overhead due instruction executed separate tinyos task requires enqueue dequeue operation 
ran loop code determining ips mat task executed instructions 
average ips jumped quantifies task operations roughly mat overhead 
indicates tradeoff mat concurrency performance adjusted different applications 
energy mat computational overhead poses energy overhead mat execute additional instructions interpretation 
concise representation programs represents savings energy full binary uploads programs contained handful packets hundreds 
overhead data previous section compute energy overhead mat execution data native code 
gives comparison size different tinyos programs binary code capsules 
application test mat version larger representing cooperation subsystems implements new 
uploading installing kb binary programs requires mote fully active roughly minutes cost scales linearly size 
comparing binary programs equivalents mat calculate relative energy costs installation 
energy cost execution energy cost installation systems calculate point approaches preferable 
small number executions mat preferable energy cost cpu overhead tiny comparison savings having awake receive single packet 
large number executions native code preferable savings execution overcomes cost installation 
example consider application currently deployed great duck island 
application spends time deep sleep mode power draw roughly 
seconds application wakes reads sensors sends packet containing sensor data 
cpu overhead mat duty cycle gdi application energy cost installing native image mat version running days save energy binary version 
running days energy cost mat cpu overhead grows percent infected network infection rates time seconds percentage motes running new program time network new time complete infection seconds greater cost installing binary version gdi program 
relative energy costs suggest clear mat energy constrained domains 
interpretation overhead implementing complex applications entirely mat wasteful infrequent invocations tiny energy cost capsules reconfigure native execution application modifying sample rates sensors sample provides greatly improved flexibility lower energy cost installing new application 
building new rpc mechanism application control configuration applications mat capsules general rpc engine 
network infection measure network infection rates deployed node network grid 
radio transmission radius formed hop network depending mote cells varied motes size 
figures contain data collected network infection behavior 
shows rate motes network starting running new program 
experiment configured mote run clock capsule seconds 
introduced mote network ran newer self forwarding clock capsule 
seconds recorded motes running new program new program changed led pattern mote displayed 
ran experiment times averaged results 
curve converge percent mote network mote time reprogram long time resistant new viral capsule 
inspected mote loose antenna re reprogrammed similarly motes 
shows time healthy network took fully reprogrammed 
experiment capsules varying probabilistic forwarding rates 
trial configured network clock capsule ran second forwarded certain probability 
introduced mote network new clock capsule self forwarded probability 
measured elapsed time mote introduced entire network infected new program 
performed infection times 
percentages probabilities capsule forward run 
values forwarding probability running network forwarding probability introduced capsule 
columns forwarding rates running network rows forwarding rates introduced capsule 
entry table shows mean time infection standard deviation infection runs 
chose probabilistic scheme prevent mote synchronization artificially inflate network contention 
increasing forwarding rate capsule increase rate program infects network diminishing returns 
example increasing forwarding probability eighth fourth halved time network infection increasing nearly notable effect 
drastically higher time infection networks forwarding capsules due network congestion 
radio support roughly packets second backoff encoding maximum cell size network approximately capsule forwarding second resulted network going past saturation point 

discussion presence interpreter dynamically loaded code qualitatively changes behavior usage model wireless sensor networks 
discuss ramifications change phased programming network interactions static dynamic layers capsule forwarding system architecture directions 
phased execution agility active sensors ease installing new code mat means programs transition states written series capsules 
example sense report cycle network write capsule sensed environment placing data non volatile storage log instruction 
data acquisition complete inject new program reads stored data entries logr instruction sends network collected 
lightweight nature capsules excellent candidates mechanism experimenting sensor network application agility great duck island case example 
currently mat executes capsules response types events 
imagine extending mat contexts capsules associated richer set activating primitives 
active networks ran code response network events possibility running easily code response things sensor thresholds signal detection real world actuation expands idea active network node active sensor 
capsule forwarding results network reprogramming experiments establish application control propagation rate undesirable 
obviously efficient possibilities tag capsules forward 
capsule tagged mat broadcast capsule rate appropriate network density effectively adapting forwarding rate network sustain 
necessarily slow rate programming dense network motes hear forwarded capsule sparse 
issue gets fundamental limitation current tinyos design motes actuate network send packets mechanism sense busy network tinyos included mechanism mat provide mechanisms message merge capsules called ask application aggregate data buffers sending data rapidly network handle 
additionally instruction allows mat construct logical networks top single physical network changing mote am group id raises question logically separate networks running different applications share common infrastructure ad hoc routing layer 
current tinyos am group mechanism prevents system implemented 
architectural directions motes currently traditional user kernel boundary enforced hardware protection mechanisms badly written application component cause tinyos fail 
mat interface solves problem program things disable interrupts write arbitrary memory locations 
need user land vm land provide guarantees applications 
mat contexts smaller hardware contexts allocating multiple stacks impossible rene putting harsh limits call depth 
size surprise motes hardware support virtual memory 
mat provide functionality equivalent benefits virtual memory system brings 
virtual machine mat provide virtual address space 
swapping backing store suspended programs provided mote non volatile storage 
motes enter low power sleep states ram powered restore execution context waking possibly running different version mat 
currently mat instructions reserved user specific operations 
instructions user instructions part mat binary image defined mat installed changed 
subroutines allow execution flexibility mat overhead means non trivial mathematical operation infeasible 
able load binary code user instructions manner similar subroutines greatly improve mat fact motes harvard architectures prevents effectively safely implemented 
mat efficiently tailorable situ motes unified data instruction memory capability execute instructions data memory 

sensor networks widely adopted easy 
defined set system requirements ease sensor network programming tiny virtual machine mat meets requirements 
mat small expressive concise programs resilient failure provides efficient network sensor access tailored specific domains quickly self program network 
effectiveness mat execution model suggests virtual machines promising way provide protective hardware abstractions application code sensor networks fulfilling traditional role operating system 
clearly autonomous nature viral reprogramming significant possibly novel security measures taken protect network 
application composed static organization components evolve slowly mat network dynamic flexible easily reconfigurable 
suggests mat participate management networks addition platform application development 
mat focuses areas applicationspecific virtual machines user land abstraction 
currently looking application specific mat flavors identified domain requirements 
addition toplevel interface mote programming vm sit tinyos components computational engine certain domains 
example developed version named provide execution engine system miniature query processor data aggregation system sql queries network 
current state mat architecture bytecodes step develop higher level languages programming models application development providing user land programming environment distinct tinyos 
acknowledgments members tinyos group hardware software development efforts 
specifically robert szewczyk providing table suggesting idea viral reprogramming 
supported part defense department advanced research projects agency national science foundation california micro program intel 
research infrastructure provided national science foundation eia 

smart buildings admit faults 
lab notes research college engineering uc berkeley 
coe berkeley edu html 
small times big news small tech 
www com edouard bugnion scott devine mendel rosenblum 
disco running commodity operating systems scalable multiprocessors 
proceedings sixteenth acm symposium operating systems principles 
david culler anurag sah klaus schauser thorsten von eicken john wawrzynek 
fine grain parallelism minimal hardware support compiler controlled threaded machine 
proceedings fourth international conference architectural support programming languages operating systems 
lloyd 
small virtual machines survey 
proceedings workshop virtual computer systems 
wolfgang emmerich mascolo anthony finkelstein 
implementing incremental code migration xml 
proceedings nd international conference software engineering 
deborah estrin ramesh govindan john heidemann satish kumar 
century challenges scalable coordination sensor networks 
proceedings acm ieee international conference mobile computing networking 
kevin mills stefan leigh andrew 
expressing meaningful processing requirements heterogeneous nodes active network 
proceedings second international workshop software performance 
john heidemann fabio silva intanagonwiwat ramesh govindan usc isi deborah estrin deepak ganesan ucla 
building efficient wireless sensor networks low level naming 
proceedings th acm symposium operating system principles 
jason hill david culler 
wireless embedded sensor architecture system level optimization 
intel research irb tr 
jason hill robert szewczyk alec woo seth hollar david culler pister :10.1.1.117.697
system architecture directions networked sensors 
ninth international conference architectural support programming languages operating systems 
victor hsu joseph kahn pister 
wireless communications smart dust 
electronics research laboratory technical memorandum number 
chalermek intanagonwiwat deborah estrin ramesh govindan john heidemann 
impact network density data aggregation wireless sensor networks 
technical report university southern california computer science department 
chalermek intanagonwiwat ramesh govindan deborah estrin 
directed diffusion scalable robust communication paradigm sensor networks 
proceedings acm ieee international conference mobile computing networking 
java platform micro edition technology creating mobile devices white 
java sun com docs java card technology 
java sun com products javacard richard johnsson john wick 
overview mesa processor architecture 
proceedings symposium architectural support programming languages operating systems 
joseph kahn randy katz pister 
century challenges mobile networking smart dust proceedings acm ieee international conference mobile computing networking 
philip koopman jr modern stack computer architecture 
system design network architecture conference 
tim lindholm frank yellin 
java virtual machine specification second edition 
addison wesley 
samuel madden michael franklin joseph hellerstein wei hong 
tag tiny aggregation service ad hoc sensor networks 
submission 
samuel madden shah joseph hellerstein raman 
continuously adaptive continuous queries streams 
proceedings acm sigmod international conference management data 
alan mainwaring private communication 
milojicic fred douglas yves richard wheeler zhou 
process migration 
acm computing surveys volume issue september 
charles moore geoffrey leach 
forth language interactive computing 

michael deborah wallach william dally 
machine multicomputer architectural evaluation 
proceedings th international symposium computer architecture 
brian noble satyanarayanan narayanan james eric jason flinn kevin walker 
agile application aware adaptation mobility 
proceedings sixteenth acm symposium operating systems principles 
charles perkins elizabeth belding royer samir das 
ad hoc demand distance vector aodv routing 
ietf internet draft draft ietf manet aodv txt november progress 
adrian perrig robert szewczyk victor wen david culler tygar 
spins security protocols sensor networks 
proceedings mobicom 
phillip stanley iftode 
scylla smart virtual machine mobile embedded systems 
proceedings rd ieee workshop mobile computing systems applications 
robert szewczyk private 
david tennenhouse david wetherall 
active network architecture 
computer communication review vol 
april 
thorsten von eicken david culler seth goldstein klaus schauser :10.1.1.23.716
active messages mechanism integrated communication computation 
proceedings th international symposium computer architecture 
david wetherall john guttag david tennenhouse 
ants toolkit building dynamically deploying network protocols 
ieee 
alexander wolf dennis heimbigner john knight devanbu michael gertz antonio carzaniga 
bend don break reconfiguration achieve survivability 
third information survivability workshop october 
appendix complete mat instruction set follows mat implementation ad hoc routing protocol 
mat isa clear stack push push push signed push signed push depends types bit cmd bit push push copy top stack pop push sensor send send capsule message header routing data frame destination address source address hopcount parent address hopcount parent heard 
message header frame layouts push const push message push pull entry clear don pop turn turn push stable storage read line msg read line msg set shared variable push shared variable push bit random number stack push push call swap forward code capsule forward capsule user instruction user instruction user instruction user instruction user instruction user instruction user instruction user instruction set group id push potentiometer setting set radio potentiometer set clock counter set clock freq return subroutine xxx push short xxx msg header xxx push byte xxx msg header xxx push short xxx frame xxx push byte xxx frame xxx short xxx msg header xxx byte xxx msg header xxx short xxx frame xxx byte xxx frame bf xxxxxx push xxxxxx unsigned xc ff xxxxxx jump xxxxxx clock capsule pushc add copy keeping counter copy value pushc timer clock ticks inv add timer hasn expired skip flush check jumps call pop parent flush check code get rid old timer pushc reset timer pushc call call subroutine check parent flush pushc jump point branch sense clear add read light sensor put value message send message send capsule pushc pushc pushc create bit pattern toggles red led halt message send pushc neq parent parent won branch parent parent ll skip sending get short frame parent addr set short header destination addr id set source field short header addr get hopcount set hopcount field header pushc create am broadcast addr send packet broadcast pushc turn green led halt jump point branch message receive pushc call pushc call check sender new parent pushc call current parent flag parent heard get addr packet id eq branch halt re destination pushc turn green led send packet am broadcast halt subroutine parent set hopcount pushc eq parent parent jump ret pushc pushc set hopcount ret subroutine change parent 
inv add msg hopcount greater equal hopcount jump ret set parent addr source addr packet pushc add set hopcount hopcount source ret subroutine flag parent heard 
eq parent jump ret pushc set heard parent flag frame pushc add set hopcount parent hopcount ret subroutine flush parent 
pushc eq heard parent skip parent clear pushc clear parent pushc set parent heard pushc pushc inv create add skip hopcount pushc inv set parent parent far root ret 
