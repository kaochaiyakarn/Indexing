extensible algebraic datatypes defaults matthias zenger swiss federal institute technology inr lausanne switzerland matthias zenger epfl ch major problem writing extensible software arises recursively defined datatypes operations types extended simultaneously modifying existing code 
introduces extensible algebraic datatypes defaults promote simple programming pattern solve known problem 
show possible encode extensible algebraic datatypes object oriented language new design pattern extensible visitors 
extensible algebraic datatypes successfully applied implementation extensible java compiler 
technique allows reuse existing components compiler extensions need adaptations 

extensibility problem extensibility problem extensively studied :10.1.1.100.5370:10.1.1.123.4403:10.1.1.128.7169
paraphrased follows recursively defined set data operations add new data variants new operations variants changing duplicating existing code 
academic question 
extending system modifying source code error prone task 
furthermore creating extended system duplicating source code results duplicated maintenance costs old new system going 
cases possible apply source code modifications parts system available binary form 
example consider representation lambda terms trees variants lambda apply variable eval operation trees 
possible extension consider adding variants number plus term type 
extension consider adding operation prints term 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp september florence italy 
copyright acm 
martin odersky swiss federal institute technology inr lausanne switzerland martin odersky epfl ch traditional object oriented functional approaches extensions dimension easy extensions dimension hard 
object oriented approach data modelled set classes sharing common interface 
lambda term example interface class term specifying eval method subclasses lambda apply variable 
subclass defines implementation eval 
extending datatype new variants simply done creating new classes adding new operations involves modifications base class 
hand functional approach variants datatype typically implemented algebraic type 
defining new operations easy 
just writes new function matches data variants 
ordinary algebraic datatypes extended modifications source code possible add new variants 
approaches encode 
direction object oriented languages model functional approach visitor design pattern 
direction objects represented functional languages closures algebraic datatype messages parameter 
encodings exchanges strengths weaknesses approach strengths weaknesses encoding gains simultaneous extensibility data operations 
extensibility subclassing object oriented approach extensible modifying source code allow type casts 
adding new operation extend common variant interface new operation 
lambda example define extension interface term adds print method 
consequence variants subclassed provide implementation new operation 
want invoke new operation cast receiver extended type 
instance invoke print method variable type term uses print 
able access new operation 
approach supports extensibility data functions 
adding new function tedious requires variants subclassed 
krishnamurthi felleisen friedman show apply similar coding scheme functional approach support variant extensions 
describe composite design pattern extensible visitor keeps visitors open extensions 
new variant class added existing visitors subclassed order support new variant 
runtime error appear soon old visitor applied new variant 
variants operations extensible 
time adding new variant requires visitors subclassed 
extensible visitor pattern complex error prone implement hand special syntax proposed specifying extensible visitors 
preprocessor translates specifications object oriented programming language 
pattern comparable krishnamurthi felleisen friedman described gagnon hendren 
explain add new variants operations extension reuse operations discussed 
summary subclassing techniques provide extensibility previously missing dimension rely type casts require possibly extensive adaptation code 
extensibility default cases practice appears quite operation defines specific behaviour variants variants subsumed default treatment 
operation reused modifications extended type new variants properly treated existing default behaviour 
fact experience implementation extensible java compiler shows sort application majority existing operations reused extended types section presents statistics 
case extending system techniques section cumbersome cases just map operation new variants default behaviour 
able specify default case function operating extensible type function adapted situations new variants require specific treatment 
technique improve code reuse significantly 
previously mentioned approaches able handle default cases datatype function definitions tightly coupled specified interface partner completely 
solution extensibility problem new notion extensible algebraic datatypes defaults 
describe extensible algebraic types context object oriented language 
approach smoothly combines object oriented extensibility subclassing overriding type safe pattern matching algebraic datatypes known functional programming languages 
inspired algebraic types offered pizza superset java :10.1.1.26.1697
extensible algebraic datatype derive extended types new variants addition ones defined original type 
types enable solve extensibility problem functional fashion definition datatype operations type strictly separated 
extensions operation side completely orthogonal extensions datatype 
addition adding new variants operations support extending existing variants datatype modifying existing operations 
furthermore applying existing operations new variants possible operations extensible algebraic types define default case 
extensibility achieved need modifying recompiling original program code existing clients 
show possible encode programs extensible algebraic types languages just objects subtyping java 
encoding takes form new design pattern extensible visitors default cases 
pattern difficult implement hand decided include direct support extensible algebraic types extension java 
extensible algebraic types heavily design implementation extensible java compiler jaco 
jaco projects rapidly implement language extensions java 
implementation projects showed notational convenience afforded default cases important 
statistics taken compiler extensions indicate average quarters functions operating algebraic types reused extended types modifications 
extensible algebraic datatypes allowed reuse functions having add adaptation code 
rest organized follows 
section presents simple programming protocol explains extensible algebraic datatypes defaults solve extensibility problem 
section discusses various aspects extensible algebraic datatypes detail 
section gives encoding extensible algebraic datatypes visitors 
section discusses experience gained extensible algebraic types design implementation extensible java compiler presents statistics level code reuse system 
related reviewed section 
section concludes 

extensibility algebraic datatypes typical example extensibility problem plays significant role implementation extensible interpreters compilers 
wrong design limits extensibility complicates task extending system 
section algebraic datatypes derive programming pattern writing extensible interpreters 
start small language consisting variables lambda abstractions lambda applications 
declaring algebraic types syntax introduced programming language pizza :10.1.1.26.1697
algebraic datatype defining syntax tree nodes example language class term case variable string name case apply term fn term arg case lambda string name term body algebraic type term declares constructors variable lambda apply language constructs 
define simple interpreter evaluates terms call value evaluation strategy dynamic scoping 
interpreter class contains single method eval implements operation evaluating term 
pattern matching distinguish different variants term type eval method 
pizza uses switch statements perform pattern matching objects algebraic type 
class interpreter term eval term term env env switch term case variable string return env lookup case apply term fn term arg switch eval fn env case lambda string term body return eval body env bind eval arg env default throw new error function expected default return term approach straightforward add new operations type term interpreter simply defining methods 
code adds method transforms term string class formatter void tostring term term switch term case variable string return case apply term fn term arg return tostring fn tostring arg case lambda string term return tostring default return unknown come problem adding new variants term datatype 
proposes extensible algebraic datatypes defaults solve problem 
types enable define new algebraic datatype adding additional variants existing algebraic type 
declaration extended term datatype defines new variants number plus class extends term case number int val case plus left right definition introduce new algebraic datatype consisting constructors variable apply lambda number plus 
think extensible algebraic datatype algebraic type implicit default case 
extending extensible algebraic type means refining default case new variants 
example new type inherits variants term defines additional ones 
refinement notion new variants subsumed implicit default case term 
section shows notion turns subtype term 
subtype relationship crucial code reuse allows apply functions original type terms containing nodes extended type 
existing functions perform pattern matching original variants extended variant handled default clause switch statement 
current eval method default clause simply returns node numbers additions get evaluated eval operation 
support evaluation new variants adapt interpreter accordingly 
subclassing interpreter class overriding eval method 
class extends interpreter term eval term term env env switch term case plus left right return number left env right env default return super eval term env int term env env switch eval term env case number int val return val default throw new error number expected example shows provide implementation plus variant 
variants delegate method call overridden method 
freshly introduced numbers handled properly overridden method 
new interpreter additional method projects number terms integers throws exception term number 
code fragments demonstrate expressiveness extensible algebraic datatypes context objectoriented language java 
able extend datatypes operations completely independent uniform way 
extension dimension enforce adaptations dimension 
pattern matching statements new variants simply subsumed default clause existing operations reused extended datatypes 
operations defined locally single place 
conventional object oriented approach distribute function definition classes making difficult understand operation 
approach supports modular organization datatypes operations orthogonal extensibility mechanism 
technique section extended interpreters derived existing ones simply subclassing 
differences implemented subclasses 
rest reused original system touched 
refer form software development programming difference 

principles extensible datatypes section review type theoretic intuitions extensible algebraic datatypes defaults 
usually algebraic types treated sum types variants 
classical sum types straightforwardly extended adding new variants 
extension yields subtype relation reverse extension relation extensions supertypes original type 
subsection review concepts argue induced subtyping relation useful writing extensible software 
refine section model subtyping extensible sums algebraic types include default cases 
effect reversing original subtype relation bringing sync extension relation 
extensible sums algebraic datatypes modelled sums variants 
variant constitutes new type tag tuple component types 
instance consider declaration class case 
case 
defines sum type consisting variant types components 

respectively 
denote set variants algebraic type example 
describe extensions algebraic types introduce partial order algebraic types 
holds extends adding new variants 
priori algebraic extension relation independent subtyping relation 
setting defined explicitly type declarations 
example code defines algebraic datatype extends additional variant class extends case 
new type described set variants inherited variants 
extended algebraic type get 
standard typing rules sum types subtype variants variants example original type subtype extended type summarizes relationships types 
algebraic datatypes depicted boxes variants displayed round boxes 
arrows highlight subtype relationships 
specifically outlined arrows represent algebraic type extensions arrows connect variants algebraic types belong 
unfortunately subtype relation extensible sum types opposite practice 
imagine term type class term case number int val case plus term left term right adding new variant ident yield new algebraic type 
class extends term case ident string name supertype term represent sum identifiers plus variant 
variant expects terms arguments variant ident included term type 
words extensible sums support open recursion definition datatype 
classical way describing algebraic types fixed set variants provide extensibility way need 
extensible algebraic types defaults order turn extended types subtypes keep set variants open extensible algebraic type 
achieve adding default variant algebraic datatype subsumes variants defined extensions type 
set variants extensible algebraic datatype equation 
inherited default inherited yi default extensible algebraic type defined disjoint variant sets inherited default 
inherited includes inherited variants algebraic type extending denotes new cases default subsumes variants extensions 
understanding variant sets types section look default default 
default captures default default subset default 
subtype tempted believe 
identify types closer look definition default reveals default subsumes variants extensions variants extension contained default covered default 
illustrated algebraic class declaration class extends case 
extension algebraic type completely orthogonal case included default element default 
consequence default proper subset default extended type proper subtype subtyping alternative extensions algebraic types proper subtype reasons types incompatible 
subtype relationships example illustrated 
boxes represent extensible algebraic datatypes round boxes represent variants 
subtype relationships depicted arrows 
extending algebraic datatype means creating new type subtype old inherits variants old 
furthermore new type may define additional variants 
dashed arrows connect inherited variants algebraic type get inherited 
approach extended algebraic types subtypes types extend 
existing functions applied values extended types 
new variants simply subsumed default clause pattern matching construct 
interesting observation looking different extensions single algebraic type example 
incompatible supertype 
separation different extensions direct consequence single inheritance extensible algebraic type extend single algebraic datatype 
extending type yields extended algebraic types share variants incompatible 
course possible extend extension algebraic type class extends case 
algebraic type extends defines additional variant 
shows resulting subtype relations 
compilation extensible algebraic types defaults previous section pointed extensible algebraic datatypes defaults subject single inheritance algebraic type extend single algebraic datatype 
restriction enables efficient compilation pattern matching extensible algebraic types conventional technique sealed datatypes 
conventional compilation scheme assigns unique tags variant algebraic type 
pattern matching simply implemented switch tags 
extensible algebraic datatypes defaults variants tagged subsequent numbers starting number equivalent number inherited variants 
subtyping linear extensions algebraic types doing tag variants algebraic type number 
observe different extensions algebraic type section may share tags 
extensions single algebraic datatype yield incompatible types issue usually cause problems 
pattern matching statements mix variants incompatible extensions split separate pattern matching statements dynamic typecheck selects statements 
implemented efficient version compilation scheme extensible java compiler jaco 

visitor encoding object oriented languages algebraic encoded visitor design pattern 
krishnamurthi felleisen friedman extended design pattern enable extensibility 
section take approach adding support default cases 
programming pattern models extensible algebraic types purely object oriented language small differences discussed section 
start review standard visitor pattern 
code fragments section written java 
design pattern visitor visitor design pattern models algebraic types classes 
variants algebraic type represented subclasses define fields variant corresponding constructor 
operations encapsulated visitor objects 
visitor object contains overloaded method visit variant implements operation specifically variant 
able apply visitor variant defines accept method 
methods take visitor invoke appropriate visitor method 
visitor framework example section 
show code variant variable 
variants term type encoded analogously 
interface visitor void visit variable term void visit apply term void visit lambda term class term void accept visitor class variable extends term string name variable string name name name void accept visitor visit 
concrete operations implement visitor interface provide mechanism passing arguments returning results 
various solutions possible 
technique visitor invocation new visitor object gets created 
visitor constructor stores arguments fields inside visitor 
public field res result operation stored 
implementation eval uses anonymous visitor visit apply term method applying lambda abstraction argument 
refer formal parameter term inside anonymous class java requires mark parameter final 
class eval implements visitor private env env public term res eval env env env env void visit variable term res term void visit lambda term res term void visit final apply term eval eval new eval env term fn accept eval eval res accept new visitor void visit variable throw new error void visit apply throw new error void visit lambda eval new eval env term arg accept eval new eval env bind res body accept res res visitor interface describes datatype variants 
interface fixed possible add new variants 
side adding new operations easy creating new visitor implementation 
extensible visitors default cases show derive extensible visitor design pattern default cases 
operations default cases applied extended algebraic datatypes 
provide generic treatment variants datatype extension 
visitor framework model default cases additional visit method visitor interface 
interface visitor void visit term term void visit variable term void visit apply term void visit lambda term code fragments section new code highlighted italics 
term class defines generic implementation method accept calls default case visitor 
standard visitor pattern variants override method calling visit method 
class term void accept visitor visit class variable extends term string name variable string name name name void accept visitor visit 
note accept methods class term variable syntactically identical different visit method called 
far additional default case visitors default implementation accept method setting extensible visitor framework identical standard pattern 
look implementation concrete visitors 
want visitors extensible possible subclass visitor order override existing methods add visit methods new variants 
standard visitor pattern created new visitor visitor application 
example code implemented recursive call visitor eval lines eval eval new eval env term fn accept eval extensible visitors hard coded visitor creation anymore consider fact extension eval 
scheme proposed felleisen friedman visitor object provide factory methods creating non anonymous visitors visitor object 
extensions supposed override factory methods 
extensible visitor implements eval operation 
compared version previous section added default visit method factory method creating instances eval 
factory method gets invoked recursive operation call visit method lambda applications 
class eval implements visitor protected env env public term res eval env env env env eval env env return new eval env void visit term term res term void visit variable term res term void visit lambda term res term void visit final apply term eval eval env term fn accept eval eval res accept new visitor void visit term throw new error function expected void visit variable throw new error function expected void visit apply throw new error function expected void visit lambda eval env term arg accept eval env bind res body accept res res going extend system adding new variants number plus 
creating intermediate class xterm extends old term class 
new variant classes direct subclasses xterm 
approach type xterm subsumes new variants 
update visitor interface accordingly 
extended interface inherits methods original visitor interface defines additional visit methods number plus variant 
code shows extra default visit method 
explain default methods term xterm variants going 
focus attention class xterm 
class term class defines accept method time takes calls corresponding default case 
note method override inherited accept method 
new accept simply overloads existing 
variants override new accept method order call specialized visitor method 
code fragment summarizes framework described 
additional extends clauses code extending algebraic type completely analogous defining new algebraic type 
interface extends visitor void visit xterm term void visit number term void visit plus term class xterm extends term void accept visit class number extends xterm int value number int value value value void accept visit 
quickly verify possible apply existing visitor eval term structure containing variants extended type 
xterm variants xterm override accept method term default visit method visitor gets invoked desired case 
rest section provides missing piece puzzle looking extensions existing visitor classes eval 
sure visit methods extended variants called default method original visitor 
explained variants extended types automatically get original default method refining dispatch order incorporate visitor new visit methods 
overriding default visit method extended visitor 
overriding method performs new dispatch refined term type 
purpose insert type cast xterm tells typechecker class going extend eval visitor specifically 
defer discussion type cast full pattern explained 
override default visit term term method class visitor provide new default visit xterm term method keep visitor open extensions 
cases new method just refer default method super visit 
class extends eval implements void visit term term xterm term accept void visit xterm term super visit term void visit number term super visit term void visit plus term 
trace back different method calls visitor application verify extended visitor behaving desired way 
term term new plus new number new number term accept new env initial accept invocation refers accept method class term dynamic type term plus override accept method 
method accept class term calls visit term term method visitor 
argument term gets cast xterm new dispatch accept performed 
java strategy finding best overloaded method refer method accept time 
method overridden plus dynamic type term automatically visit method plus 
illustrates full sequence method calls visitor application 
full implementation extended eval visitor 
slightly different approach implementing evaluation plus variants compared version extensible algebraic datatypes section 
class extends eval implements env env super env eval env env return new env void visit term term xterm term accept void visit xterm term super visit term void visit number term super visit term void visit plus term class implements int res void visit term throw new error void visit xterm throw new error void visit plus throw new error void visit number res value new eval eval env term left accept eval eval res accept eval env term right accept eval eval res accept res new number res term accept new env class eval implements visitor void visit term term 
class extends eval implements void visit term term xterm term accept void visit xterm term void visit plus term 
class term void accept visitor visit class xterm extends term void accept visit class plus extends xterm void accept visit 
sequence method calls visitor invocation protocol section possible implement extensible datatypes visitors objectoriented language 
datatype extensions require adaptations existing visitors 
provide default case variants added 
possible extend existing visitors modify treatment existing variants refine default case new set variants 
approach completely decouples datatype extensions extensions operations 
extensible algebraic types comparison contrast source level extensible algebraic types extensible visitor pattern opens possibility runtime errors type cast extended concrete visitor class 
programs adhering design pattern type cast fails try apply extended visitor incompatible datatype extension 
instance apply variants extension term get runtime error 
handles variants term xterm extension xterm 
extend datatype linearly introducing branches type cast fail runtime 
pattern matching dispatch differs slightly extensible algebraic types extensible visitors 
extensible visitor technique visit method variants term double dispatch 
variants xterm need double dispatches proper visit method extended visitor called 
general variants th datatype extension need double dispatches 
look back extensible algebraic datatypes 
analogous situation 
extension operation implemented overriding old operation 
new operation matched new variants forwarded call old operation existing variants 
extensions need total single method dispatches pattern matching statements 
order dispatched variants reversed 
solution extensible algebraic types variants latest extension matched 
extensible algebraic datatypes flexibly practice need observe special implementation pattern section 
main weaknesses described design pattern 
complicated implement full protocol hand 
furthermore presence anonymous local classes visitors heavy weight constructs imposing lot implementation programmer 
reason decided direct language support extensible algebraic datatypes java 
allowed implement efficient pattern matching scheme briefly introduced section 
extensibility issues extensible algebraic datatypes extensible visitors achieve simultaneous extensibility types operations 
approaches main limitation extend system linear way new extension explicitly refers previous name 
possible merge orthogonal extensions 
restriction linear extensions explicit extensible visitor approach type cast fixes visitor extension specific extension branch 
switch statement extensible algebraic types restriction 
allows pattern matching variant extended type 
instance switch statement switch selector type term match variants extension term 
term eval term term env env switch term case variable string name case number int val default 
flexibility seen advantage disadvantage 
regret loss type security possible apply eval method datatype extension term designed 
course model behaviour extensible visitors extensible algebraic type approach introducing explicit type cast 
term eval term term env env switch term 
practice experience problems issue 
applications extensible algebraic types extensible compilers interpreters happened alternative extensions single algebraic datatype simultaneously 
experienced extensions extensible compiler formulated orthogonal way 
linearity restriction really limit way extended system 
emphasized approach extensibility dimension require adaptations dimension due presence default cases 
improves code reuse significantly section show 
hand type system detect cases operation needs refinement 

experience extensible compilers originally motivated project aimed implementing extensible java compiler :10.1.1.18.6194
time today popular experiment various language extensions java 
unfortunately implementing language extensions turned difficult time consuming task suitable compiler infrastructure missing 
compiler prototype available implementation new language features done ad hoc fashion hacking copy existing compiler 
doing implementation new features original version get mixed 
extended compiler evolves independent system maintained separately 
opposed destructive reuse source code developed framework extended compilers reuse components predecessors define new extended components touching predecessor code 
extended compilers derived existing ones simply subclassing 
differences implemented subclasses 
extended compilers derived existing base compiler share components base compiler 
approach created compiler infrastructure provides basis maintaining compilers 
main difficulties implementation compiler representation syntax trees extensible fashion 
java compiler rigorous object oriented architecture demonstrated disadvantages classical object oriented approach implementing syntax trees compiler phases 
object oriented approach compiler phase gets distributed code 
difficult understand extend 
adding new passes pain explained section 
standard visitors provide ideal solution allow extensibility variants 
tend heavy weight syntactically 
extensible algebraic datatypes offered needed extensibility datatype extensibility operations light weight pattern matching construct supports nested patterns 
allowed apply functional programming style object oriented language 
object oriented features mainly providing extensibility subclassing overriding 
furthermore implement extensible component framework gluing different components compiler flexible extensible manner 
jaco extensible java compiler implementation extensible java compiler jaco extensive extensible algebraic datatypes 
jaco plain java compiler support extensible algebraic datatypes possible compile jaco 
jaco compiled extension supporting extensible algebraic types 
complicated bootstrapping process quite bit 
version jaco implemented pizza offers algebraic types 
modified pizza compiler allow restricted form extensible algebraic types 
modified pizza compiler extended jaco extension supported restricted form extensible algebraic types introduced pizza 
step able compile jaco extension implemented full support extensible algebraic types described 
years utilized extensible java compiler successfully various projects 
language extensions implemented maintained 
implementations compiler java synchronous active objects proposed 
extension introduces chi compound types type aliases 
addition added operator overloading java programming language style proposed gosling 
eugster guerraoui damm implemented domain specific language extension supporting publish subscribe primitives top jaco 
exotic extension jaco implementation small language join calculus 
replaces syntactic analyzer pass full compiler join calculus generates java syntax tree output 
tree fed remaining java compiler generate java bytecodes 
extension jaco basically backend compiler language common java 
implementation extensions mentioned modify base compiler single time 
architecture open support sorts extensions needed far 
changes base compiler related minor modifications specification java programming language bugs compiler 
changes usually elaborated way binary compatibility java classfiles broken 
consequence compilers derived base compiler benefit immediately changes inherit 
java late binding mechanism necessary recompile derived compilers 
jaco pico 
lines code 
classes 
algebraic types 
algebraic type extensions 
visitors 
visitor extensions 
visitors reused 
visitors extended types jaco 
visitors extended types 
visitor extensions extended types 
visitors extended types reused table statistics extensible compiler jaco derived compilers code reuse jaco extensions table shows data regarding base compiler jaco compiler extensions pico written zenger extends jaco adding extensible algebraic types written extends jaco compound types type aliases written synchronous active objects compiler 
row table shows code size base compiler extensions lines code including comments 
data show extensions reuse large parts base compiler unchanged 
rows state number classes algebraic types algebraic type extensions compilers consideration 
base compiler jaco contains algebraic types 
types represent syntax symbols types constants 
furthermore implementation backend uses items enable delayed code generation 
extensions jaco extend syntax tree type 
extends symbol type representation 
data rows supposed give indication different compiler extensions benefit extensible algebraic types 
row labelled visitors gives number methods contain pattern matching construct 
analogy visitors methods relatively conservative approximation counts methods multiple switch statements single visitors 
row labelled visitor extensions shows number methods override method pattern matching construct supertype 
row labelled visitors reused lists number visitors base compiler reused extension overridden 
number extension difference number visitors jaco number row 
instance pico extension defines visitors override visitors jaco 
pico incorporates visitors base compiler changing 
derived compilers extend algebraic types jaco left unchanged 
assess usefulness default cases visitors need disregard algebraic data types unchanged 
line table shows number visitors base compiler match types subsequently extended derived compiler 
line shows number visitors derived compiler match extended types 
line gives number methods override visitor method extended type 
line gives difference lines shows number percentage visitors extended types reused 
note lower bound code reuse data show method counted line overrides method base compiler counted line method defined derived compiler counted line 
data show pico defines visitors extended syntax tree type override tree visitors base system 
tree visitors reused refining default case new variants 
refine default case visitors extended types 
numbers better 
compiler reuses tree visitors base system adapting 
statistics indicate extensible compiler project operations default cases help improve code reuse enormously 
default cases update single operation corresponding datatype extended 

related language ml proposals support extensibility algebraic types 
polymorphic variants algebraic type constructor belong algebraic datatype particular 
need anymore define algebraic type specific variant 
type inference infer admissible variants 
polymorphic variants programming style possible results precise types 
functions defined pattern matching clause default case possible pass existing variant necessarily function intended 
due fact possible declare algebraic types variant constructor belongs 
presents alternative solution extensibility problem polymorphic variants 
solution precise types provide default cases operations 
supports modular organization datatype extensions 
combining datatypes necessary re define function order forward call previous implementations 
ocaml supports polymorphic variants version 
proposal ml contains generalization sml exception types 
extensible types introduced order tag objects support runtime dispatch type safe 
seen extensible form algebraic types 
extensible type described initial variant constructor 
extending type means refining variant 
extended variant subtype previous 
pattern matching construct possible match variants common supertype giving programmer ability define typecase facility 
possible implement programming protocol types ml extensible types provide slightly weaker typing support deriving extended datatypes existing types 
possible add new variants existing type specializing variant 
type section formulated 
ml extensible types refinement object ml design reppy riecke 
literature extensibility algebraic datatypes discussed context building modular interpreters functional programming languages 
existing approaches allow restricted form extensibility algebraic types extensible final datatype closed 
furthermore extensions datatypes require updates existing functions support new variants due lack default cases pattern matching constructs 
hand approaches support combination orthogonal extensions 
basically holds mixin modules proposed duggan 
open classes proposed clifton leavens chambers millstein offer extensibility default cases object oriented approach :10.1.1.100.5370
open classes allow user add new methods existing classes modifying existing code breaking encapsulation properties 
open classes datatype modelled superclass variants concrete subclasses 
new operations specified external top level methods 
default case form method superclass 
specific behaviour variant provided method overridden variant 
open classes get extensibility data operations extensions dimension require modifications 
practice open classes suffer drawbacks 
new operation typically defined external top level method single compilation unit extending modifying existing operation done explicitly subclassing affected variants overriding corresponding methods 
leads inconsistent distribution code making difficult group related operations separate unrelated ones 
furthermore extending modifying operation entails extensions datatype 
restricts complicates reuse 
instance accessing extended operation context original operation implemented straightforward way 
languages equipped multiple dispatch offer functionality 
instance multijava introduces multimethods java :10.1.1.100.5370
type safety multijava requires default implementations generic methods 
programming protocol similar solve extensibility problem 
hand multimethods support deep pattern matching syntactically heavy weight flexible apply switch statements 
context java furthermore difficult compile multiple dispatch efficiently 
dispatch costs linear number methods dynamically overload method 
palsberg jay generic visitor design pattern offers way completely decouple datatype function definitions 
generic visitors flexible extend 
generic visitors rely reflective capabilities underlying system approach lacks static type safety subject substantial runtime penalties 

classified solutions extensibility problem degree possible code reuse 
plain object oriented functional solution allow extensibility datatypes operations source code modifications 
subclassing type casts extensions possible touching source code 
depending approach extension datatype side entails extensions existing operations vice versa 
solution extensibility problem operations provide default case handles extensions require adaptations operations new datatype variants 
introduced extensible algebraic datatypes facilitate simple programming protocol supporting extensibility default cases 
extensible algebraic datatypes allow freely extend datatypes operations simultaneously independently 
novel design pattern extensible visitors default cases showing possible encode similar programming protocol object oriented language 
pattern rely additional language features complicated implement hand 
extensible algebraic datatypes designed implemented extensible java compiler 
experimenting programming language extensions extensible compiler essential rapidly implementing language extensions 
extending compiler require source code modifications 
extended compilers evolve existing ones simply subclassing 
share components predecessors technique provides basis maintaining systems 
statistics show extended compilers reuse large parts base compiler unchanged 
extended compiler reuses average operations extended algebraic types base compiler adaptations 
number shows default cases contribute significantly level code reuse 
years extensible compiler framework various projects quickly implement new language extensions java 
acknowledgments special christoph zenger michel numerous helpful discussions 
furthermore stewart david stephane christian damm 
implemented extensions jaco provided feedback implementation 

appel cardelli crary fisher gunter harper leroy lillibridge macqueen mitchell morrisett reppy riecke shao stone 
principles preliminary design ml march 
chi 
compound types java 
proc 
oopsla pages october 
cardelli wegner 
understanding types data abstraction polymorphism 
computing surveys december 

synchronous java compiler 
projet de 
cole polytechnique rale de lausanne switzerland february 
clifton leavens chambers millstein :10.1.1.100.5370
multijava modular open classes symmetric multiple dispatch java 
proceedings oopsla volume pages october 
cook 
object oriented programming versus data types 
foundations object oriented languages rex school workshop noordwijkerhout netherlands volume pages 
springer verlag new york ny 
duggan 
mixin modules 
proceedings acm sigplan international conference functional programming pages philadelphia pennsylvania may 
eugster guerraoui damm 
objects events 
proceedings oopsla tampa bay florida october 
findler 
modular interpreters 
unpublished manuscript carnegie mellon university june 
findler flatt 
modular object oriented programming units mixins 
proceedings acm sigplan international conference functional programming icfp volume pages 
flatt 
programming languages reusable software components 
phd thesis rice university department computer science june 
fournet gonthier 
reflexive chemical machine join calculus 
proc 
rd acm symposium principles programming languages pages jan 
gagnon hendren 
sablecc object oriented compiler framework 
proceedings tools august 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 

programming polymorphic variants 
ml workshop september 

code reuse polymorphic variants 
workshop foundations software engineering japan november 
gosling 
evolution numerical computing java 
sun microsystems laboratories 
java sun com people jag fp html 
gosling joy steele bracha 
java language specification 
java series sun microsystems second edition 
isbn 
krishnamurthi felleisen friedman 
synthesizing object oriented functional design promote re 
european conference object oriented programming pages 
leroy doligez vouillon 
objective caml system release documentation user manual april 
liang hudak jones 
monad transformers modular interpreters 
symposium principles programming languages pages january 

extensible algebraic datatypes prototypes subtyping 
unpublished 
odersky philippsen 
distribution 
ira uka de espresso dec 
odersky wadler :10.1.1.26.1697
pizza java translating theory practice 
proc 
th acm symposium principles programming languages pages january 
palsberg jay 
essence visitor pattern 
technical report university technology sydney 

case synchronous objects compound bound architectures 
unpublished 
cole polytechnique rale de lausanne 
philippsen zenger 
transparent remote objects java 
concurrency practice experience november 
reppy riecke 
simple objects standard ml 
proc 
acm sigplan conference programming language design implementation pages philadelphia pennsylvania 

mixin composition strategies modular implementation aspect weaving epp preprocessor module description language 
aspect oriented programming workshop icse april 
wadler expression problem 
discussion java genericity mailing list december 
wirth 
compiler construction 
addison wesley 
zenger 
jaco distribution 
epfl ch jaco 
university south australia adelaide november 
zenger 

master thesis university karlsruhe august 
zenger odersky 
implementing extensible compilers 
proceedings ecoop workshop multiparadigm programming object oriented languages pages budapest hungary june 

compound types java 
projet de 
cole polytechnique rale de lausanne switzerland june 
epfl ch jaco html 
