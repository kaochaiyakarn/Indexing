older garbage collection practice evaluation java virtual machine darko matthew hertz stephen blackburn kathryn mckinley eliot moss dept computer science university new mexico albuquerque nm darko cs unm edu dept computer science university massachusetts amherst ma cs umass edu dept computer science australian national university canberra act australia steve blackburn cs anu edu au dept computer sciences university texas austin austin tx mckinley cs utexas edu best performing copying garbage collectors generational policy repeatedly collects youngest objects copies survivors older space infrequently collects older space 
previous study simulation pointed potential improvements older copying garbage collection algorithm 
algorithm sweeps fixed sized window heap older younger objects avoids copying youngest objects sufficient time die 
describe examine implementation older algorithm jikes rvm java 
investigation shows older perform simulation results suggested greatly improves total program performance compared nursery generational collector 
compare older flexible size nursery generational collector nursery occupies heap contain older objects 
comparisons flexible nursery collector occasionally better average older collector performs best 

garbage collection object oriented programming languages automates memory management relieves programmers source errors burden explicit memory management 
objects die quickly generational copying collectors divide heap generations 
collect youngest objects frequently copy survivors progressively older generations 
heap fills collect older generation younger generation 
generational collectors prematurely copy youngest objects object needs time die 
older supported nsf itr ccr nsf aci darpa ibm 
opinions findings recommendations expressed material authors necessarily reflect sponsors 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
copyright acm 
copying garbage collector exploits observation avoiding collecting youngest objects 
organizes heap order object age collects fixed size window slides heap older younger objects 
heap full older collects window compacts survivors logically place returns free space nursery positions window collection objects just younger survived 
bumps allocation point resets window oldest heap 
previous describes range implementation possibilities older collector 
presents garbage collection simulation results show performs better fixed size nursery generational collector 
describe implementation java ibm jikes rvm performing system 
variety execution results validate simulation model compare execution times copying ratios generational collectors explore pause times range times collection total collection time tradeoff 
results show older delivers promise outperforms tuned fixed size nursery generational collector average java programs wide range heap sizes 
show improvements due reduced copying costs 
experiments flexible nursery collection introduced appel consistently performs better fixed size nursery collector :10.1.1.10.2911:10.1.1.10.2911
results show programs studied better generational collector beats generational collectors maximum pause time generational collectors collect heap 
proceed section overview design decisions implementation part garbage collector toolkit ibm jikes rvm java 
section give details experimental setting section gives comparative performance evaluation collector respect throughput section respect garbage collection pause times 

design implementation older collector older collector organizes heap object age 
collects fixed size window slides heap older younger objects 
heap full collects window free space available allocation positions window collection objects just younger survived 
bumps allocation allocation survivors design older collector point resets window oldest heap 
scheme illustrated shows allocation region copy region considered queues window size groups objects 
allocates back region usable memory consumed collects window front region copying survivors back region usable space consumed empty flips roles regions collects window new region copies survivors back new empty region continues allocate back new region illustrated heap organized left right older younger objects 
older collector remember pointers regions collected region collection assume pointers collected region refer live objects 
need remember pointers regions needs remember pointer regions independently collect target source 
generational collector generations just region boundary boundaries write barrier remembers pointers 
previous discusses design implementation strategies 
modifications design implementation 
changes necessary collector uses bit environment jikes rvm envisaged large address space enable optimizations reduce pointer maintenance costs 
original design mechanisms reduce pointer maintenance costs implementation introduces enhancement reduce number remembered pointers 
remainder section presents high level design older algorithm implementation discusses implementation deviates initial design 
blocks frames jikes rvm currently supports bits address space prevents address ordered heap write barrier quickly compare virtual addresses determine needs remember pointer 
simulate larger address space organizing objects frames mapped software larger logical age ordered address space 
frame contiguous aligned chunk virtual address space size set system build time giving frames mb 
practice frames virtual address space restrictions imposed operating system call high order bits frame address frame number 
frame largest amount contiguous space objects reside frame size determines maximum object size 
frame minimum unit collection general fill frames completely 
example collector window size determines space allocate frame 
collector represents ages associating time death tod frame array indexed frame number 
tod tod values change time passes ages 
tod corresponds frame position larger logical address space allows apply age order write barrier analogous efficient address order write barrier possible larger virtual address space frames placed virtual address space age order 
program executes hands frames region filling objects 
heap full starts handing frames region filling survivors collecting oldest frames region 
copying survivors collected frame frame available handout region 
actual order frames virtual memory matter tod table gives necessary logical ordering collection write barrier 
space frames allocated aligned chunks size call blocks 
study giving block size 
block smaller virtual memory page larger frame 
perform space accounting enforce maximum heap size terms blocks map virtual memory dynamically allocate space frames dynamically recover space collection 
frame allocation proceeds sequentially 
object allocation cross block boundary attempt obtain additional block frame assuming frame full 
trigger collection block budget exhausted 
managing tod values allocate frames regions frames obtain increasing tod values drawing sequence region higher numbered sequence region 
survival rate region collections low say region consume tod values rapidly region grows times fast survival means region tod values collide region values 
actual large address space implementation need trying emulate large address space case implementation collect remaining frames region flip regions just case window reset 
fact call case hard window reset hard forced call normal window resets soft 
flip establish starting tod value new region certain amount higher starting tod value new region 
call amount zone size specify command line multiple maximum heap size command line parameter 
runs adjusted zone size hard resets occur fact implement hard reset case need 
exceptional case having window resets hard soft tod values overflow 
way handle large address space implementation copy entire heap address space call zone reset 
hard resets chose zone size zone resets occur runs 
note long running programs may impossible avoid zone resets 
write barrier implementation limits number remembered pointers maintaining simplicity write barrier test 
write barrier test needs remember pointer blocks collect target block source block 
occurs tod value target block frame tod value source block frame 
needs remember intra frame pointers 
write barrier complicated fact pure address ordered write barrier logical ordering frames age 
making frame hold single collection window ensure collections advance frame frame 
write barrier exclusive source object target object addresses determine frame 
collects objects frame time need remember intra frame pointers 
objects different frames barrier looks frames ages table uses original age pointer filtering technique collects older objects younger ones 
expensive pure address ordered test implemented write barrier significantly limits number expensive table lookups remembered pointers 
event powerpc instruction sequences barriers compiled 
shows code address order write barrier generational collectors 
shows write barrier age lookup frame table collector 
clear low order bits pointer source rtemp compare pointer target cmp cr rtemp comparison favorable skip remembering label remember pointer fall remember pointer address order write barrier calculate frame numbers source target rtemp rtemp rtemp rtemp rtemp rtemp pointers test cmp cr rtemp rtemp beq label remember pointer heap boundary test cr rtemp xf blt label remember pointer load base tod array rtemp static offset look age source target sli rtemp rtemp rtemp rtemp rtemp sli rtemp rtemp rtemp rtemp rtemp age comparison test cmp cr rtemp rtemp ble label remember pointer fall remember pointer write barrier age lookup 
experimental method section describe collectors implementation environment hardware platform test programs configuration parameters metrics evaluate 
collector families experiments baseline generation collector variable nursery size 
refer collector appel collector 
devotes free space nursery 
nursery full copies surviving objects older generation reduces nursery size volume 
repeats process older generation occupies entire heap point performs full heap collection returning free space nursery 
best performing generational collector :10.1.1.10.2911
normalized collector compare families collectors fixed window size traditional generational fixed size nursery collectors older collectors 
nursery size generational fixed size nursery collector sizes nursery bytes collects bytes allocation 
promotes surviving objects older generation heap full collects entire heap 
refer collector generational fixed generational collector 
include non generational semi space collector demonstrates collectors perform better collecting entire heap 
experimental environment measure collectors jikes rvm release jalapeno built running optimizing compiler turned 
jikes rvm interpreter java bytecode translated native powerpc code execution 
virtual machine written java translates bytecodes native code 
translation done runtime avoid obscuring behavior benchmark programs classes virtual machine precompiled build stage jikes rvm 
measured execution includes compilation application methods native code 
version jikes rvm includes developed publicly available version umass gc toolkit 
believe collector implementations tuned 
write barrier appel fixed generational collectors write barrier fast common case code 
write barrier older collector somewhat efficient discussed preceding section 
hardware platform macintosh single mhz powerpc processor kb data instruction caches kb unified cache mb memory running yellow dog linux linux kernel 
machine placed single user mode disconnected network duration experiment 
results improved compiler fully optimize write barrier code 
inspecting compiled result actual barrier code find unneeded instructions extra branch 
expect fully optimized barrier provide additional time savings significant reengineering optimizing compiler replace compiled barrier fully optimized code verify savings 
hand currently developing bit version jikes rvm permit address order write barrier older collector 
test programs programs specjvm modification 
spec jbb posed challenge original form throughput self calibrating program 
modified code performs fixed amount 
avoid confusion benchmark named pseudojbb 
similar fashion derived code 
summary benchmark programs table 
appel collector serves performance measurements determine minimum heap size needed run benchmark stipulate circumstance memory manager request memory operating system amount memory manager fails satisfy requests amount memory cases collectors need somewhat larger heaps operate data points small heaps absent 
results report heap sizes relative minimum heap size 
configuration parameters vary heap size minimum feasible size times amount 
range reveals space time tradeoff de garbage collection 
small heaps collector runs frequently larger heaps 
large heaps sparsely populated live objects paging results 
note largest benchmark configurations operate third available physical memory experimental platform entirely avoid paging activity experiments 
cover range heap sizes spaced densely low 
generational older collector families vary window size maximum permissible size roughly half heap size 
range find best performing window sizes family 
larger window sizes families quickly degenerate semi space collector 
window sizes range 
metrics performance metric mark cons ratio 
copying garbage collectors ones consider ratio total amount data copied collector divided total amount data freshly allocated program column table 
expense copying data predominant expense garbage collection cost nearly proportional amount copied mark cons ratio ought indicator performance 
expense solely determined collection costs early history garbage collection 
general systematic differences arise collector families copying costs costs pointer tracking 
mark cons ratio provides clue copying cost remains direct metric derivable simulation 
counting amount data allocated imposes significant overhead object allocation similarly amount data copied 
perform separate statistics gathering experimental runs obtain mark cons ratios 
total execution time program ultimate metric garbage collection performance 
reported time minimum measured runs configuration 
total execution time includes costs incurred garbage collection time mutator including cache locality effects object motion write barrier actions 
unfortunately total execution time provide insight contribution various effects 
report garbage collection times include results write barrier effects 
garbage collection time sum collector induced pause times measure elapsed time jikes rvm interface powerpc linux system clock effective millisecond resolution 
note reported garbage collection time capture full cost memory management allocation write barrier actions take place execution mutator program garbage collection pauses 
actions extremely short interleaved application code result instruction scheduling order execution feasible measure cost directly 

results experimental results cover large configuration space considering detail single benchmark total time mark cons pause time results benchmarks 
choose pseudojbb detailed study allocates largest live data size set 
results benchmark pseudojbb shows mark cons ratios obtained statistics gathering runs graph generational collector graph older collector 
heap size horizontal drawn logarithmic scale provide details smaller sizes close minimum feasible 
mark cons ratios vertical normalized respect mark cons ratio appel collector heap size 
fixed generational collector relative mark cons ratio 
appel collector copies significantly utilizes heap better fixed generational collector choices nursery size range heap sizes 
result agrees goals appel collector appearing literature :10.1.1.10.2911
shows mark cons ratio older collector lower generational collector usually lower appel 
results confirm earlier simulation study comparing fixed generational collector 
looking closely sizes collected region nursery case generational collector window size note considerable variation region size gives lowest mark cons ratio heap size varied efficient sizes tend small small 
configurations generational collector operate nursery sizes heap size fail large sizes 
robust respect parameter operates window sizes heap 
shows garbage collection times different garbage collectors pseudojbb 
variation fine detail garbage collection times behavior mark cons ratios fixed generational collector generally exhibits higher garbage collection times appel generally lowers times relative differences diminishing larger heap sizes 
shows total execution times pseudojbb 
recall total execution time comprises time spent garbage collection previous mutator useful time time incurred mutator measured separately comparison shows fixed generational collector higher total execution time appel collector relative difference pronounced garbage collection time 
dilution differences expected garbage collection time considerably mutator time especially larger heaps shown appel collector 
program description mh spec compress compresses decompresses mb data lempel ziv method 
spec jess expert shell system nasa clips 
spec raytrace scene memory buffer 
spec db performs series database functions memory resident database 
spec javac sun jdk compiler 
spec mpegaudio mpeg audio decoder spec mtrt graphics ray tracer spec jack generates parser java programs 
pseudojbb fixed version spec jbb benchmark fixed version benchmark table benchmark programs experiment 
mh minimum heap size needed run program appel collector total amount data allocated program 
expressed megabytes 
heap size relative minimum heap size log pseudojbb gen gen gen gen gen gen gen gen gen generational collector heap size relative minimum heap size log pseudojbb older collector mark cons ratio pseudojbb 
heap size relative minimum heap size log pseudojbb gen gen gen gen gen gen gen gen gen generational collector heap size relative minimum heap size log pseudojbb older collector garbage collection time pseudojbb 
heap size relative minimum heap size log pseudojbb gen gen gen gen gen gen gen gen gen generational collector heap size relative minimum heap size log pseudojbb older collector total execution time pseudojbb 
heap size relative minimum heap size log pseudojbb appel gc time fraction total execution time appel collector pseudojbb 
comparison shows range heap sizes total execution time older collector appel collector reduced respect corresponding range garbage collection times 
result explained unequal contribution write barrier times record pointer stores generational collectors write barrier implementation efficient 
demonstrate differences take case study execution pseudojbb heap size relative heap size comparing appel collector collector window size 
total execution times appel giving ratio 
garbage collection times appel giving ratio 
mark cons ratios appel giving ratio 
look costs 
case write barriers code fig write barrier address order executed 
number interesting pointers remembered appel collector giving ratio 
difference arises garbage collection time remembered pointers target collected region processed 
total remembered pointers processed appel collector giving ratio 
difference number garbage collections performs collections appel collector 
larger number collections may reducing pause time section increases execution time stacks scanned 
tradeoff 
flexible choice garbage collection region resulted having record approximately times pointers write barriers process approximately times pointers garbage collection time time spent stack scanning gc startup overhead 
spite measured factors disadvantage slower write barrier fast path directly measure total execution time lower halving mark cons ratio 
program runs db noticed achieved improvements explain entirely tradeoff copying pointer maintenance costs consequence improved cache performance 
detailed study comparative cache behavior garbage collection algorithms java virtual machine called scope 
total time mark cons results benchmarks total execution time data benchmarks 
benchmark summarize generational collector data single plot line best possible nursery size heap size 
similarly best window size heap size 
automatically adaptively choosing region sizes challenging problem explore 
figures results semi space collector normalize respect total execution time appel collector 
performance results total execution times surprisingly favorable older collector 
earlier study fully accurate garbage collection traces faithful simulation older collector mark cons ratio occasionally low tenth fixed generational collector best configuration 
cases study predicted estimate write barrier costs total memory management costs factor heap size relative minimum heap size log spec compress auto best config ss gen heap size relative minimum heap size log spec jess auto best config ss gen heap size relative minimum heap size log spec raytrace auto best config ss gen heap size relative minimum heap size log spec db auto best config ss gen total execution time best configuration 
heap size relative minimum heap size log spec javac auto best config ss gen heap size relative minimum heap size log spec mpegaudio auto best config ss gen heap size relative minimum heap size log spec mtrt auto best config ss gen heap size relative minimum heap size log spec jack auto best config ss gen total execution time best configuration continued heap size relative minimum heap size log auto best config ss gen heap size relative minimum heap size log pseudojbb auto best config ss gen total execution time best configuration continued lower 
study prediction total execution times estimates extrapolate reduction larger heap sizes small heap sizes 
set smalltalk java program traces earlier simulation study showed dramatic reductions mark cons ratio programs significant improvement mark cons ratios estimated marginal improvement total collection cost 
live measurements observe consistent reductions mark cons ratio figures collector compared generational collector dramatically lower earlier study 
improvements mark cons ratio translate measurable reductions total execution time figures 
note benchmarks mark cons ratio older lower appel collector tuned minimize copying 
benchmarks compress jess raytrace db jack pseudojbb total execution time collector ultimately lower appel collector wide range heap sizes 
measurements pause times design goal improve throughput reducing mark cons ratio achieves low mark cons ratios small window sizes 
amount data copied collection bounded window size previous predicted lower pause times additional benefit compared generational collectors occasionally collect entire heap 
similar reasoning applies fixed generational collector compared appel semispace collector 
measure pause times fixed appel jikes rvm collector analyze developed method mutator utilization :10.1.1.19.6616:10.1.1.10.2911
reporting duration garbage collection pause general timing run introduces slight overhead 
time reported pause accurate execution entire program reporting increases total time 
avoid problem separate pause timing runs performed timing runs described preceding section reported time execution 
focus maximum pause times aggregate picture program runs heap sizes collector configurations 
scatter point corresponds single program run marks distinguish runs generational appel semi space collector 
horizontal coordinate gives longest pause time incurred run vertical gives mutator utilization averaged entire run fraction total execution time spent outside garbage collector 
semi space collector points form vertical band wide logarithmic scale expected span heap sizes 
shortest maximum pause times come generational collector heap large performs full heap collection 
generational collector runs incur long pauses collects nursery older generation 
appel collector highest mutator utilization scores high maximum pause times major collections 
older collector points clustered favorable region high mutator utilization low maximum pause times number runs long pause times 
survey maximum pause times capture pause behavior collector completely 
interactive real time heap size relative minimum heap size log spec compress auto best config ss gen heap size relative minimum heap size log spec jess auto best config ss gen heap size relative minimum heap size log spec raytrace auto best config ss gen heap size relative minimum heap size log spec db auto best config ss gen mark cons ratio best configuration 
heap size relative minimum heap size log spec javac auto best config ss gen heap size relative minimum heap size log spec mpegaudio auto best config ss gen heap size relative minimum heap size log spec mtrt auto best config ss gen heap size relative minimum heap size log spec jack auto best config ss gen mark cons ratio best configuration continued 
heap size relative minimum heap size log auto best config ss gen heap size relative minimum heap size log pseudojbb auto best config ss gen mark cons ratio best configuration continued 
maximum pause time microseconds gen appel semispace mutator utilization vs maximum pause time program runs 
important mutator able progress period important garbage collection pauses occur clusters 
quantify progress examine time intervals program execution 
say minimum mutator utilization mmu interval length intervals length equal greater mutator utilization interval mmu plots shown figures benchmarks relative heap size twice minimum heap size 
fixed generational collector show representative performing nursery size window size 
benchmarks compress jess raytrace mpegaudio pseudojbb older collector achieves higher average mutator utilization intercept lower maximum pause intercept appel collector mmu curve appel collector curve 
pseudojbb reduction maximum pause time 
addition mtrt older collector higher mutator utilization lower maximum pause mid range pauses appel collector greater mmu 
javac little difference collectors respect maximum pause time older collector comes close appel respect average mutator utilization mmu curve extremes markedly lower appel collector curve 
db appel collector best terms throughput responsiveness 
jack aberration semi space collector having smallest maximum pause time investigate 
note collectors discuss provide kind real time guarantee 
results indicative actual behavior insofar benchmarks representative true workloads 

summary implementation older collector inside java virtual machine 
evaluate natural competitor fixed size nursery generational collector appel variable size nursery generational collector 
domain throughput metrics find older collector yields lower mark cons ratios fixed size nursery generational collector lower appel collector range important relatively small heap sizes specjvm benchmark suite 
result true total program execution times improvement appel collector 
domain pause time metrics benchmarks older collector achieves significantly lower maximum pause times generational collectors 
believe better implementations possible 
instance profile driven pretenuring provides immediate improvements basic collector organization 
hope eventually build bit environment fast write barrier generational collectors 
question adaptive tuning window size heap configurations remains open generalizations older window motion policy 
formulation exactly :10.1.1.10.2911
slightly different mmu curves necessarily monotone increasing 
granularity microseconds log spec compress appel gen semispace granularity microseconds log spec jess appel gen semispace granularity microseconds log spec raytrace appel gen semispace granularity microseconds log spec db appel gen semispace mmu 
granularity microseconds log spec javac appel gen semispace granularity microseconds log spec mpegaudio appel gen semispace granularity microseconds log spec mtrt appel gen semispace granularity microseconds log spec jack appel gen semispace mmu continued 
granularity microseconds log appel gen semispace granularity microseconds log pseudojbb appel gen semispace mmu continued 

ben andrews help analyzing assembly code sequences anonymous reviewers comments helped strengthen 

alpern attanasio cocchi lieber smith ngo barton hummel mergen implementing jalapeno java 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla denver colorado usa november october vol 
acm sigplan notices acm press pp 

alpern attanasio barton burke cheng choi cocchi fink grove hind hummel lieber litvinov ngo mergen sarkar serrano shepherd smith sreedhar srinivasan whaley jalapeno virtual machine 
ibm systems journal feb 
appel simple generational garbage collection fast allocation 
software practice experience 
blackburn jones mckinley moss beltway getting garbage collection :10.1.1.10.2911
proceedings acm sigplan conference programming language design implementation pldi june acm sigplan notices acm press 
appear 
blackburn mckinley 
putting write barriers place 
proceedings third international symposium memory management ismm berlin germany june vol 
acm sigplan notices acm press 
blackburn hertz mckinley moss pretenuring java 
proceedings sigplan conference object oriented programming languages applications tampa fl oct vol 
acm sigplan notices acm press pp 

cheng blelloch parallel real time garbage collector 
proceedings acm sigplan conference programming language design implementation pldi snowbird utah usa june snowbird ut may vol 
acm sigplan notices acm press pp 

study allocation behavior specjvm java benchmarks 
ecoop object oriented programming th european conference brussels belgium july proceedings jul ed vol 
lecture notes computer science springer verlag pp 

lieberman hewitt real time garbage collector lifetimes objects 
communications acm 
report tm laboratory computer science mit cambridge ma july ai lab memo 
may simpson warren eds 
powerpc specification new family risc processors second ed 
morgan kaufmann san francisco california 
standard performance evaluation 
specjvm documentation release ed march 
standard performance evaluation 
specjbb java business benchmark documentation release ed 
properties age automatic memory reclamation algorithms 
phd thesis university massachusetts amherst ma feb 
mckinley moss age garbage collection 
proceedings sigplan conference object oriented programming languages applications denver oct vol 
acm sigplan notices acm press pp 

ungar generation scavenging non disruptive high performance storage reclamation algorithm 
proceedings acm sigsoft sigplan software engineering symposium practical software development environments pittsburgh pennsylvania apr sigplan notices may pp 

