languages methods specifying real time systems jan carlson department computer engineering university sweden jan carlson se speci cation complex systems software requires ned languages methods 
case real time systems temporal correctness achieved addition functional descriptions time dependant behaviour speci cation language 
report presents selection languages methods specify real time systems ranging fully formal temporal logics process algebras formal widely uml 
contents real time systems strictness criticality 
event triggered time triggered systems 
ine online scheduling 
timeliness constraints 
speci cation reasons specifying 
desirable properties speci cation methods 
classi cation speci cation methods 
real time aspects speci cation 
logics temporal logics 
duration calculus 
real time logic 
automata model languages timed automata 

process algebras communicating sequential processes csp 
calculus communicating systems ccs 
calculus 
process algebras real time speci cations 
petri nets basic petri nets 
modi ed petri nets 
uml object constraint language 
uml rt 
uml pro le schedulability performance time 
real time programming languages general issues 
concurrency 
real time facilities 
summary speci cation complex systems software requires de ned languages methods 
especially true safety critical systems faulty behaviour may cause serious damage people property 
language speci cation real time systems course meet requirements speci cation languages general readability non ambiguity 
additionally provide means specify temporal constraints time dependent behaviour allow properties safety liveness expressed 
report presents selection languages methods suggested specifying real time systems 
section contains brief real time area section gives general discussion speci cation concepts 
sections describe selection methods languages section gives overview real time support typically provided programming languages 
real time systems signi cant characteristic real time system existence requirements concerning timeliness functional behaviour 
correctness system depends results produces time results available 
real time systems range wide spectrum applications small embedded systems control applications complex software systems controlling railway switches power plants 
real time systems reactive react events changes environment 
reactive real time 
example consider system emergency break 
break supposed system button pressed behaviour reactive 
requirements state system seconds button pressed emergency break classi ed real time system 
strictness criticality distinguish hard soft real time systems critical non critical ones 
hard real time system timeliness requirements strict result delivered late early considered incorrect 
system meet temporal requirements order correct 
soft real time systems value result decreases timeliness restrictions violated late result better result 
typically system requirements de ne minimal quality service deadline missed 
hard soft critical non critical music streaming network visual monitoring power plant cd burner computerised car brakes orthogonality criticality strictness criticality system consequences failures 
critical system violation timeliness requirements cause serious damage people equipment result signi cant loss money 
noncritical systems useless deadlines missed cause signi cant harm 
classic view incorporate criticality concept hard real time systems argued concepts fact orthogonal 
gives examples typical systems categories 
event triggered time triggered systems real time systems categorised event time triggered 
time triggered system activities performed certain points time periodic fashion 
system respond directly external events occur respond events scanning environment certain points time 
style naturally suited implementing periodic activities control loops 
event triggered system execution guided non deterministic occurrences asynchronous external internal events 
provides higher degree exibility system harder analyse respect timeliness criteria 
event triggered approach suits implementation systems reactive behaviour 
example di erences consider system guaranteed certain catastrophic event temperature reaching certain level occurs emergency action carried millisecond 
ensure time triggered system sample temperature millisecond quite inecient event occur 
event triggered system hand perform duties wasting time checking temperature long catastrophic event occur 
usually ecient time triggered method complicated ensure matter happens emergency action carried time 
providing complete de nition di erence types systems trivial 
time triggered system viewed event triggered system single event clock tick 
similarly event triggered systems normally implemented hardware inherently time driven 
time event triggered approaches viewed conceptual abstractions focusing di erent aspects real time systems 
think terms services provided low level layer system operating system higher level parts 
system provides functionality react asynchronously external events classi ed event triggered permits timed constructs timeouts considered time triggered 
ine online scheduling system meet certain timeliness constraints especially order prove activities system planned rational way 
activities usually split smaller units called tasks planning order tasks executed referred scheduling 
scheduling performed design system called ine scheduling 
tasks de ned schedule created contains information tasks executed 
schedule created included system runtime decision task execute simply matter looking schedule 
approach denoted online scheduling include system algorithm making scheduling decisions runtime 
scheduling tasks optimal way respect timeliness requirements general np hard problem 
ine scheduling advantage lot ort put creating suitable schedule 
scheduling algorithm wide variety timeliness restrictions consideration 
online scheduling done runtime considerably ort allowed types timeliness constraints allowed system restricted 
systems scheduled ine easier verify need consider way schedule created schedule 
online scheduled systems scheduling algorithm proven violate timeliness constraints tasks 
main advantage online scheduling exibility 
systems scheduling decisions information known design time arrival times external events 
ine scheduled system respond external events scheduler reserve time schedule knowing needed 
possibility combining approaches 
ine schedule constructed subset system usually safety critical parts 
runtime mechanism executes tasks schedule schedules additional tasks system idle 
sophisticated algorithms allows original ine schedule altered online scheduler enable ecient scheduling long timeliness constraints met 
real time scheduling including descriptions common scheduling algorithms see 
timeliness constraints real time system task characterized set parameters 
parameters vary di erent types systems example time event triggered common ones explained 
computation time time needed execute task interruption 
worst case execution time wcet exact computation time 
deadline time execution task complete order fully useful system 
period time consecutive instances periodic task 
priority priorities guide allocation resources including processor time tasks 
typically wants guarantee task delayed task lower priority 
value systems tasks values denote importance system 
concept similar priority values typically interpreted cumulative way meaning system prefers set low valued task single task slightly higher value 
applications tasks allowed execute arbitrary order required meet certain precedence restrictions 
restrictions may originate task communication directly environment system 
precedence constraints represented directed acyclic graph de ning direct indirect precedence relations 
common timeliness constraint task nishing execution deadline types constraints certain applications 
example necessary restrict deviation nishing time instances aperiodic task called jitter 
necessary express timeliness assumptions environment 
particular scheduling policy guarantee example avoid deadline violations provided time consecutive arrivals aperiodic task ms 
correctness reactive systems expressed terms safety liveness properties 
safety properties state system delivering faulty response 
properties important trivially met system simply 
liveness properties guarantee progress system example event left unattended 
speci cation order ectively reason complex systems details omitted 
cases decided contribute particular aspect currently wants focus 
speci cation captures essential properties software behaviour depending purpose specifying properties vary 
software engineering point view speci cation de ned precise description possible ects software component vv 
de nition gives lot room interpretation provides general intuition 
limits aspects described regarding ects software 
allows incomplete speci cations describing possible ects 
comparing speci cation methods kept mind different methods give term di erent meanings 
de nitions range fully formal ones informal descriptions intended usage 
reasons specifying mentioned speci cations di erent ways 
naturally purpose speci cation big impact appropriateness speci method 
methods focused non formal concerns communicating intuition design requirement decisions 
methods aim fully formal descriptions safety critical components 
common reasons specifying include speci cation act outline system design phase 
serves common base discussing requirement design issues customer management developers 
natural language prove ambiguous providing simple de ned notation decreases risk misunderstandings 
design system speci cation clarify ideas concepts 
aid nding ambiguities incompleteness intended system early step 
speci cations act contracts developer customer 
delivery system compared speci cation validate customer gets paid 
speci cation produced customer want build system meets requirements developer build corresponds met requirements 
safety critical systems required formally prove properties safety liveness 
way doing prove speci cation desired properties system correctly implements speci cation 
executable speci cations gather non formal information system average load component system behaves temporary overload implementation system exists 
speci cation viewed rst step implementation 
transformational development re nement calculus transform speci cation series steps implementation 
development new software speci cations provide starting point software maintenance 
theoretical point view speci cations thought way rule possibility errors system 
speci cation method able produce formal proofs correctness 
practical point view may consider goal speci cations increasing quality produced systems 
case proofs viewed cost ective way uncovering errors 
desirable properties speci cation methods depending intended speci cations di erent requirements implied speci cation method 
number general requirements desirable properties identi ed simple possible create speci cation reasonable ort 
details omitted ecient 
readable speci cation easy understand training 
possible grasp major structure speci ed software having understand details 
preferably true speci ers customers non technical members developer team 
wide range methods aim providing support certain type software components 
making easy write speci cations systems means concepts outside intended domain dicult specify result complicated speci cations 
general method aim wide range applications possible 
continuous small conceptual change problem domain require small changes speci cation 
compositional specifying large complex systems requires system divided parts speci ed individually 
composing speci cations obtain speci cation complete system easy possible require changing partial speci cations 
unambiguous order ensure speci cations unambiguous method contain formal de nition semantics speci cations 
danger informal semi formal methods tend hide ambiguities misunderstandings seemingly unambiguous notation 
useful speci cations limited bene method exist simple methods formally reason resulting speci cations 
examples reasoning include proving properties liveness safety checking speci cations consistent 
addition speci cations required executable 
executable speci cation technique constructive semantics provides way evaluate speci cations 
speci cations treated prototypes get early feedback design phase 
early testing cost ective way nding design aws compared constructing formal proofs kem dk 
classi cation speci cation methods speci cation techniques classi ed di erent ways section presents possibilities 
practice methods tools cover aspects category combining di erent speci techniques single embracing 
descriptive operational methods method classifying extent technique descriptive operational bcn epo 
descriptive methods referred algebraic axiomatic specify properties system means equations rst higher order logical formulas 
example descriptive speci cation stack integers include axioms 
rst states combined ect push pop operation leaves stack unchanged 
second axiom states top returns element pushed stack 
pop push st st top push st descriptive methods provide straightforward way reason speci cations ordinary theorem provers prove di erent properties 
main diculties related methods poor readability large complex speci cations cumbersome treatment errors 
operational methods build model system set basic objects numbers tuples sequences operations addition concatenation 
semantics operation speci ed ects model 
methods essentially de ne states transitions naturally produce executable speci cations 
operational speci cation integer stack example model sequence integers 
contain de nitions operations terms de ned operations sequences cons rst 
pop st st rest st push st st cons st top st rst st st st post accent refer variable value operation carried 
diculty associated methods intended data type properties speci ed easily basic objects operations 
situations speci cation complex 
typical example operational methods described section 
data structural process temporal formalisms methods classi ed aspect software focus epo 
data type formalisms describe functional view system specifying data types system data transformed individual software components 
structural formalisms focus system decomposition sub systems 
decomposition hierarchical case sub systems allowed decomposed permitting level decomposition 
process view formalisms specify dynamic behaviour system usually collection processes activities possibly cooperation carry desired scenarios 
speci cations example ensure deadlock livelock starvation situations occur 
di erent methods di erent means specify processes system including algebraic descriptions automata petri nets graph transformation 
subsequent sections describe detail 
important aspect process view way processes may communicate synchronize 
done essentially ways shared data message passing bst 
shared data means processes allowed share variables communicate 
implementation level fairly easy accomplish method commonly real time systems 
message passing allows processes send receive messages possibly containing data 
speci cation level number advantages shared data 
provides complex speci cations issues mutual exclusion omitted 
suited specifying loosely coupled systems 
temporal view formalisms add process view concept time 
process formalisms usually introduce simple concept causality de ning example order events system express elaborate temporal properties response time deadlines 
temporal information included process view additional restrictions system 
choice temporal domain strongly uences expressiveness usefulness technique discussed section 
real time aspects speci cation signi cant aspect specifying real time systems compared general systems need explicitly stated temporal properties 
depending nature constructs specify data behaviour temporal information incorporated di erent ways important comparing di erent methods characteristics temporal domains 
temporal domain structure discrete domain models time monotonically increasing sequence integers 
structure suited formal treatment operations needed manipulate speci cations typically performed eciently 
continuous asynchronous behaviour handled approximations introducing xed granularity limits accuracy observations 
dense temporal domains monotonically increasing real numbers integers model time resulting higher accuracy 
time complexity analysis operations veri cation identi cation increases 
structure types unbounded bounded past 
structure bounded past exists time instant earlier instant exists bounded de ned similarly 
considering real time systems important distinction domain structure contains metric time 
temporal order relationships events described 
result purely causal temporal domain temporal information available precedence relationship events system environment 
structure possible refer points time events occur give exact temporal measures events events duration separation timeout 
semantic models important semantic models timed speci cations linear time branching time respectively 
linear time semantics interpret speci cation set linear structures states sequence represents possible execution sequence system 
model system completely determined set observable partial runs 
branching time semantic model speci cation interpreted tree structure states 
path tree represents possible execution sequence similar sequences linear time model 
di erence system determined possible executions structure tree choices execution 
section describes di erence models process algebras 
linear time semantics represented csp traces branching time state transition graphs ccs 
introducing time language temporal information included speci cation language implicit explicit manner 
implicit time allows speci cations contain properties vary time properties may refer time explicitly 
example property door locked minutes 
truth property depends time evaluated explicitly referring 
method explicit time represents current time speci variable 
allows speci cation refer absolute points time door unlocked time instants 
explicit time useful real time property expressed 
compositional speci cation language speci cations constructed combining smaller speci cations composition temporal information de ned 
particular decided combined parts refer single global clock keep local clock 
local clocks events system partially ordered 
global clock approach provides higher accuracy terms total temporal ordering considered cation assume entire system communicate synchronously 
possible trade self timed systems subsystems local time communicate asynchronously de ned protocol ensures predictable event ordering system sz 
logics logics describe behavior systems allows speci cations analysed standard techniques model checking automatic theorem provers 
timeliness properties expressed addition functional ones logic propositional rst order higher order extended concept time 
rst step extension modal logic logic formula set interpretations called worlds single 
world formula true false 
modal logic system de ned triple hw ri set worlds evaluation function assigns truth value formula world relation de ning possible transitions worlds 
denotes truth value true false formula world denotes directly reachable new operations added symbols operators classical logic 
formula lf true true world directly reachable mf true worlds directly reachable modal temporal logics combination modelling techniques timed automata process algebra express properties models 
combinations worlds evaluation function transition relation de ned model concepts states variables signals creating logic formulas 
possible ask example automata satis es property value states directly reachable initial state initial 
major weakness logics speci cation technique su er bad readability complexity expressed properties grows 
best suited expressing verifying relatively simple properties complex systems 
temporal logics want modal logic reason time worlds correspond possible instants temporal domain precedence relation denoted usually transitive irre exive strict partial ordering temporal domain 
modal logic type called temporal logic 
subject survey existing temporal logics example ah 
temporal operators modal logic temporal logics add new operators classical logics order quantify temporal domain 
di erent systems di erent sets operations operations slight modi cations thereof usually included 
reason operators eventually introduced denoted respectively 
corresponding operations reasoning past denoted common operator 
denoted de ned follows 
informally true eventually true true 
similar operators express statements systems change time precedence relationships reactive behavior 
expressive specify real time timeliness constraints deadlines explicit duration events 
possible temporal domain metric time see section introduced temporal logic bounded operators 
bounded versions denoted subscript interval example standard mathematical notations square round brackets denote inclusion exclusion point 
formula means true time instants interval similarly means true time instant constructs intervals interpreted relatively time evaluation 
example true time true interval length starting point 
speci cations real time systems basic temporal operations describe properties related reactivity precedence bounded operators allow important timeliness constraints expressed 
examples 
actuators activated represented predicate symbol sensors read emergency mode 
button pressed door unlocked time units 
time consecutive message arrivals time units 
comparing di erent temporal logics signi cant distinctions order classical logic built choice temporal domain 
system predicate logic discrete domain expressive higher order logic dense temporal domain simpler deal proving properties checking satis ability 
temporal logics typically complete speci cation method part elaborate methods 
example logic invariants described section extended temporal operations facilitate reasoning system liveness ds 
duration calculus duration calculus cha extended temporal logic intervals developed suit modelling real time systems 
nite continuous intervals functions time instants boolean values 
ordinary temporal logic extended operators access subintervals 
basic concepts duration calculus system state represents logical property system modelled boolean function time 
simple states combined boolean operators complex states 
key concept duration state interval denoted de ned integral interval 
meaning long system state true interval 
couple abbreviations denote common durations representing interval length 
formulas formed durations constants global variables functions express properties system 
formulas combined create new formulas propositional connectives chop operator denoted formulas formula true interval interval split sub intervals true true operators corresponding interval temporal logics denoted intervals implicit de ned terms chop 
def true true def speci cations real time systems example duration calculus specify real time systems consider part speci cation gas burner os 
gas flame represent state gas valve ame respectively 
combining states undesired state leakage formulated 
leak gas flame formula expresses safety property leakage limited time units interval shorter time units 
safe states safety property true time interval 
leak safe real time logic di erent approach dealing time taken real time logic rtl 
considering time dependent formulas evaluated point time rtl extends ordinary predicate logic special predicate relates events system times occur 
compared propositional linear temporal logic rtl strictly expressive jms 
rtl uses discrete model time formulas built mathematical relations restricted algebraic expressions existential universal quanti ers rst order connectives 
addition occurrence relation capture notion time denoting th occurrence event occurs time classes events particular interest 
start action denoted respectively 
keep track system state transition events 
predicate asserts property state variable having certain value 
true false denote events occur predicate turns false true true false 
example rtl consider property stating engine runs time units engine engine automata model languages automata oriented language focuses system state changes time 
captured straight forward way automaton explicitly de nes system states possible transitions 
system respond environment transitions labeled triggering events responses 
complex system number states large nite 
way decrease size automaton introduce state variables allowing similar system states represented single state automaton 
exact state system de ned values state variables state automaton 
handle variables transitions states labeled constraints variables statements update 
example di erence consider equivalent automata modelling behaviour vending machine 
machine change states coin inserted represented event coin button pressed button 
left automaton nite number states needed represent number coins currently machine right automaton uses state variable purpose 
coin button coin button coin button coin button coin button state variables reduce automata size methods provide simple mathematically clear ways specifying behaviour systems components 
specifying large systems su er low simplicity readability basic forms 
automata represent speci cation produced method 
method provides set high level concepts constructs combining intuitive readable speci cations 
meaning speci cation represented probably complex automata formally analysed veri ed 
examples techniques de ned terms automata include process algebras petri nets 
solution complexity problem model oriented methods section vdm 
system state split smaller parts built known mathematical entities sets functions speci cation de nes operations individual parts small number parts 
knowing full state system divided parts ect operation corresponding parts behaviour system de ned 
timed automata basic automata model capable specifying reactive behaviour order real time systems concepts time introduced 
couple di erent extensions suggested di erent notions time discrete dense di erent means specifying timeliness constrains 
simple example timed transition system hmp 
uses discrete time model single external clock initially set 
transitions labeled minimal maximal delay automata analysed bounds time stimulus response formulated temporal logic 
method modi ed making clock variable explicit allowing constraints refer directly time state 
result liveness properties reformulated ordinary safety properties veri ed standard timeless rules 
theory timed automata ad elaborate method 
uses dense time time modelled real numbers multiple explicit clocks reset read transitions 
example shows timed automaton clocks continuously accepts event sequence clock reset occurence constraint ensures occurs time unit preceding occurence similar restriction independent clock put occurences note usage multiple clocks allows type interleaved restrictions explicitly bounding time example timed automaton formal speci cation notation developed programming research group prg oxford university computing laboratory 
built concept schemas de ne small piece system 
schema capture static aspects possible states invariants dynamic aspects ects operations relationships input output state transitions allowed occur 
description section mainly spi wd som 
vdm language similar aspects 
tutorial di erences vdm see 
basic concepts schema contains information name schema 
signature part de nes name type new state variables lists included sub schemas 
predicate de ne relationships entities signature included sub schemas 
notation de ning schema name signature sig predicate pred name sig pred equivalent horizontal notation simple schemas name sig pred signature schema de nes number typed state variables 
possible types range simple types integers user de ned enumerable types compound types sequences tuples sets functions 
types de ned complex expressions containing lambda expressions function application statements addition state variables signature show included sub schemas described 
convention variables names question mark indicate input system 
similarly exclamation mark output variables 
predicate schema describes invariant statement true system lifetime 
ordinary rst order logic may include equality membership tests expressions 
de ning operation predicate refer di erent versions entity state variable expression refers value variable operation carried refers value 
predicate de ne pre postconditions invariants 
example predicate schema states provided multiple precondition result operation halved postcondition 
half mod combining schemas schemas combined number ways create complex speci cations 
mentioned way combining schemas inclusion schema included signature schema corresponds merging de nition result predicate may refer entities 
addition simple version kinds restricted inclusion 
expression 
includes entities predicate versions ordinary entity changed corresponding versions predicate included preserving invariant 
simpli es de nition operations complex schemas 
example schemas de ne limited counter data type operation 
note need add precondition operation implicitly stated predicate versions included 
counter counter 
counter schema inclusion 
second restricted inclusion denoted similar 
added predicate entity result included schema read 
apart inclusion schemas combined conjunction disjunction 
cases signatures merged create new signature predicates combined conjunction disjunction respectively 
permit type combination signatures compatible meaning variable name common schemas type 
logic connectives implication equivalence combine compatible schemas negation creates schema signature negated predicate 
common schema disjunction combine schema de ning normal behaviour operation de nes error handling 
example schemas de ne robust version increase operator counter de ned 
boolean output variable res signal user operation successful 
ok res res true counter res res false ok combining schemas disjunction conjunction 
real time specify real time systems number issues considered 
notion time introduced allowing duration calculus temporal logic ds schema predicates explicit speci cation time 
computational model decided handle nondeterminism concurrency 
extensions speci cations analyzed respect safety liveness 
process algebras key concepts process algebra processes called agents calculus represent behaviour pattern object atomic events actions initiated system environment 
processes de ned algebraic equations evolve new processes performing action 
simple processes combined number ways sequentially concurrently selection describe complex systems 
process algebra usually consists set operations syntactic rules combine semantic mapping assigns meaning processes notion equivalence set algebraic laws 
examples process algebras described brie csp ccs calculus 
communicating sequential processes csp csp developed hoare section brie presents important concepts hoa 
basic constructs simplest process simply terminates engaging event 
expression denotes process evolves process engaging event deterministic selection construct de nes process engages event behaves engages event behaves events deterministic selection construct distinct 
formally process associated alphabet de nes set events may engage 
processes de ned equations nite behaviours accomplished recursive mutually recursive de nitions 
example consider processes tick tick break process engages event tick behaves 
result process engaged nite number tick events 
process engages tick events possibly nite number may time terminate break event 
traces trace nite sequence events engaged process certain time 
general impossible know advance events occur process runs behaviour process depend events initiated environment 
possible de ne traces possibly nite set possible traces process reusing examples traces fhi tick traces fhi tick tick additional constructs processes combined concurrently expression pkq de nes process engages events order 
relative order events arbitrary resulting interleaved notion time 
concurrent processes communicate common events 
events common alphabets occur simultaneously expression pkq surrounding environment simultaneous events visible single event 
example describes clocks emitting events possibly di erent pace eventually breaking time 
tick break tock break tick tick tock traces break traces restriction de ned unable engage event traces 
concealment operation denotes process behaves just events concealed outside viewers 
de ning complex systems concurrent communicating processes useful de ne communication set channels 
csp expression denotes event transmitting value channel add expressiveness language treated way ordinary event operations processes 
notation simply provides developer useful concept 
deterministic selection operation requires processes start di erent events 
non deterministic selection operations choice arbitrarily 
process uq behaves arbitrarily 
environment uence knowledge choice 
process similar respect behaves choice fully arbitrarily 
choice deterministic long determined directly rst event 
def def 
failure sets non deterministic operations included language processes longer described properly traces 
de ne failures set pairs trace set events produce refuse engage events csp process considered fully represented failure set vg 
failures hi fbg hai fag ha bi fa bg calculus communicating systems ccs ccs developed robin milner mil similar csp aspects 
syntax di erent basic constructs roughly equivalent 
main di erences concern communication hidden events semantic model 
constructs mentioned basic constructs ccs similar csp syntax corresponds described 
minor di erence ordinary selection operation ccs allows combined processes rst event 
addition ordinary events ccs allows hidden event invisible environment 
event introduce non determinism corresponding operator csp 
process de ned csp behaves way ccs process 
ccs csp nil syntax ccs csp compared 
concurrent composition processes achieved operator 
meaning broadly similar csp operator important distinctions vg communicating single common events processes communicate process engaging event complementary event csp communication processes engaging event visible single event outside 
ccs communication involving corresponds single event visible outside 
csp common events force communication concurrent processes ccs communication optional 
example process nil nil behaves process nil nil nil 
events occur independently order synchronization invisible outside process 
state transition graphs ccs process represented directed graph nodes labeled process expressions edges labeled actions gup 
node edge labeled evolve engaging event example process nil nil example represented graph 
traces failure sets transition graphs provide di erent notions identi cation processes vg 
weakest identi cation trace semantics stating processes identical traces traces 
failure semantics csp result somewhat stronger identi cation criteria failures failures 
di erence concepts shown example 
nil nil nil nil nil nil nil nil state transition graph nil nil 
nil nil nil nil traces traces fhi hai ha ai ha big failures hi fbg hai fag hai fbg ha ai fa bg ha bi fa bg failures hi fbg hai fg ha bi fa bg trace semantics considered identical di erent failure semantics 
stronger identi cation called strong congruence achieved ccs semantics state transition graphs 
processes strongly congruent state transition graphs identical de ned existence certain binary relation bisimulation 
compare strong congruence failure semantics identi cation consider ccs processes nil nil nil nil visible behaviour processes represented traces failure sets 
represented di erent state transition graphs shown 
traces traces fhi hai ha ai ha bi ha cig failures failures hi fb cg hai fb cg ha ai fa cg ha ai fa bg ha bi fa cg ha ci fa cg reason processes strongly congruent choice di erent points time 
di erence failure semantics nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil processes di erent state transition graphs identical visible behaviour 
strong congruence essentially similar di erence linear branching time discussed section 
calculus calculus focuses describing processes interconnections change lifetime par mpw 
ccs semantics state transition graphs 
constructs constructions nil similar ccs communication operations elaborate 
expression ab denotes process sends channel behaves complementary expression denotes process receives value channel behaves acts placeholder received value 
placeholder thought variable get value input restriction operation denotes process behaves local directly communication environment 
addition calculus de nes operations compare values corresponding simple statement ordinary programming language 
communication prominent feature calculus fact distinction names values names channels 
channels sent processes 
example consider de nitions process expects receive value channel value placed guide behaviour occurs 
system value sent system described graphically follows change de nition channel sent process channel 
receiving send value ba corresponding graphical description system evolves event result communication hidden event just ccs shown 
step send value channel sending channel processes 
migrating local scopes graphical system descriptions previous section contain information processes supposed describe 
de nition processes speci es access channel sent example de nition just ne 
restriction operator name local process 
restriction put name channel channel local processes outside scope 
case example de ning ensures refer 
restriction ensures names explicitly refered outside scope 
processes scope may send restricted names processes outside turn refering corresponding placeholder 
exactly process previous section receiving placeholder sending value shows represented state transition semantics 
ba migration local scope 
transition scope includes process placeholder changed formal treatment rules concerning migrating scopes see example mpw 
process algebras real time speci cations process algebras appropriate modal logic provide fairly easy way formally model reason reactive communicating systems 
basic ones csp ccs extended number ways deal related topics scheduling analysis cle shared resources 
process algebra simple causal notion time events occur ordered fashion explicit time event 
limiting complexity method reduces expressiveness 
discussed section explicit notion time required achieve satisfactory speci cation real time behaviour 
tccs process algebras explicit time suitable real time systems mt 
ccs additional constructs 
term denotes process behaves exactly units time behaves willing wait amount time proceeding 
constructs de ne useful real time concepts timeout construct process communicate environment events event occurs time units timeout alternative allowed 
addition time process algebras extended probability introducing new selection operator assigns probabilities possible choices han 
allows veri cation performance properties average response time throughput failure frequency process algebras especially successful modeling verifying communication protocols 
methodology see par 
petri nets petri net methods graphical notations solid mathematical foundation 
number ways represent di erent aspects computer systems especially concerning concurrency distribution non determinism 
concept invented petri proposed wide range applications including performance evaluation communication protocols multiprocessor design 
speci cation methods petri nets typically classi ed operational methods focusing process view 
provide exible expressive notation simple formal concepts facilitate analysis 
signi cant problem petri nets related complexity 
lack simple algebra operations speci es combine compose nets leads lack modularity large speci cations dicult understand gup 
basic petri nets basic form petri nets powerful capable describing large number di erent aspects system 
description mainly mur 
basic concepts petri net weighted directed graph types nodes called places transitions 
edges graph restricted place transition vice versa 
graphically places denoted circles transitions boxes 
marking assigns non negative integer place graph referred tokens denoted black dots 
petri net de ned tuple graph initial marking 
model dynamic behaviour marking net evolves discrete steps simple rules 
transition enabled place edge leading transition marked number tokens weight edge 

step exactly enabled transition allowed re 

transition res place edge leading transition looses number tokens equal weight edge 
place edge leading transition gains number tokens equal weight edge 
exempli es rules 
rst net enabled may re 
second net shows resulting marking res 
interpretations modelling possibilities mentioned petri nets di erent ways model di erent system aspects 
example nite state machine described petri net 
case transition exactly incoming outgoing edge weight 
initial marking fact subsequent markings contains exactly token 
places represent states single token represents current state 
net gure models nite version vending machine automata section 
places correspond states machine received coins respectively 
transitions represent insertion coin represent button pressed 
simplify notation unlabeled edges assumed weight 
representing automata petri nets 
state machines model non deterministic choice represented petri nets places outgoing edge 
order model synchronization parallel activities interpretation needed 
edges weight transitions allowed outgoing edges 
setting transitions represent activities events places represent pre postconditions activities token denotes satis ed condition 
example consider system activities carried parallel 
may start nished ensured third activity 
system modeled net assuming interleaved concurrency 
modeling concurrency petri nets 
allowing edges weights greater permits representations elaborate synchronization behaviour 
net describes system processes read write shared memory 
writing process allowed access memory number processes may read simultaneously 
tokens pw represent number processes currently writing reading processing data respectively 
tokens pm represent free access rights memory 
order write memory process able claim access rights reading requires 
pw pm modeling synchronization petri nets 
markings denoted numbers dots 
properties solid mathematical foundation petri nets possible apply number formal analysis methods verify properties model 
general properties reachability liveness safety di erent meanings di erent interpretations de ned independently interpretation 
addition particular interpretation speci analysis methods useful models kind 
properties classi ed structural depend structure graph behavioural depend initial marking 
net marking reachable exists ring sequence transforms set markings reachable initial state net denoted 
net bounded place marked tokens marking 
special case net said safe bounded 
net structurally bounded bounded initial marking 
petri nets model resources processors memory boundedness analysis guarantee behavioural pattern may cause ow 
petri net said live marking possible eventually re transition 
corresponding structural property guarantees existence live initial marking 
liveness analysis example ensure absence deadlocks 
modi ed petri nets extensions modi cations basic petri net method proposed targeted speci usage real time systems performance evaluation 
high level nets notion high level nets covers number modi cations including predicate transition nets coloured nets allows richer concepts tokens weighs basic method 
example consider predicate transition net 
ha ai ha bi hx yi example predicate transition net 
method allows atomic tokens di erent types 
complex structures tuples 
edges labeled expressions possibly containing variables determining number types tokens participate ring transition 
transition enabled substitution expression incoming edge instantiated satis ed corresponding place 
transition res substitution expressions incoming outgoing edges instantiated decide amount type tokens remove add place 
example transition net enabled substitutions fx ag fx bg 
resulting nets shown 
ha bi hx yi ha ai hx yi results transition net res substitution fx ag fx bg 
timed nets interesting petri net extensions specifying real time systems add explicit notion time 
simplest version done assigning transition delay value discrete dense temporal domain 
transition res ected tokens reserved enable transition result ring occurs delay 
similar method assigns delays places transitions restricting time arrival token time participate transition 
delay values intervals single points time exible speci cations formulated 
methods enabled transition re interval 
violates important principle petri nets ring determined locally transition may unable re exists transition net interval forces re general time extension addresses locality issue time basic nets 
timestamp attached token indicating age 
addition transitions time conditions restrict time may re 
transition res new tokens created timestamped time ring 
time conditions transitions intervals points de ned expressions 
expressions may refer timestamps tokens places edges leading transition 
example net describes synchronization timeout behaviour process waits represented token time units process reach synchronization phase 
token stays time units synchronization action longer possible 
time timeout action enabled 
time time time timeout behaviour modeled time basic net 
di erent semantics suggested times basic nets 
weak time semantics states transition res ring time speci ed interval transitions forced re 
timeout example mean waiting process forced synchronize process reaches synchronization phase time 
order express timeout transition allowed synchronization possible speci ed time strong time semantics 
states transition enabled forced re interval 
stochastic nets providing nets concrete temporal information stochastic distributions 
stochastic petri net transition associated random delay exponential probability density function rate bal 
stochastic petri net analysed respect example expected number tokens place probability particular condition failure mean number rings transition unit time 
stochastic information especially suited performance evaluation 
uml interest object oriented programing paradigm re ected development similar methods languages analysis design 
large number languages strengths weaknesses rst draft uml uni ed modeling language emerged eventually de facto standard 
uml ered standardization object management group omg 
uml modeling language aimed analysis design speci cation communication documentation primarily software systems 
evaluating uml speci cation language remembered domain covers 
substantial description uml see 
language combines structural process data type views section 
data types modeled class statechart diagrams behaviour system parts captured interaction diagrams 
structural aspects considered component deployment diagrams 
uml model built collection graphical elements including classes relationships states actors diagrams 
syntax semantics de ned uml meta model de ne elements combined extent meaning combinations 
fact semantics uml de ned semi formally restricts possibility compare verify models 
ort put developing formal semantics uml 
parts uml fairly easy de ne formally statechart diagrams parts rely heavily descriptions written natural language 
main challenge provide semantics covers aspects language connecting aspects di erent types diagrams 
discussion issues dealt formalizing uml see 
uml real time systems uml provide means de ning explicit temporal constraints properties temporal ordering events 
language allows constraints associated graphical element describing syntax semantics constraints 
number extensions proposed allows formal treatment temporal information example providing de ned format constraints 
object constraint language object constraint language ocl developed expression language suited de ne constraints uml models wk 
declarative meaning de nes restrictions possible values attribute take describing restriction violated 
language provides number built types ranging basic ones integers strings collections sets sequences 
types constructed entities uml model classes 
typed expressions built constants uml entities operations de ned types 
examples operations equality disjunction booleans addition integers 
collection types typically complex operations intersection elements 
expressions type boolean called constraints di erent ways uml model 
de ne invariants classes types interfaces describes property relationship attributes class hold 
preconditions postconditions operations methods stating postcondition holds method called postcondition hold method nished 
conditions transition diagrams guards de ne conditions transition allowed occur 
additionally expressions type identify speci object set objects actions events transition diagram 
syntax semantics ocl fairly straightforward consideration tting ocl concepts uml 
uml aspect inheritance ocl de nes constraints inherited objects uml model 
invariants postconditions may strengthened weakened subclass 
preconditions hand may weakened strengthened subclass 
reason rules substitution principle instance class expected possible instance subclass 
general principle uml inheritance valid ocl 
uml rt uml real time uml rt extends basic uml constructs facilitate design complex embedded real time software systems sel 
constructs origin real time speci modelling language room modi ed uml 
language focuses primarily specifying architecture software systems major components externally visible properties communication 
argued decisions architectural design high impact design phase pro ts modeling language 
basic concepts uml rt adds new building blocks standard uml meta model 
capsules ports connectors model structure system fourth protocols models communication system 
behaviour system components modeled standard uml statecharts containing state variables changes expressed programming language 
capsules model complex software components concurrent physically distributed 
internal structure components described sub capsules connections 
component interacts surroundings sub capsules set ports parts component visible objects 
ports connected statechart diagram de ning functionality component port sub capsule 
way capa example uml rt concepts 
message sent port handled directly capsule forwarded suitable sub component 
shows example concepts 
port capsule capa connected statechart connected sub capsule 
addition capsule internal port visible capsule connecting port sub capsule statechart 
protocol de nes number participating roles signals sent received role 
contain speci cation valid sequences signals encoded statechart 
speci cation sequence considered valid 
connectors model communication channels ports 
ports realize di erent roles mutual protocol 
protocols connectors de ne behaviour system architectural level 
modeling real time systems compared standard uml uml rt provides additional support modeling architecture interactive systems 
provide support modelling timing issues 
possible add structures uml rt model allows concepts timeouts supported language 
consequently uml rt facilitate reasoning timeliness properties model 
uml rt provided alternative formal semantics structural behavioural parts uml rt model de ned semantically terms ow graphs 
allows formal treatment models including comparison optimisation 
uml pro le schedulability performance time omg issued request proposals regarding new uml pro le addressing speci problems related development real time systems 
resulted joint response group omg member companies proposing pro le covers example timing concepts analysis methods scheduling concurrency omg 
main aim pro le de ne standard means capture real time modeling concepts particular allow exchange models di erent modeling tools tools modeling analysis 
pro le allow wide variety real time systems modeled restricted single temporal domain 
hand supposed support essentially type analysis method including schedulability performance analysis methods 
requirements somewhat contradictory analysis methods typically consider particular domain making assumptions underlying models time concurrency problem solved de ning notion time resources instantiated provide concrete notions deadlines timers 
de nes minimal set annotations scheduling performance analysis capture common elements di erent real time speci methods extended additional concepts needed particular analysis algorithm 
include new analysis method pro le framework method provider de nes attributes essential method ties models resources time 
applying method model developer iteratively synthesize model transform format contains information appropriate method 
order method useful synthesizing done automatically 
modeling time pro le distinguishes types metric time physical simulated 
physical time considered continuous dense unbounded fully ordered simulated time models timing concepts visible system viewpoint 
discrete dense possibly non monotonic 
simulated time associated physical time means periodic clocks associate temporally close physical time instants clock tick granularity 
allow simulated time models pro le contains de nitions timers clocks 
timer generates certain timeout event speci ed time instant reached clocks periodically generate clock tick events 
clock timer associated clock provides simulated time 
number attributes common resolution drift 
modeling schedulability mentioned pro le describes set common scheduling annotations sucient perform basic schedulability 
expected individual tool vendors provide specialized annotations allow extensive analysis 
annotations de ned pro le include priority absolute relative deadline worst case completion time 
application divided scheduling jobs granularity suits scheduler system 
schedule contains assignment jobs execution entities processors time intervals 
methodology create schedule referred scheduling policy consists algorithm guided number optimality criteria 
analysing model application respect schedulability requires knowledge scheduling policy resource allocation policy 
requires analysis method ts 
method uses speci annotations synthesizing method provided 
real time programming languages speci cation performed part development process typically act base design implementation 
means usefulness speci cation language method depends concepts correspond constructs programming language 
section presents features programming languages required helpful implementing real time systems bw ks 
broadly speaking ways implement real time systems respect demands programming languages 
possibility standard language combined real time operating system 
task written separate program issues communication scheduling handled operating system 
problem type programming programmer little control real time related issues 
system designed way temporal requirements ensured platform example selecting certain periods worst case execution times 
programs developed way typically su er bad portability real time issues handled di erently di erent systems 
tend dicult maintain extend platform dependent parameters built design hard discover original requirements uenced 
tendency years way developing real time systems real time related functionality provided programming language 
examples languages real time support include ada bar real time java 
standard languages way extending standardised interface real time primitives operating system speci ed posix standard iee 
rest section focuses alternative methods languages contain real time related features 
comparative evaluation languages hs 
general issues language programming guidelines especially important realtime systems 
partly safety critical additional complexity introduced temporal perspective stresses readability simplicity demands 
general issues include consistent intuitive syntax semantics 
language support encapsulation package module concept allows information hiding data types 
language strong type system minor programming mistakes discovered compilation resulting reliable software 
preferably type system allow programmer de ne new types simple structured 
concurrency language suited real time applications provide programmer explicit control concurrency 
includes de ning concurrent activities dealing synchronisation communication 
languages requires concurrent activities known compile time said support static structure concurrency 
exible possibility example java ada posix dynamic structure concurrency new concurrent activities created execution 
broad de nition synchronisation means constraining way execution actions di erent activities may interleaved 
term refers speci task bringing processes simultaneously prede ned states 
synchronisation may required activities share common resources memory peripheral devices 
alternatively synchronisation needed ensure correct functionality relative order activities perform actions ects nal result 
shared memory setting constructs semaphores critical regions monitors achieve synchronisation controlled communication activities sg 
ada semaphores implemented means message passing constructs monitors constructed 
type monitors called protected objects ensures mutual exclusion critical sections 
posix allows activities share common memory provides semaphores monitors called mutexes 
java monitors implemented synchronised methods executed activity simultaneously 
alternative communication style messages sent received activities 
message exchange synchronous blocking sender message received asynchronous 
activities may allowed broadcast messages activities simultaneously restricted recipient message 
ada uses synchronous message style posix supports asynchronous message passing 
concurrent languages real time systems developed general imperative possibly objectoriented programming languages extended permit concurrency 
exist languages especially designed type applications 
pure functional languages inherently concurrent absence side ects ensures expressions evaluated order 
erlang concurrent functional language developed ericsson suit implementation large highly dynamic systems telephone switches 
esterel synchronous language built model concurrent activities able exchange information perform computation zero time bg 
conceptual assumption ensures system behaves intended independently concurrent activities interleaved execution 
implementation course satisfy assumption long input processed possible results output new input occur system function correctly 
example synchronous language lustre 
real time facilities discussed cases systems ensured satisfy temporal constraints carefully selected task parameters 
level portability reusability increased language provides real time related primitives 
wider range systems respect types temporal constraints developed 
interfacing time systems time relevant terms temporal restrictions directly ects functional behaviour 
example pressing button twice may give di erent results depending amount time events 
requires program access clock primitives language device drivers internal external clock 
ada posix java provides clock primitives 
useful facility possibility delay activity certain time relative period time 
explicitly delaying activity simply making period time allows scheduler distribute unused resources activities delay 
languages provide primitives waking delayed activities prematurely 
related concept timeouts restrictions time activity prepared wait communication 
term denote restrictions time allowed execution certain part activity 
shows example timeouts ada 
activity waits message arrives seconds timeout alternative chosen 
alternatively timeout construct delay de ne absolute timeout 
select accept message data perform actions accept message data perform actions delay perform timeout actions select message timeout ada 
select delay perform timeout actions abort perform actions select action timeout ada 
example timeouts actions consider ada code states execution actions takes second aborted timeout actions performed 
previous example action timeouts speci ed absolute time 
representing temporal properties real time languages ada posix allow temporal properties periods deadlines explicitly de ned 
intended behaviour achieved timeouts delays 
example language includes constructs real time euclid ks activities de ned restart certain periodicity response certain events 
real time java activities assigned scheduling parameters deadline execution time 
subclassing speci task models de ne example periodic event triggered activities 
satisfying temporal requirements methods scheduling schedulability analysis highly dependent execution times tasks 
extracting information implementation dicult languages 
problem hardware structures caches pipelines branch predictors improving average performance lead worse performance worst case scenario 
consequence structures execution time task depends highly tasks interleaved 
small underestimation worst case execution time wcet cause severe system degradation wcet analysis typically required produce safe approximations may higher actual value lower 
order maximise utilisation resources processor time approximations tight possible 
programming languages designed facilitate execution time analysis example restricting jump loop constructs recursive function calls pointers 
scheduling languages allow programmer uence scheduling algorithm 
scheduling ada priority programmer assigns priorities tasks 
programmer choose di erent policies resource locking interrupt handling 
posix allows dynamically assigned priorities supports number di erent priority scheduling algorithms 
similar features provided real time java addition language includes mechanism online feasibility analysis 
schedulable object created dynamically tested admitted respect current resources 
object assigned appropriate priority 
summary appropriateness speci cation method language strongly uenced intended purpose speci cation 
speci cation guide design implementation reasoning important properties system simply way capture intuition system 
speci cation typically abstraction focusing aspects system ignoring aspects simplify reasoning 
specifying real time systems important focus aspects concurrency causal temporal behaviour properties liveness safety 
speci cation methods suggested real time systems contain elaborate notion time basic form 
typically focus concurrency synchronisation process algebras petri nets functionality structure uml order reason temporal behaviour methods extended temporal domain integrated concepts method 
done speci temporal operations constructs adopting suitable temporal logic 
today real time systems implemented standard imperative language real time related aspects handled operating system 
developer achieves higher degree control programming language supports concurrency direct access time delay timeout constructs 
addition languages provide functionality programmer uence scheduling resource policies dynamically 
ad rajeev alur david dill 
theory timed automata 
theoretical computer science april 
fundamental study 
ah alur henzinger 
logics models real time survey 
de bakker huizing de roever rozenberg editors proceedings real time theory practice volume lncs pages berlin germany june 
springer 
armstrong williams virding 
concurrent programming erlang 
prentice hall englewood cli nj 
bal balbo 
stochastic petri nets 
lecture notes computer science 
bar john barnes 
programming ada 
addison wesley 


speci cation real time systems 
editor years pages universit de nantes france 
institut de recherche en informatique de nantes 
bcn 
tools specifying real time systems 
real time systems 
bg berry gonthier 
esterel synchronous programming language design semantics implementation 
science computer programming 
greg james gosling benjamin peter steve mark turnbull 
real time speci cation java 
addison wesley 

temporal logics real time system speci cation 
acm computing surveys march 
grady booch james rumbaugh ivar jacobson 
uni ed modeling language user guide 
addison wesley reading massachusetts usa 
bst henri bal jennifer steiner andrew tanenbaum 
programming languages distributed computing systems 
acm computing surveys september 
giorgio 
hard real time computing systems predictable scheduling algorithms applications 
kluwer academic publishers 
bw burns wellings 
real time systems programming languages 
addison wesley rd edition 
cha 
duration calculus logical approach real time systems 
lecture notes computer science 
cle rance cleaveland 
language real time schedulability analysis 
proceedings real time systems symposium pages raleigh durham north carolina december 
dk je rey douglas richard kemmerer 
symbolic execution tool testing formal speci cations 
international symposium software testing analysis pages 
ds roger duke graeme smith 
temporal logic speci cations australian computer journal 
epo ehrig padberg orejas 
basic views aspects integration speci cation formalisms 
bulletin european association theoretical computer science october 
columns formal speci cation column 
grosu broy selic gh 
stefanescu 
calculus uml rt speci cations 
seventh oopsla workshop behavioral semantics oo business system speci cations vancouver canada monday october th 
carlo ghezzi dino mandrioli mauro general way put time petri nets 
acm sigsoft notes proceedings fifth international workshop software speci cation pittsburgh pennsylvania usa pages may 
gup vineet gupta 
chu spaces model concurrency 
phd thesis stanford university september 
han hansson 
time probability formal design distributed systems 
elsevier 
halbwachs caspi raymond pilaud 
synchronous data ow programming language lustre 
proceedings ieee september 
hayes jones 
understanding di erences vdm technical report umcs university manchester computer science department august 
hmp tom henzinger zohar manna amir pnueli 
temporal proof methodologies real time systems 
acm editor popl 
proceedings eighteenth annual acm symposium principles programming languages january orlando fl pages new york ny usa 
acm press 
hoa hoare 
communicating sequential processes 
prenticehall englewood cli nj 
hs 
comparative evaluation high level real time programming languages 
real time systems journal 
iee ieee 
ieee standard information technology portable operating system interface posix rationale informative ieee new york ny usa 
jms jahanian mok douglas stuart 
formal speci cation real time systems 
technical report cs tr university texas austin june 
kem richard kemmerer 
testing formal speci cations detect design errors 
ieee transactions software engineering january 
ks 
real time euclid language reliable real time systems 
ieee trans 
software eng september 
ks krishna shin 
real time systems 
mcgraw hill 
andrew lyons 
uml real time overview april 
rational software whitepaper www rational com products whitepapers jsp 
mil robin milner 
lectures calculus communicating systems 
brookes roscoe winskel editors seminar concurrency volume pages berlin 
springerverlag 
lecture notes computer science vol 

mpw milner parrow walker 
calculus mobile processes ii 
information computation september 
mt moller chris 
temporal calculus communicating systems 
baeten klop editors concur theories concurrency uni cation extension volume lecture notes computer science pages amsterdam netherlands august 
springer verlag 
mur murata 
petri nets properties analysis applications 
proceedings ieee april 
omg omg 
response omg rfp schedulability performance time june 
omg document number ad www omg org cgi bin doc ad 
os 
olderog 
design real time systems interface duration calculus 
desel editor structures concurrency theory workshops computing pages 
springer verlag 
par joachim parrow 
verifying csma cd protocol ccs 
aggarwal editor proceedings th ifip symposium protocol speci cation testing veri cation pages 
north holland june 
par joachim parrow 
pi calculus 
jan bergstra ponse scott smolka editors handbook process algebra pages 
elsevier science 
sel selic 
uml modeling complex real time systems 
lecture notes computer science 
sg silberschatz 
operating system concepts 
addison wesley edition 
bran selic garth jim mcgee ian 
room object oriented methodology developing real time systems 
gene forte uller editors th int 

computer aided software engineering pages july 
som sommerville 
software engineering 
addison wesley reading ma edition 
spi spivey 
notation manual 
prentice hall international series computer science nd edition 
sz john 
state transition techniques specifying real time system review 
proceedings australasian conference parallel real time systems part 
peter van emde boas 
formalizing uml mission impossible 
luis andrade ana moreira deshpande stuart kent editors proceedings oopsla workshop formalizing uml 


vg van glabbeek 
notes methodology ccs csp 
theoretical computer science may 
vv hans van vliet 
software engineering principles practice 
john wiley sons chichester 
wd woodcock davies 
speci cation proof re nement 
prentice hall international series computer science 
wk jos warmer kleppe 
object constraint language precise modeling uml 
addison wesley 

