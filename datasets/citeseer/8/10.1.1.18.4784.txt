appear calculational system design proceedings international summer school marktoberdorf ed 
broy nato asi series ios press amsterdam 
mechanizing development software douglas smith kestrel institute avenue palo alto california december 
presents framework software development refinement 
framework category specifications 
key idea representing knowledge programming concepts algorithm design datatype refinement expression simplification means taxonomies specifications morphisms 
examples drawn working systems specware planware 
contents 
overview 
basic concepts 
specifications 

morphisms 

category specs 

diagrams 

structuring specifications 

refinement diagrams 

logic morphisms code generation 

software development refinement 
constructing specifications 

constructing refinements 

development sorting algorithms 

sorting algorithm design 

sorting datatype refinement 

sorting expression optimization 

sorting summary 

domain specific software development 
constructing requirement specification 

datatype refinement problem reformulation 

scaling 
design classification taxonomies refinements 

tactics 

summary containers bags sequences specification sorting 
overview software system viewed composition information variety sources including ffl application domain ffl requirements system behavior ffl software design knowledge system architectures algorithms data structures code optimization techniques ffl run time hardware software physical environment software execute 
presents framework representing various sources information composing context refinement process 
framework founded category specifications 
morphisms structure parameterize specifications refine 
colimits compose specifications 
diagrams express structure large specifications refinement specifications code application design knowledge specification 
framework features collection techniques constructing refinements formal representations programming knowledge 
algorithmic concepts datatype refinements program optimization rules software architectures user interfaces represented diagrams specifications morphisms 
arrange diagrams taxonomies allow incremental access construction refinements particular requirement specifications 
example user may specify scheduling problem select theory global search algorithms algorithm library 
global search theory construct refinement scheduling problem specification specification containing global search algorithm particular scheduling problem 
framework partially implemented research systems specware planware 
specware provides basic support composing specifications refinements generating code 
code generation specware supported morphisms translate specification language logic logic particular programming language 
specware intended general purpose industrial settings 
extends specware taxonomies software design theories support constructing refinements 
planware provides highly automated support requirements acquisition synthesis high performance scheduling algorithms 
remainder covers basic concepts key ideas approach software development refinement particular concept design classification 
simple example carried algorithm design datatype refinement expression simplification 
discuss application techniques domainspecific refinement planware 
assumes rudimentary knowledge logic category theory details categories interest introduced motivated examples 
spec container sorts container op empty 
container op singleton container op join container container container constructors singleton construct container axiom container join empty empty join op container boolean definition axiom empty false axiom singleton axiom join definition spec specification containers 
basic concepts 
specifications specification finite presentation theory 
signature specification provides vocabulary describing objects operations properties domain interest axioms constrain meaning symbols 
theory domain closure axioms rules inference 
example specification partial orders notation adapted specware 
introduces sort infix binary predicate called le constrained usual axioms 
specware allows higher order specifications order formulations sufficient 
spec partial order sort op le boolean axiom reflexivity le axiom transitivity le le le axiom antisymmetry le le spec example containers constructed binary join operator represent finite collections elements sort specification shown includes definition means axioms 
operators required total 
constructor clause asserts operators singleton construct sort container providing basis induction container 
generic term expression refer term formula sentence 
model specification structure sets total functions satisfy axioms 
software development purposes defined notion semantics mind specification denotes set possible implementations computational model 
currently regard functional programs 
denotational semantics maps classical models 

morphisms specification morphism translates language specification language specification preserving property provability theorem source specification remains theorem translation 
specification morphism map sort operator symbols domain spec symbols codomain spec specification morphism required axiom translates theorem follows specification morphism translates theorems domain specification theorems codomain 
example specification morphism partial order integer morphism partial order integer fe 
integer le 
translation expression morphism straightforward application symbol map example partial order axiom le translates axioms partial order remain provable integer theory translation 
example parameterized specification treated morphism 
specification bag appendix parameterized spec triv single sort spec riv sort spec morphism morphism bag parameterization fe 
semantics specification morphism contravariant functor mod maps specification category models specification morphism reduct functor mod mod 
morphisms come variety flavors 
extension import inclusion specs 
example build theory partial orders importing theory preorders 
import morphism fe 
le 
leg 
spec reorder sort op le boolean axiom reflexivity le axiom transitivity le le le spec spec partial order import reorder axiom antisymmetry le le spec definitional extension written import morphism new symbol axiom defines 
definitions implicit axioms existence uniqueness 
semantically definitional extension property model domain unique expansion model codomain 
example container formulated definitional extension re container spec re container sorts container op empty container op singleton container op join container container container constructors singleton construct container axiom container join empty empty join spec spec container imports re container definition axiom empty false axiom singleton axiom join definition spec 
category specs specification morphisms compose straightforward way composition finite maps 
easily checked specifications specification morphisms form category spec 
colimits exist spec easily computed 
suppose want compute colimit oo form disjoint union sort operator symbols define equivalence relation symbols iff signature colimit known pushout case collection equivalence classes wrt cocone morphisms take symbol equivalence class 
axioms colimit obtained translating collecting axiom example suppose want build theory partial orders composing simpler theories 
spec sort op le boolean spec gamma 
spec preorder import axiom reflexivity le axiom transitivity le le le spec spec antisymmetry import axiom antisymmetry le le spec pushout antisymmetry reorder isomorphic specification partial order section 
detail morphisms fe 
le 
leg preorder antisymmetry 
equivalence classes ffe fle le colimit spec sort rename operator rename le 
furthermore axioms antisymmetry preorder translated axioms colimit 
partial order 
category specifications colimit acts kind union operator pushout collects symbols antisymmetry preorder morphisms indicate symbols shared 
colimit universal property computes simplest specification 
example pushout operation instantiate parameter parameterized specification 
binding argument parameter represented morphism 
form specification bags integers compute pushout bag riv integer bag riv fe 
riv integer fe 

example specification sequences built container pushouts 
regard container parameterized binary operator spec binop sort op bop spec morphism container parameterization binop container fe 
bop 
define refinement arrow extends binary operator semigroup spec associativity import binop axiom associativity join join join join spec pushout associativity binop container produces collection specification associative join operator proto seq core sequence theory appendix 
diagrams roughly diagram graph morphism category usually category specifications 
example pushout described started diagram comprised arrows fflffl reorder antisymmetry computing pushout diagram produces diagram fflffl reorder fflffl antisymmetry partial order diagram commutes composition arrows paths start finish node yields equal arrows 

structuring specifications colimits construct large specification diagram specs morphisms 
morphisms express various relationships specifications including sharing structure inclusion structure parametric structure 
examples appear 
example finest grain way compose partial order colimit fflffl reflexivity antisymmetry example appendix gives structured specification sorting bags linear order 

refinement diagrams described specification morphisms help structure specification refine specification 
morphism refinement intended effect reduce number possible implementations passing domain spec codomain 
sense refinement viewed embodying particular design decision property corresponds subset possible implementations domain spec possible implementations codomain 
software refinement want preserve extend structure structured specification versus flattening colimit 
specification structured diagram corresponding notion structured refinement diagram morphism 
diagram morphism diagram diagram consists set specification morphisms node spec node certain squares commute functor underlies diagram natural transformation underlies diagram morphism 
notation diagram morphisms 
example datatype refinement refines bags sequences diagram morphism bag bag seq bag riv triv fflffl oo bag seq bag seq riv oo kk bag seq domain codomain shown boxes square commutes 
bag seq definitional extension seq provides image bag theory 
specs bag seq bag seq details refinement appendix interesting content spec morphism morphism bag bag seq 
bag seq empty bag 
bag empty empty bag 

bag empty nonempty 

bag nonempty singleton bag 
bag singleton singleton bag 

bag singleton nonsingleton bag 

bag nonsingleton 
bag bag union 
bag union bag 
bag size 
bag diagram morphisms compose straightforward way spec morphism composition 
easily checked diagrams diagram morphisms form category 
colimits category computed colimits spec 
sequel generally term refinement mean diagram morphism 

logic morphisms code generation inter logic morphisms translate specifications specification logic logic programming language 
see details 
useful translating specification logic logic supported various theorem provers analysis tools 
useful translating theory libraries various systems 

software development refinement code development correct construction code formal refinement process shown left 
refinement process starts specification requirements desired software artifact 
represents structured specification diagram arrows refinements represented diagram morphisms 
refinement embodies design decision cuts number possible implementations 
inter logic morphism translates low level specification code programming language 
semantically effect narrow set possible implementations just specification refinement viewed constructive process proving existence implementation specification proving consistency 
clearly key issues supporting software development refinement construct specifications construct refinements 
sequel treats techniques constructing refinements 

constructing specifications specification development environment supplies tools creating new specifications morphisms structuring specs diagrams composing specifications importation parameterization colimit 
addition software development environment needs support large library reusable specifications typically including specs common datatypes integer sequences finite sets common mathematical structures partial orders monoids vector spaces addition generic operations libraries system may support specialized construction tools libraries domain specific theories resource theories generic theories domains satellite control transportation 

constructing refinements refinement development environment supplies tools creating new refinements 
innovations showing library reusable generic refinements applied produce refinements specification 
focus mainly refinements embody design knowledge algorithm design datatype refinement expression optimization 
believe types design knowledge similarly expressed exploited including interface design software architectures domain specific requirements capture see section 
planware 
addition generic operations libraries system may support specialized construction tools libraries domain specific refinements 
key concept design knowledge datatype refinement algorithm design software architectures program optimization rules visualization displays expressed refinements diagram morphisms 
domain refinement represents structure required user specification order apply embodied design knowledge 
refinement embodies design constraint effect reduction set possible implementations 
codomain refinement contains new structures definitions composed user requirement specification 
ff left shows application library refinement structured specification library refinement selected 
applicability refinement shown constructing classification arrow classifies having structure making explicit structure refinement applied computing pushout category diagrams 
creative lies constructing classification arrow 

development sorting algorithms goal section show simple example refines requirement spec code applying algorithm design refinement datatype refinement expression optimization refinement 
step refinement specification sorting bag arbitrary linear order 
full specification import sorting appendix spec sorting import bag seq op sorted 
bag seq boolean def sorted ordered seq bag op sorting bag seq axiom sorted sorting spec diagram serves roadmap design steps covered subsections 
divide conquer refinement applied datatype refinement bags implemented sequences expression simplification refinement applied 
squares represent application library refinements main line refinement descends directly sorting 
divide conquer ff sorting ff divide conquer scheme sorting alg ff bag ff new expression ff sorting alg ff bag seq equational simplification sorting alg ff 
sorting algorithm design algorithm design applying defined problem solve 
problem theory expresses structure problem input datum find feasible solution satisfying problem requirement constraint 
call input datum problem instance note problem theory intended specify function 
suppose user decides apply generic refinement divide andconquer algorithms 
empty seq sort empty seq gamma fflffl empty seq hi id hi empty seq oo singleton seq sort singleton seq gamma fflffl singleton seq id singleton seq oo sorting concat gamma fflffl hx sorting hz merge oo principle divide conquer solve small problem instances direct means solve larger problem instances decomposing solving pieces composing resulting solutions 
left shows mergesort generalized kind divide conquer cases 
bottommost square shows familiar divide andconquer case input decomposed subproblem instances solved produce turn composed form solution decomposition operator loosely specified inverse constructor concat 
cases decompose solve compose pattern decomposition operator inverse constructor 
datum hi tuple treated output inverse constant constructor hi sole element empty product sort denoted unit 
cases differ third input decomposes subproblem easily solved identity function appropriate sort 
domain spec simple divide conquer refinement abstracts mergesort example 
supposes cases indexed signature constructor similar homomorphism algebras constructors 
abstraction lies treating operator example problem theory 
subscripted denote problem requirement constraints odecompose gammai specifies decomposition operator case 
discriminator represents condition odecompose gammai decompose input 
soundness axiom relates odecompose ocompose asserts problem instance decompose subproblem instances subproblem instances feasible solutions respectively compose form feasible solution input similar comments hold soundness axioms 
operator founded order assure termination axioms omitted simplicity 
general scheme problem reduction theories including divide conquer 
idea different order divide conquer theory possible constructor signature 
codomain spec divide conquer refinement contains schematic definition top level divide conquer functions schematic requirement specifications morphism divide andconquer functions satisfy requirement specifications corresponding instance divide conquer function satisfies requirement specification 
complication needs explaining 
specware requires functions total deterministic operation spec implicit axioms existence uniqueness solutions 
simplifies logic specware complicates treatment nondeterministic functions arise naturally refinement due levels abstraction 
consider example operation decomposes bag element remainder bag inverse insert bag 
bags ultimately implemented lists natural rest perform decomposition 
consider equal bags 
represented decompose 
represented decompose 
decomposition functional bags functional lists 
various approaches problem 
observe extra required naturally nondeterministic operator deterministic unnecessary programming point view nondeterminism don care variety solution extra force unique solution constraint posed programming system software requirements 
solution problem treat operations may need nondeterministic existential quantification 
place decomposition operators existentially quantified requirement constraints development divide conquer algorithm sorting begins con spec theory sorts op boolean spec spec divide conquer import dro sort op op boolean axioms founded order op boolean op odecompose unit boolean op ocompose unit boolean axiom soundness odecompose hi ocompose hi axiom discriminator decompose odecompose hi op boolean op odecompose boolean op ocompose boolean axiom soundness odecompose ocompose axiom discriminator decompose odecompose op boolean op odecompose boolean op ocompose boolean axiom soundness odecompose ocompose axiom discriminator decompose odecompose axiom xor xor spec simple divide conquer algorithm theory spec divide conquer scheme import divide conquer op 
axiom ocompose hi op axiom ocompose op axiom ocompose definition axiom odecompose hi axiom odecompose axiom odecompose definition theorem spec parameterized divide conquer algorithm struction morphism problem theory sorting theory 
bag 
seq 
sorted 
morphism problem theory divide conquer inclusion straightforward propagation obtain translations components divide conquer 
bag 
seq 
sorted 




odecompose 
ocompose 
complete classification arrow attempt translate remaining operators expressions sorting 
alternative translations give rise different sorting algorithms 
ways proceed 
approach choice set standard decomposition operators library 
tactic uses soundness axioms derive specifications composition operators 
approach allows derivation insertion sort mergesort various parallel sorting algorithms 
dual approach choose set standard composition operators library soundness axioms derive decomposition operators leading selections sort heapsort quicksort 
approach detail sketch second 
suppose choose constructor set bag singleton bag bag basis decomposition relation input domain bag 
gives partial signature morphism 
bag 
seq 
sorted 

sorting 

bag 
empty bag 
odecompose 
empty bag ocompose 

singleton bag 
odecompose 
singleton bag ocompose 

nonsingleton bag 
odecompose 
bag union ocompose 
soundness axiom odecompose ocompose translated sorting ocompose translation 
technique called allows inference tools deduce suitable translation ocompose 
operator symbol ocompose replaces occurrence ocompose fresh existentially quantified variable scope quantifiers boolean odecompose formula satisfiability properties original translated sorting partial morphism yielding seq boolean bag bag union sorted sorted sorted straightforward proof formula sorting finds witness results translation ocompose sorted def sorted 
ordered seq bag assumption bag union ordered bag union seq bag assumption seq bag ordered bag union seq bag seq bag seq bag unify assumption term variables generally pick part witness assumptions expressed variables case yielding ocompose 
ordered ordered ordered bag union seq bag seq bag seq bag course specification merge operation 
take translation ocompose know soundness axiom translates theorem sorting construction 
remaining steps constructing classification arrow similar 
ocompose soundness derive witness sorted def sorted 
ordered seq bag assumption singleton bag ordered singleton bag seq bag bag seq conv axiom ordered seq bag singleton seq seq bag equality congruence ordered singleton seq simplifying ordered singleton seq true singleton seq yielding translation ocompose 
singleton seq ocompose soundness derive witness sorted def sorted 
ordered seq bag assumption empty bag ordered empty bag seq bag bag seq conv axiom ordered seq bag empty seq seq bag equality congruence ordered empty seq simplifying sorting axiom ordered empty seq true empty seq yielding translation ocompose 
empty seq classification arrow complete 
bag 
seq 
sorted 

sorting 

bag 
empty bag 
odecompose 
empty bag ocompose 
empty seq 
singleton bag 
odecompose 
singleton bag ocompose 
singleton seq 
nonsingleton bag 
odecompose 
bag union ocompose 
ordered ordered ordered seq bag bag union seq bag seq bag note classification arrow translates symbol expression symbol 
commonly occurring situation treated extending codomain diagram definitional extensions necessary 
sequel assume treatment need symbol expression translation arises 
compute pushout divide conquer ff sorting ff divide conquer scheme sorting alg obtain refinement sorting contains definition mergesort algorithm shown 
example sketch derivation quicksort spec sorting alg import bag seq op sorted 
bag seq boolean definition sorted ordered seq bag op sorting bag seq theorem sorted sorting definition sorting axiom empty bag empty bag sorting axiom singleton bag singleton bag sorting axiom nonsingleton bag bag union sorting sorting sorting definition op seq axiom empty seq op seq axiom singleton op seq seq seq axiom ordered ordered ordered seq bag bag union seq bag seq bag spec divide conquer sorting algorithm derivation variant quicksort dual derivation mergesort select simple set constructors basis decomposition operations select simple set constructors basis composition operators 
particular return stage filling partial morphism 
bag 
seq 
sorted 

sorting 

bag 
odecompose 
ocompose 
choose set sequence constructors seq singleton seq basis composition get 
bag 
seq 
sorted 

sorting 

bag 
odecompose 
ocompose 
empty seq 
odecompose 
ocompose 
singleton seq 
odecompose 
ocompose 
concat soundness axioms deduce translations decomposition requirement constraints 
interesting case operator symbol odecompose axiom soundness boolean ocompose formula translated partial morphism yielding bag boolean seq sorted sorted concat sorted straightforward proof formula sorting sorted def sorted 
ordered seq bag assumption concat ordered concat seq bag concat distributing axioms sorting bag seq conv ordered le ordered bag union seq bag seq bag simplifying seq bag le bag union results translation odecompose odecompose 
le bag union element bag equal element bag decomposes exhaustive 
course specification partition operation quicksort 
take translation odecompose know soundness axiom translates theorem sorting theory construction 
cases similar base cases mergesort 
divide conquer theory allows pleasing derivational symmetry algorithms simple decomposition operations complex composition operations dually algorithms simple composition operations complex decomposition operations 

sorting datatype refinement bag ff sorting bag seq suppose user decides bring mergesort algorithm closer implementation refining bags sequences 
datatype refinement discussed section 
detail appendix classification arrow bag sorting essentially inclusion comprised identity morphisms bag specs corresponding specs diagram sorting spec 
classification arrow pushout shown 
cocone arrows shown dashes help distinguish 
save space abbreviates bag seq bas 
pushout gives refinement sorting shown 
effect mergesort definition arises mainly translations morphism section 
note bag operators directly image classification arrow 
particular operators le seq bag extensions bag theory added construction sorting theory 
fact defined triv seq bag bag seq linear order bag seq conv bag seq bag seq triv seq bas bas seq linear order bas seq conv bas seq bas seq triv bas triv bag seq seq sorting bas sorting refining bags seqs sorting means pushout translate definitions remain defined translation 
auxiliary sorts operators datatype image classification arrow pushout simply translate constraints sorts operators 
constraints definitions translation definitional symbols constrained necessarily uniquely refinement required 
datatype refinement mainly serves bring spec closer programming language level 
datatype refinements dramatic effect refining complicated data structure efficiently implements type 
machinery applies 
leverage programming task apparent relatively small domain specification refines relatively large codomain spec extra bits information codomain added user spec essentially free classification arrow constructed 
examples include boolean expressions refining bdds sets fixed finite universe refining bit vectors hash tables finite relations refining trees 
spec sorting alg import bag seq seq op sorted 
bag seq seq boolean def sorted ordered seq bag op sorting bag seq seq theorem sorted sorting definition sorting axiom bag empty bag empty sorting axiom bag singleton bag singleton sorting axiom bag nonsingleton bag union sorting sorting sorting definition op 
seq axiom empty seq op seq axiom singleton op seq seq seq axiom ordered ordered ordered seq bag bag union seq bag seq bag spec sorting algorithm datatype refinement 
sorting expression optimization performing algorithm design datatype refinement opportunities optimizing various subexpressions 
transformation rules optimization tactics equational rewriting context dependent simplification finite differencing partial evaluation specialized techniques result dramatic improvements complexity final implementation 
show optimization techniques captured refinements applied manner refinements express algorithm design datatype refinement knowledge 
general approach representing expression optimization techniques stage process equation deduced expression simplified left hand side second spec reformulated exploit new theorem 
applicable metatheorem spec theorem spec occurrences replaced isomorphic specifications 
metatheorem justifies substitution operator specs creates spec isomorphism 
equational rewriting basic optimization technique uses equational inference user spec deduce equal term 
determine side simpler requires metric 
approach kids specware assign weight operator measuring complexity expression summing weights operator occurrence 
refinement express equational simplification spec expression sorts op expr spec spec new expression import expression op new expr axiom expr new expr spec spec equational simplification import new expression theorem expr new expr spec equational simplification es degenerate case approach representing expression optimization techniques 
presence theorem es required order included pushout spec refinement applied 
context dependent simplification generalization equational simplification 
suppose wish simplify expression expr context spec simplify expr want equations theorems spec contextual properties hold expr evaluated 
example simplifying branch conditional assume negation test conditional 
spec expression context import expression op boolean op new expr axiom expr new expr spec spec context dependent simplification import expression context theorem expr new expr spec finite differencing basic optimization nondegenerate structure codomain refinement 
idea finite differencing replace expensive expression loop incremental computation making extra variables 
refinement expresses correspondence concepts symbols refinement expensive expression may occur definition operator body definition new operator abstraction extra parameter maintained satisfy invariant 
theorem asserts equality invoked argument satisfies invariant 
developing classification arrow pushing substitution meta operator replaces occurrences realize implicit incremental benefits change context dependent simplification applied exploit local invariant 
spec expression function import expression sort op op def spec spec abstracted op import expression function sort dq op dq def theorem spec show equational simplification refinement works simplifying clauses definition sorting sorting alg simplification serves larger goal 
algorithm design usually opportunities simplify expressions due juxtaposition subexpressions different sources assembled means definitional scheme 
pertinent datatype refinement performed codomain constructed sort simplification definitions terms base sorts construction 
definitional axioms sorting sorting alg expressed terms quotient sort construction sort axiom bag seq seq perm 
simplification effect axioms terms sequences coercion functions 
show simplification singleton case clearly exemplifies essential reasoning pattern 
classification arrow partially filled user selected expression simplify 
unit 
boolean expr 
bag seq bag singleton bag singleton sorting new expr 
obtain translation new expr new expression axiom translate result find witness sorting theory shown 
proof draws axioms bag seq seq quantifier change theorems quotient 
relax completed classification arrow 
unit 
boolean expr 
bag seq bag singleton bag singleton sorting 
singleton seq new expr 
seq singleton seq sorting effect computing pushout refinement classification arrow add theorem asserting equality expressions context 
apply substitution meta operator creates isomorphic spec 
simplifying axioms sorting refinements effect shown 
special form restrict coerces value subsort provided subsort predicate holds context 
sorting alg shown shows effect aggregating clauses sorting definition conditional refinement 

sorting summary remaining step design definition spec refined applying divide conquer create possible simple merge operators straightforward usual linear time sequential merge alternate derivation yields log time parallel merge underlying sort 
way synthesize definition reduce legacy code existing library routine satisfy requirement specification 
reduction process uses general mechanism called connections theories 
code generation process uses library refinements specification language programing language currently specware 
bag seq bag singleton bag singleton sorting quantifier change seq bag seq quotient perm 
seq bag singleton bag singleton sorting simplifying defs bag singleton 
bag singleton seq singleton seq singleton seq sorting quantifier change subsort coercion seq seq relax singleton seq 
seq singleton seq sorting unifying singleton seq singleton seq inv inferred inverse axiom singleton seq singleton seq inv seq sorting singleton seq inv unfolding def seq sorting singleton seq singleton seq inv simplifying inverse axiom seq sorting quantifier change reverse subsort coercion seq seq seq singleton seq sorting simplification sorting axiom spec sorting alg import bag seq seq op sorting bag seq seq theorem sorted sorting definition sorting axiom empty seq sorting axiom singleton seq sorting axiom nonsingleton seq left split restrict right split restrict sorting sorting sorting definition spec spec sorting alg import bag seq seq op sorting bag seq seq theorem sorted sorting def sorting empty seq elseif singleton seq left split restrict right split restrict sorting sorting spec sorting algorithm simplifications 
domain specific software development sorting example shows exploit domain independent design knowledge uniformly represented refinements 
section planware system provides examples refinements represent domain specific design knowledge 
planware synthesis system specialized production scheduling algorithms 
extends specware libraries theories refinements scheduling specialized tactic controlling application design knowledge 
planware applies library refinements transform information user formal requirement specification typically thousands line specification text 
refinement code algorithm design datatype refinement expression optimization completely automatic 

constructing requirement specification planware provides answer question help automate acquisition requirements user assemble formal requirement specification user 
key idea focus narrow defined class programs specification covers class 
interaction user required order obtain refinement spec specification requirements user particular problem 
scheduling problem general compute set reservations set resources order accomplish set tasks subject certain constraints 
optionally may want optimize objective function 
sketch scheduling specification follows import scheduling import combines specifications time quantity task resource reservation set task set resource set reservation spec task sort task spec spec resource sort resource spec spec scheduling imports scheduling import sorts reservation resource task time schedule set reservation op scheduler set ask set resource schedule op tasks scheduled 
set ask schedule boolean def tasks scheduled tasks schedule tasks schedule task axiom tasks scheduled tasks scheduler tasks resources resource consumable asynchronously reusable fflffl synchronously reusable fflffl tth hh hh hh hh hh hh hh fflffl taxonomy resource theories op resources 
set resource schedule boolean def resources resources schedule schedule resource resources axiom resources resources scheduler tasks resources spec specifies scheduler input set tasks unspecified structure set resources unspecified structure 
generic problem constraints imposed output scheduler operator tasks scheduled 
asserts schedule input tasks resources 
asserts uses supplied resources 
example input cargo items fly aircraft schedule generated scheduler schedule items aircraft 
briefly describe domain specific refinements applied refine scheduling spec spec particular problem transportation problem power plant maintenance problem processor scheduling problem 
depicts taxonomy resource theories covers commonly occurring types resources 
resource theory refines consumable resources fuel crew duty time reusable resources aircraft trucks parking lots printers 
reusable resources refine synchronously reusable resources ships aircraft reservations resource instance synchronized passenger reservations particular airline flight start finish time 
synchronously reusable resources refine transportation resources spatial translation starting points unit capacity resources handle reservation time 
axiomatic formulation benefits object oriented classification hierarchy 
provide signature relevant operations resource 
specification resource type provides axiomatic characterization properties spec semilattice structured attribute sorts task attr sort op attribute task attr sort op attr reservation attr sort op le attr sort attr sort boolean axioms le bounded semilattice spec spec create constraint task attribute import semilattice structured attribute op consistent attr schedule boolean def consistent attr sched sched tasks attr le attr axiom consistent attr scheduler tasks resources spec refinement constructing requirement constraints scheduler shared instances resource class 
furthermore important theorems provide basis important algorithmic concepts recorded resource spec 
scheduling specification planware requests user select resource theory taxonomy 
composed arrow resource theory selected theory arrow refinement 
step user interacts spreadsheet interface simultaneously gathers information task attributes ordered semilattice information critical algorithm design 
skip details process order focus task attributes lifted requirement constraints scheduler see 
example consider release time attribute task suppose user selected lower bound start time attribute required reservations transportation resource 
domain specific refinement create problem requirement constraints shown codomain refinement creates new predicate asserted requirement constraint scheduler 
axiom asserts scheduler produce output satisfies new constraint 
context planware automatically constructs classification arrow task 
task attr sort 
time attribute 
release time attr 
start time le 
pushout automatically adds new structure including requirement constraint scheduler scheduling specification spec scheduling imports scheduling import sorts reservation resource task time schedule set reservation op scheduler set ask set resource schedule op tasks scheduled 
set ask schedule boolean def tasks scheduled tasks schedule tasks schedule task axiom tasks scheduled tasks scheduler tasks resources op resources 
set resource schedule boolean def resources resources schedule schedule resource resources axiom resources resources scheduler tasks resources op start time reservation time op consistent start time schedule boolean def consistent start time sched sched tasks release time start time axiom consistent start time scheduler tasks resources spec new requirement constraint scheduler asserts actual start time reservation earlier release date task reservation 
applying domain specific refinement attributes task gathered dialog user allows planware automatically generate requirements constraints scheduler user having know see write advanced mathematics 
datatype refinement problem reformulation datatype refinement plays important roles planware 
briefly mention problem formulation stage critical development algorithms stage 
set resource theta task theta time ff map resource set resource theta task theta time ff map resource ordered seq resource theta task theta time level planware schedule set reservations turn effectively tuples 
abstraction suited gathering formalizing user requirements quite poor implemented straightforward naive way lists 
planware exploits refinements shown second refinement exploits linear ordering time refine set sorted sequence ordered increasing time 
effect refine schedule relation schedule time function common representation scheduling algorithms 
main benefit output constraints scheduler function simplify tremendously 
put way refined data structures satisfy constraints implicitly built need explicit 
clear example phenomenon arises queens problem 
straightforward specification problem define theta bit matrix represent placement queens theta chessboard 
representation constraints satisfy queens row queens column queens queens descending diagonal 
constraint queen column allows refine bit matrix sequence th entry represents row number queen column 
effect cut space possible solutions building constraint queens 
furthermore specification queens problem condensed queens column constraint simplifies away refined representation 
phenomenon points benefit refinement approach supports users exploring alternative formulations problem 
complicated lots information efficient tighter representation problem junk search space representation derived simpler understandable formulation 
oftentimes current software development approaches inertia lots bits formulation may discourage users backing rethinking reformulating approach 
refinement approach encourages carefully staged design process user expresses essential requirements desired software begins explore decisions formulation algorithms architectures data structures 

scaling process refining specification described basic steps 
select refinement library 
construct classification arrow 
compute pushout resulting refinement cocone arrow basic refinement process repeated relevant sorts operators spec sufficiently explicit definitions easily translated programming language compiled 
section address issue basic process developed order scale size complexity library specs refinements container fflffl seq fflffl bag fflffl seq bag set fflffl taxonomy container datatypes expression tth hh hh hh hh hh hh hh hh fflffl new expression expression context expression function taxonomy expression optimization refinements grows 
key idea organize libraries specs refinements taxonomies 
second key idea support tactics levels theory specific tactics constructing classification arrows task specific tactics compose common sequences basic refinement process larger refinement step 

design classification taxonomies refinements productive software development environment large library reusable refinements letting user tactic select refinements decide apply 
need arises way organize library support access support efficient construction classification arrows 
library refinements organized taxonomies refinements indexed nodes taxonomies nodes include domains various refinements library 
taxonomic links refinements indicating refinement applies stronger setting 
sketches taxonomy datatypes collections 
details appendix arrows nodes express refinement relationship morphism proto seq proto bag extension axiom commutativity applied join constructor proto seqs 
datatype refinements indexed specifications taxonomy refinement finite bags finite sequences indexed node specifying finite bag theory 
shows beginnings taxonomy expression optimization refinements includes ones section 
shows taxonomy algorithm design theories 
refinements indexed node correspond families program schemes 
algorithm theory associated scheme sufficient prove consistency instance scheme 
nodes deeper taxonomy correspond specifications structure shallower levels 
generally wish select refinements indexed deeply taxonomy possible maximal amount structure requirement specification exploited 
algorithm taxonomy deeper node structure exploited problem problemsolving power brought bear 
roughly speaking narrowly scoped faster algorithms deeper taxonomy widely applicable general algorithms shallower nodes 
problems arise library refinements selecting appropriate refinement constructing classification arrow 
organize library refinements taxonomy ladder construction process provides incremental access applicable refinements simultaneously incremental construction classification arrows 
spec ff ff spec ff ff spec ff ff ff spec process incrementally constructing refinement illustrated ladder construction diagram left 
left side ladder path taxonomy starting root 
ladder constructed rung time top 
initial interpretation spec simple construct 
ladder constructed constraint solving process involves user choices propagation consistency constraints calculation colimits constructive theorem proving 
generally rung construction stronger colimit cocone constructed 
intent spec spec sufficient defined symbols serve codomain 
words implicitly defined symbols translated explicitly defined symbols spec ff spec ff spec constructed classification arrow spec selected refinement indexed node taxonomy constructing refinement spec straightforward compute pushout yielding spec compose arrows right side ladder pushout square obtain spec spec final constructed refinement 
rung construction simply matter computing colimit 
example problem theory generate test constraint satisfaction set maps global structure set recursive partition global search binary search backtrack branch bound local structure set relation genetic algorithms problem reduction structure divide conquer divide conquer complement reduction problem reduction generators dynamic programming branch bound game tree search local structure set binary relation local search steepest ascent simulated annealing tabu search local poset structure poset monotone function fixpoint iteration local semilattice structure semilattice genetic algorithms linear programming simplex interior point primal dual network flow ford fulkerson specialized simplex integer linear programming methods branch bound transportation nw algorithm assignment problem hungarian method gs csp set recursively partitioned set maps gs horn csp definite constraints constraint propagation taxonomy algorithm theories distinct arrows divide conquer sorting corresponding mergesort quicksort distinct cocones universal sorting algorithm corresponding colimit 
applying refinement select node taxonomy simple matter computing pushout 
algorithm design pushout simply instantiates definition schemes axiom schemes 
general automated method exists constructing ladder creative decisions 
general purpose design users involved guiding rung construction process 
domain specific settings certain conditions possible automate rung construction discussed section 
goal build interface providing user various general automated operations libraries standard components 
user applies various operators goal filling partial morphisms specifications rung complete 
user directed operation constraint propagation rules automatically invoked perform sound extensions partial morphisms specifications rung diagram 
constructive theorem proving provides basis important techniques constructing classification arrows 

tactics design process described far uses primitive operations selecting spec refinement library computing pushout colimit diagram diagram morphisms translating formula morphism witness finding derive symbol translations construction classification arrows 
operations accessible gui inevitably users notice certain patterns operations arising wish macros parameterized procedures call tactics 
provide higher level semiautomatic operations user 
need kinds tactics discerned 

classification tactics control operations constructing classification arrows 
divide conquer theory admits common tactics constructing classification arrow illustrated section 
tactic procedurally described follows user selects operator symbol dro requirement spec system analyzes spec obtain translations dro symbols user prompted supply standard set constructors input domain tactic performs composition relation soundness axiom derive translations oci 
tactic followed mergesort derivation 
tactic similar tactic selects constructors composition relations versus step uses solve decomposition relations step 
tactic followed quicksort derivation 
classification tactic context dependent simplification provides example 
procedurally user selects expression expr simplify type analysis infer translations input output sorts expr context analysis routine called obtain contextual properties expr yielding translation witness finding derive translation new expr 

refinement tactics control application collection refinements may compose common sequence refinements larger refinement step 
planware code generation tactic automatically applying spec code morphisms 
example refinement tactic context dependent simplification procedurally classification tactic construct classification arrow compute pushout apply substitution operation spec replace expr simplified form create isomorphism 
finite differencing requires complex tactic applies tactic context dependent simplification repeatedly order incremental expressions set applying expression function abstracted op refinement 
envision possibility construct tactics class tasks 
example algorithm theory may ways analyze sorts ops axioms determine various orders constructing translations classification arrows 
tactics divide conquer mentioned section 
example 

summary main message formal software refinement process supported automated tools particular libraries design knowledge brought bear constructing refinements requirement specification 
goal show diagram morphisms adequate capture design knowledge algorithms data structures expression optimization techniques refinement process 
showed apply library refinement requirement specification constructing classification arrow computing pushout 
discussed library refinements organized taxonomies techniques constructing classification arrows incrementally 
examples concepts described working specware planware systems 
reported result extended collaboration colleagues kestrel institute 
particularly acknowledge contributions david espinosa liu pavlovic stephen 
lambert meertens suggestions treating nondeterministic functions specware context 
liu smith planware domain specific synthesis high performance schedulers 
proceedings thirteenth automated software engineering conference october ieee computer society press pp 

meseguer general logics 
logic colloquium ehrig ed 
north holland amsterdam pp 

paige koenig finite differencing computable expressions 
acm transactions programming languages systems july 
smith top synthesis divide conquer algorithms 
artificial intelligence september 
reprinted readings artificial intelligence software engineering rich waters eds los altos ca morgan kaufmann 
smith kids semi automatic program development system 
ieee transactions software engineering special issue formal methods software engineering september 
smith structure design problem reduction generators 
constructing programs specifications moller ed 
north holland amsterdam pp 

smith constructing specification morphisms 
journal symbolic computation special issue automatic programming may june 
smith derivation parallel sorting algorithms 
parallel algorithm derivation program transformation paige reif wachter eds 
kluwer academic publishers new york pp 

smith classification approach design 
proceedings fifth international conference algebraic methodology software technology amast vol 
lncs springer verlag pp 

srinivas specware formal support composing software 
proceedings conference mathematics program construction moeller ed 
lncs springer verlag berlin pp 

containers bags sequences section parts taxonomy container structures refinements 
taxonomy adapted specware library 
refinement detail bag seq 
container fflffl seq fflffl bag fflffl seq bag set spec container sorts container op empty 
container op singleton 
container op join container container 
container axiom unit join empty empty join constructors empty singleton join construct container op empty 
container 
boolean definition empty 
axiom empty empty true axiom empty singleton false axiom empty join empty empty definition op nonempty 
container 
boolean def nonempty empty op container 
boolean definition axiom empty false axiom singleton axiom join definition spec spec proto seq translate colimit diagram nodes associative container bin op arcs bin op 
associative bin op 
container 
container binop 
join diagram container 
seq empty 
empty seq empty 
empty seq singleton 
singleton seq join 
concat definition proto seq evaluates flat spec spec proto sequence sorts seq const empty seq 
seq op singleton seq 
seq op concat seq seq 
seq constructors empty seq singleton seq concat construct seq axiom unit forall seq concat empty seq empty seq concat axiom associativity concat concat concat concat op empty seq 
seq 
boolean definition empty seq 
axiom empty seq empty true axiom empty seq singleton false axiom empty seq concat empty seq empty seq definition op nonempty seq 
seq 
boolean def nonempty seq empty seq op seq 
boolean definition axiom empty seq false axiom singleton seq axiom concat definition spec spec proto bag translate colimit diagram nodes bin op commutative proto seq arcs bin op 
commutative bin op 
proto seq 
seq binop 
concat diagram seq 
bag empty seq 
empty bag empty seq 
empty bag singleton seq 
singleton bag concat 
bag union spec proto set translate colimit diagram nodes bin op idempotent proto bag arcs bin op 
idempotent bin op 
proto bag 
bag binop 
bag union diagram bag 
set empty bag 
empty set singleton bag 
singleton set bag union 
union extend proto specs additional sorts operations get useful theories 
practice extensions proto seq yielding sequence theories useful different contexts 
note subsort definitions 
subsorts necessitated requirement operators total 
example ne seq short non empty sequences defined sequences restricted nonempty sequences 
selectors head tail introduced signature ne seq seq 
subsort construction 
comes injective coercion function relax 
takes subsort elements parent sort 
function introduced abbreviation relax nonempty seq 
coerces subsort ne seq parent sort seq 
note seq introduces destructors inverses constructors 
play key role divide andconquer style algorithms 
unit denotes empty product construction sort element hi 
spec seq import proto seq sort ne seq sort axiom ne seq seq nonempty seq 
op ne seq 
seq def relax nonempty seq 
op prepend seq 
seq op head ne seq 
op tail ne seq 
seq constructors empty seq prepend construct seq axiom prepend singleton concat op size seq 
nat definition size axiom size empty seq axiom size prepend size definition sort seq sort axiom seq seq empty seq 
op seq 
seq def relax empty seq 
op empty seq inv seq 
unit inversion constructor empty seq discriminator empty seq 
destructors empty seq inv axiom fa seq empty seq empty seq inv sort seq sort axiom seq seq singleton seq 
op singleton seq 
seq 
boolean def singleton seq size op seq 
seq def relax singleton seq 
op singleton seq inv seq 
inversion constructor singleton seq discriminator singleton seq 
destructors singleton seq inv axiom fa seq singleton seq singleton seq inv sort seq sort axiom seq seq nonsingleton seq 
op nonsingleton seq 
seq 
boolean def nonsingleton seq size op seq 
seq def relax nonsingleton seq 
op left split seq 
seq op right split seq 
seq inversion constructor concat discriminator nonsingleton seq 
destructors left split right split axiom fa seq concat left split right split spec spec bag import proto bag op size bag 
nat definition size axiom size empty bag axiom size singleton bag axiom size bag union size size definition op bag bag bag 
boolean def bag size size op singleton bag 
bag 
boolean def singleton bag size op nonsingleton bag 
bag 
boolean def nonsingleton bag size spec text gives refinement bags sequences described section 
note quotient sort definition 
sort bag seq defined sequences permutation relation 
purpose bag seq serve translation bag 
quotienting captures commutativity bags say sequences equal bags exactly permutations 
translate code equality bags translate permutation relation implementing sequences 
quotient sort construction comes surjective coercion function quotient takes elements equivalence class 
function introduced abbreviation quotient perm 
spec bag seq import seq op remove seq 
seq definition remove axiom empty seq 
remove axiom head 
remove tail axiom head 
remove prepend head remove tail definition op perm 
seq seq 
boolean definition perm 
axiom empty seq 
perm empty seq axiom perm 
head perm tail remove head definition sort bag seq sort axiom bag seq seq perm 
constructors bag empty bag singleton bag union construct bag seq op seq 
bag seq def quotient perm 
op bag empty bag seq def bag empty empty seq op bag empty 
bag seq 
boolean def bag empty empty seq op bag nonempty 
bag seq 
boolean def bag nonempty empty seq op bag singleton 
bag seq def bag singleton singleton seq op bag singleton 
bag seq 
boolean def bag singleton singleton seq op bag nonsingleton 

bag seq def bag nonsingleton nonsingleton seq op bag bag seq 
boolean def bag op bag union bag seq bag seq 
bag seq def bag union concat op bag size bag seq 
nat definition bag size axiom bag size size definition op bag bag seq bag seq 
boolean definition bag axiom bag gt bag size bag size definition spec refinement bag seq bag diagram morphism triv triv 
triv bag bag 
seq bag diagram bag nodes bag triv arcs triv 
bag 
diagram diagram bag seq nodes seq bag seq triv arcs triv 
bag seq 
triv 
seq 
seq 
bag seq import morphism diagram morphism bag bag 
bag seq bag 
bag seq empty bag 
bag empty empty bag 
bag empty nonempty 
bag nonempty singleton bag 
bag singleton singleton bag 
bag singleton nonsingleton bag 
bag nonsingleton 
bag bag union 
bag union bag 
bag size 
bag size specification sorting listed components structured specification problem sorting bag elements drawn linearly ordered set 
specification parameterized linear order 
triv linear order fflffl bag seq bag seq fflffl bag seq conv bag seq fflffl bag seq fflffl sort ing spec bag seq colimit diagram nodes triv bag seq arcs triv 
bag triv 
seq diagram spec bag seq conv import bag seq op seq bag seq 
bag definition seq bag axiom seq bag empty seq empty bag axiom seq bag singleton seq singleton bag axiom seq bag concat bag union seq bag seq bag definition spec spec bag seq colimit diagram nodes triv linear order bag seq conv arcs triv 
linear order triv 
bag seq conv diagram spec bag seq import bag seq op le bag bag 
boolean definition le axiom le empty bag empty bag true axiom le empty bag true axiom le singleton bag empty bag true axiom le singleton bag singleton bag le axiom le singleton bag bag union le singleton bag le singleton bag axiom le bag union le le definition op ordered 
seq 
boolean definition ordered 
axiom ordered empty seq true axiom ordered singleton true axiom ordered prepend le singleton seq bag axiom ordered concat ordered le seq bag seq bag ordered definition spec spec sorting import bag seq op sorted 
bag seq 
boolean def sorted ordered seq bag op sorting bag 
seq axiom sorted sorting spec 
