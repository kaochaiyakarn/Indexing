new approach subdivision simplification mark de berg dept computer science utrecht university box tb utrecht netherlands cs ruu nl marc van kreveld dept computer science utrecht university box tb utrecht netherlands marc cs ruu nl stefan schirra max planck institut fur informatik im stadtwald saarbrucken germany mpi sb mpg de line simplification problem old studied problem cartography 
algorithms compute simplification algorithms perform line simplification context geographical objects 
presents nearly quadratic time algorithm line simplification problem polygonal line set extra points real ffl compute simplification guarantees maximum error ffl ii extra points remain side simplified chain original chain iii simplified chain self intersections 
algorithm applied main subroutine subdivision simplification 
line simplification problem studied problem various disciplines including geographic information systems buttenfield douglas peucker hershberger snoeyink li mcmaster digital image analysis asano katoh hobby davis computational geometry chan chin eu toussaint guibas imai iri rourke 
input polygonal chain maximum allowed error ffl methods described obtain polygonal chain fewer vertices lies distance ffl original polygonal chain 
methods yield chains vertices vertices input chain methods yield chains points vertices 
source variation basic problem error measure 
known criteria parallel strip error criterion hausdorff distance fr echet distance areal displacement vector displacement 
research supported esprit basic research action project alcom ii algorithms complexity project dutch organization scientific research geometric error criteria geographic information systems criteria geographic knowledge perception mark 
motivation studying line simplification problems twofold 
firstly polygonal lines high level detail consume lot storage space 
situations high level detail unnecessary unwanted 
secondly objects described high level detail operations performed tend slow 
example problem severe animation 
motivation studying line simplification problem stems reducing storage space needed represent map geographic information system 
assume map modelled subdivision plane rectangular region thereof 
application main consideration reduction complexity subdivision 
processing time may little higher reason 
description size subdivision permanent cost geographic information system processing time spent applications 
maastricht canterbury maastricht canterbury netherlands belgium france england germany part map western europe inconsistent simplification subdivision 
important requirements subdivisions maps simple 
edges subdivision may intersect endpoints 
poses extra conditions line simplification method 
firstly polygonal chain reduced complexity output polygonal chain simple polygonal chain 
line simplification methods described don satisfy constraint chan chin douglas peucker eu toussaint hershberger snoeyink imai iri li rourke 
second condition need satisfied output chain intersect polygonal chain subdivision 
words simplification method respect fact polygonal chain simplified context 
usually context just chains subdivision 
map borders countries cities represented polygonal chains points simplification method respect points result simplified map cities close border lie wrong country 
maastricht moved netherlands belgium canterbury moved sea near top border netherlands germany coast lines intersect 
topological errors simplification lead inconsistencies geographic information systems 
show conditions enforced reformulating problem geometric setting 
quite different approach reported zhan mark done cognitive study conflict resolution due simplification 
accept simplification process may lead conflicts topological errors try patch problems 
avoid conflicts start geometric algorithms 
algorithms fairly easy implement give necessary pseudo code 
remainder organized follows 
section discusses approach subdivision simplification identifies main subtask new version line simplification 
section describes approach imai iri standard line simplification problem 
section adapt algorithm new version line simplification 
section summarizes subdivision simplification algorithm section gives number practical approaches improve speed output quality basic algorithm 
section 
subdivision simplification convex hull junctions enschede gronau subdivision junctions indicated 
subdivision models map 
subdivision geometric structure represents embedded planar graph 
adopt terminology standard computational geometry say subdivision consists vertices edges faces 
degree vertex number edges incident 
vertex degree leaf vertex degree interior vertex vertex degree junction 
see 
generally number leafs junctions small compared number interior vertices 
sequence vertices edges starting leaf junction interior vertices called polygonal chain simply chain 
convenience consider cycle interior vertices occur islands chain choose vertices junction 
start vertex chain 
set points model special positions inside regions map 
subdivision simplification performed follows 
keep positions leafs junctions fixed positions points replace chain start vertex new chain start vertex fewer interior vertices 
polygonal chain require simplification 
point chain distance prespecified error tolerance simplification 
simplification chain self intersections 

simplification may intersect chains subdivision 

point lies side take closer look requirement 
chain part subdivision generally separates faces subdivision 
faces may points simplified chain start vertex vertex separate faces subdivision faces slightly different shape 
fourth requirement states simplified chain subsets points faces 
chains face sides observation 
simplification leave points face subdivision 
requirement enforced extending known algorithm guarantees maximum error ffl 
requirements enforced way extend known algorithm 
intuitively simplified chain consists sequence edges bypass zero vertices input chain 
develop efficient tests determine edges simplified chain leave points wrong side 
ll see enforcing third requirement doesn add difficulty algorithm 
applying simplification algorithm chain subdivision temporarily add set points vertices chains subdivision 
show vertices chains side simplified chain won intersect chain subdivision 
apply similar idea avoid self intersections 
simplified chain points correct side self intersections doesn intersect chains subdivision consistent simplification 
disadvantage adding vertices point set quite large slow algorithm 
observations help reduce number points need added firstly take vertices chains bound faces separated chain simplifying 
secondly easy show points inside convex hull chain simplified possibly wrong side 
points vertices chains lie inside convex hull 
chain represents border netherlands germany shown convex hull dashed cities close border squares 
chains intersect convex hull cities enschede considered chain pseudo code idea follows 
remains solve new version line simplification problem 
extra points side original chain simplified chain 
problem develop efficient algorithm sections 
takes log time worst case polygonal chain vertices extra points 
lead theorem planar subdivision vertices extra points maximum allowed error ffl simplification satisfies requirements stated computed log time worst case 
close quadratic time behavior algorithm may inefficient subdivisions millions vertices 
expect quadratic time behavior worst case won show practice 
depend description sizes chains subdivision number extra points positions shapes chains 
implementation test runs required examine running time real data 
theoretically satisfactory compute efficiently minimum size simplification subdivision satisfies constraints 
size chain refers number edges length 
unfortunately difficult 
noted version subdivision simplification problem objective obtain minimum complexity simple subdivision np hard problem guibas 
guarantee minimum size simplification simplification polygonal line satisfies condition weaker monotonicity 
preliminaries line simplification describe line simplification algorithm imai iri method 
input polygonal chain line segment shortcut subchain error shortcut maximum distance point shortcut allowed error induces prespecified positive real value ffl 
wish replace chain consisting allowed shortcuts 
chain shortcuts possible 
don consider simplifications vertices input chain 
directed acyclic graph node set fv arc set contains shortcut allowed 
error arc defined error shortcut error ffl graph constructed trivial algorithm time size 
shortest path corresponds minimum size simplification polygonal chain 
topological sorting shortest path computed time linear number nodes arcs cormen 
construction problem solved time 
approach terminate valid output original polygonal line valid output hardly simplification 
bottleneck efficiency construction graph rourke shown computed log time reducing time bound log time 
chan chin algorithm construct time 
optimal worst case theta arcs 
explain algorithm briefly 
simple useful observation error shortcut maximum errors half line starting containing half line starting containing denote half lines ij ji respectively 
construct graph contains arc error ij ffl graph contains arc error ji ffl 
obtain graph arc arc problem remains construction boils determining errors half lines ffl 
describe case half lines ij case completely analogous 
algorithm starts letting vertices turn errors half lines ij determined order follows 
associate closed disk centered radius ffl error ij ffl ij intersects disks half line rooted algorithm compute allowed shortcuts ffl input polygonal chain vertices real ffl 
output set allowed shortcuts 
half line ij disk defined 

gamma 
gamma 


angle ij 
accept shortcut 

angles half lines intersect 
accepted wedge shown grey 
vertex doesn lie wedge accepted 
reduced wedge shown grey 
vertex lies wedge accepted 
wedge need reduced 
vertex lies outside wedge accepted 
wedge empty arc accepted 
ii iii iv deciding arcs accepted accepted 
extending positive direction 
algorithm maintains set angles half lines starting intersect disks incrementally 
initially set contains angles gamma 
set angles interval set half lines error ffl vertex form wedge apex 
updating wedge takes constant time take algorithm may inner iteration wedge empty 
pseudo code algorithm shortcuts algorithm illustrated 
approach graph construction requires time worst case chan chin 
consistent simplification chain section generalize line simplification algorithm just described respect extra points 
consider issue computing simplification 
polygonal chain polygon self intersections called simple 
chains consistent respect points shown disks respect point shown cross 
simple polygonal chains set points 
part boundary face subdivision requirement subset points lie face boundary subset points face replaced define polygonal chains oriented consistent respect exists simple chain oriented closes simple polygons subset points interior 
simple polygons edges oriented clockwise counterclockwise 
gives example chains closed simple polygons clockwise orientation 
show chain completes simple polygons orientation give result consistency general approach take compute graph vertices chain node set arc nodes shortcut corresponding vertices consistent 
don consider error shortcuts recall algorithm previous section graphs intersections arc sets represented shortcuts sufficiently small error 
intersect arc set additional property resulting arcs consistent 
remainder section concentrate computing consistent shortcuts polygonal chain monotone vertical line intersects point 
words monotone polygonal chain piecewise linear function defined interval 
easy see simplification monotone polygonal chain monotone polygonal chain 
subsection discuss simplification monotone chains 
show compute consistent shortcuts vertex applying algorithm vertices chain get consistent shortcuts 
subsection possible extensions arbitrary chains considered 
arbitrary chains property simplification simple doesn hold 
extra measures taken avoid self intersections 
monotone chains monotone polygonal chain vertices denote subchain vertices ij set points lemma consistent simplification respect point lies bounded face formed proof point count number intersections half line extending vertically downward chains monotone counts zero 
suppose consistent simplification exists chain completes simple polygons denoted bc bc bc bc point polygon criterion point lies polygon vertically downward half line point intersects boundary polygon odd number times follows counts mentioned point lies bounded face formed hand assume point lies bounded face formed monotone chains easy see chain exists completes simple polygons clockwise orientations 
denote polygons bc bc point polygon test bc bc point lies vice versa 
consistent simplification ij necessarily simple polygon bounded ij edge ij contains gamma edges edge edge may intersect edges ij algorithm decide efficiently vertices polygon ij contains points bounded faces 
minimal maximal part chain tangent splitters 
step algorithm locate tangent segments define shortcut tangent gamma lie closed half plane bounded line shortcut considered tangent 
tangent shortcuts tangent shortcut minimal slope gamma lies line gamma lies line maximal slope gamma lies line degenerate 
tangent splitter line segment defined maximal closed subsegment intersect point interior point intersection point chain shortcut closest see 
gamma lies shortcut degenerates point tangent splitter minimal maximal degenerate tangent shortcut fl fl nondegenerate tangents 
corresponding set tangent splitters define subdivision plane linear size see 
subdivision bounded faces bounded pieces minimal maximal tangent splitters 
face consider vertex highest index bounding face 
vertex define tangent splitter fl fl assume fl associate face number subdivision numbering useful properties 
lemma bounded face subdivision monotone respect half line rooted intersects bounded face zero connected component 
corresponding subdivision faces fl fl fl fl 
proof assume face monotone 
vertex boundary face half line rooted intersects interior left right tangent tangent splitter edge subdivision contradicts statement half line rooted intersects interior left right lemma bounded face subdivision connected subchain half lines rooted leave face 
proof subdivision consists parts tangent splitters extend vertex face part boundary half lines rooted leave consists subchain vertex tangent 
tangent splitter chosen extending supposed face contradiction 
lemma directed half line intersects faces order increasing number 
proof previous lemma connected subchain directed half lines leave face 
tangent splitter gives number face vertex highest index chain endpoint 
suppose exists directed half line intersects face intersects consider unique points half line leaves respectively 
consider faces referred previous paragraph 
connected disjoint follows lies left assumption follows monotone contradiction 
tangent splitters linear time follows 
traverse vertex tangent non degenerate walk back reach find intersection case fact monotone guarantees point rightmost intersection continue traversal forward approach take quadratic time idea bring linear 
time walk back compute tangent splitter previous tangent splitters walk back quickly 
new maximal tangent splitter previously maximal algorithm compute tangent splitters input chain vertices integer output tangent splitters respect 

maximal tangent 
gamma 
ij gamma 
gamma 
maximal tangent 
gamma contains maximal tangent splitter 
gamma 
ij gamma 
store pointer gamma 
minimal tangent 
take analogous steps 
tangent splitters new minimal tangent splitter minimal ones 
show skipped part contains endpoint tangent splitter looking 
algorithm compute tangent splitters contains pseudo code 
total number steps backward walks seen follows 
walks back visit vertex incident splitter twice locating maximal tangent splitter minimal tangent splitter 
backward walks bypass vertices visited 
similarly tangent splitter quick walk backwards time bypassed tangent splitter 
charge cost backwards walks vertices tangent splitters 
face point indicated square maintained 
second step algorithm distribute points faces subdivision plane sweep algorithm line rotates preprocessing point location step requires log time preparata shamos 
points don lie bounded face discarded bounded face polygon ij shortcut discard points 
face consider tangent splitter vertex highest index 
tangent splitter minimal discard points point maximizes slope directed segment see 
similarly tangent splitter highest index maximal discard points face point minimizes slope directed segment face contains point algorithm distribute points gives pseudo code 
lemma shortcut consistent subchain ij respect consistent respect remaining subset points algorithm distribute points input subdivision topological network structure integer set points 
output assignment points faces 
plane sweep method 

subset points larger coordinate 
sort points fv ng angle put priority queue 
initialize empty binary search tree 
half line rooted sweep vertically upward clockwise vertically downward 

store edges intersecting sweep line order intersection 

empty 
extract max 
vertex 
update edges incident 
search find leftmost edge right sweep line 
edge exists store 
traverse vn gamma vn collect points stored edges store clockwise minimal maximal appropriate face 
proof definition consistent point contained closed faces polygon ij face monotone follows shortcut inconsistent respect point inconsistent respect retained point face 
conversely shortcut consistent respect retained point face shortcut consistent respect points face faces monotone 
statements hold faces subdivision lemma follows 
shortcuts accepted 
third step algorithm decide shortcuts consistent graph form arc 
third step efficient start sorting shortcuts slope 
consider shortcuts directed away monotone shortcuts directed right 
shortcuts stored deque double ended queue 
treat faces order increasing associated number 
treating face discard shortcut accepted inconsistent respect remaining point face 
accept shortcut boundary face discarded 
discarding shortcuts order shortcuts slope stored deque accepting shortcuts order chain shortcuts subsequently discarded face treated shortcuts accepted face treated discarded 
algorithm discard accept input subdivision topological network structure integer face possibly point output shortcuts starting consistent 

sort shortcuts slope store deque maintain cross pointer deque element vertex 
current position accepting 
assign numbering faces 

point stored 
bounded maximal tangent splitter 
discard shortcuts front deque long slopes shortcuts greater slope 
discard shortcuts back deque long slopes shortcuts smaller slope 
tangent splitter vertex 
discarded 
accept remove 
pseudo code algorithm discard accept 
lemma discarded shortcut inconsistent subchain ij respect points proof construction 
lemma accepted shortcut consistent subchain ij respect points proof shortcut accepted faces intersects treated lemma faces treated order increasing number 
shortcut discarded treating intersected faces shortcut doesn contain point bounded face 
consistent ij third step requires time seen follows 
face spend time discarding segments discarded 
obvious discarding simply removing deque accept efficiently maintain cross pointers deque chain shortcuts accepted removed constant time 
spend time shortcuts accepted 
shortcut discarded accepted linear number faces follows third step takes linear time 
completed description steps lead computation consistent shortcuts starting vertex chain 
result obtained lemma monotone polygonal chain vertices set points possible compute consistent shortcuts vertex log time 
apply lemma vertices construct graph representing consistent shortcuts combine obtained graph graphs defined previous section create graph conclude result 
theorem monotone polygonal chain vertices set points error tolerance ffl possible compute minimum size simplification consistent respect approximates error tolerance ffl log time 
simplification simple automatic simplification monotone chain monotone chain monotone polygonal chain simple 
arbitrary chains algorithm obtained simplification monotone chains generalized arbitrary chains different ways 
ll describe fairly simple way extend algorithm described give data reduction 
theoretical side guarantee simplification minimum link simplification monotone case 
main idea 
deciding vertex shortcuts starting consistent look shortcuts certain vertex vertex chosen run algorithm described previously subchain hardly changes 
idea may resulting subchain longest monotone chain gives poor performance chain extends left 
clearly change coordinate system get long subchain algorithm applied 
second problem face difficult guarantee simplicity output chain 
vertices shown chain 
consider determine longest subchain vertex algorithm applied 
observe algorithm previous section works general chains monotone chains 
features need correctness monotonicity faces subdivision lemma intersection order faces half lines lemma 
features polygonal chain doesn cycle doesn backward tangents 
intuitively backward tangents means shouldn edge closer preceding edge gamma formally segment backward tangent angles gamma measured counterclockwise gamma gamma segment backward tangent easily determined constant time 
second condition polygonal chain doesn cycle give problems second step algorithm half line rotating distribute points subchain run algorithm previous section vertex backward tangent algorithm determine subchain input simple polygonal chain vertices integer output vertex gamma doesn backward tangents doesn cycle 


gamma gamma angle 
interval represents angles half line starting doesn intersect subchain 

gamma gamma 

gamma angles half lines intersect gamma 

return gamma 
return doesn cycle chosen angle condition chosen cycling condition 
running algorithm determine subchain coordinate system chosen negative axis half line angle rotating half line second step full rotation starting negative axis making half turn positive negative axis algorithm distribute points 
second problem take care parts chain intersect shortcuts cause simplification prevent shortcuts consistent intersect edge simple remedy add vertices gamma extra points set show shortcut consistent ij respect extra points destroy condition output chain simple 
conclude theorem simple polygonal line vertices set points maximum allowed error ffl simplification lies distance ffl consistent respect points simple computed log time 
subdivision simplification summary ingredients subdivision simplification 
combine summary general subdivision simplification algorithm 
algorithm calls previously algorithms 
assumed monotone chains generalized method arbitrary chains 
algorithms subsection changed slightly 
need extra parameter specify vertex computing consistent shortcuts restrict values 
trivial adapt algorithms way 
furthermore algorithm distribute points changed full sweep half line explained subsection 
computing consistent allowed shortcuts construct graph arcs represent consistent allowed shortcuts 
graph minimum link path computed 
path usually called shortest path algorithm simplify subdivision ffl input simple polygonal subdivision positive real ffl set points 
output simplified simple polygonal subdivision consistent respect error ffl 

determine vertices degree endpoints collection polygonal chains 

polygonal chain 
vertices order 
graph nodes 
gamma 
determine subchain 
change coordinate systems appropriately 

vertices 
calls algorithms extra parameter replace algorithms monotone case 

compute tangent splitters 
distribute points 
discard accept add accepted edges arcs 
compute graphs algorithm compute allowed shortcuts ffl 

compute graph intersecting arc sets 

determine minimum link path vn simplification graph literature computation standard cormen 
path represents simplification chain 
practical considerations section discuss ideas lead efficient implementations efficient variants subdivision simplification 
consider extra conditions may want enforce included algorithm 
important speed achieved reducing size set algorithm simplify subdivision 
union extra points vertices subdivision part chain simplified 
section noted need take entire set 
points lie far away influence choices simplification anyway 
observation simplification chain stays convex hull chain 
points inside convex hull relevant 
chain ll compute convex hull determine subset pc points vertices chains lie inside convex hull far fewer points pc inside inner loop set pc add vertices gamma compute convex hull simple polygonal chain simple algorithm uses deque execution 
convex hull computed test point lies inside convex hull 
test done binary search point 
algorithm reduce extra points gives pseudo code 
called appropriate parameters just inner loop algorithm simplify subdivision 
second idea speed simplification algorithm 
algorithm reduce extra points input simple polygonal chain vertices set points includes vertices chains output set points lie inside convex hull 
algorithm maintains convex hull incrementally 

initialize deque vertices 
stores vertices convex hull cyclic order starting vertex 



reflex turn points 
remove vertex 
point removed add ends 
store contents convex hull array allow binary search 

point 
lies convex hull add set suppose simplifying chain computing shortcuts allowed distance ffl consistent respect extra points 
suppose know vertex distant vertex allowed shortcut exists 
computation consistent shortcuts need go distant vertex 
argue perspective know shortcut distant vertex shortcuts consistent computation allowed shortcuts need go vertex 
version efficient difficult predict 
depends condition restrictive seemingly restrictive condition computed 
guess allowed restrictive consistent ffl large extra points 
idea sketched easily incorporated algorithms omit details 
discuss issues extension algorithm account extra condition may required practice 
condition guaranteeing points get close simplified chain 
presently algorithm keeps points correct side points considered infinitesimally small polygonal lines infinitesimally narrow 
drawing subdivision points output device assumption longer valid 
may want specify minimum clearance points polygonal chains subdivision 
clearance guaranteed holds subdivision 
idea handle situation 
replace point small number points small circle 
put points set running algorithm 
new points respected algorithm original points minimum distance simplified subdivision assuming minimum clearance initial situation 
second condition may required output subdivision doesn contain small angles consecutive line segments 
condition enforced practice 
method help avoid small angles 
algorithm described run point minimum link path graph computed 
transform graph graph gl called line graph transformation done follows 
arc algorithm ffl input simple polygonal chain vertices indices real ffl set points 
output true simplified false case index farthest vertex 
determine farthest vertex segment 
dist ffl 
return false 
determine polygons gamma 
point 
lies polygon 
return false 
return true algorithm douglas peucker extra ffl input simple polygonal chain vertices indices set points 
initial call output simplification similar douglas peucker algorithm respects extra points 
ffl 
return 
returned farthest vertex 
douglas peucker extra ffl 
douglas peucker extra ffl node gl nodes gl corresponding arcs connect gl arc angle line segments sufficiently large 
minimum link path gl corresponds simplification angles consecutive shortcuts sufficiently large 
unfortunately number drawbacks approach 
firstly simplification sufficiently large angles may exist case algorithm fails find simplification 
secondly running time space requirements algorithm go size gl larger worst case algorithm needs cubic time space 
thirdly small angles may show consecutive chains simplified separately 
fourthly simplified chain may appear small angles short line segments connecting line segments small angle 
satisfactory solution avoiding small angles remains 
issue section consider adaptation line simplification algorithm douglas peucker respect extra points 
considered adaptation line simplification algorithm yielded better data reduction 
hand douglas peucker algorithm simple running time better practice 
depends application algorithms preferable 
roughly douglas peucker simplification algorithm chain vertices initially chooses simplified chain 
current simplification satisfies ffl condition done 
furthest point current simplification chosen added simplification 
gives recursively defined subproblems 
douglas peucker 
adapt algorithm need reimplement test current simplification 
depend ffl condition extra points algorithms douglas peucker extra subroutine gives pseudo code adaptation 
wish guarantee simplified chain self intersections may arise douglas peucker algorithm adaptations necessary 
test running algorithm simplification 
intersecting segments handled continuing recursion 
algorithm efficient practice reducing size set recursive calls 
convex hull computed points lie convex hull selected recursive call 
similar computation second recursive call 
shown possible perform line simplification way topological relations maintained 
points lie original chain lie simplified chain points lie remain 
furthermore line simplification algorithm guarantee user specified upper bound error output chain self intersections 
line simplification method leads efficient algorithm subdivision simplification creating false intersections 
obtain results relied techniques computational geometry 
ideas similar line simplification methods adapted consistent respect set extra points 
particular showed algorithm douglas peucker extended 
algorithm takes log time perform simplification chain vertices extra points 
leads log time worst case algorithm simplifying subdivision vertices extra points 
ideas speed algorithm practice 
expect algorithm performs better practical situations worst case analysis suggests 
implementation required discover practical behavior algorithms 
algorithms fairly straightforward implement 
plan implement algorithm run real world data 
way find situations efficiency method satisfactory 
asano katoh asano katoh number theory helps line detection digital images extended 
proc 
th isaac lect 
notes comp 
science pp 

buttenfield buttenfield treatment cartographic line 
pp 

chan chin chan chin approximation polygonal curves minimum number line segments 
proc 
rd isaac lect 
notes comp 
science pp 

cormen cormen leiserson rivest algorithms mit press cambridge 
vertex substitution approach numerical line simplification 
proc 
rd symp 
spatial data handling pp 

douglas peucker douglas peucker algorithms reduction number points required represent digitized line caricature 
canadian pp 

edelsbrunner edelsbrunner guibas stolfi optimal point location monotone subdivision siam comput 
pp 

eu toussaint eu toussaint approximating polygonal curves dimensions 
graphical models image processing pp 

guibas guibas hershberger mitchell snoeyink approximating polygons subdivisions minimum link paths 
int 
computational geometry applications pp 

hershberger snoeyink hershberger snoeyink speeding line simplification algorithm 
proc 
th symp 
spatial data handling pp 

hershberger snoeyink hershberger snoeyink computing minimum length paths homotopy class 
computational geometry theory applications pp 

hobby hobby polygonal approximations minimize number inflections 
proc 
th acm siam symp 
discrete algorithms pp 

imai iri imai iri polygonal approximations curve formulations algorithms 
toussaint ed computational morphology elsevier science publishers pp 

davis davis polygonal approximation minimax method 
computer graphics image processing pp 

li li algorithms automated line generalization natural principle objective generalization 
int 
geographical information systems pp 

mark mark conceptual basis geographic line generalization 
proc 
auto pp 

mcmaster mcmaster automated line generalization 
pp 

line construction convex hull simple polyline 
inform 
process 
lett 
pp 

rourke rourke polygonal chain approximation 
toussaint ed computational morphology elsevier science publishers pp 

preparata shamos preparata shamos computational geometry 
springer verlag new york 
tarjan tarjan planar point location persistent search trees comm 
acm pp 

zhan mark zhan mark conflict resolution map generalization cognitive study 
proc 
auto pp 


