guaranteed optimization proving nullspace properties compilers todd veldhuizen andrew lumsdaine indiana university bloomington usa acm org osl iu edu 
writing performance critical programs frustrating optimizing compilers imperative languages tend unpredictable 
subset optimizations simplify reorder code useful prove compiler reliably performs optimizations 
show adopting approach optimization enables proof 
analogy linear algebra define nullspace optimizer programs reduces empty program 
span nullspace define rewrite rules de optimize programs introducing abstraction 
model compiler prove sequence de optimizing rewrite rule applications undone optimizer 
able give programmers clear mental model simplifications compiler guaranteed perform progress problem abstraction penalty imperative languages 
experience developing high performance numerical libraries objectoriented languages industrial compilers fail eliminate abstraction reliably 
fact best optimizing compilers achieving remarkably performance achieving performance unpredictable phrasing program 
reports progress devising compiler structure achieves guaranteed optimization imperative languages 
optimizing compilers map programs programs 
interesting ask linear algebra nullspace kernel mapping 
clearly optimizing compilers linear transforms analogy useful 
nullspace linear transform set vectors transformed zero vector null fx ax 
compilers sensible choice nullspace set programs reduced optimizer empty program 
mean syntactically minimal program generating value program int main return notation delta program program optimizer define nullspace null fp program program code may loosely divided useful code implements desired semantics program abstraction code change observable properties introduced software engineering goals encapsulation modularity 
example want program compute software engineering reasons write new integer new integer plus resulting performance hit called abstraction penalty pressing concern attempting software engineering practice high performance 
ideally optimizing compilers eliminate abstraction preserving semantics 
words nullspace compilers encompass typical patterns software engineering abstraction 
carrying analogy linear algebra property linear transform null implies ax adding nullspace effect 
account adding abstraction program 
analogy linear algebra weak turn rewrite systems 
term rewriting systems long history program optimization :10.1.1.15.3043
consider application opposite usual rules de optimize program introducing abstraction optimizing 
rules stated informally 
replace expression fresh variable insert immediately 
select subset local variables allocate record sufficient size appropriate program point replace variable definitions writes variable uses reads appropriate slots record 
rules span rudimentary oop style encapsulation applying produce code resembling new integer new integer 
regard de optimizing rules basis desired nullspace program delta optimizer fg de optimizing rules want gamma delta delta delta sequence rule applications gamma delta delta delta analogy additivity linear algebra 
build optimizer capable undoing application rules necessary avoid phase ordering problems problems arise optimizers constructed discrete optimizing passes 
adopting exact program point dominates definitions uses variables 
approach analyses performed simultaneously followed single transformation step 
approach known powerful applying individual optimizations sequence iteratively optimizations synergistic 
enables proof nullspace property sequence rule applications undone single application optimizer 
nullspace proof induction rule applications rule consider changes analysis equations show resulting system equations consistent solution transformation step erases code added rule 
demonstrate proof technique proving nullspace property small arithmetic language 
accompanying technical report prove nullspace property model optimizer imperative language summarize results 
proof proof sake 
proof guides design optimizer 
enable nullspace proof obliged changes structure optimizer proof complete optimizer design desired property 
related contributions notion guaranteed optimization known functional world 
compilers functional languages guarantee tail call optimization staged languages metaml guarantee expressions annotated static evaluated fully compile time deforestation reliably eliminate intermediate representations certain expressions :10.1.1.30.9032
sands improvement theory shows certain optimization algorithms offer strong guarantees 
rewrite rules optimization guarantee restricted cases existence normal forms 
imperative world vagaries effects control flow absence algebraic properties pure functional languages guaranteed optimization difficult 
contribution propose idea nullspace guiding principle guaranteed optimization imperative languages introduce proof technique proving nullspace properties compilers 
believe step practical theory minimal normal forms imperative programs 
definitions adopt interpretation style lattices associated absent conflicting information 
opposite convention data flow analysis 
partial order relation lattice join theta lattice direct product 
tuple lattices dn understood lattice theta theta dn reserve mean logical conjunction 
program analyses special purpose solvers simultaneously build solve lattice equations 
reason analyses take view program analysis builds system equations xn xn 
xn xn analysis variables monotone functions 
write system xn 
notation lfp mean fixpoint function definition 
system lattice equations pair dn tuple complete lattices tuple monotone functions theta theta dn variables xn define lfp solution fixpoint system equations 
write mean similarly parameters apparent context 
definition 
optimizer pair analysis program producing system lattice equations mapping program points elements transformation solution program mapping producing new program write informally state main theorem establish goal proper version stated proved section 
forward de optimizing rules analysis transform model compiler defined sections 
informal statement theorem 
fg set rewrite rules section analysis section transformation section 
program program derived finite number applications rules 
structure remainder devoted proving theorem organized follows 
give simple example optimizing arithmetic expressions section serves introduce proof technique 
introduce intermediate representation suitable imperative languages section sketch sample set de optimizing rules section 
model optimizer consisting simultaneous analyses congruence reachability backward escape analysis transform analysis section 
analysis equations solved single transformation step produces optimized program section 
section introduce proof technique apply prove theorem model compiler sample de optimizing rules 
example optimization arithmetic expressions introduce proof technique consider optimizing arithmetic expressions comprised integers variables addition study de optimizing rewrite rules 

example 

gamma 
gamma 
define optimizer prove undoes sequence applications single step 
impressive result serves introduce proof technique 
simple example single analysis suffices constant propagation 
lattice delta delta delta delta delta delta analysis takes expression constructs system analysis equations mapping analysis variables program points 
represent mapping annotating expression analysis variables 
analysis rules expression equation version key requirement proof technique analysis compositional system analysis equations expression obtained composing analyses subexpressions 
implies rewrite expression induces rewrite analysis equations straightforward way 
consider single rewrite 
gamma convenient think rewrite terms context redex example context redex denotes hole 
analysis expressions mapping gamma equations gamma table see term rewrite induces rewrite analysis equations equations associated context unchanged equation redex altered new equations added subexpression gamma 
rewrite rule proof technique parts showing rewrite induced analysis equation effect solution analysis variables associated context showing transformation step eliminates code added term rewrite 
arithmetic example transformation step delta rules rule eqn 
says addition expression constant value replace constant arguments zero replace addition argument 
prove optimizer undoes sequence rewrites single step induction number rewrites 
proof define terms 
consistency equations define notion consistency systems analysis equations 
intuitively system consistent system extra variables compared variables common map program points lfp solution 
definition 
systems dn 
say consistent write permutation applied elements dn dn dm components map program points 
consistency relation transitive reflexive 
guarantee lfp common variables need reason fixpoint construction kleene sequence lfp define ascending solution chains generalize kleene sequence arbitrary subterms system 
definition 
system 
ascending solution chain set fx 
solution lfp greatest element ascending solution chain 
function complete lattice define asc ff techniques useful proving consistency 
results show certain transformations systems equations preserve fixpoint transformations studied systematically 
state useful results lemma 
system equations 
rewrites result system satisfying 
adding equation new variable monotone function 
equation xn choosing subterm adding equation replacing occurrence new variable 
equation xn replacing subterm identity lattice ascending solution chain brevity say identity mean sense conditions case lemma 
second technique proving consistency reason directly fixpoint doing chaotic iteration principle fixpoints constructed updating variables order convergence useful 
proof arithmetic example nullspace proof structured follows lemma rewrite rule theorem number rewrites undone single step optimizer 
proof structure highly modular add rewrite rules adding new lemma rest proof unaffected 
arithmetic example consider rule 
write delta imply lfp solution analysis equations 
lemma 
expression 

proof 
consider rewrites induced analysis equations application 
rewrite applied subexpression inside larger context write unknown analysis equations associated rewrite context 
systems consistency 
system equation clearly system transformation 
show consider context redex rewrite separately 
analysis variables guiding transformation rewrite context solution rewrite context 
consider redex 
original expression eqn 

rewritten expression eqn 


ut lemma 
expression 

proof 
consider rewrites induced analysis equations application ca 
ca equations original system refer refer rewriting 
notation indicate substitution consistency 
equation 

definition eqn 
chaotic iteration fixpoint constructed evaluating subsequent iterations follow evaluation evaluation maintain invariant transformation 
rewrite context 
redex consider cases case eqn 
eqn 

case eqn 

show cases ffl case ca eqn 

ffl case ca contradicts assumption case apply ffl case ca eqn 

rewrite context transformed identically 
ut prove sequence rewrites undone single step optimizer 
theorem 
expression fg rewrite rules analysis transformation 
analysis system delta delta delta sequence rewrites sn analysis system produced delta delta delta 
sn delta delta delta 
proof 
induction number rule applications 
base case zero rule applications trivial reflexive 
induction step expression analysis system assume 
consider applying single rewrite analysis system ge lemma ge 
ut corollary 
sequence rewrites delta delta delta program delta delta delta 
nullspace proofs imperative languages intermediate language turn substantial example proving nullspace properties imperative language exceptions loops 
top level definitions function vn function definition block delta delta delta statement variable definition final statement return function return break break loop throw raise exception expression trivial primitive function call expression try catch exception handling loop loops trivial expression integer literal variable fig 
grammar intermediate language 
optimizing compilers typically lower source form highly constrained intermediate language il optimizations performed 
shows intermediate language consider 
il retains high level control structures simplify analyses proof 
expressions syntactically constrained quadruple normal form disallows nested expressions favour 
control structures typical structured imperative languages loops exceptions expressions 
distinguish notions dominance 
static dominance mean dominance relation apparent pre analysis control flow graph 
analysis dominance mean online dominance relation determined reachability analysis dead edges considered removed control flow graph 
notes il variables may defined statically scope variable extends analysis dominance region definition 
assume variables renamed global ff conversion pass ensure uniqueness 
avoid dealing assignments necessity real optimizer scope assume handled boxing 
primitive operations generate exceptions 
expressions branch zero tests 
blocks try catch may generate values 
block produces value de optimizing rules consider set simple de optimizing rules 
rules somewhat weak deliberately proof reasonable size 
rule applies resulting program pass syntactic semantic checks say block shorthand syntactically valid block containing variables unbound context placed 
define subblock block non empty sequence write 
indicate single rewrite 
indicate sequence rewrites 
rule 
subblock new block free 
rule 
statement decomposed context subexpression subexpression trivial expression new globally unique identifier 
rule insert statement position ref new globally unique identifier trivial expression insert statement positions static dominance region definition setref trivial expressions primitive ref allocates box heap stores value expression deref dereferences box setref overwrites value box 
assumption necessary proof manageable 
trivial expression variable literal 
weak form box variable rule weakened avoid dealing propagation boxes 
propagation boxes complex analysis rule 
try catch subblock free function calls throw statements new globally unique identifier new block free 
applying rules program computes obtain elaborate version debugging mode boxes integers handles exceptions function main return 
function main ref ref print print try return catch err deref deref print print exit optimizer guaranteed undo rule applications effectively reversing direction arrow 
obvious question pose rewrites de optimizing rules 
reverse direction rewrites apply inverse rules directly programs 
problem deciding inverse rules apply requires supporting analysis 
example deciding rule gamma applies box requires knowing reads box unreachable box escape 
doing analyses rewriting step scope 
allow value escape box guarantee box read boxing undone transformation step optimizations performed value escape 
omit statement separator apparent indentation 
avoid propagation boxes manually applied optimization replacing uses respectively 
example assume print exit primitives 
inefficient devising rewriting strategy allow convergence proof general compiler interprocedural analysis heap analysis appears difficult 
prove optimizer effectively subsumes rewrite system implementing inverse rules 
optimizer runs jpj log jpj time rewrites undone jpj log jpj time 
analysis equations limit attention simplifying optimizations reduce eliminate code 
optimizations reorder code example loop nest optimizations interesting regard orthogonal issue 
formulate analyses optimistic 
optimistic analysis starts optimistic assumption iterates fixpoint 
optimistic analysis intermediate results fixpoint iteration conservative may transformation 
adopt terminology calling simultaneous interacting analyses 
consider simultaneous analyses reachability decides expressions may reached execution 
unreachable expressions dead code may eliminated 
congruence partitions program points equivalence classes values reaching 
escape backward analysis determines value produced program point may 
transform simple analysis deciding subexpressions processed value effect transformation step 
analyses part conventional understood analyses drawn literature adjustments enable proof 
purposes regard soundness stated analyses important tangential issue 
analogy logical implication adopt notation usual way ae false true predicate analysis variable monotone lattice true false encode interactions analyses 
identify analysis variables corresponding program points superscripts notation asserts congruence analysis variable corresponding subexpression similarly reachability analysis associate program point reachability flow analysis variable value element lattice live dead define predicate live live reachability equations built control flow graphs constructed function program 
vertex flow graph represents basic block sequence statements control guaranteed flow sequentially top bottom 
edges represent control flow branches return statements exception throws loops try catch 
function pads vertices containing code serve collect return throw edges 
block reachable incoming edges live resolve control flow expressions results congruence analysis defined manner conditional propagation 
consider expression congruence analysis variable test 
control flow subgraph fflffl resolve control flow writing equations nonzero zero zero nonzero ae true gamma false predicates zero nonzero determine arguments zero nonzero respectively branch determined way predicates true 
straight line code split multiple blocks function calls 
consider code gamma fibonacci gamma fibonacci return prior analysis know fibonacci throw exception split sequence blocks add edges account possible exception throws fibonacci fibonacci return returns throws limit intra procedural analysis interprocedural analysis assume reachable function call may complete normally throw exception 
code generate equations assume function may called function body initial edge add equation live 
congruence analysis congruence analysis partitions program points equivalence classes values reaching 
simplicity constant copy propagation component congruence analysis omit value numbering techniques finding congruences 
efficient way analysis partitioning facilitate proof propagate equivalence class representatives 
congruence lattice domain vars set integers vars set program variables 
associate value producing program point analysis variable inference asserts program point integer value inference vars asserts program point value equal value variable inference valid analysis dominance region definition analysis ensures inferences escape respective dominance regions 
partial order reflexive transitive closure vars vars definition statically dominates definition program points satisfy congruence equivalence class 
initially variables assumed program points equivalence class analysis progresses equivalence classes effectively split fixpoint reached 
table summarizes analysis equations straight line code 
write reachability analysis variable enclosing basic block expression analysis variables equation function defn function ck integer literal fa live variable definition fa cx live fa live ref fa ref live read primitive fa ck live function call fa ck live return fa return live throw fa throw live break fa break live loop fa loop live function lattice approximation primitive operation function introduces name equivalence class representative ae 
predicate read delta tests value box read program point described section 
support compile time garbage collection analysis discovers box created ref read ref propagates 
control flow joins due return throw try catch incoming values combined merge function distinguished lattice operator merge expression equation merge reachability analysis variables control flow edges branches 
similarly expression try catch cx congruence equations merge equation combine congruence variables throw points merge function 
escape analysis escape analysis decides value may program points 
support simple transformations eliminating dead variables rudimentary compile time garbage collection 
support transforms need know value read box written box 
associate value producing program point analysis variable lattice theta read theta written theta denotes lattice direct product 
shorthand write mean similarly read written 
write read written 
define predicates read read written written table summarizes analysis equations straight line code expression analysis variables equation function function block ua 
uk gamma gamma uk 
gamma variable definition ua uses 
uk ref fa ua ref live read deref fa ua deref live read setref fa ua setref live written live primitives fa ua uk 
function call fa ua uk live live 
live fa ua live loop fa ua loop control flow join add equations 
fflffl delta delta delta un vv fn live live 
un live return throw pad function add equations live reachability return escape pad 
transform analysis helper analysis transformation step simpler decides expression process value effect 
associates program points analysis variable uses simple lattice value effect transform analysis details table summarizes analysis equations expression analysis variables equation function function effect block 
gamma gamma effect 
gamma effect var def value return return value throw throw value try catch try catch loop loop effect solution step analysis equations built solved constructing fixpoint solution 
implementation usual way constructing dependence graph analysis variable vertex edge appears equation building acyclic condensation graph doing fixpoint iteration sets mutually dependent analysis variables worklist algorithm 
yields solution system 
transformation step minimal transformations allow proof reasonable optimizer 
represent empty expression 
transformation step implicitly takes parameter solution analysis equations omit reduce syntactic noise 
ae value ae value ae value ae live live try catch ae live try catch ref ae ref setref ae setref expressions covered cases constructed applying delta subexpressions reconstructing natural way example loop loop 
transforms require explanation value trivial expression needed eqns 

possible congruence analysis variables reachable trivial expressions integer value variable name lemma 
compile time garbage collection box creation point ref propagate escape analysis determines box may read 
box read ref expression setref box dead code eliminated eqn 
eqn 

proof main theorem proofs lemmas main text appendix 
structure proof prove theorem consider rule turn 
analysis equations 
study rewrites induced show gfp solution equal shared variables 
consider transformation prove sufficient bounds analysis variables show 
prove lemma rule section proofs remaining rules appendix 
lemma 
rule program 

lemma required proof rule lemma 
trivial subexpression asc lemma 
rule program 

proof 
consider changes induced analysis equations fa ua fa ca fa ua system live value effect show substitutions added equations consistent application lemma asc equation definition eqn 
appendix asc identity lemma applies 
equation lemma applies 
remaining equations lemma applies 
consider transformations value eqn 
eqn 

previous arguments identity 
value lemma value 
eqn 
eqn 
eqn 

value eqn 


ut lemma 
rule program 

lemma 
rule program 

proof main theorem theorem 
program fg set rewrite rules section analysis section transformation section 
analysis system delta delta delta sequence rewrites sn analysis system produced delta delta delta 
sn delta delta delta 
proof 
induction number rule applications 
base case zero rule applications trivial reflexive 
induction step program analysis system assume 
consider applying single rewrite analysis system gp lemmas gp 
ut nullspace compilers true optimizers section show consequence nullspace proof weak assumptions optimized programs minimal metric 
review necessary rewrite terminology 
write 
mean rewrites single step 
derives reflexive transitive closure 
write convertible mean 

reflexive transitive closure 
equivalence relation partitions set programs equivalence classes 
notation equivalence class program 

nullspace theorem guarantees 
write jpj textual size program 
assumptions 
rewrites strictly increase size jpj rewrite program 
nonincreasing program size jo jpj 

fixpoint 
third assumption reasonable transformation delta minimal changes support nullspace proof 
allow possibility improvements performed delta required nullspace proof 
lemma 
program 
nonempty set programs program 
derivable proof 
jpj rewrite program relation 
antisymmetric cycles 


pn 

furthermore 
reflexive transitive definition 

poset programs simply elements poset 
ut definition 
abstraction level program written minimum programs number rewrite steps shortest derivation 

theorem 
programs 
proof 
contradiction 
choose assume 
program rewrite gp 
apply optimizer gp nullspace theorem fixpoint assumption 
jo jo jp jo contradiction 
ut optimizing compiler nullspace property satisfying assumptions true optimizer produces program minimal metric demonstrated technique proving guaranteed optimization imperative compilers 
de optimizing rules proof technique give programmers intuitive feel abstractions may introduce performance loss 
proof shows sequence de optimizing rule applications undone single application optimizer optimizer effectively subsumes rewrite system implementing inverse optimizing rules 
proof relies adopting approach optimization simultaneous analyses followed single transformation step 
key unanswered question approach extend complex analyses transformations 
believe limits 
identify requirements adding framework analysis equations lattice framework analysis equations composable assembles expression subexpressions corresponding way assemble analyses subexpressions able describe suitable de optimizing rewrite rules rewrite rules admit proof lines lemmas 
explored rigorous way adding function pointers interprocedural analysis propagation values heap objects appear meet requirements 
plan incorporate formally proof framework 
acknowledgments kenneth kent dybvig ron garcia jaakko amr sabry jeremy siek comments drafts arch discussions reviewers helpful comments 

cliff click keith cooper 
combining analyses combining optimizations 
acm transactions programming languages systems march 

patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
principles programming languages pages january 

patrick cousot radhia cousot 
automatic synthesis optimal invariant assertions mathematical foundations 
proceedings symposium artificial intelligence programming languages pages 

nachum dershowitz 
taste rewrite systems 
proc 
functional programming concurrency simulation automated reasoning volume lecture notes computer science pages 

nachum dershowitz jean pierre jouannaud 
rewrite systems 
handbook theoretical computer science volume formal models pages 


gill peyton jones 
cheap deforestation practice optimiser haskell 
simon editors proceedings ifip th world computer congress 
volume technology foundations pages amsterdam netherlands august september 
elsevier science publishers 

gary kildall 
unified approach global program optimization 
conference record acm symposium principles programming languages pages 
acm sigact sigplan acm press 

lerner david grove craig chambers 
composing dataflow analyses transformations 
acm sigplan notices january 

steven muchnick 
advanced compiler design implementation 
morgan kaufmann san francisco 

matthias muller 
abstraction benchmarks performance applications 
proceedings fourth international conference supercomputing nuclear applications 

arch 
abstraction penalty small objects 
parallel object oriented methods applications conference feb mar 
santa fe new mexico 

amr sabry matthias felleisen 
reasoning programs continuationpassing style 
lisp symbolic computation 

david sands 
total correctness local improvement transformation functional programs 
acm transactions programming languages systems march 

jeremy siek andrew lumsdaine 
matrix template library unifying framework numerical linear algebra 
parallel object oriented scientific computing 
ecoop 

alex stepanov 
abstraction penalty benchmark 

walid taha tim sheard 
multi stage programming explicit annotations 
acm sigplan notices 

todd veldhuizen 
arrays 
computing object oriented parallel environments second international symposium volume lecture notes computer science pages 
springer verlag 

todd veldhuizen andrew lumsdaine 
guaranteed optimization proving nullspace properties compilers 
technical report tr indiana university computer science 

eelco visser 
survey rewriting strategies program transformation systems 
gramlich lucas editors workshop reduction strategies rewriting programming wrs volume electronic notes theoretical computer science utrecht netherlands may 
elsevier science publishers 

eelco visser el benaissa andrew tolmach 
building program optimizers rewriting strategies 
acm sigplan notices january 
proceedings international conference functional programming icfp 

wadler 
deforestation transforming programs eliminate trees 
theoretical computer science june 

mark wegman kenneth zadeck 
constant propagation conditional branches 
acm transactions programming languages systems april 

wei 
correctness fixpoint transformations 
theoretical computer science june 
lemmas statement additional lemmas lemma 
complete lattices theta thetad monotone functions lfp 
lfp 
lemma 
system expression normal completion edge reachability system live satisfies lemma 
expression reachability satisfies asc fdeadg 
expression static dominance region reachability congruence escape variables respectively asc fdeadg asc asc lemma 
system contains subterm asc fff fi ff asc fi asc yg 
lemma 
system contains equation asc asc 
lemma 
system contains equation asc range 
lemma 
system contains subterm asc ff ff fi ff asc fi asc yg 
proofs lemmas proof 
lemma added variable occur unchanged variables 
application lemma 
ff ff ff asc unchanged 
ut proof 
lemma consider changes induced analysis equations 
easier reading give newly introduced analysis variables numeric subscripts pre existing analysis variables alphabetic subscripts 
table shows flow graph analysis variables subexpression application fflffl fa fflffl fflffl fa fflffl ca ua ua ca block may uses variables local causes additional terms inserted escape equations 
variable defined additions form definition prior ux previous escape function unknown function analyzes congruence flow escape transform functions analysis uses variables cause rewritten described 
set analysis variables system live merge nonzero zero live live live congruence flow functions 
consider equations turn 
show revised equations substitutions resulting system consistent generally showing cases lemma applies 
additions equation live lemma asc 
equation nonzero definition nonzero eqn 
asc fdeadg 
application lemma added equations satisfy asc escape terms form delta added identities lemma applies 
live consistent lemma 
previous arguments asc fdeadg lemma asc fdeadg 
asc fdeadg delta identity 
lemma applies 
assumed completes normally equation identity zero live lemma system containing equation zero solution equation replaced zero live identity eqns 

lemma applies 
merge 
previous arguments asc fdeadg application lemma asc merge delta identity eqn 

lemma applies 
lemma applies 
remaining equations lemma applies 
consider transformation step 
previous arguments asc fdeadg dead eqn 


ut proof 
lemma trivial expressions constrained integers variable uses 
case integer literal analysis equation asc ng 
case variable analysis equation analysis variable 
lemma asc range 
range eqn 
asc ut lemma 
see section 
proof 
lemma consider changes induced analysis equations 
label analysis variables th setref statement superscript fa ref 
setref 
setref expression term form delta added escape equation corresponding expression term delta added escape equation 
revised escape equations 
system live read live 
live live live read live written 
live written live 
live value 
effect 
functions 
live written asc lemma 
asc repeated application lemma 
live read lemma asc read know case live asc lemma 
case dead asc lemma 
asc live 
cases asc live cases asc terms delta tu identities lemma applies 
live read cases asc term delta identity lemma applies 
consider transformation step 
previous arguments asc effect 
ref ref eqn 
eqn 

setref statement asc previous arguments 
setref eqn 


ut proof 
lemma consider changes induced analysis equations 
fflffl fa ca ua fflffl fflffl fa try fflffl fflffl fflffl catch fflffl yy fflffl ca ua ua try ca catch block may uses variables local causes additional terms inserted escape equations 
variable defined additions form definition prior ux previous escape function unknown function analyzes congruence flow escape transform functions analysis uses variables cause rewritten described 
assumed free function calls throw statements throw points system dead live functions 
show revised equations substitutions result consistent generally showing cases lemma applies 
dead asc fdeadg asc fdeadg 
lemma asc fdeadg 
equation delta identity 
lemma applies 
lemma applies 
previous arguments asc fdeadg lemma asc equation delta identity lemma applies 
equation live consistent lemma 
additions previous arguments asc fdeadg 
lemma variables corresponding uses variables satisfy asc added terms delta identities lemma applies 
equation lemma applies 
equations lemma applies 
consider transformation step 
previous arguments asc fdeadg dead try catch eqn 


ut proof 
lemma construction fixpoint 
induction monotonicity lim 
ut proof 
lemma construction fixpoint 
consider iteration value ff asc ff asc asc asc 
ut proof 
lemma lemma asc range 
ut proof 
lemma invoke soundness analysis 
value generated may normal completion edge live asc live asc ut proof 
lemma dominance region invoke soundness analysis assert asc asc congruence analysis variables proof bottom induction expression trees 
base case leaf expressions literals variables uses break 
expression dominance region case live asc fdeadg asc lemma 
case live 
asc fdeadg asc lemma 
case live 
asc fdeadg asc lemma 
case return live 
asc fdeadg asc lemma 
case break 
live 
asc fdeadg asc lemma 
case throw live 
asc fdeadg asc lemma 
case 
live 
asc fdeadg asc lemma 
case 
live 
asc fdeadg asc lemma 
case merge 
dominated induction hypothesis applies asc asc lemma asc case try catch merge 
dominated induction hypothesis applies asc asc lemma asc case loop live 
asc fdeadg asc lemma 
asc fdeadg 
escape analysis variables proof top induction expression trees 
block uk gamma gamma uk equations 
gamma escape variable expression receiving value clearly asc gamma induction hypothesis 
expression dominance region case tu variables associated uses case return value go control flow join return pad equation live return pad 
asc fdeadg asc lemma 
case throw value go control flow join throw pad catch block equation live control flow join 
asc fdeadg asc lemma 
case uk 
equation asc induction hypothesis asc case uk 
live 
asc fdeadg asc lemma 
equations live 
asc fdeadg asc lemma 
case live 
asc fdeadg asc lemma 
assuming conservatively may complete normally liveness normal completion edges 
equation live 
clearly dominated asc asc asc asc asc asc lemma 
case try catch assuming conservatively may complete normally liveness normal completion edges 
equation live 
clearly dominated asc asc asc asc asc asc lemma 
case loop equation asc asc fdeadg 
ut proof 
lemma construction fixpoint value fx ty fx gg 
ut 
