algorithm optimal winner determination combinatorial auctions tuomas sandholm sandholm cs cmu edu computer science department carnegie mellon university forbes avenue pittsburgh pa combinatorial auctions auctions bidders bid combinations items tend lead efficient allocations traditional auction mechanisms multi item auctions agents valuations items additive 
determining winners maximize revenue afp complete 
ana existing approaches tackling problem exhaustive enumeration dynamic programming restricting allowable combinations 
second study possibility approximate winner determination proving inapproximability general case discussing approximation algorithms special cases 
search algorithm optimal winner determination 
experiments shown bid distributions introduce 
algorithm allows combinatorial auctions scale significantly larger numbers items bids prior approaches optimal winner determination capitalizing fact space bids sparsely populated practice 
algorithm provably sufficient selective generation children search tree secondary search fast child generation heuristics admissible optimized speed preprocessing search space ways 
incremental winner determination quote computation techniques 
show basic combinatorial auctions allow bidders express complementarity items 
introduce fully expressive bidding languages called xor bids xors material invited talk st international confer ence information computation economies charleston sc 
technical report version circulated washington university st louis department computer science wucs 
conference version appeared international joint conference artificial intelligence ijcai pp 
stockholm sweden july august 
brief overview different approaches winner determination appeared decision support systems pp 

bidders express general preferences complementarity substitutability 
language concise 
show languages enable vickrey clarke groves mechanism construct combinatorial auction bidder dominant strategy bid truthfully 
extend search algorithm preprocessors handle languages arbitrary xor constraints bids 
keywords auction combinatorial auction multi item auction multi object auction bidding synergies winner determination multiagent systems 
auctions popular distributed autonomy preserving ways ing items goods resources services agents 
relatively efficient terms process outcome 
extensively human bidders variety task resource allocation problems 
internet auction servers built allow software agents participate auctions auction servers built support mobile agents 
auction seller wants sell items get highest possible payments bidder wants acquire items lowest possible price 
auctions cooperative agents open systems consisting self interested agents 
auction analyzed noncooperative game theory strategies self interested agents best auction desirable social outcome example efficient allocation follow 
auction mechanisms designed desirable social outcomes follow agent acts self interest 
focuses auctions multiple distinguishable items allocated techniques special case items indistinguishable 
auctions complex general case bidders preferences bundles bidder valuation bundle items need equal sum valuations individual items bundle 
case example electricity markets trading bandwidth auctions markets services pollution right auctions auctions airport landing slots auctions carrier resort responsibilities universal services 
types auction mechanisms setting subsections discuss 
sequential auction mechanisms sequential auction items auctioned time 
determining winners auction easy done picking highest bidder item separately 
bidding sequential auction difficult bidders preferences bundles 
determine valuation item bidder needs estimate items receive auctions 
requires speculation bid affects items receive 
furthermore bid depends believe bid counterspeculation introduces computational cost wasteful overhead 
auctions reasonable number items lookahead game tree intractable known way bid rationally 
bidding rationally involve optimally trading computational cost lookahead gains provides depend strike tradeoff 
furthermore lookahead computationally manageable usually uncertainty remains bids agents ex act information 
leads inefficient allocations bidders fail get combinations want get ones 
parallel auction mechanisms alternative sequential auctions parallel auction design 
parallel auction items open auction bidders may place bids certain time period bids publicly observable 
advantage bids partially signal bidder bids uncertainty need lookahead drastic sequential auction 
problems prevail sequential auctions albeit mitigated form 
parallel auctions additional difficulty arises bidder wait see going prices optimize bids maximize payoff final prices 
bidder want wait chance bidding commence 
patch problem activity rules 
bidder bid certain volume sum bid prices predefined time points auction bidder rights reduced prespecified manner example bidder may barred auction 
unfortunately game theoretic equilibrium bidding strategies auctions known 
follows outcomes auctions unknown rational bidders 
methods fixing inefficient allocations sequential parallel auctions computational cost lookahead counterspeculation recovered attempt fix ficient allocations stem uncertainties discussed 
approach set bidders exchange items auction closed 
approach undo inefficiencies may lead economically efficient allocation general may take large number exchanges agents 
approach allow bidders retract bids get combinations want 
example federal communi cations commission bandwidth auction bidders allowed retract bids 
case retraction item opened 
new winning price lower old bidder retracted bid pay difference 
guarantees retractions decrease auctioneer payoff 
exposes retracting bidder considerable risk retraction time know retraction costing 
risk mitigated leveled commitment mechanism penalties set front possibly item basis 
mechanism allows bidders allows auctioneer 
bidder may want example get combination wanted subset 
auctioneer may want example believes get higher price item 
leveled commitment mechanism interesting strategic aspects agents truthfully chance agent case agent freed contract obligations pay decommitment penalty collect penalty agent 
showed despite strategic breach nash equilibrium mechanism increase expected payoff parties enable contracts individually rational parties full commitment contract 
developed algorithms computing nash equilibrium strategies algorithms optimizing contract parameters 
addition experimentally studied sequences leveled commitment contracts associated cas cade effects 
approach sell options price option paid front option exercised 
methods implement bid retraction winning bids determined 
methods try fix inefficient allocations clearly desirable get efficient allocations right away auction fixing necessary 
combinatorial auctions hold significant promise goal 
combinatorial auction mechanisms combinatorial auctions overcome need lookahead inefficiencies stem related uncertainties 
combinatorial auction seller sellers acting concert multiple bidders 
bidders may place bids combina tions items 
allows bidder express complementarities items speculate item valuation impact possibly getting complementary items 
example federal communications commission sees desirability combinatorial bidding bandwidth auctions far combinatorial bidding allowed largely due perceived intractability winner determination 
focuses winner determination combinatorial auctions bidder bid combinations bundles indivisible items number bids accepted 
rest organized follows 
section defines winner determination problem formally analyzes complexity discusses different approaches attacking 
section presents new optimal algorithm problem 
section discusses setup winner determination experiments section discusses experimental results 
section discusses incremental winner determination quote computation properties quotes 
section discusses applications algorithm 
section overviews related tree search algorithms 
section discusses substitutability introduces bidding languages handle develops algorithm determining winners languages 
section presents research directions 
combinatorial auctions generalized exchanges multiple sellers multiple buyers 
commission directed congress balanced budget act develop combinatorial bidding system 
specifically balanced budget act requires commission directly contract provide design conduct purposes testing competitive bidding contingent combinatorial bidding system permits prospective bidders bid combinations groups licenses single bid enter multiple alternative bids single bidding round 

winner determination combinatorial auc tions assume auctioneer determines winners decides bids winning losing maximize seller revenue 
winner determination easy non combinatorial auctions 
done picking highest bidder item separately 
takes am time number bidders number items 
unfortunately winner determination combinatorial auctions hard 
set items auctioned imi agent place bid bi combination define length bid number items bid 
clearly bids submitted combination items winner determination purposes simply keep bid highest price discarded irrelevant beneficial seller accept inferior bids 
highest bid price combination max bi bidders agent submitted bid combination say bi 
bidder submitted bid combination say 
winner determination combinatorial auction problem 
goal find solution maximizes auctioneer revenue winning bidder pays prices winning bids max partition 
definition 
partition set subsets items item included subsets 
formally 
set partitions wc ties maximization broken desired way example randomly preferring bids received earlier ones received 
assignment bi need carried long special care taken combinations received bids 
show power algorithm stems explicitly assigning value zero combinations received bids constructing parts solution space populated bids 
corresponds auctioneer able keep items analogously settings disposal items free 
note partition ome item included ub 
notion partition simplicity 
explicitly state subsets items go 
partition trivial determine bids winning combination bidder placed highest bid bidder win combination 
winner determination problem formulated integer programming problem decision variable xs highest bid combination chosen winning xs 
formally max xs vs xs xsl subsections discuss different approaches tackling winner determination problem 
enumeration exhaustive partitions items way optimally solve winner determination problem enumerate exhaustive partitions items 
definition 
exhaustive partition partition item included exactly subset partition 
example space exhaustive partitions 
number exhaustive partitions grows rapidly number items auction increases 
exact number exhaustive partitions zz number exhaustive partitions subsets number exhaustive partitions level graph 
quantity known stirling number second kind captured recurrence qz 
recurrence understood con addition new item setting items 
term qz counts number exhaustive partitions formed adding new item existing exhaustive partitions 
level space exhaustive partitions item example 
vertex represents exhaustive partition 
followed upward arc represents bundles exhaustive partition 
followed downward arc represents mer bundles exhaustive partition 
choices existing exhaustive partitions subsets 
second term considers new item subset existing exhaustive partitions previous subsets counted 
proposition characterizes asymptotic complexity closed form 
proof appendix proposition number exhaustive partitions tm ands ram 
number exhaustive partitions large impossible enumerate number items auction extremely small dozen practice 
winner determination algorithm completely enumerates exhaustive partitions viable settings 
dynamic programming enumerating exhaustive partitions space exhaustive partitions explored efficiently dynamic program ming :10.1.1.56.9425
function dynamic program determines set items highest possible revenue obtained items algorithm proceeds systematically small sets large ones 
needed optimal substructure property comes fact set maximal revenue comes single bid price sum maximal revenues disjoint exhaustive subsets algorithm corresponds smaller subsets entire set higher revenue subsets 
possible subsets subset complement tried 
dynamic programming algorithm restated 
algorithm dynamic program winner determination input specified input bids received output optimal exhaustive partition opt 
set 
tom isi max maximizes right hand side 

opt goto start new time savings dynamic programming compared enumeration come fact revenue maximizing solutions subsets need computed 
dynamic program runs tm time :10.1.1.56.9425
significantly faster enumeration 
clearly dynamic program takes tm time looks dynamic program complex scale large numbers items practice 
dynamic program executes steps independent number bids 
algorithm generates combination bids placed interpreted positively means auctioneer determine ex ante long winner determination take regardless number bids received 
independent number bids dynamic programming algorithm choice number items small 
interpreted negatively means algorithm scale small number items number bids small 
section search algorithm avoids generation partitions include combinations items bids submitted 
allows algorithm scale significantly larger numbers items 
compact problem representation completeness bid received combination partitions include need considered 
enumeration dynamic program discussed capitalize observation 
capitalizing observation restrict attention relevant partitions 
definition 
set relevant partitions bid received restrict attention set combinations items bid received 
number relevant bids 
recall combination received bid highest bid relevant bids discarded 
winner determination formulated integer program max sc vss xs xs ig integer program fewer equal number variables constraints integer program numbers combination received bid 
discussed complexity dynamic programming 
furthermore tm lg 
combination items received bid input includes tm numbers means algorithm running time polynomial size input 
proposition states general condition dynamic program runs polynomial time 
proposition dynamic program runs time constant 
constant dynamic program runs plg time 
proof 
complexity dynamic program exists constant tm large re exists constant cl solving get implies 
exists constant cs large means exists constant substitute get gn 
get plg 
important question complex dynamic program executes steps regardless bids received 
important question exists algorithm runs fast size actual input include bids combinations 
words complexity problem 
unfortunately algorithm general solve polynomial time size input ap problem ap complete :10.1.1.56.9425
integer programming formulation problem weighted set packing view bid set items price weight set 
ap completeness winner determination follows fact weighted set packing ap complete 
polynomial time approximation algorithms way attempt achieve tractability try find reasonably relevant partition optimal 
trade expected cost additional computation cost computational resources cost associated delaying result expected improvement solution 
expectations try devise algorithm establish worst case bound guarantee revenue optimal solution greater positive constant times revenue best solution algorithm 
considerable amount research focused generating approximation algorithms run polynomial time size input 
relevant approximation algorithms developed weighted set packing problem weighted independent set problem winner determination 
section translate known algorithms inapproximability results theory combinatorial algorithms winner determination problem 
general case considerable interest taming computational complexity winner determination combinatorial auctions approximate winner determination 
question close optimal algo rithms get understood important remained open 
negative result shows polynomial time algorithm constructed achieving reasonable worst case guarantee 
proof inapproximability result maximum clique 
proposition inapproximability winner determination problem polynomial time algorithm guarantee bound af ff proof 
assume contradiction exists polynomial time ap proximation algorithm establishes bound winner determination problem 
algorithm solve weighted independent set problem polynomial time 
weighted independent set problem instance polynomially converted winner determination instance preserving approximability 
done generating item edge graph 
bid generated vertex graph 
bid includes exactly items correspond edges connected vertex 
algorithm approximate weighted independent set problem polynomial time approximate independent set problem polynomial time 
polynomial time approximation algorithm independent set problem directly approximate maximum clique problem polynomial time 
maximum clique problem independent set problem complement graph 
stad showed polynomial time algorithm establish maximum clique problem iv 
contradiction 
class problems solved polynomial time randomized algorithm zero probability error 
weighted independent set problem problem finding maximally weighted collection vertices undirected graph vertices adjacent 
practical perspective question polynomial time approximation worst case guarantees answered algorithms come close bound inapproximability result constructed 
asymptotically best algorithm establishes bound logn 
ask randomized algorithms help winner determination problem 
conceivable randomization provide improvement logn bound 
proposition applies randomized algorithms meaningful advantage gained randomization 
bound depends number items established polynomial time 
algorithm originally devised weighted set packing establishes bound 
auctioneer choose value increases bound improves running time increases 
specifically steps nc step step step naively implemented step 
algorithm max nc polynomial algorithm greedy winner determination input integer output approximately optimal relevant partition approx tt 

wc 

sw 
repeat return xt return greedy algorithm winner determination simply inserts bids order bid shares items allocation largest bid allocation bid discarded 
algorithm establishes bound 
bound algo rithm establishes better algorithm 
hand computational complexity algorithm quickly exceeds algorithm grows 
number items small compared number bids algorithms establish better bound proposition 
bound algorithm establishes best obtain showed bound established polynomial time positive 
bound high limited value auctions 
similarly bound 
bound mean algorithm capture available revenue 
summarize approach constructing polynomialtime approximation algorithms worst case guarantees futile general winner determination problem 
special cases general winner determination problem polynomial time somewhat better special cases bids special structure 
example cap number items bid cap number bids bid share items 
desired special structure enforced bidders restricting allowable bids 
lead inefficiencies non combinatorial auctions bidders may allowed bid combinations want 
alternatively auctioneer allow general bids special case algorithms bids happen exhibit desired special structure 
section reviews best polynomial time algorithms known special cases 
algorithms developed weighted independent set problem weighted set packing problem 
show apply winner determination problem 
bids items bound established nw time number bids bid share items note 
bids greedily inserted solution highest price basis 
local search improve solution search terminated number steps 
step new bid inserted solution old bids share items new bid removed solution 
improvements chosen maximize ratio new bid price divided sum prices old bids removed 

algorithms developed case bid shares items bids 
bound established linear time size input partitioning set bids subsets subset dynamic programming solve weighted set packing problem subset 
polynomial time algorithms setting establish bounds 

bids colored colors bids share items color bound established polynomial time 

bids claw bid shares items bids share items 
bids free bound established local search time 
algorithm establishes bound time 

largest subset bids bid shares items bids subset 
bound established polynomial time 
approximation algorithms known special cases improved repeatedly 
possibility probabilistic algorithms improve deterministic ones 
addition possible additional special cases desirable approximability properties 
example current approximation algorithms restrictions structure bids items new family restrictions lend approximation stems limitations prices 
example function close additive approxi mation easy 
unfortunately reasonable auctioneer restrict bid prices discard outlier bids 
setting upper bound reduce auctioneer revenue higher bids occur 
setting lower bound zero disable bidders lower valuations bidding bidder valuation bound bids combinations placed 
reduce auctioneer revenue 
forcing special structure sense auctioneer capitalize special price structure structure happens 
put considerable done approximation algorithms special cases combinatorial problems algorithms special cases winner determination problem 
worst case guarantees provided current algorithms far optimum limited importance auctions practice 
restricting combinations guarantee optimal winner determination polynomial time severe restrictions apply bids winner determination carried optimally polynomial time 
capitalize idea practice restrictions imposed auctioneer currently known ones severe hold chance 
section review bid restrictions suggested achieving polynomial winner determination 
bids items winners optimally determined time algorithm maximum weight matching :10.1.1.56.9425
problem complete bids items proven reduction set packing 

bids length greater winners optimally determined nog time nog number bids length greater :10.1.1.56.9425
factor comes exhaustively trying combinations long bids 
long bid uses large number items solution include long bids 
factor follows solving rest problem case 
part problem uses bids length items allocated long bids 

allowable combinations tree structure leaves correspond items bids submitted node internal leaf winners optimally determined time :10.1.1.56.9425
example left bid allowed bid 
tree structures winners optimally determined propagating information tree 
node best decision accept single bid items node best solutions children node 
left allowable bids tree structure 
right interval bids 

items ordered required bids placed consecutive items :10.1.1.56.9425
example right bid allowed bid 
wrap winners optimally determined dynamic programming 
algorithm starts item needed optimal substructure property comes fact highest revenue achieved items achieved picking bid placed entire combination picking bid placed combination doing best choices runs time 
sandholm suri developed faster dynamic program problem runs time :10.1.1.19.2028
asymptotically best hope 
wrap allowed winners optimally determined time rerunning algorithm times time cutting chain different point :10.1.1.56.9425
faster algorithm sandholm suri runs takes time :10.1.1.19.2028
introduce families combinations items winner determination easy family combinations different families intersect 
winner determination problem solved family separately solution family highest revenue chosen :10.1.1.56.9425
example lay items rectangular grid 
family columns family rows 
lay items tree structure allow bidding subtree 
solved nm time dynamic program 
problem complete items structured directed acyclic graph bids allowed directed subtree 
imposing restrictions bids introduces inefficiencies non combinatorial auctions bidders may barred bidding combinations want 
inherent tradeoff computational speed economic efficiency 
imposing certain restrictions bids achieves provably polynomial time winner determination gives rise economic inefficiencies 
optimal search algorithm generated approach optimal winner determination 
highly optimized search 
motivation approach allow bidding combinations approach re combinations 
order avoid inefficiencies occur non combinatorial auctions 
recall auctions lead economic inefficiency computational burden bidders need look ahead game tree 
find optimal solution time approximation algorithms 
maximizes revenue seller obtain bids 
optimal winner determination enables auction designs bidder incentive bid truthfully regardless bid discussed 
removes bidder motivation bid strategically 
bidders truthfully express preferences bids winner determination maximizes welfare system goods hands agents value 
completely avoid loops redundant generation vertices natural concerns algorithms try search graph exhaustive partitions directly 
algorithm search space directly searches fruitful space 
capitalize heavily sparseness bids dynamic program uses amount time irrespective number bids 
practice space bids extremely sparsely populated 
example items auc tioned combinations take longer life universe bid person world submitted bid second people happened bid different combinations 
sparseness bids implies relevant partitions small subset partitions 
dynamic program algorithm searches space relevant partitions 
follows run time algorithm depends number bids received dynamic program 
search space search tree search achieve goals 
input highest bid kept combination items bid received bids deleted list bids bj set items bid bj 
price bid path search tree consists sequence disjoint bids bids share items bj bk bids path 
point search path corresponds relevant partition 
set items path bj bj path set free items path ends bid added path 
occurs bid items path vj 
settings compact representations bidders expand large number bids 
example bidder may state ready pay ay items set items 
expand si bids 
search proceeds path tally kept sum prices bids path bj 
path search node revenue path value compared best value far search tree determine current solution path best far 
stored best solution far 
search completes stored solution optimal solution 
care taken correctly treat possibility auctioneer may able keep items proposition auctioneer revenue increase keep items allocate items bidders 
keeping items increases revenue item bids positive price submitted item 
proof 
consider auction items 
say bid item bid item bid combination 
profitable revenue auctioneer keep allocate allocate revenue 
bids positive price item auctioneer receive positive revenue allocating item bidder regardless auctioneer allocates items 
auctioneer revenue strictly lower kept items 
auctioneer possibility keeping items implemented preprocessing step algorithm placing dummy bids price zero individual items received bids 
example item bids dummy bids tree generated optimality lost 
dummy bids included set bids relevant partition captured path root node interior leaf search tree 
guarantees algorithm finds optimal solution 
rest dummy bid technique 
terms notation say dummy bids included list bids total number bids including dummy bids follows naive method constructing search tree include bids include items path children node 
proposition enables significant reduction bids search 
example search space corresponds bids listed left 
bid items shown price 
branching factor capitalizing fact order bids path matter 
proposition relevant partition represented tree exactly path root node interior leaf children node bids include item smallest index items path min include items path 
formally node search tree children sfu proof 
prove relevant partition represented path root node 
condition proposition leads fact partition generated order bids path 
exist path search node item allocated bidder bid auctioneer dummy bid allocated 
note difference possibilities allocating unallocated items dummy bid yields new relevant partition 
leaf search tree item allocated bidder bid auctioneer dummy bid 
partition bid occur multiple times child node 
tree uses bid child node 
remains proven relevant partition represented path root node tree 
assume contradiction relevant partition yf 
point bid partition bid item smallest index path bid inserted path 
contradiction 
search algorithm restricts children proposition 
seen example level bids considered level include item 
illustrates fact minimal index coincide depth search tree general 
summarize search tree path root node interior leaf corresponds relevant partition 
relevant partition represented exactly path 
partitions generated 
call search search 
size tree search section analyze worst case size tree search 
proposition number leaves search greater number leaves search greater qm tig tm see equations definition 
furthermore number leaves search greater number nodes search excluding root greater times number leaves 
number nodes search greater proof 
prove number leaves greater depth tree node path uses item 
ni set bids include item items smaller index ni 
clearly vi ni nj 
nm upper bound number leaves tree nm branching factor node hi increases strictly path tree 
maximization problem max 
nm solved nm divisible value maximization upper bound 
number leaves tree greater prove number leaves search greater qm 
dummy bids path root leaf corresponds relevant exhaustive partition 
num ber leaves greater number exhaustive partitions generally lower exhaustive partitions relevant 
section showed number exhaustive partitions qm 
proposition prove number nodes number leaves greater combinations bids including bids 
search tree path root node corresponds unique combination bids reverse true combinations bids share items combinations repre sented path tree 
number nodes greater nodes path excluding root number nodes tree excluding root greater times number leaves 
proposition bound tighter lower bound proof 
log log holds positive numbers bound shows number leaves nodes search polynomial number bids worst case number items fixed 
hand number items increases number bids increases due dummy bids worst case number leaves nodes search remains exponential number items fast generation children search node tree search determine children 
words needs find bids satisfy conditions proposition 
naive approach loop list bids search node accept bid child includes include items takes nm time search node loops list bids bid loops list items 
sophisticated scheme child generation faster 
version search uses secondary depth search search quickly determine children node 
search takes place different space data structure call 
binary tree bids inserted front leaves parts tree generated bids received 
blocked data structure 
select parts search allowed go 
differentiates classic binary tree 
vector variable item take values blocked 
blocked search progress left depth tm effect bids include item pruned instantly place 
search progress right depth effect bids include item pruned instantly place 
bit architecture time reduced factor representing items representing items 
machine compute xor bits time 
return bid includes items root tree depth 
corresponds pruning item search may go left right depth illustrates particular values prune 
search generate children search 
basic principle node search blocked values variable settings search return exactly bids satisfy proposition 
naive implementation set values anew node search generate entire list children continuing search child 
deploy faster method setting values 
generate child time 
follows technique detail 
search begins 
child node search determined depth search search top leaf bid reached 
bid node added path search 
time bid appended path search algorithm sets blocked 
blocked values changed back backtracking bid path search value reallocated place bid appended path 
unexplored sibling child search determined continuing search backtracking search explored tree fl 
note search needs backtrack depth items smaller indices path search 
ordering children search search search depth search children search node generated lexicographic order bid set items viewed vector 
example auction items item vector bid contains items 
demonstrate lexicographic order current bids include item 
item implemented search execute place memory allocation search 
accomplished observation open list recursion stack required search algorithms 
depthfirst search search tree entirely kept memory decide go suffices know search focus came 
enable algorithm stores depth search separately search focus search came 
vectors 
children generated order item vectors 
children generated subtrees explored order generating children order search branches explored 
implication ordering bid item child explored 
alternatively generate children search node search store example linked list exploring 
allow children ordered additional considerations 
exploring promising children improve performance search solutions earlier 
main advantages 
search needs terminated completed better solution available 
second finding solutions earlier allows pruning search paths search bounding technique discussed section 
complexity search discussed previous section naive approach generating children takes nm time worst case 
desired search generate children reduces complexity worst case 
finding entire set children time corresponds conducting depth search search 
complexity search greater number edges times account backtracks 
proposition gives tight upper bound number edges 
proposition tree uniform depth convention root depth leaves node children case search number edges nm log nj bound tight 
innocuous assumption logn constant log 
hand assumption logn proof proposition appendix complexity reduction search naive method moderate worst case cases complexity reduction significantly greater 
extreme example best case search takes time example bids include item item path complexity naive approach remains nm 
case search wide late ree right upper part log edges lower part edges complexity max log 
analysis section pertains single search node 
due substantial pruning nodes search suffer worst case child generation 
research study complexity child generation amortized search nodes 
discussed search nodes pruned 
sophisticated analysis child generation amortize search nodes children generated 
anytime winner determination depthfirst search strategy search implemented main search search depth search 
runs linear space counting statically allocated data structure uses slightly memory shown proposition 
feasible solutions quickly 
relevant exhaustive partition search path left leaf 
fact path root interior node converted feasible solution having auctioneer keep items allocated path far 
solution improves monotonically algorithm keeps track best solution far 
implements anytime feature algorithm complete desired amount time terminated prematurely guarantees feasible solution improves monotonically 
testing anytime feature turned practice revenue generated early desired diminishing returns computation 
preprocessing algorithm preprocesses bids ways main search faster compromising optimality 
preprocessors conjunction approaches winner determination search algorithm 
subsections preprocessors order executed 
keep highest bid combination bid arrives inserted 
bid set items exists leaf created new bid exists bid higher price kept bid discarded 
ties broken randomly example favor bid received earlier 
inserting bid insertion involves creating path length bids insert 
time complexity pre pre remove provably bids preprocessor removes bids provably 
bid disjoint collection subsets bid sum bid prices subsets exceeds equals price bid 
example bid items pruned bid items bid items 
determine search bid potential combinations disjoint subset bids 
depth search main search restricts search bids include items includes blocked kept items 
ensures subset bids contribute pruning 
bids search tree generated pre 
dotted paths generated pruning occurs reached 
determined permanently discarded 
participate pruning bids 
especially bids contain large number items pre take time saves main search 
extreme bid items preprocessing search bid main search main search path contains bid 
save preprocessing time pre carried partially 
partial pruning bids left unpruned 
compromise optimality main search main search sped compared full pruning 
implemented ways restricting pre cap number bids combined try prune particular bid 
limits depth search pre cap number items bid 
longer bids targets pruning 
entails cap tree depth 
tends exclude wide trees long usually lead trees large branching factors 
method pre takes log time polynomial constant cap tree finding child 
logn 
tm method usually preferable 
waste computation long take lot preprocessing time significantly increase main search time 
main search shallow branches include long bids due fact item path long bid uses items 
second additive method lead pruning prematurely cap 
occur bid prices close path cut pre decompose set bids connected compo nents bids divided sets item shared bids different sets 
sets determined follows 
define graph bids vertices vertices share edge bids share items 
generate adjacency list representation graph mn time 
number edges graph 
clearly depth search generate depth forest graph time 
tree forest set desired analysis innocuous assumption ra log constant recall proposition 
complexity finding child children 
property 
pre main search done set bids independently items included bids set 
presentation follows denote number items connected component question number bids connected component question 
pre mark tuples bids tuples disjoint bids marked need considered path search 
example pair bids items items bid items bid items 
formally definition 
tuple ji jj jk jt ji jj jk bab exists bx bb tuples determined pre virtual bid contains items bids tuple ubc bi bk price sum prices bids bc 
pre inequality price com parison strict tuples equally get excluded compromise optimality 
pre concern cause bids discarded determined 
computational speed determine tuples pairs bids 
pre partial preprocessor pre caps 
pre runs logn time 
considering pairs bids tree pair finding child 
log handling tuples increase complexity mt log handling large tuples slows main search needs ensure tuples exist path 
lit sound exclude tuples draw 
order avoid overhead keeping track rare occurrences exclude tuples draw 
analysis innocuous assumption ra log constant recall proposition 
complexity finding child children 
bid appended path search excludes rest path bids constitute pair bids share items 
algorithm determines quickly follows 
bid list bids exclude determined pre 
search exclusion count kept bid starting 
bid appended path exclusion counts bids excludes incremented 
bid backtracked path exclusion counts decremented 
searching bids append search path bids exclusion count accepted 
iterative deepening heuristics sped main search iterative deepening ida search strategy depth search 
search tree search generate children search node preprocessors stay 
practice ida finds provably optimal solution searching small fraction entire search tree search 
pseudocode shows applied ida search strategy winner determination problem 
function discussed detail gives upper bound revenue items allocated current search path contribute 
defined earlier sum prices bids current search path 
search node upper bound total revenue obtained including search node solution 
basic ida search ida iteration keep incrementing limit equal revenue best solution far order avoid futile search 
words solution algorithm converts branch bound heuristic function modification included pseudocode 
pre pre converted anytime preprocessors compromising optimality starting small cap conducting searches increasing cap searches preprocessing complete cap user decides stopping criterion met 
pre pre converted approximate preprocessors allowing pruning sum prices exceeds fixed fraction price 
allow bids pruned main search faster compromise optimality 
global variable limit algorithm ida winner determination returns set winning bids maximizes sum bid prices 
limit 
loop winners new dfs contour winners null return winners limit min new 
limit algorithm dfs contour winners returns set winning bids new cost 
compute methods doing 

search returns children path reached limit revert leaf reached return winners 
null 
bid children children search solution new dfs bid 
winners bid 
solution null new new ii 
solution max new 
null return return null constant determined experimentally range discussed 
iteration ida limit gives upper bound solution quality revenue 
example communicate search progress auctioneer 
winner determination maximization problem heuristic func tion underestimate revenue items allocated bids path compromise optimality 
designed admissible heuristics 
heuristic take sum unallocated items item maximal contribution 
item maximal contribution price bid divided number items bid maximized bids item belongs 
formally max proposition heuristic gives upper bound revenue unallocated items contribute 
proof 
set bid determined winning items contributes abl revenue 
item winning bid 
revenue contribution item max 
get upper bound unallocated items contribute simply sum isl heuristic identical heuristic accuracy increased recomputing time bid appended path bids may excluded 
bid excluded items current path search constitutes itive pair determined bid current path search 
proposition heuristic gives upper bound revenue unallocated items contribute 
proof 
excluded bids affect revenue designated winning 
recomputed ex bids proof proposition holds 
heuristic methods speeding 
tally kept values need updated bid appended path 
pre precompute bid list items updated items included bid bids bid exclude list 
update faster keep item list bids belongs 
value computed traversing list choosing highest bids exclusion count 
recomputing takes time number items need updated nf average greatest number bids items belong 
time complexity main search search worst case time complexity main search polynomial bids exponential items 
desirable auctioneer control number items sale usually control want restrict number bids received 
specifically proposition number search nodes 
pruning 
time search node node activities child generation function updating 
ida generates nodes multiple times nodes generated iteration regenerated iteration 
new limit lowered maximum value lower limit previous iteration lower value iteration generates search node previous iteration 
number nodes search tree search nodes 
practice generate ida generate significantly fewer limit decreased iterations pseudocode discussed section experimental results 
hypothetical worst case worst case complexity remains polynomial bids regeneration nodes ida increases complexity polynomially 
complexity number bids complexity number bids received 
contrast approaches dynamic program executes steps independent bids received 
pre pre depth search due caps execution time negligible compared main search time 
alternatively ida 
main search values computed combinations subsets 
limit ida set equal bid price fraction thereof case approximation ida complete iteration 
care needs taken heuristic tuple exclusion handled correctly results preprocessing 
experimental setup determine efficiency algorithm practice ran experiments general purpose uniprocessor workstation mhz sun ultra gigabyte ram different bid distributions random bid pick number items randomly randomly choose items replacement 
pick price randomly 
weighted random pick price number items bid 
uniform draw number randomly chosen items bid 
pick prices 
decay give bid random item 
repeatedly add new random item probability item added bid includes items 
pick price number items bid 
bid generated twice new version deleted regenerated 
example generator asked produce bids produced different bids 
bids bidder 
conservative method causes pre prune bids 
model reality number items large bidders place bids randomly chosen combinations chance agents bid combination small due number combinations large tm 
cases pre effective 
extreme prunes bids bids placed combination different bidders 
pre effective algorithm run faster suggested conservative experiments 
experimental results focus ida branch bound iteration leaf reached orders magnitude faster depth search 
lower limit iterations previous limit highest value lower limit previous ida iteration whichever smaller shown pseudocode previous section 
clearly reason limit higher highest value lower limit previous ida iteration 
criterion decrease limit faster 
experimentally tended rate decreasing limit 
decreased fast number search nodes increases iteration lead large number search nodes df 
decreased slowly number search nodes increases new iterations repeat large portion search previous iterations 
pre cap gave compromise preprocessing time main search time 
pre led compromise 
values rest experiments 
caps hard problem instances short bids get preprocessed completely pre pre tend take negligible time compared main search trees short small 
caps take effect easy cases long bids 
uniform distribution bids length pre prune bids bid subset 
expected pre saved significant time uniform decay distributions partitioning bids connected components number bids small compared number items bids short 
hand experiments random weighted random distributions bids fell connected component bids long 
real world combinatorial auctions number bids significantly exceed number items suggest pre help 
practical settings bids short bidders interests special structure leads items independent pre automatically capitalize 
main search generated nodes second num ber items small bids short items bid rate decreased slightly number bids significantly number items bid size 
weighted random distribution items bids search generated nodes second 
algorithm solved cases easily search paths short heuristic focused search 
long bids heuristic exclusion checking slower search tree shallower easier algorithm short bids 
observation supported results 
point graph represents average problem instances 
execution times include preprocessing times 
problem sizes consider pre vious optimal winner determination approaches exhaustive enumeration dynamic programming practice take prohibitively long discussed earlier 
basic experiments different bid distribu tions problem instances drawn random distribution tended easy 
reason search shallow bids long 
bid uses large number items small number bids search path 
log seconds random distribution items items items items bids execution time random distribution 
run times point number items number bids varied order magnitude 
despite averaging instances points items bids items bids unusually high points happened encounter unusually hard instances 
weighted random distribution easier 
weighted unweighted case curves sublinear meaning execution time polynomial bids 
clear unweighted case 
extend experiments higher ratio bids items 
apparent unweighted case 
comparing figures see weighted random distribution bulk execution time spent preprocessing searching 
avoided turning preprocessors distribution 
keep experiments honest algo rithm parameterization distribution independent preprocessor caps distributions 
research focus automatically identifying caps set problem instance 
distributions weighted random preprocessing time small fraction search time 
plots execution time search time identical plots execution time 
uniform distribution harder 
bids shorter search deeper 
shows complexity decrease log seconds weighted random distribution bids items items items items execution time preprocessing time plus search time weighted random distribution 
leg seconds search time bids search time weighted random distribution 
leg seconds uniform distribution items bid items items items items bids execution time uniform distribution 
bids get longer search gets shallower 
decay distribution hard 
complexity leg items items bid bids bids bids execution time uniform di tribution number item bid 
log seconds decay distribution alpha items items items items bids execution time decay distribution 
despite averaging instances points items bids items bids unusually high points happened encounter unusually hard instances 
creases decreases 
left maximum pre decomposes problem leading small fast searches 
hardness peak moves slightly left number bids grows decomposition successful 
right maximum bids set 
complexity decreases longer bids lead shallower search 
graphs distribution fix hardest value 
scaling larger numbers bids practice auctioneer usually control number items sold combinatorial auction control number bids log seconds decay distribution items ds alpha execution time decay distribution varies 
submitted 
particularly important winner determination algorithm scales large numbers bids 
section test algorithm scales large numbers bids fix number items 
shows random weighted random distributions algorithm scales large numbers bids 
complexity clearly polynomial bids number bids reaches certain level additional bids increase complexity slightly 
log seconds items bids random weighted random execution time random weighted random distributions 
uniform decay distributions harder 
distribution curves sublinear meaning execution time polynomial bids 
log seconds items bids uniform item bids decay alpha execution time uniform decay distributions 
varying number items fixing num ber bids studied complexity number items fixing number bids 
shows random weighted random distributions algorithm scales large numbers items 
curves sublinear meaning execution time polynomial items 
log seconds bids items random weighted random execution time random weighted random distributions varying number items 
figures show uniform decay distributions harder 
execution time increases rapidly number items increases 
distributions curves sublinear meaning execution time polynomial items 
seconds uniform item bids items execution time uniform distribution varying number items 
leg decay bids alpha items execution time decay distribution varying number items 
fixing ratio bids items practical perspective reasonable number bids grows number items grows 
additional experiment called number items number bids fixed 
experiment fixed ratio bids items 
presents execution times random weighted random distributions 
curves sublinear means execution time polynomial bids items 
presents execution times uniform decay distributions 
significantly harder random weighted random distributions 
log seconds bids items items random weighted random execution time random weighted random distributions 
log seconds decay alpha items execution time uniform decay distributions 
incremental computations auction settings important provide results auction open 
motivated need designed incremental methods computing results 
subsections discuss incremental winner determination incremental quote computation 
incremental winner determination auction settings important able compute optimal solu tions interim bids received received 
allows bidders told current winners bids received 
information naively produced running preprocessors main search scratch time new bid arrives 
amount redundant computation reduced observations 

say new bid 
arrived winner de termination carried 
pre pre prune new bid bid affect solution 
follows solution optimal new bid arrived remains optimal pre pre main search need executed 
new bid permanently discarded 
bids arrive competitive 
bid prune bids pruned anyway 

pre pre prune new bid winners determined follows 
rl old optimal revenue new bid conduct winner determination items bids include items call new optimal revenue rm 
rm 
told optimal revenue 
optimal solution includes new bid winning bids new winner determination 
old revenue rta corresponding bids optimal 
winner determination items done ida iteration setting limit ida returns solution old optimal solution best 
hand ida returns solution solution bid best 
single ida iteration involve unnecessary search price new bid high relative prices old bids scenarios new solutions better old solution higher limit leading pruning search 
reduce number nodes generated iteration starting ida higher limit lowering iterations solution 
need lower start lowering limit upper bound ub ub upper bound rm 
revenue old optimum minus highest revenue obtained non overlapping old bids items contained new bid 
formally ub max ti tgt computed old bids 
incremental winner determination bids arrived winner determination 
observation 
extended setting 
old bids new bids prune new bids pre pre 
determine old solution optimal new bids pruned 
get pruned solution needs recomputed old bids targets pruning 
old bid pruned light new bids 
observation 
extended setting 
observation 
fails pre pre main search need executed old optimal revenue rid provides lower bound new optimal revenue rew lower bound initial limit main search ida completes iteration 
ida returns solution limit new optimal solution includes new bids 
old optimal solution remains best 
single ida iteration involve unnecessary search prices new bids high relative prices old bids scenario higher limit leading pruning suffice finding new optimal solution better old optimal solu tion 
reduce number search nodes iteration starting ida higher limit lowering iterations solution 
need lower start lowering limit old old upper bound vw 
upper bound uss ub rw uss new bids maximal revenue obtained items old new bids rl maximal revenue obtained items old bids 
revenues determined preprocessing search tech niques si carrying winner determination 
incremental quote computation settings important able tell prospective bidder bid combination winner bids far 
example bidder may post query bid obtain set items assuming bids submitted 
developed methods computing quotes 
exact quote 
revenue current optimal solution 
remove items bids include items determine winners optimally 
call new revenue reduce exact quote reduced 
quote bounds 
upper bound quote bid certainly get assuming bids submitted computed upper bound exact value minus lower bound exact value reduc similarly lower bound quote bid certainly get assuming bids submitted computed lower bound exact value minus upper bound exact value lower bound computed approximation algorithm discussed earlier running time search algorithm amount time 
earlier solution obtained newest bids lower bound 
allows winner determination run occasionally supporting approximate quotes 
compute lower bounds provide highest 
upper bound computed linear programming relax ation problem discussed section function value directly upper bound 
alternatively limit ida upper bound 
limit provide upper bound ida iteration know advance current iteration highest value lower limit previous iteration 
alternative incrementally computed upper bound ubs previous subsection 
allows winner determination run occasionally supporting approximate quotes 
compute upper bounds provide lowest 

binary search quote quote bounds 
hypothetical bid placed combination binary search carried price new bid running preprocessors main search algorithm price binary search generates new bid 
observations 

previous subsection directly speed execution price point 
price low preprocessors quickly determine hypothetical bid competitive 
provides lower bound quote binary search proceed 
price high search quickly find solutions include new bid give revenue exceeds revenue obtainable bid 
occurs search interrupted upper bound quote established binary search proceed 
properties quotes quotes exact quotes combinatorial auctions interesting properties 
quote combination necessarily sum quotes individual items proposition quotes combinatorial auction additive 
proof 
consider auction items 
say bids submitted item item combination 
quote item quote item quote combination 

means providing quotes individual items provide information bidder prefers combinations 
usual single item auctions quote increase stay new bid arrives 
new bids reduce quote 
monotonicity ceases hold combinatorial auctions proposition bid submitted combination individual item combinatorial auction quotes combinations individual items increase decrease 
proof 
consider example proof proposition 
say new bid submitted combination 
quote item increases quote item increases 
bid submitted item quote item decreases 
bid currently winner quote set items bid simply price bid 
applications algorithms algorithms winner determination directly solve weighted set packing weighted independent set weighted maximum clique cause fact analogous problems 
addition coalition structure generation characteristic function games 
characteristic function assigns value potential coalition agents 
objective partition agents exhaustively disjoint coalitions maximize sum values coalitions 
agents correspond items coalitions combinations coalition values bid prices 
problem analogous winner determination problem coalitions nonnegative values 
usually achieved normalizing hold front 
coalition structure generation differs winner determination major ways 
values coalitions usually nonzero space bids densely populated 
reduces usefulness algorithms capitalize sparseness bids 
speaks favor dynamic program 
scale past small numbers agents 
second coalition structure generation values coalitions known party values complete coalition structures known known search process 
sandholm proved inapproximability results devised anytime approximation algorithm worst case guarantees case harder case values coalitions observed 
related tree search algorithms significant amount field operations research focused problems analogous combinatorial auction winner determination problem particularly weighted set packing weighted independent set 
approximation approaches discussed detail earlier 
addition considerable research done exact algorithms problems 
algorithms typically branch bound search strategy function value upper bound revenue unallocated items contribute computed linear programming problem obtained winner determination problem items bids usable bids search path changing constraints xs xs nomial time size input nm interior point methods fast average simplex method 
upper bound linear programming relaxation provides tight lowered introducing cuts 
additional constraints affect solution integer program constrain linear programming polytope 
major research questions algorithms include inventing new sound cuts constructing fast algorithms constructing cuts experimenting tradeoff time spent generating cuts time saved due reduction search tree size stems tighter upper bounds 
vast literature see example 
modern books approach overviews applying approach auctions written 
generally approach leads smaller number search nodes approach due tighter upper bounds spends time search node 
faster depends problem instance distribution 
viewing approaches mutually exclusive viewed complementary 
hybrid algorithm techniques ap proach preprocessors fast child generation methods combination ida branch bound function fast compute traditional integer programming approach linear programming relaxation provide upper bounds introducing cuts 
example hybrid algorithm slow relatively ac linear programming relaxation occasionally fast function provide upper bounds search nodes 
sound compute types upper bounds lowest 
circulated technical report review artificial intelligence similar algorithm called cass published 
fact algorithms vsa cass 
focus cass vsa generally find optimal solution 
despite significant similarities cass differs algorithm certain 
cass uses branch bound search strategy ida combined branch bound 
search strategy dominates 
ida lead fewer search nodes limit allows pruning parts search space branch bound search 
hand branch bound lead fewer search nodes ida searches nodes close root multiple times 
cass uses basic mn child generation technique developed elaborate method 
logn child generation 
cass uses binning improve average case speed child generation 
specifically cass keeps lists bids 
list bids include item find children node algorithm needs loop list recall smallest index items path 
binning technique garfinkel nemhauser 
cass uses rough approximation function supports computing function values advance search 
cass uses caching 
caching directly incorporated algorithm 
cass items search promising bids tried early search 
relabeling directly incorporated algorithm 
experimentally proved effective cass 
cass uses child ordering heuristics determine order children node considered 
incorporating child ordering heuristics algorithm straightforward incremental child generation imposes particular order children discussed section 
child ordering heuristics incorporated algorithm generating children node batch ordering children search proceeds 
cass sophisticated preprocessing 
preprocessors conjunction cass 
substitutability xor bids xors bidding methods winner determination reviewed early combinatorial auctions see example setting bidder bid combinations items number bidder bids accepted 
works bids superadditive 
bids superadditive lead problems 
example happens agent bids bidders 
auctioneer allocate items agent separately agent bid combination value 
current techniques focus capturing synergies complementarities items 
practice local substitutability subadditivity bid prices occur 
simple example bidding landing slot airplane bidder willing take host slots want 
address issue internet auction house prototype part electronic commerce server called see www 
cs 

edu 
developed bidding language bidders submit xor bids bids combinations bids get accepted 
allows bidders express gen eral preferences complementarity substitutability see 
words bidder express value function example bidder item auction may submit put auctioneer xor xor xor xor default bid empty set items 
xor xor xor xor xor xor xor xor xor xor fully expressive bidding languages advantages 
bidder express preferences having approximate utterance expressive bidding language 
extra expressiveness generally increases economic efficiency allocation winner determination algorithm takes input fully expressive bids approximations 
second fully expressive bidding languages enables auctioneer extract truthful valuation bids 
fully expressive bidding language bidding truth fully incentive compatible dominant strategy vickrey clarke groves mechanism 
means bidder motivated bid truthfully regardless bid 
renders counterspeculation unnecessary 
vickrey clarke groves mechanism applied combinatorial auction setting follows assuming fully expressive bidding language 
winning bids determined maximize auctioneer revenue constraint item allocated bid 
amount agent needs pay sum winning bids agent submitted bids minus sum winning bids actual optimal allocation 
winner determination problem solved winning agent agent bids 
fast winner determination crucial 
note example just removing winning bid time constitute incentive compatible mechanism 
incentive compatibility lost winner determination price determination done approximately 
xor bids fully expressive representing preferences language leads large numbers bids combined xor 
maintain full expressiveness time representation concise propose bidding language call xors 
supported 
language set bids combined xor forming xor disjunct 
xor disjuncts combined non exclusive ors represent independence 
example bidder wants submit offer example submitting concise input auctioneer xor xor note simple xor bidding language special case xors language 
shortest way represent particular value function xors language longer simple xor bidding language 
traditional winner determination problem xors special case winner determination xors bidding language completeness inapproximability results apply winner deter xors bidding language 
winner determination xors winner determination algorithm easily adapted handle bids simple xor bidding language xors language language bidder place arbitrarily bids 
bids bids appended search path search excluded appended search path 
discussed earlier exclusion occurs bids share items bids constitute pair determined pre 
discussed exclusion mechanism part algorithm 
bid list bids exclude kept 
bid appended search path search exclusion counts bids bid excludes incremented decremented bid backtracked search path 
point search bids exclusion count considered appending search path 
handling xors algorithm easy 
bids xor disjunct simply added exclusion lists algorithm handle xors correctly 
xor constraints reduce size search space search faster constraints 
preprocessing xors preprocessors directly xor constraints 
section uncover issues design modifications preprocessors circulated technical report review artificial intelligence fully expressive input method proposed 
approach bids mutually exclusive dummy item created included bids 
bids occur solution share item 
correctly handle xor constraints 
preprocessor pre consider item auction bidder submitted xor bidder submitted naive application pre bid permanently remove bid maximal revenue 
accepting bids auctioneer achieve revenue 
words pre discarded bid 
pre easily modified correctly handle xor constraints bids 
achieved having pre discard bids aggressively 
bid prune bid set items bids xor disjunct 
second bid prune bid set items xor disjunct bid xor disjunct 
second preprocessor pre consider item auction bidder submitted bidder submitted xor naive application pre bids prune bid 
pruning maximal revenue 
words pre discarded bid 
pre easily modified correctly handle xor constraints bids 
achieved having pre discard bids aggressively 
pruning bid xor disjunct allow bid prune bid item set subset bid bid price higher equal bid price limited value practice reason having multiple bids set items xor disjunct 
allowing set bids prune bid pre 
bids set occur combined xor 
second bids prune bid different xor disjunct bids xor disjunct 
third preprocessor pre consider item auction bidder submitted xor naive application pre decompose problem connected components bid 
winner determination run independently connected component total revenue actual maximal revenue 
words pre decomposed problem 
pre easily modified correctly handle xor constraints bids 
achieved having pre decompose problem aggressively 
specifically graph pre constructs purpose identifying connected components extra edge added pair bids xor disjunct 
connected components identified graph pre main search carried connected component separately 
fourth preprocessor pre consider auction bidder submitted bidder submitted bidder submitted xor naive application pre bids mark pair bids 
lead maximal revenue actual maximal revenue 
pre easily modified correctly handle xor constraints bids 
achieved having pre mark tuples bids aggressively 
bids xor disjunct need marked ensures search path search 
second bids mark bids different bids xor disjunct 
incremental winner determination quotes xors incremental techniques determining winners computing quotes discussed section easily xor constraints bids allowed 
modification incremental techniques main search preprocessors adjusted discussed previous subsections 
research combinatorial auctions auctions bidders bid combinations items tend lead efficient allocations traditional auction mechanisms multi item auctions agents valuations items additive 
users express bids winner determination algorithm take account 
tackled winner determination combinatorial auc tions bidder bid unrestricted combinations items 
settings determining winners maximize auctioneer revenue vp complete 
space partitions items explicated closed form asymptotic upper lower bounds number exhaustive partitions derived 
number large enumeration small number items 
dynamic programming avoids redundancy scale auctions small number items generates entire search space independent bids received 
showed conditions running time scales polynomially 
approach compromising optimality achieve polynomial time winner determination futile interested worst case approximation guarantees proven inapproximability maximum clique proved winner determination problem 
combinations restricted somewhat better guarantees established known approximation algorithms weighted independent set problem weighted set packing problem guarantees remain weak useful domain auctions practice 
main hope practical approximations special cases lies new forms special structure especially bid prices 
imposing severe restrictions allowable combinations optimal winner determination guaranteed polynomial time 
restrictions introduce economic inefficiencies non combinatorial auctions 
tackle limitations existing approaches winner determination developed search algorithm optimal winner determination 
experiments different bid distributions introduced showed algorithm significantly enlarges envelope inputs combinatorial auctions optimal winner determination computationally feasible 
highly optimized algorithm achieves mainly capitalizing fact space bids sparsely populated practice 
dynamic programming generates populated parts search space 
algorithmic methods implement include provably sufficient selective generation children search tree secondary search find children quickly heuristics admissible optimized speed 
algorithm preprocesses search space keeping highest bid combination removing bids provably determined search decomposing problem independent parts marking tuples bids determined search 
ida search algorithm main search easily distributed multiple computers additional speed 
burden search imposed bidders giving bidder portion search space explore 
introduces risks 
bidder may search portion partially save computational effort 
free riding desirable bidders find solutions anyway assuming free ride 
second bidder may report suboptimal solution solution leads higher payoff 
prevent problems auctioneer randomly select bidders reported best solutions re search portions 
portion auctioneer finds better solution reported bidder gets caught fraudulent searching penalty imposed 
penalty high compared cost computation compared maximal gain reporting probability getting checked sufficiently high bidder motivated search portion truthfully 
algorithms winner determination directly solve weighted set packing weighted independent set weighted maximum clique fact analogous problem 
coalition structure generation characteristic function games similar problem differing features discussed 
techniques incremental winner determination quote computation 
showed quotes nonadditive new bid may increase decrease quotes combinations 
showed basic combinatorial auctions allow bidders express complementarity items 
proposed bidding language called xor bids 
fully expressive bidders express substitutability 
discussed bidding language enables vickrey clarke groves mechanism construct combinatorial auction bidder dominant strategy bid truthfully strategically 
introduced fully expressive bidding language called xors 
advantages xor bids concise 
extended search algorithm preprocessors handle languages languages xor constraints arbitrarily inserted bids 
search algorithm easily extended settings auctioneer keep items 
accomplished dummy bids considering solution feasible search node items allocated bidders 
settings bids negative zero prices may accepted 
current developing faster winner determination algorithms combinatorial auctions algorithms clearing combinatorial reverse auctions exchanges 
study ing impact side constraints non price attributes complexity clearing combinatorial markets 
direction restricted market designs studying complexity clearing markets goods sale identical bidders may different bidding languages supply demand curves 
studying selective bid elicitation combinatorial auctions designing optimal bidding agents may know valuations bundles ex ante compute 
acknowledgment kate larson significantly contributed proof proposition 
anonymous reviewers helpful comments 
martin andersson tuomas sandholm 
contract type sequencing negotiation 
proceedings twentieth international conference distributed computing systems taipei taiwan april 
martin andersson tuomas sandholm 
leveled commitment con myopic individually rational agents 
proceedings third international conference multi agent systems icmas pages paris france july 
martin andersson tuomas sandholm 
time quality tradeoffs negotiation combinatorial contract types 
proceed ings national conference artificial intelligence aaai pages orlando fl 
martin andersson tuomas sandholm 
leveled commitment con tracts myopic strategic agents 
journal economic dynamics control 
special issue agent computational economics 
early version national conference artificial intelligence aaai madison wi 
craig boutilier moises goldszmidt 
sequential auc tions allocation resources complementarities 
proceedings sixteenth international joint conference artificial intelligence ijcai pages stockholm sweden august 
chandra 
greedy local search weighted set packing approximation 
loth annual siam acm sym discrete algorithms soda pages january 
clarke 
multipart pricing public goods 
public choice 

advanced combinatorics 
reidel pub 

wolfram tuomas sandholm 
minimal preference elicitation combinatorial auctions 
ijcai workshop economic agents models mechanisms pages seattle wa august 
wolfram tuomas sandholm 
preference elicitation com auctions extended 
proceedings acm conference electronic commerce acm ec tampa fl october 
william cook william cunningham william pulleyblank alexander schrijver 
combinatorial optimization 
john wiley sons 
thomas cormen charles leiserson ronald rivest 
algorithms 
mit press 
sven de vries rakesh vohra 
combinatorial auctions survey 
draft august th 
ledyard porter 
new improved design multi object iterative auctions 
technical report california institute technology social science november 
kevin leyton brown yoav shoham 
taming computational complexity combinatorial auctions optimal approximate approaches 
proceedings sixteenth international joint conference artificial intelligence ijcai pages stockholm sweden august 
garfinkel nemhauser 
set partitioning problem set cover ing equality constraints 
operations research 
theodore groves 
incentives teams 
econometrica 

approximations independent sets graphs 
jansen editors international workshop approximation algorithms combinatorial optimization problems approx pages aalborg denmark july 
springer lncs 

approximations weighted independent set hereditary subset problems 
journal graph algorithms ap plications 
early versions appeared computing combinatorics proceedings th annual international conference cocoon tokyo japan lecture notes computer science vol 
springer berlin pp 

jan jan arne 
independent sets domination constraints 
discrete applied mathematics 
appeared proceedings th international confer ence automata languages programming icalp aalborg denmark july 
springer lecture notes computer science 
lau 
low degree graph partitioning local search applications constraint satisfaction max cut coloring 
journal graph algorithms applications 
johan hastad 
clique hard approximate 
acta math 

multi object auctions sequential vs simultaneous sales 
management science 
hochbaum 
efficient bounds stable set vertex cover set packing problems 
discrete applied mathematics 
hochbaum 
approximation algorithms np hard problems 
pws publishing 
karp 
reducibility combinatorial problems 
raymond miller james thatcher editors complexity computer computations pages 
plenum press ny 
frank kelly richard steinberg 
combinatorial auction multi ple winners universal services 
management science april 
richard korf 
depth iterative deepening optimal admissible tree search 
artificial intelligence 
kate larson tuomas sandholm 
computationally limited agents auctions 
agents workshop agents pages montreal canada may 
kate larson tuomas sandholm 
costly valuation computation auctions deliberation equilibrium 
theoretical aspects reasoning knowledge tark pages siena italy july 
john ledyard 
personal communications national science foundation workshop research priorities electronic commerce 
austin tx september th 
daniel lehmann ira callaghan yoav shoham 
truth revelation rapid approximately efficient combinatorial auctions 
proceedings cm conference electronic commerce pages denver november 

algorithm maximum internally stable set weighted graph 
intern 
computer math 
preston mcafee john mcmillan 
analyzing auction 
journal economic perspectives 
john mcmillan 
selling spectrum rights 
journal economic tives 
paul milgrom 
putting auction theory simultaneous ascending auction 
technical report stanford university department economics 
revised 
noam nisan 
bidding allocation combinatorial auctions 
pro ceedings acm conference electronic commerce acm ec pages minneapolis mn 
christos papadimitriou 
computational complexity 
addison wesley 
panos pardalos desai 
algorithm finding maximum weighted independent set arbitrary graph 
intern 
computer math 
smith 
combinatorial auction mechanism airport time slot allocation 
bell economics 
alexander volker 
aida asynchronous parallel ida 
loth canadian conf 
ai pages banff canada 
michael rothkopf ronald 
computationally manageable combinatorial auctions 
management science 
tuomas sandholm 
strategy decreasing total transportation costs area distributed transportation centers 
nordic opera tions analysis cooperation business turku school economics finland 
tuomas sandholm 
implementation contract net protocol marginal cost calculations 
proceedings national con ference artificial intelligence aaai pages washington july 
tuomas sandholm 
negotiation self interested computationally limited agents 
phd thesis university massachusetts amherst 
available www cs cmu edu sandholm tion ps 
tuomas 
sandholm 
contract types satisficing task allocation theoretical results 
aaai spring symposium series satisficing models pages stanford university ca march 
tuomas sandholm 
generation electronic commerce server 
proceedings fourth international conference au agents agents pages barcelona spain june 
early version appeared aaai workshop ai electronic commerce orlando fl pp 
july washington university st louis dept computer science technical report wucs jan 
tuomas sandholm 
issues computational vickrey auctions 
international journal electronic commerce 
special issue applying intelligent agents electronic commerce 
short early version appeared second international conference multi agent systems icmas pages 
tuomas sandholm kate larson martin andersson onn shehory fernando coalition structure generation worst case guarantees 
artificial intelligence 
early version appeared national conference artificial intelligence aaai pages 
tuomas sandholm victor lesser 
issues automated negotiation electronic commerce extending contract net framework 
proceedings international conference multi agent systems icmas pages san francisco ca june 
reprinted readings agents huhns singh eds pp 

tuomas sandholm victor lesser 
leveled commitment contracts strategic breach 
games economic behavior 
special issue ai economics 
short early version appeared advantages leveled commitment contracting protocol pro ceedings national conference artificial intelligence aaai pp 
portland 
extended version university massachusetts amherst computer science department technical report 
tuomas sandholm sandeep 
algorithms optimizing leveled commitment contracts 
proceedings international joint conference artificial intelligence ijcai pages stockholm sweden 
extended version washington university department computer science technical report wucs 
tuomas sandholm subhash suri 
improved algorithms optimal winner determination combinatorial auctions generalizations 
proceedings national conference artificial intelli gence aaai pages austin tx 
tuomas sandholm subhash suri 
market 
proceedings seventeenth international joint conference artificial intelli gence ijcai pages seattle wa 
tuomas sandholm subhash suri 
side constraints non price attributes markets 
ijcai workshop distributed constraint reasoning pages seattle wa 
tuomas sandholm subhash suri andrew david levine 
cabob fast optimal algorithm combinatorial auctions 
proceedings seventeenth international joint conference artificial intelligence ijcai pages seattle wa 
tuomas sandholm subhash suri andrew david levine 
winner determination combinatorial auction generalizations 
agents workshop agent approaches pages montreal canada may 
vickrey 
counterspeculation auctions competitive sealed tenders 
journal finance 
wireless telecommunications bureau federal communications commission 
wireless telecommunications action wt september 
laurence wolsey 
integer programming 
john wiley sons 
peter wurman michael wellman william walsh 
michigan internet auctionbot configurable auction server human software agents 
proceedings second international conference autonomous agents agents pages minneapolis st paul mn may 
proof proposition proof 
prove number exhaustive partitions 
items auction 
set locations combinations items form combination location 
number locations state locations candidate exhaustive partition 
allows exhaustive partition form exhaustive partition combinations 
say items get placed locations item time 
item placed different locations items place 
number candidates tm 
number exhaustive partitions mm 
number candidates ra overestimates number exhaustive partitions 
exhaustive partitions counted multiple times combination exhaustive partition exhaustive partition counted location combination form counted 
remains proven number exhaustive partitions mm 
lemma proof 
lemma positive integers 
rq 
proof 

way count number exhaustive partitions bell numbers 
bell number tim equal number exhaustive partitions generated items 
ways calculating bell numbers including formula tm ei 
show number exhaustive partitions suffices show lim term series formula positive suffices take term show lim ram cx mo set constant 
expression interested re calculate re lira oc natural logarithm exponential functions continuous calculate limit follows 
lnm mb lnm lim oo bm lime mo lim nm mo lira lira nm shown 
proof proposition proof 
proof term tree mean tree leaves depth nodes children 
number leaves tree number binary nodes nodes children 
rest nodes unary nodes child 
claim worst case case largest number edges constructed having binary nodes close root possible 
specifically depths log tree consist binary nodes remaining binary nodes depth logn 
call tree wide early tree 
left illustrates wide early tree power binary nodes depth log 
wide differ binary nodes distributed depth log number edges 
assume contradict claim tree leaves depth log log wide early edges log log wide late depth edges left wide early tree 
right wide late tree 
binary nodes rest nodes unary larger number edges wide early tree 
wide early unary node depth say loss generality right child empty binary node depth tree 
right child consist path new edges followed right subtree 
right child empty 
resulting tree leaves depth nodes binary rest unary tree larger number edges contradiction 
proves wide early tree worst case 
remains proven number edges wide early tree leaves depth node children 
case power left 
case complete binary tree top tree 
number leaves binary tree number nodes complete binary tree twice number leaves minus case 
number edges tree number nodes minus case 
binary tree branches length log amounting 
log edges 
total number edges 
log nm log 
original tree tree transformation depth transformation proof 
case power 
case top part tree complete binary tree 
leaves 
number nodes complete binary tree twice number leaves minus case 
number edges tree number nodes minus case 
middle part includes unary binary nodes 
leaves entire tree nodes middle part unary middle part exactly leaves 
depth middle part number edges equals number leaves edges middle part 
bottom part includes branches length log nj amounting 
edges 
total number edges tree logn nm logn lgn 
note power collapses number edges case 
case covers case special case 
edge counts exact bound proposition tight 
remains proven asymptotic complexity 
nm log nj log nj 
logn wide early power bottom nj depth edges wide early tree power 
analysis splits case relative magnitude case logn case logn logn 
log 
case log case 
logn 
