packrat parsing practical linear time algorithm backtracking bryan ford submitted department electrical engineering computer science partial fulfillment requirements degree master science computer science engineering massachusetts institute technology september massachusetts institute technology 
rights reserved 
author 
department electrical engineering computer science september certified 
frans kaashoek professor computer science engineering thesis supervisor accepted 
arthur smith chairman department committee graduate students packrat parsing practical linear time algorithm backtracking bryan ford submitted department electrical engineering computer science september partial fulfillment requirements degree master science computer science engineering packrat parsing novel practical method implementing linear time parsers grammars defined top parsing language tdpl 
tdpl originally created formal model top parsers backtracking capability thesis extends tdpl powerful general purpose notation describing language syntax providing compelling alternative traditional context free grammars cfgs 
common syntactic idioms represented concisely cfg easily expressed tdpl longest match disambiguation syntactic predicates making possible describe complete lexical grammatical syntax practical programming language single tdpl grammar 
packrat parsing adaptation year old tabular parsing algorithm put practice 
packrat parser recognize string defined tdpl grammar linear time providing power flexibility backtracking recursive descent parser attendant risk exponential parse time 
packrat parser recognize ll lr language languages requiring unlimited lookahead parsed shift reduce parsers 
packrat parsing provides better composition properties ll lr parsing making suitable dynamic extensible languages 
primary disadvantage packrat parsing storage cost constant multiple total input size proportional nesting depth syntactic constructs appearing input 
monadic combinators lazy evaluation enable elegant direct implementations packrat parsers functional programming languages haskell 
di erent packrat parsers java language demonstrating construction packrat parsers haskell primitive pattern matching monadic combinators automatic generation declarative parser specification 
prototype packrat parser generator developed third case uses packrat parser read parser specifications supports full tdpl notation extended semantic predicates allowing parsing decisions depend semantic values syntactic entities 
experimental results show packrat parsers run reliably linear time ciently support scannerless parsing integrated lexical analysis provide user friendly error handling facilities necessary practical applications 
thesis supervisor frans kaashoek title professor computer science engineering acknowledgments advisor frans kaashoek thoughtful attentive guidance infinite patience 
wish colleagues chuck blake russ cox helpful comments suggestions 
portions appear proceedings international conference functional programming 
contents expressing syntax grammars 
top parsing language tdpl 
packrat parsing 
automatic generation packrat parsers 
thesis overview 
code availability 
top parsing language regular expressions 
context free grammars 
tdpl parsing grammars pgs 
definition parsing grammars 
example parsing grammar 
greedy versus nondeterministic repetition 
parsing complete strings 
left recursion 
expressiveness cfgs versus pgs 
tokens whitespace 
reserved words 
operators variable precedence 
limitations parsing grammars 
packrat parsing building packrat parser 
recursive descent parsing 
backtracking versus prediction 
tabular top parsing 
packrat parsing 
practical extensions algorithm 
left recursion 
integrated lexical analysis 
monadic packrat parsing 
error handling 
packrat parsing state 
general issues limitations packrat parsers 
localized backtracking 
limited state 
space consumption 
packrat parser java 
pappy packrat parser generator haskell parser specification language 
basic lexical elements 
semantic values haskell code blocks 
global structure 
nonterminal definitions 
parsing rules 
sequencing operator 
parser specification reduction validation 
rewriting left recursive definitions 
rewriting iterative rules 
pappy parser specification java 
internal grammar representations transformations 
grammar simplification 
memoization analysis virtual inlining 
code generation 
experimental results parsers 
space ciency 
parsing performance 
related tdpl background 
ts tdpl formal system 
gts gtdpl formal system 
relationship tdpl cfgs 
practical tdpl parsing 
ll lr parsing 
lookahead 
grammar composition 
noncanonical bottom parsing algorithms 
nslr 
bounded context parsable grammars 
noncanonical algorithms 
general cfg parsing algorithms 
tdpl 
packrat parsing 
pappy 
practical experience 

example packrat parsers basic expression parser 
monadic expression parser 
tdpl grammar pappy parser specification language list figures context free grammar trivial arithmetic expression language 
parsing grammar trivial arithmetic expression language 
reading string grammar 
grammar trivial language 
matrix parsing results string 
derivs data structure produced parsing string 
packrat parsing functions left associative addition subtraction 
result type augmented error information 
joining sets error descriptors 
monadic parser combinators error handling 
error annotation combinator 
syntax basic lexical elements pappy parser specifications 
syntax raw haskell code blocks embedded pappy specifications 
global structure pappy parser specification language 
syntax nonterminal definitions pappy 
syntax parsing rules pappy 
syntax pappy sequencing operator 
header portion pappy parser specification java 
parsing rules java whitespace comments 
parsing rules java keywords identifiers 
parsing rules java symbols 
parsing rules java type expressions 
parsing rules java expressions 
maximum heap size versus input size 
execution time versus input size 
rules rewriting extended tdpl definitions formal ts tdpl 
rules rewriting formal ts tdpl extended tdpl syntactic predicates formal gts gtdpl 
chapter practically languages common today human readable machine readable founded idea expressing information linear form sequences written marks symbols 
text written language usually represented electronically string sequence characters chosen standardized character set 
character set may vary language locale ascii versus unicode details normal writing direction conventions expressing relevant formatting information whitespace line breaks method expressing composite symbols accented letters 
regardless details task language processing application analyze flat strings characters meaningful higher level groupings words phrases sentences expressions statements 
task deriving useful high level structural information linear text known syntax analysis parsing 
expressing syntax grammars order create parser particular language just reason formally kinds strings meaningful formed language way expressing understanding language syntactic structure 
purpose commonly grammar concise representation structure language expressed ideally small simple language 
language structure grammar intended represent language talking known object language language grammar expressed known grammar definition language 
able express syntactic structure language concisely grammar especially important programming languages languages expressly designed precision machine readability grammars reason properties language mathematically help mechanical tools 
common type grammar today context free grammar cfg typically expressed ubiquitous backus naur form bnf 
context free grammar essentially specifies set mutually recursive rules describe strings described language may written 
rule production cfg specifies way syntactic variable nonterminal expanded string 
nonterminal may expand string containing nonterminals expanded turn nonterminals remain 
multiple ways expand particular nonterminal grammar express infinite set strings having defined hierarchical structure 
parsing string syntax specified cfg involves reversing process determining fully expanded string containing atomic characters terminals sequence sequences expansion steps produce string 
task complicated fact cfgs contain ambiguities local ambiguities correct interpretation portion string determined context appears global ambiguities string may multiple valid syntactic interpretations 
top parsing language tdpl method expressing syntax formally set rules describing strings language read written 
top parsing language tdpl formal scheme describing language syntax shares close relationship top recursive descent parsing 
tdpl developed time classic cfg parsing algorithms invented time formal model study certain top parsing algorithms 
contribution thesis develop tdpl practical syntactic notation right demonstrate advantages expressiveness tdpl cfg paradigm 
machine readable languages today easier express tdpl pure cfg particularly tdpl natural support pervasive longest match disambiguation policy common localized disambiguation rules 
low level lexical high level grammatical syntax language expressed single unified tdpl grammar cfg paradigm levels syntax usually considered separately 
lexical analysis separated grammatical analysis cfg specifications practical languages include supplemental rules describing certain ambiguities cfg resolved 
usually supplemental rules described informally behavior specific parsing algorithm bottom shift reduce parser expected parse language 
tdpl paradigm rules fit cleanly basic syntactic notation require special extensions 
packrat parsing simplest method parsing string tdpl grammar topdown recursive descent parser backtracking capability 
observation come surprise tdpl created place formalization parsers 
unfortunately tdpl grammars ordinary recursive descent parser take exponential runtime parse input strings 
reason blow backtracking recursive descent parser may redundantly compute intermediate results multiple times 
memoization prevent redundant computation tdpl grammar parsed linear time proportional size input string 
theoretical existence linear time tdpl parsing algorithm previously known apparently viewed impractical implemented involves storing large table intermediate results grows proportion length input string 
furthermore nave approach construction table compute results needed single result computed 
modern machines storage cost memoization table longer serious problem typical problem sizes lazy evaluation techniques possible avoid computing results needed 
second main contribution thesis packrat parsing version tabular linear time tdpl parsing algorithm refined practical 
packrat parsing particularly suited implementation modern lazy functional programming languages haskell packrat parsing course implemented languages 
lazy functional language packrat parsing requires ordinary algebraic data types explicit hash tables costly lookup structures 
packrat parser implemented way identical style structure conventional recursive descent parser backtracking packrat parser essentially just uses di erent method tie mutually recursive calls functions comprising parser provide memoization necessary ensure parsing linear time 
automatic generation packrat parsers packrat parsing simple implement hand particularly lazy functional language constructing packrat parsers easier help automatic parser generator lines yacc world happy haskell world 
third major contribution thesis pappy prototype packrat parser generator takes declarative parser specifications generates packrat parsers haskell 
parser specification language accepted pappy tdpl notation developed thesis extensions allow parser compute semantic values syntax trees input string parsed 
tradition parser generators semantic values computed help code fragments implementation language haskell embedded parser specification 
pappy extends tdpl notation support semantic predicates parsing decisions depend semantic values just success failure syntactic rule 
example semantic predicates syntactic character classes expressed terms haskell functions requiring specialized notation 
thesis overview rest thesis organized chapters chapter briefly reviews common syntax notation schemes regular expressions context free grammars presents tdpl notation system thesis explores expressiveness comparison cfg notation 
chapter introduces packrat parsing algorithm demonstrates implementation packrat parsers haskell series examples 
chapter presents extended techniques integrated lexical analysis packrat parsing monadic combinators user friendly error handling 
chapter presents pappy prototype packrat parser generator 
chapter describes tdpl specification language accepted pappy details operation grammar transformations performs order produce cient parsers 
chapter describes experimental results measuring storage cost performance hand implemented automatically generated packrat parsers java programming language 
chapter details relevant prior 
chapter begins reviewing origins background tdpl provides detailed informal comparisons packrat parsing algorithms ll lr noncanonical lr generalized cfg parsing 
chapter concludes points possible directions 
code availability complete versions examples library code described thesis pappy packrat parser generator web site pdos lcs mit edu packrat thesis java trademark sun microsystems chapter top parsing language common methods describing language syntax today regular expressions context free grammars 
formalisms means ways precisely specifying syntactic structure language 
useful syntax description paradigm known top parsing language tdpl bears close relationship context free grammars fundamental di erences 
provide flavor relationship paradigms context free grammar geared writing text specified language high level structured information tdpl grammar geared reading text strings deriving structured information name parsing language 
description languages intended written humans read machines tdpl suitable specification tool context free grammar 
common syntactic idioms practical programming languages longest match rules easily naturally expressed tdpl 
addition tdpl grammars parsed linear time packrat parsing algorithm described subsequent chapters restricted subclasses cfgs parsed linear time 
rest chapter consists brief review regular expressions context free grammars followed depth exploration tdpl paradigm comparison expressive power comparison conventional cfg notation 
regular expressions regular expressions provide way specifying simple languages structure may involve sequencing choice repetition recursive syntactic constructs 
regular expression built rules empty string regular expression denoting empty string 
formal descriptions empty string denoted 
literal single character regular expression denoting corresponding single character string 
sequence regular expressions 
regular expression denoting strings constructed concatenating strings substring matches second substring matches choice regular expressions regular expression denoting strings match 
repetition regular expression regular expression denoting strings constructed concatenating number substrings substring matches regular expression practical regular expression languages typically precedence rules dispense unnecessary parentheses convenience usually support additional operators implemented terms primitives optional regular expression regular expression denoting empty string addition strings matching equivalent 
regular expression regular expression denoting strings constructed concatenating substrings matches equivalent ee 
regular expression essentially provides simple concise rules writing strings language denoted regular expression 
example regular expression shorthand recipe generating strings consisting followed number 
process subexpression generating single character 

process subexpression decide repetitions subexpression generate 
individual repetition choose alternative subexpressions generate ii 
alternative chosen generate single character 
second alternative chosen generate single character 
strings trivial language intended convey useful information kind various choices recipe determined content transmitted 
example versus choices intended transmit bit binary number number repetitions decided step determined number bits binary number 
important point structure regular expressions defined fundamentally terms strings produced recognized read 
priori guarantee strings produced regular expression unambiguous readable general 
example regular expression perfectly legitimate information may direct choice repetition operators lost generated string expression ultimately yield single string 
recognizing strings defined regular expressions nearly straightforward generating strings recognition problem di cult done linear time proportional length input string 
relevant algorithms compiler textbook 
conciseness 
context free grammar trivial arithmetic expression language simplicity ciency regular expressions de facto basis generic searching text manipulation tools kinds defining lexical stage conventional language processors 
issues ambiguity information preservation usually considered highly important regular expression processing practice regular expressions primarily merely find identify strings matching pattern subsequent manual automatic processing methods extract information strings directly 
context free grammars important limitation regular expressions express recursive syntactic constructs 
syntax practical languages inherently involves recursive rules expressions expression expression statements statement 
informal definition regular expressions uses rules regular expressions powerful express syntax ectively 
context free grammar cfg solves problem representing syntax single rule set rules refer recursively 
classes symbols utilized cfg terminals represent atomic syntactic elements correspond literal characters regular expressions nonterminals represent higher level composite constructs expressions statements 
common practical representation context free grammars known backus naur form bnf rule form 
nonterminal symbol rule defines right hand side string consisting number terminals nonterminals 
rule represents alternative syntactic expansion derivation nonterminal left 
significance attached order multiple alternatives appear rule order rules appear grammar 
regular expressions context free grammar essentially provides recipe writing strings language expressed grammar 
example shows context free grammar trivial expression language featuring addition subtraction decimal numbers 
grammar uses nonterminal symbols represents expressions represents decimal numbers consisting digits represents individual decimal digits 
want generate expression grammar gives choices write number rule write string form expression strings likewise generated rule 
similarly generate number choices just write single digit base case prepend digit number generated rule 
bnf notation extended practice repetition operators repetition usually considered primitive context free grammars easily expressed terms recursion demonstrated nonterminal example grammar 
regular expressions ambiguity information preservation issues context free grammars 
ambiguity important problem practice cfgs regular expressions primary goal usually just recognize string conforms particular cfg parse string ectively reconstructing full set decisions generate string cfg 
recognizing parsing cfgs harder problem recognizing regular expressions 
parsing arbitrary cfgs equivalent complexity boolean matrix multiplication generally believed lie 
fastest known algorithm recognize arbitrary unambiguous cfgs question arbitrary cfg unambiguous undecidable general 
various linear time algorithms exist recognize useful restrictive classes cfgs 
top predictive parsing algorithms start high level syntactic constructs goals break progressively smaller subgoals recognizing string bottom shift reduce algorithms start atomic units terminals string progressively clump reduce higher level constructs nonterminals 
algorithms explored contrasted packrat parsing chapter 
tdpl parsing grammars pgs di erent equally legitimate approach expressing language syntax represent set rules writing strings language set rules reading 
top parsing language tdpl notation express grammars way 
name implies tdpl geared top style parsing seen simple programming language writing top parsers 
grammar tdpl similar parsing oriented notation referred top parsing grammar just parsing grammar pg short 
definition parsing grammars cfgs parsing grammar terminal nonterminal symbols consists set rules provide definitions nonterminal 
rule refer rules grammar recursively 
parsing grammar definitions notation nonterminal parsing expression defined 
left arrow right arrow expresses conceptual di erence natural information flow pg cfg 
rules cfg directly represent expansions nonterminals right hand side strings rules pg directly represent reductions right hand side parsing expressions nonterminals 
furthermore expansions expressed cfg represent operations strings reductions expressed tdpl grammar represent operations prefixes input string 
example cfg rule read produce string matching nonterminal generate string matching string matching concatenate form result 
interpretation similar looking pg rule quite di erent read instance nonterminal string look instance nonterminal followed instance nonterminal possibly followed additional unrecognized input 
succeed consume corresponding portion input string 
fail consume 
subtle important di erence interpretations elaborated 
tdpl notation thesis parsing expressions constructed follows empty string parsing expression denoting empty string 
interpretation don try read just trivially succeed consuming input 
terminal terminal symbol single character parsing expression interpretation input terminal consume terminal succeed 
fail consuming 
nonterminal nonterminal symbol parsing expression interpretation try read input grammar rule nonterminal succeed fail accordingly 
sequence parsing expressions 
parsing expression interpretation follows try read string matching succeeds try read string matching starting remaining input text left succeeds continue expressions successfully recognized consecutively succeed consume corresponding input text 
sub expression fails sequence fails consuming text 
ordered choice parsing expressions 
parsing expression interpretation follows try read string matching succeeds choice expression succeeds consumes corresponding input text 
try original input text order stopping matching alternative 
alternatives match fail consuming text 
parsing expression read forward slash symbol denote choice tdpl place vertical bar symbol cfgs order emphasize critical di erence choice cfg symmetric order important choice tdpl asymmetric implies priority relationship 
greedy repetition parsing expression parsing expression interpretation apply expression repeatedly input text consuming input text progressively iteration long continues succeed 
failure consume successfully matched text succeed 
match succeed anyway consume 
greedy positive repetition parsing expression parsing expression interpretation apply expression repeatedly succeed consume matched text long instance recognized 
fail consuming 

parsing grammar trivial arithmetic expression language optional parsing expression parsing expression interpretation try apply expression input 
succeeds consume matched text succeed 
fails succeed anyway consume input 
followed predicate parsing expression parsing expression interpretation try apply expression input 
matches succeed consume input back original position applied 
fails fail 
followed predicate parsing expression parsing expression interpretation try apply expression input 
matches fail consuming input 
fails succeed consuming input 
despite richness vocabulary tdpl constructs defined easily reduced small kernel primitive constructs 
appropriate choice primitives depends intended language formal analysis versus practical parser implementation issue dealt 
example parsing grammar shows parsing grammar trivial arithmetic expression language cfg represents 
structure essentially order alternatives construct di erence important explained shortly 
shows illustration string read parsing grammar 
start trying read expression starting string 
alternative try alternatives succession position matches character opening parenthesis digit 
try second alternative rule addition expressions 
rule successfully matches opening parenthesis directs read sub expression starting position 
read sub expression try alternative 
case alternative successfully matches digit position recursively looks second instance position 
alternative second instance fails digit position followed digits second alternative succeeds matching digit producing result labeled 
success result enables earlier attempt expressions numbers position digits input string reading string grammar read starting position succeed yielding character wide instance position labeled result turn leads corresponding character expression returning attempt read expression position second alternative fails expression followed input 
subsequently attempting third alternative alternative succeeds matches opening parenthesis way alternative continues match single digit expression position closing parenthesis 
expression generated matches entire input string 
greedy versus nondeterministic repetition rule nonterminal illustrates important di erences parsing grammar context free grammar 
cfg order alternatives unimportant choice nondeterministic oriented writing strings reading 
pg order alternatives critical attempted shorter alternative longer pg alternative succeed 
resulting grammar able read example input string reading nonterminal position consume number leaving subsequent attempts parse larger expression starting position 
di erence repetition constructs parsing grammar naturally greedy nondeterministic repetitive construct default consumes text regardless context 
nonterminal example parsing grammar eliminated replacing alternative result exactly operator parsing grammar known greedy positive repetition 
practice greedy repetition want dealing languages intended unambiguous machine readable 
easy create cal examples context free grammars unambiguous depend nondeterministic choice cfg converted directly pg obvious way reversing arrows changing resulting grammar match string 
nonterminal pg consume consecutive cause subsequent attempt match trailing fail 
pathological cases usually pg written achieve desired ect 
example pg equivalent cfg followed operator alternative ensures exactly left text matched able succeed 
parsing complete strings grammar read string xyz starting nonterminal result success part string read leaving xyz remainder 
intention read input string known length usually desirable parsing process succeed entire input accepted just part 
fortunately behavior easy accomplish adding special start symbol follows 
single character start symbol looks expression uses followed operator ensure follows recognized expression input 
text match causing fail fails succeeds 
example nonterminal representing character class 
long character set finite nonterminals representing character classes theory written directly list individual alternatives 
particularly shift ascii bit relatives unicode usually easier consider character classes primitive 
specialized character classes typically include letters digits whitespace characters control characters punctuation symbols 
left recursion context free grammar left recursion right recursion allowed 
nonterminal expanded times yield string starting nonterminal 
similarly right recursive nonterminal expand string nonterminal 
example typical express syntax left associative operators terms left recursive cfg definitions right associative operators terms right recursive definitions unary unary unary primary additive additive unary additive unary unary right recursive definition unary symbols serve right associative unary operators sign flags standard interpretation 
right recursive self unary definition allows multiple unary operators precede primary expression 
example primary expression string unary expression containing nested unary expression contrast definition additive left recursive result successive expansions nonterminal build right leading unary expression 
example unary expressions naturally interpreted binary expression left hand operand nested binary expression 
tdpl right recursion works way cfg left recursive definition considered erroneous interpretation tdpl rules leads degenerate self 
example changing definition additive directly tdpl definition obvious way lead interpretation read additive expression try read additive expression followed 
way read additive expression doing require having read additive expression starting position 
recursive nonterminals tdpl function properly progress rightwards input string recursive invocation nonterminal 
example definition unary converted directly valid right recursive tdpl definition interpretation follows read unary expression try read sign read unary expression sign 
cfg left recursion convenient essential expression language syntax cfg involving left recursion rewritten cfg representing language left recursion 
tdpl usually convenient concise repetition operators left right recursion 
example cfg written tdpl follows unary primary additive unary unary expressiveness cfgs versus pgs purpose expressing languages intended unambiguous machinereadable parsing grammars powerful convenient cfgs practice 
part expressiveness arises tdpl natural support reading text longest match greedy policy pervasively practical languages 
important part expressiveness provided operators demonstrated 
operators represent syntactic predicates allow arbitrary syntactic patterns direct decisions consuming input text 
subsections provide practical examples expressive power pgs comparison cfgs 
tokens whitespace programming languages lowest level syntax apart atomic characters level tokens 
token corresponds string directly consecutive characters word decimal number 
tokens may separated whitespace characters spaces tabs newlines whitespace padding appears token 
tokens separated whitespace characters order readable 
example consecutive words bar fly separated whitespace character order distinguishable single word 
despite apparent simplicity standard tokenization rules di cult express pure context free grammar 
reason cfgs usually express language syntax character level token level 
converting strings characters strings tokens usually left separate preprocessing phase parsing known lexical analysis 
di culty primary historical reason atomic symbols context free grammar referred tokens terminals characters 
consider simple expression language expression identifier parenthesized sequence consecutive expressions 
identifiers ident parentheses open close assumed atomic terminals produced separate lexical analysis phase language easily expressed cfg expr ident open exprs close exprs empty expr exprs suppose want express tokenization directly cfg 
standard rules identifiers contain parentheses whitespace padding optional parentheses parenthesis identifier 
consecutive identifiers separated whitespace character 
express tokenization rules original expression grammar unfolded way contexts distinguished 
example way grammar rewritten expr identifier exprs exprs empty exprs exprs identifier identifier spaces identifier letter letter identifier empty spaces spaces space space spaces example letter space assumed denote character classes representing identifier letters whitespace characters respectively 
order isolate case identifiers appear consecutively exprs nonterminal factored nonterminals empty expression lists expression lists starting parenthesized subexpression expression lists starting identifier 
rule whitespace mandatory identifier nested tail optional identifier tail 
unfolding tokenization rules expressed implicitly cumbersome way uses spaces nonterminals sprinkled grammar 
furthermore process unfolding grammar simplicity elegance clarity original grammar obscured considerably 
language marginally complex expressing tokenization rules implicitly way quickly impractical 
contrast natural longest match repetition tokenization easily expressed natural modular fashion parsing grammar 
pg expression language integrated tokenization expr identifier open expr close identifier letter space open space close space identifier nonterminal example simple natural informal interpretation parse identifier read consecutive letters possible ensuring followed consecutive space characters possible 
implicit longest match policy directly yields desired behavior 
rules number kinds tokens expressed similarly 
reserved words possibility expressing syntax conventional programming language top context free grammar remote language includes reserved words programming languages 
reserved word syntactic construct takes basic form identifier typically consisting fixed sequence consecutive letters serves completely di erent purpose higher level syntax 
reserved words generally serve syntactic markers introduce delineate specific kinds statements definitions programming language constructs 
order serve syntactic markers reliably usually critical mistaken identifiers 
nonterminal syntax representing identifiers match reserved words reserved words reserved syntactically space identifiers 
unfortunately pure cfg provides direct way express notion want nonterminal identifier represent strings large class specific strings 
definition identifier unfolded feel edges set reserved words 
example language single reserved word foo cfg rules recognizing tokens written follows foo foo identifier letter empty letter letter letter approach obviously cumbersome practical especially number reserved words increases 
contrast reserved words easy express parsing grammar syntactic predicate operator 
example parsing grammar rules express tokenization identifiers reserved words including handling trailing whitespace identifier letter space 
letter space letter space letter space letter space 
definition identifier read follows read identifier check position fail 
read letters followed number spaces 
reserved word corresponding nonterminal named capitals historical convention 
nonterminal reserved word matches appropriate string checks word followed letters recognized sequence part longer identifier consumes whitespace padding reserved word 
operators variable precedence examples focused tokenization issues parsing grammars convenient cfgs expressing practical higher level language constructs 
example languages classic ambiguity relating statement allows optional clause statement expression statement expression statement statement 
reading statement form cfg leaves undecided final part statement associated outer inner 
haskell language includes severe examples kind ambiguity lambda operators high precedence accept low precedence expression tail unguarded syntactic marker indicate tail exp low precedence expressions 
exp 
exp 
exp exp exp exp high precedence expressions cfg specify string form 
interpreted 


essentially practical situations kind desired behavior dangling tail bind innermost possible construct 
example dangling example resolved haskell example resolved 

rule intuitive sense innermost construct closest dangling tail probably programmer thinking dangling tail written 
innermost binding rule cause occasional confusion practice accepted provide substantial notational flexibility 
disambiguation rule just higher level variant longest match policy needed parse tokens whitespace ectively reason policy extremely natural pg 
examples converted directly pg obvious way yield desired behavior 
earlier dangling case possible rewrite original cfg resolve ambiguity innermost binding rule unfolding duplicating statement nonterminal 
haskell case number operators contributing ambiguity large di erence precedences relevant operators precedences tail expressions prospect disambiguating cfg way practice 
result haskell specification specifications programming languages similar situations simply provide ambiguous cfg informal side note specifying parser language resolve ambiguity 
essence language specification stepping gap cfg paradigm describing phrases written tdpl paradigm describing phrases read 
frequency gap crossed practice taken compelling argument starting tdpl side place 
limitations parsing grammars primary limitation tdpl notation parsing grammars express ambiguous syntax need 
expressing natural languages example ambiguity fact life context free grammars clearly appropriate enable parser enumerate possible ways reading string 
natural language usually simple purely local syntactic rules innermost binding rule resolve various ambiguities consistently 
language recognizer rely global syntactic structure semantics readings sense 
attention restricted unambiguous context free grammars pathological cfgs appear pg recognizing language pathologies sort occur practical programming languages designed legible humans machines 
argued specifying grammars cfgs useful automatic tools check grammar unintended ambiguities 
checking grammars way worthwhile goal current practice undermined practical problems 
undecidable arbitrary cfg unambiguous tools best check grammar conservative class grammars known safe lalr 
second grammars useful programming languages intended ambiguities unintended ones easily overlooked warnings 
best lucky notice number shift reduce conflicts reported parser generator increased compile 
possible extend tdpl notation unordered choice operator expresses intention alternatives supposed unambiguously di erentiable non overlapping 
claim checked automatically methods similar tools cfgs reduced simple ordered choice claim verified 
approach notable benefit allowing ordered choice operator parts grammar ambiguity expected desire resolve explicit priority relationship 
unordered choice operator interpretation easy add tdpl appropriate algorithms check overlap alternatives pg obvious extension left 
chapter packrat parsing chapter address problem ciently parsing strings syntax specified tdpl 
programming language haskell implementation language currently popular established non strict functional programming languages 
shall see lazy evaluation capabilities nonstrict languages haskell implementation packrat parsers direct elegant 
course reason packrat parser implemented languages doing merely slightly straightforward need hand code lazy evaluation functionality haskell provides part language 
section chapter describe basic principles packrat parsing algorithm creating backtracking recursive descent trivial language converting parser packrat parser 
second section useful extensions basic parser demonstrate practical methods handling left recursion integrated lexical analysis constructing parsers monadic combinators user friendly error handling 
third section explores practical issues limitations packrat parsers localized backtracking limited state high space consumption 
building packrat parser packrat parsing essentially top parsing strategy packrat parsers closely related recursive descent parsers 
reason build recursive descent parser trivial language convert packrat parser 
additive multitive additive multitive multitive primary multitive primary primary additive decimal decimal 
grammar trivial language recursive descent parsing consider tdpl grammar shown trivial arithmetic expression language 
grammar viewed direct short hand representation parser backtracking 
construct recursive descent parser grammar define functions nonterminals grammar 
function takes takes string parsed attempts recognize prefix input string derivation corresponding nonterminal returns success failure result 
success function returns remainder input string immediately part recognized semantic value computed recognized part 
function recursively call functions order recognize nonterminals appearing right hand sides corresponding grammar rules 
purpose practical parser usually just recognize string derive meaningful semantic information structure example parser developed act simple calculator computing integer value arithmetic expression recognizes 
implement recursive descent parser haskell need type describing result parsing function data result parsed string noparse order type generic di erent parsing functions producing di erent kinds semantic values result type takes type parameter representing type associated semantic value 
success result built parsed constructor contains semantic value type remainder input text type string 
failure result represented simple value noparse 
particular parser parsing functions takes string produces result semantic value type int padditive string result int pmultitive string result int pprimary string result int string result int definitions functions general structure directly reflecting mutual recursion expressed grammar padditive 
calls pmultitive pmultitive 
calls pprimary pprimary 
calls padditive 
example padditive function coded follows primitive haskell pattern matching constructs parse additive precedence expression padditive string result int padditive alt additive alt case pmultitive parsed case case padditive parsed parsed alt alt alt additive alt case pmultitive parsed parsed noparse noparse compute result padditive compute value alt representing alternative grammar rule 
alternative turn calls pmultitive recognize multiplicative precedence expression 
pmultitive succeeds returns semantic value expression remaining input recognized portion input 
check operator position successful produces string representing remaining input operator 
recursively call padditive recognize additive precedence expression position successful yields right hand side result final remainder string 
matches successful return result initial call padditive semantic value addition final remainder string 
matches failed fall back alt second alternative merely attempts recognize single multiplicative precedence expression original input position returns result verbatim success failure 
parsing functions constructed similarly direct correspondence grammar 
course easier concise ways write parsing functions appropriate library helper functions combinators 
techniques discussed section clarity stick simple pattern matching 
backtracking versus prediction parser developed backtracking parser 
alt padditive function fails example parser ectively backtracks initial position starting original input string second alternative alt regardless alternative failed match second third stage 
input consists single multiplicative expression pmultitive function called twice string alternative fail trying match nonexistent operator successfully applying second alternative 
backtracking redundant evaluation parsing functions lead parse times grow exponentially size input blow principal reason nave backtracking strategy realistic parsers inputs substantial size 
standard strategy making top parsers practical design predict alternative rules apply making recursive calls 
way guaranteed parsing functions called redundantly input parsed linear time 
example grammar directly suitable predictive parser converted tdpl equivalent ll grammar suitable prediction lookahead token left factoring additive multitive nonterminals follows additive multitive additive multitive primary multitive decision alternatives making recursive calls simply checking input character 
prediction mechanism raw input tokens characters case operate constant time restricted class grammars parsed predictively 
care taken keep prediction mechanism consistent grammar di cult manually highly sensitive global properties language 
example prediction mechanism adjusted higher precedence exponentiation operator added language exponentiation operator falsely trigger predictor multiplication expressions cause parser fail valid input 
top parsers prediction decisions fall back full backtracking flexibility needed 
strategy yields combination flexibility performance practice su ers additional complexity prediction requires parser designer intimately aware prediction backtracking required 
tabular top parsing pointed birman ullman backtracking top parser kind section operate linear time added complexity constraints prediction 
basic reason backtracking parser take super linear time redundant calls parsing function input substring redundant calls eliminated memoization 
parsing function example dependent single parameter input string 
parsing function recursive call parsing function supplies input string call padditive pmultitive su original input string recursive call padditive matching operator 
input string length distinct su xes recursive calls counting original input string empty string 
input pprimary pmultitive padditive column matrix parsing results string parsing functions distinct intermediate results parsing process require 
avoid computing intermediate results multiple times storing table 
table row parsing functions column distinct position input string 
fill table results parsing function input position starting right input string working left column column 
column start bottommost cell upwards 
time compute result cell results recursive calls corresponding parsing function computed recorded table merely need look appropriate results 
illustrates partially completed result table input string 
brevity parsed results indicated semantic value column number associated remainder su begins 
columns labeled avoid confusion integer semantic values 
noparse results indicated cell 
cell filled pprimary column indicated circled question mark 
rule primary expressions alternatives parenthesized additive expression decimal digit 
try alternatives order expressed grammar pprimary check parenthesized additive expression 
pprimary attempts match opening column succeeds yields remainder string input su starting column 
simple recursive descent parser pprimary recursively call padditive remainder string 
table simply look result padditive column table 
entry indicates semantic value result addition expression remainder su starting column 
match success pprimary attempts match closing parenthesis position succeeds yields empty string remainder 
result entered pprimary column 
long input string complex grammar result table may large grows proportion size input string 
long computation cell looks limited number previously recorded cells matrix completes constant time parsing process completes linear time 
due forward pointers embedded results table computation result may examine cells widely spaced matrix 
example computing result pprimary results columns 
ability skip ahead arbitrary distances making parsing decisions source algorithm unlimited lookahead capability making algorithm powerful linear time predictive parsers lr parsers 
packrat parsing obvious practical problem tabular right left parsing algorithm computes results needed 
additional inconvenience carefully determine order results particular column computed parsing functions padditive pmultitive depend results column correctly 
packrat parsing essentially lazy version tabular algorithm solves problems 
packrat parser computes results needed order original recursive descent parser 
result computed time stored subsequent calls 
non strict functional programming language haskell provides ideal implementation platform packrat parser 
fact packrat parsing haskell particularly straightforward require arrays explicit lookup structures language ordinary algebraic data types 
types packrat parsing need new type represent single column parsing result matrix call derivs derivations 
type merely tuple component nonterminal grammar 
component type result type corresponding parsing function 
derivs type contains additional component call dvchar represent raw characters input string results parsing function 
derivs type example parser conveniently declared haskell follows data derivs derivs result int result int result int result int dvchar result char haskell syntax declares type derivs single constructor named derivs components specified types 
declaration automatically creates corresponding data accessor function component function type derivs result int extracts component derivs tuple 
modify result type remainder component success result plain string instance derivs data result parsed derivs noparse derivs result types mutually recursive success results derivs instance act links derivs instances 
result values fact provide linkage need di erent columns matrix parsing results 
packrat parsing functions modify original recursive descent parsing functions function takes derivs string parameter padditive derivs result int pmultitive derivs result int pprimary derivs result int derivs result int original parsing functions examined input characters directly new parsing function refers dvchar component derivs object 
original functions recursive call parsing function order match nonterminal grammar new parsing function uses derivs accessor function corresponding nonterminal 
sequences terminals nonterminals matched chains success results multiple derivs instances 
example new padditive function uses dvchar accessors follows making direct recursive calls parse additive precedence expression padditive derivs result int padditive alt additive alt case parsed case dvchar parsed case parsed parsed alt alt alt additive alt recursive tie function create special top level function parse produce instances derivs type tie recursion individual parsing functions create result matrix input string parse string derivs parse derivs add mult prim dec chr add padditive mult pmultitive prim pprimary dec chr case parsed parse noparse magic packrat parser doubly recursive function 
level recursion produced parse function case statement 
relatively conventional form recursion iterate input string character time producing derivs instance input position 
final derivs instance representing empty string assigned dvchar result noparse ectively terminates list columns result matrix 
second level recursion symbol identifier names derivs instance constructed returned parse function parameter individual parsing functions 
parsing functions turn produce rest components forming derivs object 
form data recursion works non strict programming language allows components object accessed parts object available 
derivs instance created function example dvchar component accessed components tuple available 
attempting access component tuple cause invoked turn uses dvchar component require higher level components 
accessing component similarly invoke pprimary may access dvchar 
case pprimary accessing higher level component doing create cyclic dependency case invokes di erent derivs object called position opening parenthesis 
component derivs object produced parse lazily evaluated fashion 
data evaluation packrat parser illustrates data structure produced parser example input text appear memory modern functional evaluator fully reducing cell 
vertical column represents derivs instance result components 
results form parsed semantic value shown appropriate cell arrow representing remainder pointer leading derivs instance matrix 
modern lazy language implementation dvchar derivs data structure produced parsing string properly preserves sharing relationships evaluation arrows diagram literally correspond pointers heap cell structure evaluated twice 
shaded boxes represent cells evaluated case result leftmost column value ultimately needed application 
illustration clear algorithm run time lazy evaluator input string length top level parse function function creates instances derivs type creates exactly instances 
parsing functions access entries structure making direct calls function examines fixed number cells computing result 
lazy evaluator ensures cell evaluated parser critical memoization property necessary guarantee linear parse time evaluates results completely di erent order tabular right left bottom top algorithm earlier 
practical extensions algorithm previous section provided basic principles tools required create packrat parser building parsers real applications involves additional details ected packrat parsing paradigm 
section explore important practical issues incrementally building example packrat parser developed 
examine annoying straightforward problem left recursion 
address issue lexical analysis seamlessly integrating task packrat parser 
explore monadic combinators express packrat parsers concisely 
left recursion limitation packrat parsing inherits tdpl shares top parsing schemes directly support left recursion 
example suppose wanted add subtraction operator example addition subtraction properly left associative 
context free grammar natural approach left recursive rules additive additive multitive additive multitive multitive multitive expressions string correctly interpreted 
described earlier section rule form erroneous tdpl expresses degenerate cycle 
recursive descent parser constructed rule padditive function recursively invoke input provided get infinite cycle recursive function calls 
packrat parser rule padditive attempt access component derivs tuple component supposed compute create circular data dependency 
case parser fails packrat parser failure mode viewed slightly modern lazy evaluators detect circular data dependencies run time detect infinite recursion 
fortunately left recursive context free grammar rewritten equivalent right recursive generally easy construct corresponding tdpl grammar 
desired left associative semantic behavior easily reconstructed higher order functions intermediate parser results 
example additive expressions left associative example parser split definition additive nonterminals additive yielding tdpl definitions additive multitive multitive multitive shows corresponding functions packrat parser defined 
parsing function collects series infix operators right operands builds semantic value function type int int 
higher order function value turn takes argument initial left hand side operand computes result addition subtraction operators right hand side operands represented su padditive function recognizes single multitive expression followed uses higher order function produced modifier perform operations indicated su left hand side value 
alt case function demonstrates implement empty string rules tdpl notation simply return original derivs object remainder parsing 
care taken rules introduce subtle left recursion parser 
example definition foo bar foo left recursive nonterminal bar match empty string 
integrated lexical analysis traditional parsing algorithms usually assume raw input text partially digested separate lexical analyzer stream tokens 
parser treats tokens atomic units may represent multiple consecutive input characters 
separation usually necessary conventional linear time additive padditive derivs result int padditive case parsed vl case parsed parsed vl noparse noparse multitive multitive derivs result int int alt alternative multitive alt case dvchar parsed case parsed vr case parsed parsed vl vl vr alt alt alt alternative multitive alt case dvchar parsed case parsed vr case parsed parsed vl vl vr alt alt alt alternative empty string alt parsed packrat parsing functions left associative addition subtraction parsers primitive terminals lookahead decisions refer higher level nonterminals 
limitation explained section predictive topdown parsers bottom lr parsers depend similar token lookahead mechanism sharing problem 
parser atomic tokens lookahead decisions parsing easier tokens represent keywords identifiers literals raw characters 
packrat parsing su ers lookahead limitation 
packrat parser reflects true backtracking model decisions alternatives parsing function depend complete results produced parsing functions 
reason lexical analysis integrated seamlessly packrat parser special treatment 
implementing tokens extend packrat parser example real lexical analysis add new nonterminals derivs type data derivs derivs expressions result int 
lexical tokens result int int result int result char result raw input dvchar result char parsing function consumes whitespace may separate lexical tokens derivs result case dvchar parsed isspace parsed parsed function illustrates handling longest match disambiguation described earlier section 
complete language function task eating comments space characters 
full expressive power tdpl notation packrat parsing available lexical analysis comments may complex hierarchical structure nesting markups literate programming 
continuing lexical analysis example function recognizes operator tokens consisting operator character followed optional whitespace parse operator followed optional whitespace derivs result char case dvchar parsed elem case parsed parsed noparse noparse noparse tokens high level constructs lexical analysis defined functions modify higher level parsing functions expressions invoke dvchar scan operators parentheses 
example pprimary implemented follows parse primary expression pprimary derivs result int pprimary alt primary alt case parsed case parsed case parsed parsed alt alt alt primary alt function demonstrates parsing decisions depend existence match position nonterminal symbol semantic value associated nonterminal 
case symbol tokens parsed treated uniformly rules pprimary distinguish particular symbols 
sophisticated language operators identifiers reserved words semantic values produced token parsers type string char values matched way 
dependencies syntax semantic values known semantic predicates provide powerful useful capability practice 
syntactic predicates expressed operators tdpl semantic predicates require unlimited lookahead general implemented conventional parsing algorithms giving linear time guarantee 
direct equivalent pprimary function basic tdpl notation basic tdpl express semantic values semantic predicates 
chapter semantic extension tdpl semantic values semantic predicates expressed 
advanced lexical analysis capabilities packrat parser integrated lexical analyzer link lexical highlevel syntax need unidirectional 
high level syntax lexical elements lexical parsing functions potentially refer upwards parsing functions high level syntactic constructs 
example language syntax allow identifiers code fragments embedded comments parser find analyze actual expressions statements making intelligent software engineering tools ective 
similarly escape sequences string literals contain generic expressions representing static dynamic substitutions 
example lexical tokens complex hierarchical structure seen chapter structured fragments code language embedded literals language 
monadic packrat parsing popular method constructing parsers functional languages haskell monadic combinators 
unfortunately monadic combinator approach usually comes performance penalty packrat parsing tradeo presents difficult choice 
implementing packrat parser described far assumes set nonterminals corresponding result types known statically bound single fixed tuple form derivs type 
constructing entire packrat parsers dynamically packrat parsers combinators require making derivs type represent dynamic lookup structure associating variable set nonterminals corresponding results 
approach slower space cient 
practical strategy provides convenience combinators significant performance penalty combinators define individual parsing functions comprising packrat parser keeping derivs type top level recursion structure static 
parser type combinators build parsing functions need directly obvious method combinators simple type alias type parser derivs result unfortunately order take advantage haskell useful syntax combinators type special class monad simple aliases assigned type classes 
wrap parsing functions real user defined type newtype parser parser derivs result basic combinators implement haskell standard sequencing result producing return error producing combinators instance monad parser parser parser pre pre post post parsed parser post noparse noparse return parser parsed fail msg parser noparse parsing need ordered choice combinator parser parser parser parser parser parser pre pre post post noparse post combinators addition trivial recognize specific characters padditive function original packrat parser example written follows parser padditive char return parser iterative combinators tempting build additional combinators higher level idioms repetition infix expressions 
iterative combinators packrat parsing functions violates assumption cell result matrix computed constant time results cells depends available 
iterative combinators ectively create hidden recursion intermediate results memoized result matrix potentially making parser run super linear time 
example suppose rule implemented zero repetitions combinator applied input string consisting 
compute parsing matrix cell nonterminal possible positions string computation result start scratch iterate remaining part string making computation cell run making computation entire parsing matrix run 
contrast grammar written terms primitive constant time combinators rule result input position builds results positions farther right time guarantee preserved 
problem necessarily serious practice experimental results chapter show 
iterative combinators practical grammars result cell sequence needed 
case lazy evaluation ensures result cells tails sequence computed ective amount done 
situation amounts partial regression conventional functional backtracking approach practical grammars occasional backtracking acceptable 
may di cult predict combinations input strings lead exponential parse times complex grammar forms input strings take 
packrat parser combinator library line examples thesis include full featured monadic combinator library build large packrat parsers conveniently 
library substantially inspired parsec combinator library designed construction top predictive parsers support occasional backtracking 
combinators packrat parsing library simpler parsec treat lexical analysis separate phase implement token lookahead mechanism traditional predictive parsers 
full packrat parsing combinator library provides variety safe constant time combinators dangerous iterative ones convenient necessary construct useful parsers 
combinator library simultaneously multiple parsers di erent derivs types supports user friendly error detection reporting described 
error handling graceful error handling critical practical parsers expected interpret source files nontrivial size written humans 
error handling techniques conventional ll lr parsers variants studied techniques directly applicable packrat parsers generally assume parser performs deterministic left right scan input simply report error gets stuck 
packrat parsing somewhat di cult localize determine true cause error failures occur parsing process represent errors merely cause backtracking alternate path 
success result indicate error condition particular result contributes error fundamentally depends context result 
consider definition appear grammar imperative language block statement suppose third statement block input text malformed 
case statement portion rule succeeds anyway operator succeeds matches 
statements block consumed character matched portion expected closing brace block fails match 
position reported location error 
position expected find closing brace error reported invalid statement 
invalid statement may complex construct lines long nested block containing embedded statements 
actual error embedded statements reporting position block may data pos pos string int int data expected string message string data parseerror parseerror pos data result parsed parseerror noparse parseerror result type augmented error information provide little useful information 
order locate actual error precisely able descend apparent success result generated statement subrule discover subrule match text 
representing error information error handling method inspired method parsec combinator library mentioned 
solution results generated parsing functions success failure augmented error information shown 
error information result contains components position input text file name line number column number set error descriptors 
error descriptor indicates possible reason error may detected position 
legal parseerror instance error descriptors situation simply means information available error position 
kinds error descriptors 
variant form expected indicates syntactic element named described string scanned starting position 
example may name specific keyword operator punctuation symbol may name larger composite construct expression declaration 
kind error descriptor far common 
second variant form message indicates general syntax error kind described error message variant allows specific information provided cause error particularly useful amount semantic checking performed parser addition pure syntax analysis 
example parsing function decimal number successfully reads string digits discovers value number legal range numeric literals produce positions ordered line number column number 
instance ord pos pos join giving preference farthest right merging descriptor sets position 
parseerror parseerror parseerror parseerror parseerror null null parseerror union joining sets error descriptors message error descriptor string numeric literal range 
propagating error information inherently speculative nature packrat parsing generally known time parseerror instance produced information contains indicates error 
error information produced parsing function filtered combined propagated upwards parsing functions defined rules 
rules defined error input string relevant information trickle upward eventually emerge part failure result produced top level parsing function 
probably perfect method deciding exactly information relevant error simple heuristic provides results practice simply prefer information produced positions farthest right input stream 
tdpl packrat parsing inherently oriented reading text left right error information corresponding positions farthest forward generally specific closest actual error 
core error information combination filtering process implemented function shown 
function takes parseerror instances combines single instance 
instances indicate errors di erent positions farthest forward returned 
instances associated position respective sets error descriptors combined haskell union function merges elements lists discarding duplicates 
function modify monadic combinators defined section shown 
return combinator produces parseerror error information position result produced fail combinator produces parseerror supplied message obvious way 
sequencing combinator operates follows 
combinator invokes lefthand side parser 
fails combinator returns result verbatim including error information contains 
succeeds combinator standard monadic combinators instance derivs monad parser sequencing combinator parser parser parse parse dvs dvs parsed val rem err parser val second err rem noparse err noparse err second err parsed val rem err parsed val rem err err second err noparse err noparse err err result producing combinator return parser dvs parsed dvs parseerror dvs failure combinator fail msg parser dvs noparse parseerror dvs message msg ordered choice derivs parser parser parser parser parser parser parse parse dvs dvs dvs dvs result parsed val rem err result dvs noparse err second err dvs second err parsed val rem err parsed val rem err err second err noparse err noparse err err monadic parser combinators error handling function invokes right hand side parser calls second result passing error information generated 
function second turn combines error information error information generating sequencing combinator final result regardless succeeds fails 
suppose example parsing function statement subrule block construct parsing function closing brace 
syntax error statements sequence parsed produces success parsed result result includes error information describing statement parsed text successfully consumed 
result subsequently produced indicate error invalid statement expected 
error detected indicates position farther right portion invalid statement successfully parsed failure occurred error information overrides information 
hand get farther successfully parsed statement sequence statements correct block accidentally terminated parseerror position sequencing combinator merge error descriptors 
example error information indicates expected statement combined parseerror contains descriptor list expected statement expected produce descriptive error message position expected statement 
ordered choice operator combines error information similar fashion 
invokes parser alternative returns result directly successful including error information produced parse longer string 
failed invoked error information result combined error information regardless succeeded failed 
obvious combined fail looks statement keyword looks statement parser produce error message position expected 
see sets combined succeeds consider parsing actual statement subrule statement block example 
subrule functionally equivalent right recursive definition statements statement statements suppose parsing function alternative statement statements parsing function second alternative merely parses empty string 
parser succeeds producing parseerror error descriptors error occurred expected 
statement sequence invalid information error come succeeded 
injecting error information final basic error handling primitive need convenient way inject error information place 
fail combinator inject general purpose error messages 
error information commonly produced error annotation combinator shown 
combinator associates derivs parser string parser parser desc parser dvs dvs dvs dvs parsed rem err parsed rem fix dvs err dvs noparse err noparse fix dvs err fix dvs err parseerror ms dvs err parseerror dvs expected desc error annotation combinator human readable name syntactic construct parsing function looking 
parser annotated combinator generates result combinator compares position parseerror result starting position annotated construct 
error information result right starting position combinator assumes represents detailed information syntactic element annotated construct returns parser result unmodified 
combinator replaces error information annotated parser result expected descriptor containing name attached combinator 
example consider annotated monadic parsing function corresponding tdpl definition expression expression expression decimal derivs result int parser char char char return parser expression suppose invoked finds opening parenthesis decimal digit position 
alternatives choice combinator fail indicating expected starting position second indicating expected decimal digit input position 
alternative got farther input text expression annotation combinator replaces error information produced single higher level error descriptor expected expression 
hand suppose input text position starts 
characters string appear expression represents syntax error 
case alternative matches part string fails yielding parseerror indicating position 
choice combinator invokes second alternative fails successfully parsing text error information overridden parseerror alternative 
error annotation combinator likewise passes parseerror information modification position indicates represents detailed information error expected expression 
parsers high level constructs language annotated way useful detailed error messages produced merely appropriate library functions parse low level lexical tokens keywords operators 
monadic combinator library includes function purpose string matches characters sequence 
string derivs string parser string string str str show str return str ch chs char ch chs example string creates parser scans keyword produces error descriptor expected 
extra pair string literal generated haskell show function string helps clarify user sequence characters expected kind syntactic construct known 
maintaining input position information error handling facilities described depend able determine input position corresponding derivs tuple 
purpose add additional element tuple accessor named data derivs derivs dvchar result char pos position values produced top level tie function packrat parser modify follows parse pos string derivs parse pos derivs chr pos chr case parsed parse pos parseerror pos noparse parseerror pos message unexpected input parse function takes additional argument position start counting input text pos increments appropriately character function incrementally compute position text file character current position 
follows standard convention character tab stops 
pos file line col pos file line pos file line div col pos file line col packrat parsing state final extension packrat parsing algorithm need practical situations ability parse context sensitive grammars parsing decisions depend kind state built incrementally parsing process 
known example requirement grammars various constructs disambiguated properly knowledge identifiers names types represent ordinary variables 
new type names declared source file symbol table kept parsing process updated time new type declared constructs declarations parsed properly 
state inherently problem packrat parsing algorithm assumes way parse nonterminal input position 
presence state violates assumption means usually infinite number ways parse nonterminal input text state parsing region text may di erent parsing 
problem necessarily insurmountable just means state change occurs parser create switch new derivations structure mid stream 
maintaining state add state packrat parser incorporate desired state element component derivations tuple 
addition ciency improved considerably state changes record derivs instance original input string supplied parse function created derivs instance 
example state element want maintain type symboltable extend derivs type section follows data derivs derivs dvchar result char pos string symboltable add parameter parse function specifying initial state value parsing process parse pos string symboltable derivs parse pos str symtab derivs chr pos str symtab chr case str parsed parse pos symtab parseerror pos noparse parseerror pos message unexpected input referencing state parsing functions packrat parser current state simply accessor appropriate derivs instance 
parsing functions defined monadic combinators combinator easy access current state getstate parser symboltable getstate parser combinator current state accessed haskell block statement form symtab getstate identifier symtab bound state ect getstate combinator invoked 
changing state derivs instance associated element top level parse function replicates state value invoked derivs instances creates input string derivs instances state change 
parsing function making state change create entirely new result matrix starting point state change occurred 
parsing function returns derivs instance new result matrix remainder portion result 
parsing function probably called order produce cell original result matrix result cell original matrix direct link new 
parsing functions original result matrix subsequently remainder part result continuation point parsing automatically forwarded new result matrix causing subsequent actions occur context new state 
state changes easily implemented help combinator complements getstate combinator setstate symboltable parser setstate newstate parser parsed parseerror pos pos input parse pos input newstate setstate function extracts position input string original derivs instance calls top level parse function position input string new state value order create derivs instance representing column result matrix new state 
parsing function returns new derivs instance remainder part success result 
dangers state obvious making state changes packrat parser potentially expensive operation terms speed storage consumption 
lazy evaluation crucial stateful packrat parser computing complete parsing matrix entire remainder input text state change 
lazy evaluation cells result matrix needed parsing actions occur corresponding state computed 
stateful packrat parser ect computes results backtracking recursive descent parser compute 
state changes create risk result cells nonterminal input position may computed multiple times di erent parsing matrices di erent states 
results computed parallel states way defeat packrat parser memoization capability create potential super linear runtime 
state changes occur packrat parsing yield practical benefit simple backtracking just consume additional storage 
reason viability packrat parsing state depends properties specific language parsed 
general issues limitations packrat parsers packrat parsing powerful cient applications main issues inappropriate situations 
packrat parsing supports localized backtracking parsing function produces result 
second packrat parser depends ciency completely stateless 
due reliance memoization packrat parsing inherently 
issues discussed section 
localized backtracking important assumption far mutually recursive parsing functions packrat parser built return result 
ambiguities grammar parser built parsing functions able resolve locally parsing function 
example parsers developed thesis multiple alternatives implicitly disambiguated order tested alternative match successfully independent alternatives may match 
behavior easy implement useful performing longest match forms explicit local disambiguation 
parsing function try possible alternatives produce failure result alternative matches 
parsing functions packrat parser return multiple results parallel disambiguated global strategy 
languages designed machine consumption requirement multiple matching alternatives disambiguated locally problem practice ambiguity usually undesirable place localized disambiguation rules preferred global ones easier humans understand 
parsing natural languages grammars global ambiguity expected packrat parsing tdpl notation useful 
classic generalized top parser context free grammars parsing functions return lists results memoized similar way resulting parser linear time comparable existing tabular algorithms ambiguous context free grammars 
generalized cfg parsing equivalent computational complexity boolean matrix multiplication linear time solution di cult problem 
limited state second limitation packrat parsing fundamentally geared stateless parsing 
packrat parser memoization system assumes parsing function nonterminal depends input string information accumulated parsing process 
section demonstrated stateful packrat parsers implemented state changes occur frequently algorithm may ine cient certain conditions blow take exponential time space 
contrast traditional top ll bottom lr parsers little trouble maintaining state parsing 
algorithms perform single left right scan input look ahead tokens lost state change occurs 
space consumption probably striking characteristic packrat parser fact literally away computed input text including entire input text 
reason packrat parsing storage requirements equal possibly substantial constant multiple input size 
contrast ll lr backtracking recursive descent parsers designed space consumption grows maximum nesting depth syntactic constructs appearing input 
nesting depth practice orders magnitude smaller total size text 
ll lr parsers non regular language linear space requirements worst case average case di erence important practice 
way reduce space requirements derivations structure especially parsers grammars nonterminals splitting derivs type multiple levels 
example suppose nonterminals language grouped broad categories lexical tokens expressions statements declarations 
derivs tuple components addition dvchar nonterminal categories 
components turn tuple containing results nonterminals category 
majority derivs instances representing character positions tokens components representing categories nonterminals evaluated small top level object unevaluated closures components occupy space 
derivs instances corresponding token results categories needed depending kind language construct located position 
optimizations packrat parser consume times working storage size original input text 
reason application areas packrat parsing probably best choice 
example parsing xml streams fairly simple syntax encode large amounts relatively flat machine generated data power flexibility packrat parsing needed storage cost justified 
hand parsing complex modern programming languages source code usually written humans top priority power expressiveness language space cost packrat parsing probably reasonable 
standard programming practice involves breaking large programs modules manageable size independently compiled main memory sizes modern machines leave orders magnitude expansion typical kb source file parsing 
parsing larger source files working set may relatively small due strong structural locality properties realistic languages 
entire derivations structure thrown away parsing complete parser space consumption irrelevant result fed complex computation global optimizer requires space packrat parser 
chapter evidence space consumption reasonable practical applications 
packrat parser java order illustrate construction full scale packrat parser practical programming language parser java programming language available line smaller examples developed chapter 
parser described detail structurally functionally equivalent parser specification explored chapter notational details di erent 
chapter pappy packrat parser generator haskell chapter demonstrated packrat parsers expressed directly concisely non strict functional language haskell standard features language 
non strict functional languages time little curiosity outside academic research community able implement packrat parsers easily conventional languages 
languages obvious approach create compiler compiler tool lines yacc world accept grammar concise notation produce working packrat parser target language 
haskell world practical benefit automatic parser generator coding packrat parsers directly 
example grammar compiler generate parsing functions appropriate derivations type declaration top level recursive tie function making easier add remove nonterminals grammar 
compiler rewrite left recursive rules terms right recursive ones easier express left associative constructs grammar reduce iterative notations repetition operators low level grammar uses primitive constant time operations ensure linear parse time guarantee preserved 
specialized high level notation express language syntax possible check analyze grammar automatically verify contain illegal recursion cycles easier re grammar di erent applications 
chapter presents pappy prototype packrat parser generator performs functions described 
pappy written haskell currently generates haskell parsers 
pappy designed retargetable order generate parsers languages java extending way left 
section describes pappy parser specification language sections describe operation parser generator example pappy parser specification java language 
parser specification language naturally parser specification language accepted pappy tdpl 
addition parser specification language terms tdpl 
start spacing grammar eof identifier spacing letter digit spacing spacing char spacing char tab cr lf cr lf cr lf eof char syntax basic lexical elements pappy parser specifications details specification language syntax primary importance complete definition syntax included order provide practical example full scale tdpl syntax specification complementing toy grammars chapter 
tdpl syntax pappy specification language included fragments section single unified listing appendix basic lexical elements presents syntax basic lexical elements pappy parser specification language 
convention construct representing lexical token responsible consuming whitespace comments token nonterminal spacing serves purpose 
comments pappy specifications syntax haskell comments indicated double dash continue line 
special nonterminal start top level symbol representing complete pappy specification file 
nonterminal merely wrapper grammar defined represents high level global structure pappy specification 
start symbol invokes spacing order allow comments whitespace precede regular token complete grammar parsed checks file eof reached described section 
semantic values haskell code blocks practical parser generators pappy designed create parsers recognize language specified grammar compute semantic values recognized constructs 
semantic values subsequent processing code written target programming language case haskell 
semantic values generated parser commonly form syntax tree ast representing parsed string 
ast represents high level structure input convenient hierarchical form eliminating irrelevant syntactic details textual layout comments syntactic markers parentheses keywords 
order automatically generated parser produce meaningful semantic values user parser generator way specify semantic values generated 
common flexible method specifying semantic values allow actual fragments code target language haskell included parser specification defined points 
code fragments completely uninterpreted parser generator simply pasted generated parser appropriate locations 
traditional solution pappy adopts 
ect parser specification language accepted pappy pure tdpl language supporting tdpl rules containing fragments haskell code specify semantic values generated 
advantage approach full power target language available computation semantic values code compute values conveniently located corresponding syntax definitions 
main disadvantages scheme target language code fragments parser specification specification dependent target language type semantic values computed 
example approach single parser specification directly generate parsers multiple target languages 
usually impractical re implement target language full syntax type checking parser generator erroneous target language code fragments parser specification generally caught parser generator 
source file target language successfully generated target language compiler subsequently fail compile 
actual cause error specification may obvious error message produced target language compiler 
problem compounded pappy haskell target language equivalent line preprocessor directive placed automatically generated source files indicate original source code fragment particular line parser specification file 
syntax haskell code blocks embedded pappy specifications shown 
contents code block uninterpreted syntax haskell code contains examined determine block ends closing brace code block may contain nested brace pairs part haskell expressions nested braces matched properly reading code block 
haskell character string literals contained code blocks may contain unmatched curly braces character string literals character escape sequences turn detected properly 
haskell identifiers include characters haskell identifiers code block parsed atomic units prevent quote character embedded identifier improperly interpreted character literal 
spacing char char cr lf char char cr lf char syntax raw haskell code blocks embedded pappy specifications syntactic machinery easily expressed tdpl serves prime example advantages tdpl traditional stage syntactic paradigms lexical analysis considered separate parsing 
pappy parser specification syntax haskell code block treated single lexical token representing uninterpreted string characters deposited verbatim haskell source file generated parser 
syntactic specification special kind token involves complex recursive structures conventional lexical analyzer generators regular expressions expected handle 
reason syntax embedded code fragments kind traditionally expressed formal syntax merely described informally construct hand coded lexical analyzer 
global structure lexical building blocks pappy syntax established move global structure pappy specification summarized 
parser specification consists text file containing main components order 
component header form parser name name legal haskell identifier prefix various identifiers generated parser 
matter name starts uppercase lowercase letter pappy convert letter uppercase generating haskell type constructor names lowercase generating ordinary haskell identifiers 

optional block haskell code included header enclosed curly braces inserted verbatim braces grammar header 
definition 
header parser identifier colon top nonterminal comma nonterminal nonterminal identifier parser parser spacing top top spacing colon spacing comma spacing global structure pappy parser specification language generated parser top level haskell code haskell declarations produced parser generator 
code block typically declare haskell types type classes semantic values generated parser 

comes mandatory declaration form top names names list nonterminal names grammar separated commas 
nonterminal listed declaration considered parser generator top level nonterminal ensures corresponding component derivations tuple generated packrat parser corresponding haskell accessor function 
nonterminals declared top level way may inlined optimized away pappy parser generated 

main component specification grammar 
grammar sequence definitions nonterminal associated haskell type corresponding right hand side expression indicating nonterminal parsed associated semantic value generated 

second optional block haskell code included specification enclosed curly braces 
block included generated parser way 
nonterminal definitions presents syntax nonterminal definitions bulk pappy parser specification composed 
definition consists nonterminal name haskell type parsing rule expression 
haskell type definition describes semantic value nonterminal expressed single haskell identifier raw haskell code block 
code block express complex haskell types functions tuples lists user defined parameterized types 
example pappy definition assigns nonterminal comment haskell type empty tuple type comment definition nonterminal equals rule identifier spacing equals spacing syntax nonterminal definitions pappy parsing rules syntax pappy parsing rules shown 
rules precedence levels order highest lowest primary rules unary operators sequencing ordered choice 
primary rules consist nonterminal names character string literals matching raw input characters rules enclosed parentheses 
unary postfix operators 
optional zero 
order handle construction semantic values syntax sequencing operator pappy parser specifications somewhat di erent basic tdpl notation described section 
ordered choice operator lowest precedence 
operators express parsing rules produce semantic values target language haskell semantic value haskell type 
haskell type semantic value rule expression determined follows haskell type primary rule consisting simple nonterminal identifier haskell type associated nonterminal definition 
character literal rule yields semantic value haskell type char 
string literal rule yields semantic value haskell type string 
rule haskell type rule haskell type optional instance type 
rule haskell type rules haskell type list elements type 
rules 
haskell type rule 
type pappy perform full checking haskell types doing di cult general sequencing operator described allows semantic values computed arbitrary haskell expressions 
mismatch definition declared type type semantic value produced rule definition right hand side di erent sub rules alternation expression di erent types error detected haskell compiler attempts compile generated parser 
types declared nonterminals pappy specification required parser generator order produce haskell declaration derivs tuple type resulting packrat parser 
nonterminal open rule close question star plus sequence slash rule open spacing close spacing question 
spacing star spacing plus spacing slash spacing syntax parsing rules pappy sequencing operator standard tdpl notation sequencing multiple subexpressions merely adjoined directly suitable pappy specifications provides indication semantic result sequence computed semantic results individual components sequence 
reason pappy uses explicit binary operator indicate sequencing 
syntax operator shown 
left hand side operator series matchers specifying elements sequence match right hand side result expression indicating final semantic value computed 
matchers serve primary purposes specify parsing rule parse component sequence second specify semantic value resulting parsing rule matched bound haskell identifiers computation result 
addition matchers serve purpose expressing syntactic semantic predicates 
semantic value computed sequence expressed ways 
result expressed single haskell identifier case identifier bound produced matchers left hand side sequence operator 
second result computed arbitrary haskell expression enclosed curly braces 
case expression refer number semantic values bound di erent haskell identifiers matchers left hand side sequence operator 
sequence arrow identifier colon colon colon colon identifier arrow spacing colon spacing spacing 
spacing syntax pappy sequencing operator example definition involving sequencing operators integer digits 
digits sequences matchers left hand sides 
sequence semantic result computed haskell expression identifier bound semantic value produced digits component 
second sequence result expressed simple identifier haskell expression 
pappy supports kinds matchers sequence operator anonymous matcher consists final default alternative definition 
anonymous matcher causes rule invoked sequence throws away resulting semantic value binding haskell identifier 
component sequences example anonymous matcher consisting sub rule matches character input binding semantic value subrule haskell identifier 
second component sequence anonymous matcher matching sign case optional sign second 
identifier matcher takes form haskell identifier unary parsing rule 
identifier matcher invokes rule binds semantic value haskell identifier result computation sequence 
third component sequences identifier matcher digits binds haskell identifier semantic value produced subrule digits 
semantic value digits haskell type integer order compatible declared type 
pattern matcher takes form arbitrary haskell pattern parsing rule 
haskell pattern may bind number identifiers match semantic result produced rule order assign values identifiers 
example semantic value nonterminal foo pair sequence expression foo invokes nonterminal foo returns component semantic value semantic value sequence 
haskell pattern pattern matcher need exhaustive irrefutable 
rule succeeds pattern fails match semantic result entire sequence fail exactly rule failed 
refutable pattern matcher simple way express semantic predicate allowing parsing decisions syntactic construct depend semantic values computed constructs 
example nonterminal bar yields semantic value haskell type integer sequence rule just bar succeed rule nonterminal bar succeeds generates value matching just constructor 
bar fails produces value sequence fails match 
character matcher form single character haskell character escape sequence unary parsing rule 
rule produce semantic value haskell type char semantic result designated character sequence fails 
notation essentially shorthand haskell pattern matcher string matcher form number characters suitable haskell string literal unary parsing rule 
character matcher string matcher just shorthand notation pattern matcher followed matcher form unary rule 
matcher implements syntactic predicates causes rule invoked appropriate position sequence succeeds input position backed position invoked acting consumed input text 
fails sequence fails 
followed matcher form unary rule implements negative form syntactic predicate succeeds sequence fails fails matcher succeeds consuming input text parsing sequence allowed continue 
final type matcher predicate matcher implements semantic predicates general form 
predicate matcher takes form arbitrary haskell expression producing value type bool 
predicate expression evaluates true parsing sequence allowed continue semantic predicate evaluates false sequence fails 
expression refer haskell identifiers bound matchers sequence point matcher appears 
example sequence foo bar semantic predicate expression simple example semantic predicates implement character classes generically terms built haskell functions letter char char digit char char 
parser specification reduction validation reading parser specification pappy automatically performs basic validity checks specification 
example ensures nonterminal defined nonterminal referenced rule definition 
parser generator performs transformations specification order rewrite form implement linear time packrat parser directly 
simple left recursive definitions rewritten right recursive ones 
second iterative rules rewritten terms simple right recursive definitions 
transformations implications parser specifications described detail 
rewriting left recursive definitions described earlier section left recursion tdpl grammar normally considered erroneous 
tdpl definition form read ectively means order read try read 
ordinary tdpl notation purpose express language syntax usually little need equivalent left right recursive cfg definition ect achieved concisely repetition operators 
parser generator pappy generated parser expected just recognize string compute semantic values syntactic structure left right recursion useful allow semantic value sequence syntactic elements computed incrementally values individual elements sequence 
operators produce lists may type semantic value desired sequence 
example consider fragment trivial expression language expression number number just wanted semantic value expression list semantic values numbers sequence convert definition directly pappy definition expression integer number ns number ns really want add numbers sum semantic value expression operator mean building useless list take apart expression integer number ns number foldl ns task cumbersome kind operator expression integer number foldl op op ns integer integer number number right associative operators operators addition multiplication associativity matter right recursion easy natural add numbers incrementally expression integer number expression number attempted parse binary subtraction operator right recursion way string improperly interpreted leading incorrect result 
clearly want able express left recursion directly 
simple left recursion left recursive definitions invalid pappy specification free assign meaning suits pragmatic needs meaning quite fit tdpl paradigm 
convenience expressing left associative constructs pappy automatically rewrites certain kinds left recursive definitions terms right recursive definitions 
direct left recursion rewritten way left recursive parsing rule right hand side refer directly nonterminal left hand side definition indirectly nonterminals 
right hand side left recursive definition choice construct left recursive alternatives construct exactly form 
haskell identifier nonterminal defined 
alternatives right hand side left recursive take forms 
example left recursive definition simple language addition subtraction expression integer expression number expression number number rewrite definition pappy separates left recursive alternatives rest case transforms definition pair definitions expression integer number integer number number essence pappy automatically performs left factoring section construct packrat parser manually left associative operators 
due basic left right asymmetry tdpl paradigm left recursive pappy definitions transformed way behave exactly mirrored definitions 
example left recursive alternatives separated original definition relative order left recursive alternative nonrecursive alternative definition matter relative order alternatives category important 
example left recursive definition functionally equivalent previous expression integer number expression number expression number comparable right recursive definition second third alternatives match alternative succeed override 
practical purposes asymmetry usually issue 
indirect left recursion simple left recursive definitions rewritten described pappy checks entire grammar direct forms left recursion signals error illegal recursion 
check ensures parsing process terminate assuming course haskell expressions compute semantic values predicates terminate 
obvious question pappy support rewriting left recursive definitions general example handle indirect left recursion multiple nonterminals 
transformation possible implement clear behavior transformed grammar characterized clear meaningful way tdpl paradigm 
generalized left recursive tdpl construct expected behave di erently superficially similar left recursive construct cfg fundamental di erences paradigms 
furthermore clear due left right asymmetry tdpl noted construct expected behave mirrored version right recursive tdpl construct 
left recursion tdpl studied utilizing feature amount opening syntactic box clearly defeats pragmatic purpose simple left recursion transformation provided 
clear danger generalized left recursion rewriting triggered language designers accidentally intentionally subtle dependencies nonterminals unexpectedly lead left recursion 
cases probably useful language designer informed problem front parser generator solve silently obscure way may lead unexpected results 
rewriting iterative rules pointed section di cult implement iterative syntactic constructs expressed operators haskell combinators direct functional code implementing way invalidate packrat parser linear time guarantee 
pappy implements repetition operators parser specification rewriting terms basic sequencing choice recursion 
rewrite subexpression parsing rule definition pappy creates new right recursive nonterminal match sequence instances build semantic values list 
parser generator substitutes new nonterminal original definition 
example consider definition word string letter cs spacing cs pappy expands definition pair definitions structure word string letter cs spacing cs char cs cs instances repetitions operator rewritten similarly second alternative iterative rule base case expects instance repeated subrule produces element list matching producing empty list char cs cs unfortunately minor practical di culty arises rewriting rules way 
subrule repetition operator applied arbitrary parsing rule expression 
order create new iterative definition pappy able determine haskell type semantic value generates associate proper corresponding list type newly created nonterminal 
mentioned earlier pappy know haskell type associated nonterminal grammar order declare appropriate derivs tuple type generated parser 
common cases pappy infer haskell type iterated subrule examination subrule 
example case subrule name nonterminal haskell type simply taken definition nonterminal char case enclosed brackets create corresponding haskell list type char haskell string 
pappy machinery parse type infer arbitrary haskell patterns expressions may compute semantic values sequence rule 
appropriate haskell type subrule repetition operator inferred due dependence haskell patterns expressions pappy aborts error 
example pappy infer appropriate haskell type iterated subrule examples char legal char illegal char illegal case clear pappy subrule char generates semantic value haskell type char result generated sequence derived directly result second matcher sequence binding expressed simple identifiers 
second case result sequence computed haskell expression albeit seemingly trivial pappy unable interpret 
third case result sequence indicated simple identifier pappy determine identifier bound binding haskell pattern 
limitation occasionally inconvenient cause serious problem practice solved separating iterated subrule nonterminal definition explicitly declared haskell type 
pappy parser specification java section describes example pappy parser specification java language functionally equivalent example monadic packrat parser mentioned earlier section 
fragments pappy specification java complete specification available line 
parser specification provides illustration power expressiveness pappy specification language 
pappy specification just lines long significantly shorter monadic haskell version lines 
apart trivial preprocessing unicode escape sequences lexical analysis seamlessly integrated parser specification implemented separate stage necessary traditional lr parser generator 
summarizes header portion pappy specification java 
aside declaration parser name java top declaration toplevel nonterminal header primarily consists raw haskell code 
purpose code declare haskell data types represent java syntax trees 
keywords constant list reserved words java language parsing identifiers 
parser specification comes grammar proper begins definitions nonterminals representing lexical elements language 
earlier tdpl specification syntax pappy parser specification language java parser specification adopts convention parsing rule token pappy packrat parser specification java language version parser java import char import system import numeric syntax tree data types type identifier string type name identifier data literal integer integer float double char string bool data expression literal identifier 
syntax tree data types 
list java reserved words keyword keywords boolean break byte case catch char class const continue top header portion pappy parser specification java spacing space space whitespace comment whitespace char comment char char parsing rules java whitespace comments responsible consuming whitespace comments token 
function performed spacing nonterminal defined 
whitespace comments normally ignored subsequent processing definitions simply produce empty tuple semantic result value 
important retain information example application reads java source file writes back modified java source text comprising whitespace comments retained syntax tree 
traditional style comments comment style comments comment extending line easily handled repetition operator 
example expects number characters matching subrule char means character long sequence 
java disallows nested comments sequences comment ignored 
changing definition support nested comments easy contrast traditional lexical analyzer generators usually limited non recursive regular expressions char shows rules parsing java reserved words keywords identifiers 
semantic predicates possible simpler approach task outlined section pure syntax tdpl 
approach adopted single nonterminal word responsible parsing words kind represent identifiers keywords 
semantic value word string characters comprising identifier keyword 
keyword nonterminal uses haskell semantic keywords identifiers identifier identifier keyword word keyword string word elem keywords word string cs spacing cs char char char char parsing rules java keywords identifiers predicate recognize keywords keywords list defined earlier 
identifier nonterminal uses negative syntactic predicates prevent keywords word literals accepted identifiers 
java language specification classifies special words true false null separately literals keywords pappy parser adopts convention consistency language specification treating names keywords yield slightly simpler cient parser 
java operators punctuation handled definitions 
practical programming languages java includes number operators consisting multiple characters standard longest match rule applies reading operators 
example character sequence interpreted single logical right shift operator consecutive greater operators 
reason operators punctuation symbols java listed definition longest ones priority 
sym nonterminal represents symbol token matches followed optional spacing 
keywords semantic value sym sequence characters comprising operator semantic value grammar distinguish di erent symbols 
parsing integer floating point character string boolean null literals straightforward involves details important thesis definitions lexical constructs described 
pappy left recursion rewriting comes particularly useful parsing numbers symbols operators punctuation sym string spacing string parsing rules java symbols digits integer digits digit digit digit int char shows parsing rules type expressions providing example basic lexical elements identifiers keywords symbols grammar 
example definition alternatives refer nonterminal word 
qualified specific string semantic predicate order recognize specific java keywords denoting primitive types 
definition informally interpreted look word semantic value byte word semantic value short 
definition dims similarly uses string matchers recognize specific symbols 
semantic predicates way allows basic syntactic elements keywords symbols treated uniformly low level lexical level case di erent ways higher syntactic levels 
shows sample rules java expressions including operators assignment lowest precedence level left associative operators postfix array access method calls left recursion rewriting 
traditional parser generators yacc allow precedence levels infix operators specified special purpose auxiliary annotations control parser disambiguation process pappy provide feature notion disambiguation meaning tdpl cfgs obvious appropriate equivalent expressed cleanly tdpl paradigm 
rate cumbersome express precedence level separate nonterminal 
remaining definitions statements declarations related constructs straightforward translations java language specification typename dims typename typename byte word short word char word int word long word float word double word boolean word identifier identifier sym identifier int dims dims int sym sym dims sym sym parsing rules java type expressions expression expression op expression op string sym sym sym 
precedence levels 
expression sym expression 
sym arguments sym primexpr sym class word sym sym primexpr primexpr expression literal identifier sym expression sym 
parsing rules java expressions discussed 
details please see full parser specification available line 
internal grammar representations transformations accepting parser specification rewriting repetition operators definitions pappy uses stage back pipeline produce working parser specification 
back stage simplifies grammar variety local global optimizations 
second stage analyzes grammar determine nonterminals memoized parser derivs tuple ciently implemented terms simple functions 
stage code generator uses simplified grammar results memoization analysis write parser 
remainder section describes important details stages 
grammar simplification number nonterminals memoized packrat parser derivs tuple critical importance parser space consumption parser store instance tuple character position input string 
experimentation reveals haskell number nonterminals important factor packrat parser performance 
reason pappy implements number optimizations designed primarily reduce number nonterminals grammar secondarily reduce complexity rules possible 
application optimization may create optimization opportunities pappy invokes optimizations repeatedly applied anymore 
process terminates optimizations strictly reduce size grammar grammar size measured number nonterminals second aggregate size rules definitions 
peephole optimizations simple peephole optimizer performs simple local transformations reduce complexity rules parser specification 
redundant sequencing operators containing component choice operators containing alternative eliminated 

sequence operators nested directly sequence operators choice operators nested directly choice operators flattened 
example rewritten 
addition improve lexical analysis performance peephole optimizer detects left factors constructs consisting choice literal characters strings rule java parser specification 
multiple alternatives start common characters common prefix factored needs tested sequence 
example rule rewritten form 
addition implementing factored constructs terms normal sequencing choice pappy optimizer uses special internal switch operator 
operator invoked directly user parser specification generated internally left factoring optimization 
switch operator implementation prefix recognition trees preserves knowledge branches tree disjoint prefix matches input stream prefixes need tested subrule matched prefix subsequently fails 
result recognition simple operators literal symbols language implemented directly ciently terms nested haskell case expressions 
example optimization definition java parser results haskell expression form result string case parsed case parsed case parsed case parsed parsed 
parsed 
parsed parsed 
parsed 
parsed parsed 
parsed 
parsed 
redundant rule elimination repetition operators applied subrule multiple places user original parser specification rewriting operators creates multiple nonterminals equivalent definitions 
pappy optimizer scans combines redundant nonterminals created way original specification may contained 
structural equivalence analysis relatively primitive eliminating redundant nonterminals identified time 
multiple redundant sets mutually recursive nonterminals detected example limitation problem practice rewriting repetition operators produce sets occur naturally typical grammars 
inlining grammar specifications nonterminals simple non recursive definitions 
pappy attempts eliminate nonterminals classic process inlining folding copies definitions directly call points grammar 
inlining general purpose programming languages inlining definitions pappy grammar done cautiously avoid blow size complexity grammar resulting parser 
reason pappy inlines kinds definitions tiny definitions containing operators right hand side definitions referenced entire grammar 
experience demonstrates inlining conservatively way reduces number nonterminals grammar substantially open door local optimizations applied inlined parsing rules 
memoization analysis virtual inlining smallest nonterminal definitions safely inlined direct substitution parser specification nonterminals eliminated derivs tuple virtual inlining 
virtually inlined nonterminal remains part grammar corresponds separate haskell parsing function generated parser 
virtually inlined nonterminal corresponding component derivs tuple 
location parser nonterminal invoked parsing function nonterminal directly derivs data accessor function 
ect virtually inlined functions simply de memoized 
order ensure packrat parser linear time guarantee invalidated transformation nonterminals inlined direct substitution selected virtual inlining 
specifically virtually inlined definitions recursive directly indirectly virtually inlined definitions 
long recursion grammar broken memoization virtually inlined definition accesses fixed number cells parsing structure performs fixed number primitive parsing operations order compute result constants increased virtual inlining 
larger definitions virtually inlined safely directly inlined caution required prevent possibility redundant computation 
pappy virtually inline nonterminal definition consists operators including size definitions nonterminals invoked nonterminal consideration selected virtual inlining 
limitations judicious virtual inlining substantially reduce number memoized nonterminals size packrat parser derivs tuple leading reduced storage consumption increased performance due lower garbage collection overhead 
example packrat parser generated example java grammar contains nonterminals rewriting simplification nonterminals memoized 
code generation final step pappy internal pipeline writing haskell code parser 
code generation relatively straightforward process directly struc ture internal parser specification described detail important feature code generator worthy note 
order reduce space consumption pappy code generator uses trick described section breaking derivs structure levels 
top level derivs tuple consists dvchar set sub tuples turn contains result components number nonterminals 
pappy attempts balance number sub tuples top level derivs tuple number components sub tuple distributes nonterminals specification evenly sub tuples 
special attempt cluster nonterminals appropriate way nonterminals assigned sub tuples order appear parser specification preserving natural proximity related nonterminals tends specifications written humans 
java parser specification example lexical analysis rules clustered specification result corresponding components derivs tuple memoized sub tuples 
lexical analysis rules consume complete tokens parser usually evaluates results sub tuples internal character positions multi character token 
experimentation reveals level derivs structure critical packrat parsers haskell space consumption performance 
simple flat derivs tuple example java parser parser order magnitude slower ghc haskell compiler 
ect caused size derivs tuple size top level parse function lazy evaluator instantiate input position 
ect probably specific haskell languages similar lazy evaluation model space consumption behavior substantially di erent target programming languages 
chapter experimental results chapter presents preliminary experimental results demonstrate practicality packrat parsing 
experiments study performance hand coded packrat parsers java programming language 
java chosen rich complex grammar adopts fairly clean syntactic paradigm 
example java require parser maintain state declared types parsers perform special processing lexical hierarchical analysis haskell layout scheme requires 
parsers experiments di erent functionally equivalent packrat parsers java 
apart trivial preprocessing stage line breaks java unicode escape sequences lexical analysis parsers fully integrated parser 
parsers technique described section splitting derivs tuple levels order increase modularity reduce space consumption 
parsers manually written haskell methods described chapter 
parsers uses monadic combinators exclusively parser parser uses primitive pattern matching directly code parsing functions frequently lexical constructs keywords operators identifiers integer literals 
parsers monadic combinators construct higher level parsing functions 
second hybrid monadic pattern matching parser created order study practical cost monadic combinators packrat parsers 
third parser experiments parser generated pappy parser specification section 
test suite experiments consists unmodified java source files library chosen primarily known freely available includes substantial number relatively large java source files 
java source files small average compilation model encourages programmers place class definition separate file 
sections study aspects performance java parsers 
examine space utilization maximum heap size order address java trademark sun microsystems www org source file size kbytes monadic avg 
hybrid avg 
pappy avg 
monadic parser scanner hybrid monadic parser pattern matching scanner pappy generated parser maximum heap size versus input size important question packrat parser result matrix consumes storage algorithm practical 
second measure absolute performance parsers order provide feel general performance compare ects di erent methods constructing packrat parsers 
space ciency set experiments java parsers compiled glasgow haskell compiler version optimization profiling enabled 
ghc heap profiling system measure live heap utilization excludes unused heap space garbage samples taken 
shows plot parser maximum live heap size size input files parsed 
smaller source files parsed quickly garbage collection occurred heap profiling mechanism yield samples plot includes data points hand coded parser uses monadic combinators exclusively data points hybrid parser combination monadic combinators pattern matching data points packrat parser generated pappy 
data point java source file kb size included analysis shown graph compressing horizontal axis su ciently include unacceptably obscures densely packed portion graph left 
www haskell org ghc averaged test suite fully monadic parser uses bytes live heap byte input hybrid parser uses bytes heap input byte pappy generated parser falls middle bytes heap input byte 
general results encouraging packrat parsing consume substantial amount space typical modern machine kb ram trouble parsing source files kb 
furthermore parsers iterative monadic combinators break linear time space guarantee theory space consumption parsers appears grow fairly linearly 
monadic combinators clearly substantial penalty terms space ciency 
modifying parser direct pattern matching may yield improvement degree di cult predict cost lexical analysis dominates rest parser 
parser generated pappy uses direct pattern matching exclusively parsing functions due di erences hand coded parsers performance considered directly indicative result switching pure pattern matching 
pappy generated parser consumes storage hand coded pattern matching parser considerably space cient monadic parser 
space consumption pappy generated parser furthermore noticeably consistent hand coded parsers 
data points produced test suite standard deviation monadic parser average heap input ratio standard deviation hybrid parser standard deviation pappy parser 
di erence directly apparent graph points pappy generated parser seen follow middle line representing average parser closely data points hand coded parsers follow corresponding lines 
improvement predictability attributed fact parsing functions pappy parser contain hidden recursion parsers 
repetition operators pappy specification rewritten terms constant time primitives parser generated pappy parser guarantee asymptotically linear execution time hand coded parsers containing hidden recursion 
result indicates avoiding hidden recursion important practice necessarily critical 
parsing performance second experiment compares absolute execution time packrat parsers 
test parsers compiled ghc optimization profiling timed ghz amd athlon processor running linux 
source files test suite larger kb included test smaller files parsed quickly linux time command yield adequate precision 
data point kb source file test suite included analysis omitted graph purposes clarity 
shows resulting execution times plotted source file size 
inputs fully monadic parser averaged kbytes second standard deviation kb hybrid parser averaged kb standard deviation kb pappy parser averaged kb standard deviation kb tests parser generated pappy comes intermediate level hand coded parsers performance noticeably linear 
source file size kbytes monadic avg 
kbps hybrid avg 
kbps pappy avg 
kbps monadic parser scanner monadic parser pattern matching scanner pappy generated parser execution time versus input size standard deviation performance hand coded parsers represents respective averages standard deviation pappy parser represents average performance 
numbers suggest packrat parsing provide dependable linear time parsing real source files complex languages especially automatic parser generator pappy rewrite repetition operators parser specification 
chapter related chapter relates tdpl notation developed thesis packrat parsing algorithm relevant prior 
briefly review historical background tdpl theoretical results derived 
second informally explore relationship packrat parsing ubiquitous ll lr parsing algorithms 
examine noncanonical extensions lr paradigm address limitations lr packrat parsing di erent way 
discuss general cfg parsing algorithms practical parser generators 
tdpl background birman ullman developed formal properties parsing algorithms localized backtracking 
refined aho ullman classified topdown limited backtrack parsing restriction parsing function produce result backtracking localized function 
specific formal models limited backtrack parsing developed 
model referred tmg recognition scheme ts original renamed top parsing language tdpl inspired tmg early compiler generation system 
second formal model originally referred generalized ts gts generalized tdpl gtdpl inspired meta ii early compiler compiler 
keep distinction clear tdpl notational parsing paradigm thesis specific formal systems developed prior theoretical formal systems referred ts tdpl gts gtdpl respectively 
ts tdpl formal system formal model ts tdpl definitions nonterminals restricted primitive forms 
bc nonterminals 

nonterminal terminal character empty string distinguished symbol representing failure 
form rule bc embodies sequencing ordered choice 
operational interpretation invoked 
succeeds invoked description extended tdpl formal ts tdpl empty string terminal nonterminal ary sequence 
bc 
ary ordered choice 

greedy repetition ba positive repetition cb cb optional 
rules rewriting extended tdpl definitions formal ts tdpl input text succeed rule succeeds 
fail invoked original input position invoked backtracking input string necessary 
second form rule match constant terminal symbols characters produce unconditional success consuming produce unconditional failure 
nonterminal definition extended tdpl notation thesis reduced primitives supported formal model provided contain syntactic predicate operators 
syntactic predicates appear require additional functionality gts gtdpl system 
provides set rewrite rules reduce extended tdpl notation rules primitive ts tdpl formal system 
rules involve introducing new nonterminals grammar nonterminal letter appearing right side rewrite rule left assumed fresh nonterminal 
rewrite rules containing variables appearing sides rule representing parsing subrule expressions new definitions produced transformation may turn rewritten order decompose subrule expressions 
primitive ts tdpl grammars produced rules means optimal 
description extended tdpl formal gts gtdpl ts tdpl sequencing choice bc followed predicate followed predicate rules rewriting formal ts tdpl extended tdpl syntactic predicates formal gts gtdpl gts gtdpl formal system gts gtdpl formal system uses primitive rules slightly di erent form 
nonterminals 

nonterminal terminal form rule di ers ts tdpl 
form involving number nonterminals sequencing choice rule ts tdpl system interpreted di erently 
invoking causes invoked 
succeeds invoked starting position text consumed result success failure result fails invoked position called result call result important point invoked invoked 
gts rule functionally equivalent definition extended tdpl notation thesis 
birman ullman proved ts tdpl grammar transformed equivalent gts gtdpl rewriting primitive sequence choice rules ts tdpl grammar rule shown row table 
gts gtdpl powerful ts tdpl 
appears gts gtdpl properly powerful ts tdpl conjecture proven 
syntactic predicate operators extended tdpl notation thesis rewritten terms gtdpl second third rules shown 
example language probably recognized formed ts tdpl grammar 
language consisting strings form exactly matched pairs easily expressed extended tdpl grammar eof eof character gts gtdpl behaved ts tdpl certain respects 
possible detect potential loop failures caused direct indirect left recursion gts gtdpl grammar rewrite grammar form recognizes language causing loop failures 
contrast strong evidence eliminating loop failures ts tdpl grammars impossible general 
birman ullman left recursion elimination algorithm gts gtdpl serves di erent purpose implemented pappy 
algorithm rewrites grammar fail gracefully strings original grammar get infinite loop purpose pappy left recursion elimination grammar succeed pragmatically useful way fail 
pappy left recursion elimination intentionally equivalence preserving transformation 
relationship tdpl cfgs gts gtdpl known powerful recognize non context free languages 
language example expressed cfg 
parsing grammar recognizes language parsing grammar reduced formal gts gtdpl rules 
nonterminal grammar uses syntactic predicate check matched consuming 
rule skips past matches 
known tdpl powerful simulate push automaton recognize ll lr language 
formally proven appears set context free languages set languages expressible tdpl incomparable 
example pathological cfg earlier section appears expressible tdpl cfg describes language consisting odd length strings middle character 
problem tdpl way find middle homogeneous string containing distinguishable syntactic middle character case order reject strings position 
practical tdpl parsing birman ullman demonstrated existence linear time parsing algorithm ts tdpl gts gtdpl grammars tabular variety described section 
linear time algorithm apparently implemented probably computers time limited ram 
compilers period operate streaming fashion generating output progressively input text consumed keeping complete intermediate representation memory large source files processed near constant space 
compiler compiler systems tdpl theory inspired took basic recursive descent approach meta ii fact fully support backtracking modeled formal system 
formal tdpl appears largely neglected initial development part result excitement lr algorithms newly developed time probably seen practical 
adams tdpl modular language prototyping framework 
addition practical top parsing libraries toolkits including popular antlr parsec combinator library haskell provide similar limited backtracking capabilities parser designer invoke selectively order overcome limitations predictive parsing 
ect providing ad hoc backtracking support practical recursive descent parsers ectively adopt tdpl paradigm explicitly recognizing 
parsers implement backtracking traditional recursive descent fashion memoization creating danger exponential worstcase parse time making impractical general rely backtracking substitute prediction integrate lexical analysis parsing 
ll lr parsing lr parsing commonly seen powerful limited lookahead topdown ll parsing class languages parsers recognize 
pepper points lr parsing viewed simply ll parsing grammar rewritten eliminate left recursion delay important parsing decisions long possible 
result lr provides flexibility way grammars expressed actual additional recognition power 
reason treat ll lr parsers essentially equivalent 
lookahead critical practical di erence packrat parsing ll lr parsing lookahead mechanism 
packrat parser decisions point depend text input string 
computation individual result parsing matrix perform constant number basic operations basic operations include forward pointers parsing matrix skip large amount text 
ll lr parsers look ahead constant number terminals input packrat parsers look ahead constant number terminals nonterminals combination 
ability parsing decisions take arbitrary nonterminals account gives packrat parsing unlimited lookahead capability 
viewpoint computational complexity packrat parsing inherently requires takes advantage powerful computational model ll lr parsing 
ll lr parsers implemented simple stack machine deterministic pushdown automata linear time packrat parsing inherently requires machine memory 
conversely claim packrat parsing linear time algorithm depends assumption ram accessed constant time 
log cost ram packrat parsing log 
illustrate di erence language recognition power packrat parsing lr cfg expresses language cfg lr lr class cfg recognize language 
lr parser encountered boundary string language decide immediately start reducing matching matching pairs 
way lr parser decision encountered left hand side 
non lr language recognized packrat parser converting cfg directly tdpl grammar obvious way packrat parser grammar operates speculative fashion potentially reducing complete input string parallel 
ultimate decision ectively delayed entire input string parsed decision merely matter checking succeeded 
mirroring grammar left right change situation making clear di erence merely side ect fact lr parser decisions depend primarily leftward context limited rightward lookahead packrat parser decisions depend unlimited rightward lookahead leftward context 
grammar composition limitations lr parsing due fixed lookahead frequently felt designing parsers practical languages limitations stem fact ll lr grammars cleanly composable 
example grammar represents simple language expressions assignment allows simple identifiers left side assignment id eq ne id symbols id eq ne terminals representing tokens produced separate lexical analysis phase lr parser trouble grammar 
try integrate tokenization parser simple rules grammar longer lr id id eq ne problem scanning identifier lr parser decide immediately primary expression left hand side assignment immediately token 
token parser way knowing assignment operator half operator 
particular case grammar parsed lr parser 
practice lr lalr parsers uncommon 
lexical analysis separated parsing limitations lr parsers surface practical situations frequently result seemingly innocuous changes evolving grammar 
example suppose want add simple array indexing language array indexing operators appear left right side assignment 
possible approach add new nonterminal represent lvalue expressions incorporate array indexing operator types expressions shown eq ne id id id eq ne symbols treated terminals grammar lr parser sees identifier immediately decide part expression way knowing array indexing operators fully parsed 
packrat parser trouble grammar ectively evaluates alternatives parallel complete derivations knowledge absence time critical decision needs 
general grammars packrat parsers composable lookahead packrat parser uses decisions alternatives take account arbitrary nonterminals eq example second 
packrat parser give primitive syntactic constructs terminals special significance ll lr parser terminal fixed sequence terminals appearing grammar substituted nonterminal breaking parser 
noncanonical bottom parsing algorithms substantial orts develop practical extensions lr class parsing algorithms solve problems described giving linear time guarantee 
algorithms known noncanonical bottom algorithms operate general bottom fashion lr parser successively reducing phrases input corresponding nonterminals lr perform reductions phrases leftmost stream point 
ect modification certain conditions nonterminals terminals lookahead decisions 
nslr noncanonical bottom algorithm known practical nslr algorithm created tai 
example cfg tai expresses language lr nslr grammar indicative limitations algorithm seemingly redundant nonterminals replaced simple terminal grammar longer nslr 
reason limitation lr parser boundary input string nslr parser decide symbol lookahead start reducing matched nonterminal grammar shown distinct nonterminals represent respectively nslr algorithm reduces string depending lookahead character 
parser reduces depending lookahead symbol phrase just reduced 
reduced algorithm start reductions nonterminals nslr algorithm way transmit information character string back boundary needed choice contrast packrat parser speculatively reduce instances delay decision results needed reason example language recognized packrat parser tdpl grammar constructed redundant nonterminals despite limitation nslr shown salomon cormack powerful implement types scannerless parsers lexical analyzer integrated parser 
achieving goal involved augmenting context free grammar set restrictive disambiguation rules kinds 
exclusion rules serve comparable function negative syntactic predicate operator tdpl disallowing certain derivations allowed 
exclusion rules salomon cormack prevent reserved words recognized identifiers example 
second adjacency restriction rules disallow specific pairs nonterminals appearing directly adjacent input string 
rule handle problem discussed section expressing notion whitespace optional time mandatory identifiers keywords 
general operator tdpl provide functionality adjacency rules example foo bar matches foo long immediately followed bar 
case handling whitespace necessary syntactic predicates tdpl inherent support longest match parsing 
unknown nslr languages recognized packrat parser packrat parsing expressive nslr classes languages incomparable 
packrat parsing clearly restrictive rightward lookahead nslr take leftward context account making reduction decisions 
practice nslr probably space cient packrat parsing simpler cleaner 
lr grammars nslr grammars represent mathematically complicated subclass context free grammars closed composition tdpl rules 
bounded context parsable grammars bounded context parsable bcp grammars represent largest known class languages decidable parsed noncanonical bottom parser linear time 
unfortunately parsing algorithm exists bcp grammars put practice requires large table parsing contexts 
bcp grammars developed explored possible bcp grammar parsing manageable modern machines way tabular gtdpl parsing practical 
bcp parsing practical su ers limitation discussed conventional bottom parser speculative reductions 
example example language discussed section bcp language expressed simpler variant trailing example noncanonical bottom parser syntactic markers input allow determine start reducing way parser distinguish alternatives case perform actual reductions parallel successively matching single pairs branches exploration fails 
noncanonical algorithms szymanski williams developed general formal model bottom parsing algorithms analyze various classes noncanonical bottom parsable grammars including bcp 
broadest classes terms language recognition power lr grammars consists unambiguous cfgs sentential form possible state bottom parser arrive reducible phrase uniquely distinguished examining symbols left phrase symbols terminals nonterminals right 
class languages membership undecidable include language described example grammar 
string language serving initial state bottom parser reducible phrase innermost ab abb reductions start determined counting symbols left right phrase 
expressiveness gtdpl noncanonical bottom algorithms compared formally appears algorithms fit non speculative reduction model share common limitation gtdpl grammars 
known exist bottom parsable languages recognizable gtdpl 
general cfg parsing algorithms recursive descent parser functional language built recognize context free language making parsing functions return list results allowing unrestricted backtracking 
approach risks exponential worst case execution time general useful error detection di cult 
cient general parsing algorithms cfgs exist earley tomita handle arbitrary context free grammars including ambiguous ones 
earley algorithm asymptotically fastest known runs arbitrary cfgs unambiguous cfgs 
tabular structures earley algorithm bear resemblance tabular result matrix constructed packrat parser 
due greater di culty general cfg parsing problem earley algorithm store sets results items cell table merely result cell packrat parser leading super linear parse time earley algorithm 
sdf practical parser generation system uses generalized cfg parsing tomita generalized lr glr algorithm support parsing integrated lexical analysis 
due limited expressiveness pure cfg notation sdf provides extensions allowing useful disambiguation rules various kinds declared 
parser uses disambiguation rules trim set alternative parse trees produced parser parsing process 
forms disambiguation rules adjacency restrictions exclusion rules introduced salomon cormack nslr specifically lexical analysis 
addition sdf supports rules specifying precedence associativity binary operators rules enabling parser choose default multiple alternative parse trees ambiguity occurs 
disambiguation rules provided sdf provide practical expressive power tdpl expressive power achieved cost linear time parsing 
furthermore disambiguation rules declarative sense expressing high level intentions concisely declarations consistent tdpl paradigm cfg paradigm essentially represent direct instructions sdf parser 
disambiguation rule inherently describes language read language written general straightforward generate strings language automatically cfg annotated disambiguation rules pure cfg 
cross tdpl paradigm anyway order gain expressiveness seek questionable cfg paradigm right starting point 
chapter thesis explored top parsing language tdpl powerful notation specification language syntax packrat parsing practical algorithm parsing tdpl grammar linear time 
tdpl tdpl originally created formal model top parsers backtracking capability thesis developed extended tdpl notation serves viable compelling alternative traditional context free grammars cfgs describing syntax programming languages machine readable languages 
fundamental di erence tdpl cfg notation cfg specifies strings language written tdpl specifies strings language read 
common syntactic idioms impossible represent concisely pure cfg easily expressed tdpl 
example tdpl naturally oriented disambiguation pervasive lexical level programming languages frequently higher level syntax 
sophisticated decision rules including general syntactic predicates supported directly tdpl 
contrast cfg notation possible express precisely complete syntax practical programming languages including lexical syntax unified tdpl grammar 
packrat parsing packrat parsing adaptation classic tabular parsing algorithm existence known development tdpl apparently put practice 
packrat parser recognize string defined tdpl grammar linear time providing power flexibility backtracking recursive descent parser attendant risk exponential parse time 
packrat parser recognize ll lr language languages requiring unlimited lookahead parsed shift reduce parsers 
packrat parsing provides better composition properties ll lr parsing making suitable dynamic extensible languages 
primary limitation algorithm considerable asymptotically linear storage cost 
thesis explored implementation packrat parsers manually automatically parser generator 
monadic combinators lazy evaluation ca modern functional programming languages haskell manual implementation packrat parsers particularly simple elegant 
packrat parsing nearly easy implement non strict language recursive descent parsing backtracking simpler predictive parsing special lookahead mechanism necessary 
graceful error handling packrat parser slightly involved conventional deterministic parser monadic combinators implement packrat parser implementation sophisticated error handling straightforward painless 
pappy thesis pappy automatic packrat parser generator simplifies parser implementation creating packrat parsers declarative specifications 
pappy parser specifications support full generality tdpl purpose specifying syntax 
addition pappy extends tdpl notation features allow generated parser compute semantic values recognized constructs arbitrary fragments haskell code 
pappy complements tdpl capability expressing syntactic predicates analogous capability representing semantic predicates allowing parsing decisions semantic values 
example parsers semantic predicates implement character classes allow keywords operators language handled uniformly lexical level remaining distinguishable high level syntactic constructs 
practical experience hand implemented automatically generated packrat parsers java programming language developed thesis order evaluate packrat parsing algorithm 
example parsers demonstrate packrat parsing viable method parsing real programming languages complex grammars 
packrat parsers provide reliable linear time performance particularly repetition constructs grammar rewritten avoid hidden recursion 
packrat parsers consume bytes heap storage average byte input text reasonable typical problem sizes modern modern machines 
example packrat parsers demonstrate practical linear time scannerless parsing lexical analyzer fully integrated parser 
packrat parsing practical parsing algorithm support scannerless parsing linear time imposing complex constraints grammar specify language 
results demonstrate power practicality packrat parsing experimentation needed evaluate flexibility performance space consumption wider variety languages 
example languages rely extensively parser state layout sensitive languages ml haskell may prove di cult packrat parser handle ciently 
hand syntax practical language usually designed particular parsing technology mind 
reason equally compelling question new syntax design possibilities created free unlimited lookahead unrestricted grammar composition capabilities packrat parsing 
section suggested simple extensions depend integrated lexical analysis packrat parsing may useful languages extensible syntax grammar composition flexibility important 
practical area packrat parsing may di culty warrants study parsing interactive streams 
example read eval print loops language interpreters expect parser detect line input needed finish current statement requirement violates packrat algorithm assumption entire input stream available front 
similar open question conditions packrat parsing may suitable parsing infinite streams 
opportunity additional formal development tdpl paradigm 
unproven gts gtdpl fact powerful ts tdpl context free languages exist recognized tdpl grammar 
highly useful algorithms available bridge gap cfgs parsing grammars example testing language equivalence converting useful subclasses grammars form 
methods unparsing writing string tdpl grammar structured high level information syntax tree useful 
appendix example packrat parsers appendix contains complete listings example packrat parsers developed chapter 
section contains full version basic packrat parser described section section contains equivalent parser constructed monadic combinators developed section 
basic expression parser packrat parser trivial arithmetic language 
module data result parsed derivs noparse data derivs derivs result int result int result int result int dvchar result char evaluate expression return result ignoring unparsed remainder 
eval case parse parsed rem error parse error construct lazy parse result structure input string result computed linear time respect length input 
parse string derivs parse derivs add mult prim dec chr add padditive mult pmultitive prim pprimary dec chr case parsed parse noparse parse additive precedence expression padditive derivs result int padditive alt additive alt case parsed case dvchar parsed case parsed parsed alt alt alt additive alt case parsed parsed noparse noparse parse multiplicative precedence expression pmultitive derivs result int pmultitive alt multitive alt case parsed case dvchar parsed case parsed parsed alt alt alt multitive alt case parsed parsed noparse noparse parse primary expression pprimary derivs result int pprimary alt primary alt case dvchar parsed case parsed case dvchar parsed parsed alt alt alt primary alt case parsed parsed noparse noparse parse decimal digit derivs result int case dvchar parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed parsed noparse monadic expression parser packrat parser trivial arithmetic language 
module import pos import parse data result int result int result int result int result char pos instance derivs dvchar evaluate expression return result ignoring unparsed remainder 
eval case parse pos parsed error parse error construct lazy parse result structure input string result computed linear time respect length input 
parse pos string parse pos add mult prim dec chr pos add padditive mult pmultitive prim pprimary dec chr case parsed parse pos noparse parse additive precedence expression padditive result int parser padditive char return parser parse multiplicative precedence expression pmultitive result int parser pmultitive char return parser parse primary expression pprimary result int parser pprimary char char return parser parse decimal digit result int parser return appendix tdpl grammar pappy parser specification language start spacing grammar eof grammar header 
definition 
header parser identifier colon top nonterminal comma nonterminal nonterminal identifier definition nonterminal equals rule identifier nonterminal open rule close question star plus sequence slash rule sequence arrow identifier colon colon colon colon identifier identifier spacing letter digit spacing spacing char spacing char char cr lf char char cr lf char parser parser spacing top top spacing spacing equals spacing colon spacing comma spacing open spacing close spacing question 
spacing star spacing plus spacing slash spacing arrow spacing spacing 
spacing spacing char tab cr lf cr lf cr lf cr lf tab eof char bibliography stephen robert adams 
modular grammars programming language prototyping 
phd thesis university southampton 
alfred aho ravi sethi je rey ullman 
compilers principles techniques tools 
addison wesley 
alfred aho je rey ullman 
theory parsing translation compiling vol 
parsing 
prentice hall englewood cli 
alexander birman je rey ullman 
parsing algorithms backtrack 
information control aug 
carlos figueiredo 
monadic combinator compiler compiler 
th brazilian symposium programming languages pr brazil may 
universidade federal 
luca cardelli florian matthes martn abadi 
extensible syntax lexical scoping 
technical report digital systems research center 
jeroen fokker 
functional parsers 
advanced functional programming pages 
bryan ford 
packrat parsing simple powerful lazy linear time 
proceedings international conference functional programming oct 
andy gill simon marlow 
happy parser generator haskell 
www haskell org happy 
graham hutton 
higher order functions parsing 
journal functional programming jul 
graham hutton erik meijer 
monadic parsing haskell 
journal functional programming jul 
simon peyton jones john hughes editors 
haskell report 
www haskell org 
lillian lee 
fast context free grammar parsing requires fast boolean matrix multiplication 
journal acm 
appear 
leijen 
parsec fast combinator parser 
www cs uu nl 
mcclure 
tmg syntax directed compiler 
proceedings th acm national conference pages 
terence parr russell quong 
adding semantic syntactic predicates ll pred ll 
computational complexity pages 
terence parr russell quong 
antlr predicated ll parser generator 
software practice experience 
peter pepper 
lr parsing grammar transformation ll parsing making lr parsing understandable cient 
technical report tu berlin apr 
daniel salomon gordon cormack 
scannerless nslr parsing programming languages 
proceedings acm sigplan conference programming language design implementation pldi pages jul 

meta ii syntax oriented compiler writing language 
proceedings th acm national conference pages 
thomas szymanski john williams 
noncanonical extensions bottom parsing techniques 
siam journal computing jun 
kuo chung tai 
noncanonical slr grammars 
acm transactions programming languages systems oct 
masaru tomita 
cient parsing natural language 
kluwer academic publishers 
van den brand visser 
disambiguation filters scannerless generalized lr parsers 
compiler construction 
eelco visser 
scannerless generalized lr parsing 
technical report programming research group university amsterdam 
philip wadler 
replace failure list successes method exception handling backtracking pattern matching lazy functional languages 
functional programming languages computer architecture pages 
john williams 
bounded context parsable grammars 
technical report department computer science cornell university april 

