type classes higher order polymorphism matthias neubauer peter thiemann universit freiburg neubauer thiemann informatik uni freiburg de propose extension haskell type class system lambda abstractions type language 
type inference extension relies novel constrained unification procedure called guided higher order unification 
unification procedure general haskell kind preserving unification powerful full higher order unification 
main technical result soundness completeness unification rules fragment lambda calculus admit type level 
categories subject descriptors programming languages language classifications applicative functional languages programming languages language constructs features polymorphism logics meanings programs studies program constructs type structure general terms languages theory keywords type classes higher order unification type inference haskell haskell type system powerful type systems implemented programming language 
due haskell type class system supports parametric overloading type constructors higher order polymorphism 
features applications everyday programming problems 
concepts monads functors permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp october pittsburgh pennsylvania usa 
copyright acm conveniently expressed type classes higher order constructors 
retain decidable type inference algorithm haskell type language restricted combinator language type constructors variables abstractions 
number interesting examples lack lambda abstraction type language limiting leads awkward programming exercises 
propose extend haskell type language suitably restricted notion lambda abstraction 
main problems remain downwards compatible haskell keep type inference decidable 
add unrestricted lambda abstraction type inference rely unification simply typed lambda terms higher order unification 
known decidable subclasses problem instance pattern unification generalizations thereof bounded higher order unification 
subclasses implementing logic programming languages elf descendants theorem provers notably isabelle 
unfortunately subclasses mentioned really suited type inference demonstrate section 
technically reports results 
define restricted simply typed lambda calculus suitable type language extended haskell 
define henkin model prove function type model inhabited injective functions 
required downwards compatibility 
define guided higher order unification prove soundness completeness unification rules 
unfortunately currently rely heuristic guarantee termination procedure 
subsections exhibit programming problems motivate lambda abstraction type language 
discuss problems existing higherorder unification procedures non deterministic recall haskell approach explain approach informally 
section starts formal treatment 
introducing notation define syntax language section semantics type level language section sets injective functions 
stating properties define guided higher order unification section prove soundness completeness rules 
briefly discuss termination issues section sketch extension milner algorithm system section 
section evaluates proposal reviewing motivating examples discussing limitations 
discuss related section conclude 
completed prototype implementation performed preliminary experiments 
particular examples checked 
implementation builds jones typing haskell haskell 
implementation higher order unification inspired nipkow 
assume familiarity haskell 
refer haskell specified standard extensions haskell implementations 
functors type class functor expresses essence categorical concept functor specifying action functor function type functor map function called fmap transforms function type function type type class definition formalizes 
class functor fmap parameter type constructors fact functors example type constructor maps type type lists elements type type constructor maps type type elements just type instance declarations illustrate map functions functors 
instance functor fmap fmap xs xs instance functor fmap fmap just just concept functor common usual notion map sets higher level 
commonality fact identity functor maps type composition functors functor 
unfortunately concepts readily available haskell 
cases additional data structures introduced provide names identity functor composition operator 
suitable definition identity functor 
data id id instance functor id fmap id id composition operator requires special feature haskell 
type variables may just range types functions types functions functions types 
definitions sense 
data comp comp instance functor functor functor comp fmap comp comp fmap fmap possible write functions composable functors functor identify definitions awkward forced provide names simple identity function function composition 
life easier poor programmer define similar instances functor having introduce data types id comp wish write code instance functor lx fmap instance functor functor functor lx fmap fmap fmap named identity function named composition operator employ anonymous functions lambda expressions type language 
contravariant functors accepted lambdas type language readily identify applications 
example function type constructor functor second result parameter fact easily expressed standard instance declaration prefix notation infix operator instance functor fmap known contravariant functor action mapping exchanges domain range argument 
course concept captured type class 
class unfortunately haskell possible function type constructor instance possible parameter 
lambda expressions type language turns easy 
instance lx real world example wash cgi reader tempted rate motivation academic exercise real world example taken wash cgi embedded domain specific language server side web scripting 
context need perform task known kind lifting generic programming community 
roughly spoken essence lifting pull type parameters contexts 
features wash cgi provides means construct typed interactions follows 
programmer constructs html form combinator inputfield construct typed input fields 
combinator submit specifies action taken form submitted submit button 
example demo run ask demo text enter number awkward impose performance penalty 
submit echo inputfield int valid cgi value input echo text show important point evaluation inputfield creates handle input field type inputfield int invalid 
submit combinator type submit inputfield int invalid inputfield int valid cgi validates input field checks input field contains number passes function processes form submitted 
different kinds input fields selections boxes combinator submit overloaded follows submit inputhandle invalid valid cgi class inputhandle instances input fields listed 
example instance inputhandle inputfield 
class constraint inputhandle variable ranges type constructors kind 
evident instance declaration inputfield applied type argument declared 
consider case want pass pair handles processing function submit 
unfortunately results strange type error message haskell 
workaround programmer invent suitable lifted datatype instance inputhandle class data instance inputhandle inputhandle inputhandle 
reason having invent follows 
apply submit necessary unify argument type submit type submit inputhandle invalid valid cgi inputfield int invalid inputfield char invalid type checker solve equation invalid inputfield int invalid inputfield char invalid equation solved order unification basis haskell type inference 
situation remedies 
perform kind lifting explicitly introducing type shown 
consider higher order unification type checker 
fact higher order unification proceed substituting 
fresh type variables called imitation step 
library designer 
higher order unification 
applying substitution simplifying 
invalid leads invalid invalid inputfield int invalid inputfield char invalid decomposed invalid inputfield int invalid invalid inputfield char invalid imitation substitute inputfield fresh type variables equation obtain inputfield invalid invalid inputfield int invalid conclude standard steps higher order unification imitation int projection completely reduce equation 
second equation reduced analogously 
analogous problems arise try pass input handles list input handles submit submit may addressed analogous manner pairs introducing explicit lifting types fl done current version wash cgi higher order unification type checker 
feel explicit lifting types forced haskell particularly inappropriate embedded domainspecific language wash cgi 
experts program problem introducing specialized wrapper data types enclosing input fields suitable wrappers 
argue inconvenient leads obscure programs hard explain non expert users intended customers wash cgi 
proposed extension explain possible directly haskell standard data structures pairs lists 
higher order unification anyway 
preceding subsections hinted higherorder unification type checker 
able discuss pros cons higher order unification type checking purposes give short informal explanation higher order unification subsection 
comparison better known notion order unification helpful readers order unification underlying formal languages order terms signature function symbols set order variables 
unification problem pair terms solution substitution terms syntactically equal 
contrast language considered higher order unification simply typed calculus constants 
unification problem pair terms solution substitution free variables resulting terms normal form 
difference order unification clear cut substituted functions compose function symbols consist arbitrarily complex anonymous expressions 
terms usually compared respect equational theory likewise search solutions result equal terms terms normal form 
higher order unification undecidable hilbert tenth problem reduced exist algorithm known huet algorithm sound complete procedure higher order unification problems 
briefly sketch algorithm formulated set transformation rules working finite sets term equations 
step applicable rule chosen transform actual set equations new 
silently assume terms occurring equations long bh normal form term reduced normal form usual reduction rules expanded exactly reflect type structure 
decision rule applicable equation nature head symbols terms 
call term rigid head symbol constant bound universal variable call flexible head symbol free variable 
case equations flex flex pair decomposition rule applies xm tn xm tn decomposes different equations pair arguments creates new equation xm lx xm bound variables head symbol act similar constants 
case head symbols differ procedure fails immediately 
rules cover flex rigid pairs 
match rigid side substitution flex variable eventually result term head symbol rigid side 
possibilities symbol may come substitution free variable may introduce symbol called imitation 
equations xk tn xk tm substituted preliminary solution xn xn 
gm xn gm fresh variables substituted 
possibility needed symbol comes arguments projection rule handles case applied substitution projects arguments head position xn xi xn 
gj xn number arguments xi determined type 
clearly kind non deterministic choice flex rigid pair rule apply 
provided exists constant kind know flex flex pair solution equation xk tn xk tm solved substituting xn xm kind rules successively applied flex flex pairs remain 
higher order unification won argue full higher order unification undecidable introduces non determinism produce useful results 
hand pattern unification decidable unitary restrictive intended applications 
need power higher order unification restrict non determinism providing guidance algorithm 
set investigate guided higher order unification 
exhibit problems higher order unification reconsider example unification subsection 
number simplification steps imitation decomposition imitation arrived equations invalid int invalid invalid solved imitation int projection case imitation invalid 
suppose start inputfield int invalid inputfield char invalid type variable 
steps previous subsection go point equations reached int invalid point desired choice unify invalid ignore argument imitation int projection choice possible choices choosing projection equations fails immediately point view unification algorithm choices look equally plausible 
algorithm way telling imitation projection desired 
see higher order patterns restrictive purposes sufficient consider term invalid occurs example 
term free variable constant argument invalid 
pattern relaxed pattern arguments free variables restricted distinct bound variables haskell look definition haskell hint done 
ruling lambdas type language haskell reduces unification problem order 
case flex rigid pair haskell chooses imitation 
kind flexible head variable match kind constructor prefix suitable kind constructor term substituted head variable 
prefix exists unification fails 
flex flex pairs treated way flex rigid pairs 
decomposition applies flex flex case 
proposal approach restrict syntax lambda terms projection terms ruled 
unification algorithm 
kinding judgement choose imitation case flex rigid pair 
restrict calculus church li terms terms lambda abstraction variables occur free 
restriction enables deal flex flex pairs way haskell decomposition applicable flex flex pairs identical head variable imitation style treatment unconstrained flex flex pairs sound 
remains consider case flex flex flex rigid pairs head variable restricted type class constraint 
restricted flex rigid case general substitution huet imitation rule instance declaration predicate 
way avoid subsequent choices imitation projection simply instance declaration 
flex flex pairs restrictions head variables different simplified spot deferred kept constraints customary higher order unification 
deferral departs haskell practice leads different inferred types necessary instance substitution restricted head variable chosen guidance rigid term 
program level expect flex flex constraints resolved give rise typing errors top level programs usually polymorphic 
unresolved flex flex constraints point give rise unresolved overloading errors 
formal type system developing formal system fix notation 
write 
abbreviate lists syntactic phrases 
furthermore fold nested function application corresponding kind lambda calculus employ standard notation definitions barendregt fv free variables syntactic identity 
employ barendregt variable convention 
functions total set theoretic functions noted denotes set functions sets write lx function final note notation variables constructors constants haskell constructors capitalized variables written lower case standard logic programming exactly opposite 
decided break standards distinguishing syntactic categories name capitalization 
range constructors range type variables 
haskell type language type language haskell generated grammar type variable constant type constructor type application 
language typed rules simply typed lambda calculus 
avoid confusion types types called kinds kinds generated grammar kind base kind categorizes types 
kind categorizes type constructor functions map constructor kind kind contains known kinding rules 
convenience kinded type variables drop kind annotation kind important 
kinded variables term exactly kind write kind 
unification type language boils syntactic term unification aka kind preserving unification possible extend ml style type inference algorithm support higher order types retaining soundness completeness properties 
general case extension higher order polymorphism requires higher order unification type inference algorithm undecidable 
syntax type language extends haskell type language restricted notion lambda abstraction 
restrictions sufficient retain important features kind preserving unification 
distinguish variables may substituted unification variables introduced lambda abstraction 
call variables substituted unification existential variables ranged variables introduced lambda abstraction universal variables ranged existential variables occur free type term universal variables may occur free bound judgement restricts judgement set lambda terms normal form shown 
restricted lambda terms defined set head symbol constant existential variable universal variables occur free corresponding lambda bodies church calculus 
stay inside restricted language define substitution performs reduction fly 
standard practice literature logical frameworks give illustrative cases definition substituting lambda expression existential variable 
definition takes advantage assumption flexible functions fully expanded universal variables appear function position 
lx ly ly ly ly ly ly due restriction universal variables substitution create redex 
top type language constrained type scheme form note connection unification mixed prefix 
distinction avoided treatments higher order unification considering terms long bh normal form 
free bound variables immediately apparent 
var ex var univ const app lambda universal variable lam xm fv lam xm fv 
kinding judgement restricted lambda calculus type term kind type variables constrained unification problem 
set class predicates name type class existential variables set equations type terms 
program triple classes instances classes set class declarations form class fv 
defines class named introduces type variable ranges members class defines type scheme single member value instances set instance declarations form inst lx free variable occurs fv form 
declaration defines instance class type starting type constructor arguments restricted type class predicates 
pair instance declaration 
expression value level defined term variables lv lambda abstraction application expression restriction instance declarations simple generalization haskell restriction 
time ignore expression instance declarations declares member value 
purposes type inference interested set instances typing environment generated classes iff class classes semantics interestingly need define semantics type language 
able prove soundness completeness transformation rules unification algorithm purely syntactical reasoning 
semantics terms henkin model 
underlying mathematical structures henkin models typed applicative structures definition 
typed applicative structure triple app const kind indexed family sets app indexed family application operators app const constant interpretation functions maps constant appropriate set henkin model typed applicative structure satisfy additional criteria extensional certain defined meaning function ajk environment model condition 
formally definition 
henkin model typed applicative structure app const extensional app mapping meaning function js kkh defined total function environments partial functions variables dom dom dom need definitions state intended henkin model 
need strong notion semantic values different 
kind indexed relation captures notion 
usual equality base types 
function types differs usual pointwise notion inequality 
definition 
app const typed applicative structure 
kind indexed binary relation strongly different defined inductively 
iff js kkh js kkh const js kkh app js kkh js kh js lx kkh unique th 
app js kkh 
environment semantics iff 
definition 
function strongly injective 
intended henkin model define typed applicative structure app const set closed terms kind 
set strongly injective functions strongly injective 
app function application 
const curried term formation operator constant symbol consider examples illustration write function type constructor prefix operator int bool float list int list bool list float pair int int pair int bool int int int bool lt list ls llt pair ls llt const int int const list lt list const pair ls llt pair lemma 
const strongly injective 
accept definition henkin model need sure unique th 
app js kkh exists prove strongly injective 
fortunately comes free theorem 
function deal injective unification apply decomposition rule limitation 
brief decomposition rule variable say requires 

iff 
direction right left follows directly compatibility equivalence direction left right requires attention 
fact valid injective function 
unfortunately hard prove directly functional term injective possible prove stronger claim strong injectivity 
theorem 
terms holds judgement holds fv fv strongly injective exactly true fv fv proposition 
typed applicative structure henkin model turn solving equations guided higher order unification guided higher order unification simplifies constrained unification problem need preliminaries give definition solution 
instance satisfaction relates set instance declarations instances predicate applied type instances holds exactly collected instance declarations indicate type belongs class particular type constructor instance instance declaration inst lx instances head symbol argument declaration corresponding subterm unconstrained corresponding subterm arbitrary term kind variables mentions corresponding subterm instance leaving flex flex pairs unresolved appropriate speak pre unification 
strip lx lx decomp flex rigid tm kind fv flex rigid inst lx fv flex flex iff flex flex tm kind fv 
guided higher order unification side conditions enforced auxiliary judgement instances definition 
instance satisfaction relation instances defined inst lx instances instances instances lx instances kind kind instances instances ly instances definition 
substitution solution constrained unification problem written iff holds instances 
rewriting system specifies guided unification procedure 
configuration rewriting system triple 
set predicates existential variables 
set equations 
substitution existential variables terms 
rules interpreted similarly stage nipkow article 
rules closed symmetry relation 
strip rule bound variables sides assumed equal due conversion 
rule fails side start lambda term implicitly expanded 
decomp rule constants may universal variables customary higher order unification case arise attempt unify terms different head symbols fails immediately reflected rules 
equations head symbol existential variable head symbol constant handled rules flex rigid flex rigid respectively 
rule handles cases class constraints restricting free variable cases mimic current behavior haskell free variable gets substituted constant right hand side applied leading arguments depending kinds involved 
rule applies kinds match free variable occur prefix right hand side 
rule guide unification process determining substitution free variable constraint free variable instance declarations predicate substitution side conditions instance declarations head symbol selection deterministic 
equation existential variable side handle equation definitely decide simplify 
case variables applied number arguments variable constrained exactly set predicates different number arguments constraints 
case flex flex unify variables decompose terms case flex flex mimic haskell flex rigid rule 
unification rules sound complete change set solutions constrained unification problem 
lemma 
transformation holds iff 
termination study proof lemma reveals condition fv needed proving soundness completeness rule flex rigid 
side condition necessary condition rules terminate 
suppose rule flex rigid defined just rule flex rigid condition fv 
configuration leads non termination presence instance declaration inst lx configuration rewrites flex rigid step lx resulting predicate equation just renamings original ones rule flex rigid applies 
problem substitution introduces variable matches step constant introduced substitution 
restriction sufficient ensure termination 
reason occur check applied usual obvious way 
decompositions delayed cf 
rules flex flex constrained flex rigid match leads partial substitution flex rigid occurrence variable substitution need obvious point 
reason relying heuristic unification procedure 
roughly heuristic marks symbol variable constant original set equations unique label labels equation empty set 
rule applies newly generated equations inherit label originating equation 
exception flex rigid add pair label variable constant set newly generated equations 
fresh variables generated rule application inherit label variable rewriting stops reporting failure unify pair set label pairs equation triggering rule flex rigid 
type inference type inference rules straightforward adaption milner algorithm extended type language 
algorithm formulated syntax directed typing judgement rule states certain form expression considered typing assumptions type constraints free type variables satisfy considering certain substitution var lam rules standard 
app rule uses guided higher order unification procedure order unification algorithm 
rule uses generalization procedure gen purpose generate type scheme generalizing free variables occurring free type assumptions adding constraints affected free var new lam new lx app new gen 
type inference variables 
specified follows gen fv fv fv fv addition implementation performs predicate normalization generalization 
definition predicate normalization 
norm norm inst lx instances norm ly norm predicate normalization terminates due syntactic restriction instance declarations 
normalization finds suitable instance declaration scope instances decomposes argument predicate recursively tries normalize arguments 
suitable instance declaration equivalent existential variable predicate returned change 
evaluation section reconsider examples section light proposed extensions 
example yields typing remaining flex flex pairs 
functors example desire express identity functor functor composition instances functor class 
turns model identity functor lx term model functor composition directly 
little bit foresight functor instances composable 
idea write instance functor functor lx fmap xs fmap xs instance functor functor lx instances section 
identity type id required start stack composable functors need explicit composition operator 
contravariant functors example motivation section function arrow abstracted parameter works desired 
instance lx wash cgi instance declarations class inputhandle may written follows instance inputhandle inputfield instance inputhandle 
defining data type fl instance inputhandle inputhandle 
defining data type instance inputhandle inputhandle inputhandle 

lifting possible instance inputhandle 
case data type avoided data stands constant function 
fit framework li term 
flex flex pairs show typing remaining flex flex pairs occur example 
consider algebraic data type associated function fun data char kind fun fmap ord type constructor abstracts types result applying type constructor type characters 
function fun takes value instance type constructed maps library function ord fmap 
simplicity assume typings fmap functor ord char int typing fun inferencer considers pattern left hand side declaration 
result type assumption pattern variable char inferring type body function fun consider function application fmap ord get unification problem functor char int rules decomp flex rigid get fmap ord functor char int type inference second function application fmap ord leads new unification problem functor char int char simplifies functor char char int decomp rule 
second equation eliminated flex flex remaining flex flex pair sure necessarily type constructor 
resulting type fun fun functor char char int discussion places framework fall short expectations include constant functions projections include identity functions 
additions desirable defer parts unification lead ambiguities 
addition constant functions projections complicates applicability rules flex flex pairs 
rules hold strongly injective functions sure head variable may instantiated constant function 
addition sure argument term disappears example term appears argument variable may instantiated constant function 
addition identity functions introduces ambiguities level instance declarations 
typical way introducing identity example functor instance functor lx 
declaration play role default instance declaration 
example consider equation tree int functor absence instance tree default instance obtain equation tree int 
worthwhile considering extension 
refrained doing reasons hand kind overlapping instances counterpart standard haskell hand resulting unification procedure deterministic anymore 
omitted subclasses definitions 
easy add price complicating definition instance satisfaction definition usual way insisting corresponding terms instance declarations match 
easy check decidable pattern unification instance terms happen higher order patterns 
related closely related analyzes algorithms equality unification presence notational definitions 
authors introduce notion strictness lambda term lx enables prove strict term behaves injective function reduction 
definition term strict equality terms head symbol decided just checking arguments equality avoiding need expanding definition similar improvement possible unification algorithm 
notion strongly injective function motivated desire strong decomposition rule unification algorithm flex flex 
interesting compare notion strictness strong injectivity may straightforward strictness defined syntactically strong injectivity defined semantically recourse specific model 
type inference polymorphic typing discipline type reconstruction algorithm key features number successful functional programming languages ml haskell 
starting algorithm hindley milner variety extensions proposed implemented 
biggest boost come parametric overloading suggested number authors 
proposal modified integrated programming language haskell form type classes 
type class inductively defined set types 
type class qualification class constraint restrict polymorphic type members particular class classes 
number works tried explain type inference haskell principles 
subsequently extensions investigated 
thesis jones investigated qualified types 
qualified types instantiated range interesting type systems type classes record types subtyping 
paved way explorations 
multi parameter type classes generalize type classes sets types inductively defined relations types 
unfortunately come non trivial ambiguity problems render virtually useless 
problem prompted jones add functional dependencies multiparameter type classes 
addition resolves ambiguity problems arising practice 
semantic foundation laid earlier simplification improvement type class constraints type reconstruction 
line type classes generalized constructor classes 
constructor class defines set type constructors 
part haskell language basis convenient programming monads turn essential write haskell programs type inference constructor classes implemented order sorted unification 
higher order unification point give brief impression complicated research area 
information may dowek survey article 
higher order unification considered huet 
huet showed general problem undecidable gave semi algorithm may terminate solution 
undecidability result strengthened include second order terms 
miller defined higher order patterns unification problem decidable unitary regardless order terms 
monadic case constant symbols unary unification decidable second order terms undecidable higher orders 
matching believed decidable concrete results exist second third order problems 
inspired miller pattern unification generalization prehofer 
implementation nipkow transformation rule description pattern unification readily implementable functional version proved helpful haskell implementation avoid complications 
construction extension haskell type class system restricted notion lambda abstraction straightforward task 
achieved define system types number interesting examples possible price awkward programming 
extension conservative sense programs typeable haskell typeable extended language 
downside type schemes get complicated constraints include remaining flex flex pairs head variable carries predicate 
contrived cases involve data structures arrow kinded type parameters extended language infers types constraints 
barendregt 
lambda calculus syntax semantics 
north holland 
dowek 
second order pattern matching algorithm cube typed calculi 
proceedings mathematical computer science lecture notes computer science pages 
rapport de recherche inria 
dowek 
third order matching decidable 
proceedings ieee symposium logic computer science 
ieee computer society press june 
dowek 
higher order unification matching 
robinson voronkov editors handbook automated reasoning volume chapter pages 
north holland 
duggan cormack 
kinded type inference parametric overloading 
acta inf 
farmer 
unification algorithm second order monadic terms 
annals pure applied logic 
farmer 
simple second order languages unification undecidable 
theoretical comput 
sci sept 
goldfarb 
undecidability second order unification problem 
theoretical comput 
sci feb 
haskell non strict purely functional language 
www haskell org definition dec 
hindley 
principal type scheme object combinatory logic 
transactions american mathematical society 
huet 
unification algorithm typed calculus 
theoretical comput 
sci 
jones 
system constructor classes overloading implicit higher order polymorphism 
arvind editor proc 
functional programming languages computer architecture pages copenhagen denmark june 
acm press new york 
jones 
qualified types theory practice 
cambridge university press cambridge uk 
jones 
functional programming overloading higher order polymorphism 
advanced functional programming volume lecture notes computer science pages 
springer verlag may 
jones 
simplifying improving qualified types 
peyton jones editor proc 
functional programming languages computer architecture pages la jolla ca june 
acm press new york 
jones 
typing haskell haskell 
meijer editor proceedings haskell workshop number uu cs technical reports 
ftp ftp cs uu nl pub ruu cs cs pdf 
jones 
type classes functional dependencies 
smolka editor proc 
th european symposium programming number lecture notes computer science pages berlin germany mar 
springerverlag 
kaes 
parametric overloading polymorphic programming languages 
ganzinger editor proc 
nd european symposium programming number lecture notes computer science pages 
springer verlag 
kaes 
type inference presence overloading subtyping recursive types 
proc 
acm conference lisp functional programming page san francisco california usa june 
miller 
unification simply typed lambda terms logic programming 
furukawa editor eighth international logic programming conference pages paris france june 
mit press 
miller 
unification mixed prefix 
journal symbolic computation oct 
milner 
theory type polymorphism programming 
comput 
syst 
sci 
milner tofte harper macqueen 
definition standard ml revised 
mit press 
mitchell 
foundations programming languages 
mit press 
nadathur miller 
overview prolog 
kowalski bowen editors proceedings fifth international conference symposium logic programming pages seattle 
alp ieee mit press 
narendran 
remarks second order unification 
technical report university calgary july 
nipkow 
functional unification higher order patterns 
proc 
th annual ieee symposium logic computer science pages 
ieee computer society press 
nipkow prehofer 
type checking type classes 
proceedings acm sigplan symposium principles programming languages pages charleston south carolina jan 
acm press 
nipkow snelting 
type classes overloading resolution order sorted unification 
hughes editor proc 
functional programming languages computer architecture number lecture notes computer science pages cambridge ma 
springer verlag 
paulson 
isabelle theorem provers 
odifreddi editor logic computer science pages 
academic press 
peyton jones jones meijer 
type classes exploration design space 
launchbury editor proc 
haskell workshop amsterdam netherlands june 
yale university research report yaleu dcs rr 
pfenning 
partial polymorphic type inference higherorder unification 
acm conference lisp functional programming pages snowbird utah 
acm press 
pfenning 
logic programming lf logical framework 
huet plotkin editors logical frameworks pages 
cambridge university press 
pfenning 
algorithms equality unification presence notational definitions 
altenkirch reus editors types proofs programs number lecture notes computer science pages germany mar 
prehofer 
decidable higher order unification problems 
automated deduction cade th international conference automated deduction 
springer 
schmidt schau schulz 
decidability bounded higher order unification 
technical report frank universitat frankfurt 
thiemann 
wash cgi server side web scripting sessions typed compositional forms 
practical aspects declarative languages proceedings fourth international workshop padl number lecture notes computer science pages portland usa jan 
springer verlag 
wadler blott 
ad hoc polymorphism ad hoc 
proc 
th annual acm symposium principles programming languages pages austin texas jan 
acm press 
web authoring system haskell wash 
www informatik uni freiburg de thiemann haskell wash mar 
wolfram 
clausal theory types 
cambridge tracts theoretical computer science 
cambridge university press 
