scalable approach conditioned slicing danicic college university london london se nw united kingdom mark harman brunel university ub ph united kingdom chris fox university essex park colchester sq united kingdom ward software technology research lab de university gateway leicester le bh united kingdom keywords conditioned slicing fermat program comprehension 
conditioned slicing applied reverse engineering problems involve extraction executable fragments code context criteria interest 
introduces conditioner wide spectrum language wsl 
symbolic executor prunes symbolic execution paths predicate reasoning system uses fermat simplify transformation place conventional theorem prover 
show combination pruning reasoner leads scalable approach conditioning 
program slicing source code extraction technique allows reverse engineer extract executable subprogram slicing criterion 
original formulation slicing static 
slicing criterion contained information input program 
slicing created different paradigms slicing including dynamic slicing input known quasi static slicing input prefix known 
way slicing produces executable subprogram criterion interest gives rise applications re engineering 
example slicing suggested tool integration different versions program 
forms part approaches decompilation put forward part tool assisted approach program comprehension :10.1.1.13.6694
concerned variation slicing called conditioned slicing 
conditioned slicing forms theoretical bridge extremes static dynamic slicing 
augments traditional slicing criterion condition captures set initial program states interest 
additional condition simplify program applying traditional static slicing algorithm 
pre simplification called conditioning achieved eliminating statements contribute computation variables interest program executed initial state satisfies condition 
conditioned slicing extends applicability traditional slicing problems reverse engineering additional ability express conditions allows reverse engineer refine code extraction conditions interest 
example canfora show form conditioning isolate reusable functions large monolithic chunks code 
de lucia show conditioned slicing part approach initial code comprehension typically precedes reverse engineering tasks 
cimitile show conditioned slicing related techniques extract reuse functions reverse reengineering 
conditioned slicing criterion triple condition interest components static slicing criterion 
shall concerned conditioning phase conditioned slicing criterion interest simply similar approach called constrained slicing introduced field 
condition 
condition system simply attempt remove infeasible paths useful step 
introduces conditioning system implemented wide spectrum language wsl 
wsl language fermat transformation system previously part transformation approach reverse engineering 
chose wsl allow combine conditioning slicing amorphous slicing 
ultimately allow produce amorphous conditioned slicer 
wsl uses algol syntax additional facilities wide spectrum allow transformations expressed wsl 
space prevents full explanation wsl syntax semantics 
example wsl way conditioning identifies sub programs consider taxation program 
contains fragment program encodes uk tax regulations tax year april april 
person personal allowance amount un income 
size personal allowance depends status person encoded boolean variables blind married integer variable age 
example condition age age income blind married conditioning program identifies statements appear boxed 
useful allows reverse engineer isolate sub computation concerned initial condition interest 
sub program extracted compiled executed separate code unit 
guaranteed mimic behaviour original initial condition met 
conditioning program conditioned slice obtained applying static slicing conditioned program 
example conditioned slice variable tax condition depicted shading lines conditioned program identified static slicing 
describes system focusing approach symbolic execution determining outcome symbolic predicates 
features designed allow technique scale readily larger systems 
principal contributions approach symbolic execution exploits simplification embodied conditioning prune symbolic paths created speeding analysis 
wsl version program previously 
new implementation reasoning symbolic states path conditions introduced uses fermat simplify transformation decide propositions 
initial empirical results show approach scales reasonably experiments fit quadratic curves 
rest organized follows 
section introduces integrated approach symbolic execution combines conditioning symbolic execution prune paths symbolic execution proceeds 
section describes fermat simplify transformation achieve form super lightweight theorem proving required determine outcome symbolic predicates symbolic conditioned state pair 
section presents results empirical investigation performance approach section concludes directions 
symbolic execution tool uses phase approach 
symbolically execute propagate assertions program possible 
produce conditioned program eliminate statements executed condition 
perform static slicing steps integrated single symbolic executor conditioner 
allows conditioning prune execution traces considered symbolic execution 
slicer handles side effects procedure calls details scope conditioning program need symbolic state set path conditions represents sequences conditions true order symbolic state pertain point 
symbolic paths built symbolic executor moves program 
typically feasible paths symbolic state call contains set pairs 
pair consists symbolic path condition symbolic state 
formally program defined pair corresponds conditioned state 
boolean expression representing conditions note referee separate submitted wcre describes slicer way handles side effects 
age personal age personal personal fi fi age income personal income personal personal personal income fi fi blind personal personal fi married age pc married age pc married widow pc pc fi fi fi married age income pc income pc pc pc income fi fi income personal income income personal income tax pc rate income income pc income tax tax rate income income tax tax income rate fi fi fi key original program unboxed lines code conditioned program boxed lines code condition age age income blind married conditioned slice shaded boxed lines code 
fragment taxation calculation program wsl possible path statement taken 
represents symbolic state variables path 
think function maps program variables symbolic value expressions variables program symbolic values element pair conditions second element true 
symbolic execution starts empty symbolic state null path condition interpreted universally valid true proposition 
order condition program define functions condition update air eval expression state expression prove boolean expression ft function condition takes program produces program results conditioning respect 
condition top level function condition program 
function takes program returns new results symbolically executing 
function defined terms function individual pairs called update 
order define condition require auxiliary functions eval prove 
eval takes expression state returns expression results evaluating symbolic state 
obtained substituting variables mentioned symbolic values denote 
function prove denotes theorem prover heart conditioner 
component conditioner 
uses fermat simplify transformation implement super lightweight theorem prover manner described section 
section prove function treated black box takes symbolic boolean expression inequalities integer expressions returns possible values 
returned value indicates proved true 
returned value indicates proved false 
returned value indicates proved true false 
course fact boolean expression proved true false provide information provable booleans system conceivable replacement fail decide 
approach safe prove correctly decide subset statements tautologies contradictions 
statement set post corresponding set prior conditioned state formed union update describe conditioning subset wsl includes sufficient features explain approach 
conditioning sequence statements conditioning sequence statements defined steps df condition df condition condition conditioning assignment statement df condition function defined follows condition df set update post conditioned state pairs corresponding prior conditioned state formed adding symbolic state fact variables left side assignment statement bound value expression right side variables occurring expression replaced current symbolic values respective state 
variable occurring expression symbolic value relevant state assigned unique symbolic constant value skolem constant update function defined follows update df fx eval assignment function update function defined df fhv ei hv ei hv ei hv conditioning statement df fi 
set prior conditioned state post conditioned state conditioned statement defined 
define new path condition say true false path conditions respectively df eval df eval set update post conditioned state corresponding prior conditioned state df eval provably true false follows prove update df update prove update df update update df update update condition defined case provably true provably false follows prove condition df condition prove condition df condition condition df condition condition fi fi original program conditioned program 
conditioning statement illustrates basic example analysis statement program containing assignments followed statements 
set conditioned states execution initial assignments rue predicate rue sent simplifier simplified true 
result false branch statement removed rue nested predicate rue sent simplifier simplified false 
result true branch nested statement removed rue rue simplified false resulting removal true part program statement rue conditioning statement df od df eval cases consider prove update df negation condition added copy current conditioned state pairs replacing variables symbolic values corresponding symbolic states 
prove update df update eval eval symbolic state start final iteration 
symbolic state obtained final iteration 
loop body executed 
loop terminates final execution loop may may executed 
general executed times 
easy obtain precise symbolic representations variables assigned values previous iterations loop 
approach proceeds follows 
copy prior conditioned state pairs added fact condition initially true 

conceptually symbolically executed just context conditioned state pairs result variables assigned values previous iterations loop treated previously assigned values unique symbolic constants 

loop condition true start start final iteration false final iteration conditioned state pairs result final iteration algorithm adds loop condition evaluated symbolic states final iteration negation loop condition evaluated final iteration 
union conditioned state result previous cases formed 
conditioned statement condition defined provably false follows od fi print print od od fi original program conditioned program 
conditioning loop prove condition df skip condition df od condition eval illustrates effect conditioning loop 
conditioning assert statement df fbg fbg assertion statement 
statement acts partial skip statement thought equivalent skip od condition true statement terminates immediately changing variables fails terminate 
assert statement helpful practical point view insert conditioned slicing criterion directly program program code 
assert functions condition defined follows update prove prove condition skip prove abort prove super lightweight theorem proving fermat simplify transformation having parser major reason implementing conditioned slicer available transformations fermat 
ability simplify conditions important conditioned slicer 
obvious solution existing theorem prover previous approaches conditioned slicing approach suggested 
unfortunately theorem prover impose large overhead memory cpu time 
theorems relevance typically involve inequalities arithmetic expressions 
may techniques appropriate kinds theorems general purpose theorem provers 
technique adapted built simplifier fermat workbench 
advantages disadvantages fermat expression condition simplifier design aimed providing fast efficient simplification common expressions conditions occur transformation providing fast response expressions conditions easily simplified 
scalability requirements expression condition simplifier fermat transformation system 
efficient especially small expressions 

easily extendible 
difficult attempt simplify possible expressions capable simplification 
content lessthan complete implementation important able add new simplification rules necessary 
easy prove correct 
clearly faulty simplifier generate faulty transformations incorrect code 
simplifier easily extended important prove correctness extended simplifier equally easily 
empirical validation considered classes programs sn 
programs class formed program fragments multiple repetitions fragments 
gives systematic approach testing scalability 
programs class generated fragments shown multiple repetitions second fragment 
set programs tests conditioning process sequential statements conditions testing equality arithmetic expressions opposed inequalities 
paths repetitions second fragment 
class programs generated manner fragments repeating second fragment 
conditions statements involve inequalities logical 
furthermore class programs involves greater symbolic evaluation class program variables get updated continually example class variables assigned constant numeric values example 
paths repetitions second fragment alternate repetition true false vice verse 
sn class programs generated program fragments inserting multiple copies middle program fragment branch previous statement adding appropriate number fi third fragment 
produces arbitrarily large nesting statements 
class formed exactly way initial fragment excluded 
difference program classes simplification performed sn path programs uniquely determined 
classes performance tested presence nested statements best worse case scenarios 
results running set programs class shown figures 
results obtained dual pentium iii mhz mb ram running linux 
graphs show time taken seconds condition program class plotted size program lines code 
squares regression performed data sets models linear model bx exponential model ae bx power law model ax quadratic model bx cx fi fi fi 
style program fi fi 
style program quadratic model degrees freedom gave best fit data 
models significantly worse models degree freedom 
squares quadratic polynomials coefficient determination analysis complex semantically intricate conditioning unreasonable expect linear near linear performance quadratic complexity appear best hope 
conditioning involves theorem proving kind symbolic execution computationally expensive 
fortunately conditioning conditioned slicing typically applied programs unit level example support detailed understanding unit level testing aid unit level reuse code extraction tool 
applications quadratic performance acceptable technique appears scale unit level 
fi fi 
nested program time seconds size program loc 
performance class programs squares quadratic polynomial 
size program loc 
performance class programs squares quadratic polynomial 
size program loc 
performance sn class programs squares quadratic polynomial 
time seconds size program loc 
performance class programs squares quadratic polynomial 
introduced conditioner wide spectrum language wsl 
previous approach involves symbolic execution reasoning symbolic predicates determine true false information built symbolic paths traversed 
previous approaches system integrates reasoning symbolic execution single system 
empirical analysis approach suggests reasonable conditioning tasks algorithm polynomial size program conditioned 
agrawal horgan 
dynamic program slicing 
acm sigplan conference programming language design implementation pages new york june 
binkley harman smith 
empirical study amorphous slicing program comprehension support tool 
th ieee international workshop program comprehension iwpc pages limerick ireland june 
ieee computer society press los alamitos california usa 
canfora cimitile de lucia 
conditioned program slicing 
harman gallagher editors information software technology special issue program slicing volume pages 
elsevier science 
canfora cimitile de lucia 
software conditions 
international conference software maintenance icsm pages victoria canada sept 
ieee computer society press los alamitos california usa 
cifuentes 
intraprocedural static slicing binary executables 
ieee international conference software maintenance icsm pages 
ieee computer society press los alamitos california usa 
cifuentes gough 
decompilation binary programs 
software practice experience july 
cimitile de lucia munro 
identifying reusable functions specification driven program slicing case study 
proceedings ieee international conference software maintenance icsm pages nice france 
ieee computer society press los alamitos california usa 
cimitile de lucia munro 
qualifying reusable functions symbolic execution 
proceedings nd working conference reverse engineering pages toronto canada 
ieee computer society press los alamitos california usa 
danicic fox harman hierons 
conditioned program slicer 
ieee international conference software maintenance icsm pages san jose california usa oct 
ieee computer society press los alamitos california usa 
de lucia munro 
understanding function behaviours program slicing 
th ieee workshop program comprehension pages berlin germany mar 
ieee computer society press los alamitos california usa 
field ramalingam tip 
parametric program slicing 
nd acm symposium principles programming languages pages san francisco ca 
harman danicic 
amorphous program slicing 
th ieee international workshop program iwpc pages michigan usa may 
ieee computer society press los alamitos california usa 
harman hierons danicic fox 
pre post conditioned slicing 
ieee international conference software maintenance icsm pages florence italy nov 
ieee computer society press los alamitos california usa 
harman hu zhang munro 
amorphous slicing system combines slicing transformation 
st workshop analysis slicing transformation ast pages stuttgart oct 
ieee computer society press los alamitos california usa 
hierons harman fox 
conditioned slicing supports partition testing 
software testing verification reliability mar 
horwitz prins reps integrating non interfering versions programs 
acm transactions programming languages systems july 
korel laski 
dynamic program slicing 
information processing letters oct 
harman 
slice dynamic memory modelling case study 
th ieee annual computer software applications conference compsac oxford uk aug 
ieee computer society press los alamitos california usa 
appear 
venkatesh 
semantic approach program slicing 
acm sigplan conference programming language design implementation pages toronto canada june 
proceedings sigplan notices pp 
ward 
assembler migration fermat transformation system 
ieee international conference software maintenance icsm oxford uk aug 
ieee computer society press los alamitos california usa 
ward 
formal approach source code analysis manipulation 
st ieee international workshop source code analysis manipulation pages florence italy 
ieee computer society press los alamitos california usa 
ward 
program slicing fermat transformations 
th ieee annual computer software applications conference compsac oxford uk aug 
ieee computer society press los alamitos california usa 
appear 
ward bennett 
practical program transformation system 
working conference reverse engineering pages baltimore md usa may 
ieee computer society press los alamitos california usa 
weiser 
program slicing 
ieee transactions software engineering 

