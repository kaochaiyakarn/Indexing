packrat parsing simple powerful lazy linear time functional pearl bryan ford massachusetts institute technology cambridge ma lcs mit edu packrat parsing novel technique implementing parsers lazy functional programming language 
packrat parser provides power flexibility top parsing backtracking unlimited lookahead guarantees linear parse time 
language defined ll lr grammar recognized packrat parser addition languages conventional linear time algorithms support 
additional power simplifies handling common syntactic idioms widespread troublesome longest match rule enables sophisticated disambiguation strategies syntactic semantic predicates provides better grammar composition properties allows lexical analysis integrated seamlessly parsing 
despite power packrat parsing shares simplicity elegance recursive descent parsing fact converting backtracking recursive descent parser linear time packrat parser involves fairly straightforward structural change 
describes packrat parsing informally emphasis practical applications explores advantages disadvantages respect conventional alternatives 
categories subject descriptors programming languages processors parsing programming techniques applicative functional programming mathematical logic formal languages grammars rewriting systems parsing general terms languages algorithms design performance keywords haskell memoization top parsing backtracking lexical analysis scannerless parsing parser combinators permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
icfp october pittsburgh pennsylvania usa 
copyright acm ways implement parser functional programming language 
simplest direct approach top recursive descent parsing components language grammar translated directly set mutually recursive functions 
top parsers turn divided categories 
predictive parsers attempt predict type language construct expect point looking ahead limited number symbols input stream 
backtracking parsers decisions speculatively trying different alternatives succession alternative fails match parser backtracks original input position tries 
predictive parsers fast guarantee lineartime parsing backtracking parsers conceptually simpler powerful exhibit exponential runtime 
presents top parsing strategy choice prediction backtracking 
packrat parsing provides simplicity elegance generality backtracking model eliminates risk super linear parse time saving intermediate parsing results computed ensuring result evaluated 
theoretical foundations algorithm worked linear time version apparently put practice due limited memory sizes computers time 
modern machines storage cost algorithm reasonable applications 
furthermore specialized form memoization implemented elegantly efficiently modern lazy functional programming languages requiring hash tables explicit lookup structures 
marriage classic neglected linear time parsing algorithm modern functional programming primary technical contribution 
packrat parsing unusually powerful despite linear time guarantee 
packrat parser easily constructed language described ll lr grammar languages require unlimited lookahead lr 
flexibility eliminates troublesome restrictions imposed parser generators yacc lineage 
packrat parsers simpler construct bottom lr parsers making practical build hand 
explores manual construction approach automatic construction packrat parsers promising direction 
packrat parser directly efficiently implement common disambiguation rules longest match followed difficult express unambiguously context free grammar implement conventional linear time additive multitive additive multitive multitive primary multitive primary primary additive decimal decimal 

grammar trivial language parsers 
example recognizing identifiers numbers lexical analysis parsing statements languages handling lambda expressions haskell inherently involve longest match disambiguation 
packrat parsers easily naturally composable lr parsers making suitable substrate dynamic extensible syntax :10.1.1.48.3355
lexical hierarchical analysis seamlessly integrated single unified packrat parser lexical hierarchical language features blended handle string literals embedded expressions literate comments structured document markup example 
main disadvantage packrat parsing space consumption 
asymptotic worst case bound conventional algorithms linear size input space utilization directly proportional input size maximum recursion depth may differ orders magnitude 
applications modern optimizing compilers storage cost parser greater cost subsequent processing stages 
cost may reasonable tradeoff power flexibility linear time parsing unlimited lookahead 
rest explores packrat parsing aim providing pragmatic sense implement useful 
basic familiarity context free grammars top parsing assumed 
brevity clarity presentation small excerpts example code included text 
examples described available complete working haskell code pdos lcs mit edu packrat icfp organized follows 
section introduces packrat parsing describes works conventional recursive descent parsing starting point 
section presents useful extensions basic algorithm support left recursion lexical analysis monadic parsing 
section explores detail recognition power packrat parsers comparison conventional linear time parsers 
section discusses main practical limitations packrat parsing determinism space consumption 
section presents experimental results demonstrate practicality packrat parsing real languages 
section discusses related section points directions exploration section concludes 
building parser packrat parsing essentially top parsing strategy packrat parsers closely related recursive descent parsers 
reason build recursive descent parser trivial language convert packrat parser 
recursive descent parsing consider standard approach constructing recursive descent parser grammar trivial arithmetic expression language shown 
define functions nonterminals left hand sides rules 
function takes takes string parsed attempts recognize prefix input string derivation corresponding nonterminal returns success failure result 
success function returns remainder input string immediately part recognized semantic value computed recognized part 
function recursively call functions order recognize nonterminals appearing right hand sides corresponding grammar rules 
implement parser haskell need type describing result parsing function data result parsed string noparse order type generic different parse functions producing different kinds semantic values result type takes type parameter representing type associated semantic value 
success result built parsed constructor contains semantic value type remainder input text type string 
failure result represented simple value noparse 
particular parser parse functions takes string produces result semantic value type int padditive string result int pmultitive string result int pprimary string result int string result int definitions functions general structure directly reflecting mutual recursion expressed grammar padditive 
calls pmultitive pmultitive 
calls pprimary pprimary 
calls padditive 
example padditive function coded follows primitive haskell pattern matching constructs parse additive precedence expression padditive string result int padditive alt additive alt case pmultitive parsed case case padditive parsed parsed alt alt alt additive alt case pmultitive parsed parsed noparse noparse compute result padditive compute value alt representing alternative grammar rule 
alternative turn calls pmultitive recognize expression 
pmultitive succeeds returns semantic value expression remaining input recognized portion input 
check operator position successful produces string representing remaining input operator 
recursively call padditive recognize expression position successful yields right hand side result final remainder string 
matches successful return result initial call padditive semantic value addition final remainder string 
matches failed fall back alt second alternative merely attempts recognize single multiplicative precedence expression original input position returns result verbatim success failure 
parsing functions constructed similarly direct correspondence grammar 
course easier concise ways write parsing functions appropriate library helper functions combinators 
techniques discussed section clarity stick simple pattern matching 
backtracking versus prediction parser developed backtracking parser 
alt padditive function fails example parser effectively backtracks original input position starting original input string second alternative alt regardless alternative failed match second third stage 
notice input consists single multiplicative expression pmultitive function called twice string alternative fail trying match nonexistent operator successfully applying second alternative 
backtracking redundant evaluation parsing functions lead parse times grow exponentially size input principal reason naive backtracking strategy realistic parsers inputs substantial size 
standard strategy making top parsers practical design predict alternative rules apply making recursive calls 
way guaranteed parse functions called redundantly input parsed linear time 
example grammar directly suitable predictive parser converted ll grammar suitable prediction lookahead token left factoring additive multitive nonterminals follows additive multitive additive multitive primary multitive decision alternatives making recursive calls simply checking input character 
prediction mechanism raw input tokens characters case operate constant time class grammars parsed predictively restrictive 
care taken keep prediction mechanism consistent grammar difficult input pprimary pmultitive padditive column 
matrix parsing results string ally highly sensitive global properties language 
example prediction mechanism adjusted higher precedence exponentiation operator added language exponentiation operator falsely trigger predictor multiplication expressions cause parser fail valid input 
top parsers prediction decisions fall back full backtracking flexibility needed 
strategy yields combination flexibility performance practice suffers additional complexity prediction requires parser designer intimately aware prediction backtracking required 
tabular top parsing pointed birman ullman backtracking top parser kind section operate linear time added complexity constraints prediction 
basic reason backtracking parser take super linear time redundant calls parse function input substring redundant calls eliminated memoization 
parse function example dependent single parameter input string 
parse function recursive call parse function supplies input string call padditive pmultitive suffix original input string recursive call padditive matching operator 
input string length distinct suffixes recursive calls counting original input string empty string 
parse functions distinct intermediate results parsing process require 
avoid computing intermediate results multiple times storing table 
table row parse functions column distinct position input string 
fill table results parse function input position starting right input string working left column column 
column start bottommost cell upwards 
time compute result cell results recursive calls corresponding parse function computed recorded table merely need look appropriate results 
illustrates partially completed result table input string 
brevity parsed results indicated semantic value column number associated remainder suffix begins 
columns labeled avoid confusion integer semantic values 
noparse results indicated cell 
cell filled pprimary column indicated circled question mark 
rule primary expressions alternatives parenthesized additive expression decimal digit 
try alternatives order expressed grammar pprimary check parenthesized additive expression 
pprimary attempts match opening column succeeds yields remainder string input suffix starting column 
simple recursive descent parser pprimary recursively call padditive remainder string 
table simply look result padditive column table 
entry indicates semantic value result addition expression remainder suffix starting column 
match success pprimary attempts match closing parenthesis position succeeds yields empty string remainder 
result entered pprimary column 
long input string complex grammar result table may large grows linearly size input assuming grammar fixed number nonterminals 
furthermore long grammar uses standard operators backus naur form fixed number cells matrix need accessed order compute new result 
assuming table lookup occurs constant time parsing process completes linear time 
due forward pointers embedded results table computation result may examine cells widely spaced matrix 
example computing result pprimary results columns 
ability skip ahead arbitrary distances making parsing decisions source algorithm unlimited lookahead capability capability algorithm powerful linear time predictive parsers lr parsers 
packrat parsing obvious practical problem tabular right left parsing algorithm computes results needed 
additional inconvenience carefully determine order results particular column computed parsing functions padditive pmultitive depend results column correctly 
packrat parsing essentially lazy version tabular algorithm solves problems 
packrat parser computes results needed order original recursive descent parser 
result computed time stored subsequent calls 
non strict functional programming language haskell provides ideal implementation platform packrat parser 
fact packrat parsing haskell particularly efficient require arrays explicit lookup structures language ordinary algebraic data types 
need new type represent single column parsing result matrix call derivs derivations 
type merely tuple component nonterminal grammar 
component type result type corresponding parse function 
derivs type contains additional component call dvchar represent raw characters input string results parsing function 
derivs type example parser conveniently declared haskell follows data derivs derivs result int result int result int result int dvchar result char haskell syntax declares type derivs single constructor named derivs components specified types 
declaration automatically creates corresponding data accessor function component function type derivs result int extracts component derivs tuple 
modify result type remainder component success result plain string instance derivs data result parsed derivs noparse derivs result types mutually recursive success results derivs instance act links derivs instances 
result values fact provide linkage need different columns matrix parsing results 
modify original recursive descent parsing functions takes derivs string parameter padditive derivs result int pmultitive derivs result int pprimary derivs result int derivs result int original parse functions examined input characters directly new parse function refers dvchar component derivs object 
original functions recursive call parse function order match nonterminal grammar new parse function uses derivs accessor function corresponding nonterminal 
sequences terminals nonterminals matched chains success results multiple derivs instances 
example new padditive function uses dvchar accessors follows making direct recursive calls parse additive precedence expression padditive derivs result int padditive alt additive alt case parsed case dvchar parsed case parsed parsed alt alt alt additive alt create special top level function parse produce instances derivs type tie recursion individual parsing functions create result matrix input string parse string derivs parse derivs add mult prim dec chr add padditive mult pmultitive prim pprimary dec chr case parsed parse noparse magic packrat parser doubly recursive function 
level recursion produced parse function case statement 
relatively conventional form recursion iterate input string character time producing derivs instance input position 
final derivs instance representing empty string assigned dvchar result noparse effectively terminates list columns result matrix 
second level recursion symbol identifier names derivs instance constructed returned parse function parameter individual parsing functions 
parsing functions turn produce rest components forming derivs object 
form data recursion course works non strict language allow components object accessed parts object available 
example derivs instance created function dvchar component accessed components tuple available 
attempting access component tuple cause invoked turn uses dvchar component require higher level components 
accessing component similarly invoke pprimary may access dvchar 
case pprimary accessing higher level component doing create cyclic dependency case invokes different derivs object called position opening parenthesis 
component derivs object produced parse lazily evaluated fashion 
illustrates data structure produced parser example input text appear memory modern functional evaluator fully reducing cell 
vertical column represents derivs instance result components 
results form parsed semantic value shown appropriate cell arrow representing remainder pointer leading derivs instance matrix 
modern lazy language implementation properly preserves sharing relationships evaluation arrows diagram literally correspond pointers heap cell structure evaluated twice 
shaded boxes represent cells evaluated dvchar 
illustration derivs data structure produced parsing string case result leftmost column value ultimately needed application 
illustration clear algorithm run time lazy evaluator input string length top level parse function function creates instances derivs type creates exactly instances 
parse functions access entries structure making direct calls function examines fixed number cells computing result 
lazy evaluator ensures cell evaluated critical memoization property provided linear parse time guaranteed order results evaluated completely different tabular right left bottom top algorithm earlier 
extending algorithm previous section provided basic principles tools required create packrat parser building parsers real applications involves additional details affected packrat parsing paradigm 
section explore important practical issues incrementally building example packrat parser developed 
examine annoying straightforward problem left recursion 
address issue lexical analysis seamlessly integrating task packrat parser 
explore monadic combinators express packrat parsers concisely 
left recursion limitation packrat parsing shares top schemes directly support left recursion 
example suppose wanted add subtraction operator example addition subtraction properly left associative 
natural approach modify grammar rules additive expressions follows change parser accordingly additive additive multitive additive multitive multitive recursive descent parser grammar padditive function recursively invoke input provided get infinite recursion cycle 
packrat parser grammar padditive attempt access component derivs tuple component supposed compute create circular data dependency 
case parser fails packrat parser failure mode viewed slightly modern lazy evaluators detect circular data dependencies run time detect infinite recursion 
fortunately left recursive grammar rewritten equivalent right recursive desired semantic behavior easily reconstructed higherorder functions intermediate parser results 
example additive expressions left associative example parser split rule nonterminals additive 
padditive function recognizes single multitive expression followed padditive derivs result int padditive case parsed vl case parsed suf parsed suf vl noparse noparse function collects infix operators righthand side operands builds semantic value type int int takes left hand side operand produces result derivs result int int alt alt case dvchar parsed case parsed vr case parsed suf parsed vl suf vl vr alt alt alt alt parsed integrated lexical analysis traditional parsing algorithms usually assume raw input text partially digested separate lexical analyzer stream tokens 
parser treats tokens atomic units may represent multiple consecutive input characters 
separation usually necessary conventional linear time parsers primitive terminals lookahead decisions refer higher level nonterminals 
limitation explained section predictive top parsers bottom lr parsers depend similar token lookahead mechanism sharing problem 
parser atomic tokens lookahead decisions parsing easier tokens represent keywords identifiers literals raw characters 
packrat parsing suffers lookahead limitation 
packrat parser reflects true backtracking model decisions alternatives parsing function depend complete results produced parsing functions 
reason lexical analysis integrated seamlessly packrat parser special treatment 
extend packrat parser example real lexical analysis add new nonterminals derivs type data derivs derivs expressions result int 
lexical tokens result int int result int result char result raw input dvchar result char parse function consumes whitespace may separate lexical tokens derivs result case dvchar parsed isspace parsed parsed complete language function task eating comments 
full power packrat parsing available lexical analysis comments complex hierarchical structure nesting markups literate programming 
syntax recognition broken unidirectional pipeline lexical constructs refer upwards higher level syntactic elements 
example language syntax allow identifiers code fragments embedded comments parser find analyze actual expressions statements making intelligent software engineering tools effective 
similarly escape sequences string literals contain generic expressions representing static dynamic substitutions 
example illustrates commonplace longest match disambiguation rules easily implemented packrat parser difficult express pure context free grammar 
sophisticated decision disambiguation strategies easy implement including general syntactic predicates influence parsing decisions syntactic lookahead information consuming input text 
example useful followed rules allow parsing alternative text matched alternative followed text matching arbitrary nonterminal 
syntactic predicates kind require unlimited lookahead general outside capabilities linear time parsing algorithms 
continuing lexical analysis example function recognizes operator tokens consisting operator character followed optional whitespace parse operator followed optional whitespace derivs result char case dvchar parsed elem case parsed parsed noparse noparse noparse modify higher level parse functions expressions dvchar scan operators parentheses 
example pprimary implemented follows parse primary expression pprimary derivs result int pprimary alt primary alt case parsed case parsed case parsed parsed alt alt alt primary alt function demonstrates parsing decisions depend existence match position nonterminal symbol semantic value associated nonterminal 
case symbol tokens parsed treated uniformly rules pprimary distinguish particular symbols 
sophisticated language multi character operators identifiers reserved words semantic values produced token parsers type string char values matched way 
dependencies syntax semantic values known semantic predicates provide extremely powerful useful capability practice 
syntactic predicates semantic predicates require unlimited lookahead general implemented conventional parsing algorithms giving linear time guarantee 
monadic packrat parsing popular method constructing parsers functional languages haskell monadic combinators 
unfortunately monadic approach usually comes performance penalty packrat parsing tradeoff presents difficult choice 
implementing packrat parser described far assumes set nonterminals corresponding result types known statically bound single fixed tuple form derivs type 
constructing entire packrat parsers dynamically packrat parsers combinators require making derivs type dynamic lookup structure associating variable set nonterminals corresponding results 
approach slower space efficient 
practical strategy provides convenience combinators significant performance penalty monads define individual parsing functions comprising packrat parser keeping derivs type top level recursion statically implemented described earlier 
combinators build parse functions need directly obvious method combinators simple type alias type parser derivs result unfortunately order take advantage haskell useful syntax combinators type special class monad simple aliases assigned type classes 
wrap parsing functions real user defined type newtype parser parser derivs result implement haskell standard sequencing result producing return error producing combinators instance monad parser parser parser pre pre post post parsed parser post noparse noparse return parser parsed fail msg parser noparse parsing need alternation combinator parser parser parser parser parser parser pre pre post post noparse post combinators addition trivial recognize specific characters padditive function original packrat parser example written follows parser padditive char return parser tempting build additional combinators higher level idioms repetition infix expressions 
iterative combinators packrat parsing functions violates assumption cell result matrix computed constant time results cells depends available 
iterative combinators effectively create hidden recursion intermediate results memoized result matrix potentially making parser run super linear time 
problem necessarily serious practice results section show taken account iterative combinators 
line examples include full featured monadic combinator library build large packrat parsers conveniently 
library substantially inspired parsec packrat parsing combinators simpler implement lexical analysis separate phase implement token lookahead prediction mechanism traditional top parsers 
full combinator library provides variety safe constant time combinators dangerous iterative ones convenient necessary construct parsers 
combinator library simultaneously multiple parsers different derivs types supports user friendly error detection reporting 
comparison ll lr parsing previous sections served tutorial construct packrat parser remaining sections turn issue packrat parsing useful practice 
section informally explores language recognition power packrat parsing depth clarifies relationship traditional linear time algorithms ll lr 
lr parsing commonly seen powerful limited lookahead top ll parsing class languages parsers recognize 
pepper points lr parsing viewed simply ll parsing grammar rewritten eliminate left recursion delay important parsing decisions long possible 
result lr provides flexibility way grammars expressed actual additional recognition power 
reason treat ll lr parsers essentially equivalent 
lookahead critical practical difference packrat parsing ll lr parsing lookahead mechanism 
packrat parser decisions point text input string 
computation individual result parsing matrix perform constant number basic operations basic operations include forward pointers parsing matrix skip large amount text 
ll lr parsers look ahead constant number terminals input packrat parsers look ahead constant number terminals nonterminals combination 
ability parsing decisions take arbitrary nonterminals account gives packrat parsing unlimited lookahead capability 
illustrate difference language recognition power grammar lr problem packrat parser lr parser encountered string language decide immediately start reducing nonterminal way decision encountered left hand side 
packrat parser hand essentially operates speculative fashion producing derivations nonterminals parallel scanning input 
ultimate decision effectively delayed entire input string parsed decision merely matter checking nonterminal success result position 
mirroring grammar left right change situation making clear difference merely side effect fact lr scans input left right packrat parsing operate reverse 
grammar composition limitations lr parsing due fixed lookahead frequently felt designing parsers practical languages limitations stem fact ll lr grammars cleanly composable 
example grammar represents simple language expressions assignment allows simple identifiers left side assignment id eq ne id symbols id eq ne terminals atomic tokens produced separate lexical analysis phase lr parser trouble grammar 
try integrate tokenization parser simple rules grammar longer lr id id eq ne problem scanning identifier lr parser decide immediately primary expression lefthand side assignment immediately token 
token parser way knowing assignment operator half operator 
particular case grammar parsed lr parser 
practice lr lalr parsers uncommon 
developed extensions traditional left right parsing algorithms improve situation somewhat provide unrestricted lookahead capability maintaining linear time guarantee 
lexical analysis separated parsing limitations lr parsers surface practical situations frequently result seemingly innocuous changes evolving grammar 
example suppose want add simple array indexing language array indexing operators appear left right side assignment 
possible approach add new nonterminal represent left side lvalue expressions incorporate array indexing operator types expressions shown eq ne id id id eq ne symbols treated terminals grammar lr parser sees identifier immediately decide part expression way knowing array indexing operators fully parsed 
packrat parser trouble grammar effectively evaluates alternatives parallel complete derivations knowledge absence time critical decision needs 
general grammars packrat parsers composable lookahead packrat parser uses decisions alternatives take account arbitrary nonterminals eq example second 
packrat parser give primitive syntactic constructs terminals special significance ll lr parser terminal fixed sequence terminals appearing grammar substituted nonterminal breaking parser 
substitution capability gives packrat parsing greater composition flexibility 
recognition limitations packrat parser recognize broader class languages linear time ll lr algorithms kinds grammars packrat parser recognize 
precise theoretical capabilities algorithm thoroughly characterized trivial unambiguous context free grammar provides example proves just troublesome packrat parser ll lr parser problem grammar kinds parsers scanning string left right lr case left packrat case algorithm know advance middle string apply second alternative position build outwards alternative rest input stream 
stream completely homogeneous way parser find middle entire input parsed 
grammar provides example albeit contrived requiring general non linear time cfg parsing algorithm 
practical issues limitations packrat parsing powerful efficient applications main issues inappropriate situations 
packrat parsing useful construct deterministic parsers parsers produce result 
second packrat parser depends efficiency completely stateless 
due reliance memoization packrat parsing inherently space intensive 
issues discussed section 
deterministic parsing important assumption far mutually recursive parsing functions packrat parser built deterministically return result 
ambiguities grammar parser built parsing functions able resolve locally 
example parsers developed multiple alternatives implicitly disambiguated order tested alternative match successfully independent alternatives may match 
behavior easy implement useful performing forms explicit local disambiguation 
parsing function try possible alternatives produce failure result alternative matches 
parsing functions packrat parser return multiple results parallel disambiguated global strategy 
languages designed machine consumption requirement multiple matching alternatives disambiguated locally problem practice ambiguity usually undesirable place localized disambiguation rules preferred global ones easier humans understand 
parsing natural languages grammars global ambiguity expected packrat parsing useful 
classic nondeterministic top parser parse functions return lists results memoized similar way resulting parser linear time comparable existing tabular algorithms ambiguous context free grammars 
nondeterministic parsing equivalent computational complexity boolean matrix multiplication linear time solution general problem 
stateless parsing second limitation packrat parsing fundamentally geared stateless parsing 
packrat parser memoization system assumes parsing function nonterminal depends input string information accumulated parsing process 
pure context free grammars definition stateless practical languages require notion state parsing really context free 
example require parser build table type names incrementally types declared parser able distinguish type names identifiers order parse subsequent text correctly 
traditional top ll bottom lr parsers little trouble maintaining state parsing 
perform single left right scan input look ahead tokens lost state change occurs 
packrat parser contrast depends efficiency unlimited lookahead capability 
stateful packrat parser constructed parser start building new result matrix time parsing state changes 
reason stateful packrat parsing may impractical state changes occur frequently 
details packrat parsing state please refer master thesis 
space consumption probably striking characteristic packrat parser fact literally away computed input text including entire input text 
reason packrat parsing storage requirements equal possibly substantial constant multiple input size 
contrast ll lr simple backtracking parsers designed space consumption grows maximum nesting depth syntactic constructs appearing input practice orders magnitude smaller total size text 
ll lr parsers nonregular language linear space requirements worst case average case difference important practice 
way reduce space requirements derivations structure especially parsers grammars nonterminals splitting derivs type multiple levels 
example suppose nonterminals language grouped broad categories lexical tokens expressions statements declarations 
derivs tuple components addition dvchar nonterminal categories 
components turn tuple containing results nonterminals category 
majority derivs instances representing character positions tokens components representing categories nonterminals evaluated small top level object unevaluated closures components occupy space 
derivs instances corresponding token results categories needed depending kind language construct located position 
optimizations packrat parser consume times working storage size original input text 
reason application areas packrat parsing probably best choice 
example parsing xml streams fairly simple structure encode large amounts relatively flat machine generated data power flexibility packrat parsing needed storage cost justified 
hand parsing complex modern programming languages source code usually written humans top priority power expressiveness language space cost packrat parsing probably reasonable 
standard programming practice involves breaking large programs modules manageable size independently compiled main memory sizes modern machines leave orders magnitude expansion typical kb source file parsing 
parsing larger source files working set may relatively small due strong structural locality properties realistic languages 
entire derivations structure thrown away parsing complete parser space consumption irrelevant result fed complex computation global optimizer requires space packrat parser 
section evidence space consumption reasonable practice 
performance results detailed empirical analysis packrat parsing outside scope helpful idea packrat parser behave practice committing new unfamiliar parsing paradigm 
reason section presents experimental results realistic packrat parsers running real source files 
detailed results please refer master thesis 
space efficiency set tests measure space efficiency packrat parser java programming language 
chose java experiment rich complex grammar adopts fairly clean syntactic paradigm requiring parser keep state declared types parsers perform special processing lexical hierarchical analysis haskell layout scheme requires 
experiment uses different versions java parser 
apart trivial preprocessing stage line breaks java unicode escape sequences lexical analysis parsers fully integrated described section 
parser uses monadic combinators lexical analysis functions parser relies primitive pattern matching 
parsers monadic combinators construct higher level parsing functions 
parsers technique described section splitting derivs tuple levels order increase modularity reduce space consumption 
parsers compiled glasgow haskell compiler version optimization profiling enabled 
ghc heap profiling system measure live heap utilization excludes unused heap space garbage samples taken 
java trademark sun microsystems www haskell org ghc source file size bytes avg 
avg 
monadic parser scanner monadic parser pattern matching scanner 
maximum heap size versus input size test suite consists unmodified java source files library chosen includes substantial number relatively large java source files 
java source files small average compilation model encourages programmers place class definition separate file 
shows plot parser maximum live heap size size input files parsed 
smaller source files parsed quickly garbage collection occurred heap profiling mechanism yield samples plot includes data points fully monadic parser data points hybrid parser direct pattern matching lexical analysis 
averaged test suite fully monadic parser uses bytes live heap byte input hybrid parser uses bytes heap input byte 
results encouraging packrat parsing consume substantial amount space typical modern machine kb ram trouble parsing source files kb 
furthermore parsers iterative monadic combinators break linear time space guarantee theory space consumption parsers appears grow fairly linearly 
monadic combinators clearly substantial penalty terms space efficiency 
modifying parser direct pattern matching may yield improvement degree difficult predict cost lexical analysis dominates rest parser 
lexical analysis portion hybrid parser twice long equivalent portion monadic parser suggesting writing packrat parsers pattern matching somewhat cumbersome unreasonable efficiency important 
parsing performance second experiment measures absolute execution time packrat parsers 
test parsers compiled ghc optimization profiling timed ghz amd athlon processor running linux 
test source files test suite larger kb smaller files parsed quickly linux time command yield adequate precision 
shows resulting execution time plotted source file size 
inputs fully monadic parser averaged kbytes www org execution time seconds source file size bytes avg 
kbps avg 
kbps avg 
kbps avg 
kbps monadic parser scanner monadic parser pattern matching scanner 
execution time versus input size second standard deviation kb hybrid parser averaged kb standard deviation kb order provide legitimate performance comparison packrat parsing traditional linear time algorithms converted freely available yacc grammar java grammar happy lr parser generator haskell 
unfortunately ghc unable compile kb haskell source file resulting grammar optimization machine gb ram 
difficulty incidentally lends credibility earlier suggestion modern compilers temporary storage cost packrat parser exceeded storage cost subsequent stages 
generated lr parser worked haskell interpreter hugs 
provide rough performance comparison ran larger java sources lr packrat parsers hugs mb heap 
fairness compared lr parser slower fully monadic packrat parser lr parser uses monadic lexical analyzer derived packrat parser 
lexical analysis performance comparable parsing algorithm primary importance 
hugs lr parser consistently performs approximately twice number reductions allocates total heap storage 
find way profile live heap utilization hugs total allocation 
difference real execution time varied widely lr parser took twice long smaller files performed largest ones 
probable reason variance effects garbage collection 
running packrat parser naturally higher ratio live data garbage lr parser time garbage collection increases overhead cost decreases effectiveness frees space live data garbage collection penalize packrat parser lr parser size source file increases 
encouraging packrat parser able outperform lr parser largest java source files 
related section briefly relates packrat parsing relevant prior 
detailed analysis packrat parsing comparison algorithms please refer master thesis 
www haskell org happy www haskell org hugs birman ullman developed formal properties deterministic parsing algorithms backtracking 
refined aho ullman classified top limited backtrack parsing restriction parsing function produce result backtracking localized 
showed kind parser formally known generalized top parsing language gtdpl parser quite powerful 
gtdpl parser simulate push automaton recognize ll lr language recognize languages context free 
failures caused left recursion detected eliminated gtdpl grammar ensuring algorithm behaved 
birman ullman pointed possibility constructing linear time gtdpl parsers tabulation results linear time algorithm apparently put practice doubt main memories limited time compilers operate streaming filters run near constant space 
adams gtdpl parsing component modular language prototyping framework recognizing superior composability comparison lr algorithms :10.1.1.48.3355
addition practical top parsing libraries toolkits including popular antlr parsec combinator library haskell provide similar limited backtracking capabilities parser designer invoke selectively order overcome limitations predictive parsing 
parsers implement backtracking traditional recursive descent fashion memoization creating danger exponential worst case parse time making impractical rely backtracking substitute prediction integrate lexical analysis parsing 
prior known linear time parsing algorithm effectively supports integrated lexical analysis scannerless parsing nslr algorithm originally created tai put practice purpose salomon cormack 
algorithm extends traditional lr class algorithms adding limited support making lookahead decisions nonterminals 
relative power packrat parsing respect nslr unclear packrat parsing restrictive rightward lookahead nslr take leftward context account 
practice nslr probably space efficient packrat parsing simpler cleaner 
scannerless parsers linear time deterministic algorithms favor general slower ambiguity tolerant cfg parsing 
results demonstrate power practicality packrat parsing experimentation needed evaluate flexibility performance space consumption wider variety languages 
example languages rely extensively parser state layout sensitive languages ml haskell may prove difficult packrat parser handle efficiently 
hand syntax practical language usually designed particular parsing technology mind 
reason equally compelling question new syntax design possibilities created free unlimited lookahead unrestricted grammar composition capabilities packrat parsing 
section suggested simple extensions depend integrated lexical analysis packrat parsing may useful languages extensible syntax grammar composition flexibility important 
packrat parsing simple implement hand lazy functional language practical benefit grammar compiler lines yacc world happy haskell world 
addition parsing functions grammar compiler automatically generate static derivations tuple type top level recursive tie function eliminating problems monadic representation discussed section 
compiler reduce iterative notations popular repetition operators low level grammar uses primitive constant time operations preserving linear parse time guarantee 
compiler rewrite left recursive rules easier express left associative constructs grammar 
practical area packrat parsing may difficulty warrants study parsing interactive streams 
example read eval print loops language interpreters expect parser detect line input needed finish current statement requirement violates packrat algorithm assumption entire input stream available front 
similar open question conditions packrat parsing may suitable parsing infinite streams 
packrat parsing simple elegant method converting backtracking recursive descent parser implemented non strict functional programming language linear time parser giving power unlimited lookahead 
algorithm relies simplicity ability non strict functional languages express recursive data structures complex dependencies directly relies lazy evaluation practical efficiency 
packrat parser recognize language conventional deterministic linear time algorithms providing better composition properties allowing lexical analysis integrated parsing 
primary limitations algorithm supports deterministic parsing considerable asymptotically linear storage requirements 
acknowledgments wish advisor frans kaashoek colleagues chuck blake russ cox anonymous reviewers helpful comments suggestions 
stephen robert adams :10.1.1.48.3355
modular grammars programming language prototyping 
phd thesis university southampton 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
alfred aho jeffrey ullman 
theory parsing translation compiling vol 
parsing 
prentice hall englewood cliffs 
alexander birman jeffrey ullman 
parsing algorithms backtrack 
information control aug 

free yacc able java tm grammar 
home com grammars java html 
carlos figueiredo 
monadic combinator compiler compiler 
th brazilian symposium programming languages pr brazil may 
universidade federal 
luca cardelli florian matthes martn abadi 
extensible syntax lexical scoping 
technical report digital systems research center 
jeroen fokker 
functional parsers 
advanced functional programming pages 
bryan ford 
packrat parsing practical linear time algorithm backtracking 
master thesis massachusetts institute technology sep 
andy gill simon marlow 
happy parser generator haskell 
www haskell org happy 
graham hutton erik meijer 
monadic parsing haskell 
journal functional programming jul 
lillian lee 
fast context free grammar parsing requires fast boolean matrix multiplication 
journal acm 
appear 
leijen 
parsec fast combinator parser 
www cs uu nl 
terence parr russell quong 
adding semantic syntactic predicates ll pred ll 
computational complexity pages 
terence parr russell quong 
antlr parser generator 
software practice experience 
terence john parr 
obtaining practical variants ll lr splitting atomic tuple 
phd thesis purdue university apr 
peter pepper 
lr parsing grammar transformation ll parsing making lr parsing understandable efficient 
technical report tu berlin apr 
daniel salomon gordon cormack 
scannerless nslr parsing programming languages 
proceedings acm sigplan conference programming language design implementation pldi pages jul 
kuo chung tai 
noncanonical slr grammars 
acm transactions programming languages systems oct 
masaru tomita 
efficient parsing natural language 
kluwer academic publishers 
van den brand visser 
disambiguation filters scannerless generalized lr parsers 
compiler construction 
eelco visser 
scannerless generalized lr parsing 
technical report programming research group university amsterdam 
philip wadler 
replace failure list successes method exception handling backtracking pattern matching lazy functional languages 
functional programming languages computer architecture pages 
