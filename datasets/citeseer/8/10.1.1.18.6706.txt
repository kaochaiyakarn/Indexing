massachusetts institute technology artificial intelligence laboratory memo march security kernel lambda calculus jonathan rees publication retrieved anonymous ftp publications ai mit edu 
cooperation independent agents depends establishing degree security 
cooperating agents needs assurance cooperation endanger resources value agent 
computer system computational mechanism assure safe cooperation system users mediating resource access desired security policy 
mechanism called security kernel lies heart operating systems programming environments 
report describes scheme programming environment design guided established principles operating system security 
scheme security kernel small consisting call value calculus simple extensions support data types object mutation access hardware resources 
agent user subsystem separate evaluation environment holds objects representing privileges granted agent 
environments ultimately determine availability object protection sharing controlled largely way environments constructed 
describe experience scheme shows serves robust flexible experimental platform 
successful applications scheme programming environment cornell mobile robots scheme runs operating system support secure multi user environment runs workstations 
copyright fl massachusetts institute technology report describes research done artificial intelligence laboratory massachusetts institute technology 
support research provided part advanced research projects agency department defense office naval research contract 
cooperation independent agents depends establishing degree security 
cooperating agents needs assurance cooperation endanger resources value agent 
computer system computational mechanism assure safe cooperation system users mediating resource access desired security policy 
mechanism called security kernel lies heart operating systems programming environments 
claim calculus serve central component simple flexible security kernel 
report supports thesis motivating describing calculus security kernel giving lines evidence kernel effectiveness 
security kernel consists call value calculus simple extensions support data types object mutation access hardware resources 
agent user subsystem separate evaluation environment holds objects representing privileges granted agent 
environments ultimately determine availability object protection sharing controlled largely way environments constructed 
effectiveness security kernel demonstrated lines evidence 
ability address certain fundamental security problems important cooperation sections 
structural correspondence familiar operating system kernels section 
success scheme complete implementation scheme programming language built basis secure robust flexible programming systems section 
security kernel calculus calculus calculus functions concerned computations abstracted instantiated names come meanings 
calculus procedures generalized functions capable performing side effects 
procedures correspond operating system programs servers 
side effects include access input output devices memory cells 
side effects communication cooperation possible 
side effects harmful 
example computer controlled robot arm easily hurt person gets way 
purpose security kernel allow control access objects 
challenge designing security kernel support sharing protection se allow flexible control extent object shared protected 
way name chosen mnemonic value 
calculus provide protection closure procedure just program program coupled environment origin 
procedure access environment call caller access procedure environment origin 
caller callee protected 
sharing accomplished shared portions environments may include procedures allow objects shared 
address number authentication certification problems includes data type facility 
usually term refers type abstraction enforced compile time type checking means dynamic information hiding mechanism 
facility akin digital signatures subsystem may sign object way signed object may recognized having definitely signed subsystem 
particular compiler particular signature mean signed procedure harmless technical sense safe apply fragile arguments 
scheme scheme complete scheme system tests capacity support safe cooperation 
scheme major design implementation effort constitutes heart project 
section gives overview scheme information related reports :10.1.1.50.8035
large amount engineering goes making practical programming environment scheme security concern nearly component 
major facilities design shaped security concerns include ffl module system 
modules truly encapsulated just procedures allowing shared safely 
ffl macro facility 
macros closed procedures 
allows form compile time security module may export macro protecting objects macro implementation 
ffl dynamic variables 
information communicated caller callee implicit dynamic environment 
dynamic variable accessed key keys protected 
major theme running design scheme avoidance minimization shared global state 
example virtual machine byte code interpreter essential minimum set registers registers hold global symbol tables environment structure lisp scheme implementations 
example run time system modules alter global state scheme terms top level variable assigned set 
data structures manipulated modules instantiated multiple times avoid conflict 
success scheme demonstrated number applications 
include programming environment cornell mobile robots scheme runs operating system support secure multi user environment runs workstations :10.1.1.50.8035
security kernel section exposition starting principles problem secure cooperation independent agents 
describes simple idealized security kernel addresses problem 
presentation intended show essential unity security concerns operating systems programming languages 
idealized kernel graph encapsulated objects 
accessibility object constrained connectivity object graph limited object specific gatekeeper programs 
kernel enables natural construction variety mechanisms support secure cooperation agents 
particular agent securely call untrusted agent program sensitive input 
kernel similar capability operating systems 
main differences kernel simpler clearly connected programming language concepts classical capability systems 
safe computer mediated cooperation participants cooperative interaction carry joint activity uses combines resources provides 
resources include energy information skills equipment 
agent relinquishes control extent resources agent brings 
agent values resource relinquishing control dangerous resource may come harm may cause harm 
assure resource safety control relinquished desirable agent able dictate precisely extent control relinquished 
trusted intermediary helpful situation 
resource handed intermediary performs actions specified recipient subject restrictions imposed source 
computer system may useful cooperation resources may provide programmable processor memory network communications programs potential act trusted intermediary 
agent providing resource dictate restrictions form program resource recipient specify actions performed resource form program 
program invocation plays critical role computer mediated cooperation 
program untrusted programs invoking fraught 
invoking agent puts risk resources value inputs parts computer system 
similarly agent supplied program may endowed access resources value agent resources put risk program invoked 
consider scenario bart writes program sorts list numbers 
generous fellow gives useful program lisa expressed interest program 
lisa hesitant bart program bart may arranged program things 
example program covertly send list sorted back bart electronic mail 
unfortunate lisa wants sort list credit card numbers keep secret 
bart lisa 
distinct approaches solving safe invocation problem general situation agent cooperation resources protected agent program invoked context inputs computer system agent 
approach program runs limited computing environment dangerous operations sending mail prohibited 
second approach second agent rejects program bears recognized certificate safety 
sections look approaches 
limited environments way avoid disclosure numbers instance confinement problem lisa isolate computer running bart program making physically impossible program harm 
require computer network removing disks read written setting special network disk transmitting inputs results 
measures inconvenient time consuming expensive 
crude example permissible bart program fetch information network disks write information 
selective restriction impossible hardware configurations 
basic idea sound 
trick ensure accesses sensitive resources intercepted special supervisor program 
supervisor program checks validity access attempt allows go 
straightforward method achieved emulator emulator program mimics role processor hardware usually plays decoding executing programs 
instructions safe emulator simulates hardware precisely dangerous instructions supervisor program invoked 
emulator programs run slowly common alternative special hardware feature available computers called user mode 
processor user mode dangerous operations preempted causing supervisor program invoked 
supervisor program runs ordinary non user supervisor mode may implement protection policy likes 
safe program invocation accomplished architecture user mode support 
invoker runs program user mode telling supervisor program operations permitted 

supervisor program monitors potentially dangerous operations refusing perform operations permitted 

program done executes special operation return supervisor mode 
screening certification way avoid disclosure list numbers lisa screen bart program verify contains dubious operations calls send email program 
probably require receiving program source form binary program modest size written language familiar lisa 
need access compiler time hands run compiler 
lisa willing able go trouble bart unwilling give source program contains information wants keep secret passwords material subject copyright trade secrets personal information 
dilemma solved help trusted third party 
different ways third party help variant screening method suggested doesn require lisa obtain bart source program 
suppose bart lisa trust ned 
bart gives source program ned instructions ned give source program lisa may answer question program obviously harmless run 
obviously harmless mean program uses potentially harmful operations sophisticated test 
uncomputable test approximation 
lisa obtains machine program asks ned machine program obviously harmless run says runs assurance 
screening approach agent invoking program rejects bears recognized certificate safety 
initial check invoking program just simple invoking fully trusted program 
need emulator program user mode hardware support 
safe program invocation accomplished screening approach 
invoker checks see program definitely restricted operations permitted invoker 

invoker refuses run program appears operations 

invoker runs program real machine 
harmful operations needn prevented won occur certifier correct 
screening drawback cooperation required person supplying program 
go trouble obtaining certification change program 
simple kernel security kernel innermost layer operating system programming language fundamental component responsible protecting valued resources unwanted disclosure manipulation 
isolating security kernel rest system helps ensure reliability trustworthiness 
simplicity important kernel simpler kernel easily tested verified 
follows just ways define security kernel 
design ll call intended suitable operating system programming language 
seen theory security describe security existing programming languages operating systems 
organizes computer resources network logical entities ll call objects 
objects basic units protection 
link network object means second accessible 
objects object access successors objects access object predecessors 
objects may thought representing particular privileges capabilities resources 
example object represent ability draw pictures display transmit messages communications line read information data file run programs processing element 
new nodes enter object network running program requests creation new object 
order avoid dangers dangling links deleted nodes memory leaks object deletion left hands kernel 
kernel may delete object soon path network current computation 
absence path detected automatic mechanism counts garbage collection 
different kinds objects 
introduced needed presentation 
choice notation order elucidate kernel design describe consequences necessary specimen programs purpose choose notation programming language 
choice principle arbitrary important affects exposition 
unfortunately object loaded term computer science 
people implies complicated phenomena methods classes inheritance 
don mean suggest baggage 
may best take undefined term point geometry 
interested comparing currently popular familiar security kernels operating systems examples programs perform kernel operations traditional way system calls 
programs written algol language machine level language viable approach theory precludes see section 
approach examples awkward write understand 
particularly awkward frequent case creating new object program specify second program 
traditional languages don way program specify entire program 
notation division labor language security kernel difficult tease apart 
reason prefer notation kernel operations natural forms expression 
language unix shell approaches goal program invocation natural syntax operations programs processes concise algol go step direction languages integrated kernel support version scheme scheme values including procedures identified objects known kernel 
ml reasonable choice language 
notation avoid confusion scheme dialects ll refer small dialect scheme examples scheme gamma grammar summarizes scheme gamma stands expression 
meaning constructs full scheme 
group constructs scheme gamma calculus core variable procedure abstraction lambda application 
second group constructs special evaluation rule 
third group set primitive operators 
case operand expressions evaluated operator applied 
familiar require explanation cell mutable object single outgoing access link field 
new cell creates new uninitialized cell cell ref cell returns object cell currently link cell set 
cell obj redirects cell outgoing link obj enclose operator takes program specification successor set converts procedure 
enclose called output scheme gamma algol compiler 
details unimportant 
see section 
control operator controls hardware devices 
example control keyboard read char read character particular keyboard 
arguments interpreted differently different kinds devices 
reduce complexity exposition pairs assumed immutable eq 
assumed applicable symbols cells 
ll term value describe integers booleans symbols entities carry information privileges 
values considered objects unimportant 
procedures kernel principally concerned procedures 
procedure associated program 
procedure program access procedure successors various operations 
access transitive access procedure imply ability access procedure successors 
access necessarily controlled procedure program 
sense procedure program gatekeeper protects procedure successors 
primary operation procedure application argument sequence 
procedure applied arguments may include objects values integers program run 
addition procedure successors program access arguments 
may objects making new objects performing applications 
applications written scheme gamma syntax procedure argument 
example names link procedure denotes application procedure essential source security procedure program absolutely limited procedure successors objects application argument sequence 
scheme gamma lambda expressions concise notation specifying procedures 
program evaluates lambda expression new procedure created 
new procedure successors objects values lambda expression free variables program specified body lambda expression 
example illustrating lambda application 
lambda specifies procedure successors knows resulting procedure say applied argument applies argument applies result obtained applying result result call acts functional composition procedure program written language scheme gamma example algol machine language 
consider possibility section 
initial program suppose call obtains brand new machine running operating system kernel 
turns machine begins executing initial program 
initial program ordinary program special relation kernel var lambda var 

constant 
var 
var var 
arith cons car cdr null 
pair 
list 
symbol 
eq 
new cell cell ref cell set 
enclose control arith grammar scheme gamma executed power 
principle initial program arbitrary manufacturer chosen provide 
initial program access objects represent computer system attached hardware resources include keyboards displays facsimile machines traffic lights 
hardware may manipulated control primitive operator details important 
resources objects program access hardware resources explicitly granted access initial program indirectly series programs 
order computer generally useful possible manufacturer installed initial program executes commands entered keyboard 
kind command simply scheme gamma expression 
expression seen initial program compiles executes expression displays result 
example command causes number displayed 
second kind command definition looks define var 
definitions give way user extend environment new objects names subsequent commands see 
example write define square lambda define squaring procedure square invoke display result 
able existing resources commands need access 
reason processed relative environment set variable bindings allowing objects accessed name 
environment initially includes kinds resources devices names display fax machine handy utilities user written manufacturer supplied 
utilities usual scheme procedures assoc write read string append described 
initial program just described including utilities command processor written entirely scheme gamma case resemble program eval utility executes scheme gamma expression representation obtained user received computed 
compiler translates expression form acceptable kernel primitive enclose operator 
translated expression access specified environment executed 
define eval lambda expression env enclose compile scheme expression map car env map cdr env definitions handled bind extends environment adding binding variable value 
environments represented association lists bind defined define bind lambda name value env cons cons name value env 
administration mechanism disposal consider examples 
intends set machine lisa bart resources 
means machine users share objects defines simple object repository define repository new cell cell set 
repository define command processor lambda env source sink loop env env command read source definition 
command loop bind cadr command eval caddr command env env write eval command env sink loop env define definition 
lambda command pair 
command eq 
car command define simple initial program 
define lookup lambda name probe assoc name repository probe cdr probe define publish 
lambda name object cell set 
repository cons cons name object repository access lookup procedure obtain values repository access publish 
store values repository 
assoc assumed lisp traditional association list search function 
environment bart command processor 
include objects bart able access initially 
harm including system utility procedures assoc read harm come 
needs careful devices 
sake safety includes bart devices bart env define user env lambda user user bind standard input user bind standard output user bind lookup lookup bind publish 
publish 
utilities env define bart env user env bart bart bart command processor initiated command processor bart env bart bart simplicity assumed concurrency issue 
multiprocessing multitasking system access repository cell serialized 
similarly lisa command processor lisa env lisa lisa security results omission vulnerable objects users initial environments 
example lisa devices lisa lisa aren accessible bart environment bart won able cause reading writing 
bart lisa able share objects repository bart define really sort lambda list numbers null 
list numbers insert car list numbers really sort cdr list numbers define insert lambda recur null 
list 
car cons cons car recur cdr publish 
sort sort lisa define bart sort lookup sort bart sort gamma 
course bart lisa trust full control resources 
treat administrative structure part machine trusted substrate 
trust avoided 
bart lisa trust software machine just trusts manufacturer installed software manufacturer trusts semiconductor chip factories chip factories trust solid state physicists 
trusted third party establishes safety great deal safety built structure kernel 
procedure invoked privileges invoked procedure program created installed passed arguments 
privilege sets contain dangerous privileges way harm come invocation 
reason pass privileges sensitive information unknown program 
problem installed program access channels information transmitted cell privilege information may saved unexpected 
return main example lisa wants call bart sort program risking disclosure input may contain sensitive information 
specifically risk runs bart written define list numbers new cell define sort lambda list numbers cell set 
list numbers list numbers really sort list numbers define really sort lambda list numbers null 
list numbers insert car list numbers really sort cdr list numbers publish 
sort sort deceit allow bart extract input passed sort evaluating cell ref list numbers 
sketch rudimentary solution 
ned bart lisa trust sets safe compilation service 

bart submits source code sort program ned service 

ned service analyzes bart source code determine program divulge input bart 
definition divulge see 

ned evaluates initialization bart program fresh environment extracts access resulting sort procedure 

ned sort available lisa 

lisa obtains program ned runs assurance input 
program divulge input undecidable test property necessarily conservative test reject perfectly benign useful programs easily cast safe form 
possible tests 
simple test program divulge input program obviously applicative program obviously applicative iff lambda expressions contains cell set 
expression 
clearly better methods discussed context module system section 
see safe compilation service continue scenario begun established public object repository 
problem lisa needs way determine authorship repository entry distinguish bart entries ned 
assuming objects published ned safe sure sort procedure uses published ned bart 
fundamental flaw repository fix 
see 
object repository accompanied name user put user environment publish 
procedure 
bart publish 
procedure example store entries form cons bart object repository 
complete scenario ned define publish safe 
lambda name program safe 
program publish 
name eval program obviously safe define safe 
lambda program publish 
publish safe 
publish safe 
bart define sort program define sort 
define insert 
sort define publish safe 
cdr lookup publish safe publish safe 
safe sort sort program lisa define safe sort entry lookup safe sort define safe sort eq 
car safe sort entry ned cdr safe sort entry safe sort published ned safe sort bart trick lisa 
tries publish unsafe safe sort procedure publish 
procedure ned publish 
isn accessible 
case lisa lookup safe sort result marked define publish 
lambda submitter lambda name object publish 
name cons submitter object define user env lambda user name user user bind standard input user bind standard output user bind lookup lookup bind publish 
publish 
user name utilities env define bart env user env bart bart bart define lisa env user env lisa lisa lisa define ned env user env ned ned ned improved repository 
bart name ned lisa discard 
authentication section treats problem authentication considers solution 
broadly speaking authentication procedure test determines object trustworthy genuine 
example checking student identification card authenticates person presenting card student indicated card 
having authentic person may granted privileges appropriate status permission ice 
authentication important capability secure computer systems 
examples authentication systems ffl request received untrusted source public communications network authenticated originating agent right perform action specified request 
ffl dynamically typed programming language lisp snobol value authenticated correct type operator receiving operand 
ffl solution safe invocation example section involves test authenticity safe trustworthy object bart program authentication necessary reliable transmission object untrusted messenger channel 
authenticate object transmitted sender receiver sender label package object recognized authenticated receiver labeling packaging done unforgeable tamper proof manner 
ll word capsule object labeled packaged 
physical analogy capsule locked box receiver key 
object digital information sequence characters numbers known digital cryptographic techniques implement authenticated transmission 
object transmission security kernel limits object access accessibility graph requires different mechanism 
kernel transmitting name object encrypted transmitting access object interpretation names accessibility named objects local object 
access transmitted approved channels argument result transmission procedure invocation 
data types authentication required results procedure intended constitute valid inputs procedure 
objects results valid inputs related set procedures called instances type data type 
set related procedures called module cluster context programming languages protected subsystem server classical operating systems parlance 
example consider central accounting office issues account objects clients 
clients may create new accounts new account procedure transfer money accounts transfer procedure 
integrity accounts great importance accounting office unfortunate client created counterfeit account transferred money valid account 
transfer needs authenticate accounts asked manipulate genuine created new account 
clients point view accounts objects clients may manipulate certain set operators 
accounting office point view accounts capsules transmitted new account transfer untrusted network interacting clients 
key authentication section solution safe invocation problem relies exchange object names 
bart tells lisa name object trusted repository safe sort lisa obtains repository fact object safe placed ned object lisa 
bart wishes keep object secret lisa may give secret key form name password transmit name lisa 
passwords long random probability unauthorized discovery arbitrarily small 
course assumes way untrusted agents obtain list names defined repository 
passwords possible cells section keys suggested morris 
passwords cells objects unique recognizable identities 
passwords security advantages objects access transferred kernel supported operations 
need single repository store objects need authenticated 
separate data type mapping keys objects 
gives implementation general authentication facility essentially described morris 
call new seal returns new triple objects sealed 
triple represents new data type 
seal encloses object capsule authenticated extraction operator reveals encapsulated object iff capsule authentic seal sealed 
predicate returns true iff capsule authentic 
assumed association list lookup determine cell identity 
cells holding association list identities holding objects 
example program implementation accounting system described 
important publish account cell doing allow clients accounting system set account balances arbitrary values 
case kernel support seen existing kernel mechanisms cells procedures implement authentication 
argue favor direct authentication mechanism implemented kernel 
argument favor required due stated goal keeping kernel simple possible 
key authentication mechanism practical problems 
ffl performance inefficient search central table instance 
ffl memory management kernel know safe delete object 
straightforward garbage collection techniques don central table holds links type instances garbage collector ignorant association key object 
ffl semantic obscurity unfortunate creating object data type necessarily side effect key generated 
side effect defeats optimizations subgraph sharing 
direct approach involving keyed table requires kernel support 
argument shows kernel data type support recipient fooled matter packaging method 
consider candidate encapsulation authentication technique 
loss generality assume capsules procedures 
order authenticate capsule recipient choice apply argument sequence done procedure 
application appropriately called challenge examining result distinguishes authentic capsules ones 
challenge correctly met additional application capsule related object returned challenge return perform operation underlying object 
authentic capsule untrusted messenger may easily counterfeit follows counterfeit answers challenges consulting authentic capsule returning returns handles applications way likes 
argument doesn consider problem challenge diverge signal error cause troublesome side effects 
annoyance handling situations see section argue procedures way 
kernel support provided adding new seal new primitive operator new seal capsules new kind object implemented efficiently 
capsule represented record fields containing unique seal holding encapsulated object 
inelegant aspect design distinct encapsulation mechanisms procedures capsules various ways remedy example introducing capsules separate kind object lambda application extended take unique markers requirement procedure marker match marker specified application procedure define new seal instances new cell cell set 
instances seal lambda rep abs new cell cell set 
instances cons cons abs rep cell ref instances abs lambda abs probe abs cell ref instances probe cdr probe error invalid argument abs sealed 
lambda cell ref instances list seal sealed implementation seals 
define account operators new seal define account car account operators define account cell cadr account operators define account 
caddr account operators define new account lambda account new cell define transfer lambda amount cell account cell cell account cell cell ref cell amount cell set 
cell cell ref cell amount cell set 
cell cell ref cell amount error error insufficient funds publish 
new account new account publish 
transfer transfer accounting module 
data segment code segment shared segment data segment code segment network domain domain pc handle pc handle operating system accessibility resources controlled kernel data structures called protection domains simply domains 
domain includes segment table page table specifies memory segments directly accessible program running domain 
domain specifies availability resources devices represented network procedures residing domains 
procedures called remote procedure handles inter process communication handles literature 
protection domains section attempts explain correspondence conventional operating system kernels 
typical secure operating system objects immediately accessible running program constitute protection domain simply domain 
objects various sorts including may 
mapped memory segments 
contain programs data programs directly manipulate 

descriptors hardware devices files 
descriptors control access devices file system may include information buffers position markers 

operating systems procedures residing domains variously called gateways inter process communication handles remote procedure handles write simply handle 
handle consists domain address domain specifying procedure entry point 
lambda marker var 
body marker procedure arg 
number unifications proposed 
vector object table object list object list object string object network environment environment lambda 
procedure lambda 
procedure calculus interpreter accessibility resources controlled interpreter data structures called environments 
environment contains data structures lists directly accessible program running environment 
environment specifies availability resources devices represented network procedures connected environments 
program refers objects short names numbers 
example load store machine instruction uses memory address access memory segment object system call instruction requesting information read file uses file descriptor number specify file 
domain determines names interpreted 
domain contains segment table page table hardware interpreting memory addresses tables descriptors handles system call handlers interpreting procedure call requests 
just domain maps name address descriptor number accessible object memory segment descriptor environment maps name identifier denotation value object 
various object types parallel frameworks see figures 
mapped memory segments correspond lists cells 
full scheme vector string data types better approximations memory segments lists cells 
complete version support memory segments directly 

device file descriptors correspond devices 

handles correspond procedures 
just handle domain coupled entry point procedure environment coupled executable code 
implementation experience variant kernel forms basis complete scheme implementation called scheme 
section describes scheme analyzes security standpoint discusses experience various applications security important 
implementation scheme consists parts virtual machine manages memory executes byte code instruction set set modules executed virtual machine 
virtual machine code principle replaced real machine code require significant compiler construction effort scope project time 
virtual machine approach virtues robustness small size ease portability 
thorough discussion scheme scheme system 
scheme security kernel scheme security kernel implemented part virtual machine part set run time system modules defined privileged instructions supplied virtual machine 
vm component includes instructions car secure vm raises exception applied pair application raises exception non procedure 
run time modules include exception system byte code compiler 
export interfaces unrestricted defined terms lower level operations restricted 
type safety instructions car procedure application rely followed tagging discipline 
values immediate values small integers access links objects stored memory represented descriptors 
descriptor tag distinguishes immediate values links 
arithmetic operations require immediate tagged operands affix immediate tags results 
non tag portion descriptor link holds hardware address stored object 
stored object represented contiguous series memory locations 
memory location holds header specifying object size type procedure capsule cell subsequent locations hold descriptors include links object successors accessibility network 
tagging discipline guarantees object addresses seen programmer 
promote security gives memory manager freedom move objects place guaranteeing relocations affect running computations 
security kernel provide direct access byte code interpreter 
new programs scheme programs byte compiled eval 
compiler translates program byte code instruction stream uses privileged closure instruction procedure 
closure instruction restricted reasons ffl agent defeat security constructing executing code streams containing privileged instructions 
example closure env instruction allows unrestricted access successors arbitrary procedure 
ffl agent execute object access instruction index specifying location object accessed 
fetch object shouldn seen 
performance reasons instructions perform bounds checking 
rely byte code compiler ensure indexes valid 
data types section heavily scheme run time system 
provided form record facility convenient efficient theoretically equivalent elegant new seal 
common case capsule tuple fields single object record created tuple capsule 
memory consumed field require indirection 
features scheme security kernel defines ffl basic features standard scheme characters vectors full suite numeric operators strings string symbol conversion 
security implications belong kernel sake efficiency 
ffl exception handling 
important agent initiating computation able gain control computation leads exceptional event division zero 
special construct allows exceptions exceptions certain types intercepted 
ffl fluid variables 
application implicitly passes environment maps unique tokens called fluid variables cells 
special construct extends environment new binding 
interesting aspect security perspective fluid variable unique token protected bindings fluid variable protected 
calls calls case access fluid bindings established 
contrasts similar facility unix process environments protection 
ffl multiple threads control 
new thread control may started spawn thunk 
synchronization mechanisms include locks condition variables 
thread separate exception context fluid environment 
threads really secure see section ffl immutability 
feature somewhat useful 
pair vector string read created quote 
immutable objects may passed untrusted procedures worry altered attempted mutation set car vector set raise exception 
variables pairs mutable scheme 
module system scheme provides operators constructing querying environments 
environment control important determining environment advertising environment 
roughly speaking environment excludes dangerous things dangerous 
environments manipulated objects passed compiler called top level environments packages 
packages static dynamic components 
static component defines information important compilation syntactic keywords type information early binding information definitions line procedures 
dynamic component package determines variables obtain values run time 
bindings move packages kind environment object called structure 
structure particular package implementation particular interface interface set names optional types attached simple interface names gamma 
interface structure package interface gamma 
structure dually package receives bindings packages structures package structures gamma 
package borrowing terminology standard ml ll say package opens structures receives bindings 
simple example 
assume scheme defined structure holding useful bindings define lambda forth 
define repository package package list scheme eval define repository 
define lookup 
define publish 
repository package define repository interface lookup publish define repository structure repository package repository interface 
define repository client package list scheme repository describe scheme module system detail 
checking structures safety seen section useful able determine procedure safe 
particular useful know procedure access resource communication channel outside world 
possible traverse access graph starting procedure possible determine answer question 
traversal done outside security kernel 
scheme information necessary perform certain safety checks contained network structures packages 
network considered quotient summary true access network 
procedure considered safe structure exports safe structure safe underlying package safe package safe structure opens safe 
definition safe recursive relative basis set structures assumed safe 
crude implementation safety predicate define safe 
struct assumed safe cond struct assumed safe structure 
struct lambda safe 
assumed safe package opens structure package struct isn precise test virtue simple intuitive 
rely sophisticated techniques types effects verification kinds code analysis involves visibility values 
usual scheme run time system provides number structures may considered safe purpose guaranteeing absence communication channels 
structure implementing standard scheme dialect easy create channels 
different safe scheme structure defined eliminates possibility channels described source channels assignments top level variables 
example define sorted list define sort set 
sorted list really sort get rid top level definitions prevent set 
disallowed top level variables possibly initialization 
current solution exclude set 
entirely safe scheme compiler modified project time constraints didn allow 
mutations data structures reachable top level variables prohibited excluding mutations entirely suggested section exclude top level variables hold mutable data structures 
done excluding normal scheme define replacing variant right assurances ffl define var var 
body allowed 
ffl define var exp allowed iff exp evaluates verifiably immutable object 
verifiably immutable objects include scalars numbers characters immutable strings immutable pairs vectors capsules verifiably immutable components 
note category doesn include procedures procedures easily hide channels 
course safe scheme excludes operations access file system 
includes routines take explicit port arguments display port excludes implicit port variants display 
static privileges fact static bindings syntactic keywords macros primitive operators determined relative package means entity may considered privilege granted 
example particular agent user subsystem denied access operators side effects just excluding operators environments available agent 
scoping syntactic static entities effectively allows equation languages modules derivative ideas safe languages modules safe written safe languages 
macros secure precise sense names macro introduces expanded program text resolved environment macro definition environment 
example package define letrec terms set 
export letrec exporting set 
structure letrec clients considered applicative safe process compiling involves source source rewrites containing imperative operators 
explanation problem lexically scoped macros algorithm scheme implement 
deployed configurations scheme configurations described interesting ones respect protection problems 
configurations include single user development environment far evolved multiprocessor version written mit bob brown distributed version developed richard kelsey nec 
mobile robot system scheme operating system running mobile robots cornell computer science robotics vision lab 
main board computer system mhz mc ram 
user code isolated operating system internals scheme type bounds checking means user program harm robot 
important robots programmed undergraduates robotics course relatively novice programmers 
scheme virtual machine running robot communicates development environment running scheme common lisp workstation 
byte code compiler runs workstation sends byte codes executed robot 
link workstation debugging programming environment support including byte code compiler 
division labor frees precious memory robot 
tether physical detached affecting virtual machine time debugging downloading 
detailed description mobile robot system :10.1.1.50.8035
multi user system scheme development environment configured accessed internet multiple users user separate initial evaluation environment thread control 
configuration developed turbak dan called multi user simulation environment muse similar 
www evaluation server scheme configured run worldwide web server httpd response appropriate request arriving internet 
service aims promote scheme giving general network public chance experiment easily 
request contains scheme program scheme expression execute server 
server replies printed representation result evaluating expression 
environment programs expressions run explicitly reduced default environment order limit capabilities programs come internet shouldn trusted 
security standard scheme scheme implements scheme standard 
order maintain security users different instantiations built procedures conventional time sharing system provides users different address spaces 
shared agents procedures spell trouble safe cooperation ffl built procedure opens file open output file 
buggy malevolent program overwrite important files read sensitive information files 
ffl binds accesses current input output ports display explicit port argument 
procedures allow spoofing misleading output mistaken valid messages coming legitimate source error handler command processor 
ffl load accesses file system reads writes current interaction environment 
multi agent scheme systems need ensure nonconflicting external file system assuming external file system 
agent instantiations file opening procedures private versions implement file system access specific agent 
file opening procedures access agent files utility opens files file names access files form procedures ports appropriate data abstraction 
transition name oriented protection exactly necessary order implement principle privilege analogous shift lisp dynamic scoping scheme lexical scoping 
files agent current output port procedure allowed access output port matters agent 
agent version current output port display write char read call current continuation procedure raises fundamental question ability invoke continuation multiple times privilege available agents 
answer isn obvious see section 
features accepted scheme report authors inclusion revised report troubling ffl interaction environment 
eval problem load 
ffl dynamic wind 
operator supposed establish dynamic context entries exits context guarded specified actions 
program initiate longrunning continuation invoking computations unwind action set arbitrarily large number nested dynamic winds defeating time sharing mechanisms established control error abort request 
basic premise program exchange interaction powerful modes cooperation encouraged computational infrastructure risk free possible 
program exchange interaction easier common advances hardware infrastructure increasing numbers computers growing network connectivity hindered computer systems provide little protection danger inflicted unknown programs 
techniques proposed attain safety 
employ security kernel simple powerful semantics allows fine grained control privileges 

invoked program privileges needs job 
rights secondary storage devices shouldn implicitly inherited invoking agents privilege set 

certify program passed reliable safety test 

label seal objects authenticated 
ideas particularly new 
derived saltzer schroeder protection computer systems lays desiderata secure systems 
principle economy mechanism principle privilege principle separation privilege 
main novelty demonstration spare security kernel derived principles spanning operating system programming language gulf simultaneously secure practical 
previous actors connection lambda calculus message passing actor semantics known 
application lambda calculus corresponds message passing actor systems argument sequences playing role messages 
actor languages scheme developed programming language frameworks little explicit attention security concerns cooperation mutually suspicious agents 
security course implicit fact actor procedure sent message inspected transfer control argument sequence transmitted part caller environment 
provision authentication actor recognition data types actor languages scheme 
multi user simulation environment muse mud multi user moo mud objectoriented simulates world number places rooms inhabited users players characters 
muse typically runs network accepts connections users 
users move place place communicate manipulate simulated physical objects 
objects may value users users programs may attempt actions harm objects generally open door policy security important issue muse design administration 
programming languages particular feature caller privileges aren implicitly passed called program 
certainly improvement behavior mainstream operating systems give caller privileges callee 
correct behavior dictated demands environment users encounter strange objects things causes invocation programs belonging objects creators 
generally ad hoc programming languages peculiar features lead security problems inflexibility 
lack security fact special privilege programmer 
new members muse convince administrator worthy allowed write new programs 
system resembles scheme simple multi user scheme programming environment operating system 
similarity ends 
extends scheme hierarchical globally accessible namespace objectoriented programming framework 
global namespace analogous conventional file system access controlled access control lists attached objects 
obvious way implement data types authentication 
discussion schroeder thesis schroeder studied problem cooperation mutually suspicious principals dissertation 
describes extension multics operating system caller callee cross domain call may protect resources 
aware problem protecting parameters unauthorized transmission particular say cases may desirable guarantee protected subsystem invoked remember divulge values input parameters 
problem appears difficult solve purely technical way considered thesis 
page operating system security status quo operating systems vms unix dos windows don effectively address safe invocation problems 
program invoked inherits privileges invoker 
assumption program user runs absolutely trustworthy 
safe invocation implemented versions unix require heavy machinery 
way privileged program invokes program privileges specially unprivileged user 
program standard created ordinary user 
different implementation network server dedicated purpose result strangely limited awkward file descriptors couldn passed interrupts act strangely 
unix facility program owner mark program way program invoked runs program owner privileges invoker arguments sounds similar safe invocation procedures reads fine print points program obtain invoker privileges simply doing setuid system call 
common operating systems distinguish persistent objects files volatile objects unix file descriptors 
open system call coerces persistent object volatile 
persistent objects global names volatile objects short numeric indexes interpreted locally running program 
scoping resemble procedure successor links 
volatile objects passed program process invokes way 
operating system designs support secure program invocation ways similar describe designs aren deployed 
remarkable get secure cooperation 
people programs place high level trust people write programs 
basic reason high level trust computer systems isolated 
communication theft stolen goods communicated back thief 
harm arises vandalism accident 
vandalism current epidemic computer viruses sophisticated untraceable difficult carry little payoff perpetrator really harmful accidents commercial software product accidentally erases disk rare 
section points various shortcomings scheme attempts suggest ways fixing 
dreams driving extend scheme cover operating system services including device drivers 
point possible dispense host operating system run scheme stand workstation mobile robots 
preemption means preempt running process necessary operating system 
agent invoking unknown object runs risk invocation nonterminating agent way request invocation halted condition receipt special input outside processor abort key button passage predetermined amount time 
preemption desirable necessary support class continuations coroutines sufficient constructing scheduler simulates multiple hardware processing elements software 
particularly elegant design timed preemption facility mechanism known engines dybvig hieb published general implementation 
engines timed preemption providing way run computation specified amount time 
sufficient construct user mode task scheduler 
dybvig hieb engine implementation problems system caller callee mutually suspicious 
response time sensitive engine nesting depth malevolent callee pile deeply nested sequence engines making response outer engine priority arbitrarily sluggish 

design specifying engines interact waits interrupts associated concurrent activities 
problems solved believe engines serve part 
scheme supports multitasking scheduler threads system threads inferior engines ways 
threads secure engines share processor proportional threads want take processor need create lots threads 
scheme threads give reliable way monitor execution time supervised untrusted computation computation spawn new threads 
way limit monitor amount processor time allocated thread threads system doesn keep track processor time thread 
continuations class continuations troublesome caller callee mutually 
scheme call current continuation operator callee obtain continuation invoke twice 
caller continuation code performs side effect vulnerable having side effect happen twice may unexpected undesired 
code invokes untrusted objects prepared possibility 
deal contingency requires code similar returned 
new cell cell set 
returned 
result untrusted arg cell ref returned 
error didn expect cell set 
returned 
side effect 
retained continuation undesirable resource allocation standpoint continuation creator penalized tying resources space consumed continuation 
machine programs supporting execution compiler generated machine code programs important reasons vastly improve performance relative scheme current byte code interpreter existing compilers scheme run useful programs written variety languages pascal 
main difficulty supporting machine programs ensuring kernel security policy followed machine program obtain access resources shouldn access 
easily happen machine programs construct arbitrary addresses attempt dereference construct arbitrary machine code sequences jump 
object uses memory machine program address space accessible sequence machine instructions risk 
approaches eliminating risks associated machine programs ffl limitation switch limited user mode invoking machine program 
approach operating systems 
user mode memory belonging program protected access hardware permitted 
instructions alter memory protection registers disabled 
protected environment established instructions permitted actively prohibited 
ffl verification trusted program scans machine program sure doesn shouldn 
programs rejected 
ffl sandboxing similar verification extra code inserted troublesome instructions dynamically ensure security policy respected :10.1.1.142.4909
programs may rejected fewer verification 
ffl trusted compilation program generated compiler may respect security policy construction trust compiler trust output 
type array bounds safety compilers scheme pascal compilers sufficient guarantee kernel security policy respected 
compilers may change 
limitation may option little influence compiler program compiled 
example programs pointers ways difficult guarantee safe verification sandboxing compilers generate object code checks validity pointers 
limitation avoided transfers user mode expensive hardware architectures 
hand programs control transfers programs memory protection hardware may efficient way detect invalid pointers array indexes implement kernel security policy 
important part implementation machine program support interface machine programs kernel 
machine program perform kernel operation creating invoking procedure operands generally object specified 
answered differently depending extent machine program trusted 
machine program trusted object represented pointers data structures representing objects kernel operations implemented subroutine calls object creation accomplished call allocation routine code sequences occurring directly program invocation procedure compiled similarly local procedure call 
machine program untrusted transfers control outside program generally accomplished trap system call 
hardware architectures support general calls protection domains object amenable validation program may arbitrary bit pattern putative object 
method operating systems similar circumstances associate activation untrusted machine program table mapping small integer indexes objects 
unix indexes known file descriptors 
program presents index kernel interprets specifying object position table 
validation consists simple range check determine index table 
alternatively objects may unique names addresses memory names untrusted machine programs 
program presents name kernel operation kernel validates name determining occurs object table specific program activation 
approach similar approach protection 
kernel little reason prefer small index approach table searches unique name maintenance complicated inefficient relative indexes determined program compiled installed 
reflection reflection reasoning self 
computing system concept reflection examining internal structure objects continuations purposes debugging analysis optimization 
reflection interacts security issues ways knowledge researched resolved 
example scheme debugger access special reflective operators break protection boundaries examine internals procedures records continuations 
useful unfortunately debugger insecure allows user access value transitively accessible accessible object 
easy achieve security scheme disabling debugger better solution kernel provide simple safe way examine continuations procedures unprivileged debugger built 
believe done way user able see ought entitled see 
particular user able see information exists object representations long information available included extra debugging hooks programs 
issues persistence 
support needed keeping objects secondary storage efficiently guarantees objects necessarily survive crashes 
currently scheme relies external file system store information persistently integrated internal protection system fact access file system limited 
quotas 
limits imposed amount memory agents allowed 
malevolent buggy program consume available space making system 
memory limitation difficult execution time limitation allowed space decreases memory allocated increase memory reclaimed garbage collection 
object associated account credited object reclaimed 
done putting extra field object indicating account maintaining distinct regions memory different accounts 
reminiscent multi stage garbage collection unified 
accountability 
goes wrong nice know responsible exactly went wrong 
responsibility difficult assign cooperative enterprises 
particular goes wrong agent invokes agent program responsible 
server receives request client server client responsible ensuring request reasonable safe 
revocation 
way scheme revoke access object 
objects simulating revokable links defined cells obvious sufficient 
decide giving access object 
times want revoke link precisely times didn anticipate want 
distribution 
network encapsulated objects lends distribution network computer systems 
major component distributed operating system missing scheme remote invocation mechanism classically called rpc remote procedure call 
mechanism properties ffl objects passed arguments returned results 
requires automatic creation stub delegate objects forward calls network 
ffl calls properly tail recursive call node node call node specifying result sent ffl exceptions distributed transparently exception machine find correct exception handler machine 
alan bawden described implemented relevant phd thesis 
contributions success scheme shows spare security kernel provide flexible solid security difficult program 
simpler security kernels 
complexity operating system kernels arises performance concerns address rational comparison difficult 
difficult see smaller services provides shown necessary program object creation invocation object marking authentication primitive access devices 
scheme community believe procedures primitive data types symbols cells serve basis construction useful programming constructs 
hope discussion authentication data types section seen refute position show need built authentication mechanism minimal programming languages 
ease trojan horses viruses may computer systems extent users blindly trust software provided vendors 
hope contributed bit currently unpopular cause principled solutions security problems 
hope document helps break artificial distinction programming languages operating systems 
progress areas hindered failure recognize concerns fundamentally 
needed operating systems provide services useful languages languages give convenient access operating system services 
report extracted dissertation complete section reproduced 
joseph weizenbaum generously allowing office long final stretch 
gerry sussman ai bruce donald cornell gregor kiczales xerox parc moral financial support guidance ideas 
hal abelson tom knight serving committee 
richard kelsey hard helped bring scheme life 
norman adams clinger productive collaborations 
alan bawden david espinosa dave gifford philip ian horswill dave mcallester jim toole brian bill mark sheldon olin shivers turbak tech square making life mit just tolerable interesting amusing 
russell brown jim jennings daniela rus cornell computer science robotics vision laboratory humor 
kathleen mike dixon john lamping brian smith xerox parc creating environment peculiar ideas 
butler lampson clear explanations 
hal abelson frans kaashoek tom knight mark sheldon olin shivers gerry sussman turbak comments suggestions drafts document 
marilyn pierce making administrative go away 
rebecca making 
albert meyer 
tom collett giving reason finish 
laura burns heine kris jacobson geoff generosity emotional support strange times 
arpa nsf projects employed numerous mention 
diverse array model glow dark wind beetle pop puppet ants cricket 
norman adams iv jonathan rees 
object oriented programming scheme 
proceedings acm conference lisp functional programming pages 
gul agha 
actors model concurrent computation distributed systems 
mit press cambridge ma 
david albert 
issues muse security 
manuscript 
alan bawden 
linear graph reduction confronting cost naming 
phd thesis mit 
nathaniel borenstein marshall rose 
mime extensions mail enabled applications application safe tcl multipart enabled mail 
working draft 
internet ftp ftp fv com pub code safe tcl tar 
william clinger jonathan rees 
macros 
proceedings eighteenth annual acm symposium principles programming languages pages january 
william clinger jonathan rees editors 
revised report algorithmic language scheme 
lisp pointers iv july september 
pavel curtis 
programmer manual version 
xerox ftp xerox com pub moo txt 
kent dybvig robert hieb 
engines continuations 
computer languages 
adele goldberg david robson 
smalltalk language implementation 
addison wesley 
christopher haynes daniel friedman 
engines build process abstractions 
conference record acm symposium lisp functional programming pages 
ieee std 
ieee standard scheme programming language 
institute electrical electronic engineers new york ny 
richard kelsey jonathan rees 
tractable scheme implementation 
lisp symbolic computation appear 
butler lampson 
note confinement problem 
cacm 
henry levy 
capability computer systems 
bedford ma digital press 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
david moon 
genera retrospective 
international workshop object oriented operating systems 
james morris jr protection programming languages 
cacm 
jonathan rees 
module system scheme 
ftp ftp swiss ai mit edu pub scheme tar gz march 
jonathan rees 
june meeting 
lisp pointers october december 
jonathan rees 
security kernel lambda calculus 
ph dissertation mit 
jonathan rees norman adams 
dialect lisp lambda ultimate software tool 
conference record acm symposium lisp functional programming pages 
jonathan rees bruce donald :10.1.1.50.8035
program mobile robots scheme 
proceedings ieee international conference robotics automation pages 
rivest shamir adleman 
method obtaining digital signatures publickey cryptosystems 
communication acm feb 
guillermo 
procedures abstraction opacity 
phd thesis mit may 
jerome saltzer schroeder 
protection information computer systems 
proceedings ieee 
michael schroeder 
cooperation mutually suspicious subsystems computer utility 
ph thesis mit project mac tr 
brian smith 
reflection semantics lisp 
proceedings eleventh annual acm symposium principles programming languages pages salt lake city january 
guy lewis steele jr gerald jay sussman 
lambda ultimate imperative 
mit ai memo 
robert 
multi user programming environment scheme 
bulletin irisa campus de beaulieu france july 
gerald jay sussman guy lewis steele jr scheme interpreter extended lambda calculus 
mit ai memo 
swinehart cedar 
toplas 
robert wahbe steven lucco thomas anderson susan graham :10.1.1.142.4909
efficient software fault isolation 
proceedings fourteenth acm symposium operating system principles pages december 
william wulf roy levin samuel harbison 
hydra mmp experimental computer system 
mcgraw hill 

