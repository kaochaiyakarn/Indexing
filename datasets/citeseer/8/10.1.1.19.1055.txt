journal artificial intelligence research submitted published critical assessment benchmark comparison planning adele howe howe cs colostate edu eric cs colostate edu computer science department colorado state university fort collins trends planning research led empirical comparison commonplace 
field started settle methodology comparisons obvious practical reasons requires running subset planners subset problems 
characterize methodology examine implicit assumptions problems planners metrics comparisons 
problem assumptions pr performance general purpose planner penalized biased executed sampling problems domains pr minor syntactic differences representation affect performance pr problems solvable strips capable planners require adl 
planner assumptions pl latest version planner best pl default parameter settings approximate performance pl time cut offs unduly bias outcome 
metrics assumptions performance degrades similarly planner run degraded runtime environments machine platform number plan steps distinguishes performance 
find assumptions supported empirically particular planners affected differently assumptions 
conclude call community devote research resources improving state practice especially enhancing available benchmark problems 

years comparative evaluation increasingly common demonstrating capabilities new planners 
planners directly compared problems taken set domains 
result advances planning translated dramatic increases size problems solved weld empirical comparison highlighted improvements 
comparative evaluation planning significantly influenced expedited artificial intelligence planning scheduling aips conference competitions 
competitions dual effect highlighting progress field providing relatively unbiased comparison state art planners 
individual researchers compare planners include fewer planners fewer test problems time constraints 
support competition mcdermott drew mcdermott defined contributions organizing committee shared problem domain definition language pddl mcdermott planning domain definition language 
fl ai access foundation morgan kaufmann publishers 
rights reserved 
howe common language means planners performance directly compared entailing hand translation factoring different representational capabilities 
second benefit lack translation human accomplished translation meant performance compared large number problems domains fact competition planners large number problems problems adl track strips track domains including domain planner developers seen prior competition 
competition generated large collection benchmarks domains competition plus considered 
domains available ftp ftp cs yale edu pub mcdermott domains 
second competition added novel domains set 
third major benefit competitions appear motivated researchers develop systems 
number entrants went competition second 
additionally competitors sixteen competitors code available web sites 
perform comparisons 
describe current practice comparative evaluation evolved aips competitions critically examine underlying assumptions practice 
summarize existing evidence assumptions describe experimental tests previously considered 
assumptions organized groups concerning critical decisions experiment design problems tested planners included performance metrics collected 
comparisons part competitions specific researchers proven enormously useful motivating progress field 
goal understand assumptions readers know far comparative results generalized 
contrast competitions community fairness individual researcher comparative evaluations readers may able identify cases results viewed confidence 
conclude observations call considerably research new problems metrics methodologies support planner evaluation 
contrast competitions goal declare winner 
goal critique individual studies 
consequently draw attention away possible interpretation possible report results letter designators assigned randomly planners 

planning competitions direct comparisons aips competitions spurred considerable interest comparative evaluation 
roots comparative planner evaluation go back considerably 
researchers able run side side comparisons planners 
solve particular planning problem construct sequence actions transform initial state goal state planners require domain theory problem description 
domain theory represents actions executed environment typically domain descriptions include variables instantiated specific objects values 
multiple problems defined domain problem descriptions require initial state description goal state association domain 
critical assessment benchmark comparison planning able demonstrate performance planner known problems viewed de facto benchmarks 
sussman anomaly sussman blocksworld premier planning benchmark problem domain years planner needed cut teeth 
researchers tired blocksworld called additional benchmark problems environments 
mark drummond leslie kaelbling stanley rosenschein organized workshop benchmarks metrics drummond kaelbling rosenschein 
testbed environments martha pollack tileworld pollack ringuette steve hanks hanks nguyen thomas comparing algorithms planners 
ucpop penberthy weld distributed large set problems problems domains demonstration purposes 
barry fox mark set planning scheduling benchmarks web page www com collect problem definitions emphasis manufacturing applications 
planet coordinating organization european planning scheduling researchers proposed planning benchmark collection initiative planet dfki de 
clearly benchmark problems established means demonstrating planner performance 
practice known benefits pitfalls hanks pollack cohen discuss detail context agent architecture design 
benefits include providing metrics comparison supporting experimental control 
pitfalls include lack generality results potential benchmarks unduly influence generation solutions 
words researchers construct solutions excel benchmarks regardless benchmarks accurately represent desired real applications 
obtain benefits just listed benchmarks problems idealized simplified versions real problems 
cohen points research papers ai aaai conference exploit benchmark problems relate benchmarks target tasks 
may significant problem example study scheduling benchmarks performance standard benchmark set generalize performance problems realistic structure watson barbulescu howe whitley 
study just blocksworld problems best known blocksworld benchmark problems atypical require short plans solution optimal solutions easy find slaney 
spite difficulties benchmark problems aips competitions considerably influenced comparative planner evaluations 
example aips conference proceedings chien kambhampati knoblock papers improvements classical planning papers conference relied heavily comparative evaluation benchmark problems papers concerned scheduling specific applications theoretical analyses special extensions standard paradigm pomdp sensing 
classical papers problems aips competition benchmark set problems kautz selman distribution problems blackbox kautz added problems 
showed results subset problems benchmark distributions 
scheduling area related planning actions known sequence needs determined 
scheduling type manufacturing scheduling problem 
howe drew mcdermott competition logistics blocksworld rocket gripper domains popular papers respectively 
availability planners competition exploited papers compared systems aips planners blackbox stan ipp hsp papers respectively 

assumptions direct comparison canonical planner evaluation experiment follows procedure table 
procedure designed compare performance new planner previous state art highlight superior performance set cases new planner 
exact form experiment depends purpose showing superiority class problem highlighting effect design decision 

select construct subset planner domains 
construct problem set ffl running large set benchmark problems ffl selecting problems desirable features ffl varying facet problem increase difficulty number blocks 
select planners ffl representative state art problems ffl similar distinct new planner depending point comparison advance new planner ffl available able parse problems 
run problems planners default parameters setting upper limit time allowed 
record problems solved plan steps actions solution cpu time required solve problem fail time table canonical comparative planner evaluation experiment 
protocol depends selections problems planners evaluation metrics 
simply practical desirable run available planners available problems 
needs informed decisions select 
purpose examine assumptions underlying decisions help informed 
planner comparison adopt assumptions assumptions ones commonly planner comparisons 
example comparisons designed specific purpose show scale certain problems suitability planner logistics problems carefully select particular types problems benchmark sets 
critical assessment benchmark comparison planning problems planning systems developed solve particular type planning problem explore specific type algorithmic variation 
consequently expect perform better problems developed 
designed specific purpose test set development may subtly biased development 
community knows planner performance depends problem features general 
researchers tend design planners general purpose 
consequently comparisons assume performance general purpose planner penalized biased executed sampling problems domains problem assumption 
community knows problem representation influences planner performance 
example benchmark problem sets include versions blocksworld problems designed different planner developers 
versions vary problem representation minor apparently syntactic changes clauses ordered operators initial conditions goals information extraneous changes reflecting addition domain knowledge constraints included variables typed 
consequently comparisons assume syntactic representational modifications matter affect planner equally problem assumption 
pddl includes field requirements capabilities required planner solve problem 
pddl defined values requirements field base default requirement strips meaning strips derived add delete sets action effects 
adl pednault action description language requires variable typing disjunctive preconditions equality built predicate quantified preconditions conditional effects addition strips capability 
planners ignore requirements field reject problem specifies adl ignoring requirements cause trouble 
comparisons assume problems benchmark set solvable strips planner require adl problem assumption 
planners wonderful trend making planners publicly available led dilemma determining configure 
problem compounded longevity planner projects projects produced multiple versions 
consequently comparisons tend assume latest version planner best planner assumption 
planners may include parameters 
example blackbox planner allows user define strategy applying different solution methods 
researchers expect parameters affect performance 
consequently comparisons assume default parameter settings approximate performance planner assumption 
howe experiments invariably time cut offs concluding planning solution declared failure 
planners need exhaustively search large space declare failure 
practical reasons time threshold set determine halt planner failure declared time reached 
comparisons assume picks sufficiently high time threshold highly solution slightly time granted planner assumption 
metrics ideally performance measured planner job constructing best possible plan solve problem efficiently 
planner shown solve possible problems basic metric performance number percentage problems solved allowed time 
metric commonly reported competitions 
research papers tend report directly typically test relatively small number problems 
efficiency clearly function memory effort 
memory size limited hardware 
effort measured cpu time preferably platform language 
problems cpu time known programmer skill varies research code designed fast prototyping fast execution numbers literature compared newer numbers due processor speed improvements 
cpu times regenerated experimenter environment assumes performance degrades similarly reductions capabilities runtime environment cpu speed memory size metric assumption 
words experimenter user system expect code optimized particular compiler operating system hardware configuration perform similarly moved compatible environment 
commonly reported comparison metric computation time 
second number steps actions planners allow parallel execution plan 
planning seeks solutions achieving goals goals defined terms states world lend general measures quality 
fact quality problem dependent resource cost amount time execute robustness number plan steps favored 
comparisons assume number steps resulting plan varies planner solutions approximates quality metric assumption 
comparison competitions especially task determining trade combine metrics number solved time number steps 
number steps matter comparison simplified 
converted assumption testable question 
summarized literature question ran experiment test 
critical assessment benchmark comparison planning experimental setup key issues examined previously directly indirectly 
simply summarize results subsections follow 
open questions 
ran known planners large set benchmark problems 
planners accept pddl representation built translators pddl internal representation rely translators added 
versions planner available included total planners 
basic problem set comprises ucpop benchmarks aips competition test sets additional problem set developed specific application 
exception permuted problems see section problem assumption specifics problems run mhz ultrasparc megabytes memory running sunos 
possible versions compiled developers source code available compiled systems developers instructions 
planners written common lisp run common lisp version 
planners compiled gcc version 
planner minute limit wall clock time find solution times reported run times returned operating system 
planners planners called primitive action planners wilkins desjardins planners require relatively limited domain knowledge construct plans simple action descriptions 
aips competition required planners accept pddl majority planners study competition entrants versions thereof common language facilitated comparison planners having address effects translation step 
exceptions ucpop prodigy representations similar pddl translated automatically 
planners represent different approaches planning plan graph analysis planning satisfiability planning heuristic search state space planning learning partial order planning 
possible multiple versions planner necessarily 
conducted study period time years set early comparing performance declare winner think lack versions undermined results testing assumptions 
ipp koehler nebel hoffmann dimopoulos extends graphplan blum furst algorithm accept richer plan description language 
early versions language subset adl extends strips formalism graphplan allow conditional universally quantified effects operators 
version negation handled new predicates negated preconditions 
actual time lightly loaded machines occasionally system thrash due inadequate memory resulting little progress considerable time 

bus system manager running planners howe hansen von mayrhauser implemented aips competition planners 
facilitated running different planners somewhat bias included 
howe corresponding mutual exclusion rules subsequent versions handle directly koehler 
aips version ipp version 
sgp sensory graph plan weld anderson smith extends graphplan richer domain description language primarily focusing uncertainty sensing 
ipp transformation performed expansion techniques remove quantification 
sgp directly supports negated preconditions conditional effects 
sgp tends slower implemented common lisp graphplan planners 
sgp version 
stan state analysis fox long extends graphplan algorithm part adding preprocessor called tim infer type information problem domain 
information planning algorithm reduce size search space graphplan algorithm search 
stan incorporated optimized data structures bit vectors planning graph help avoid redundant calculations performed graphplan 
additionally stan maintains wave front graph construction track remaining goals limit graph construction 
subsequent versions incorporated analyses symmetry exploitation additional simpler planning engine 
versions stan tested aips competition version version version development snapshot version 
blackbox kautz selman converts planning problems boolean satisfiability problems solved variety different techniques 
user indicates techniques tried order 
constructing satisfiability problem blackbox uses planning graph constructed graphplan 
blackbox version version 
hsp heuristic search planner bonet geffner heuristic search 
planner uses variation hill climbing random restarts solve planning problems 
heuristic graphplan algorithm solve relaxed form planning problem 
study version algorithmic refinement version entered aips competition version 
prodigy prodigy research group combines state space planning backward chaining goal state 
plan construction consists head plan totally ordered actions starting initial state tail plan partially ordered actions related goal state 
officially entered competition informal results aips competition suggested prodigy performed comparison entrants 
prodigy version 
ucpop barrett golden penberthy weld partial order causal link planner 
decision include ucpop factors 
expand quantifiers negated preconditions domains expansion grounding operators great problem 
second ucpop significantly different algorithm interest 
ucpop version 
eugene fink code translates pddl prodigy 
critical assessment benchmark comparison planning source domains problems benchmarks aips aips developers application table summary problems testing set source problems number domains problems domains 
test problems standard practice experiments require planners solve commonly available benchmark problems aips competition problems 
addition test assumptions influence domains assumption pr representations problems assumption pr include permuted benchmark problems application problems 
section describes set problems domains study focusing source composition 
problems require strips capabilities add delete lists 
chose common denominator reasons 
capable planners handle strips requirements maximized number planners included experiment 
surprisingly problems type available 
second examining assumptions evaluation including effect required capabilities performance 
propose duplicate effort competitions planners distinction purpose determine factors differentially affect planners 
bulk problems came aips aips problem sets set problems distributed pddl specification 
remaining problems solicited sources 
source counts problems domains summarized table 
benchmark problems preponderance problems planning test sets toy problems known synthetic problems designed test attribute planners 
blocksworld domain long included evaluation known subgoal interactions supports constructing increasingly complex problems towers blocks 
benchmark problems simplified versions realistic planning problems flat tire refrigerator repair logistics domains 
set included ucpop planner 
problems contributed large number people include multiple encodings problems domains especially blocksworld 
aips competitions aips competition drew mcdermott solicited problems competitors constructing mystery domain semantically useless names objects operators 
problems generated domain automatically 
competition included problems domains robot movement grid gripper balls howe moved rooms robot grippers logistics transporting packages organizing movie watching mystery domains disguised logistics problems 
format competition required entrants execute problems round 
problems solved planner 
round planners executed new problems domains included round 
competition attracted competitors tracks strips adl hand tailored track 
required performance problems domains logistics blocksworld parts machining card game elevator control 
domains determined organizing committee fahiem bacchus chair represented somewhat broader range 
chose problems untyped strips track set 
scientific standpoint interesting competitions observed trade offs performance 
planners appeared excel different problems solving set finding solution faster 
ipp solved problems shorter plans round stan solved problems fastest hsp solved problems round blackbox solved problems fastest round 
awards groups distinguished planners different categories planners strips adl hand tailored judges impossible say planner best bacchus ff highest distinguished planner group 
graphs performance show differences computation time relative planners problem scale 
planner failed solve problems trends harder interpret computation time graphs gaps 
purpose competitions showcase planner technology succeeded 
planners solved harder problems accomplished years past 
trend planners handling increasingly difficult problems competition test sets may historical interest tracking field progress 
problems solicited planner developers asked planner developers problems development 
developer maria fox sent domain logistics application set problems 
included domains problems received 
applications elevator domain aips competition derived actual planning application 
domain problems extremely simplified removing arithmetic 
add realistic problem comparison included planning application set test domains generating cases test software interface 
similarities software interface test cases plans developed system years ago automatically generating interface test cases ai planner 
system designed generate test cases user interface storage technology robot tape library howe von mayrhauser 
interface commands interface coded domain theory 
example mount com critical assessment benchmark comparison planning mand action description required drive empty effect changing position tape mounted changing status tape drive 
problems described initial states tape library tapes resident status devices software controller goal states human operator wish achieve 
time simplest problems generated planners available 
included application part knew challenge 
part test set include domain theories different ways coding application involving operators problems domain 
included wanted include problems see effect overly bias results 
problems relatively simple requiring movement tape coupled status changes difficult solved original system 
problem assumptions general purpose planners exhibit differential capabilities domains problems domain 
selection problem set critical evaluation 
example problems benchmark sets variants logistics problems general purpose planner tailored logistics may appear better current benchmarks 
section empirically examine possible problem set factors may influence performance results 
problem assumption extent performance general purpose planners biased particular problems domains 
planners developed general purpose competitions previous studies shown planners excel different domains problems 
unfortunately community understanding planner particular domain 
studied impact problem selection performance ways 
assessed performance positively biased problems tested development 
developer asked indicate domains development 
compared planner performance development problems development set problems remaining complete test set rest 
ran tests comparing number problems solved versus failed development test sets 
included number solved failed analysis timed problems difference results results analysis summarized table graphically displays ratio successes failures development problems 
planners performed significantly better development problems 
suggests planners tailored intentionally particular types problems tend better test sets biased accordingly 
example 
decided studying planners way representations development problems pddl 

planner exception rule case planner timed far frequently non development problems 
howe development rest planner sol 
fail sol 
fail table results comparing outcome development versus problems 
planners set stan designed emphasis logistics problems fox long 
histogram ratios success failures development problems planners 
analysis introduces variety biases 
developers tended give short lists probably really representative 
set moving target stationary suggests 
set problems included experimentation publication may different 
consequently second part broadened question determine effect different subsets problems critical assessment benchmark comparison planning rank dominance total pairs table rank dominance counts samples domains domain sizes 
performance 
trials randomly selected domains companion problems form problem set 
counted problems solved planner ranked relative performance planner 
value obtained planner rankings 
focused rankings problems solved reasons domain includes different number problems making count problems variable trials 
second relative ranking gets heart planner considered improvement 
tested values half domains disposal 
give sense variability size problems solved trial varied 
assess changes rankings trials computed rank dominance pairs planners rank dominance defined number trials planner rank lower planner note ties count planner 
planners study resulted dominance pairings 
relative ranking planners stable expect dominate rank dominance 
table shows number pairs having value rank dominance values pair highest number rank dominance pair lower rank pair rank dominance 
ties maximum 
data suggest picking half domains rankings completely stable pairings dominates greater chance switching relative ranking 
values degrade decreases dominating 
problem assumption syntactic representation differences affect performance 
known planners performance depends representation joslin pollack srinivasan howe developments planner research suggest effect needs better understood 
common representation pddl may bias performance 
planners rely pre processing step convert pddl native representation step usually requires making arbitrary choices ordering coding 
second advantage planners graphplan supposed vulnerable minor changes representa howe planner subset table number problems planners able solve subset permutations 
tion 
reasoning claim sound implementation may require re representation sensitivity 
evaluate sensitivity representation permutations problem aips set generated resulting permuted problems 
permutations constructed randomly reordering preconditions operator definitions order definitions operators domain definition 
limited number problems study permutations problems prohibitive 
selected aips problems attention developed benchmark set 
set domains permuted result different domains transformation 
purposes investigation limited set modifications permutations preconditions operators known affect planners practical considerations limited number permutations executed 
ran permutations smaller number faster platforms expedited throughput computation time factor study 
analyze data divided performance permutations problems groups planner able solve permutations permutations subset permutations 
planner insensitive minor representational changes subset count zero 
results table see planners affected permutation operation 
susceptibility permuting problem strongly planner dependent demonstrating planners vulnerable 
examining number subset column assess degree susceptibility 
planners sensitive reorderings relied graphplan critical assessment benchmark comparison planning planner feature axioms cond 
eff 
dis 
pre 
equality pre 
safety strips typing pre 
table number problems claiming require pddl feature solved planner 
methodology 
sensitive included graphplan planners problems mixed results permutations sensitive affected 
problem assumption performance depend pddl requirements features 
planners intended handle strips problems 
problems test set claim require features strips expect planners able handle problems 
addition planners claim able handle feature may planners 
table shows effects feature requirements ability solve problems 
data table features specified requirements list pddl definition domain 
verify requirements accurate necessary problem may solvable ignoring part pddl syntax understood problem may mislabeled designer 
evident cases planner support feature appears able solve corresponding problem 
planners older versions stan reject problem requires strips trying solve adl problem strips features attempted 
guidance planner results viewed skepticism 
example appear results planner howe choice problems conditional effects able solve problems 
mistake planner handle types problems 
cases problems claim require adl fact strips subset 
clearly certain problems solved specific planners 
instance planners able handle safety constraints data appear handle domain axioms 
half planners trouble typed problems 
gaps appear due problems translation native representation 
planners publicly available general purpose planners tend large programs developed period years enhanced include additional features time 
versions available versions features turned parameter settings 
authors release versions planning systems general assumption newer versions outperform predecessors 
may case practice 
instance planner better optimized specific class problem turn hurts performance problems 
advanced capabilities unused may incur overhead solution problems 
comparison purposes latest version 
tested question study comparing multiple versions planners 
second planner relies parameter settings tune performance 
blackbox parameters 

comparisons tend default published parameter settings people usually understand effects parameters tuning extremely time consuming 
practice undermine fair comparison 
planner assumption latest version best 
study compared performance multiple versions planners labeled section larger version numbers indicating subsequent versions 
considered criteria improvement outcome planning computation time solved problems 
outcome planning solved failed timed 
criterion statistically analyzed data superior performance versions 
outcome results planners summarized table 
table shows rarely new version result problems solved 
improved number test problems solved subsequent versions 
check differences outcome significant ran tests planner version independent variable outcome dependent 
table summarizes results analysis 
compared version successor 
differences significant transition expected versions extremely similar 
planner performance metric evaluated speed solution 
analysis limited comparison just problems solved versions planner 
classified problem version solved critical assessment benchmark comparison planning planner version solved failed timeout delta solved 
table version performance counts outcome change number solved 
old new planner version version table results comparing versions planner 
problem faster slower time preceding version 
results table see planners improved average speed solution subsequent versions exception transition versions 
increase number problems solved versions 
planner old new faster slower total table improvements execution speed versions 
faster column counts number cases new version solved problem faster slower specifies cases new version took longer solve problem 
howe planner assumption parameter settings matter fair comparison 
planner set obvious easily manipulable parameters blackbox hsp ucpop 
blackbox extensive set parameters control trace information print sequence solver applications 
hsp function varied include loop detection change search heuristic vary number paths expand 
ucpop user change strategies governing node orderings flaw selection 
run experiments assumption planners parameters clear literature parameters matter 
blackbox relies heavily random restarts trying alternative sat solvers 
kautz selman authors blackbox carefully study aspects blackbox design demonstrate differential performance different sat solvers propose hypotheses performance differences working better models performance variation 
heart hsp heuristic search 
performance varies depending heuristics 
experiments hsp ff planner builds ideas hsp shown importance heuristic selection search space expansion computation time problem scale geffner hoffmann nebel 
hsp heuristic search critical ucpop performance 
set studies explored alternative settings flaw selection heuristics employed ucpop joslin pollack srinivasan howe schubert producing dramatic improvements domains heuristics 
pollack 
confirmed default strategy derived performance best circumstances 
parameters control fundamental aspects algorithms search strategies role parameters comparisons easily dismissed 
planner assumption time cut offs unfair 
planners admit failure 
planner stops allotted time solution 
setting time threshold requirement planner execution 
comparison wonder time allotted fair solution execution terminated 
determine cut minutes fair examined distribution times declared successes failures planners problem set distributions skewed approximately log normal long right tails planners quick declare success failure going 
table shows max mean median standard deviation success failure times planners 
differences mean median indicate distribution skew low standard deviations relative observed max times 
max time shows rare occasions planners decision minutes cut 

separated usually observed significant difference distributions time succeed time fail half planners quick succeed slow fail half reversed relationship 
critical assessment benchmark comparison planning successes failures planner max mean median sd max mean median sd table max mean median standard deviations sd computation times success failure planner 
table show observed distributions show values greater half time cut 
figures display distributions planner means middle set planners quite typical distributions 
consequently problems cut minutes seconds significantly change results 
success time histogram times seconds planner succeed 
howe fail time histogram times seconds planner fail 
performance metrics comparisons emphasize number problems solved cpu time completion metrics 
problems organized increasing difficulty show scale 
comparing metrics leaves lot open interpretation 
example planners designed find optimal plan measured number steps parallel sequential plan 
consequently planners may require computation 
ignoring plan quality planners may unfairly judged 
hypothesize hardware software platform tests vary results 
planner developed machine gb memory performance degrade 
key issue effect uniform set planners 
section examine issues execution platform effect plan quality 
metric assumption performance vary planners run different hardware platforms 
planner run competition lab hardware software platforms differ platform development 
clearly slowing processor speed slow planning requiring higher cut offs 
reduction memory may change set problems solved increase processing time due increased swapping 
changing hardware configuration may change way memory cached organized favoring planners internal representations 
changing compilers affect amount type optimizations code 
exact effects probably unknown 
assumption changes affect planners equally 
test ran planners powerful lower memory machine compared results platforms base sun ultrasparc mb memory ultrasparc mb memory 
operating system compilers versions machines 
problems run platforms 
followed methodology comparison planner versions comparing number problems solved time solution 
table shows results measured problems solved failed timed planner platforms 
critical assessment benchmark comparison planning planner platform solved failed timed reduction ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra ultra table number problems solved failed timed planner hardware platforms 
column percentage reduction number solved faster slower platforms 
howe planner faster slower total mean delta sd delta mean delta sd delta table improvements execution speed moving slower faster platform 
counts problems solved platforms 
faster slower mean standard deviation sd difference provided 
looked change time solution 
table shows time solution changes planner 
surprisingly faster processor memory nearly lead better performance 
somewhat surprisingly difference far doubling expected mean differences mean times faster processor see table mean solution times 
effect vary planners 
counts lisp planners appear susceptible trend ones faster slower platform 
advantages small affecting primarily smaller problems 
think effect due need load lisp image startup centralized server computation time small problems dominated network delay 
older versions planners appear sensitive switch platform 
study platforms little difference results despite doubling processor speed doubling memory 
platforms compared development platforms planners 
chose platforms differed characteristics processor speed memory amount access identically configured machines 
really observe difference gb memory may needed 
trends planning technology exploited cheap memory translations propositional representations compilation problems built caching memory management techniques 
planners designed trade memory time 
propose amount requested participants aips planning competition 
critical assessment benchmark comparison planning planners understandably affected memory limitations problems 
results study considered performing careful study memory artificially limiting memory planners access sufficiently large machines difference devise scheme fairly doing planners implemented different languages require different software run time environments 
important factor may memory architecture management 
planners include memory managers map better hardware platforms hsp uses linear organization appears fit intel memory architecture 
metric assumption number plan steps vary 
researchers examined issue measuring plan quality directing planning perez estlin mooney chien 
number steps plan weak measure plan quality far widely primitive action planning 
expect planners sacrifice quality measured plan length speed 
ignoring measure plan quality may unfair planners 
check appears factor problem set counted plan length plans returned output compared lengths planners 
planners construct parallel plans adopted general definition sequential plan length 
compared plan lengths returned planner successfully solved problem 
problems solved planner necessarily 
planners equal length solutions remained problems 
calculated standard deviation sd plan length solutions problem analyzed sds 
minimum observed sd maximum mean standard deviation 
thirteen cases showed sds higher 
obviously cases involved fairly long plans steps cases problems logistics gripper domains 
check planners favored minimal lengths counted number cases planner shortest length plan ties attributed planners variance plan length 
table lists results 
planners find shortest length plans third problems 
planner designed optimize plan length shows results 
exception older planners rarely find shortest plans 

interpretation results recommendations previous section summarization analysis planner runs 
section reflect results mean empirical comparison planners summarize results recommend partial solutions 
possible guarantee fairness propose magic formula performing evaluations state practice general certainly improved 
propose general recommendations recommendations targeted specific assumptions 
howe planner count table number plans planner shortest plan 
data include problems different length plans 
targeted recommendations amount requesting problem planner developers precise requirements expectations contributions 
planners extremely complex time consuming build documentation may inadequate determine subsequent version differs previous conditions parameter settings problem types planner fairly compared 
current positive trend making planners available developer include information distribution system 
sweeping recommendation shift research focus away developing best general purpose planner 
competitions planners identified superior ones designed specific classes problems ff ipp 
competitions done great job exciting interest encouraging development public availability planners incorporate representation 
advance research informative comparative evaluations designed specific purpose test hypothesis prediction performance planner experimental hypothesis focuses analysis leads naturally justified design decisions experiment 
example hoffmann nebel authors fast forward ff system state jair ff development motivated specific set benchmark domains system heuristic designed heuristics fit expectations needs domains hoffmann nebel 
additionally part evaluation compare specific system system commonalities point various advantages disadvantages design decisions specific 
paul cohen advocated experimental methodology artificial intelligence hypotheses predictions models considerable detail see cohen 
critical assessment benchmark comparison planning problems 
follow researchers comparing systems ff defined starting point comparison 
recommendation experiments driven hypotheses 
researchers precisely articulate advance experiments expectations new planner augmentations existing planner add state art 
expectations turn justify selection problems planners metrics form core comparative evaluation 
general issue results accurate 
reported results output planners 
planner stated output successful took face value 
examining output determined claims successful solution erroneous proposed solution 
way ensure output correct solution checker 
drew mcdermott solution checker aips competition 
planners provide output compatible format checker 
concern comparative evaluation output needs cross checked 
declaring winner planner exhibited superior performance think lack solution checker casts serious doubt results 
part concerned factors cause observed success rates change 
recommendation just input standardized pddl output standardized format returned plans 
general issue benchmark sets representative space interesting planning problems 
test directly fact sure clustering results observations planning community suggest set biased logistics problems 
additionally problems getting dated longer distinguish performance 
researchers begun formally analyze problem set service building improved planners hoffmann nebel better understand planning problems 
example related area scheduling group identified distinctive patterns topology search spaces different types classical scheduling problems related topology performance algorithms watson beck barbulescu whitley howe 
planning hoffmann examined topology local search spaces small problems benchmark collection simple structure respect known relaxations hoffmann 
additionally worked partial taxonomy characteristics analyzed domains 
analyzed computational complexity subclass benchmarks transportation problems identified key features affect difficulty problems 
recommendation benchmark problem sets evaluated 
problems easily solved removed 
researchers study benchmark problems domains classify howe problem types key characteristics 
developers contribute application problems realistic versions evolving set 
remainder section describes recommendations improving state art planner comparisons 
problem assumption general purpose planners biased particular problems domains 
set problems planner developed strong effect performance planner 
effect unintentional specialization result concerted effort part developers optimize system solve specific problem 
exception planner fared better tailored subset problems training set 
consequently conclude choice subset problems may affect outcome comparison 
fair planner comparison account biases problem set 
performance certain class problems imply performance general 
large performance differential planners targeted problem domain focus problems poorly may indicate developers succeeded optimizing performance planner 
recommendation problem sets constructed highlight designers expectations superior performance planner specific selection criteria 
hand goal demonstrate board performance results randomly selecting domains suggests biases mitigated 
recommendation highlighting performance general problems goal problem set selected randomly benchmark domains 
problem assumption syntactic representation differences affect performance 
studies including shown planners may sensitive representational features 
just representations translated automatically mean performance unaffected 
just algorithm theoretically insensitive factor mean practice planners showed sensitivity permuted problems degree sensitivity varied 
outcome suggests translators minor variations problem descriptions impact outcome care especially sensitivity focus study planner vulnerable effect 
recommendation representation translators avoided native versions problems testing multiple versions problems necessary 
planner developers participating aips competitions issue 
importantly researchers explicitly testing effect alternative planning problems determine sensitivity performance separate effects advice tuning essence problem 
critical assessment benchmark comparison planning recommendation studies consider role minor syntactic variations performance include permuted problems initial conditions goals preconditions actions problem sets demonstrate robustness provide opportunity learning protect developers accidentally fitting algorithm set test problems 
problem assumption performance depend pddl requirements features 
planners perform quite advertised expected problem features 
discrepancy possible causes problems incorrectly specified planners sensitivity thought solutions correct example problems benchmark set designed competitions intended widely may specified carefully 
recommendation problems contributed benchmark set developers verify requirements stated description problem correctly reflect subset features needed 
planner evaluators problems match planner capabilities 
depending cause results skewed planner may unfairly unable solve problem specifically designed solve 
recommendation addresses gaps specification problem set mismatches capabilities specifiable pddl planners possess remain 
recommendation planner developers develop vocabulary planner capabilities pddl flags specify expected capabilities planner distribution 
planner assumption latest version best 
results suggest new versions run faster solve problems 
newest version may represent best depending definition performance class planner 
competitions fields automatic theorem proving community require previous year best performer compete advantage establishing baseline performance allowing comparison focus may shift time 
recommendation primary evaluation metric speed newer version may best competition 
number problems solved wishes establish progress may worth running older version 
recommendation followed evaluators select version guidance 
planner assumption effect parameter settings 
performance planners vary parameter settings 
unfortunately difficult set parameters properly changing settings difficult compare results experiments 
generally issue howe developers users tend rely default parameter settings 
unfortunately developers exploit alternative settings experiments complicating comparison 
recommendation planner includes parameters developer guide users settings 
default settings developers experiments facilitate comparison 
planner assumption time cut offs unfair 
little benefit increasing time cut offs minutes problems 
recommendation total computation time bottleneck run problems separate batches incrementally increasing time cut runs including unresolved problems subsequent runs 
additional problems solved run 
metric assumption alternative platforms lead different performance experiments performance vary expected 
result suggests researchers general developing specific hardware software configurations trends suggest regards memory 
systems research prototypes developer clear expectations subsequently system accommodate requests studies 
recommendation factors planner design researchers clearly state hardware software requirements planners design platform assumptions 
additionally careful study memory versus time trade offs undertaken trends memory exploitation 
metric assumption number plan steps vary 
certainly 
neglects quality measures planners penalized efforts declare best planner 
recommendation expedite generalizing studies reports describe performance terms solved types time required quality solutions 
tradeoffs reported possible increase computation time decrease plan length 
additionally design goal find optimal solution compare planners design goal 
metrics plan quality needed 
latest specification pddl specification supports definition problem specific metrics fox long metrics indicate total time new concept supported specification action durations specified functions minimized maximized 
addition excellent start general metrics just plan length total time needed expedite comparisons problems 
critical assessment benchmark comparison planning recommendation developing metrics valuable research contribution 
researchers consider worthwhile project conference organizers reviewers encourage papers topic planner developers implement planners responsive new quality metrics support tunable heuristics evaluation criteria 

fair evaluation comparison planners hard 
apparently benign factors exert significant effects performance 
superior performance planner problem intentionally designed solve may explained minor representational features 
comparative analysis general problems practical importance practical create specialized solution problem 
analyzed effects experiment design decisions empirical comparison planners recommendations effects decisions 
recommendations common sense suggestions improving current methodology 
expand current methodology require substantive changes 
field needs question trying show performance planning problems general 
shift general comparisons focused comparisons problem class mechanism hypothesis testing produce significant advances understanding planning 
second benchmark problem sets require attention 
problems discarded simple show 
domains far removed real applications 
may time revisit testbeds 
example researchers robotics constructed interactive testbed comparing motion planning algorithms 
testbed consists user interface defining new problems collection known algorithms simulator testing algorithms specific problems 
user design problems compare performance various algorithms including web site 
testbed affords advantages current paradigm static benchmark problems developer conducted comparisons particular replicability test set 
alternatively challenging problem sets developed modifying deployed applications wilkins desjardins engelhardt chien barrett willis 
years planning community significantly improved size planning problems solved reasonable time advanced state art empirical comparison systems 
interpret results empirical comparisons understand motivate development planning community needs understand effects empirical methodology 
purpose understanding initiate dialogue methodology 
howe acknowledgments research partially supported career award national science foundation iri air force office scientific research 
government authorized reproduce distribute reprints governmental purposes notwithstanding copyright notation thereon 
grateful reviewers careful reading considered comments submitted version hope done justice suggestions 
bacchus 

aips planning competition 
www cs toronto edu aips ppt 
barrett golden penberthy weld 

ucpop user manual 
dept computer science engineering university washington seattle wa 
tr 
blum furst 

fast planning planning graph analysis 
artificial intelligence journal 
bonet geffner 

planning heuristic search new results 
proceedings fifth european conference planning ecp durham uk 
chien kambhampati knoblock 
eds 
proceedings fifth international conference artificial intelligence planning scheduling aips 
aaai press breckenridge cohen 

survey eighth national conference artificial intelligence pulling pulling apart 
ai magazine 
cohen 

empirical methods artificial intelligence 
mit press 
drummond kaelbling rosenschein 

collected notes benchmarks metrics workshop 
artificial intelligence branch fia nasa ames research center 
engelhardt chien barrett willis 

data citizen explorer benchmark problem sets 
proceedings sixth european conference planning ecp toledo spain 
estlin mooney 

learning improve quality planning 
proceedings fifteenth international joint conference artificial intelligence pp 
nagoya japan 
fox long 

efficient implementation plan graph stan 
journal artificial intelligence research 
fox long 

pddl extension pddl expressing temporal planning domains 
available www dur ac uk long pddl ps gz 
critical assessment benchmark comparison planning schubert 

accelerating partial order planners techniques effective search control pruning 
journal artificial intelligence research 
hanks nguyen thomas 

beginner guide simulator 
dept computer science engineering uw cse tr university washington 
hanks pollack cohen 

benchmarks test beds controlled experimentation design agent architectures 
ai magazine 
geffner 

admissible heuristics optimal planning 
proceedings fifth international conference artificial intelligence planning scheduling aips pp 
breckenridge aaai press 


complexity planning transportation domains 
th european conference planning ecp lecture notes artificial intelligence new york springer verlag 
hoffmann 

local search topology planning benchmarks empirical analysis 
proceedings th international joint conference artificial intelligence seattle wa usa 
hoffmann nebel 

ff planning system fast plan generation heuristic search 
journal artificial intelligence research 
howe hansen von mayrhauser 

exploiting competitive planner performance 
proceedings fifth european conference planning durham uk 
howe von mayrhauser 

test case generation ai planning problem 
automated software engineering 
joslin pollack 

cost flaw repair plan refinement strategy partial order planning 
proceedings twelfth national conference artificial intelligence pp 
seattle wa 
kautz selman 

blackbox new approach application theorem proving problem solving 
working notes aips workshop planning combinatorial search pittsburgh pa kautz blackbox sat technology planning system 
www cs washington edu homes kautz blackbox index html 
kautz selman 

unifying sat graph planning 
proceedings sixteenth international joint conference artificial intelligence stockholm sweden 
koehler 

handling conditional effects negative goals ipp 
tech 
rep institute computer science albert university freiburg germany 
howe koehler nebel hoffmann dimopoulos 

extending planning graphs adl subset 
proceedings fourth european conference planning 
mcdermott ghallab howe knoblock ram veloso weld wilkins 

planning domain definition language 
mcdermott 

ai planning systems competition 
ai magazine 
penberthy weld 

ucpop sound complete partial order planner adl 
proceedings third international conference knowledge representation reasoning pp 

perez 

learning search control knowledge improve plan quality 
ph thesis carnegie mellon university 


interactive benchmark planning algorithms web 
proceedings ieee international conference robotics automation 
pollack ringuette 

introducing tileworld experimentally evaluating agent architectures 
proceedings national conference artificial intelligence pp 
boston ma 
pollack joslin paolucci 

flaw selection strategies partial order planning 
journal artificial intelligence research 
chien 

generic incrementally improve plan quality 
proceedings fifth international conference artificial intelligence planning scheduling aips breckenridge slaney 

blocks world revisited 
artificial intelligence journal 
srinivasan howe 

comparison methods improving search efficiency partial order planner 
proceedings th international joint conference artificial intelligence pp 
montreal canada 
sussman 

computational model skill acquisition 
tech 
rep memo 
ai tr mit ai lab 
prodigy research group 
prodigy manual tutorial 
school computer science carnegie mellon university 
watson barbulescu howe whitley 

algorithm performance problem structure flow shop scheduling 
proceedings sixteenth national conference artificial intelligence aaai orlando fl 
watson beck barbulescu whitley howe 

descriptive model local search cost job shop scheduling 
proceedings sixth european conference planning ecp toledo spain 
critical assessment benchmark comparison planning weld anderson smith 

extending graphplan handle uncertainty sensing actions 
proceedings fifteenth national conference artificial intelligence madison wi 
weld 

advances ai planning 
ai magazine 
wilkins desjardins 

call knowledge planning 
ai magazine 

