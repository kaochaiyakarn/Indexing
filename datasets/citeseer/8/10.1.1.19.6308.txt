proc 
large databases conference vldb pp 
translating web data popa yannis ren miller mauricio hern ndez ronald fagin ibm almaden research center harry road san jose ca novel framework mapping combination xml relational schemas high level userspecified mapping translated semantically meaningful queries transform source data target representation 
approach works phases 
phase high level mapping expressed set inter schema correspondences converted set mappings capture design choices source target schemas including hierarchical organization nested referential constraints 
second phase translates mappings queries source schemas produce data satisfying constraints structure target schema preserving semantic relationships source 
nonnull target values may need invented process 
mapping algorithm complete produces mappings consistent schema constraints 
implemented translation algorithm clio schema mapping tool experience clio real schemas 
important issue modern information systems commerce applications providing support inter operability independent data sources 
broad variety data available web distinct heterogeneous sources stored different formats database formats relational model permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings th vldb conference hong kong china university toronto king college road toronto semi structured formats dtds sgml xml schema scientific formats integration data increasingly important problem 
effort involved integration practice considerable translation data format schema requires writing managing complex data transformation programs queries 
new comprehensive solution building refining managing transformations heterogeneous schemas 
prevalent web data exchange data translation tool handle relational data data represented nested data models commonly available web 
solutions applicable structured semi structured data described schema relational schema nested xml schema dtd 
consider exchange documents unstructured data including multimedia unstructured text 
approach distinguished treatment fundamental issues 
discuss highlighting contributions main related 
heterogeneous semantics consider schema mapping problem pair independently created schemas asked translate data source target 
schemas may different semantics may reflected differences logical structures constraints 
contrast heterogeneous data focuses schema integration problem target global schema created source local schemas designed view sources 
target created reflect semantics source independent semantics 
earlier schema mapping considered problem mapping flat single table target schema constraints ignoring half general problem 
contrast section gives semantic translation algorithm preserves semantic relationships translation source target source alternatively local view approach source schema modeled view target schema 
target schemas may contain rich highly heterogeneous constraints 
heterogeneous data content assume source target schema represent data 
certainly may source data represented target omitted translation 
interesting case need data target represented source 
cases values produced undetermined elements attributes target schema target elements corresponding source element 
values may needed target element null elements key default 
importantly creation new values target elements essential ensuring consistency target data may need create values foreign keys target ensure source data correctly mapped 
problem previously addressed specialized translation languages include skolem functions value creation notably ilog 
previous research considered problem automatically determining correct set skolem functions respects target constraints preserves information translation 
data translation algorithm section provides new solution automatically generating missing target values skolem functions guarantees translated data satisfies nested structure constraints target 
developing solutions paid special attention developing algorithms techniques fuel schema mapping tool clio 
design motivated practical considerations 
clio evaluated real world schemas promising results 
section details experience mapping schemas 
solutions highlight main design choices illustrate solutions examples 
example consider schemas 
schemas shown common nested relational representation defined section tool 
left hand schema represents source relational schema tables cid cname city grantee pi amount sponsor proj project name year 
describes information companies projects projects 
specific project 
tuple foreign keys grantee proj referencing associated project tuples 
foreign keys shown dashed lines 
addition principal investigator pi amount amount expensedb rcd companies rcd cid cname city rcd grantee pi amount sponsor proj projects project rcd name year rcd city orgs org rcd cid name set rcd fund rcd pi aid set rcd financial rcd aid amount proj year example source left target right 
sor sponsor 
right hand schema represents target xml schema 
information target contains similar source data structured different way 
organizations projects grouped city 
different city element containing organizations org city 
project funding data nested org related financial information foreign key aid element 
inter schema correspondences perform translation understand schemas correspond 
numerous proposals representing inter schema correspondences including proposals general logic expressions state components schema correspond components 
simplest form correspondence element attribute correspondences 
intuitively element correspondence pair source element target element give formal definition section 
shows example correspondences 
semantically impoverished simple element correspondences reasons 
element correspondences independent logical design choices grouping elements tables normalization choices nesting records tables example hierarchical structure xml schema 
need specify logical access paths join navigation define associations elements involved 
users unfamiliar complex structure schema provide correspondences 
addition automated techniques schema matching proven successful extracting correspondences see survey techniques including cupid lsd dike 
clio modular design lets plug schema matching component 
current version uses automated attribute matcher suggest correspondences provides gui permit users augment correct correspondences 
understanding schema semantics easy create manipulate element correspondences inherently ambiguous 
may transla tions consistent set correspondences effect approach find possible translations consistent constraints schemas 
example consider correspondences 
translate data understand associate name principal investigator 
combinations cname pi values semantically meaningful 
semantic information source schema determine combinations values meaningful 
foreign key constraint grantee cid indicates pi naturally associated foreign key 
populate target place values cname pi correctly target semantic information expressed target schema 
example semantics conveyed constraints nesting structure target 
specifically fund tuples nested org tuples 
org name group pi values nested set 
semantic associations schema set elements associated way 
example may ways associating cname pi 
suppose sponsor sponsor foreign key 
associate cname companies pi join grantee pi sponsor join sponsor 
choice depends semantics represented source schema user 
reasoning data semantics time consuming process large schemas 
clio supports incremental creation modification mappings 
important modifications efficiently 
support compile semantics schemas convenient data structure represents semantic relationships embedded schema 
compiled form semantic translation algorithm efficiently interprets correspondences 
semantic translation semantic translation provides interpretation correspondences faithful semantics schemas 
addition enumerate faithful interpretations call logical mappings 
enumeration mappings essential ingredient approach 
mappings correspond user intentions pair schemas correspondences 
entire process semantic translation semi automatic process 
system generates logical mappings consistent schema specifications user chooses subset 
experience real schemas shown number mappings typically large see section real situations intended semantics includes mappings 
heuristic approach prunes consistent mappings general 
reduce burden user order mappings users focus mappings provide data viewer described uses carefully choosen data examples help explain mapping 
data translation second translation phase data translation generate implementation logical mappings 
result phase set internal rules logical mapping 
rules direct translation external queries provide query wrappers xquery xslt xml case sql relational case 
correctly translate data values may need produced undetermined target elements data may need nested target structure 
example pi amount mapped fund amount financial 
foreign key aid fund aid financial indicates pi values associated amount 
semantic translation algorithm generates logical mapping includes focus 
populate target values aid elements 
maintain proper association target values may arbitrary null 
case elements carry structural information real data correspondence maps aid source 
solution invent id values way maintains source data associations 
section semantic translation algorithm completeness guarantee semantic relationships exist elements schema discovered algorithm 
section contains data translation algorithm converts logical mappings queries rich restructuring constructs resembling ilog wol xml ql :10.1.1.33.2943
section describes experience mapping real schemas prototype 
semantic translation perform schema mapping seek interpret correspondences way consistent semantics source target schemas 
call interpretation process semantic translation 
semantics encoded logical structures call resulting interpretation logical mapping 
data model results simple nested relational data model 
tool relational semi structured schemas including dtds xml schemas represented internally model 
model includes set atomic types set types form setof record types form rcd ak represents atomic set record type 
symbols ak called labels elements 
atomic type ai atomic element 
records type rcd ak unordered tuples label value pairs ak ak ak types respectively 
record elements non repeatable 
elements may repeated modeled set types 
value type setof represented associated set en children ei type 
representation sets set ids faithfully capture graph data models xml 
ease exposition assume schema consists single named root type xml schema 
relational schema multiple tables modeled record type components set types table 
clauses expensedb companies 
contents record projection notation 
model supports optional nullable elements key constraints 
referential constraints foreign keys expressed explained subsection 
primary paths constraints consider correspondences 
understand arrows understand names semantically related pis source schema target elements org name fund pi associated 
treat correspondences separately 
map data independently data 
elements associated interpret correspondences way consistent association 
step learn elements may semantically related schema 
relational schemas semantic associations atomic elements represented ways 
organization attributes tables schema structure indicates semantic groupings 
fact cname city attributes table indicates tuple attribute values semantically related 
addition attributes different tables may associated foreign key dependencies 
example information companies hold projects receive may logical design broken separate tables foreign key dependencies 
www org tr xmlschema select expensedb companies select expensedb select expensedb projects select select orgs select orgs org select primary paths expensedb 
similarly semi structured data models schema structure constraints represent semantic associations 
nesting structure schema represents semantic groupings elements 
structure may augmented nested referential constraints form simple pointers key xml schema provide richer semantics connecting related elements 
section consider compute sets semantically related atomic elements source schema target schema 
represent elements related schema structure constraints 
refer sets primary paths show computed 
example shows primary paths schemas represented queries return set semantically related atomic elements 
notation select shorthand atomic elements immediately reachable variable query excludes atomic elements contained nested set elements 
example select equivalent select city atomic elements underneath reachable nested set type orgs 
relational schema primary path individual relation 
nested schema primary paths obtained constructing tree node set type schema edge nodes node set type contains second 
primary path set elements path root intermediate node leaf tree 
nested schema example primary path denotes set records 
denotes records organizations organizations may may funds 
primary paths schema denote vertical data relationships exist instance conforming schema 
consider data relationships span horizontally relationships records nested need consider various ways primary paths associated 
consider associations faithful semantics conveyed nested referential integrity constraints schemas 
referential constraints assert equality element set elements primary paths 
combine primary paths larger sets logically related elements 
example schemas source foreign keys represented follows 
expensedb exists expensedb companies cid grantee expensedb exists expensedb projects project name proj constraint form bodies primary paths equality condition relating paths 
path primary path 
constraints write primary paths simplified form ignoring atomic elements return select clause 
target schema similar notation represent nested referential integrity constraints orgs org exists financial aid fund aid nested constraint example primary path second path relative variable example 
second path start root record path 
allows express fact fund organization refers aid financial tuple set record 
ability express nested dependencies central able generate nested logical relationships 
definition primary paths may specified relative variable equality condition relating paths nested referential integrity constraint nri expression form exists nested referential integrity constraints include large class referential constraints 
relational foreign keys fall class xml schema key constraints 
note solutions require declared constraints 
simply constraints advantage declared suggested tool 
constraints combine primary paths 
example constraint example represents horizontal relationship primary paths 
paths form logical relation 
note logical relation contains copy equated elements aid case 
intuitively represents fund information org city associated nesting structure financial data associated key aid 
logical relations consider generate maximal sets logically related elements 
chase classical relational method assemble logically connected elements 
intuitively chase works enumerating logical joins set dependencies relational schema 
extension relational chase enumerate logical 
definition logical relation result chasing primary path schema 
assume reader familiar basics chase 
illustrate example 
example result chasing source primary path constraint example represented query 
select expensedb expensedb companies cid grantee note equivalent returns larger set atomic elements 
projected elements equivalent 
applying chase obtain query 
select expensedb expensedb companies expensedb projects cid grantee proj project name chase steps applied expanded logical re lation 
chasing schema brings components schema containing tuples logically related tuples expensedb project tuples 
chase computes join conditions exist tuples 
primary path chased schema 
intuitively means tuples exist tuples logical relation 
lists logical relations schemas note 
nested target paths chased form logical relations respectively 
primary path chased produce logical relation 
mapping algorithm logical relations understand correspondences 
example existence logical source relation containing elements cname pi tells correspondences interpreted 
section formalize intuition give algorithm interpreting correspondences 
select cid cname city expensedb companies select cid cname city pi amount sponsor proj project year expensedb expensedb companies expensedb projects cid grantee project name proj select project name project year expensedb projects select city select city org cid org name orgs select city org cid org name fund pi fund aid financial amount financial proj financial year orgs org financial aid fund aid select city financial aid financial amount financial proj financial year logical relations expensedb 
example correspondences interpreted simple inter schema referential constraints 
expensedb companies exists orgs cname org name expensedb exists orgs org pi fund pi correspondence uses primary paths source target 
primary paths simply way unambiguously referring atomic elements nested schemas 
similarly uses 
interpretation ignores semantics source target schemas 
indicates created say nested org generated appropriate receiving 
create interpretation faithful semantics schemas logical relations primary paths state inter schema constraint 
source elements cname pi appear logical relation represents companies logically associated 
target elements name pi appear logical relation represents orgs logically associated 
combine logical relations interpretation 
expensedb expensedb companies expensedb projects cid grantee project name proj cname pi exists orgs org financial aid fund aid org name fund pi clause comes source logical relation 
indicates source data populate target 
added clause clear source data translated 
exists clause comes target relation indicates source data appear target 
clause includes target join condition conditions indicating placement source data 
far example ignored 
consider amount financial appears target logical relation 
replace meaningful covers 
interpretation similar binds variable clause equality target exists clause corresponding 
describe algorithm creating interpretations 
algorithm begins set correspondences expressed primary paths schema example 
correspondence simple case inter schema referential constraint specifies placement source values target 
definition primary path source target equality condition equating single atomic element single atomic element expression form exists determine sets correspondences interpreted find sets correspondences source elements logical relation target elements target logical relation 
seen previous section logical relations necessarily disjoint 
example include information includes project information 
correspondence relevant logical relations source target 
looking individual correspondence mapping algorithm algorithm looks pair source logical relation target logical relation 
pair computes interpretation correspondences expresses source logical relation mapped target logical relation 
correspondences interpretations modeled source target referential constraints dependencies 
primary paths interpretations logical relations 
constraint example example dependency 
computation dependency driven correspondences covered pair logical relations 
coverage correspondence logical relation slightly complicated suggested example 
check logical relation includes element name involved ambiguous general 
assume element names different schema 
element schema may included logical relation see example 
precisely identify element logical relation corresponds element involved correspondence need match path defining variables defining logical relation 
specifically find renaming function variables correspondence variables logical relation 
nested schemas additional problem matching paths flat element 
general may multiple ways cover correspondence respect pair source target logical relations 
algorithm takes account choices 
example assume source schema additional restriction sponsor 
means sponsor foreign key referencing 
describe nri expensedb exists expensedb companies cid sponsor logical relation result chasing primary path constraints 
additional constraint extend logical relation select cid cname city pi amount proj cid cname city project year expensedb expensedb companies expensedb companies expensedb projects cid grantee cid sponsor project name proj hard see covered covered multiple ways 
specifically possible renaming functions 
maps variable variable maps element cname renamed ways cname element source schema 
reflects fact companies joined ways grantee foreign key sponsor 
different renaming functions different interpretations correspondences 
generates query maps companies projects second maps companies funding companies 
interpretations meaningful 
definition coverage pair logical relations set correspondences renaming functions variables correspondences algorithm semantic translation input source schema target schema set correspondences 
phase 
compile schemas chase compute source logical relations 
chase compute target logical relations bm 
phase 
interpret correspondences pair ai bj coverage ai bj create dependency ai exists bj output set st generated dependencies coverage generate source target dependency form exists containing equality conditions correspondences variables renamed appropriately 
note logical relations may clause example example wrote inside clause result semantic translation algorithm algorithm systematic enumeration dependencies 
full gives details including component eliminates redundant dependencies drastically reducing number interpretations :10.1.1.19.6308
complexity completeness logical compilation generalize class relational inclusion dependencies 
special case embedded path conjunctive dependencies express constraints nested object oriented schemas 
chase compute logical relations special case chase 
special case chase may terminate 
possible solution problem restrict class legal constraints chase guaranteed terminate 
acyclic sets inclusion dependencies particularly useful class capture naturally integrity constraints relational schemas constraints met real world semi structured schemas 
acyclic sets fully defined compilation terminates polynomial time size schema :10.1.1.19.6308
furthermore complete mention 
procedural definition logical relations result chasing primary path schema 
chase clearly finds natural associations elements 
obvious natural associations discovered algorithm 
fact dust old relational theory find declarative definition set logical associations connections exist schema 
definition show algorithm complete finds connections connections 
theorem completeness schema acyclic set 
set atomic elements connection iff exists logical relation contains algorithm able away specific schema details normalization nesting 
theorem precise statement 
change logical design source target get logical mapping set correspondences long elements meaning 
cyclic schemas schemas cyclic sets constraints consider standard example employees managers employees recursively defined part machine composed parts 
mapping schemas may result infinitely possible translations 
clio permits users schemas restricted way gives completeness 
particular stops chase branch closes cycle 
result mapping employee name address clio associate employee name employee address manager address manager manager address interpretation correspondences interpret correspondences compute coverages set elements covered logical relation 
process similar determining view answer query 
important note correspondences represented simple paths 
process matching logical relations fast linear correspondence relation 
interpret correspondences source target dependencies 
important consequence mapping algorithm fact implementation generated dependencies automatically satisfies target constraints 
implementation means source instance find target instance dependencies satisfied 
implementations section gives canonical implementation dependencies queries 
state result implementation 
theorem st algorithm 
require acyclic set 
instances source respectively target schemas 
satisfies satisfy st result allows focus implementation dependencies worry satisfaction target constraints 
taken account producing target logical relations chase 
theorem hold algorithm extend class legal target constraints arbitrary nested dependencies join dependencies :10.1.1.19.6308
essential linear paths theorem hold 
useful fragment representing integrity constraints relational nested schemas include referential constraints expressible standards notably sql xml schema 
data translation source target dependencies generated algorithm inclusion dependencies relational sense source logical relations target logical relations 
example section inclusion dependency cname pi name pi meaning projection logical relation cname pi contained projection name pi 
take correspondence account replaced similar dependency cname pi amount name pi amount specifies atomic element target 
atomic elements target logical relation may specified dependency 
order materialize target fill values undetermined atomic elements 
null values may sufficient 
want materialize target logical relation nested schema logical relation flat view 
issues addressed second phase translation process data translation 
specifically main problems considered creation new values target values needed specified dependencies grouping nested elements aform data merging specified dependencies desirable 
illustrate issues simple examples highlight design principles 
design principles implemented component system compiles dependencies set lowlevel language independent rules 
turn compiled transformation language hand xslt xquery xml sql relational 
creation new values target 
consider simple mapping scenario 
source emps target emps sets employee emp elements 
element source atomic subelements emp element target extra atomic subelement purpose discussion chose names associate scenarios elements 
mapping source elements mapped emps set emp emps set emp emps set emp emps set emp spouses set spouse creation new values target 
target elements target left unmapped 
dependency emps exists emps emp emp emp emp specify value 
populate target need decide values elements 
frequent case practice unmapped element play crucial role integrity target 
example employee name salary address respectively date birth 
creating null value sufficient 
unmapped element optional target schema leave entirely 
example optional optional nullable translate dependency rule obvious semantics emps emp emp return emp null emps creation needed values key target relation 
intention mapping case copy employee data source assign new id employee target 
non null value needed integrity target 
target element needed part key foreign key nullable optional 
example create different unique value foreach combination source values technically speaking values created skolem function 
rule translates dependency case previous rule null similarly needed element target created different function 
function depend value source element source may exist tuples combination different values spouse employee listed spouses target tuple combination unknown spouse 
semantics target solely values source elements mapped 
course new correspondence change mapping employee spouses appear twice target 
similar mechanism creation new values target relation adopted semantics ilog 
generalize mechanism 
generalization multiple correlated sets elements target second frequent case requires creation non null values foreign key 
target element stored different location set spouses elements association values values meant preserved foreign key constraint plays role pointer case 
semantic translation recognizes situations computing logical relation joins emps spouses generating dependency emps abc abc 
give value needed element case single target set time logical relation assign function values generated rule emps emp emp emp return emp emps spouse spouses briefly meaning rule triple values source create element emp emps create element spouse spouses source values corresponding places invented value places element occurs 
duplicate triples occur source different values element generated emps respectively spouses 
eliminate duplicates target 
general level nesting flat case rule associate skolem functions needed elements follows fully nested case adjustment section 
skolemization atomic elements dependency needed element target computed different function depends mapped atomic elements target logical relation 
presence functional dependencies target schema may change functions value creation 
illustrate key spouses functional dependency holds rule replace 
grouping nested elements 
consider target schema nested levels elements top level bs element multiple subelements bs set type 
elements andc source emps mapped correspondences respective elements target emps 
mapping corresponding dependency requires values source emps set emp emps set emp bs set emps set emp emps set emp bs set spouses set spouse grouping elements target 
moved target 
addition intended semantics requires different values grouped fixed values illustration andc employee child spouse names respectively mapping requires grouping children set employee spouse 
behavior specified dependency stated level flat logical relations 
tasks data translation providing desired grouping target 
grouping performed nesting level dictated target schema 
property resulting target instance satisfy known partitioned normal form pnf 
pnf target nested relation exist distinct tuples coincide atomic elements source created 
achieve behavior skolemization 
target element set type identifier recall set identified data model set id created skolem function 
function depend atomic elements mapped respective set type schema hierarchy 
depends atomic elements level root schema 
skolem function set type target schema dependencies 
intuitively perform deep union data target independently source 
example create rule emps emp emp emp return emp bs bs emps bs meaning rule triple values source create sub element emp emps appropriate sub elements bs sub element value set id bs 
skolem function bs create set node 
create sub element value bs 
triple values different value retrieved source skip creation step required emp sub element exists 
second part return clause applies append anew sub element value previously constructed set node bs 
mechanism achieves desired grouping elements fixed values 
similar grouping mechanism expressed xml ql skolem functions :10.1.1.33.2943
implemented languages support skolem functions xquery xslt described :10.1.1.19.6308
value creation interacts grouping create nested target instance pnf need refine process creation new values described section subsection non nested case 
explain technique example 
consider elements stored separate target sets 
association employee name spouse name preserved foreign key spouse id 
needed element created 
case intuitive value depend value value 
combined pnf requirement means child values grouped employee spouse names 
achieve effect mapping achieves 
contrast created differently different values child singleton set 
implementation logical mapping choose alternative believe natural interpretation 
adjust skolemization scheme section follows 
function creation atomic element depend atomic elements occur lower level target schema 
emps emp emp emp return emp bs fbs fe fe emps fbs fe spouse fe spouses extreme instructive case suppose remove correspondences keep needed created skolem functions arguments 
saying assigned constant values 
consequently target sets emps spouses contain single element unknown employee unknown spouse respectively 
contrast nested set bs contain values children listed emps 
top level part schema plays structural role minimally created order satisfy schema requirements respective values irrelevant 
fine mapped 
correspondences may added children separated different sets depending mapped values 
skolemization algorithm sketched section polynomial time graph walking algorithm 
described full detail describes translation rules xquery xslt :10.1.1.19.6308
experience implemented solutions prototype system clio 
experience shown intended semantics correspondences captured system user effort creating debugging translation queries significantly approaches including manually writing query query building tools 
standard benchmark evaluation methodology subjective task integration attempt provide evidence performance effectiveness tool discussing usage clio schemas different sizes complexity 
test schemas listed table pairs source target schemas listed consecutively 
include xml schemas dblp bibliography obtained dblp web site relational tpc schema nested xml view benchmark relational schemas amalgam integration suite bibliographic data relational dtd version mondial database schemas representing variety gene expression microarray experimental results 
schemas available web page www cs toronto edu db clio contains links original sources 
included dblp schemas examples schemas constraints 
schemas differ semantically semantics encoded primarily different nesting structure schemas constraints 
amalgam relational schemas hand examples schemas nesting structure semantics captured rich set referential constraints 
included real xml schemas relatively constraints genex constraints mondial 
table shows characteristics schemas internal nested relational representation 
nesting depth indicates nesting repeated elements set types 
nesting record types affect efficiency algorithms 
load compile time indicate respectively time read schemas time compile schemas internal logical representation 
compile time includes time understand nested structure computing primary paths combine structures linked constraints chase compute logical relations 
load time expected closely reflects schema size including schema structure constraints compile time affected number 
schemas compile nest 
total leaf load compile schemas depth nodes nodes time time dblp xml dblp xml tpc rdb tpc xml genex rdb genex xml mondial rdb mondial xml amalgam rdb amalgam rdb table test schemas characteristics time sec schema subsumed dblp tpc genex mondial amalgam table source target dependencies generated schemas time negligible schemas large number take time compile 
compile time large seconds unoptimized prototype schemas constraints acceptable delay clio users 
recall compilation occurs schema loaded 
evaluate results semantic translation sought understand algorithms producing right results doing effective way 
table shows total number source target dependencies clio generates test schemas column labeled 
comparison included number dependencies produced ignored intra schema column labeled 
dependencies preserve semantics nesting ignore referential semantics embedded schema constraints 
schema constraints may increase number possible dependencies find practice number dependencies remains manageable users get overwhelmed choices 
furthermore column labeled subsumed shows dependencies generated subsumed better association preserving dependencies 
instance case expensedb mapping number dependencies created dependencies 
dependencies created appeared unchanged 
dependencies subsumed dependencies embraced available 
better quality mapping maintains implied relationships schemas 
schemas user able select subset generated dependencies form correct desired translation 
cases dblp amalgam expensedb intended transformation required created dependencies cases required strict subset 
clio proven effective helping users understand select desired dependencies 
discussion new algorithms schema mapping data translation nested schemas nested referential constraints 
solutions distinguished take advantage schema semantics generate consistent translations 
guarantee target instance produce satisfies target structure constraints instance contain data derived source 
logical mappings produce source target dependencies relating source query specifying source data may collected target query specifying data restructured target 
dependencies may data integration scenario target virtual queries target answered source instance 
may materialize target instance 
data translation algorithm gives implementation dependencies creates target instance pnf 
queries rich restructuring capabilities id invention translation languages precede 
differ automatically generate translation queries way respects semantics encoded schemas 
respect similar tran scm techniques schema information help automate data translation 
tran scm uses predefined matching rules describe commonly transformations derive translation 
technique flexible general 
relationship integration approaches logical data independence explored greater detail full version :10.1.1.19.6308
motivation provide tool quickly generates correct translations rich web data sources 
focused building robust tool captures semantics embedded nested structures 
currently extended algorithms consider additional types xml schema including union types planning include order framework 
support order need include list types enhance generated mappings ordering predicates 
peter buneman howard ho kolaitis felix naumann val tannen anonymous reviewers helpful suggestions 
abiteboul bidoit 
non normal form relations algebra allowing data restructuring 
jcss dec 
casanova fagin papadimitriou 
inclusion dependencies interaction functional dependencies 
jcss feb 
cosmadakis kanellakis 
functional inclusion dependencies graph theoretic approach 
advances computing research volume pages 
jai press 
davidson 
wol language database transformations constraints 
icde pages 
deutsch fernandez florescu levy suciu :10.1.1.33.2943
query language xml 
www pages 

rahm 
coma system flexible combination schema matching approaches 
vldb 
hull yoshikawa 
ilog declarative creation manipulation object identifiers 
vldb pages 
lenzerini 
data integration theoretical perspective 
pods pages 
levy mendelzon sagiv andd srivastava 
answering queries views 
pods pages 
maier mendelzon sagiv 
testing implications data dependencies 
acm tods 
maier ullman vardi 
foundations universal relation model 
acm tods june 
miller haas hern ndez 
schema mapping query discovery 
vldb pages 
milo zohar 
schema matching simplify heterogeneous data translation 
vldb pages 
naumann ho tian haas megiddo 
attribute classification feature analysis 
icde 
poster 
popa hern ndez miller naumann ho 
mapping xml relational schemas clio demo 

popa tannen 
equational chase path conjunctive queries constraints views 
icdt pages 
popa miller hern ndez fagin :10.1.1.19.6308
translating web data 
technical report csrg toronto dept cs feb 
rahm bernstein 
matching schemas automatically 
vldb journal dec 
yan miller haas fagin 
data driven understanding refinement schema mappings 
sigmod pages 
