lightweight implementation generics dynamics james cheney cornell university ithaca ny cs cornell edu years seen number proposals extending statically typed languages dynamics generics 
proposals require significant extensions underlying language 
show need case 
propose particularly lightweight extension supports dynamics generics 
furthermore features smoothly integrated dynamic values instance passed generic functions 
proposal standard hindley milner type system augmented existential types 
building ideas implemented small library readily usable hugs glasgow haskell compiler 
categories subject descriptors programming languages language constructs features general terms languages keywords generic programming dynamic typing type representations desirable feature programming languages safety 
broadly speaking safe programming languages prevent errors run time 
safety achieved static checking dynamic checking combination static dynamic checks 
approach pros cons 
supported part air force office scientific research number permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
haskell october pittsburgh pennsylvania usa 
copyright acm ralf hinze institut informatik iii universit bonn bonn germany ralf informatik uni bonn de dynamically typed languages scheme java preserve type information run time enabling concise definitions utility functions show compare dynamic casts generic functions multimethods 
type preservation introduces space run time overhead left compiler optimize away 
dynamic typing type errors caught compile time detected run time 
statically typed languages haskell ml extreme 
typechecking occurs compile time type information discarded compilation impossible write functions behaviour depends run time type information 
result utility communication functions defined 
programmers provide new versions new data type 
definitions essentially determined type structure written explicitly regular behaviour expressed hindley milner type system 
previous approaches supporting generic programming optimizations dynamic casts statically typed languages include explicit dynamic typing language augmented dynamic type typecase cast construct polytypic programming type dependent functions written language extension translated pure polymorphic functions ad hoc polymorphism haskell type classes types associated classes indicate presence overloaded functions intensional polymorphism type information preserved compilation run time type dispatch performed :10.1.1.39.8178:10.1.1.12.5664:10.1.1.30.20
techniques easy implement powerful support dynamics generics 
explicit dynamic typing nontrivial implement prove type safe especially presence polymorphism 
polytypic programming typically implemented source source translation address dynamic typing 
type classes long haskell limited expressiveness 
original type passing implementation intensional polymorphism changes language semantics violates parametricity theorem precluding simple type erasing language implementation complicating soundness proofs 
clear dynamic typing generic programming features safely combined date studied isolation 
addressed shortcomings leroy mauny abadi showed safely combine dynamics polymorphism :10.1.1.39.8178:10.1.1.12.5664
hinze peyton jones introduced derivable type classes permit polytypic definitions type classes :10.1.1.127.8206
crary weirich morrisett reconciled intensional polymorphism type erasure explicit type representations 
implementations dynamics derivable type classes type representations require substantial compiler modifications soundness proofs 
show need case 
encoding type representations haskell augmented existential types show type representations define simple polytypic functions type dynamic generic functions flavour definable derivable type classes 
provides simple safe implementation generics dynamics haskell additional compiler support proofs type soundness required 
sheds light relationship generics dynamics shows coexist interact 
rest structured follows 
sec 
explains define type representations haskell illustrates programming functions family types 
type representations heart dynamics sec 

sec 
shows achieve true genericity ability define functions types 
sec 
reviews related sec 
concludes 
complete implementation haskell library included app 
programming type representations start modest 
assume possibly infinite family types want define function say equality works types family call function polytypic 
concreteness consider family types grammar 
int assume unit type sum type pair type declarations haskell offers isomorphic types introduce new types reasons clear 
data unit data inl inr data haskell immediately fall back class system implement type indexed family functions 
equality function assigned type eq bool 
called class context eq explicit equality function types types instances type class eq 
purpose section show type classes 
basic idea pass additional argument represents type equality function called 
try assign type rep bool write universal quantifiers explicitly 
rep type type representations 
moment reflection reveals won 
parametricity theorem implies function type necessarily ignore second third argument 
trick parametric type type representations rep bool 
rep type representation 
dollar question course define type 
possibilities require extensions haskell data construct 
alternative polymorphic data signatures inhabit rep defining type constructor corresponding value constructor represents type 
family types introduce rint rep int rep rep rep rep rep rep rep 
instance type int int represented value rint rint type rep int int 
course declarations valid haskell data constructors introduced data declarations 
accept moment 
prerequisites easily define polytypic equality function works representable types 
simply pattern match type argument 
requal rep bool requal rint requal case unit unit true requal case inl inl requal inr inr requal false requal case requal requal note equation defines function type true instance declared type requal rint instance type int int bool 
polytypic function defined terms polytypic functions 
function instance implements polytypic list membership 
rep bool requal 
function hints essential difference haskell class system 
consider class variant elem eq bool class context records precisely overloaded function elem depends 
instance elem additionally called show type show added class context 
contrast signature type passing implementation change called type passing 
noted haskell data constructors introduced data declarations 
unfortunately define rep data declaration data constructors result type rep 
require slight extension allows instantiate declared type specific instance 
data rep rint int rep rep rep rep idea assign rint type rep additional constraint int recorded clause 
aside note universal quantifier front constructor name acts existential quantifier 
type rep types 
existential types supported hugs glasgow haskell compiler 

equational type constraints studied context module systems ml typed closure conversion presence intensional polymorphism 
contexts problem important relationships types hidden modular abstraction existential quantification solved translucent sum types singleton kinds restricted type equations order type sharing information evident module closure type 
unfortunately prior directly applicable addresses type sharing elements module existential package type equations depend data type cases 
example singleton kinds help case rep require different singleton kind 
addressed kind polymorphism complicates type system 
fortunately don wait extension haskell quite impressive type system clauses simulated haskell embedding projection pairs types 
alternative equivalence types type system corresponding consistent logical system motivated curry howard isomorphism think clauses propositions asserting equivalent sense 
notion equivalence range strict type equality logical equivalence equivalence type inhabitation 
propositional equivalence typically defined means 
recall conjunctions correspond product types implications function types 
define equivalence type corresponding proposition types equivalent 
function components thought casts back 
haskell declare data ep 
element ep type proof types equivalent 
haskell strongly normalizing correspond consistent logic appeal curry howard turning definition rep replace type constraint corresponding equivalence type data rep rint int rep rep rep rep additionally introduce called smart constructors corresponding constructors previous section incorporate reflexive equivalence value self proof equivalence 
self self ep id id rint rep int rint rint self rep self rep rep rep self rep rep rep self remains adapt polytypic equality function new definition rep changes straightforward analyze value type equivalent replace ep ep corresponding proof equivalence 
requal rep bool requal rint ep ep ep requal ep case ep ep unit unit true requal ep case ep ep inl inl requal inr inr requal false requal ep case ep ep requal requal important note requal polymorphically recursive recursive calls existentially quantified types 
means type signature mandatory code typecheck 
equality function takes values generic type apart 
construct value type wrap ep constructed value 
polytypic function constructs value type serves example 
rep rint ep ep ep ep unit ep ep inl ep ep terms proposition proof equivalence types values formally justified 
haskell equivalence pair guarantees cast vice versa nontermination possibility case 
turns purposes lets encode representations safely 
practice casts witnessing equivalences expected terminate usually identity 
polytypic function function intriguing example function analyzes synthesizes values generic type 
rep rint ep memoization ep case ep unit ep unit ep case ep inl inr ep inl ep inr ep case ep ep see works note helper definitions depend actual argument readily computed 
memoization relies critically fact computed demand 
guaranteed implementation fully lazy 
interested reader referred hinze background information 
new types far equivalence types consisted proofs type equality instantiated identity functions 
interpret element proof types isomorphic equal 
coincidentally haskell offers linguistic construct introducing new type isomorphic existing type 
consider example type triples 
newtype tri tri declaration defines tri isomorphic functions tri witnessing isomorphism 
tri isomorphic existing type represent follows 
rep rep rep rep tri ep tri pass triple polytypic function isomorphisms tri automatically called appropriate places 
furthermore tri implemented type right hand side casts amount identity function run time 
means new type implementation type treated alike may may want 
equivalence types need contain actual isomorphism pairs memoization defined composition function constructs memo table function queries table 
fuse functions eliminating memo data structure obtain function 
due koen claessen bringing attention 
despite appearance memo data structures vanish thin air 
built closures 
instance memo table disjoint union pair memo tables 
closure ep consequently contains pair memoized functions 
example assert equivalence int float 
ensuring equivalence cast pairs identity form isomorphism expressible haskell external proof obligations 
genuine type equality seen previous section equivalence type guarantee equal effect 
intriguing question devise equivalence type admits equal types 
surprisingly possible surprisingly underlying idea goes back leibniz see wadler related application leibniz idea 
leibniz terms equal may substituted 
adapting principle types define newtype ep 
note universally quantified type variable ranges type constructors kind 
element function converts element type element type constructor 
introduce constant self expressing reflexivity rule self self ep id strongly normalizing type system inhabitant identity equal type empty 
haskell additional inhabitants arising nontermination 
attempting elements cast result divergence 
provide functionality define functions proof type equality cast type 
function easy substitute identity type 
newtype id id ep ep id function subtle substitute type constructor 
gives function type apply identity function 
newtype inv ep ep inv id interestingly definitions precursors literature underly instance weirich implementation typesafe cast 
definition attractive stick variant rely broader interpretation type equivalence types isomorphic 
type class type representations call polytypic function supply type representation argument 
course working haskell class system purpose 
define type class representable follows class representable rep rep instance representable int rep rint instance representable rep instance representable representable representable rep rep rep instance representable representable representable rep rep rep building type class define variant polytypic equality automatically constructs type representation 
representable bool requal rep important note class system just convenience necessity programming representations 
dynamics type dynamic dynamic value pair consisting value representation type 
noted readily define dynamic type type representations rep data dynamic dyn rep dynamic representable dynamic dynamic dyn rep existential quantifier written universal quantifier effectively hides type dynamic value 
goes saying dynamic values defined class citizens instance construct list dynamic values 
dynamic int dynamic dynamic int dynamic value dyn type dynamic 
far 
polytypic function type rep appear call polytypic function analyzes type representation takes appropriate action existentially quantified type variable escape appear 
take equality dynamic values cast dynamic value static value type 
applications check type representations equality tackle 
function unify takes type representations possibly returns proof equivalence 
unify rep rep run time unification essentially combines proofs equivalence 
assume instance unify called rint ep rep rint ep rep 
proofs ep int ep int combined proof applying laws symmetry transitivity 
laws correspond functions inv respectively 
inv inv ep ep unification procedure slightly complicated parametric types 
assume instance unify passed representations ep rep ep rep 
arguments provide proofs ep ep 
recursive invocations unify possibly obtain proofs 
law congruence construct proof 
subproofs combined proof applying symmetry transitivity 
law congruence corresponds function defined 
inl inl inr inr ep function representing pair congruence law defined similarly 

aside theoretically minded reader types equivalence types form objects arrows category 
identity arrow self implements composition arrows 
furthermore sum type bifunctor category action arrows 
fact arrow ep inverse inv ep parametric data type including arrow type turned covariant functor 
prerequisites unify defined follows 
unify rep rep unify rint ep rint ep inv ep ep unify ep ep inv ep ep unify ep ep inv ep ep ep ep ep unify ep unify unify ep ep inv ep ep ep ep ep unify ep unify unify unify rep rep unify case unify just run time unification easily cast dynamic value static value representable type 
rep dynamic dyn case unify just ep ep error cast type mismatch cast representable dynamic cast rep useful function dynamic function application application dynamic function dynamic value 
introduce new case similar rep apply dynamic dynamic dynamic apply dyn ep dyn case unify just ep dyn ep ep error apply type mismatch apply error apply function example 
dynamic values instance implement heterogeneous symbol table finite map strings values type 
type table string dynamic rep string table fmap lookup alternative solutions reader referred weirich 
example 
dynamic values provide simple way implementing printf function type safe manner see :10.1.1.35.5277
printf function allows programmer show arbitrary number arguments different types 
number arguments types specified called format string passed argument printf format string may unknown compile time may read external source printf statically type checked 
printf string dynamic shows printf printf cs ds shows cast int printf cs ds printf cs ds cast string printf cs ds printf cs ds showchar printf cs ds printf cs error printf missing argument printf cs ds showchar printf cs ds note code assumes string type representable 
closing circle add dynamic family representable types pass dynamic value polytypic function data rep 
dynamic note rep dynamic defined mutual recursion 
course extend polytypic function definitions take new case account 
take equality dynamic values 
requal ep case ep ep dyn dyn case unify just ep requal ep false determine types dynamic values equal 
case requal called recursively check values equal 
generics generic representation types achieved far 
type representations program function works uniformly representable types 
ambitious 
aim broadening scope polytypic functions types including types programmer define 
won achieve goal full glory requires external tool support compiler get pretty close 
programmer bit extra newly introduced type 
principal idea type representable 
consider simple example data type booleans 
data bool false true type bool isomorphic sum type representable 
functions convert fro 
bool bool bool false inl unit bool true inr unit bool inl unit false inr unit true isomorphisms represent type bool follows 
rep bool ep bool type called generic representation type bool see :10.1.1.127.8206
haskell data construct introduces sum products sums products representable looks done 
quite data types may recursively defined may parametric possibly abstracting higher order kinded type constructors 
address point turn 
haskell list data type serves nice example data type recursive parametric 
data generic representation type isomorphisms inl unit inr inl unit inr 
representation suggests 
rep rep ep points worth noting 
type representation list type constructor function representation strictly speaking types bool isomorphic haskell contains additional bottom element 
simply ignore complication 
representation 
second representation infinite term type recursion mapped value recursion 
haskell lazy language problem far polytypic functions concerned call requal rint instance happily evaluates false 
presence infinite terms renders unification representations impossible quite call cast dynamic int int terminate 
solutions problem 
represent type recursion explicitly introducing fixed point operator approach taken polyp 
technically awkward completely general type recursion may span types mutual recursion may involve type constructors types called nested data types see 
need infinite family fixed point operators 
furthermore checking equality higher order kinded type constructors undecidable 
haskell avoids problem name equivalence structural equivalence motivates second solution 
continue represent recursive types infinite terms additionally label representation haskell name 
data type sufficient capturing closed haskell type terms including higher order kinded types 
data term app string term deriving eq instance int represented app app int 
augment rep additional constructor 
data rep rint int dynamic rep rep rep rep rtype term rep face types type representations rep captures structural information term captures naming information 
function term extracts information 
term rep term term rint ep app int term ep app dynamic term ep app term ep app term term term ep app term term term rtype ep change definition incorporate list type name 
rep rep rtype app term ep remains extend definition unify unify labelled representations rtype ep rtype ep simply test equality 
unify rtype ep rtype ep inv ep head unify ep equal know unifiable 
call head unify immediately returns proof 
note definition unify eager 
unify rtype ep rtype ep wrong inv ep ep ep ep unify turning treatment higher order kinded data types take look popular example 
definition introduces called generalized rose trees 
data tree node tree argument tree ranges type constructors kind tree kind 
seen type constructor kind represented function type rep rep 
tree abstracts type constructors kind type rtree rep rep rep rep tree 
note rtree possesses called rank type 
general type constructor kind represented element rep rep rep rep rep rep 
latest version glasgow haskell compiler ghc supports rank types fact represent types arbitrary kinds 
far 
small problem remains 
define representation tree construct type terms representations 
representation type rep function sounds hard nut crack 
fortunately haskell type language multi sorted term algebra haskell offer general type abstraction 
type term form app tn type application purely syntactic applying app tn yields app tn 
consequently result application reconstruct original function argument 
term rep rep term term case term app ts app init ts prerequisites define rtree rtype app tree term term rtree ep tree tree tree tree tree node ts ts tree tree ts node ts constructor names able write polytypic functions show read elements data type add constructor rep data type 
data rep 
string rep constructor intended record string representation data constructor 
course practice replace string elaborate data type contains information fixity see :10.1.1.127.8206
updated definition illustrates 
rep bool rtype app bool false true ep bool simplified version haskell show function converts element data type string representation 
understand definition keep mind sum type represent cases data declaration product type represent arguments single constructor 
unit type signals constructor arguments 
rshows rep shows rshows rint ep shows ep rshows ep case ep dyn showchar dynamic rshows showchar rshows ep rshows ep case ep inl rshows inr rshows rshows ep case ep rshows rshows rshows rtype ep rshows ep rshows ep nullary constructor rshows showchar showchar rshows showchar type representations ordinary values separate special cases simply pattern matching 
second equation rshows instance handles nullary constructors equation takes care remaining cases 
related polymorphic horn clause language hanus generalizes untyped horn clause resolution semantics prolog typed polymorphically typed terms 
initial definition rep section legal language appears strictly powerful haskell 
interestingly semantics requires presence types run time 
optimizations possible called type preserving functions type variables argument types occur result type note rep constructors type preserving 
jansson jeuring developed polyp variant haskell includes polytypic function construct permitting definitions primitive recursion structure regular data types support higher order kinded type arguments 
hinze proposed approach indexing values types types kinds 
possible write definitions functions map arbitrary polymorphic data structures 
approach implemented generic haskell successor polyp 
hinze peyton jones introduced derivable type classes define type indexed values classes limited kind :10.1.1.127.8206:10.1.1.127.8206
clean generics system generalizes derivable type classes allow generic type classes defined arbitrary kinds just 
abadi considered rigorously problem adding dynamic type type pattern matching typecase monomorphic ml language 
leroy mauny studied interaction dynamic implicit polymorphism implemented restricted form polymorphic type pattern matching quantifiers :10.1.1.12.5664
abadi considered dynamics explicit implicit polymorphism showed generalize typecase arbitrary polymorphic patterns :10.1.1.39.8178
believe dynamic support making values closed polymorphic types dynamic experiment unifying pattern matching polymorphic type representations 
ghc dynamic library contains dynamic types typeable class weaker untyped versions dynamic rep representable 
type representations impossible example unpack component product 
hand typed versions constitute safe implementation constructs 
clean includes support development richer type dynamic includes typecase pattern matching possibly polymorphic types style leroy mauny supports type dependent functions 
clean dynamics employ type class tc says possible dynamic earlier approaches values partially types containing free type variables cast dynamic long type variables class tc 
dynamic supports exactly behaviour clean tc analogous representable class 
shields sheard peyton jones alternative implementation dynamics staged type inference 
staged computation compilation parts program may delayed functions may specialized arguments available compile time 
staged type inference delays type inference type checking run time 
possible avoid difficulties explicit polymorphic type pattern matching encountered previous approaches unification occurs run time concrete type information available 
approach employs run time unification monomorphic types unify user level program code 
interesting see approach generalizes polymorphic 
staged computation may useful optimizing representation passing specializing generic functions particular representations 
experimented ghc rewrite rules automatically rewrite representation functions type information known compile time 
functions fully specialized non recursive types recursive types recursive types represented recursively defined representations 
result rewrite rules form limited optimizing representation programs 
weirich showed implement type safe cast form dynamic haskell type classes 
haskell implementations cast employ mutually recursive type classes implementation classes interprets cast coercion second interprets cast un restricted substitution 
interpretations cast correspond exactly interpretations type equivalence 
implicit compiler generated type information studied languages proposals implementing statically typed dynamics implementing intensional polymorphism 
explicit type representations new introduced crary weirich morrisett authors observed representations implement explicit dynamic type 
crary weirich weirich considered encodings type representations powerful type systems lx includes function sum product recursive kinds lu includes impredicative kind polymorphism 
swierstra independently discovered type representation encoding section 
starting representation passing generic functions attempting implement representations start dynamic types postulate type family contains information dynamic typechecking derive implementation 
swierstra address dynamic typing issues considered dynamic typing compilation expressions 
contrast considered generics dynamics interrelated 
shown represent general class types including polymorphic recursive types 
previous approaches implementing generic programming dynamic typing high level statically typed languages involved substantial language modifications substantial proofs type safety modified language 
dynamics generics studied separately leaving unresolved question dynamic values generic functions vice versa 
shown generic programming dynamic typing features derived simultaneously compatibly type representations 
type representations encoded haskell existentials equivalence types implemented semantics translation 
far know approach connection statically typed generics dynamics explicit 
prior approaches implementing type representations encode representations ordinary data types ordinary cases 
result existing pattern matching constructs optimizations carry representation patterns effort 
mutually recursive functions multiple type arguments pose problems 
representation passing functions compiled separately calling contexts contrast approaches statically typed generic programming compile generic function uses definitions separately 
dynamic types run time type checking defined terms representations type representations explicitly typed program data implementation dynamic flexible implementations type information compiler generated 
directions improving approach 
example possible override behaviour polytypic function specific instance changing definition rep 
contrast overriding easy type classes 
extensible data types alleviate problem 
encoding incurs unnecessary run time type dispatch overhead types available compile time 
furthermore encoding translates arbitrary tuples data types universal data type consisting binary products sums constructors may incur additional head 
drawbacks addressed specialization run time code generation deforestation optimizations 
encoding requires fair amount programmer effort plan address implementing extensions clauses haskell translation 
possible define polytypic functions map analyze type constructors kind different rep type constructing functions types kinds reach haskell type system 
important directions 
mart abadi luca cardelli benjamin pierce didier :10.1.1.39.8178
dynamic typing polymorphic languages 
journal functional programming january 
mart abadi luca cardelli benjamin pierce gordon plotkin 
dynamic typing statically typed language 
acm transactions programming languages systems april 
rinus plasmeijer 
generic programming extension clean 
th 
arts editors proceedings th international workshop implementation functional languages ifl pages sweden september 
arthur doaitse swierstra 
typing dynamic typing 
simon peyton jones editor proceedings international conference functional programming pittsburgh pa usa october 
acm press october 
appear 
roland backhouse patrik jansson johan jeuring lambert meertens 
generic programming 
doaitse swierstra pedro jose oliveira editors rd international summer school advanced functional programming braga portugal volume lecture notes computer science pages 
springer verlag berlin 
richard bird lambert meertens 
nested datatypes 
jeuring editor fourth international conference mathematics program construction mpc sweden volume lecture notes computer science pages 
springer verlag june 
clarke ralf hinze johan jeuring andres jan de wit 
generic haskell user guide 
technical report uu cs universiteit utrecht november 
karl crary stephanie weirich 
flexible type analysis 
proceedings acm sigplan international conference functional programming icfp paris france volume acm sigplan notices pages 
acm press september 
karl crary stephanie weirich greg morrisett 
intensional polymorphism type erasure semantics 
proceedings acm sigplan international conference functional programming icfp baltimore md volume acm sigplan notices pages 
acm press january 
rowan davies frank pfenning 
modal analysis staged computation 
journal acm may 
cordelia hall kevin hammond simon peyton jones philip wadler 
type classes haskell 
acm trans actions programming languages systems march 
michael hanus 
horn clause programs polymorphic types semantics resolution 
theoretical computer science october 
robert harper mark lillibridge 
type theoretic approach higher order modules sharing 
conference record st acm sigplan sigact symposium principles programming languages popl portland oregon pages new york ny january 
acm 
robert harper greg morrisett 
compiling polymorphism intensional type analysis 
conference record nd acm sigplan sigact symposium principles programming languages popl san francisco california pages 
acm press 
ralf hinze 
memo functions 
johan jeuring editor proceedings nd workshop generic programming ponte de lima portugal pages july 
proceedings appeared technical report universiteit utrecht uu cs 
ralf hinze 
new approach generic functional programming 
thomas reps editor proceedings th annual acm sigplan sigact symposium principles programming languages popl boston massachusetts january pages january 
ralf hinze 
polytypic values possess types 
science computer 
appear 
ralf hinze simon peyton jones :10.1.1.127.8206
derivable type classes 
graham hutton editor proceedings acm sig plan haskell workshop volume electronic notes theoretical computer science 
elsevier science august 
preliminary proceedings appeared university nottingham technical report 
patrik jansson johan jeuring 
polyp polytypic programming language extension 
conference record th acm sigplan sigact symposium principles programming languages popl paris france pages 
acm press january 
xavier leroy 
manifest types modules separate compilation 
conference record st acm sigplan sigact symposium principles programming languages popl portland oregon pages new york ny january 
acm 
xavier leroy michel mauny :10.1.1.12.5664
dynamics ml 
journal functional programming 
minamide greg morrisett robert harper 
typed closure conversion 
conference record rd acm sigplan sigact symposium principles programming languages popl pages st petersburg beach florida january 
simon peyton jones john hughes editors 
haskell non strict purely functional language february 
available fromhttp www haskell org definition 
simon peyton jones andrew tolmach tony hoare 
playing rules rewriting optimization technique ghc 
ralf hinze editor proceedings acm sigplan haskell workshop hw nd september firenze italy electronic notes theoretical computer science vol 
pages september 
preliminary proceedings appeared universiteit utrecht technical report uu cs 
benjamin pierce 
types programming languages 
mit press cambridge mass 
marco pil 
dynamic types type dependent functions 
kevin hammond antony davie chris clack editors implementation functional languages th international workshop ifl london uk september selected papers volume lecture notes computer science pages 
springer 
mark shields tim sheard simon peyton jones 
dynamic typing staged type inference 
th acm sigplan sigact symposium principles programming languages popl pages new york january 
acm 
walid taha tim sheard 
multi stage programming explicit annotations 
proceedings acm sigplan symposium partial evaluation semantics program manipulation pepm volume acm sig plan notices pages new york june 
acm press 
philip wadler 
theorems free 
fourth international conference functional programming languages computer architecture fpca london uk pages 
addison wesley publishing september 
philip wadler 
girard reynolds isomorphism 
kobayashi pierce editors proc 
th int 
symp 
theoretical aspects computer science tacs sendai japan oct volume lecture notes computer science pages 
springer verlag berlin 
philip wadler stephen blott 
ad hoc polymorphism ad hoc 
proceedings th annual acm sigplan sigact symposium principles programming languages popl pages austin tx usa january 
acm press 
stephanie weirich 
type safe cast functional pearl 
proceedings acm sigplan international conference functional programming icfp volume acm sigplan notices pages september 
acm press 
stephanie weirich 
encoding intensional type analysis 
david sands editor proceedings th european symposium programming esop volume lecture notes computer science pages 
listing generic representation types data unit data inl inr data standard mapping functions types function type 
type equivalence reflexivity symmetry transitivity 
inl inl inr inr data ep self self ep id id inv inv ep infixr ep mapping functions generic representation types function type implementing laws congruence 
type representations ep ep ep data rep rint int char dynamic rep rep rep rep rep rep rtype term rep string rep smart constructors 
class representable types 
dynamics run time unification types 
rint rep int rint rint self rep char self rep dynamic self rep rep rep self rep self rep rep rep self rep rep rep self class representable rep rep instance representable int rep rint instance representable char rep instance representable dynamic rep instance representable representable representable rep rep rep instance representable representable representable rep rep rep instance representable representable representable rep rep rep data dynamic dyn rep dynamic representable dynamic dynamic dyn rep unify rep rep unify rint ep rint ep inv ep ep unify ep ep inv ep ep unify ep ep inv ep ep unify ep ep inv ep ep ep ep ep unify ep unify unify ep ep inv ep ep unify ep ep inv ep ep ep ep ep unify ep unify unify ep ep inv ep ep ep ep ep unify ep unify unify unify unify rtype ep rtype ep inv ep head unify ep unify type safe cast dynamic function application 
type terms generics examples type representations 
unify rep rep unify case unify just rep dynamic dyn case unify just ep ep error cast type mismatch cast representable dynamic cast rep apply dynamic dynamic dynamic apply dyn ep dyn case unify just ep dyn ep ep error apply type mismatch apply error apply function data term app string term deriving show eq term rep term term rint ep app int term ep app char term ep app dynamic term ep app term term term ep app term ep app term term term ep app term term term rtype ep term rep rep term term case term app ts app init ts rep bool rtype app bool false true ep bool bool bool bool false inl unit bool true inr unit bool inl unit false inr unit true rep rep rtype app term ep inl unit inr inl unit inr generic functions generic equality 
generic minimum 
generic unparsing 
instance representable bool rep instance representable representable rep rep requal rep bool requal rint ep requal ep requal ep ep ep ep ep case ep ep dyn dyn case unify just ep requal ep false requal ep error requal equality functions requal ep case ep ep unit unit true requal ep case ep ep inl inl requal inr inr requal false requal ep case ep ep requal requal requal rtype ep requal requal ep ep requal rep rint ep ep ep ep ep error dynamic ep ep ep ep unit ep ep inl ep ep rtype ep ep rshows rep shows rshows rint ep shows ep rshows ep shows ep rshows ep case ep dyn showchar dynamic rshows showchar rshows ep function rshows ep rshows ep case ep inl rshows inr rshows rshows ep case ep rshows rshows rshows rtype ep rshows ep rshows ep rshows showchar showchar rshows showchar generic memoization 
rep rint ep memoization ep memoization ep memoization ep memoization ep case ep unit ep unit ep case ep inl inr ep inl ep inr ep case ep ep rtype ep ep ep note primitive types ints chars require building look table 

