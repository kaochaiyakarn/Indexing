finite model theory descriptive complexity erich september survey relationship logical definability computational complexity finite structures 
particular emphasis game evaluation algorithms various logical formalisms logics capturing complexity classes 
addition common logical systems order second order logic fragments survey focusses algorithmic questions complexity results related fixed point logics including fixed point extensions order logic modal calculus database query language datalog fixed point logic counting 
discussed general approach methodology finite model theory extended suitable domains infinite structures 
example results relating metafinite model theory complexity theory 
author address erich gr mathematical foundations computer science aachen university aachen informatik rwth aachen de www mgi informatik rwth aachen de revised version text appear chapter book finite model theory applications 
contents definability complexity complexity issues logic 
model checking order logic 
strategy problem finite games 
complexity order model checking 
encoding finite structures words 
capturing complexity classes capturing np theorem 
logics capture complexity classes 
capturing polynomial time ordered structures 
capturing logarithmic space complexity 
transitive closure logics 
fixed point logics fixed point theory 
fixed point logic 
modal calculus 
parity games 
model checking games fixed point logic 
simultaneous fixed point inductions 
inflationary fixed point logic 
partial fixed point logic 
datalog stratified datalog 
logics counting fixed point logic counting 
datalog counting 
capturing ptime canonization definable linear orders 
interpretations 
capturing ptime bisimulation 
logic ptime 
computational model theory finite structures 
finitely presentable structures 
metafinite structures 
metafinite spectra 
descriptive complexity real numbers 
alternating complexity classes definability complexity central issues finite model theory relationship logical definability computational complexity 
want understand expressive power logical system order second order logic fixed point logic logic database query language datalog related algorithmic properties 
conversely want relate natural levels computational complexity defining power logical languages want logics capture complexity classes 
aspects finite model theory related computational complexity referred descriptive complexity theory 
computational complexity theory concerned computational time space amount hardware necessary decide property descriptive complexity theory asks logical necessary define 
chapter give survey descriptive complexity theory 
assume reader familiar fundamental notions logic complexity theory 
specifically assume familiarity order logic deterministic nondeterministic complexity classes 
see appendix brief survey alternating complexity classes 
section discuss basic issues concerning relationship logic complexity introduce model checking games determine detailed way complexity order model checking 
section precise notion logic capturing complexity class 
capturing result prove theorem saying existential second order logic captures np 
limited scenario domain ordered structures derive capturing results number complexity classes including ptime logs ace fragments second order logic second order horn logic extensions order logic transitive closure logics 
section devoted fixed points logics 
probably important logics finite model theory play important role fields logic computer science 
discuss variants fixed point logics including inflationary partial fixed point logic modal calculus database query language datalog 
explain model checking issues capturing results ptime pspace discuss structural issues logics 
section introduce logics counting 
limitations common logics finite structures inability count 
adding order logic particular fixed point logic explicit counting mechanism obtains powerful logics come quite close capturing ptime 
section devoted capturing results certain specific domains unordered structures technique called canonization 
general problem exists logic capturing ptime finite structures open widely conjectured logic exists canonization permits find interesting domains structures fixed point logic fixed point logic counting express ptime 
section discuss extension general approach methods finite model theory suitable domains infinite structures generalization finite model theory computational model theory 
discuss domains potential application results see exercise infinite structures approach sense treat example domain metafinite structures capturing results studied detail 
complexity issues logic central issues relationship complexity theory logic algorithmic complexity common reasoning tasks logic 
numerous tasks easily reduced logics reasonable closure properties testing model checking 
satisfiability problem logic domain structures takes formulae inputs question answered exists model satisfiability problems fundamental importance areas logic applications really play crucial role finite model theory 
considered occasionally central results finite model theory interesting connections satisfiability problems 
point relations 
hand model checking problems occupy central place finite model theory 
logic domain finite structures model checking problem asks structure formula case closely related problem formula evaluation query evaluation structure formula free variables compute relation defined set 
obviously evaluation problem formula free variables structure elements reduces model checking problems 
note model checking problem inputs structure formula 
measure complexity terms inputs commonly refered combined complexity model checking problem 
cases inputs fixed measure complexity terms 
fix structure model checking problem structure amounts deciding theory complexity problem called expression complexity model checking problem 
particular order logic fo monadic second order logic mso problems long tradition logic numerous applications fields 
greater importance finite model theory model checking problems fixed formula amounts deciding model class inside tp 
due relevance databases complexity problem called data complexity model checking problem 
algorithmic analysis logic problems aspect logic complexity important finite model theory really central programme descriptive complexity theory 
goal characterize complexity point view logic precisely model theory providing important complexity level logical systems expressive power finite structures particular domain finite structures coincides precisely complexity level 
detailed definition see sect 

see important exist logical approaches complexity instance proof theory 
connections finite model theory approach exist flavour quite different 
successes programme remain difficult problems open 
model checking order logic discuss problem evaluating order formulae finite structures game approach 
model checking problems logic cast strategy problems appropriate model checking games called hintikka games formula structure vocabulary tuple elements associate hintikka game 
played players verifier 
verifier called player tries prove called player tries establish formula false 
order logic evaluation games simple sense winning conditions positional games founded possible plays finite regardless input structure finite infinite 
powerful logics notably fixed point logics model checking games may infinite plays complicated winning conditions see section 
game 
finite structure relational order formula assume negation normal form built atoms negated atoms means propositional connectives quantifiers obviously order formula converted linear time equivalent negation normal form 
model checking game positions subformula free assignment free variables elements simplify notation usually write position assigns tuple free variables initial position game formula 
verifier player moves positions associated disjunctions formulae start ing existential quantifier 
position moves position yt verifier move position dually player corresponding moves conjunctions universal quantifications 
atoms negated atoms positions form game 
verifier won play won 
model checking games way defining semantics logic 
equivalence standard definition proved simple induction 
proposition 
verifier winning strategy game suggests game approach model checking construct game decide verifier winning strategy initial position 
look bit closer strategy problems games 
games confounded games model comparison ehrenfeucht fra ss games describe power logic distinguishing structures 
strategy problem finite games abstractly describe player game positional winning conditions directed graph universe set positions set positions player moves set moves 
denote set positions player moves 
winning conditions adopt convention player loses positions moves possible 
alternatively explicitly include game description sets 
winning terminal positions player 
play path formed players starting position 
positions vn player chooses move vn vn player chooses move 
moves available current position player choose loses 
case occurs play goes infinitely winner established winning condition infinite plays 
moment say infinite plays won players 
strategy player function defining move situation play move 
particular interest positional strategies depend history play current position 
positional strategy player partial function indicates choice positions play consistent positional strategy player vn vn vn strategy player winning position wins play starting consistent strategy 
say strategy winning set winning position game denote sets positions player winning strategy 
game called founded plays finite 
note game graph model checking game order formula finite finite founded case 
general games finite game graphs need founded 
game called determined position players winning strategy founded games determined large classes general games games borel hierarchy see 
denote game strategy problem games finite game graphs positional winning conditions game player winning strategy position 
obvious game problem solved polynomial time denote set positions player rr strategy win game moves 
iv vi set winning terminal positions player rr compute sets inductively wo re wo re wo introduce model checking games powerful logics complicated winning conditions infinite plays 
see game solved linear time little necessary 
algorithm variant depth search computes entire winning sets players time iv iei theorem 
winning sets finite games computed linear time 
proof 
algorithm computes position player winning strategy game starting position 
computation arrays win contains indicating player wins know players winning strategy ply contains predecessors number successors win 
linear time algorithm game problem input game forall win jpm enddo 
initialisation forall enddo calculate forall 
calculate win propagate forall propagate return win procedure propagate win return win forall enddo 
mark winning player 
propagate change predecessors propagate heart algorithm procedure propagate called time player winning strategy position propagate records fact investigates able determine winning player predecessors done applying rules predecessor belongs player player winning strategy moving position predecessor belongs opponent win undefined winning player determined successors win successors player wins regardless choice opponent 
parts reached position inner part loop executed ip iei times 
running time algorithm correctness value assigned win proved straightforward induction number moves corresponding player ensure wins 
note positions satisfying part exactly outgoing edges modified propagate 
game known ptime complete problem see :10.1.1.21.9642
remains case strictly alternating games 
game transformed equivalent strictly alternating introducing move new node vi replacing move moves 
game problem called alternating reachability general com problem reappears different guises areas 
illustrate example show satisfiability problem propositional horn formula essentially problem game 
satisfiability horn formulae 
known sat horn satisfiability problem propositional horn formulae ptime complete solvable linear time :10.1.1.21.9642
game problem obtain simple proofs results 
game sat horn equivalent log lin reductions reductions computable linear time logarithmic space 
reductions simple say game sat horn really problem 
theorem 
sat horn log lin equivalent game 
proof 
game con struct time ivi iei propositional horn formula consisting clauses edges clauses vl vm nodes ue vl vm 
minimal model precisely winning set player 
horn formula unsatisfiable 
sat horn xl xn aic ci propositional variables xn horn clauses ci form hi head clause hi propositional variable constant define game follows 
positions player initial position variables xn positions player clauses player move position clause ci head player move clause ci variable occurring body ci 
formally xl 
xn ci vi head body 
player winning strategy position particular unsatisfiable player wins position 
complexity order model checking roughly size model checking game number different subformulae elements 
cases efficient construct full model checking game explicitly solve strategy problem positions game really needed 
measure size games resulting time space bounds model check ing complexity precisely possible formula length ipl parameters 
closure cl set subformulae obviously icl cases icl smaller rank qr maximal nesting depth quantifiers width maximal number free variables subformulae width max cl 
considering width rewrite formulae variables possible 
lemma 
order formula width equivalent renaming bound variables order formula distinct variable symbols 
bounded variable fragments logics received lot attention finite model theory 
state results terms formula width number variables avoid necessity number variables 
cases best method construct full model checking game explicitly solve strategy problem positions game really needed 
alternating algorithms really games surprising best estimates complexity model checking games terms alternating complexity classes 
alternating model checking algorithm order logic viewed fly construction model checking game playing 
theorem 
alternating model checking algorithm finite struc ture order sentence decides time qr log iai space log ipl width log iai atomic statements evaluated constant time 
proof 
recursive alternating procedure pa finite structure order formula may contain free variables assign ment free decides 
procedure viewed fly construction game playing 
pa input order formula negation normal form finite structure universe assignment free atom negated atom pa accept reject guess pa ifp universally choose free xt guess element universally choose element straightforward induction shows procedure correct 
time needed procedure depth syntax tree plus time needed produce variable assignments 
computation path qr elements chosen element needs log bits 
time complexity qr log 
evaluation algorithm needs maintain pointer current position store current assignment needs free log iai bits current subformula space needed algorithm log ipl width log 
theorem 
model checking problem order logic ps ace complete 
fixed model checking problem order formulae width time complete 
proof 
membership complexity classes follows immediately theorem facts alternating polynomial time coincides polynomial space alternating logarithmic space coincides polynomial time 
completeness follows straightforward reductions known complete problems 
qbf evaluation problem quantified boolean formulae pspace complete 
reduces order model checking fixed structure 
quantified boolean formula free propositional variables translate order sentence follows replace quantification xi propositional variable xi corresponding order quantification xi replace atomic propositions xi atoms 
obviously evaluates true proves expression complexity combined complexity order model checking pspace complete 
see model checking problem order formula width reduce game problem strictly alternating games player moving 
strictly alternating game graph construct formulae bi width expressing player winning strategy moves 
exy exy vz bi 
obviously bn width bn player win position moves 
player winning strategy winning moves ivi game caught loop 
instance game problem strictly alternating games reduced instance bn model checking problem order formulae width 

argument ptime completeness applies fact propositional modal logic ml 
formulae bn constructed take modal formulae ill false corollary 
model checking problem ml ptime complete 
consider fixed formula theorem tells data complexity order logic lower expression combined complexity 
corollary 
order sentence 
finite 
particular evaluation problem fixed order sentence computed deterministically logarithmic space 
encoding finite structures words complexity theory current form classical computational models notably turing machines take inputs words fixed finite alphabet 
want measure complexity problems finite structures terms notions represent structures words inputs say turing machines 
may trivial issue purely algorithmic questions say determining cost model checking algorithm programme finite model theory link complexity logical definability deeper way purpose structures words needs careful consideration 
source major unresolved problems discuss 
going describe structures encoded strings 
implicitly encoding requires select ordered representation structure 
see consider common encoding graph adjacency matrix 
fixed enumeration say iv vn represent graph word wo wn win vi vj win row row matrix 
encoding canonic 

possibilities enumerating may 
different encodings graph binary strings 
graphs come linear order canonic way enumeration elements canonic encoding 
definition 
vocabulary write fin class finite structures ord class structures fin linear order universe ordered structure cardinality identify set associating tuple rank lexicographical ordering induced ordered structures encoded binary strings natural ways 
particular choice encoding important 
need conditions satisfied 
definition 
encoding code ord finite alphabet identifies isomorphic structures values polynomially bounded order definable allows compute values atomic statements 
formally means conditions satisfied code code 
ii code polynomial 
iii symbols exists order formula fi xl vocabulary equivalence holds fi iff th symbol code 
iv code relation symbol representation tuple decide precise meaning clause iv depends context problem studied machine model considered level abstraction studies problem 
analysis algorithms assumes atomic statements evaluated constant unit time ram 
minimal requirement atoms evaluated linear time logarithmic space 
convenient encoding follows 
linear order rt structure cardinality maximal arity rt tin relation arity associate string wo vn wi th tuple aj belongs wi 
set code nx exercise 
prove encoding 
fact encoding lends simple logical description sense linear ordering corresponding successor relation constants element respect available encoding definable quantifier free formulae 
fix encoding function understand ordered structures represented encodings 
unordered structure associate set encodings code linear order say algorithm decides class structures mean decides set encodings structures language code code sense ask belongs complexity class np 
particular ask complicated decide class models logical sentence 
word structures 
seen classes structures encoded languages 
side language considered class structures vocabulary 
word wo 
wm described structure universe usual interpretation pa wi 
isomorphism invariance 
seen encoding unordered structure involves selecting ordering universe 
general different orderings produce different encodings 
want consider properties structures encodings algorithm decides structure certain property gets encodings code structure 
outcome algorithm depend particular ordered representation structure isomorphism type 
words algorithm isomorphism invariant 
algorithms considered isomorphism invariance obvious general undecidable property 
exercise 
order sentence vocabulary structures truth structure depend choice linear ordering pair linear orderings prove undecidable order formula order invariant finite structures 
hint trakhtenbrot theorem 
order sentence containing finite model elements order invariant 
capturing complexity classes mentioned research programme descriptive complexity theory links complexity logic deeper way complexity analysis model checking algorithms 
look results saying certain domain structures logic order logic fixed point logic fragment second order logic captures complexity class comp 
means fixed sentence data complexity evaluating structures problem complexity class camp property structures decided complexity camp definable logic important examples results theorem saying existential second order logic captures np class finite structures theorem saying fixed point logic captures ptime class ordered finite structures 
ordered finite structures logical characterizations kind known major complexity classes 
hand known major open problems area ptime captured logic ordering 
section prove theorem relate spectrum problem classical problem mathematical logic 
section precise notion logic capturing complexity class domain finite structures 
show section ordered structures second order horn logic captures polynomial time 
section section discuss logics capture logarithmic space complexity classes 
capturing np fagin theorem spectrum order sentence set finite models spectrum model elements 
scholz posed problem characterize class spectra subsets exists order sentence spectrum specific problem complementation problem spectra posed asked complement spectrum spectrum 
note spectrum order sentence relational vocabulary 
rm viewed set finite models existential second order sentence mp relation symbols quantified sentence empty vocabulary models just sets 
correspondence spectra order sentences classes finite models existential second order sentences empty vocabulary 
allowing different vocabularies existential second order sentences naturally leads notion generalized spectrum 
definition 
existential second order logic denoted set form rm fi rm relation symbols finite arity order formula 
generalized spectrum class finite models sentence existential second order logic 
example 
class bipartite graphs generalized spectrum 
defined sentence exy rx ry 
exercise 
prove class hamiltonian graphs class graphs fixed class graphs admit perfect matching generalized spectra 
perfect matching graph set edges node belongs precisely edge 
theorem fagin 
isomorphism closed class finite structures fixed non empty finite vocabulary 
np definable existential second order sentence generalized spectrum 
proof 
show decide generalized spectrum 
existential second order sentence 
describe non deterministic polynomial time algorithm encoding code structure decides nondeterministically guesses relations relation ri determined binary string length ri ri arity ri decides 
order done logarithmic space polynomial time 
computation consists guessing polynomial number bits followed deterministic polynomial time computation 
obviously decides class finite models conversely isomorphism closed class structures non deterministic tape turing machine input code decides polynomial time belongs construct existential second order sentence finite models precisely structures construction quite standard 
optimised easily adapted situations particular giving capturing result ptime see section 
qo set states alphabet initial state set accepting rejecting states transition function 
loss generality assume computations input code reach accepting rejecting state steps cardinality represent computation input code tuple relations construct order sentence bm vocabulary bm relations represent accepting computation code 
represent time space parameters computation identify numbers tuples linear order associated successor relation greatest element course definable 
note successor relation constants elements available induced successor relation tuples definable quantifier free formula ii fixed integer relation expressible 
description computation code consists relations 
state predicate xq time state 
symbol cr predicate time cell contains symbol 
head predicate time head position sentence bm universal closure conjunction start compute subformula start enforces configuration time input configuration code order formulae condition iii definition encodings 
set start ya 
subformula compute describes transitions configuration 
conjunction formulae change pre rr qt es post rr pre rr xq yo post rr xq fat re 
expresses contents currently scanned tape cells change configuration change enforces changes relations xq ye imposed transition function 
formula xq enforces acceptance forbidding rejection 
claim accepts code pm 
follows immediately construction pm accepting com putation code pm claim pm accepts code suppose pm configuration state head position tape content wo time conjunction atomic statements hold time nk conf xq tuples representing numbers 
input configuration code start follows due subformula compute pm non final configurations conf conf set successor configurations follows exists computation code configuration cen rejecting 
accepts code proves claim 
clearly axiomatize linear orders order logic 
iff pm proves generalized spectrum 
exercise 
prove set np defined sentence order part prefix 
furthermore prove reduced 
prove reduced existential second order quantification function symbols allowed consider ordered structures explicitly successor relation con element 
interesting consequences fagin theorem 
np completeness sat satisfiability problem propositional logic easy corollary fagin theorem 
theorem cook levin 
sat np complete 
proof 
obvious sat np problem 
remains show problem np reduced sat 
explained words viewed special kinds finite structures assume fin finite vocabulary 
theorem exists order sentence pa fin 
logspace reduction associates input structure pa fin propositional formula pa replace subformulae xi xi ai subformulae xi ai atoms truth values pa atoms efficiently evaluated translation efficiently computable 
viewing atoms ri propositional variables obtained propositional formula pa pa rmb sat 
theorem readily extends higher levels polynomial time hierarchy correspondance second order logic polynomial time hierarchy 
corollary 
isomorphism closed class finite structures fixed non empty vocabulary 
code lg polynomial time hierarchy ph exists second order sentence class finite models statement fagin theorem required vocabulary non empty 
case empty vocabulary spectra different natural way specifying finite set write size binary length encoding logarithmic encodings structures non empty vocabulary polynomial length 
formula constructed proof theorem talks computations polynomial case spectra exponential length input 
consequence fagin characterization generalized spectra terms np implies characterization spectra terms nexptime 
established different way 
corollary jones selman 
set spectrum complementation problem spectra really complexity theoretic problem spectra closed complementation nexptime nexptime 
exercise 
prove set categorical spectrum spectrum order sentence isomorphism model finite cardinality 
logics capture complexity classes theorem gives precise correspondence logic complexity class property finite structures decidable nondeterministic polynomial time exactly definable existential second order logic 
true correspondence polynomial time hierarchy corollary 
note results model checking complexity order logic give precise correspondences 
know theorem corollary property finite structures order definable decidable logspace fact 
result giving converse fact converse false 
computationally simple properties finite structures order definable 
property having number elements 
natural question arises complexity classes np polynomial time hierarchy precisely captured logics 
popular complexity classes notably ptime know possible domain finite structures 
lot interesting capturing results consider arbitrary finite structures certain specific domains 
particular close correspondences logic complexity domain ordered finite structures 
model class mean class structures fixed vocabulary closed isomorphism 
speak domain structures vocabulary fixed 
domain vocabulary write class structures 
intuitively logic captures complexity class camp definable properties structures precisely decidable comp 
detailed definition 
definition 
logic comp complexity class domain finite structures 
say captures camp vocabulary sentence model checking problem complexity class comp 
model class membership problem comp exists sentence fagin theorem logic captures np domain finite structures corollary second order logic captures polynomial time hierarchy 
simply write comp say condition definition satisfied comp domain finite structures 
classical result pre history finite model theory says language regular recognizable finite automaton definable monadic second order logic 
words viewed special domain structures capturing result sense definition 
theorem elgot trakhtenbrot 
domain word structures monadic second order logic mso captures regular languages 
numerous extensions ramifications theorem es context automata theory 
refer proof results 
emphasis finite model theory complicated structures words concerns higher complexity levels regular languages 
capturing polynomial time ordered structures section logical characterization polynomial time ordered structures terms second order horn logic 
characterizations follow subsequent sections 
definition 
second order horn logic denoted horn set second order sentences form 
ci qi ri relation symbols ci horn clauses respect precisely ci implication form ia positive atom rk order formula contain conjunction called body clause 
head clause atom rj boolean constant false 
order part sentences horn universal horn sentences respect quantified predicates rm may arbitrary order information input predicates underlying vocabulary 
horn denotes existential fragment horn set horn sentence second order quantifiers existential 
example 
problem gen known complete problem 
may set structures vocabulary unary predicate binary function constant contained closure clearly complement gen complete 
defined sentence horn ry sy ry rz ra 
example 
circuit value problem cvp complete restricted circuits fan nand gates :10.1.1.21.9642
circuit considered structure directed acyclic graph monadic constant exy means node input nodes contain inputs node value respectively stands output node 
take granted connected acyclic graph fan sources sink 
formula conjunction clauses tx fx ty fx exy fz tx exz ty tx fx tx states circuit evaluates 
exercise 
justify definition horn show admission quantifiers functions order prefixes general form restriction horn clauses pointless 
extension horn full power second order logic 
theorem 
sentence horn equivalent sentence horn 
proof 
suffices prove theorem formulae form vp conjunction horn clauses 
arbitrary formula horn may brought existential form successively removing innermost universal second order quantifier 
prove claim 
formula horn true predicates structure holds predicates false point 
arity tuple pe predicate false true points 
assumption exist predicates take predicate np claim suppose false exists relation clause assignment zl zs 
show exists tuple pe 
head take head choose exist ri 
head take arbitrary head clearly false pe 
atom occur body atoms body true atoms form occur body clause remain true pg 
atom ri body remains true ri replaced ri 
implies clause contradicts assumption 
claim established 
implies original formula equivalent conjunction resp 
obtained replacing atom pt true iff pg resp 
true 
easy transform conjunction equivalent formula horn 
theorem 
fi horn 
set finite models fi ptime 
proof 
restrict attention sentences fi sr ci horn 
finite structure appropriate vocabulary reduce problem fi satisfiability problem propositional horn formula technique proof theorem 
replace universal quantifiers conjunctions elements ai omit quantifier prefix 
substitute body clause order formulae involve rm truth values 
clause false partial interpretation head false atoms body true reject fi 
omit clauses true head true conjunct body false delete interpreted conjuncts remaining clauses 
consider atoms ri propositional variables 
resulting formula propositional horn formula length polynomially bounded cardinality satisfiable fi 
satisfiability problem propositional horn formulae solved linear time 
theorem 
ordered structures horn horn capture ptime 
proof 
follows analysis proof fagin theorem 
turing machine happens deterministic sentence constructed proof easily transformed equivalent sentence horn 
see recall fix universal closure start change 
formulae start horn form 
formula change form pre qt rt pre xq ya post xq ya 
deterministic pair unique value qt rt 
case implication pre post replaced conjunction horn clauses pre xq pre ya pre 
exercise 
prove contrary case fagin theorem assumption linear order explicitly available eliminated linear orderings axiomatizable horn formulae 
exercise 
results section proved weaker variant horn body may contain arbitrary order formulae input vocabulary atoms negated input atoms 
prove variants horn equivalent ordered structures successor relation constants element ordered structures successor relation 
hint sentences weak variant horn preserved substructures capturing logarithmic space complexity section describe approaches define logics capture logarithmic space classes ordered structures 
approach restrictions second order logic similar definition horn second technique adds transitive closures operators order logic 
definition 
second order krom logic denoted krom set second order formulae ci clause ci disjunction literals form ri order formula contain formulae krom cnf respect quantified predicates 
krom existential fragment krom 
intersection horn krom denoted krom horn 
example 
reachability problem path graph complete nlogspace order translations 
complement expressible formula krom horn tab 
case horn known sentence krom equivalent sentence krom see 
proposition 
sentence krom set finite models nlogspace 
proof analogous proof theorem 
uses fact sat satisfiability problem propositional krom formulae nlogspace 
ordered structures krom captures nlogspace 
indicate general idea proof 
suppose logn space bounded nondeterministic turing machine input tape carrying representation code separate tapes 
reduced configuration reflects control state content tapes positions heads input tape tapes 
configuration specified reduced configuration input 
reduced configurations input code length respect represent tuples cl cr fixed initial reduced configuration input code assume single accepting state say state component reduced configuration describe state condition represents accepting configuration expressed accept yl 
bit lengthy write quantifier free formula successor structure tuple representing reduced configuration represents reduced successor configuration input 
disjunctive normal form express accept input code sentence accept 
proves ordered structures complement problem nlogspace definable krom 
nlogspace closed complement formula fact krom horn proved result 
theorem 
ordered structures logics krom krom krom horn capture nlogspace 

characterizations nlogspace second order horn krom logics reformulated terms generalized spectra 
notion generalized spectrum appropriately modified notions generalized horn spectrum generalized krom spectrum 
model class isomorphism closed class structures fixed finite signature 
fagin theorem gr theorems summarized follows 
model class finite structures np iff generalized spectrum 
model class ordered structures iff generalized horn spectrum 
model class ordered structures nlogspace generalized krom spectrum 
exercise 
class problems decidable logarithmic space symmetric turing machines 
nondeterministic machines successor relation configurations symmetric 
symmetric logic denoted set second order formulae qm clauses form exclusive order formula containing instance expresses graph bipartite 
prove captures ordered structures 
transitive closure logics limitations order logic lack mechanism unbounded iteration recursion 
motivated study powerful languages add recursion way order logic 
simple important example query order expressible reachability 
adding transitive closure operators fo obtain natural family logics recursion mechanism 
definition 
transitive closure logic denoted tc obtained augmenting syntax order logic rule building formulae formula variables xl xk yl yk tuples terms 
formula says pair contained transitive closure binary relation tuples defined 
words tc exist tuples cn course understood contain free variables free new formula 
transitive closure logic closed usual order operations 
build boolean combinations tc formulae nest tc operators example 
directed graph acyclic vz tc exy 
known graph bipartite contain cycle odd length 
expressed tc formula tc 
exercise 
show tc set finite models decidable nlogspace 
idea proof theorem shows ordered structures tc captures nlogspace 
condition log space bounded turing machine accepts code expressed formula sy accept tc 
theorem immerman 
ordered structures tc captures nlogspace 
interesting variants tc deterministic transitive closure logic denoted dtc symmetric transitive closure logic denoted stc 
logics definable transitive closure definable relation respectively deterministic symmetric 
syntax dtc analogous tc allowing build formulae form dtc formula 
semantics defined equivalence dtc 
stc build formulae stc semantics defined equivalence clear transitive closures deterministic symmetric relations respectively checked deterministic symmetric turing machines logarithmic space 
conversely acceptance machines amounts decide reachability problem accepting configuration reachable input configuration respect successor relation configurations 
course deterministic turing machines deterministic symmetric turing machines symmetric 
know ordered structures order definable acceptance defined appropriate transitive closure logics 
gives capturing results 
theorem immerman 
ordered finite structures dtc captures logspace ii stc captures 
particular separating dtc tc ordered finite structures amount separating complexity classes logspace nlogspace 
domain arbitrary finite structures separate logics 
graph graph vertex set edges 
easy see class double graphs dtc collapses fo 
take tuple il uk ik vertices double graph closure set ul uk 
switching second component node automorphism definable deterministic path leave closure node belongs closure dtc definable paths bounded length defined order formulae 
side usual argument ehrenfeucht fra iss games showing transitive closures order definable applies class double graphs 
dtc strictly powerful tc double graphs 
graph classes identified tc expressive dtc 
interesting example class hypercubes 
theorem 
finite graphs dtc tc 
respects tc richer complicated logic dtc 
instance dtc positive normal form formulae dtc rewritten dt operator positively 
side alternation hierarchy tc strict 
fixed point logics distinguishing features finite model theory compared branches logic eminent role various kinds fixed point logics 
fixed point logics extend basic logical formalism order logic conjunctive queries propositional modal logic constructor forming fixed points relational operators 
mean relational operator 
note formula vocabulary viewed defining structure update operator class ary relations fixed point relation general fixed point need exist may exist 
happens occur positive operator monotone case exists relation influential fixed point formalisms logic concerned greatest fixed points discuss 
finite model theory number fixed point logics important structure expressive power algorithmic properties logics studied intensively 
discuss 
fixed point theory developed mathematical theory fixed points monotone operators complete lattices 
complete lattice partial order supremum upper bound infimum greatest lower bound 
mainly interested powerset lattices universe structure product lattices bm 
simplicity describe basic facts fixed point theory lattices arbitrary finite infinite set 
definition 
function 
fixed point 
fixed point resp 
greatest fixed point fixed point resp 
fixed point 
monotone theorem knaster tarski 
monotone operator fixed point lfp greatest fixed point gfp 
fixed points may written form lfp gfp proof 
show fixed point clearly monotone follows cf ns 
definition contained particular contained fixed points fixed point argument greatest fixed point analogous 
fixed points constructed inductively 
call operator inductive sequence stages ordinal defined xx xa limit ordinals increasing fi sequence stages inductive operator eventually reaches fixed point denote 
ordinal fi oc called cl closure ordinal lemma 
inductive operator icl proof 
ibi denote smallest cardinal greater ibi suppose claim false set xa ibi impossible 
proposition 
monotone operators inductively constructed fixed point coin fixed point lfp 
proof 
fixed point lfp 
converse show induction lfp lfp suffices show contained trivial 
monotonicity induction hypothesis limit ordinals ua greatest fixed point constructed dual induction starting setting ya limit ordinals 
decreasing sequence stages eventually converges greatest fixed point gfp 
greatest fixed point dual 
monotone operator dual operator denotes complement monotone lfp gfp gfp lfp fa 
exercise 
prove 
far said holds operators arbitrary finite infinite powerset lattices 
finite model theory considering operators finite 
inductive constructions reach greatest fixed point polynomial number steps 
consequence fixed point constructed efficiently 
lemma 
monotone operator finite set computable polynomial time wrt 
iai fixed points lfp gfp 
fixed point logic lfp logic obtained adding greatest fixed points order logic 
definition 
fixed point logic lfp defined adding syntax order logic fixed point formation rule formula vocabulary positive occurrences tuple variables tuple terms lengths match arity lfp gfp formulae vocabulary free order variables formulae free free 
semantics 
structure pro free variables formula lfp tuple elements interpreting contained lfp update operator defined 
similarly greatest fixed points 
example 
fixed point formula defines transitive closure binary predicate tc lfp exy exz 
note formula lfp may additional free variables remain free fixed point formula 
called parameters fixed point formula 
instance transitive closure defined formula 
tx exy parameter 
exercise 
show lfp formula equivalent parameters expense increasing arity fixed point variables 
example 
vy ry lfp rx defines founded part length longest founded initial segment vx lfp rx 
exercise 
prove lfp sentence vy 
vx fxy rx infinity axiom satisfiable finite model 
example 
game query asks finite game vo compute set winning positions player see section 
game query lfp definable lfp wx 
exy wy vo vy exy wy 
game query plays important role lfp 
shown lfp definable property finite structures reduced game quantifier free translation 
game complete lfp notion reduction natural candidate tries separate weaker logic lfp 
exercise 
prove problem gen circuit value problem see examples expressible lfp 
duality greatest fixed point implies formula gfp lfp formula obtained replacing occurrences atoms negations 
occurs positive true 
duality greatest fixed points omitted definition lfp 
hand convenient keep greatest fixed points duality de morgan laws translate lfp formulae negation normal form push negations way atoms 
capturing polynomial time 
fact order operations polynomialtime computable lemma immediately conclude lfp definable property finite computable polynomial time 
proposition 
sentence lfp 
decidable polynomial time finite structure model short lfp ptime 
obviously lfp fragment second order logic 
tarski knaster theorem lfp vr ry 
relate lfp horn 
theorem 
formula horn equivalent formula lfp 
proof 
theorem assume rm horn 
com predicates rm single predicate larger arity renaming variables easy transform equivalent formula ci clauses form ai exactly head dj clauses form 
clauses ci define structure monotone operator vi ai 
fixed point operator 
obviously tuple defined fixed point formula equivalent formula obtained substituting occurrences atoms 
clearly formula lfp 
horn theorem get immerman vardi theorem 
theorem vardi 
ordered structures fixed point logic cap tures polynomial time 
unordered structures horn strictly weaker lfp 
modal calculus fragment lfp fundamental importance areas computer science controller synthesis hardware verification knowledge representation modal calculus lg 
obtained adding greatest fixed points propositional modal logic ml 
words lg relates ml way lfp relates fo 
modal logics ml calculus evaluated transition systems alias kripke structures alias coloured graphs particular node 
formula transition system write denote holds node recall formulae ml reasoning transition systems built atomic propositions pb means usual propositional connectives modal operators 
formula action build formulae semantics iff iff transition relation simply writes respectively 
ml viewed extension propositional logic 
context convenient view simple fragment order logic 
modal formula defines query transition systems associating set nodes iv set equivalently defined order formula 
translation takes atomic proposition pb atom pbx commutes boolean connectives translates modal operators quantifiers follows vy 
note resulting formula width written variables 
proved proposition 
formula ml exists order formula width equivalent sense iff 
modal fragment order logic image propositional modal logic translation 
turned modal fragment interesting algorithmic model theoretic properties see 
definition 
modal calculus extends ml including propositional vari ables viewed monadic second order variables rule building fixed point formulae formula propositional variable occurs positively vx formulae 
semantics fixed point formulae completely analogous lfp 
formula defines universe interpretations free second order variables may monotone operator assigning set set pg iv 
iff lfp vx iff gfp example 
formula expresses exists path transitions node holds 
formula vac true aca expresses transition system deadlock free 
words path reaches dead node outgoing transitions 
formula vx ty says exists path current node holds infinitely 
exercise 
prove formulae example express stated properties 
translation ml fo readily extends translation lu lfp 
proposition 
formula lu equivalent formula lfp 
proof 
induction 
formula form translated similarly greatest fixed points 
argument proving lfp embedded shows fragment mso 
turn algorithmic issues 
complexity model checking problem major open problem far combined complexity expression complexity concerned see section 
data complexity settled easily 
proposition data complexity 
fix formula finite transition system node decided polynomial time exist model checking problem ptime complete 
proof 
fragment lfp claim obvious 
second claim recall game problem strictly alternating games ptime complete see section 
player winning strategy position game tx despite result difficult see calculus suffice capture ptime restricted scenarios instance word structures 
lu fragment mso define regular languages course ptime languages regular 
see section multi dimensional variant lu captures bisimulation invariant fragment ptime 
information calculus refer 
parity games fixed point logics appropriate evaluation games parity games 
games possibly infinite duration position assigned natural number called priority winner infinite play determined priority seen infinitely play odd 
open winning sets winning strategies parity games computed polynomial time 
best algorithms known today polynomial size game exponential respect number priorities 
practically competitive model checking algorithms modal calculus solving strategy problem associated parity game see 
definition 
describe parity game labelled graph game graph section assigns position priority 
set positions may finite infinite number different priorities finite called index recall finite play game lost player gets stuck move 
difference games section different winning conditions infinite plays 
number appearing infinitely sequence vl priorities player wins play player wins 
recall positional strategy player rr partial function strategy said winning set positions play starts position consistent winning player rr 
winning set winning region player rr set positions player rr winning strategy priori need positional 
exercise 
combination positional strategies 
positional strategies player rr winning sets respectively 
positional strategy defined 
prove winning forgetful determinacy theorem parity games states parity games determined position players winning strategy fact positional strategies suffice 
proved independently emerson jutla mostowski 
earlier gurevich harrington proved muller games general parity games determined finite memory strategies 
theorem forgetful determinacy 
parity game set positions partitioned sets wo player positional strategy winning wo player positional winning strategy winning 
prove theorem case finite game graphs 
presentation inspired similar proof due ehrenfeucht mean payoff games proof due sandberg 
general case refer 
proof 
parity game finite set positions 
call position live non terminal possible move 
theorem trivially holds games live position 
proceed induction number live positions 
live position cr define game change terminal position player cr wins 
technically means put vl delete outgoing edges 
induction hypothesis forgetful determinacy theorem holds cr write cr wl winning regions suffices show live position players positional strategy win exercise strategies combined positional strategies win entire winning regions 
clearly wi 
positional strategy player winning position game winning game avoids play starts consistent hits position 
lj live call positions aa strong winning position player cr informally speaking player cr win gives away live position opponent 
similarly positions outside called weak positions 
remains show weak positions players positional winning strategy 
fact players wins positional winning strategy weak positions 
induction hypothesis live positions rr player rr positional strategy fv starting position wins eventually reaches distinguish cases depending exist strong winning positions live terminal positions course strong 
case suppose exists live position player rr wins weak position know player rr positional strategy win positional strategy fv wins reaches easily combine positional winning strategy win set winning 
case ii suppose live positions weak 
claim case player wins live weak positions minimal priority player wins live positions minimal priority odd 
live positions weak know player rr live live position positional strategy fy wins reaches live position take live position minimal priority put rr case rr case odd 
pick live position combine positional winning strategies fv fw new positional strategy fw ifx fv 
claim winning strategy player rr live positions play player moves hits finitely eventually coincides play consistent fv won player rr 
play hits infinitely minimal priority seen infinitely player rr wins case 
exercise 
parity game winning sets 
obviously positional winning strategy player remain inside vo wo wo 
remain inside winning region suffice winning game 
construct parity game positional strategy player plays consistent remain won player 
hint trivial game positions suffices 
exercise 
game game game graph winning condition depend finite prefixes plays 
means 
roy infinite plays ra 
won player 
obviously parity games special case games 
prove game winning region player fixed point necessarily operator defined formula 
monotone greatest fixed points exist lfp gfp 
find conditions parity games implying lfp gfp 
theorem 
decided np np position parity game winning position player proof 
node parity game winning position player rr exists positional strategy winning position suffices show question winning strategy player rr position decided polynomial time 
prove player argument player analogous 
obtain reduced game graph gf el keeping moves consistent ef vr vl 
reduced game opponent player non trivial moves 
call cycle el odd priority nodes odd 
clearly player wins position strategy gf odd cycle terminal position reachable reachability problem solvable polynomial time claim follows 
fact proved problem denotes class np problems unique witnesses 
best known deterministic algorithms compute winning partitions parity games running times polynomial respect size game graph exponential respect index game 
theorem 
winning partition parity game index computed space iei time isl unfolding parity game 
parity game 
assume minimal priority range node minimal priority unique successor 
loss generality 
parity game way nodes non maximal priority unique successors choices relevant nodes 
priority game odd consider dual game switched roles players priorities decreased 
set nodes minimal priority game obtained deleting edges nodes terminal positions 
define unfolding sequence games ga ranges ordinals coincide winning conditions terminal positions define decomposition set declare game ga player rr winner 
write winning set player rr game ga note depends course decomposition concerning positions outside 
turn decomposition depends winning sets wy ga set limit ordinals determinacy increasing winning sets player decreasing winning sets player increasing exists ordinal cardinality bounded cardinality claim fixed points coincide winning sets original game lemma unfolding lemma 
wo proof 
suffices define strategy player strategy player game means player cr wins positions fix winning strategy fa player winning set note fa trivially extends strategy game nodes unique successors 
claim fact winning strategy positions see consider play position play leave vi vi winning strategy vi vi implies definition vi vi play leaves necessarily won player goes finitely positions coincides certain point onwards winning play goes infinitely positions case player wins minimal priority hit infinitely 
construct winning strategy player game define node ordinal min 
fix ordinal winning strategy ga player winning set game set ga yl consider play position claim vi vi vi vi vi vi vi 
vi vi vi player moves locally winning strategy ga player leave winning sets opponent vi vi successor ordinal vi vi 
definition 
vi vi 
properties imply play stays inside values decreasing 
infinite strictly descending chains ordinals play eventually remains inside fixed outside moves reduce value 
play eventually coincides play player plays winning strategy ga player wins 
model checking games fixed point logic defining evaluation games lfp formulae analysing complexity model checking convenient assumptions 
fixed point formulae contain parameters reason discussed 
second formula negation normal form negations apply atoms third named fixed point variable bound free second order variables distinct fixed point variables 
write unique subformula form fp 
fp means lfp gfp 
technical reasons assume fixed point variable occurs inside scope quantifier 
common assumption affect expressive power 
say depends occurs free 
transitive closure dependency relation called dependency order denoted 
alternation level maximal number alternations greatest fixed point variables paths alternation depth ad fixed point sentence maximal alternation level fixed point variables 
consider finite structure lfp formula assume named negation normal form parameters 
model checking game parity game 
case order logic positions game expressions subformulae instantiated elements initial position 
moves order game positions associated fixed point formulae fixed point atoms 
positions unique move say formula defining fixed point 
formal definition recall named fixed point variable unique subformula fp 

position 
moves fixed point atom moves position 
case fixed points game usual hintikka game order logic 
consider case formula fixed point operator lfp 
intuition position lfp verifier tries establish enters stage fixed point induction defined game goes order formula verifier win game finite number steps force position enters fixed point stage 
game resumes position associated descending sequence ordinals finite verifier win game finite number steps 
formula true win finite number steps force play go infinitely positions form positions assigned priority positions higher priorities play won 
gfp formulae situation reversed 
verifier wants force infinite play going infinitely positions gfp atoms assigned priority 
general case formula nested greatest fixed points infinite play may see different fixed point variables infinitely 
variables smallest respect dependency order 
shown iff smallest variable gfp variable provided players play optimally 
priority labelling assign priorities gfp atoms odd prior ities lfp atoms 
te fixed point variables different kind atoms get lower priority atoms 
index parity game main source difficulty computing winning sets number different priorities kept small possible 
avoid factor appearing common constructions kind adjusting definition alternation level alternation depth setting odd lfp variable gfp variable 
cases 
ad maximal value ad fixed point variables priority labelling positions defined fixed point atoms ad formulae 
completes definition game 
note priority labelling satisfies properties explained index ad 
theorem 
named parameter free lfp formula negation normal form relational structure 
player winning strategy parity game 
proof 
proved induction interesting case concerns fixed point formulae 

game positions minimal priority fixed point atoms unique successors 
induction hypothesis know inter iff player winning strategy 
unfolding greatest fixed points know approximations ordinal induction immediately sees games ta coincide unfolding game games 
unfolding lemma conclude player wins game iff wins games iff 
iff 
fixed point formulae proceed dualization 
clearly size game time complexity construction bounded icl iai width 
lfp formulae bounded width size game polynomially bounded 
corollary 
model checking problem lfp formulae bounded width parameters np np fact 
formulae calculus viewed lfp formulae width bound applies lu 
different approach problem mentioning games explicitly see 
known open problem model checking problem lu solved polynomial time 
exercise 
prove model checking problem lu solved polynomial time true parameter free lfp formula width fixed hint finite structure relations ri ri transition system universe unary relations 


ar ri iij ai aj binary relations ej ai bi bi substitution rr 
translate formulae lfp width formulae lu iff 
see pp 
details 
theorem obtain deterministic complexity bounds lfp model checking 
theorem 
finite structure formula width alternation depth decided space icl iai time ic il corollary 
model checking problem lfp formulae bounded width bounded alternation depth solvable polynomial time 
fixed point formulae parameters 
imposed condition fixed point formulae contain parameters 
parameters allowed naive definition width corollary longer true pspace 
intuitive reason parameters allow hide order variables fixed point variables 
proved qbf evaluation problem quan boolean formulae reduced evaluating lfp formulae order variables unbounded number monadic fixed point variables fixed struc ture elements 
expression complexity evaluating formulae pspace complete 
similar argument works case number fixed point variables bounded structure fixed combined complexity expression complexity 
collection logic lfp formulae variables including parameters contained bounded width fragment infinitary logic 
lfp formulae unbounded width 
lfp formulae unbounded width theorem gives exponential time bound 
improved simple lfp formulae 
theorem vardi 
model checking problem lfp formulae unbounded width exptime complete formulae fixed point operator fixed structure elements 
defer hardness proof section show expression complexity exptime hard datalog restricted formalism lfp 
simultaneous fixed point inductions general variant lfp permits simultaneous inductions formulae 
simultaneous induction system operators form bm fm bm bm forming operator fm bm bm 
inclusion product lattice bm component wise 
accordingly monotone xi yi fi fi said greatest fixed points carries simula induction 
particular monotone operator fixed point lfp constructed inductively starting iterating fixed point reached 
extend logic lfp simultaneous fixed point formation rule 
definition 
simultaneous fixed point logic denoted lfp extension order logic rule 
syntax formulae vocabulary rm positive occurrences sequence variables matching arity ri 
system update rules build formulae lfp gfp tuple terms length matches arity ri 
semantics structure defines monotone operator sm mapping tuples rx rm relations sx sm si 
operator monotone fixed point lfp rm 
similarly greatest fixed points 
example 
return circuit value problem circuits fan nand gates see example 
simultaneous lfp definitions nodes evaluating true false respectively circuit formulae lfp lfp system tz exz fx fz xy exz tx ty 
elimination simultaneous fixed points 
question arises simultaneous fixed points provide expressive power simple ones 
prove case 
simultaneous fixed points simulated nested simple ones technique called bekic principle 
just consider case monotone operators write fixed point combined operator 
fixed operator gx gx monotone fixed point lfp gx lemma 
operator lfp gx monotone fixed point lfp 
proof 
trivial induction shows stages gr induced operators gx gx 
consequence lfp gx lfp gx lfp gx lfp gx 
shows monotone 
note lfp gf fixed point contains fixed point lfp 
lfp avo lfp follows lfp 
remains show lfp 
proceed induction showing stages operator stages satisfy lfp lfp 
ct clear 
lfp lfp lfp lfp lfp lfp lfp lfp 
limit ordinals induction argument trivial 
ready show system formulae lfp equivalent simple lfp formula 
translation increase number arity fixed point variables alternation depth changes greatest fixed points 
remains valid interesting fragments lfp monadic lfp alternation free lfp modal calculus see 
increase nesting depth fixed point operators 
alternative elimination techniques increase nesting depth augment arity fixed point operators 
theorem 
lfp lfp 
proof 
obviously lfp contained lfp 
converse restrict attention simultaneous inductions formulae 
general case treated analogous arguments 
system claim lfp 

lfp 


prove equivalence 
fix structure consider operator 
writing fixed point lfp iff formula lfp defines operator lfp ga gt 

lfp 
previous lemma lfp 
shown simultaneous fixed points provide expressive power permit write formulae modular readable form 
positive lfp 
lfp modal calculus allow arbitrary nesting greatest fixed points arbitrary interleaving fixed points boolean operations quantifiers classical studies inductive definability order logic focus restricted logic 
lfp called positive lfp extension order logic obtained fixed points positive order formulae parameters closing disjunction conjunction existential universal quantification negation 
lfp conveniently characterised terms simultaneous fixed points 
just state result leave proof reader 
theorem 
query definable lfp definable formula form lfp system update rules ri order formulae ti 
require diminishing expressive power formulae ti system purely existential formula purely universal formula 
inflationary fixed point logic lfp instance logic explicit operator forming fixed points 
exist number fixed point extensions order logic fragments extensively studied finite model theory 
include inflationary partial nondeterministic alternating fixed point logics 
common allow construction fixed points operators necessarily monotone 
operator called inflationary operator associate inflationary operator defined kj 
particular inflationary operators inductive iterating yields fixed point called inflationary fixed point exercise 
prove facts 
monotone operators need inflationary inflationary operators need monotone 
inflationary operator need fixed point 
fixed point inflationary operator exists may different inductive fixed point 
monotone operator inflationary fixed point fixed point coincide 
logic ifp defined similar syntax lfp requirement fixed point variable occurs positive formula semantics associated inflationary operator 
definition 
ifp extension order logic fixed point formation rule 
formula tuple variables tuple terms lengths match arity build formula ifp 
semantics 
structure ifp contained union stages inflationary operator defined 
item exercise inflationary inductions equivalent positive formulae ifp expressive lfp 
finite structures inflationary inductions reach fixed point polynomial number iterations ifp definable class finite structures decidable polynomial time 
proposition 
ifp captures ptime ordered finite structures 
versus inflationary fixed points 
logics capture ptime ifp lfp equivalent ordered finite structures 
unordered structures 
shown gurevich shelah equivalence ifp lfp holds finite structures 
proof infinite structures important aspects inflationary inductions behave differently 
instance ar order operators arithmetic say inflationary fixed point definable fixed point order operator 
alternation hierarchy lfp strict ifp positive normal form see exercise 
conjectured ifp powerful lfp 
show ifp equivalent lfp arbitrary structures 
proofs gurevich shelah rely constructions showing stage comparison relations inflationary inductions definable lfp inductions 
definition 
inductive operator stages inductive fixed point rank element min ct stage comparison relations defined formula write stage comparison relations defined operator assuming inductive inf inf stage comparison relations associated inflationary operator 
example 
formula exy sz exz relation graph distance comparison iff dist stage comparison theorems results definability stage comparison relations 
instance moschovakis proved stage comparison relations positive order formula definable simultaneous induction positive order formulae 
equivalence results ifp lfp needs stage comparison theorem ifp inductions 
observe stage comparison relations ifp inductions easily definable ifp 
formula stage comparison relation inf defined formula ifp needs show stage comparison relation ifp inductions fact lfp definable 
theorem inflationary stage comparison 
formula fo lfp stage comparison relation inf definable lfp 
finite structures definable positive lfp 
see proofs case finite structures difficult construction general case 
result equivalence lfp ifp follows easily 
theorem gurevich shelah 
ifp formula equivalent lfp formula 
inf 
proof 
formula stage comparison theorems interesting consequences 
instance moschovakis theorem implies finite structures greatest fixed points negations fixed points expressed positive lfp 
gives normal form lfp ifp see 
theorem 
finite structures lfp formula ifp formula equivalent formula lfp 
result fails infinite structures 
infinite structures exist lfp formulae equivalent positive ones fact alternation hierarchy greatest fixed points strict see 
exercise 
prove ifp formula equivalent uses ifp operators positively 
hint assuming structures contain elements constant available formula ifp 
equivalent inflationary induction predicate ty simulates induction defined checks fixed point reached atoms true contained fixed point 
finite model theory due gurevich shelah theorem logics lfp ifp interchangeably 
significant differences overlooked 
despite equivalence ifp lfp inflationary inductions powerful concept monotone inductions 
translation equivalent lfp formulae formulae complicated requires increase arity fixed point variables case infinite structures introduces alternations greatest fixed points 
convenient inflationary inductions explicit constructions advantage restricted inductions positive formulae 
example see proof theorem 
furthermore ifp robust sense inflationary fixed points remain defined non monotone operators generalized quantifiers added language see instance 
differences inflationary fixed points particularly significant context modal logic compare modal calculus inflationary counterpart 
instance finite model property satisfiability problem decidable complete exptime model checking problem np np conjectured solvable polynomial time practical automata techniques solving algorithmic problems associated terms expressive power characterised bisimulation invariant fragment monadic second order logic mso 
hand inflationary counterpart model iteration calculus mic behaves differently 
finite modal property fails satisfiability problem undecidable arithmetic hierarchy model checking problem space complete expressive power goes monadic second order logic words 
partial fixed point logic fixed point logic relevant finite structures partial fixed point logic pfp 
arbitrary formula defining finite structure neces monotone operator consider sequence finite stages lm 
sequence necessarily increasing 
finite sequence converges fixed point reaches cycle period greater 
define partial fixed point fixed point reached case empty relation 
logic pfp obtained adding order logic partial fixed point formation rule allowing build formula formula pfp saying contained partial fixed point operator note occurs positive lfp pfp lfp pfp 
pfp powerful lfp 
instance fixed point induction finite structures reaches fixed point polynomial number iterations partial fixed point induction may need exponential number stages 
example 
consider sequence stages defined formula finite linear order 
easily seen fixed point reached induction set fixed point reached induction goes lexicographic order possible subsets fixed point reached stage 
simultaneous inductions 
case lfp extend ifp pfp simultaneous inductions formulae simultaneous fixed point logics ifp pfp expressive simple variants 
proof bit different case lfp 
requires encodes relations increases arity fixed point variables 
consequence unknown simultaneous monadic pfp collapses simple monadic pfp 
complexity 
pfp induction finite structure may go exponentially stages respect cardinality structure stage represented polynomial storage space 
order formulae evaluated efficiently follows simple induction pfp formulae evaluated polynomial space 
proposition 
formula pfp set finite models pspace short pfp pspace 
ordered structures similar techniques previous capturing results simulate polynomial space bounded computation pfp formulae 
theorem abiteboul vianu vardi 
ordered finite structures pfp captures pspace 
proof 
remains prove class finite ordered structures recognizable pspace defined pfp formula 
polynomially space bounded deterministic turing machine state set alphabet recognizing encoding ordered structure pa pa 
loss generality assumptions 
input structures cardinality requires space fixed configuration denote configuration 
transition function adjusted accepting configuration 
represent configuration current state tape inscription wl wm head position word wl wi wi kl wm alphabet just marker description uniform 
moving configuration turing machines local changes 
associate function configuration cm successor configuration determined rules ci ci ci 
recall encode structures exist order formulae th symbol input configuration code represent configuration computation tuple er ary relations th symbol 
configuration time stage simultaneous pfp induction defined rules rr rule just says stage represents word starting 
rules ensure sequence contains empty relations stage stage represents input configuration sequence represents configuration stage represents successor configuration 
convention accepts input sequence configurations stationary reaches fixed point 
accepts code relations defined simultaneous pfp induction rules described nonempty 
pfp definable 
alternative characterisation pspace terms database query language consisting essentially order relational updates loops 
vardi proved captures pspace ordered finite structures abiteboul vianu proved pfp equivalent finite structures 
versus partial fixed point logic 
capturing results ptime pspace immediately get ptime pspace lfp pfp ordered finite structures 
natural question arises lfp pfp separated domain finite structures 
number logics separation results arbitrary finite structures established relatively simple methods corresponding separation ordered structures solve major open problem complexity theory 
instance proved quite simple argument dtc difficult show tc lfp tc contained stratified datalog strictly contained lfp see sect 

trivial lfp expressive finite structures 
situation different lfp vs pfp 
theorem abiteboul vianu 
lfp pfp equivalent finite structures ptime pspace 
datalog stratified datalog datalog extensions family rule database query languages extend conjunctive queries relational recursion mechanism similar fixed point logics 
see datalog seen fragment fixed point logic 
purpose section simply identify relational database finite relational structure 
adequate aspects database theory questions considered appropriate 
information databases see 
definition 
datalog rule expression form bm head rule atomic formula body rule conjunction literals atoms negated atoms form st tuples variables constants 
relation symbol called head predicate rule 
allow boolean head predicates 
datalog rule positive contain negative literals 
datalog program ii finite collection rules head predicates occurs negated body rule 
predicates appear bodies rules called input predicates 
input vocabulary ii set input predicates constants appearing ii 
example 
datalog program consists rules exy ry tay 
input vocabulary head predicates structure input vocabulary program computes interpretation head predicates defines expansion ii rk ri values head predicates computed ii 
interpretation defined equivalent ways instance minimal model semantics fixed point semantics 
read datalog rule tr bm associate program ii universal closure conjunction formulae compare expansions component wise inclusion additional predicates minimal model semantics minimal expansion 
satisfies 
example 
formula associated program iir cn example exy ry tay 
minimal expansion graph distinguished node transitive closure set points reachable path exercise 
prove minimal model semantics defined datalog program ii input database unique minimal expansion model fixed point semantics read rule fi update oper ator instantiation fi body rule true current interpretation head predicates corresponding instantiation head true 
initially head predicates empty 
stage apply simultaneously update operators rules program current interpretation iterate operation fixed point rc reached 

exercise 
prove minimal model semantics fixed point semantics coincide 
definition 
datalog query pair consisting datalog program designated head predicate structure query associates result interpretation computed input 
relate datalog lfp 
show datalog query equivalent formula lfp fact special form 
datalog program input vocabulary head predicates rk 
normalize rules rules head predicate ri head 
done appropriate substitutions rule body adding equalities 
instance rule rewritten xl xl program containing head predicate ri rules rij form ri ij ij tion literals equalities 
combine update operators associated head predicate describe update ri existential order formula ij 
consequence fixed point semantics described system order update rules query ri equivalent formula lfp ri 
datalog query equivalent lfp formula fixed point operators applied existential formulae 
definition 
existential fixed point logic denoted efp set simultaneous lfp formulae universal quantifiers gfp operators negations applied atomic formulae 
seen datalog efp 
converse true established straightforward induction formula efp associates datalog program ii distinguished head predicate query ii equivalent leave details exercise 
proposition 
datalog equivalent efp 
know lfp captures ptime ordered finite structures 
question arises datalog sufficiently powerful 
answer depends precise variant datalog notion ordered structures 
distinguish cases 
simple monotonicity argument shows datalog weaker ptime structures linear order successor relation 
pa substructure ii ii datalog query ii 
course exist simple order queries monotone sense 
note argument break databases successor relation just linear order constants elements 
exercise 
literature datalog programs required contain positive rules input predicates positively 
restricted variant weak capture ptime successor structures 
input predicates positively queries monotone extensions input relations database obtained pa augmenting input relations exercise 
prove property give examples order queries defined datalog programs 
case programs negations input predicates databases successor relation constants element capture ptime datalog 
originally established implicit 
theorem blass gurevich papadimitriou 
successor structures datalog negations input predicates captures ptime 
proof 
result established ways instance reduction horn making fact ptime closed complement 
give direct proof 
clear datalog queries computable polynomial time 
remains prove class finite successor structures recognizable ptime defined boolean datalog query 
polynomial time turing machine state set alphabet rec encoding successor structure pa pa denote cardinality input structure assume computation time pa construction similar proof theorem 
configurations represented words wl wi wi wm alphabet describe behaviour function configuration cm successor configuration determined rules ci ary relation symbol ii datalog program head predicate computing successor relation tuples associated lexicographic order defined give successor relation 
recall encode successor structures exist quantifier free formulae fi fi th symbol input configuration code rr 
ii datalog query equivalent 
represent computation tuple cr ary relations th symbol configuration time datalog program associated consists program ii defining successor relation tuples programs ii describing input rules rr rr rule ca rule acc accepting state symbol rules say configuration starts ends set rules ensures configuration time input configuration 
rules imply time time computation proceeds required rule boolean predicate acc true accepting state reached 
obviously accepts input structure query iim acc evaluates true 
proof shows expression complexity datalog lfp exptime complete see theorem 
theorem 
evaluation problem datalog programs head predicates unbounded arities complete exptime programs positive rules fixed database elements 
proof 
results section lfp formulae datalog programs evaluated polynomial time respect size input structure exponential time respect formula program length 
prove completeness fix database elements constant symbols alternatively unary relations tl 
deterministic turing machine accepts rejects input words wo wm time mu fixed 
input construct datalog program hm evaluates fixed database boolean head predicate acc true accepts construction proof theorem differences 
previous proof fixed depended input way round description input configuration simpler just explicitly list atomic facts defining input configuration input note part program depends remaining rules depend length input 
note program contains positive rules 
stratified datalog 
datalog defines natural way queries require recursion transitive closure weak respects mainly include negation 
exist various possibilities add negation datalog 
definition 
stratified datalog program sequence hr basic datalog programs called strata head predicates head predicate precisely stratum hi input predicate higher strata hj particular means head predicate stratum hj occurs positively body rule stratum hi ii head predicate stratum hj occurs negatively body rule stratum hi semantics stratified program defined stratum stratum 
input predicates stratum hi input predicates entire program head predicates lower stratum 
lower strata evaluated compute interpretation head predicates hi case basic datalog programs 
clearly power stratified datalog datalog lfp stratified datalog provides formalism captures ptime ordered structures 
unordered structures stratified datalog strictly expressive datalog includes order logic strictly powerful lfp 
main example separating lfp stratified datalog game query defining winning positions player strictly alternating game 
defined lfp formula lfp wx exy vx wz 
involves recursion universal quantifier general done stratified datalog 
theorem dahlhaus kolaitis 
stratified datalog program express query 
stratified datalog lfp 
example 
interesting class examples showing limits stratified datalog foundedness properties statements saying infinite paths eventually hit node certain property typical statements verification expressed ctl formula afp 
lfp foundedness partial order wx 
ctl formula afp expressed tx lfp lfp rx 
px vy exy ry 
finite structures properties definable stratified datalog programs essentially negations reachability problems cycles 
afp means path eventually cycles globally false 
expressed stratified program 
px exy py pz px exy rx stratum computes set pairs nodes exists path false set nodes exists path eventually cycles 
finiteness graph essential way guarantees infinite path eventually reaches cycle 
second stratum takes complement 
shown stratified datalog program express statements infinite structures countable ones 
variant datalog called datalog lite express ctl properties admits linear time evaluation algorithms incomparable stratified datalog defined studied 
stratified datalog program linear body rule occurrence head predicate stratum may arbitrary occurrences head predicates lower strata 
example 
program example linear replacing second non linear rule linear rule obtain equivalent linear program 
pays prize linearization 
original program reaches fixed point log iterations linear program needs iterations length longest path graph 
linear programs suffice define transitive closures follows straightforward induction tc linear stratified datalog 
converse true see 
proposition 
linear stratified datalog equivalent tc 
corollary 
ordered structures linear stratified datalog captures nlogspace 
logics counting point view expressiveness order logic main deficiencies lacks power express requires recursion simplest example transitive closure count witnessed impossibility express structure cardinality generally law 
discussed number logics add recursion way fo part notably various forms fixed point logics 
ordered finite structures logics express precisely queries computable ptime pspace 
arbitrary finite structures known examples showing involve counting 
presence ordering ability count inherent fixed point logic hardly retained absence 
instance lfp pfp fragments loc law holds 
immerman proposed add counting quantifiers logics asked suitable variant fixed point logic counting suffice capture ptime 
cai immerman eventually answered question negatively fixed point logic counting turned important robust logic defines natural level expressiveness allows capture ptime interesting classes structures 
fixed point logic counting logics counting terms 
different ways adding counting mechanisms logic necessarily equivalent 
straightforward possibility addition quantifiers form obvious meaning 
perfectly reasonable bounded variable fragments order logic infinitary logic see general fixed point logic allow recursion counting parameters quantifiers ix 
fact counting parameters fixed numbers adjoining quantifiers ix give additional power logics fo lfp closed replacing ski existential quantifiers restrictions bounded width 
counting parameters considered variables range natural numbers 
define precise way logic counting recursion extends original objects study finite sorted structures sorted auxiliary structures second numerical finite sort 
definition 
sorted finite structure universe associate sorted structure iai canonical ordering stand element 
taken disjoint union linear order length iai 
start order logic sorted vocabularies structures defined obvious way 
latin letters variables sort greek letters variables second sort 
sorts related counting terms defined rule formula variable sort free variables 
term second sort set free variables free qo free 
value qo number elements satisfy qo 
counting logics form introduced gr otto studied detail 
start order logic counting denoted fo closure sorted order logic counting terms 
simple examples illustrate counting terms 
example 
undirected graph formula exz ex presses node degree regular 
example 
formula fo expresses equivalence relations isomorphic course necessary sufficient condition number elements equivalence classes size el xy 
define inflationary fixed point logic counting ifp partial fixed point logic counting pfp adding fo usual rules building inflationary partial fixed points ranging sorts 
definition 
inflationary fixed point logic counting ifp closure sorted order logic rule building counting terms ii usual rules order logic building terms formulae iii fixed point formation rule suppose tb formula vocabulary xl xk mixed arity tuple second sort terms respectively 
ifp rfi 
formula vocabulary 
semantics ifp rfi 
defined way logic ifp inflationary fixed point operator ru 
definition pfp analogous replacing inflationary fixed points partial ones 
literature finds different variants fixed point logic counting sorts related counting quantifiers counting terms 
count ing quantifiers form exist second sort variable 
obvious definitions equivalent 
fact ifp robust logic 
instance expressive power change permits counting tuples mixed type terms form gt 
course define fixed point logic counting lfp careful positivity requirement natural uses counting quantifiers counting terms 
equivalence lfp ifp readily translates lfp ifp 
number logical formalizations concept inductive definability counting turn expressive power ifp see paragraph datalog counting details 
example 
interesting example ifp definable query method stable graph canonization 
graph colouring vertices define refinement giving vertex new colour fx fx rl 
ni exy fy 
new colours sorted lexicographically form initial subset lt process iterated fixed point stable colouring reached 
easy see stable colouring graph polynomial time computable uniformly definable ifp 
graphs stable colouring uniquely identifies vertex distinct vertices get stable colour 
case instance trees 
babai selkow proved probability happens random graph nodes approaches goes infinity 
stable provide polynomial time algorithm finite graphs 
discuss expressive power evaluation complexity fixed point logic counting 
mainly interested ifp formulae pfp formulae free variables second sort compare usual logics counting 
exercise 
making counting terms ifp sorted structures expressive ifp 
prove construct sorted ifp sentence 
clear counting terms computed polynomial time 
data complexity remains ptime ifp pspace pfp 
see inclusions strict 
theorem 
finite structures ifp ifp ptime 
pfp pfp pspace 
infinitary logic counting 
infinitary logic variables extended quantifiers exist 
proposition 
ifp due sorted framework proof result bit involved corresponding result counting really 
refer details 
separation ifp ptime established cai immerman 
construction provides analysis method stable graph canonization 
simplest form explained example 
sophisticated variants compute refine tuples vertices 
called dimensional lehman method logical terms amounts label tuple type variable logic counting quantifiers 
conjectured method provide polynomial time algorithm graph isomorphism graphs bounded degree 
cai immerman construct families gn nen hn ne graphs side hn nodes degree admit linear time canonization algorithm side order infinitary logic counting variables necessary distinguish gn hn 
particular implies theorem 
inflationary rs 
partial fixed points 
abiteboul vianu proved partial fixed point logic collapses fixed point logic ptime pspace 
analogous result presence counting true ptime pspace ifp pfp 
datalog counting fixed point formulae reputation difficult read people find formalisms datalog easier understand 
presence successor relation data log negation input predicates sufficient capture ptime equally expressive lfp 
general datalog natural extensions notably stratified datalog weaker lfp 
counting terms added datalog 
conclude section discussing datalog counting 
show datalog closed negation equivalent ifp 
presence counting common extensions datalog notably stratified datalog equivalent datalog 
definition 
datalog counting denoted datalog extends datalog allowing sorted head predicates counting terms 
sorted head atoms form rfi range sort elements input database range second sort 
atom counting term 
term second sort called arithmetical term 
arithmetical terms counting terms arithmetical term 
program datalog finite set clauses form 
bm head atomic formula bm atomic formulae equalities terms second sort 
input database program computes intensional relations inflationary fixed point semantics 
note classical datalog programs difference fixed point semantics defined inflationary underlying operator monotone anyway 
programs datalog semantic inflationary equalities arithmetical terms give rise non monotone operators 
reason minimum model semantics longer defined 
inflationary fixed point semantics various equivalent ways define semantics datalog syntax semantics datalog generalize datalog natural way 
introduce counting sight general form allowing counting terms form 
may convenient write program shorter understandable form affect power datalog 
exercise 
prove counting tuples mixed type increase expressive power datalog 
cardinalities arbitrary predicates equated datalog program take liberty write equalities body rule simplicity 
technical lemma essential reducing ifp datalog 
lemma 
ii datalog program head predicates qt 
exists datalog program ii head predicates include qr boolean control predicate qi qi ii true databases true stage evaluation ii proof 
add unary head predicate head predicate qi ii new head predicate qi arity 
ii obtained adding clauses ii cox fi observe qi just lags step qi 
atom cox necessary avoid set true right stage 
lemma essentially says attach program boolean control predicate true evaluation program terminated 
compose datalog programs making sure evaluation second program starts terminated 
application show datalog closed negation 
lemma 
complement datalog query datalog query 
proof 
ii datalog query ii program specified lemma 
take new variable new head predicates arity arity arity arity 
construct ii adding ii rules query ii complement ii 
difficulties express negation reason absence counting ordering datalog weaker fixed point logic 
limited form negation available stratified datalog allow recursion negation suffice express fixed point queries 
datalog limitations equally expressive ifp 
theorem otto 
datalog ifp 
obvious datalog ifp 
converse constructs induction formula ifp datalog program ii goal predicate ii equivalent exercise 
atomic formulae disjunctions existential quantification construction obvious closure negation proved 
complete proof applications counting terms formulae fixed point formulae ifp 

construction lemma 
example 
illustrate expressive power datalog exhibit program game query strictly alternating games 
game query canonical example separates lfp stratified datalog 
game definable fixed point logic formula lfp wx 
exy vz wz defines winning positions player 
datalog program goal predicate defining game exy wz vy exy vy zx wx evaluation program game graph assigns respectively set pairs player winning strategy position moves respectively player begins game 
capturing ptime canonization seen number logics capturing polynomial time ordered finite structures express ptime absence linear order 
conjectured logic whatsoever capture ptime domain finite structures 
discuss problem section 
course conjecture turn true remains important issue capture ptime relevant domains ordered structures 
definable linear orders obvious approach try define linear orders apply known capturing results ordered structures 
definition 
domain finite structures logic 
say admits definable linear orders vocabulary exists formula exists structure pa tuple relation pa linear order elements called parameters order defined pa example 
consist structures undirected cycle 
admits lfp definable linear orders parameters formula zl lfp rxy 
vu 
straightforward automorphism arguments show define linear orders parameters 
exercise 
domain structures isomorphic finite rectangular grid 
show admits lfp definable linear orders 
exercise 
class structures property 
ra exists structure tuple exists non trivial automorphism admit definable orders logic 
domain admits lfp definable linear orders capture ptime lfp formulae express polynomial time properties ordered structures modify appropriately 
proposition 
admits lfp definable linear orders lfp captures polynomial time 
proof 
remains show polynomial time model class 
formula defining linear order structures 
lfp captures ptime ordered structures exists formula lfp structure linear order iff follows linear order formula obtained form replacing atom form 
interpretations set equivalence relation canonization function function associating element canonical member equivalence class 
means finite model theory interested canonization algorithms finite structures isomorphism coarser equivalence relation indistinguishability logic bisimulation 
algorithms take encodings structures inputs encoding structure determined ordering universe view canonization structures operation associates structure ordered say structures mapped ordered structure encoding 
class structures write linear order 
definition 
class finite structures equivalence relation 
canonization function function structure ordered structure interpretations 
especially interested defined interpretations 
notion interpretation important mathematical logic model theory particular 
interpretations define copy structure inside permit transfer definability decidability complexity results theories 
definition 
logic vocabularies rm relational ri arity ri 
dimensional er interpretation sequence formulae consisting called domain formula called equality formula relation symbol arity formula xl xr 
interpretation induces mappings structures formulae 
structure structure say interprets pa short exists surjective map called coordinate map ii relation bl br va bl bk bl bk fl 
rm defines function interpretation rm defines congruence structure qo qo isomorphism quotient structure 
mapping structures structures defines mapping formulae formulae 
formula associates formula obtained quantifier qx replacing equalities atom corresponding formula lemma interpretation lemma 
interpretation structure omit interpretation trivial sense holds equivalent notion interpretation generalized various ways 
particular dimensional interpretation sequence rl rm xl disjoint tuples distinct variables 
dimensional interpretation represents elements elements equivalence classes exercise 
show order interpretation finite structures graphs see chapter chapter 
precisely vocabulary construct fo interpretation foil interpretation finite structure elements graph 
follows model class fin decidable polynomial time class graphs 
definition 
logic equivalence relation class structures 
say admits definable canonization exists ru canonization function 
domain structures say admits definable canonization vocabulary say admits definable canonization 
example 
definable canonization versus definability order admits definable linear orders closed order operations admits definable canonization 
obvious formula parameters may define structure family ordered expansions expansions compared lexicographic order encodings 
closed order operations minimal expansion respect lexicographical order definable gives definable canonization 
note exist definable cases order definable 
consider instance class finite directed paths pn lq take double graphs cf 
section graphs pn 
class order definable logic finite number parameters see exercise 
class admits dtc definable canonization 
explain construction uniform informally 
obvious equivalence relation re iff order definable interpretable 
nodes definable cn directed cycle distinguished point interpretable 
suffices show ordered copy interpretable 
represent nodes edges inverse edges cn node represented pair node pair 
order pairs domain formula interpretation pn cn exy 
difficult see edge relation linear order definable dtc operators 
details left reader 
simple interesting example definable canonization tree canonization fixed point logic counting 
proposition 
class directed trees admits ifp definable canonization 
proof 
interpretation construct maps tree nodes ordered tree tl natural order 
dimensional maps nodes numbers defined formulae formula explicitly construct 
construction inductively defined ternary relation tl encodes sequence binary relations fv 
node tv denote subtree root graph tl fv 
construction ensure sv isomorphic tv 
leaf fv 
suppose children vl vm graphs vl vm constructed 
define compute code words wi code vi natural order arrange lexicographic order 
graph nodes obtained copy vi smallest codeword copy second adding node connected roots copies obviously determines fv clear inductive construction done ifp formula bf 
take te 
theorem 
domain finite structures logic captures ptime proof 
polynomial time decidable model class formula defining 
interpretation defines canonization 
interpretation lemma captures ptime 
result important shown particular number interesting domains admit canonization fixed point logic counting ifp 
domain finite labelled trees see proposition 
class planar graphs generally domain structures gaifman graphs embeddable fixed surface 
domain structures bounded tree width 
corollary 
ifp captures ptime domains 
results extend domains reduced mentioned ones simple definable operations adding deleting vertex edge 
example called nearly planar apex graphs planar vertex removed 
capturing ptime bisimulation mathematics consider isomorphic structures identical 
goes saying relevant mathematical notions distinguish isomorphic objects 
classical algorithmic devices ordered representations structures structures capturing results rely ability reason canonical ordered representations isomorphism classes finite structures 
application domains logic structures distinguished coarser equivalences isomorphism 
best known example mod computational behaviour concurrent programs transition systems 
meaning program usually captured unique transition system 
transition systems distinguished appropriate notions equivalence important bisimulation 
context idea logic capturing ptime gets new twist 
express logic precisely properties structures decidable polynomial time invariant notion equivalence studied 
look specific problem context problem properties transition systems 
definition 
consider transition systems ea aca pb ea aea beb vocabulary 
bisimulation non empty relation respecting sense iff satisfying back forth conditions 
forth ea back exists ea rooted transition system pair transition system node rooted transition systems bisimilar denoted bisimulation exercise 
bisimulation greatest fixed point 
prove nodes transition system bisimilar gfp rxy 
px bb vx 

rx aa vy 

rx 
aa class rooted transition systems invariant bisimulation say rooted transition systems bisimulation invariant ptime invariant bisimulation exists polynomial time algorithm deciding pair belongs logic invariant bisimulation definable properties rooted transition systems 
exercise 
prove ml modal calculus infinitary modal logic ml invariant bisimulation 
clearly lu bisimulation invariant ptime 
pointed section lu far weak capture class mainly essentially monadic logic 
consider multi dimensional variant lu 
define logic explain main technical step relies definable canonization course respect bisimulation isomorphism 
simplicity notation consider transition systems single transition relation extension case transition relations ea completely straightforward 
rooted transition system pb associate new transition system set equivalence classes nodes reachable formally denote bisimulation equivalence class node path iv shown exercise pair isomorphism canonical bisimulation equivalence class exercise 
prove iv 
follows class rooted transition systems bisimulation invariant 
domain canonical finite transition systems crc 
proposition 
admits lfp definable linear orderings 
proof 
show vocabulary pb exists formula lfp defines linear order transition system recall bisimulation equivalence transition system greatest fixed point 
complement bisimulation fixed point limit increasing sequence defined follows atomic type exists nodes property pb 
sets classes reachable step respectively different 
idea refine inductive process defining relations classes 
transition system relations pre orders 
inductive limit bisimulation equivalence classes 
transition systems bisimulation classes element precise choose order define atomic types respect propositions pb sequel taken abbreviation similarly define condition set classes reachable lexicographically smaller set classes reachable note inductive definition monotone directly captured lfp formula 
know lfp ifp ifp formula 
explicitly defined ifp 
sy vx exercise 
complete proof showing formula 
defines order described 
corollary 
domain lfp captures ptime 
fact result suffices give capturing result bisimulation invariant ptime sense section composing map rooted transition system canonical lfp queries obtain logic recursive syntax polynomial time semantics describes precisely polynomial time computable bisimulation invariant queries rooted transition systems 
situations polynomial time arbitrary finite structures quite happy capturing result 
bisimulation invariant scenario better capture ptime terms natural logic multi dimensional calculus transition 
syntax dimensional calculus terns pb syntax usual calculus modal operators substitution 
set substitutions 
semantics different 
formula interpreted transition systems pb node evaluating formula modified transition system ei pb bb node 
ei vi wi vj wj forj wi vi iff 
multi dimensional calculus 
evaluating formula single nodes evaluate tuples nodes iff example 
bisimulation definable sense just 

pb pb 
transition system vl iff vl bisimilar exists point reachable path length bisimilar exercise 
prove invariant bisimulation 
show embedded lfp 
exercise establishes easy direction desired result ptime 
converse suffices show lfp equivalent domain class rooted transition systems bisimulation invariant ptime 
canonical lfp equivalent exists formula iff bisimulation invariance follows iff proposition 
domain lfp precisely formula xx xk lfp width exists formula lk nae note ultimately interested formula just free variable need general formulae evaluation formulae tuples nodes inductive treatment 
formulae xl free variable interpret xl root transition system 
obvious modification formula exercise express xi xj atomic formula translated lfp xi xj xi xj pb boolean connectives treated obvious way quantifiers translated fixed points 
find witness xj satisfying formula start set xj xx search transitions expression reachability 
substitution maps fixes indices translate ty 
fixed points brought normal form variables appear right order translated literally lfp 
translates 
proof translation desired property induction leave exercise see details 
altogether established result 
theorem otto 
multi dimensional calculus captures bisimulation invariant ptime 
otto established capturing results respect equivalences 
finite structures say order sentence width distinguish similarly order sentences width counting quantifiers form ix theorem otto 
exist logics effectively capture invariant ptime invariant ptime class finite structures 
details see 
logic ptime 
discuss problem ptime captured domain finite structures need precise notion logic refine notion logic capturing complexity class exclude pathological examples due gurevich 
example 
syntax logic consist pairs turing machine natural number 
finite structure model exists model class fin accepts encoding code finite structure time ibi note logic captures ptime finite structures 
example pathological mainly due unusual format semantics effective undecidable turing machine accepts isomorphism closed class structures 
example kind order invariant lfp 
sentences logic lfp sentences vocabulary finite structures linear orders defines syntax 
semantics obvious structure model linear orders 
logic captures ptime undesirable feature undecidable sentence lfp order invariant compare exercise logic effective syntax 
start defining general notion logic finite structures imposing requirements effective syntax isomorphism invariant semantics 
definition 
logic domain finite structures pair function assigns vocabulary decidable set elements called sentences binary relation sentences finite structures sentence class closed isomorphism 
recall definition logic captures ptime domain polynomial time decidable model class definable logic sentence logic model checking problem solved polynomial time 
exclude pathological examples impose addition sentence polynomial time model checking algorithm effectively constructed 
definition 
logic effectively captures ptime domain finite structures captures ptime sense definition exists computable function associating sentence algorithm polynomial decides time 
simply say effectively captures ptime class finite structures 
definition modified obvious way complexity classes 
capturing results proved far effective sense 
exercise 
complexity class recursively indexable domain recursive index set computable function mapping code turing machine mi appropriate bound polynomial bounding running time mi class structures accepted mi mi bound witnesses membership ii model class domain mi decides 
prove logic effectively capturing domain recursively indexable definition logic may practical purposes 
justified equivalence recursive indexings described exercise result dawar showing logic effectively captures ptime exists natural 
precisely dawar proved logic effectively capturing ptime extract model class complete ptime order reductions 
consequence ptime effectively captured logic fo adjoining fo vectorized quantifiers associated see information 
exercise 
finite model theorists conjecture logic effectively capturing ptime finite structures 
prove may win dollars 

computational model theory finite structures long time descriptive complexity theory concerned exclusively finite structures 
important problems remain open relationship definability complexity finite structures fairly understood interesting connections fields databases knowledge representation computer aided verification 
applications strict limitation finite structures restrictive 
fields mentioned considerable efforts extend relevant methodology finite structures suitable domains infinite ones 
particular case databases computer aided verification infinite structures constraint databases transition systems infinite state spaces increasing importance 
finite model theory generalized comprehensive computational model theory extends research programme general approach methods finite model theory interesting domains infinite structures 
general theoretical point view may ask domains infinite structures suitable extension 
specifically conditions satisfied domain necessarily finite structures approach methods finite model theory sense 
obvious fundamental conditions finite representations 
structure representable finite way binary string algorithm collection automata axiomatization logic interpretation 
effective semantics 
relevant logics considered order logic model checking problem decidable 
sentence representation structure decidable just minimal requirements may need refined context questions considered 
may instance require closure 
structure formula expansion relation defined belongs 
effective query evaluation 
suppose fixed way representing structures 
representation formula able compute representation expanded structure 
note contrary case finite structures query evaluation necessarily reduce model checking 
just effectiveness tasks may required performed complexity bounds 
finitely presentable structures briefly survey domains infinite finitely presentable structures may relevant computational model theory 
discuss detailed way metafinite structures descriptive complexity issues studied 
recursire structures countable structures functions relations com finitely presentable 
studied quite intensively model theory see 
recursive model theory different finite model theory papers studying classical issues finite model theory recursive structures recursive databases 
applications domain recursive structures far large 
general quantifier free formulae admit effective evaluation algorithms 
constraint databases modern database model admitting infinite relations finitely quantifier free formulae constraints fixed background structure 
example store geometrical data useful just finite set universe database include real numbers background 
presence interpreted functions addition multiplication desirable 
constraint database framework introduced kanellakis kuper revesz meets requirements 
formally constraint database consists context structure set tm quantifier free formulae defining database relations 
constraint databases treated detail 
automatic structures structures functions relations represented finite automata 
informally relational structure rm automatic find regular language provides names elements function mapping word element represents 
function surjective element named need injective elements name 
addition recognisable finite automata reading input words synchronously words name elements relation ri tuple words names tuple ri 
example 
finite structures automatic 
important examples automatic structures presburger arithmetic lt expansions lt ip relation ip saying power ofp dividing ary encodings starting significant digit construct automata recognizing equality addition consider tree structure tree 
eri el eri xi means xz el means equal length 
obviously structures automatic 
automatic structures provide vast playground finite model theorists examples high relevance computer science 
interesting connections computational group theory automatic groups studied quite intensively 
general notion structures presentable automata proposed theory developed :10.1.1.32.9967
notion automatic structure modified generalised directions 
automata infinite words obtain notion automatic structures contrary automatic structures may uncountable cardinality 
example 
automatic structures automatic 
group reals expanded structure rp ip automatic lp pn andy tree structures tree extend natural way uncountable automatic structures tree 
el 
contrary class recursive structures automatic structures admit effective fact automatic evaluation order queries possess pleasant algorithmic properties 
fo denote extension order logic quantifier exist infinitely 
automata theoretic arguments get result 
theorem 
model checking problem fo domain cv automatic structures decidable 
model theoretic characterisations automatic automatic struc tures terms interpretations appropriate expansions presburger arithmetic trees additive group reals see examples 
write pa fo denote exists order interpretation pa note domains automatic automatic structures closed fist order interpretations 
theorem 
structure pa equivalent 
pa automatic 
ii pa ro 
iii pa ro tree 
structure pa equivalent 
pa automatic 
ii pa ro 
iii pa ro tree 
proof see 
similar characterisations tree automatic structures 
results automatic structures see 
model theoretic characterisations automatic automatic structures terms interpretability suggest general way obtaining domains infinite structures may interesting computational model theory fix structure pa nice algorithmic model theoretic properties appropriate notion interpretation consider class structures interpretable pa ously structure class finitely presentable interpretation 
nice properties preserved interpretations structure class inherits pa particular class queries effective pa closed order operations effective closure pa order interpretations 
approach relevant domain structures discuss 
tree interpretable structures structures interpretable infinite bi nary tree dimensional mso interpretation 
theorem second order formulae effectively evaluated 
mso closed dimensional interpretations interpretation lemma implies tree interpretable structures admit effective evaluation mso 
tree interpretable structures generalize various notions infinite graphs studied logic automata theory verification 
examples context free graphs con figuration graphs pushdown automata hr equational vr equational graphs defined certain graph grammars prefix recognisable graphs instance defined graphs form ea aca regular language edge relation ea finite union sets xy xz regular languages fact established series papers classes coincide tree interpretable graphs see 
theorem 
graph ea aca equivalent 
tree interpretable 
ii vr equational 
iii prefix recognizable 
iv restriction regular set configuration graph pushdown au transitions 
side classes context free graphs hr equational graphs strictly contained class tree interpretable graphs 
exercise 
prove tree interpretable structure automatic 
converse true 
question arises powerful domains tree interpretable structures monadic second order logic effective 
interesting way obtain domains tree constructions associate structure kind tree unravelling 
simple variant unfolding labelled graph node tree 
courcelle walukiewicz show mso theory effectively computed mso theory 
general operation applicable relational structures kind invented muchnik 
relational structure rm iteration pa son clone structure universe relations wal war successor relation son wa predicate clone consisting elements form 
difficult see unfoldings graphs order interpretable iterations 
theorem states monadic theory pa decidable monadic theory proofs see 
define domain tree constructible structures closure domain finite structures dimensional mso interpretations iterations 
theorem effective mso model checking preserved interpretations tree constructible structures finitely presentable admit effective evaluation mso formulae 
results algebraic tree tree constructible 
algebraic trees tree interpretable follows domain tree constructible structures forms proper extension tree interpretable ones 
metafinite structures 
class infinite structures descriptive complexity theory studied intensively metafinite structures proposed gurevich studied :10.1.1.32.9670
structures somewhat reminiscent sorted structures define fixed point logic counting ifp 
second sort finite linear order 
metafinite structures similar structures essential differences numerical sort need finite structures may contain functions second sort general operations counting considered 
definition 
simple metafinite structure triple pa consisting finite structure ii finite infinite structure called secondary numerical part 
assume contains distinguished elements true false iii finite set functions vocabulary triple ra rr rw set relation function symbols corresponding component 
consider constants functions arity 
distinguished elements named constants example 
structures descriptive complexity theory real numbers developed meer see sect :10.1.1.32.9670
lt structures simple metafinite structure secondary part subtraction division primitive operations assume element named constant cr rational function quotient polynomials written term 
variations metafinite structures 
important metafinite structures multiset operations 
function defines multiset mult notation indicates may multiple occurrences element 
set fm denote class finite multisets metafinite structures consider secondary part just order structure usual sense comes collection multiset operations fm mapping finite multisets elements natural examples say real numbers addition multiplication counting mean maximum minimum 
multiset operation clearer introduce logics metafinite structures 
just multiset operations natural way precise notion re ates database query languages sql 
example 
arithmetical particular interest metafinite structures secondary part structure natural numbers includes constants functions ordering relation multiset operations max rain suture product 
functions relations multiset operations evaluated polynomial time 
call metafinite structures kind arithmetical 
simple arithmetical structure obtained arithmetical structure omitting multiset operations 
notion metafinite structures revolutionary just special kind sorted structures 
interest metafinite model theory just structures logics access primary secondary part different ways designed approach methods finite model theory remain meaningful applicable 
important feature logics contain formulae terms usual sense calculus wei ht terms primary secondary part 
definition 
logics finite structures fo lfp 
described previous sections vocabulary metafinite structures may may names multiset operations 
appropriate modification reasoning metafinite structures fit vocabulary defined follows 
fix countable set xl 
variables ranging elements primary part 
point terms defining functions weight terms defining functions formulae defining relations defined inductively follows 
point terms defined usual way closing set variables application function symbols weight terms built applying weight function symbols point terms function symbols previously defined weight terms 
note variables ranging atomic formulae equalities point terms equalities weight terms expressions pt tr relations symbols point terms tl tr expressions fr predicates weight terms fl ft 
rules building formulae propositional connectives quantifiers operators may applied account variables may 
addition characteristic function rule formula weight term 
case contains multiset operations provide additional means building new weight terms weight term formula free variables multiset operation 
expression weight term free variables 
true simplify notation rf semantics obvious 
term evaluates true 
weight term formed application multiset operation 
weight term defines metafinite structure fit function fixed tuple collection values ranges tuples true forms finite multiset 
interpretation obtained applying multiset example 
binary representations consider arithmetic structures primary part form unary relation 
interpreted bit sequence un representing natural number ui ui iff 
number represented definable term example 
counting elements arithmetic structures order logic count 
formula weight term counting number tuples true 
metafinite spectra descriptive complexity theory generalize meaningful way finite structures 
give evidence generalizations possible fruitful focus generalizations theorem arithmetical structures structures see examples 
recall theorem says generalized spectra equivalently properties finite structures definable existential second order logic coincide complexity class np 
discuss possible translations metafinite structures need precise notions notion metafinite spectrum generalized spectrum metafinite structures 
notion complexity particular deterministic nondeterministic polynomial time context metafinite structures 
fixed structure denote class metafinite structures secondary part vocabulary course vocabulary 
start notions metafinite spectra 
definition 
class metafinite spectrum exists firstorder sentence vocabulary exists expansion 
note secondary part expanded 
primary metafinite spectrum defined similar way primary part structures expanded set weight functions 
means expanded structures set weight functions notions metafinite spectra correspond variants existential second order logic 
restrictive allows second order quantification primary relations general allows quantification weight func tions 
primary metafinite spectrum class structures models existential second order sentence form relation variables primary part order 
relations primary part replaced characteristic functions metafinite spectrum general sense class models sentence 
fmb fi function symbols ranging weight functions 
see notions metafinite spectra capture suitable variants nondeterministic polynomial time certain contexts fail 
general notion complexity problems metafinite depends computation model cost size associated elements secondary part 
instance secondary part consists natural numbers binary strings natural notion cost number bits 
side study complexity real numbers respect blum shub smale model element treated basic entity cost 
denote cost metafinite structure max cost maximal weight 
assuming fixed cost representing polynomially bounded max polynomial depends vocabulary 
popular complexity classes invariant polynomial increase relevant input parameters sense measure complexity terms maxg 
instance algorithm class metafinite structures runs polynomial time respectively logarithmic space input computation terminates max steps polynomial respectively uses log space 
discuss arithmetical structures described example assuming cost natural numbers length binary representations 
question circumstances np captured class metafinite spectra primary metafinite spectra 
original proof fagin theorem generalizes case arithmetical structures large weights 
definition 
class metafinite structures small weights exists max 
max stands cost largest weight means values weights bounded function polynomial obtain generalization fagin result 
theorem gurevich 
ff class arithmetical struc tures small weights closed isomorphisms 
equivalent np 
ii primary generalized spectrum 
proof 
obvious ii implies 
converse reduced theorem follows 
assume structure max ai suppose loss generality ordering available expand vocabulary binary relation add conjunct asserting linear order 
identify initial subset viewed bit positions binary representations weights 
associate finite structure expanding primary part follows weight function arity add new relation pw arity pw th bit 
ic np icy ty ic np set finite structures fact choose encodings way represented binary string 
ic np fagin theorem icy generalized spectrum defined order sentence example construct order sentence vocabulary consists weight functions corresponding primary relations expresses pw encode weight functions sense defined 
pac order sentence witnessing ic primary metafinite spectrum 
result holds arithmetical structures multiset operations 
restriction weights small longer true np set primary metafinite spectrum 
inputs huge weights compared primary part relations primary part code information describe computations bounded polynomial length weights 
tempting unrestricted metafinite spectra 
metafinite spectra general sense capture larger class np 
theorem gurevich 
arithmetical structures metafinite spectra cap ture sets 
sketch proof 
difficult show metafinite spectrum arithmetical structures recursively enumerable 
converse note tuple viewed arithmetical structure empty primary vocabulary nullary weight functions ak 
arithmetical relation viewed special class arithmetical structures 
shows recursively enumerable set metafinite spectrum 
particular exist undecidable metafinite spectra 
theorem see recursively enumerable set diophantine represented exists bl bm polynomial xl xk yl ym 

metafinite spectrum desired order sentence uses additional weight functions bl bm asserts 
extended class arithmetical structures arbitrary vo 
see encode structures tuples depends 
fact problem reduce 
similar case finite struc tures encoding involves selection linear order primary part 
fact convenient ranking primary part just linear ordering 
definition 
suppose contains copy structure bijection class ic ranked contains weight function interpretation ranking 
coding lemma arithmetical structures says vocabulary exists encoding function associating ranked arithmetical structure tuple code properties 
code definable order terms ii primary part weight functions reconstructed code polynomial time iii exists polynomial ci max fit recursively enumerable 
set code le icode ranking recursively enumerable diophantine 
desired order sentence uses symbols unary weight function nullary weight functions bl bm expresses ranking ii code suitable polynomial xl xk yl ym defining code 
descriptive complexity real numbers contexts metafinite spectra capture suitable notion nondeterministic polynomial time 
important example computations real numbers model blum shub smale 
computation blum shub introduced model computations real numbers rings usually called bss machine 
important difference say turing model real numbers treated basic entities arithmetic operations reals performed single step independently magnitude complexity involved numbers 
particular model abstracts problems actual computers real numbers approximated bit sequences complexity arithmetic operations depends length approximate representations rounding errors problem exact testing impossible practice 
similar notions computations arbitrary fields rings investigated earlier algebraic complexity theory see comprehensive treatment 
novelty approach blum shub model uniform input lengths notions explored algebraic complexity straight line programs arithmetic circuits decision trees typically non uniform 
main purposes bss approach create uniform complexity theory dealing problems having analytical topological background show certain problems remain hard arbitrary reals treated basic entities 
basic concepts fundamental results classical computability complexity theory reappear bss model existence universal machines classes np real analogues np existence np complete problems 
course notions appear different form strong analytic flavour typical examples undecidable recursively enumerable sets complements certain julia sets problem shown np complete question multivariate polynomial degree real root 
classical setting problems class np decidable single exponential time trivial classical case versus np question major open problems 
differences classical real complexity theory 
just mention note meaning space resources different certain separation results complexity classes established nc np exp analogues classical theory open discrete problems change complexity behaviour considered bss model 
detailed treatment refer interested reader book 
bss model 
equivalently set functions finitely call ixi max length note identified natural way concatenation 
blum shub smale machine sequel called bss machine essentially ram evaluate rational functions unit cost registers store arbitrary real numbers 
definition 
bss machine finite set instructions labelled input output spaces subsets 
configuration quadruple instruction currently executed numbers called copy registers see describes content registers machine 
input computation started configuration 
computation stops case value output computed machine 
instructions types computation instruction type performs update xo gk register gk rational function 
simultaneously copy registers may updated rules similarly registers remain unchanged 
instruction 
branch goto goto 
contents registers remain unchanged 
copy xw xr content read register copied 
instruction registers remain unchanged 
set exists bss machine running time bounded polynomial ixi accepts analogue np class np 
set np exists set constant tx ix 
equivalently np defined class problems decidable polynomial time nondeterministic bss machine bss machine nondeterministically guess real numbers unit cost 
encodings 
recall structures metafinite structures second sort cr rc 
want relate decision problems described logical formulae decision problems decided consider example 
example 
feasibility 
problem shown npr complete problem real polynomial degree unknowns varies input real zero 
problem considered decision problem structures follows 
coefficients homogeneous polynomial xn coded function 
obtain arbitrary necessarily homogenous polynomial xn degree setting multivariate polynomial degree represented structure observe viewed class structures primary part finite linear order decision problems regarded special case decision problems structures way words considered special cases finite structures 
conversely structures encoded 
choose ranking replace functions relations primary part characteristic functions ak gives structure primary part plain set functions xt form xi ranking functions xi represented tuple xo 
xm tm iai xi th tuple respect lexicographic order induced concatenation tuples gives encoding code depends ranking chosen 
obviously structures fixed finite signature length code bounded polynomial iyi depends signature 
view code single function xi basically means representing structure single function appropriate arity 
furthermore encoding order definable sense lemma 
signature order formula signature structures signature rankings functions ill coe 
case finite structures say class structures complexity class np set encodings recall metafinite spectrum structures set structures definable existential second order sentence sy 
syrup order variables range weight functions 
fagin theorem analogue real setting 
theorem meer 
class structures 
np metafinite spectrum 
proof 
easy see metafinite spectra np 
suppose 
input structure guess assignments functions evaluate 
yr polynomial time 
converse np corresponding problem 
polynomial time bss machine deciding natural number stops encodings tm steps uses tm registers 
suppose ranking available 
induced lexicographic ranking rm tm order definable identify element maximal rank number term available rm abbreviation tl tm tm 
identify tm initial subset tm 
formulae constructed tuples tl tm variables considered range natural numbers expressed order formulae vocabulary 
computation input code represented function follows 
instruction executed time indices read write registers time content register time construct order formula property ranked structures iff represents accepting computation code 
express time function encodes input ration 
need subformula stating values encode input 
lemma expressed order logic 
second ensure tm sequence tm represents configuration sequence values represents successor configuration 
formula asserting form describes transitions performed instruction consider example computation instruction xo xo xt assume addition increases index read register sets back index write register 
formula express instruction read register index increased write register index set back register writes result applying rational function register contents time 
registers remain unchanged 
clearly conditions order expressible 
noted number terms rational function number term 
example illustrating explicit embedding function consider copy instruction xw xr 
formula express update instruction number done content register time content register time expressed formula tm tm zg zg express accepts input just say tm convention result computation single number stored register 
combining subformulae appropriate way obtain desired formula follows structures proves theorem case ranked structures 
away assumption input structures ranked 
ranking input structures introduce existentially quantifying function adding conjunct asserts exists element 
follows example 
logical description feasibility 
second order sentence feasibility problem quantifies functions describes zero partial sum monomials lexicographical order 
feasibility problem described sentence sx sv ff ui polynomial degree defined real zero 
capturing results complexity classes 
combining general ideas complexity theory finite structures approach described finds characterisations complexity levels notably polynomial time provided structures ranked ordering finite part available 
carried detail 
am grateful comments corrections contributions dietmar achim dawar kolaitis stephan martin otto 
abiteboul vianu datalog extensions database queries updates journal computer system sciences pp 

abiteboul hull vianu foundations databases addison wesley 
andj 
structural complexity ii springer 
van benthem nmeti modal languages bounded fragments predicate logic journal philosophical logic pp 

arnold calculus north holland 
ash knight computable structures hierarchy elsevier 
das im der mit zeitschrift ffir mathematische logik und grundlagen der mathematik pp 

babai selkow random graph isomorphism siam computing pp 

equational simple graphs tech 
rep universit mainz institut ffir informatik 
benedikt libkin schwentick model theoretic approach regular string relations proc 
th ieee symp 
logic computer science pp 

monadic theory tree structures au logic infinite games gr del thomas wilke eds springer verlag 
appear 
blass gurevich existential fixed point logic computation theory logic ed lecture notes computer science nr 
springer pp 

blum shub smale complexity real computation springer 
blum shub smale theory computation complexity real numbers bulletin amer 
math 
society pp 

automatic structures 
diplomarbeit rwth aachen 
prefix recognisable graphs monadic second order logic tech 
rep aib rwth aachen 
gradel automatic structures proc 
th ieee symp 
logic computer science pp 

modal calculus alternation hierarchy strict theoretical computer science pp 

stirling modal logics mu calculi handbook process bergstra ponse smolka eds elsevier pp 

clausen shokrollahi algebraic complexity theory springer verlag 
cai immerman optimal lower bound number variables graph identification combinatorica pp 

infinite transition graphs having decidable monadic theory automata languages programming rd international colloquium icalp lecture notes computer science nr 
springer pp 

courcelle monadic second order logic graphs ii infinite graphs bounded width math 
system theory pp 

monadic second order logic graphs ix machines behaviours theoretical computer science pp 

courcelle walukiewicz monadic second order logic graph coverings unfoldings transition systems annals pure applied logic pp 

meer logic capture complexity classes reals journal symbolic logic pp 

dahlhaus skolem normal forms concerning fixed point computation theory logic ed lecture notes computer science springer verlag pp 

dawar generalized quantifiers logical journal logic computation pp 

dawar inflationary fixed points modal logic proceedings th annual conference european association computer science logic csl lecture notes computer science nr 
springer verlag pp 

dawar expressive power finitely generalized quantifiers information computation pp 

dowling gallier linear time algorithms testing satisfiability propositional horn formulae journal logic programming pp 

bounded variable fixpoint queries pspace complete th annual conference computer science logic csl 
selected papers lecture notes computer science nr 
springer pp 


ebbinghaus flum finite model theory springer nd edition ed 
ehrenfeucht positional strategies mean payoff games international journal game theory pp 

emerson jutla tree automata mu calculus determinacy proc 
nd ieee symp 
foundations computer science pp 

epstein cannon holt levy paterson thurston word processing groups jones bartlett publishers boston 
ershov goncharov nerode remmel handbook recursive mathematics north holland 
fagin generalised order spectra polynomial time recognizable sets complexity computation 
siam ams proceedings karp ed pp 

automatic groups guided tour pp 

gottlob gradel veith datalog lite deductive query language linear time model checking acm transactions computational logic pp 

gradel transitive closure logic proceedings th workshop computer science logic csl bern vol 
lncs springer verlag pp 

capturing complexity classes fragments second order logic theoretical computer science pp 

gr del gurevich metafinite model theory information computation pp 

gradel gurevich hirsch complexity query reliability th acm symposium principles database systems pods seattle acm press 
gr del jm laws recursive structures archive mathematical logic pp 

gr del power deterministic transitive closures information computation pp 

hierarchies transitive closure logic stratified datalog infinitary logic annals pure applied logic pp 

gr del meer descriptive complexity theory real numbers mathe numerical analysis real number algorithms renegar shub smale eds vol :10.1.1.32.9670
lectures applied mathematics ams pp 

gr del otto inductive definability counting finite structures com puter science logic th workshop csl san selected papers ger martini richter eds vol 
lncs springer verlag pp 

gr del otto logics variables theoretical computer science pp 

gr del thomas wilke eds automata logics infinite games lecture notes computer science nr 
springer 
greenlaw hoover ruzzo limits parallel computation :10.1.1.21.9642
completeness theory oxford university press 
fixed point logics planar graphs proc 
th ieee symp 
logic computer science pp 

isomorphism testing embeddable graphs definability proc 
nd acm symp 
theory computing pp 

marino definability descriptive complexity databases bounded tree width proceedings icdt vol 
lecture notes computer science springer pp 

gurevich logic challenge computer science current trends theoretical computer science ed computer science press pp 

harrington trees automata games proceedings th annual acm symposium theory computing stoc pp 

gurevich shelah fixed point extensions order logic annals pure applied logic pp 

harel theory recursive structures proceedings rd international symposium mathematical foundations computer science mfcs vol 
lecture notes computer science springer pp 

hirst harel recursive structures descriptive complexity zero laws proc 
th ieee symp 
logic computer science pp 

hodges model theory cambridge university press 
immerman relational queries computable polynomial time information control pp 

languages capture complexity classes siam journal computing pp 

itai mai journal logic programming pp 

janin calculus respect monadic second order logic proceedings th international conference concurrency theory concur lecture notes computer science springer verlag pp 

jones complete problems deterministic polynomial time theoretical computer science pp 

jones selman turing machines spectra order formulas journal symbolic logic pp 

deciding winner parity games information processing letters pp 

annual symposium theoretical aspects computer science proceedings vol 
lecture notes computer science springer pp 

kanellakis kuper revesz constraint query languages journal computer systems sciences pp 

extended appeared proceedings pods 
khoussainov nerode automatic presentations structures logic computational complexity vol 
lncs springer pp 

kolaitis expressive power stratified logic programs information computation pp 

expressive equivalence inflationary fixed point logic proceedings th ieee symp 
logic computer science lics pp 

kuper libkin paredaens eds constraint databases springer 
martin borel determinacy annals mathematics pp 

hilbert tenth problem mit press 
meer query languages real number databases descriptive complexity proc 
th international symposium mathematical foundations computer science mfcs lecture notes computer science nr 
springer pp 

moschovakis elementary induction structures north holland 
mostowski games forbidden positions tech 
rep tech 
report university 
muller schupp groups theory ends context free languages journal computer system sciences pp 

theory ends pushdown automata second order logic theoretical computer science pp 


otto bounded variable logics counting springer 
bisimulation invariant prime higher dimensional mu calculus theoretical computer science pp 

note expressive power prolog bulletin eatcs pp 

scholz ein problem der logik journal symbolic logic 
recursive model theory logic colloquium eds lecture notes logic springer pp 

finite automata formal logic circuit complexity boston 
thomas synthesis strategies games proceedings stacs lecture notes computer science nr 
springer verlag pp 

thomas languages automata logic handbook formal languages vol 
rozenberg salomaa eds springer pp 

complexity relational query languages proceedings th acm symposium theory computing pp 

complexity bounded variable queries proc 
th acm syrup 
principles database systems pp 

monadic second order logic tree structures theoretical computer science pp 

zielonka infinite games coloured graphs applications automata trees theoretical computer science pp 

alternating complexity classes alternating algorithms generalization nondeterministic algorithms games 
view nondeterministic algorithms restriction alternating algorithms solitaire player games 
complexity classes defined terms turing machines focus model alternating turing machines 
note alternating algorithms defined terms computation models 
definition 
alternating turing machine nondeterministic turing machine state set divided classes qv 
means existential universal accepting rejecting states 
states final states 
configuration called existential accepting rejecting state 
computation graph gm alternating turing machine input defined way nondeterministic turing machines 
nodes configurations instantaneous descriptions distinguished starting node input configuration edge configuration configuration successor configuration recall nondeterministic turing machines acceptance condition reachability problem accepts graph gm accepting configuration ca reachable 
alternating turing machines acceptance defined game problem see sect 
players called moving existential configurations universal ones 
wins accepting configurations loses rejecting ones 
definition accepts player winning strategy game gm complexity classes 
time space complexity defined nondeterministic turing machines 
function say alternating turing machine time bounded inputs computation paths terminate steps 
similarly space bounded configuration reachable uses cells space 
complexity classes atime aspace contain problems decidable respectively time bounded space bounded alternating turing machines 
classes particular interest aspace logn atime nd ace ue ace alternating versus deterministic complexity 
general slogan parallel time complexity coincides sequential space complexity 
standard techniques complexity theory easily shows nicely behaved space constructible functions atime dspace dspace atime see details 
particular pspace 
expspace 
side alternating space complexity corresponds exponential deterministic time complexity 
theorem 
space constructible function log aspace dtime 
proof 
proof closely associated game problem 
space bounded alternating turing machine input construct time computation graph gm solve game problem order decide acceptance converse show constant dtime aspace log 
dtime 
deterministic tape turing machine deciding time 


configuration computation input length described word wo wi wi wt 
ith symbol successor configuration depends symbols positions 
function fx symbols positions configuration symbol fx position successor configuration alternating algorithm decides input existential step guess guess existential step guess verify fm ao reject 
universal step choose od ith symbol input configuration equals accept reject 
algorithm needs space log 
accepts input player winning strategy game ca value chosen time accepts chosen configuration time form wi wi wt 
jth iteration loop configuration symbols positions configuration time chosen conversely accept input ith symbol configuration time 
holds player chooses ao th symbol configuration differs ak 
player chooses exactly ak different ith symbol input configuration player wins 
accepts 
particular follows ptime exptime 
relationship major alternating complexity classes summarized diagram 
logspace ptime alternating logarithmic time 
pspace exptime expspace 

time bounds alternating turing machines needs modified little indirect access mechanism 
machine writes binary address separate index tape access th symbol input 
model sense define instance complexity class atime 
example 
construct algorithm set palindromes words read right left left right 
important examples problems model checking problem propositional logic data complexity order logic 
results mentioned relating alternating time sequential space hold logarithmic time space bounds 
note imply logspace due quadratic overheads 
known logspace converse inclusion open problem 

