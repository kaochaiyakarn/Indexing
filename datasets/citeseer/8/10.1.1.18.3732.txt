formal language constrained path problems chris barrett jacob marathe 
alphabet directed graph edges weighted labeled formal language formal language constrained shortest simple path problem consists nding shortest simple path complying additional constraint denotes unique word concatenating labels edges path main contributions include 
show formal language constrained shortest path problem solvable eciently polynomial time restricted context free language 
speci ed regular language provide algorithms improved space time bounds 

contrast show problem nding simple paths source destination np hard restricted xed simple regular languages simple classes graphs complete grids 

class treewidth bounded graphs show problem nding regular language constrained simple path source destination solvable polynomial time ii extension nding context free language constrained simple paths np complete 
results extend previous results mw ya 
additional extensions applications results context transportation problems 
instance corollary results obtain polynomial time algorithm best similar path problem studied 
previous best algorithm takes exponential time worst case 
key words 
algorithms formal languages computational complexity transportation planning world wide web shortest paths query processing multi criteria problems 
ams subject classi cations 


path nding problems arising diverse areas certain patterns edge vertex labels labeled graph traversed allowed preferred disallowed 
feasibility path determined length cost known measures graphs distance ii associated label 
acceptable label patterns speci ed formal language 
example transportation systems mode options traveler go source destination mode selection destination patterns itinerary route seek optimize speci ed formal language 
problem nding label constrained paths arises application areas production distribution network vlsi design databases queries mw amm study problem nding shortest simple paths network subject certain formal language constraints labels paths obtained 
illustrate type problems studied discussing prototypical application areas 
route planning 
initial interest problem studied came transims project los email lanl gov los alamos national laboratory box ms los alamos nm 
research supported department energy contract eng 
email brics dk 
brics basic research computer science center danish research foundation 
department computer science university aarhus ny munkegade bg dk denmark 
done staying los alamos national laboratory 
transims acronym transportation analysis simulation system 
see transims lanl gov details 
barrett jacob marathe os national laboratory 
refer reader tr ab tr detailed description project 
part route planning module transims goal nd feasible near optimal paths travelers network network mode choices train car subject certain mode choice constraints 
mode choices traveler obtained processing data module certain statistical models built real life survey data 
refer reader book ben akiva lerman bal detailed discussion theory discrete choice analysis applied transportation science 
example illustrates prototypical problem arising context 
example directed labeled weighted graph graph represents transportation network labels edges representing various modal attributes label represent rail line 
suppose wish nd shortest route traveler 
ubiquitous shortest path problem 
told traveler wants go modal choices walks train station uses trains walks destination oce go way home oce car 
represent trains represent walking represent car travelers mode choice speci ed denote usual operators describe regular languages 

searching web 
browsing web nd documents interest searching database queries interpreted graph traversals certain graph 
viewpoint views web database directed undirected labeled graph nodes url sites text edges hyperlinks 
query nding particular url site instance proceeds browsing network links searching sending information retrieval requests index servers 
serious problem arises context pattern matching search engines queries exploit topology document network 
example pointed ha content search ignores structure hypermedia network 
contrast structure search speci cally examines hypermedia structure subnetworks match pattern 
refer reader mw amm ha thorough discussion topic 
abiteboul vianu av discusses regular expression constrained path queries query web 
example essentially amm :10.1.1.12.678
example graph describing hypertext document 
suppose want search job opportunities software engineers 
rst query index server nd pages mention keywords employment job opportunities pages follow local paths length zero nd pages contain keywords software engineer 
state problem nding labeled paths constraints admissible labelings 
refer amm number additional interesting queries formulated framework :10.1.1.12.678

problem formulation 
problems discussed examples formally described follows un directed graph 
edge attributes 
denotes label edge label drawn xed nite alphabet 
attribute denotes formal language constrained path problems weight edge 
assume weights non negative integers 
positive results fact extended handle negative edge weights negative cycles 
path length sequence edges path simple vertices path distinct 
path weight path label de ned 


words label path obtained concatenating labels edges path natural order 
denote weight label respectively 
definition 
formal language constrained shortest path un directed labeled weighted graph source destination formal language regular context free context sensitive nd shortest necessarily simple path definition 
formal language constrained simple path un directed labeled weighted graph source destination formal language regular context free context sensitive nd shortest simple path rest denote formal language constrained shortest path problem restricted regular context free context sensitive languages reg shp cfg shp csg shp respectively 
similarly denote formal language constrained simple path problem restricted regular context free context sensitive languages reg sip cfg sip csg sip respectively 
general consider input problems consist description graph including labeling weights description formal language grammar 
restricting topology graph syntactic structure grammar get modi cations problems 
claim statement true xed language refer variant problem input consists graph language considered part problem speci cation 
note unlabeled networks non negative edge weights shortest path necessarily simple 
need true wish nd shortest path subject additional constraints set allowable labels 
simple example consider graph simple cycle nodes 
edges weight label consider adjacent vertices shortest path consists single edge contrast shortest path label aaaaa consists cycle starting additional edge 

summary results 
investigate problem formal language constrained path problems 
number variants problem considered polynomial time algorithms hardness results np pspace hardness undecidability proved 
np hardness results obtained combining simplicity path constraints imposed formal language 
believe techniques prove results independent interest 
main results obtained summarized include 
show cfg shp polynomial time algorithm 
reg shp operators 
give polynomial time algorithms substantially ecient terms time space 
polynomial time solvability holds reg shp problem underlying regular expressions composed barrett jacob marathe 
operators 
observe extension regular expressions operators 
pspace hard 

contrast results shortest paths show problem nding simple paths source destination np hard restricted simple xed locally testable regular language see section details simple graphs undirected grid graphs 

contrast results show class treewidth bounded graphs reg sip solvable polynomial time ii cfg sip problem np complete xed deterministic linear context free language 
easiness proof extended way log space recognizable languages 
uses dynamic programming method tables turn quite intricate 

investigate complexity problems csg shp 
simple reductions contrast complexity results show csg sip pspace complete ii csg shp undecidable xed language 

application theory developed provide polynomial time algorithm number basic problems transportation science 
section consider examples best similar path trip chaining problem 
results mentioned provide tight bound computational complexity versus 
np problems considered assumptions inclusions classes formal languages nite locally testable regular deterministic linear context free tight natural class languages classes 
furthermore grid graphs considered easiest class graphs bounded treewidth 
preliminary versions algorithms outlined incorporated route planning module transims 
jmn conduct extensive empirical analysis basic route nding algorithms realistic trac network 

related 
refer reader monograph hu comprehensive survey path problems 
tr ab tr provide detailed account transims project 
regular expression constrained simple path problems considered mendelzon wood mw 
authors investigate problem context nding ecient algorithms processing database queries see mw 
abiteboul vianu describes results related problems av 
yannakakis ya keynote talk independently outlined polynomial time algorithms section 
ro independently considered problems discussed section 
emphasis ya database theory ro considered regular languages 
online algorithms regular path nding 
nding formal language constrained shortest paths related ramalingam reps rr 
authors interested nding minimum cost derivation terminal string non terminals context free grammar 
problem rst considered knuth ku referred grammar problem 
rr give incremental algorithm version grammar problem operator simple stands square operator 
denotes 
formal language constrained path problems word recognition shortest path general graph simple path treewidth bound simple path grid graph xed nite fp fp fp fp free nite fp fp fp np 
xed lt fp fp fp np 
free rl fp fp fp np 
log tm fp undec fp np 
lin 
det cfl fp fp np 
np 
free cfl fp fp np 
np 
xed csl pspace 
undec 
pspace 
pspace 
section theorem section section section theorem section theorem 
fig 

summary results formal language constrained simple shortest paths contrast word recognition problems 
lt rl cfl csl denote locally testable regular context free context sensitive languages respectively 
regular languages time bounds hold regular expressions operators 

fp states problem computed deterministic polynomial time language speci cation part input 
superscripts table corresponding text tell result proven 
corollaries obtain incremental algorithms single source shortest path problems positive edge weights 
close section additional remarks 
knowledge rst attempt formal language theory context modeling mode route choices transportation science 

polynomial time algorithms hardness results give boundary classes graphs queries polynomial time query evaluation possible 
mw authors state additional classes queries polynomial time evaluation possible identi ed results signi cantly extend known hardness easiness results mw nding regular expression constrained simple paths 
example graph theoretic restriction considered mw acyclicity 
positive side polynomial time algorithms regular expression constrained simple path problem restricted graphs bounded treewidth step characterizing graph classes problem easy 
speci cally shows graphs xed size recursive separators problems easy 
examples graphs cast framework include chordal graphs xed clique size outer planar graphs series parallel graphs 
see bo examples 

basic techniques extend quite easily appropriate time performance bounds solve regular expression constrained variants shortest path problems 
notable examples frequently arise transportation science solved multiple cost shortest paths ha ii time dependent shortest paths 
extensions brie outlined section 
rest organized follows 
section contains preliminary results basic de nitions 
section ecient algorithms grammar constrained shortest path problems reg shp cfg shp 
section barrett jacob marathe contains hardness easiness results simple paths 
section outlines extensions applications basic results 

basic de nitions 
recall basic concepts formal language graph theory 
additional basic de nitions topics related hu gj ahu clr 
rest ji denote size object represented binary notation 
definition 
nite alphabet disjoint 
regular expression de ned follows 
empty string empty set atomic regular expressions 

regular expressions 
compound regular expressions 
definition 
regular expression language set de ned denoted de ned follows 

fag 





definition 
nondeterministic nite automaton nfa tuple 
nite nonempty set states 
input alphabet nite nonempty set letters 
state transition function power set 
initial state 
set accepting states 
nonempty subset automaton said transitions 
transitions set element regarded partial function said deterministic nite automaton dfa 
extended transition function de ned standard manner 
size denoted jm de ned equal definition 
nfa 
language accepted denoted set string said accepted automaton 
definition 
context free grammar cfg quadruple disjoint nonempty sets nonterminals terminals respectively nite set productions start symbol 
cfg said linear nonterminal appears right hand side productions 
definition 
bo graph 
tree decomposition pair fx ig fx ig family subsets tree properties 

edge subset 
lies path formal language constrained path problems treewidth tree decomposition fx ig max jx 
treewidth minimum treewidth tree decomposition 

shortest paths 
section polynomial time algorithms problems reg shp cfg shp 

algorithm reg shp extensions 
subsection describe algorithms regular expression constrained shortest path problems 
note regular expressions 
transformed equivalent nfas time ahu represents size regular expression 
rest subsection assume regular expressions speci ed terms equivalent nfa 
basic idea nding shortest paths satisfying regular expressions construct auxiliary graph product graph combining nfa denoting regular expression underlying graph 
formalize notation 
definition 
labeled directed graph source destination de ne nfa follows 
fdg 
set labels label edges 
edge label note de nition interpret nfa labeled graph 
definition 
nfas 
product nfa de ned 
clear 
algorithm re paths outlines basic steps solving problem uses cross product construction mentioned 
algorithm re constrained short paths input regular expression directed labeled weighted graph source destination 
construct nfa 
construct nfa 
construct 
length edges product graph chosen equal corresponding edges 
starting state nd shortest path vertices denote paths denote cost 
min 
uniquely determined choose arbitrary 
output path minimum length subject constraint 
theorem 
algorithm re constrained short paths computes exact solution problem reg shp non negative edge weights time 
denotes running time shortest path algorithm graph nodes 
barrett jacob marathe proof 
correctness algorithm observe consider shortest path cost satis es regular expression path accepting sequence states nfa imply path cost know sought path considered 
conversely path cost begins starting state ends nal state projection nodes yields path cost satis es regular expression calculate running time algorithm observe size 
running time dominated step obtain bound 

extensions regular expressions 
consider possible extensions problem reg shp allowing additional operators complement squaring expression 
theorem 
shortest path complement nfa regular expression 
pspace hard 
proof 
regular expression 
question deciding complement empty regular expression non universality known pspace complete 
gj problems 
instance problem create graph node loop symbol alphabet 
existence path label complement language equivalent existence word 
immediately implies corollary 
reg shp regular expressions 
pspace hard 
easy see regular expressions consisting operators 
represented context free grammars rules form bb 
observation results section section yields corollary 
reg shp regular expressions 
solved polynomial time 

algorithm cfg shp 
extend results section obtain polynomial time algorithms context free language constrained shortest path problems 
applicability algorithm result stands contrast hardness simple path problems single xed regular expression 
algorithm solving context free grammar constrained shortest paths dynamic programming 
rst investigate structure optimal shortest path graph labeled context free grammar assume chomsky normal form rules form ab see hu details 
consider shortest path am important property cfg nonterminals expanded independently 
case chomsky normal form derivation forms binary tree means label decomposed parts ab structure mind de ne quantity shortest path distance subject constraint label path derived starting nonterminal formal language constrained path problems values de ned ful ll recurrence min bc min 
observation 
equations uniquely determine function immediately imply polynomial time dynamic programming algorithm 
proof 
consider case satisfy recurrence di erent 
smallest witness fact assume consider smallest de nition unambiguous know nonterminal 
minimal nite satis es 
implies exist witnesses establish sum 
lengths graph positive smaller choice know implying contradiction discussion immediately implies dynamic programming approach compute table starting values links network ll table increasing values 
done bellman ford type algorithm 
algorithm nally set entry table round 
execution time bound square number entries table times amount time needed compute minima 
polynomial jv jn jrj vertices graph nonterminals rules grammar chomsky normal form 
way implementing set table lling smallest values rst 
heap hold current estimates entries smallest nally put table generating changing estimates 
implies entry extract min operation jv update operations 
fibonacci heaps see clr analysis sums jv jn 
log jv jn jv jv jn 
naive adaptation floyd warshall type algorithm fails split optimal path optimal arbitrary node path 
splitting dynamic programming works done accordance grammar 

simple paths 
investigate complexity nding formal language constrained simple paths 
ease exposition results directed graphs 
lemma shows extend results undirected graphs 
lemma 

reg sip directed grids reduced reg sip directed grids 

reg sip directed grids reduced reg sip undirected grids 

cfg sip directed graphs treewidth reduced cfg sip undirected graphs treewidth 
proof 
applying changes illustrated nodes grid obtain grid part grid roughly times larger original 
furthermore alphabet needs extended barrett jacob marathe symbols inaccessible edges symbol edges inside extended nodes 
fig 

example replacing multi labels 
dotted edges inside labeled connection right completely depicted 
regular language replaced regular language de ned follows fvg 
xn 
xn paths new instance correspondence paths original instance 
known see example hu regular context free languages closed substitution 
fa zg alphabet 
fa marked copy alphabet 
substitution homomorphism 
aa yields regular language jw 

xn regular 
original graph 
directed edges labeled get replaced consecutive edges labeled introducing new node 
situation paths complying correspondence paths complying straightforward extend weight function edges preserve weights paths 
additionally relative path length number edges preserved 
proof follows fact resulting embedded grid new symbol label 
tree decomposition treewidth graph tree replacing edges paths length change treewidth 
tree decomposition width 
new node create new set tree decomposition consisting new node endpoints edge splits 
set included tree decomposition attaching set covered split edge 
sets cardinality change treewidth yielding new tree decomposition width 
finite languages 
definition 
language called nite nitely words finite languages considered smallest subclasses regular languages 
formal language constrained path problems theorem 
xed nite language problem reg sip solved polynomial time 
proof 
maximum length word considering tuples nodes checking form sought path yields polynomial time algorithm running time 
theorem 
graph class planar grid hamiltonian path problem np hard restricted problem reg sip np hard restricted free nite languages 
proof 
consider xed class graphs hamiltonian path problem np hard 
instance hamiltonian path problem nodes construct instance regular expression constrained simple path problem labeling edges claim hamiltonian path simple path satis es constraining language chosen nite language fa 
hardness reg sip 
formally stating theorem proof idea 
perform reduction sat 
easy verify reduction carried polynomial time logarithmic space 
encoding satis ability question naturally decomposes parts 
rst choose assignment second check assignment satis es formula 
choosing assignment correspond choosing certain part path 
cnf formula checked clause clause 
requires access value variable 
achieved forcing suciently subpaths similar sense stand assignment 
copies assignment check underlying assignment satis es cnf formula 
local task copy assignment clause 
order achieve suciently similar copies assignment beads holes argument useful think holes forming straight line beads 
bead allowed fall holes adjacent 
allow bead hole 
state system beads fall holes description contents hole 
reporting hole free state beads holes system described completely beads left free hole fell left hole remaining beads fell right hole 
additionally know exists set consecutive beads fell direction 
construction enforces snake path goes times 
schematically depicted 
provides additional details construction described sequel 
point sucient note nodes vertical dotted line referred nodes column vertices horizontal dotted line referred nodes level row 
case levels variables columns statements provide outline proof 
column rotated grid depicted represents member extended sequence clauses 
feasible path column nodes 
path naturally decomposes subpaths span entire column called legs 

shape leg uniquely corresponds assignment levels rotated grid identi ed variables 
barrett jacob marathe fig 

shape feasible paths dotted circles stand nodes identi ed 
possible leg rst column depicted dashed line 

identically shaped legs interfere neighboring columns 

xed feasible path path consists legs columns 
path visits node precisely variable nodes level 
shape legs change beads holes argument turn assures lot similar legs 

column labeling language allows check assignment represented leg satis es clause extended set clauses 
symbol alphabet stand literals clause 
prove theorem multi labeled directed grid graphs 
lemma implies result holds undirected grid graphs 
theorem 
reg sip problem np hard complete multi labeled directed grids xed regular expression 
proof 
reduction problem sat known np complete 
see example gj 
sat formula construct labeled complete directed grid exists path start vertex destination vertex complies xed independent formula regular expression formula satis able 
cnf formula fx xn set variables fc set clauses 
beads holes argument need repetitions sequence clauses 
construct extended sequence dm clauses consists exactly copies original sequence clauses 
important ordering basic sequence remains unchanged di erent copies 
extended sequence clauses sequel constructing formal language constrained path problems graph 
describe grid rotated degree coordinate system de ne levels rows columns 
di erent types vertices clause vertices ii variable vertices iii join vertices 
layout vertices illustrated means example 
coordinate system essentially clause vertical line name clause variable horizontal line named variable 
lines shown dotted lines 
vertices grid lie middle formed line segments 
clause vertices lie dotted vertical clause lines drawn 
variable vertices lie horizontal variable lines drawn circles 
additional bottom top line join vertices drawn hexagons 
easy see grid part complete square grid nodes 
east west fig 

graph corresponding formula west true general upward edges labeled downward edges labeled label gure states corresponding edge labeled deviating general rule 
simplicity additional repetitions basic clause sequence omitted 
simplify description assume 
rest proof slight abuse notation phrase edges incident vertex mean incoming outgoing edges endpoints 
start node lowermost clause node destination node lowermost clause node cm achieve paths snake form depicted direct edges incident clause vertex odd numbered column upward edges incident clause vertex lying numbered columns downward 
barrett jacob marathe orientation depicted 
order enforce shape admissible paths label edges incident join vertices furthermore important exceptions described upward edges general downward edges general multi labeled de ne regular expression ww ww ww corresponding language 
nal construction labels removed set feasible paths smaller 
proposition summarizes key property construction 
proposition 
simple path described graph complying regular language holds partitioned set legs ii exist consecutive legs identical shape 
proof 
call subpath labeled leg 
usual shorthand regular expressions 
label regular language de nes partitioning subpaths labeling grid legs endpoint lower join level upper join level 
length 
additionally second vertex leg clause node clause nodes column 
traverse leg low numbered high numbered deviate vertical line passing variable vertices way 
sequence deviations east west de ne shape leg 
shape leg infer assignment variables discussed 
ii simple node grid visited result shapes neighboring legs independent 
deviates variable level east may deviate west level 
variable vertices grid mn variable vertices exactly variable vertices averaging argument yields exist consecutive columns variable vertices implies legs range identical shape 
legs multiple copies encoding assignment truth values variables 
removing labels graph allow enforce semantics clauses 
shape leg rule denoted rule infer assignment variables shape deviates level west east assign truth value true false 
note legs identical shapes consistent assignment variables clauses 
constraining regular expression appropriate labels edges ensure holds 
leg corresponding shapes corresponding assignment variables rule true 
odd numbered clause remove labels graph way resp 
remove label edges incident variable vertex east resp 
west column resp 
label resp 
removed way level corresponding variable literal 
numbered clauses take role formal language constrained path problems proposition 
leg path column complying assignment corresponding shape rule labeling chosen form fa fg evaluates true 
proof 
evaluate true 
literals true 
choose accordingly example rst literal odd 
level corresponding positive resp 
negative literal path deviates west resp 
east labeled independent shape labeled levels 
conversely leg labeled focus literal clause corresponding example rst literal 
labeling level variable available correct direction evaluate clause true 
completes construction graph 
prove correctness reduction 
suppose exists satisfying assignment formula 
choose shape path snake fashion additional property deviate west level set true deviate east 
satisfying assignment clause contains literal set true choose labeling legs path column corresponding literal yields simple path complies conversely simple path complying proposition know path consecutive legs shape corresponding assignment construction extended sequence clauses proposition know satis es original clauses 
formula satis able 
fact results stays valid smaller class nite regular languages 
definition str 
language called locally testable exists nite set stands fact subword length corollary 
reg sip problem np hard complete multi labeled directed grid xed locally testable language 
proof 
proof theorem constraining regular language replaced regular language de ned follows fa fg condition equivalent stating sequence fa fg may ended starting rst symbol word guarantees single symbol repeated labeling grid ensures top join vertex columns simplicity enforces follows inductively enforces snake shape path uniform labeling legs 
strong language proof theorem 
noted lemma applied immediately situation 
result corollary extends 
easy verify slight barrett jacob marathe modi cation graph proposed proof lemma modi cation language 
fact directionality readily omitted constructions form expressible locally testable languages 
note result theorem immediately extends graph classes corollary 
class graphs instance contains subgraph mesh graph subgraph computable time polynomial reg sip problem np hard reg sip problem np hard complete cliques ii interval graphs iii chordal graphs iv complete meshes complete hypercubes vi permutation graphs 

hardness cfg sip 
show cfg sip problem nding simple path complying context free language np hard graphs bounded treewidth 
formally stating proof give idea 
reduction sat see gj de nition 
basic idea path consisting subpaths 
rst subpath uniquely chooses assignment creates identical copies 
second subpath checks clause copy assignment reach destination assignment satis es formula 
consider language fw jw standard denotes reverse string heart reduction crucial observation expressed intersection context free languages consider see observe establishing holds imagine representing assignment variables cnf formula xed ordering variables 
clause formula create copy assignment 
ensure copies consistent identical 
note basic objects performing reduction cfg labeled graph 
specify cfg labeled graph simple paths graph implicitly simulate recall straightforward deterministic pushdown automaton accepting graph consist upward chain vertices downward chain vertices additional vertices 
upward chain simulate behavior pushes stack 
downward chain simulate popping contents stack verifying match call gadget tower analogy stack describe proof detail 
purposes simplicity prove results directed graphs extension undirected graphs follows lemma 
theorem 
cfg sip problem np hard graphs constant treewidth xed deterministic context free language 
proof 
reduction sat 
cnf formula fx xn denotes set variables fc denotes set clauses 
corresponding create instance cfg sip follows 
describe reduction parts rst subgraph subgraph 
formal language constrained path problems subgraph constructed follows corresponding clause tower consists simple path stack cell gadgets variable 
basic gadget depicted 
consider simple path bottom nodes marked square top nodes 
labels gadget de ne signature path cyc fa bg 
simple path vertex common starts top nodes ends bottom nodes 
properly de ne signature path 
nodes signatures identical furthermore uses node node node similarly uses node node node gadgets composed form towers identifying top terminal nodes bottom terminal nodes tower levels corresponding variable 
call oor tower 
bottom tower connected bottom tower start vertex connected bottom tower connections depicted 
describe remaining edges discuss properties tower 
fig 

gadget implement tower forcing assignment spread consistently graph 
dashed ellipses denote called level sets 
consider tower simple path labeled starts bottom vertex reaches bottom vertex 
path important properties 
path consists simple subpaths separated edge labeled 
starts bottom tower labeled regular expression oor uses exactly nodes fx realizing assignment variables assignment uniquely corresponds labeling path 

constraints simplicity direction edges implies structure starts unused top vertex labeled avoids nodes reaches unvisited bottom vertex 
furthermore uniquely determined barrett jacob marathe 
note variable simple path visits exactly nodes fx path re ects assignment true unused vice versa 
free nodes second part reduction verify chosen assignment satisfying start fig 

assembling gadgets building graph assemble towers form graph depicted 
proposition 
simple path starting start node reaching intermediate node constraint labeling belongs generates language wn proof 
statement follows 
choose constraining cfl path important lemma follows proposition de nition lemma 

proposition enforces tower unused nodes uniquely interpreted assignment variables 
enforces assignments consistent consecutive towers 
describe subgraph 
label edge subgraph subgraph composed subgraphs dm subgraph corresponding clause depicted 
basically consists simple chains 
rst goes tower 
splits downward directed paths 
corresponds literal node tower corresponding literal part path 
bottom paths joined connected boundaries replaced dm completes description graph 
formal language constrained path problems xk fig 

tower second part graph clause 
instance cfg sip consists graph constraining cfl 
enforces path go tower edges visit vertex edges reach prove correctness reduction 
suppose exists satisfying assignment choose path towers accordingly 
remaining path fact clause literal true 
choosing downward directed subpath literal complete simple path construction label path complies context free grammar 
conversely suppose exists simple path satisfying labeling constraint 
alternation enforces path visits tower vertex nally destination 
situation de ne assignment path rst tower 
lemma path simple know consistently represented towers 
second part path shows satisfying assignment easy verify constant treewidth 
describe tree decomposition graph 
nodes level gadget nodes path form called level sets 
neighboring level sets bottom level sets neighboring towers respectively form set tree decomposition 
additional sets adjacent nodes needed 
shows treewidth bounded 
result theorem extended obtain corollary 
cfg sip np hard restricted graphs treewidth xed linear deterministic cfg 
proof 
proof similar proof theorem describe barrett jacob marathe necessary modi cations needed prove corollary 
replace second part graph verify assignment satis es formula 
done proof theorem replacing symbols 
modify language context free part equivalent equivalent 
add regular component language take intersection enforcing leg indices identical 
removing certain labels sure tower clause tested 
fig 

smaller gadgets replacing original construction 
stands encode clauses labels get removed proof theorem 
need free nodes anymore gadget depicted replaced smaller depicted 
note replacing parallel directed links disjoint paths length increase treewidth situation 
additional nodes edges covered tree decomposition leaf sets size 
increase width tree decomposition 
total treewidth modi ed construction reduced 
new alphabet symbol de ne language vjw easy see speci ed linear context free grammar regular language 
de ned reverse bottom marker top marker exchanged 
take regular language enforces path top marker tower 
sucient argue proof theorem modi ed constraining context free language replaced double sequence variables introducing new set variables fx yielding extended sequence xn new variables constructing towers evaluation clauses 
additionally incorporate middle marker graph 
assuming number clauses odd means modify tower level lowermost gadget created new variable gadget replace upward edges paths length 
upper edge gets original label lower edge gets labeled proof correctness consists showing new ensures single assignment represented subpaths towers 
shown inductively middle symbol outwards 
way information spread depicted 
induction formal language constrained path problems fig 

schematic labeling path solid arrows stand correspondence enforced language dashed arrows correspondence resulting graph 
starts fact signature upward path tower forced comply leading de nition property distinguish graph enforces enforces 
establishes lower signatures identical 
remaining part proof follows details theorem closely 
note language proof theorem accepted deterministic log space bounded turing machine having way input tape 

algorithm reg sip graphs bounded treewidth 
contrast np hardness results show graphs bounded treewidth problem reg sip solvable polynomial time 
class treewidth bounded graphs includes interval graphs chordal graphs bounded clique size complete meshes xed length width outer planar graphs series parallel graphs easiness result hardness result preceding section imply results sense best possible 
notion nice tree decomposition discussed bo 
definition 
tree decomposition hf nice choose root tree binary tree leaf jx start node children join node child exists vertex fvg forget node fvg introduce node 
fact exists nice tree decomposition optimal width treewidth constructed linear time bo 
theorem 
reg sip problem solvable polynomial time treewidth bounded graphs proof sketch treewidth bounded graph nice tree decomposition describe algorithm computes tables partial shortest barrett jacob marathe simple paths bottom fashion speci cally table set corresponding node describe entries tables compute values leaf sets ii internal nodes values tables child node 
number values computed number tables polynomial size yields polynomial time algorithm 
complicated task keep track simplicity path precisely nodes partial solutions represented entries table 
entry type path going set nodes table attached 
sets separators necessary keep complete information possible paths separator 
remainder section denote treewidth tree decomposition set corresponding node give characterization distinct need maintained 
indices called atoms proof describe stored table 
node path starts 
state automaton reading label path 
node path ends 
state automaton having read label path 
accept special situation node paths indices identical nodes states 
special half atoms standing segment segment path node state identifying node simple path starts source label lead automaton speci ed state 
similarly segment path node state labeling path gets automaton state accepting state sink 
completely described atoms plus special half atoms set nodes need allow atoms empty meaning denote path 
noting total number ways partition set size leads upper bound 

number entries tables polynomial size nfa xed treewidth note entry table special half atoms empty stands complete solution visited part graph 
type partial solutions maintain total length shortest partial solution 
describe tables formally 
leaf sets consisting single node table easy compute 
entries value partial solutions states length path start states additional nodes 
length path initial state 
accepting states length path state order compute tables bottom fashion need consider account moves automaton choose 
attempted optimize size tables 
understand certain usage pattern chooses 
possible representations 
formal language constrained path problems possible cases depending type nodes node join node 
letting children know combine partial solution stored table associated partial solution stored table associated pairs types partial solutions check combined form partial solution commonly nodes matching boundary node state partial solution respecting special cases source destination subpaths 
create new type compute value combined solution 
type exist table newly computed value smaller old table entry update table entry 
justi ed observation described associated disjoint set separator nodes 
keep componentwise min tables types partial solutions description match sets decomposition identical keep smaller value 
solution type exist assume value nity 
seen combine entry empty sub solution cost left right choose better 
forget node node removed set nice tree decomposition 
discard partial solutions contain path endpoint partial solutions delete set nodes 
resulting identical keep minimum value 
introduce node new node edges nodes set child 

set new node 
copy known partial solutions 
create new partial solutions combining known solutions created rules stated leaf sets form fvg 

include incident edges 
consider possible new paths edge 
correctness algorithm follows noting 
entry root table existence path length easily nd path recursively associated children root 

conversely optimal shortest solutions 
set associated root assume join node left right children 
argument cases similar omitted 
easy see path broken paths empty sub solution maintained sub solution maintained generalization previous result holds corollary 
xed language decidable way input tape log space bounded nondeterministic turing machine 
problem nding shortest simple path source destination solvable polynomial time treewidth bounded graphs 
proof 
length simple path graph bounded number con gurations nondeterministic turing machine log tape cells polynomial con gurations machine recognizing word length smaller equal machine reads input tape barrett jacob marathe direction create nfa states representing con guration decides words length ii size polynomial algorithm proof theorem nfa compute sought path polynomial time 
note languages accepted pushdown automata having stack symbol examples languages 

algorithm acyclic graphs 
know situation shortest simple paths feasible acyclic graphs 
stems fact paths acyclic graph simple shortest shortest simple path coincide 
results section yields result corollary 
problem cfg sip solvable polynomial time directed acyclic graphs 
making fact length simple path bounded size graph get corollary 
problem nding shortest simple simple source destination directed acyclic graph formal language solvable polynomial time exists polynomial time computable cfl size polynomial property jxj 
extensions applications 
section brie discuss extensions applications results problems transportation science 
applications possible devise dynamic programming methods solve problems aim convey applicability general methodology proposed 

node labels trip chaining 
consider problem edges nodes labels constraint compound node label path 
easy transformations input show results develop edge labeled case true node labeled case 
transform kind instance edge labeled steps network stays edges get labeled new symbol 
node gets additional loop attached 
loop gets label node 
language extended exactly second symbol new edge symbol ii word edge symbols original language 
easy see regular context free languages closed operation 
shows easiness results edge label constraints imply easiness results node label constraints 
edge labeled graph split edges insert node edge label label old nodes new symbol 
language extended 
construction transfer edge label constrained hardness results node label constrained results 
node label extensions turn useful modeling transportation related problems 
example transportation applications transims needs nd paths travelers need visit xed sequence location types 
instance want nd shortest path home home visits locations atm gas station supermarket post oce particular order freedom choose atm gas stations formal language constrained path problems city 
problems type referred transportation literature trip chaining problems 
problem solved direct application dijkstra shortest path algorithm nd best paths consecutive concatenating paths 
treating destination type node label constructing simple regular expression select places nd shortest path networks satisfy precedence constraints polynomial result discussed 

finding alternatives shortest paths 
considerable interest algorithms variations shortest paths amo 
example scott jimenez bernstein authors consider problem graph shortest path sp integer parameter nd shortest path sp links common sp call best similar path 
authors integer linear program formulation problem heuristics lagrangian relaxation 
veri ed heuristic takes exponential time worst case 
quoting link overlap constraint nding best path dicult shortest path problems single constraint np hard suggesting best similar path np hard 
show problem solvable time denotes time taken nd shortest path graph vertices 
substantially improves exponential time algorithm 
approach solving problem algorithm regular expression shortest paths 
approach uses fact symbol language consisting words occurrences symbol regular 
graph shortest path sp integer parameter perform steps 
label edges shortest paths edges 
construct nfa accepts strings occurrences corresponding automaton shown happens deterministic 

find shortest path constraint label 
fig 

automaton count shared links accepting proof correctness straightforward 
note particular case fact get simple path remove loop path increasing length acceptability shorter string 

handling left turn turn penalties 
suppose told road network additional cost incurred take certain left turns 
common scenario transportation science referred turn penalties 
scenario 
fact current dallas ft worth case study exactly situation 
speci cally left turns study area prohibited amounts saying cost edge left turn 
infrastructure change proposed case study intends barrett jacob marathe series left turns illegal near area valley view mall 
known reduction original problem problem nding shortest path modi ed network see amo details solve problem 
basic idea replace intersection clique size 
slightly complicated subgraph required directed graphs 
giving penalty turn suppose wish nd path take say left turns 
variant problem solved direct application dijkstra algorithm amenable ecient solution formal language approach 
replace intersection clique size add appropriate labels edges 
construct automaton accepts strings contain labels corresponding left turns 
constructed lines similar path problem 
rest details straightforward 
consider complicated query wish nd path number left turns small fraction total number edges 
easy see written context free grammar solved eciently 

time dependent networks multi criteria shortest paths 
transportation applications desirable solve shortest path problems networks edge weights function time 
orda rom consider type problem various waiting policies function classes 
basic algorithms dynamic programming functions 
combining results obtain polynomial time algorithm cfl constrained shortest paths time depending networks 
nal application consider bicriteria general multi criteria shortest path problems 
instance di erent weight functions edge function captures cost edge function captures time takes traverse edge 
aim bicriteria shortest path problem aims nding minimum cost path source destination obeys budget bound time taken go problem studied extensively literature see 
cross product construction simply constructs multiple copies basic graph easy design polynomial time approximation scheme bicriteria shortest path problem subject labeling constraints 
idea straightforward combination ones outlined designing approximation scheme basic bicriteria problem 

formal languages 
expected attempts extend polynomial time algorithms general grammars context sensitive grammars fail yield polynomial time results 
intuitively hardness problems due fact emptiness recognition problems context sensitive grammars undecidable pspace complete respectively 
consider problem context sensitive grammars 
easy show problem csg shp undecidable xed log space decidable context sensitive language 
easy see language tm halts empty input space log context sensitive 
fact log space computable 
straightforward see fw lg formal language constrained path problems way stating halting problem undecidable 
showing csg shp decide establishes csg shp undecidable 
construct directed chain labeled start additionally put loop labeled 
xed constraining language equivalent existence general simple path graph 
note graph nearly tree 
contrast csg sip pspace complete 
membership pspace follows observing simple path graph jv nodes 
space bounded guess simple path verify csg 
hardness shown reducing problem deciding nding simple path directed chain labeled denote points chain 
path labels 
similar extensions hold formal languages 
note argument context sensitive language xed represent arbitrary pspace complete problem 


general approach modeling solving number problems seek nd paths subject certain labeling constraints 
model shown particularly useful understanding solving transportation science problems 
results provide fairly tight characterization complexity problems varying type considered path underlying grammar allowed graph classes 
number non trivial cases completely characterizes boundary easy hard cases 
results seen investigating tradeo economy descriptions languages describe labeling constraints ii ecient solvability corresponding problems 
bk jmn obtained number additional theoretical empirical results related topics 
speci cally show apply results nding reg shp time dependent networks solve number additional problems arising transportation science 
bk jmn carried detailed experimental analysis validate suitability extensions algorithm suggested realistic transportation networks 
refer reader web site transims lanl gov comprehensive information transims related documents 
results raise number questions investigation 
interest characterize class xed regular context free languages regular expression constrained simple path problems solvable polynomial time 
interest provide natural formulation label constrained subgraph problems 
example natural way specify labeling constraints spanning trees graph 
number possible ways aim nd ways natural useful modeling practical problems 
acknowledgments want harry hunt iii sven alberto mendelzon ravi ravi dan rosenkrantz yannakakis hans christoph wirth stephen eubank kai nagel terence kelly robert white brian bush useful discussions pointers related literature suggested improvements course writing 
anonymous referee careful barrett jacob marathe reading manuscript number helpful comments earlier draft 
av abiteboul vianu regular path queries constraints computer system sciences pp 

bal ben akiva lerman discrete choice analysis mit press series transportation studies cambridge ma 
amo ahuja magnanti orlin network flows theory algorithms applications prentice hall englewood cli nj 
ac arnborg courcelle algebraic theory graph reductions journal acm jacm pp 

amm arocena mendelzon mihaila applications web query language proc th int :10.1.1.12.678
www conf santa clara april 
ahu aho hopcroft ullman design analysis computer algorithms addison wesley reading ma 
ab anson barrett marathe nagel stein engineering route planner dallas case study technical report los alamos national laboratory february 
arnborg easy problems tree decomposable graphs algorithms pp 

bo bodlaender dynamic programming graphs bounded treewidth proc 
th international colloquium automata language programming icalp lncs pp 

bo bodlaender tourist guide treewidth technical report ruu cs utrecht university 
bl bern lawler wong linear time computation optimal subgraphs decomposable graphs algorithms pp 

bal blue adler list real time multiple objective path search vehicle route guidance systems proc 
th annual meeting transportation research board washington january 
buchsbaum kanellakis vitter data structure arc insertion regular path nding proc 
st acm siam symposium discrete algorithms soda pp 

bk barrett routing problems transims theory practice validation technical report los alamos national laboratory march 
cruz mendelzon wood graphical query language supporting recursion proc 
th acm sigmod conference management data san francisco ca pp 

cruz mendelzon wood recursive queries recursion proc 
nd international conference expert data base systems corner ca pp 

clr cormen leiserson rivest algorithms mcgraw hill book 
gj garey johnson computers intractability guide theory np completeness freeman san francisco 
ha halasz re ections notecards issues generation hypermedia systems communications acm pp 

hart nilsson formal basis heuristic determination minimum cost paths ieee trans 
system science cybernetics july pp 

ha approximation schemes restricted shortest path problem mathematics operations research 
hm highway research board highway capacity manual special report national research council washington 
hu hopcroft ullman automata theory languages computation addison wesley reading ma 
hu extremal paths graphs foundations search strategies related topics akademie verlag berlin isbn jacob barrett marathe models ecient algorithms class routing problems time dependent labeled networks technical report los alamos formal language constrained path problems national laboratory march 
jmn jacob marathe nagel computational study routing algorithms realistic transportation networks invited accepted subject revisions acm experimental algorithmics december 
preliminary version appeared proc 
nd workshop algorithmic engineering saarbrucken germany august 
ku knuth generalization dijkstra algorithm information proc 
lett pp 
hrs hunt iii rosenkrantz szymanski equivalence containment covering problems regular context free grammars computer system sciences pp 

mw mendelzon wood finding regular simple paths graph databases siam computing pp 

marathe ravi sundaram ravi rosenkrantz hunt iii bicriteria network design problems algorithms pp 
july 
pa papadimitriou computational complexity addison wesley reading massachusetts 
ro shortest paths rational constraints information processing letters pp 

scott jimenez bernstein finding alternatives best path proc 
th annual meeting transportation research board washington jan 
available draft report intelligent transport systems program princeton university 
str finite automata formal logic circuit complexity birkh auser 
tr barrett smith loose beckman davis roberts williams operational description transims technical report la ur los alamos national laboratory 
tr smith beckman anson williams overview transims transportation analysis simulation system technical report la ur los alamos national laboratory may 
ta tarjan uni ed approach path problems acm pp 

orda rom shortest path delay algorithms networks time dependent edge lengths acm pp 

rr ramalingam reps incremental algorithm generalization shortestpath problem algorithms pp 

ya yannakakis graph theoretic methods database theory invited talk proc 
th acm sigact sigmod sigart symposium database systems acm pods nashville tn pp 

ya yannakakis perspectives database theory invited talk proc 
th annual ieee symposium foundation computer science focs pp 

