achieving high performance designed virtual machines smith sastry tim heil todd dept electrical computer engr 
computer sciences dept university wisconsin madison university wisconsin madison 
today virtual machines layer software allows programs compiled instruction set executed processor executing different native instruction set 
virtual machines popular years providing platform independence virtual machines open new opportunities enhancing performance 
design virtual machine software underlying hardware microarchitecture enable enhanced instruction level parallelism adaptable performance mechanisms possible hardware application software separated instruction set architectures traditionally done 
high performance computers virtual instruction set architecture isa level maintaining architectural compatibility 
isa implemented virtual machine blends software hardware symbiotic manner design 
hardware support architecture implementation instruction set architecture isa 
isa special features keyed specific hardware optimizations built microarchitecture 
designed virtual machine implementation include fast compilation isa isa efficient hardware performance feedback optimizing re compilation adaptive hardware performance features enable performance improvements achieved conventional hardware software 
sense software implementing virtual machine available hardware contrast current paradigm hardware designer isolated software fixed inflexible instruction set architecture 
application virtual machines contrast current vm proposals focussed maintaining compatibility portability platforms supporting existing isas performance objectives typically ambitious minimizing performance losses occur process 

search high performance processor microarchitecture evolving years 
performance increases primarily come exploiting larger amounts instruction level parallelism ilp increased prediction speculation 
microarchitectures evolved serial pipelined superscalar implementations 
evolution continue evident substantially different far reaching approach 
current obstacles increased performance include limited visibility ilp known window instructions visible hardware increased provide higher ilp 
hardware increase instruction window size typically leads greater complexity 
substantial advances take place instruction window larger hardware support 
potentially compiler software instructions visible window software view static restricted 
particular object oriented programming paradigm widely adopted nature compile time visible instruction window limited due method calls dynamic linking 
instruction set compatibility performance obstacle difficult change existing instruction set enhance performance 
fact changes enhance performance generation may lead added design complications performance benefits generations delayed branches 
furthermore removing old instructions difficult maintaining compatibility older generation software important 
designers tradeoffs provide best performance averaged number application programs 
tradeoffs may give best performance individual programs phases larger programs 
ability adapt specific program program phase limited decisions hardware design time 
researchers clever devising hardware performance enhancements 
usually targeted particular aspect design give relatively small performance improvement 
features sense individual program may able take advantage 
implementing tends weigh clean pipeline structure small complicated special purpose possibly extent complexity individual benefits 
vm design overcome obstacles open new opportunities computer architects 
provide wider scope finding ilp allow hardware designer considerable flexibility isa design allow dynamic adaptivity hardware performance features allow cleaner pipeline design removing hardware putting complexity software selectively applied 
furthermore provide high performance object oriented programs 

virtual architectures traditional processor architecture hard division hardware software see fig 

pointed clean hardware software division provided number advantages inflexibility inhibiting 
virtual architecture abstraction provides revolutionary opportunities computer architects 
abstraction popular form java bytecodes virtual machine vm implementations 
fig 
illustrates vm java environment 
vm layer effectively widens traditional isa separation hardware software 
application software compiled virtual architecture specification java bytecodes hardware designed existing instruction set referred native isa 
vm implemented software layer placed traditional hardware software layers 
vm underlying hardware implement isa interpretation just time compilation adaptive recompilation combination 
primary goal vms manner just described provide platform independence 
java bytecodes hardware platform provided vm implemented platform 
providing additional layer abstraction performance typically lost inefficiencies matching isa native isa interpretation just time jit compilation 
isa native isa defined completely independently real opportunity mesh 
consequently typical performance goal environment provide performance fast native isa execution 
application program binary native isa hardware native isa virtual machine virtual isa application program binary hardware application program binary virtual isa implementation isa vm software vm hardware conventional virtual machine interface envisioned vm hardware software design conventional hardware software interface 
relationships software hardware virtual machines vm design oct vm design isa abstraction exploited exceed native processor performance 
approach illustrated fig 

vm software underlying hardware designed 
underlying native isa implementation dependent existing isa case fig 

refer lower level isa implementation isa isa emphasize implementation dependence 
isa implementation dependent hardware software boundary designed division blurred 
flexibility enables distribution features hardware software optimal performance 
current environment java bytecodes obvious choice isa isa fact conventional risc cisc isa 
desirable support conventional native isa java bytecodes supported matter multiple isas supported isa 
case isa may better suited isas designer choose tradeoffs 
platform independence feature provided isa level 

vm implementation fig 
illustrates designed vm system envision 
isa binary executed combination vm hardware software 
software may phased common java vms today 
software may compile isa demand just time jit may interpreted initially compilation occurring usage determined high 
initial jit compilation fast simple 
program runs hardware software cooperatively optimize program execution 
hardware collects relevant performance information form efficiently obtained interpreted software designed match software needs 
ways hardware software communicate cooperatively optimize performance offer opportunities innovation 
example consider hardware passing performance information software 
hardware designed collect performance information keyed specific features implementation hand 
performance data collected instruction basis software selection instructions instructions program region 
performance information passed profiles triggers jit compiler interpreter dynamic compilation system run time info va binary implementation architecture architecture virtual executable fig 

overview designed vm system 
vm design oct software instructions read performance data polling may hardware triggers cause vm software invoked certain event occurs performance characteristic shift outside operating envelope program changes processing phases 
going direction software manage hardware features implementation dependent instructions tailored specific hardware performance features executed part dynamically re compiled user binary 
example number prefetching load store opcodes control memory operations trigger prefetches type prefetch 
vm software directly execute special instructions tune hardware performance features match characteristics user code currently executed 
example instruction may reach hardware adjust branch predictor global history length particular program certain region program 
optimization process occur fact typically occur times program executes continue adjusting changes program data 
intermediate form re compiled binary persists programs execution may may persist program executions tradeoff research issues 

performance optimizations problems forefront microarchitecture research benefit vm design approach 
research problems led developing approach 
subsections discuss microarchitecture research problems interested ways vms help solve 

trace selection control independence maintaining large accurate window dynamic instructions important high performance microarchitecture 
trace processors rot high performance instruction supply relies accurate trace prediction trace cache performance 
potential maintaining large instruction window spite mispredicted branches exploiting control independence 
trace control independent prior branch trace fetched executed regardless outcome branch typically occurs paths branch re converge control independent traces 
control independent traces squashed restarted branch mispredicted 
study done rot explores potential limitations control independence context superscalar processors 
control independence potentially reduce performance gap real oracle branch prediction half 
detailed implementation performance improvements order observed 
trace processors offer complexity effective solution implementing control independence mechanisms distributed window organization naturally isolates traces 
harvest potential control independence trace processors traces selected expose control independent points points program 
hardware trace selection algorithm heuristics divide dynamic instruction stream traces identify control independent points terminate traces related points 
current trace selection constrained fairly trivial decisions hardware limited view control flow program 
hardware may able expose amount control independence new level sophistication layer software provide may necessary 
software determine control independence relationships precisely 
importantly sophisticated heuristics consider variables selectively intelligently apply control independence information 
variables include static information control flow graph dynamic profile information hardware 
vm design provides vehicle kind trace selection 
software implement overly complex analysis 
second transfer information software hardware isa hardware provides dynamic profile information software supplies hardware information select traces 
designed trace selection likewise applied improving trace prediction accuracy trace cache performance 
vm design oct 
improving control prediction data values conventional branch predictors history past branch outcomes predict outcomes 
branch prediction methods elaborate clever ways predictors efficient reducing aliasing 
performance improvements probably leveling information extracted stream outcomes 
substantial improvements branch prediction need additional information 
particular certain hard predict branches predictable data values results non branch instructions 
folding data values branch prediction process productive way difficult large number data values choose branches data values hurts predictability 
considering vms method solving problem having software experiment fly branch prediction algorithms data values 
similar spirit hardware tuning method global branch histories 
furthermore opcodes implementation isa enable disable data values instruction basis needed 

memory systems object oriented applications increasing relative delay memory growing performance problem 
consequently vm help manage memory hierarchies appears application approach 
furthermore memory management issues especially acute object oriented programs small data structures continuously created abandoned garbage collected 
designed vms improve memory hierarchy performance reorganizing cached data improving cache hierarchy management constraining highest cache data item reside 
methods tightly integrated features performance monitoring architecture collect performance data instruction region basis 
optimizations include ability re organize memory data permitted java semantics ability prefetch move data hierarchy type information available java bytecodes 
information directly communicated isa special opcodes example 
performance feedback hardware allow dynamic runtime optimizations usage patterns 

performance tradeoffs vm design way envisioned important performance tradeoffs resolved 
particular overhead performing optimizations software offset performance gains eventually realized 
means fast simple software methods 
points study algorithms different points cost time performance curve 
suggests hierarchical implementation different algorithms complex better optimizing algorithms invoked portions program heavily 

summary isa layer hardware software design vm provide powerful new way dynamically optimizing executing programs 
important optimizations exploit observed run time performance characteristics 
optimizations involve re compilation fly adjustments underlying hardware performance mechanisms 
optimizations done broad scale limited relatively small issue window purely hardware approaches 
effect higher performance results combining strengths software compilation dynamic hardware execution 
apparent need avenue expanding search instruction level parallelism 
designed vms provide avenue 
coincidentally number proposals put put forward systems similar objectives approach vm design 
number listed bibliography 
supported part nsf mip army intelligence center fort contract dabt arpa order 
ibm partnership award sun microsystems 
views contained authors interpreted necessarily representing official policies endorsements expressed implied army intelligence center fort government 
vm design oct 
selected bibliography adv sarita adve doug burger rudolf eigenmann michael smith catherine kandemir david choudhary jesse fang pen chung yew changing interaction compiler architecture ieee computer pp 
december 
amm glenn ammons thomas ball james larus exploiting hardware performance counters flow context sensitive profiling prog 
lang 
design impl pp 
june 
che chernoff reeve rubin yates fx profile directed binary translator ieee micro pp 
march april 
con conte evolutionary compilation long instruction word microarchitectures exploiting parallelism levels asplos wild crazy ideas session oct 
dea jeffrey dean james hicks carl waldspurger william weihl george hardware support instruction level profiling order processors thirtieth symp 
pp 
december 
kemal ebcioglu erik altman daisy dynamic compilation architecture compatibility ibm research report rc august 
kemal ebcioglu erik altman erdem java processor fast dynamic vliw compilation intl 
workshop security efficiency aspects java january 
fis joseph fisher walk time techniques catalyst architectural change ieee computer pp 
september 
gri david griswold java tm hotspot tm virtual machine architecture white sun second generation java tm virtual machine sun microsystems white java sun com products hotspot whitepaper html march hol urs holzle adaptive optimization self reconciling high performance exploratory programming sun microsystems laboratories technical report tr 
hsi cheng hsieh marie conte teresa johnson john gyllenhaal net capture performance java software ieee computer pp 
june 
toni juan juan navarro dynamic history length fitting third level adaptivity branch prediction fifth intl 
symp 
comp 
arch pp 
june 
men menezes hardware profiling program optimization ph thesis dept elec 
comp 
eng north carolina state univ rot rotenberg jacobson smith trace processors thirtieth intl 
symp 
pp 
december 
rot rotenberg jacobson smith study control independence superscalar processors appear fifth intl 
symp 
high perf 
comp 
arch january 
sol frank inside duke press nd ed 
vm design oct 
