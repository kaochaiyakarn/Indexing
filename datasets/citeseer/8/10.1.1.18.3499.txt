burst tries fast efficient data structure string keys steffen heinz justin zobel hugh williams school computer science information technology rmit university gpo box melbourne australia jz hugh cs rmit edu au applications depend efficient management large sets distinct strings memory 
example index construction text databases record held distinct word text containing word information counters 
propose new data structure burst trie significant advantages existing options applications requires memory binary tree fast trie fast hash table burst trie maintains strings sorted near sorted order 
describe burst tries explore parameters govern performance 
experimentally determine choices parameters compare burst tries structures task variety data sets 
experiments show burst trie particularly effective skewed frequency distributions common text collections dramatically outperforms data structures task managing strings maintaining sort order 
keywords tries binary trees splay trees string data structures text databases 
computing applications involve management large sets distinct strings 
example vast quantities information held text documents ranging news archives law collections business reports repositories documents gathered web 
collections contain millions distinct words number growing linearly collection size 
applications involve large numbers distinct strings bibliographic databases indexes genomic data 
sets strings managed applications indexing efficiency reasons complete set held memory 
construction inverted index involves determination set distinct terms vocabulary collection term maintenance information total occurrence count set locations occurs 
gather statistics collection parsed justin zobel contact author correspondence 
terms memory data structure store distinct terms statistics 
task vocabulary accumulation focus example application data structures string management 
existing data structures task vocabulary accumulation generally maintain memory set records string key 
large data sets efficient hashing 
standard methods hashing strings maintaining chained hash table particularly fast shown bitwise hash function chaining move front chains hash tables faster alternatives 
disadvantage hashing strings randomly distributed slots problem significant bulk insertion creation static index means hashing candidate structure applications index maintenance convenient strings available sorted order 
having strings sorted allows browsed allows index information strings shared prefixes efficient range query evaluation kept disk updated minimal disk activity 
candidate structures varieties search tree maintain strings sorted order 
tries ternary search trees fast space intensive :10.1.1.44.5506:10.1.1.17.3904
binary search trees major variants splay trees randomised search trees red black trees space slow 
propose new data structure call burst trie 
structure collection small data structures call containers accessed conventional trie context call access trie 
searching involves characters query string identify particular container remainder query string find record container 
container data structure reasonably efficient small sets strings list binary search tree 
general principle maintaining burst trie initially consists single container 
container deemed inefficient burst replaced trie node set child containers partition original container strings 
major design decisions explored burst tries data structure container determine container burst 
experiment data structures containers propose test heuristics determining container burst 
heuristics assumption string data sets typically skewed lesson learned comparing hashing trees major obstacle efficiency excessive numbers string comparisons 
experiments data sets compare burst tries existing data structures vocabulary accumulation 
experiments show burst trie twice fast conventional tree slower hash table uses space conventional tree hash table maintains strings sort order 
compared splay tree fastest variant burst trie accumulate vocabulary gb collection web data time memory 
compared ternary search tree burst trie faster uses memory 
analysing superior performance burst trie comparison structures show ability burst trie store frequently accessed records locations close root containers far outperforms adaptivity splay tree 
results consistent theoretical analysis similar structures shows logarithmic height bounds search performance expected burst tries 
burst trie significantly superior existing tree structures tasks vocabulary accumulation 
existing data structures binary search trees binary search tree bst tree node stores string pointers left right child nodes 
search find query string involves node comparing query string node string determine string branch left right 
root string comparison typically terminates inspection single character search progresses number characters inspected string comparison gradually increases 
allocation strings nodes determined insertion order skew distribution reasonable expect common words occur close text collection close root bst 
assuming distribution stable accesses common term fast levels tree usually kept cache string comparisons required 
hand strings inserted sorted order creating sticks distribution changes happen example documents indexed variety languages behaviour bst extremely poor 
absence rebalancing technique prevent sticks occurring move common nodes root bst limited practice vocabulary accumulation despite earlier performance typical data 
include bsts discussion common data structure serve yardstick experiments 
known variants bsts maintain balance approximate balance particular avl trees red black trees 
techniques tree insertion deletion ensuring leaves approximately depth 
hand rebalancing ensures nodes log upper limit length search path 
hand rebalancing consider frequency access node common words placed leaves 
experimented red black trees observed effect detrimental red black trees slightly faster data low skew standard bsts faster typical vocabulary accumulation 
report experiments red black trees 
principle cost searching bst reduced skipping string prefixes 
search proceeds upper lower bounds search narrow characters shared bounds need checked 
cost identifying prefix skip outweighs savings 
splay trees splay tree variant bst search node accessed moved root series node rotations operation known 
effects expected beneficial vocabulary accumulation 
intuitively nodes remain near root cpu cache allowing accessed rapidly tree quickly adapts local changes vocabulary guarantees amortised cost accessing tree nodes log 
practice splay trees significant disadvantages 
comparison bst splay tree requires memory efficient implementation requires node pointer parent 
common word moved surprisingly far root searches data seventeenth word deep tree 
expensive reorganisation technique term comparisons pointer assignments level 
investigated variations efficient splay accesses say moving common words close root reducing total cost reorganisation 
report experiments accesses intermittent interval accesses value worked data 
form bst access randomised search tree rst node uses additional number initially zero 
inorder traversal sort order strings heap property maintained numbers number node large children 
search positive random number generated node accessed replaced left unchanged 
tree rotations restore property 
provide similar performance splay trees report experiments 
hash tables efficient form hash table vocabulary accumulation chaining 
hash tables large array index set linked lists nodes said slot 
search array index computed hashing query string 
string sought linked list index 
factors important performance 
hash function needs achieve reasonably uniform distribution strings slots 
practice means order slots correspond string sort order vocabulary accumulated distinct strings sorted small overhead 
second hashing needs fast 
functions commonly described texts modulo repeated multiplication division simply slow reason developed fast string hashing function bit wise operations 
hash table needs adequately large 
standard chaining number slots needs significant fraction number distinct strings 
search accessed node moved front list efficiency obtained smaller tables importantly application move front chains efficiency declines slowly increasing vocabulary size 
lower bound cost hashing search string inspection required hash function comparison required query string string node slot 
move front chains vocabulary accumulation searches terminate node slot 
reason small number total string inspections required seen experiments hashing fastest methods tested 
tries ternary search trees trie alternative bst storing strings sort order 
node standard trie array pointers letter alphabet additional pointer empty string 
leaf record concerning particular string 
string trie letters string determine pointers follow 
example alphabet letters pointer root corresponds letter node indicated pointer strings 
node pointer corresponding letter followed strings ac pointer corresponding empty string record concerning single letter string 
search trie fast requiring single pointer traversal letter query string 
search cost bounded length query string 
small increase complexity implementation trie substantially reduced size omitting nodes lead single leaf 
trie chains lead leaf branching eliminated refer variant compact trie 
compact tries extremely large particular nodes close leaves tend sparse non null pointers 
variant forms tries reduced space requirements compared standard tries ternary search trees compact tries 
tst node represents single character pointers 
left respectively right pointer strings start character alphabetically precedes respectively follows set tst nodes connected left right pointers representation trie node 
rebalanced access 
central pointer strings starting corresponding pointer trie node 
slower tries compact 
report experiments compact tries 
tries discussed detail section 
burst tries earlier comparing tree data structures discussed observed compared hashing structures sources inefficiency 
average search lengths surprisingly high typically exceeding pointer traversals string comparisons moderate sized data sets highly skew distributions 
contrast search hashing rarely requires string traversal compute hash value single successful comparison 
second structures bsts string comparisons involved redundant character inspections unnecessarily expensive 
example query string middle search michael encountered clear subsequent strings inspected prefix mi 
third tries set strings subtrie tends highly skew distribution typically vast majority accesses subtrie find particular string 
highly time efficient space intensive structure remaining strings resources 
considerations led burst trie 
primary design goal burst trie reduce average number string comparisons required search 
clear achieving goal requires adaptive structure stores frequent terms retrieved rapidly frequent terms 
secondary goal gains performance offset impractical memory requirements observed tries 
burst trie memory data structure designed sets records unique string identifies record acts key 
formally string length consists series symbols characters ci chosen alphabet size 
assume small typically greater 
burst trie consists distinct components set records set containers access trie records 
record contains string information required application burst trie information statistics word locations pointers required maintain container holding record 
string unique 
containers 
container small set records maintained simple data structure burst trie depth discussed strings length characters strings identical 
necessary store characters 
container header storing statistics heuristics bursting 
particular container depth containing author automated contain auger 
choice data structure representing containers considered 
access trie 
access trie trie leaves containers 
node consists array pointers may point trie node container single empty string array locations indexed characters remaining pointer indexed empty string 
depth root defined 
leaves varying depths 
discussed section compact forms trie designed alleviate space wasted sparse nodes 
design nodes access trie rarely sparse compact nodes costly traverse maintain 
show small alphabets simple arrays lead excessive space usage large alphabets strategies dividing symbols bytes explored true tries general 
burst trie viewed generalisation proposed variants trie discussed 
shows example burst trie storing records keys came car cat cave cy cyan went west respectively 
example alphabet set letters addition empty string symbol shown container structure bst 
access trie nodes deepest depth 
leftmost container records corresponding strings came car cat cave 
strings rightmost container corresponding string 
string cy stored wholly access trie shown empty string pointer record indexed empty string 
abc abc abc abcde burst trie bsts represent containers 
re nt st bst container enables retrieval records sort order 
inorder traversal burst trie starts root 
records container store suffixes original strings reconstructed keeping track traversal path 
unordered structure list represent containers containers sort order design small size means sorted rapidly 
consider main operations applied tree searching insertion bursting 
search searching burst trie distinct stages follows 
input query string cn characters 
output pointer record null case unsuccessful search 
search algorithm 
access trie traversed leading characters query string 
initially current object root access trie current depth 
current object trie node depth update current object node container pointed element array increment current object trie node depth current object object pointed empty string pointer simplicity regarded container zero records 
current object null string burst trie search terminates 

current object valid container 
remaining characters ci cn search container returning record returning null 
current object container zero records pointed pointer entire string consumed traversal trie returned 
example search record key came burst trie follow pointer slot trie node 
follow pointer slot corresponding second character 
reach left container search string suffix obtained removing characters came 
standard search algorithm bst 
note languages common words typically short 
terms typically stored empty string pointer simply small number access trie pointers search container 
ease access common terms major reasons burst trie fast 
insertion burst trie grow distinct ways 
insertion record added possibly initially empty container 
occurs new string encountered 
second bursting container depth replaced access trie node pointing set containers depth 
occurs container deemed heuristics discussed inefficient 
bursting considered 
consider insertion input new string cn length outcome addition record burst trie 
insertion algorithm 
stage search algorithm identify container record inserted 
container empty depth special case arriving trie node depth container empty string pointer 

standard insertion algorithm container data structure add record container suffix characters ck cn 
record added empty string pointer 
shows example burst trie insertion record key western 
deletion slightly complex 
delete record searched deleted container usual method container data structure 
deletion may empty container case parent trie node needs updated 
trie node longer children removed burst trie process applied recursively root 
deletion arise vocabulary accumulation consider 
bursting bursting process replacing container depth containers depth contain records original container 
abc abc abc abcde re nt st burst trie insertion record key western 
stern burst considered consider burst 
process follows 
input burst trie outcome replacement container new leaf node access trie set child containers 
bursting algorithm 
new access trie node created 
pointer set empty container 

record original container string cr removed string leading character cr record added container indicated cr th pointer usingthe string cr crn record empty string added pointer 

original container discarded 
bursting container save space space occupied trie node new container headers principle offset discarded characters 
significantly string inserted trie node burst character removed prefix example single root node access trie saves character stored string entire burst trie 
follows judicious choice containers burst reduce space consumption primary goal 
experiments remove leading character string burst costly omit character string inserted node 
reason experiments show cases burst trie smaller corresponding tree 
shows burst trie bursting rightmost container 
records container redistributed child nodes new trie node 
character string determine child pointer follow 
example term stern original container character determines suffix tern abc abc abc abcde burst container new 
tern inserted container slot 
string represented empty string container strings held empty string pointer 
opposite bursting consolidation process collecting set containers trie node single container 
consolidation governed heuristics similar described bursting 
consider consolidation interesting avenue explore research 
burst heuristics consider burst trie container data structures bsts 
properties burst trie depend rate bursting 
containers single record arise example containers records burst burst trie equivalent standard trie 
burst rate reduced burst trie behaves increasingly bst condition burst reached burst trie single bst 
value burst trie better properties structures rate bursting appropriately managed 
successful bursting strategy ensure common strings quickly access trie excessive searching containers 
appropriate management containers move front lists helpful reducing search costs placing commonly accessed items close root container items away 
bursting strategy ensure containers rarely accessed burst containers space efficient trie nodes 
words goal bursting transform containers high average search costs bursting unnecessarily 
presence skew distribution accesses container includes record bursting new container record skew original container 
assuming simple strategy containers represented lists move front access bursting effect increasing likelihood record root new container 
follows deciding burst container depend accessed costly access propose investigate heuristics trigger burst container 
design goal heuristics cheaply evaluated 
common require thorough inspection container decide burst 
heuristics counters container 
heuristics follows 
ratio 
heuristic propose requires counters container 
counters keep track values number times container searched number searches ended successfully root node container 
refer search ends root direct hit 
values ratio number accesses number direct hits calculated container 
ratio determine burst 
observed particular fast hash table speed largely due fact vast majority searches terminated node chain 
requiring high rate direct hits containers principle similar speed possible burst tries 
refinement worth bursting container rarely accessed ratio tested total number accesses exceeds threshold 
example say accesses container direct hits say accesses container total burst 
container accesses contain small number records records low frequency 
drawback ratio additional memory required maintain counters container number tests required access 
limit 
second heuristic bursts container contains fixed number records 
rationale eliminate large containers limiting total search costs 
compared ratio single counter required need tested insertion 
approach advantage provide reasonable performance distribution strings completely uniform 
potential disadvantages 
burst trie limit slow container terms common accesses container direct hits 
arise terms share common prefix probable occurrence 
disadvantage containers rare strings burst 
trend 
heuristic uses counter container 
container created allocated set amount capital current capital modified access 
direct hit capital incremented bonus record accessed container direct hit capital decremented penalty capital exhausted container burst 
accesses sufficiently skew offset penalties container burst 
start capital ensures containers uniform distribution burst certain number accesses 
explored choices parameters trend choice start capital bonus penalty 
discuss effect varying parameters 
considered variants strategy 
example insertion new record capital decreased helping prevent creation excessively large containers 
variants change start capital time stabilise trie example reduce penalties response availability memory pay penalty stage search penalising long searches higher short 
investigated variety options observe behaviour superior heuristics described 
container data structures data structures represent containers allow reasonably efficient insertion search records small data sets 
candidates include linked lists bsts bst variants splay trees 
hash tables candidate efficient small numbers items 
discuss options 
linked lists 
list overhead record pointer record lists space efficient candidate structures 
list records particular order average access costs high 
context lists represent containers solutions problem 
move front lists accessed node moved front position process requires single test rare case record moved assignments 
move front frequently accessed records clustered start list 
average search cost move front managed list twice search cost optimal list records sorted access frequencies 
move front lists provide adaptation local changes vocabulary topic words particular document 
solution burst distribute records new containers decreasing order frequency 
requires record stores frequency count counts kept vocabulary accumulation available list management additional cost 
experiments option effective tested web described pursue 
binary search trees 
record bst requires pointers child nodes bst uses space list search paths average shorter 
bsts position record tree depends frequency order inserted 
property reduce search costs bst burst records sorted decreasing frequency distributed new containers 
doing means frequent terms root nodes containers 
linked lists requires record stores frequency count 
splay trees 
efficient record splay tree requires pointers children parent 
space container structures consider 
frequently accessed records kept near root structure provides adaptation changing vocabulary common move front lists may lead bursting 
table statistics text collections drawn trec 
web web web web xl web xxl trec size mb distinct words word occurrences documents parsing time sec experiments test data principal test data data sets drawn large web track trec project 
files web web web web xl xxl contain collections web pages extracted internet archive trec retrieval experiments 
file trec data trec cd rom 
statistics collections shown table 
word experiments alphanumeric string containing integers starting integer 
convert words lower case 
xml html markup special characters punctuation skipped 
collections show skew distribution typical text 
example trec word occurrences just half distinct words 
frequent words collection respectively word occurs word seventeen twice second frequent term 
behaviour described inaccurately zipf distribution 
hand words total occur 
collections different properties strings extracted genomic data music data 
genomic data collection nucleotide strings typically thousands nucleotides length alphabet characters wildcards replaced nucleotides 
parsed shorter strings extracting grams length 
grams commonly genomic search utilities locate regions longer inexact match may 
music data consists pieces midi format stored textual representation alphabet characters 
extract grams length music data approach indexing midi files 
cases grams overlapping approximately gram symbol grams extracted sliding window data consecutive block characters 
table shows statistics collections 
show skew distribution typical text 
music collection apart extremely common gram representing note played times sequence distribution fairly uniform 
genomic data uniform rarest grams occurring hundreds times show locality 
expected data sets lead poor behaviour burst tries aware practical data set worse 
methodology table statistics non text collections 
genomic grams music grams size mb distinct grams gram occurrences documents parsing time sec aims experiments explore different burst heuristics choices container structure identify yield performance compare burst tries principal data structures vocabulary accumulation 
comparison terms running time memory usage 
burst trie tested refined long period algorithms widely experiments confident implementations high quality 
experiments gather vocabulary statistics collections described 
process involves parsing data strings 
parsed term inserted data structure keeps set distinct terms vocabulary collection 
addition data structure stores term total occurrence frequency number documents occurs 
purpose comparing data structures vocabulary accumulation necessary include parsing time time retrieve data disk data structures 
report cpu times elapsed times exclude time taken parse collections strings 
load parsing times excluded elapsed times generally greater cpu times 
internal buffers machines flushed prior run order starting conditions experiment 
little variation observed repeated runs 
computers pentium iii mhz mb memory text collections pentium iii mhz mb memory genomic music collections 
run standard versions linux operating system 
data structures tested keep terms alphabetical order exception hash tables burst tries lists representing containers 
fair comparison data structures memory quicksort run hash tables burst tries list containers include time sorting reported times 
reported noticed standard strcmp string comparison function linux solaris highly inefficient 
replacing standard strcmp function code achieved speed gains experiments 
version strcmp experiments 
code hashing splay trees www cs rmit edu au hugh ipl html table running time seconds parentheses peak memory usage megabytes accumulate vocabulary text collection data structure 
web web web web xl web xxl trec trie tst bst splay acc 
splay int 
hashing results data structures set experiments measure time space requirements data structures compact tries simply refer tries bsts splay trees hash tables 
report measurements variants tree access fourth access intermittent efficient 
hash tables hash table slots bit wise hash function discussed earlier 
results text collections shown table 
times seconds peak memory usage mb parentheses 
runs impractical due space requirements marked hyphen 
trends obvious results 
tries compact variant experiments space structures practical accumulating vocabularies large collections 
separate experiment determined trie required mb accumulate vocabulary gb web data 
similar problems apply 
trie faster tree data structures able tst text collections larger gb 
tries slower hash tables 
trend confirming results data sets bsts slightly outperform variants splay trees running time memory usage 
data bsts slower due likelihood sorted data yielding poor behaviour 
reported earlier intermittent variant splay tree considerably faster access 
fastest data structure tested bit wise hashing requires memory 
table shows results genomic music collections 
due limited size genomic vocabulary distinct grams due lack locality tries efficient 
tree variants particular intermittent splay tree relatively worse genomic data web data 
genomic data effectively random past pattern accesses predictor accesses 
music data trie requires memory 
tst fast space hungry splay tree worked compared bsts due high locality music data individual pieces grams repeated table running time seconds parentheses peak memory usage megabytes accumulate vocabulary non text collections data structure 
genomic grams music grams trie tst bst splay acc 
splay int 
hashing table character comparisons string comparisons millions expected search lengths standard deviation parentheses data structure trec web trec web chars strings search len chars strings search len trie splay int 
bst hashing times absence equivalent common words text 
cases hashing shown performance 
nature genomic data purpose built hash function perform better 
measure data structure number character string comparisons required expected search length 
table shows statistics data structures accesses consistently worse respects intermittent 
show results collections similar relative behaviour observed collections 
table number character comparisons total count characters inspected access trie nodes strings string comparisons 
number string comparisons number invocations utility occurs node hashing trees occasionally trie unique suffix encountered 
hash tables cost inspecting string compute hash value included 
expected search length computed string storing number times searched expected search length computed string multiplying cost accessing string depth tree frequency occurrence 
adaptive structures expected search length changes access access averaged expected search length sequence snapshots searches 
burst tries having established benchmarks data structures explored performance burst tries 
ran experiment burst heuristics different container data running time sec list bst splay tree memory mb space time burst trie ratio burst heuristic variety parameters trec 
parameter value shown side third point 
structures data sets 
ratio results ratio burst heuristic trec shown 
graph shows behaviour expected ratio increased burst trie faster containers get smaller larger due increased numbers trie nodes 
example ratio burst trie splay tree containers uses mb seconds comparison table slightly space trees running half time 
curve burst trie splay tree containers ratio requires mb seconds faster tree trie approach slightly memory tst 
container structures lists bsts splay trees yield similar curve 
ratios achieve particular points curve vary 
example bst ratio efficient list ratio 
list nodes uses space bst nodes efficient lists require higher ratio efficiency 
results extremely promising burst trees outperform tree structures vocabulary accumulation 
similar behaviour ratio observed web collection shown 
note different axis scales different data sets 
observed similar behaviour minimum number accesses increased varying ratio impact space consumption 
running time sec list bst splay tree memory mb space time burst trie ratio burst heuristic variety parameters web parameter value shown immediate right third point 
limit results limit burst heuristic trec shown 
results show different picture 
extremely small containers limit greatly outperforms ratio container structures 
bst containers faster memory list splay tree containers 
best results limit show burst tries efficient tree trie structure 
example slowest run bsts containers limit uses mb requires seconds 
memory existing tree structure tested standard bsts faster tries times faster bsts splay trees 
hashing faster 
similar results web shown 
contrast trec controlled relatively typing errors limited topic source web uncontrolled 
relative behaviour different container structures consequence different clear bsts best container structure similar values done 
results bst containers limit heuristic text data sets shown table 
show gains achieved burst tries comparison data structures consistent data sets 
results data sets shown table 
hand genomic data burst trie slower tst half speed hashing 
faster tree structures compact data structures tested 
hand music data burst trie showed best performance observed faster data structure tested including hash tables space utilisation 
running time sec list bst splay tree memory mb space time burst trie limit burst heuristic variety parameters trec 
parameter value shown immediately point 
table running time seconds parentheses peak memory usage megabytes accumulate vocabulary text collection burst tries bst containers limit heuristic 
web web web web xl web xxl trec heuristics burst trie gave better performance genomic data cost greater space utilisation 
report results heuristics effective data sets 
limit tested effect sorting terms frequency prior bursting 
omission sorting reduces proportion direct hits total impact increase running time 
frequencies stored performance obtained 
results extremely promising illustrated burst trees faster trie smaller bst 
interesting feature exception genomic data consistent data sets 
interesting feature highly surprising burst tries showed relative performance scales 
web xxl times larger web comparison tree structures speed memory consumption unchanged 
burst tries require space bst fast conventional trie 
running time sec list bst splay tree memory mb space time burst trie limit burst heuristic variety parameters web parameter value shown immediately point 
table running time seconds parentheses peak memory usage megabytes accumulate vocabulary non text collections burst tries bst containers limit heuristic 
trend genomic grams music grams explored parameter combinations trend burst heuristic 
typical set results shown varied parameters held constant 
expected heuristic best lead containers burst rapidly held common terms slowly results approach limit 
despite wide investigation identify combinations parameters significantly better performance shown graphs 
analysis experiments reported case folded strings limited total alphabet symbols 
possible doing favour tries burst tries particular node size kept small 
tested effect larger alphabet web case folding increasing node size symbols occur strings 
trees burst tries increase space larger running time sec bst splay intermittent burst burst hashing ternary trie memory mb space time data structures burst trie limit burst heuristic trec 
table character comparisons string comparisons millions expected search lengths standard deviation parentheses burst tries bst containers limit burst heuristic trec web trec web chars strings search length chars strings search length 
trees tries slightly slower 
case folding little impact relative performance data structures 
addition space speed data structures measured numbers character string comparisons expected search lengths 
similar results burst tries reported table 
compared tree data structures burst trie requires tenth fifth string comparisons third character comparisons 
burst trie requires fewer comparisons hashing 
shows reason burst trie slower hashing hashing smaller number pointers need followed believe hashing able better cpu cache 
set experiments contrasted search performance burst trie search performance splay tree hashing 
experiments processing data set build structure searched string occurrences data set 
second search phase insertions allowed limit trie running time sec list bst splay tree memory mb space time burst trie trend burst heuristic variety container structures trec 
parameter value shown immediately adjacent point fixed 
table running time seconds searching data structures term occurrences web xxl trec web xxl prime data structure 
trec web xxl splay int 
hashing burst trie burst trie heuristic bursting occurs 
results experiments shown table cases 
case trec build data structure searched string occurrences web xxl 
collection web xxl contains terms smaller trec searches successful 
second case web xxl build data structure searched string occurrences web xxl 
searches query term guaranteed successful 
results show static burst trie gives performance show hashing able achieve slightly better results previously 
cases yield similar results due fact case vocabularies trec web xxl different vast majority searches successful 
interestingly splay tree shown degradation increase vocabulary size 
experiments observed expected search lengths splay trees high markedly degrade increasing collection size slowly grow expected search length trec web number words observed expected search length intermittent splay tree trec web collections 
techniques 
trends search lengths illustrated detail figures show expected search lengths series snapshots splay trees burst tries trec web estimate trends continue indefinitely dubious supposition scale extrapolation required splay trees slowest data structure collections tens terabytes 
related standard trie structures outlined section understood 
tries proposed de la term trie coined fredkin derivative information retrieval 
tries widely represent set strings dictionary management 
range applications encompasses natural language processing pattern matching searching reserved words compiler ip routing tables text compression 
balanced tries represented single array data structure dynamic hashing 
broad range applications justifies view tries general purpose data structure properties understood 
experiments confirmed tries fast space intensive 
high memory usage tries long recognized serious problem techniques proposed reduce size 
proposals modifications tries address issue high memory usage broadly placed groups reduction trie node size reduction number trie nodes 
trie node size depends data structure represent trie node 
trie node implemented ways particular array size alphabet array expected search length trec limit trec limit web limit web limit number words observed expected search length burst trie bst containers limit heuristic trec web collections 
trie method experiments linked list stores non empty children subtrees list trie 
list implementation offers space savings trie node children array fixed size consist largely null pointers 
space savings come expense linked list traversal node simple array lookup 
proposed modified form linked list implementation trie called double chained tree children node placed list linked list implementation explained 
addition list node contains pointer list children 
theoretical analysis list trie suggested expected search time minimised list trie nodes branching keys 
branching keys kept directly node linked list sequentially accessed 
analysis concerns slow variant tries applied array tries 
option implement trie node binary search tree 
bentley sedgewick propose tst trie nodes binary search trees 
clement analyse test hybrid trie structures 
array tries list tries bst tries shown logarithmic access costs different constants 
array trie implementation experiments lowest access cost highest memory cost 
list tries reported need times comparisons tst reported ninth storage cost array trie 
results confirm lower memory requirements array trie extent 
described clement method choice managing textual data hybrid trie structures offer best time space trade 
result led adopt tst data structure 
aoe describe algorithm compaction trie applicable dynamic set keys 
principle separate tries constructed front rear keys observation strings share common prefixes suffixes 
space savings trie structure compared compact trie experiments reported insertion retrieval time trie reported similar non compacted standard trie 
compact tries trie structure practical large set keys 
second group proposals reduce size tries address number trie nodes 
standard trie characters strings represented pointers trie nodes 
natural language applications trie nodes near leaf levels tend sparse 
sparsity arise example genomic data 
simple way reduce number trie nodes omit chains nodes single descendant lead leaf 
variant trie sticks caused single descendant nodes eliminated refer compact trie array implementation compact trie experiments 
patricia tries generalize idea collapsing sticks single node important variant trie widely analysed 
single descendant nodes omitted patricia trie just lead directly leaf node 
nodes eliminated keeping branch counter indicate element key example character position string determines branching 
search character positions skipped discriminate strings stored levels trie 
avoid false matches final comparison performed query string string leaf node search terminates 
alternatively substring representing single branch stored counter described alternative implementation known compact patricia trie 
implementations lead decrease number trie nodes saving partly offset complex structure complex traversals 
value patricia optimisation depends nodes single descendant 
trec nodes compact trie single descendant similar percentage web reduction number nodes compared compact trie patricia trie larger tst collection 
patricia trie complex compact trie yield higher access costs average especially single descendant nodes compact trie rarely visited nodes single descendent nodes visited processing trec web interestingly patricia optimisation little value burst tries 
limit heuristic number single descendant nodes small trec nodes single descendant nodes web access trie nodes single descendant nodes 
descriptions patricia tries node pointers bit byte determine pointer follow 
pointer traversals major contribution running time 
digital trie typically traversals required short string unacceptable cost 
digital trie potentially compact character trie set strings sparse space highly restricted option access trie 
related structure lc trie dynamic variant lpc trie 
digital tries level compression addition path compression patricia tries 
clear compression cheaply maintained digital tries general large data sets traversal costs significant 
candidate alternative access trie mechanism space restricted fast easy maintain 
way reduce size trie orthogonal ideas mentioned 
idea change order letters string tested 
string length viewed tuple attributes 
changing order attributes influence size result trie 
unfortunately problem determining order attributes leads smallest trie np complete useful static set keys 
heuristics proposed minimize static trie locally optimizing order attribute testing 
comer proposed order containing trie trie space efficient implementation trie 
trie keeps node information attribute test 
static trie built attribute testing subtrees reordered reduce size trie 
approaches trie compaction likewise applicable static tries 
horowitz propose conserving memory overlaying nodes trie empty pointers node occupy location full pointers 
proposed reduction size trie node compressed bitmap node indicate children slots 
overhead compression scheme applicable static tries fast array trie 
ramesh investigated problem finding compromise memory usage low access costs trie 
idea collapse subtrees trie nodes completely store suffix strings represented subtree bst leaf node trie 
propose heuristics transform trie set strings optimized trie 
heuristic designed meet objective resulting trie minimal number trie nodes worst case binary search time exceed fixed quantity 
minimizes worst case binary search tree maximal number trie nodes 
additional heuristic tries solve objectives 
heuristics applied dynamic sets strings ramesh similarities 
important difference approach intended dynamic set strings 
innovation grow approximation trie smoothly starting container ramesh start static trie transform subtrees trie bsts 
possible build trie large text collection memory requirements heuristics described ramesh 
proposals discussed re interpreted light proposals proposals share idea terminology storing suffixes strings containers 
related proposal trie block size disk block allowing trie disk access structure 
contrast undertaken large scale practical investigation wide range alternative container designs burst heuristics identified relationship string frequency string length important contributor efficiency 
largely theoretical earlier papers explore bursting proceed investigate relationship space speed focus space identified scale space savings available practice proposed structures general 
analytical szpankowski relevance 
papers theoretically explore height tries strings different distributions include case multiple strings held single trie leaf 
establish bounds height terminology burst tries 
results show markovian model burst tries expected relatively flat branches exceeding log length number strings determined distribution 
described burst trie variant form trie highly efficient managing large sets strings memory 
burst trie leaf holds set strings container allowing dramatic space reductions impact efficiency 
explored wide range options managing burst trie including different container structures different heuristics deciding burst different techniques bursting 
large scale experiments variety real data sets shown burst tries faster compact tries sixth space compact binary trees splay trees times faster close hash tables efficiency keep data sort order 
results demonstrate burst trie dramatically efficient previous structure task managing sorted strings 
improvements data sets ranging mb gb size 
text data gains common strings typically shorter strings stored wholly access trie 
rare strings held containers typically long loss efficiency cost searching container offset saving having traverse large number trie nodes 
savings allow memory processing larger sets strings previously possible time 
performance burst trie depends distribution strings 
worst case observed genomic data strings equal length relatively flat probability distribution 
case performance comparable tree structures 
analytical results shown height burst trie expected logarithmic 
believe burst trie data structure choice practical string management 
supported australian research council 
adam sam anonymous referees detailed comments 
aho hopcroft andj ullman 
data structures algorithms 
addison wesley reading massachusetts 
aho sethi ullman 
compilers principle techniques tools 
addison wesley reading massachusetts 
horowitz 
algorithms trie compaction 
acm transactions database systems 
andersson nilsson 
improved behaviour tries adaptive branching 
information processing letters june 

aoe morimoto sato 
efficient implementation trie structures 
software practice experience september 

aoe morimoto 
park 
trie compaction algorithm large set keys 
ieee transactions knowledge data engineering 
baeza yates gonnet 
fast text searching regular expressions automaton searching tries 
jour 
acm 
bell gupta 
evaluation self adjusting binary search tree techniques 
software practice experience 
bell cleary witten 
text compression 
prentice hall englewood cliffs new jersey 
bentley sedgewick 
fast algorithms sorting searching strings 
proc 
annual acm siam symp 
discrete algorithms pages new orleans louisiana 
acm siam 
clement flajolet vall analysis hybrid trie structures 
proc 
annual acm siam symp 
discrete algorithms pages san francisco california 
acm siam 
clement flajolet vall dynamic sources information theory general analysis trie structures 
algorithmica 
comer 
heuristics trie minimization 
acm transactions database systems september 
comer 
analysis heuristic trie minimization 
acm transactions database systems 
comer sethi 
complexity trie index construction 
jour july 
de la 
file searching variable length keys 
proc 
western joint computer conference volume nj usa 
afips press 
devroye 
study trie structures density model 
annals applied probability 
fagin nievergelt pippenger strong 
extendible hashing fast access method dynamic files 
acm transactions database systems 
flajolet 
performance evaluation extendible hashing trie searching 
acta informatica 
flajolet puech 
partial match retrieval multidimensional data 
jour 
acm 
flajolet sedgewick 
digital search trees revisited 
siam jour 
computing 
edward fredkin 
trie memory 
communications acm september 
gonnet 
handbook algorithms data structures 
addison wesley reading massachusetts 
harman 
overview second text retrieval conference trec 
information processing management 
jacquet szpankowski 
analysis digital tries markovian dependency 
ieee transactions information theory september 

results digital search trees 
editor automata languages programming volume lecture notes computer science pages rennes france 
springer verlag 
szpankowski 
note asymptotic behavior height tries large 
electronic jour 
combinatorics 
knuth 
art computer programming volume fundamental algorithms 
addison wesley reading massachusetts 
knuth 
art computer programming volume sorting searching second edition 
addison wesley massachusetts 
mart nez 
randomized binary search trees 
jour march 
mccreight 
space economical suffix tree construction algorithm 
jour 
acm 
morrison 
patricia practical algorithm retrieve information coded alphanumeric 
jour 
acm 
nevill manning witten 
protein incompressible 
storer cohn editors proc 
ieee data compression conf pages snowbird utah 
nilsson karlsson 
ip address lookup lc tries 
ieee journal selected areas communication june 
nilsson 
implementing dynamic compressed trie 
mehlhorn editor proc 
second workshop algorithm engineering pages max planck institut informatik saarbr cken germany august 
peterson 
computer programs detecting correcting spelling errors 
communications acm 

compressing tries storing dictionaries 
roach editors proc 
ieee symposium applied computing pages april 
ieee 
jacquet szpankowski 
limiting distribution depth patricia tries 
siam jour 
discrete mathematics 
ramakrishna zobel 
performance practice string hashing functions 
topor tanaka editors proc 
int 
conf 
database systems advanced applications pages melbourne australia april 
ramesh babu peter kincaid 
variable depth trie index optimization theory experimental results 
acm transactions database systems 
regnier jacquet 
new results size tries 
ieee transactions information theory january 
rivest 
partial match retrieval algorithms 
siam jour 
computing 

identifier search mechanisms survey generalized model 
computing surveys 
sleator tarjan 
amortized efficiency list update paging rules 
communications acm february 
sleator tarjan 
self adjusting binary search trees 
jour 

tree structures processing files 
communications acm 
szpankowski 
patricia tries revisited 
jour 
acm 
szpankowski 
height digital trees related problems 
algorithmica 
szpankowski 
average case analysis algorithms sequences 
john wiley sons new york 
zobel 
melodic matching techniques large music databases 
jeffay zhang editors proc 
acm int 
multimedia conf pages orlando florida november 
williams zobel 
indexing retrieval genomic databases 
ieee transactions knowledge data engineering 

williams zobel 
searchable words web 
submission 
williams zobel heinz 
splay trees practice large text collections 
software practice experience 

witten bell 
source models natural language text 
int 
jour 
man machine studies 
witten moffat bell 
managing gigabytes compressing indexing documents images 
morgan kaufmann san francisco california second edition 
zobel heinz williams 
memory hash tables accumulating text vocabularies 
information processing letters 


