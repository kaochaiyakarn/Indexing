weakest precondition reasoning java programs jml annotations bart jacobs dept computer science univ nijmegen box gl nijmegen netherlands 
bart cs kun nl www cs kun nl bart july 

distinguishes di erent approaches organising weakest precondition wp calculus theorem prover 
implementation approaches java loop project described 
involves wp infrastructures higher order logic theorem prover pvs associated rules strategies automatically proving jml speci cations java implementations 
soundness wp rules proven basis underlying java semantics 
wp calculi integrated existing hoare logic form veri cation toolkit pvs typically uses hoare logic rules break large veri cation task smaller parts handled automatically wp strategies 
loop project works theorem prover reasoning sequential java programs 
uses interface speci cation language jml formulate correctness properties veri ed :10.1.1.34.8403
typically consist class invariants method speci cations 
written special comments java code 
loop project special compiler known loop tool translate java programs speci cations language back theorem prover usually pvs jml speci cations predicates proved interactively translated java implementations 
current situation basic veri cation technology proven case studies 
orts invested incorporating sophisticated aspects model variables speci cation language jml translation scaling proof technology larger examples primarily reducing user interaction required developing powerful program logics associated proof strategies 
contributes second point describing weakest precondition calculi java jml 
takes proof engineering perspective focusing performance scalability tool assisted handling non trivial veri cation tasks 
known wp calculus rules computing program post condition precondition wp hoare triple fpg fqg holds 
weakest predicate triple holds expressed familiar equivalence frg fqg wp famous rules assignment composition wp wp wp wp challenge extending approach java far complicated language constructs java usually considered wp calculi exceptions expressions side ects 
challenge appears wishes incorporate wp calculus theorem prover rst done gordon 
complicated languages java jml ort goes proof engineering organising material way automatic veri cation non trivial examples computationally feasible 
important keep size number proof goals control 
comes wp calculi theorem prover support distinguish di erent setups 
wp function inside logic 
prime example approach 
gives deep embedding simple language expressions having side ects associated assertion language language theorem prover hol 
wp calculations performed actual function hol form wp command assert assert list assert command postcondition result wp yields precondition list veri cation conditions 
main result proven hol combined assertions imply fpg fqg 
type command inductive type deep embedding function wp de ned induction 
loop project uses shallow embedding java pvs 
inductive de nition internal wp function impossible 
impredicative de nition form wp def fpg fqg de nes wp union predicates fpg fqg 
familiar equations proved de nition 
shall elaborate approach adapted java section 
wp function outside logic 
second approach wp calculations done outside theorem prover generated veri cation conditions fed prover 
approach followed jive project esc java static checker instance 

loop project hoare logic jml developed 
works requires relatively user interaction 
main design goals wp calculi integrate smoothly existing hoare logic 
allows wp calculi hoare logic proof instance complete proof certain branch step intermediate assertion 
integration hoare logic weakest precondition reasoning advocated 
starting point wp calculi tuples predicates hoare logic jml 
reviewed section 
turns options wp calculus logical perspective proof engineering point view theorem prover 
instance wp rules forward backward style 
various options theoretically total described section 
implemented pvs approaches called nested forward external nfe flat backward internal fbi 
nfe basically classical wp calculus adapted java jml fbi optimised variation 
calculi nfe fbi described sections respectively 
explained certain cases version works better way round cases 
result new pvs commands called nfe assert fbi assert existing hoare logic form main ingredients veri cation tool set 
related wp calculi java prominently extended static checker java esc java jive tool 
substantial di erences approaches apart mentioned di erence having wp function inside outside theorem prover 
esc java static checker back theorem prover invisible user 
checker works fast assertions limited complexity 
sound complete trap surprisingly program errors null pointer array bound violations 
contrast loop project arbitrarily complex assertions veri ed requires substantial user interaction 
esc java works translating java intermediate guarded command language wp calculus dedicated theorem prover 
works invisible user 
explicit wp rules java 
approach follow closer jive tool 
di erences 
jive wp rules act java program text translation theorem prover 
jive rules cover part sequential java certain amount desugaring translation intermediate simpli ed language 
jive tool works veri cation condition generator proof obligations back theorem prover handled separately 
proof obligations involve assertion language contain program constructs 
approach stay system pvs special rewrite rules pvs decomposing program handling resulting veri cations 
organisation exposition starts non trivial veri cation example context java smart cards 
put rst give reader impression scale issues dealing 
subsequently focuses wp calculi 
rst describes general terms various options implementing wp calculus 
focuses setting loop project 
section recalls basics representation java statements expressions higher order logic associated hoare logic ary tuples 
section explains nfe calculus higher order de nition wp function properties 
section continues fbi calculus incorporates di erent approach 
infrastructure turns complicated 
section wraps concluding remarks 
assumed reader reasonably familiar setting working 
particular nodding acquaintance jml coalgebraic semantics hoare logic loop project helpful :10.1.1.34.8403
presentation stay reasonably close actual implementations pvs try give purely logical calculus 
original motivation get runnable wp calculus theorem prover 
phone card example currently main application area veri cation java card smart cards 
involves jml speci cation veri cation api smart card applets 
section consider simple phone card applet keeps track certain byte balance enabling phone calls 
possible set balance eld initially card issued 
means applet needs eld issued type bool initially set false set true soon balance eld initial value 
represents rudimentary life cycle model 
moment possible decrease balance eld consult current value balance eld 
behavior requires null modifiable balance issued buffer ensures old issued balance signals old issued old balance old buffer iso offset ins ins issued old issued balance old balance signals issued old issued balance old balance public void process byte buffer balance iso sw security status satisfied switch buffer iso offset ins case ins balance break case ins short buffer balance short short break case ins issued iso sw security status satisfied balance buffer iso offset issued true break fig 

java code plus jml annotation process method phone card applet 
smart cards instructed perform certain operations called structured byte sequences containing instructions data iso speci cation see chapter 
byte sequences exchanged terminal client card server 
java card applet special process method responsible managing incoming command applet selected 
command contains instruction byte examined process method 
error occurs corresponding arises 
runtime exception 
process method java card implementation simple phone card applet jml speci cation 
contains keywords requires method precondition ensures postcondition case normal termination signals postcondition case abrupt termination caused exception modifiable items may changed method 
special instruction bytes relevant commands chosen static final abbreviated ins ins ins respectively 
note card rendered useless value balance reaches zero 
process method checks balance zero simply throws exception examining incoming object 
exceptions type thrown java card applet show terminal side special return codes response 
key property application expressed ensures clause card issued remain issued balance decrease 
property expressed relation pre state indicated old post state 
additionally rst signals clause guarantees thrown happens card issued pre state original balance nonpositive instruction set balance cases elds issued balance remain 
second signals clause tells runtime occurs issued balance elds remain unchanged 
applet developer may want show properties customer 
course developer rst wants sure properties hold 
aim explain precise meaning aspect process method give reader impression sort veri cation challenges relevant setting 
particular note process method involves various alternatives switch array operations method invocations static 
veri cation speci cations methods shown 
thing correctness jml speci cation proven automatically pvs nfe wp approach see section requiring basically user interaction apart starting preparatory commands 
comes close push button technology esc java 
veri cation takes half hour ghz pentium 
resulting consists commands 
ne applications informative setting 
instruct pvs show wp steps executed implicitly running proof mode 
structure resulting expanded 
wp veri cation involves subgoals generated wp rules rst branches right arise manual splits 
veri cation carried forward wp strategy proof structure closely follows program structure instance rst split left results precondition rst method invocation 
subsequently big split due rst 
resulting left branch splits identical subtrees dealing entire switch 
split arises rule discussed section 
jml start auto rewrite case static invariant static invariant iso apply 
apply auto rewrite wp assert apply semantic assert apply auto rewrite theory 
rewrite composition nfe nfe nfe ce nfe nfe meth nfe ifthenelse nfe andthen nfe int le nfe nfe const nfe nfe nfe switch nfe nfe nfe const nfe cons nfe const nfe cons nfe const nfe cons nfe const nfe null nfe skip nfe composition nfe composition nfe ifthenelse nfe nfe composition nfe nfe nfe nfe nfe const nfe nfe nfe const nfe break nfe composition nfe composition nfe nfe ce nfe nfe meth nfe composition nfe cs nfe nfe nfe const nfe meth nfe composition nfe nfe nfe nfe const nfe nfe composition nfe cs nfe nfe nfe const nfe nfe const nfe meth nfe break nfe composition nfe composition nfe nfe expr composition nfe nfe nfe int dec nfe nfe break nfe int le nfe nfe const nfe nfe switch nfe nfe nfe const nfe cons nfe const nfe cons nfe const nfe cons nfe const nfe null nfe skip nfe composition nfe composition nfe ifthenelse nfe nfe composition nfe nfe nfe nfe nfe const nfe nfe nfe const nfe break nfe nfe nfe const nfe meth nfe composition nfe composition nfe nfe ce nfe nfe meth nfe composition nfe cs nfe nfe nfe const nfe meth nfe composition nfe nfe nfe nfe const nfe nfe composition nfe cs nfe nfe nfe const nfe nfe const nfe meth nfe break nfe composition nfe composition nfe nfe expr composition nfe nfe nfe int dec nfe nfe break nfe andthen nfe int le nfe nfe const nfe nfe nfe const nfe meth nfe int le nfe nfe const nfe auto rewrite auto rewrite 
auto rewrite auto rewrite 
auto rewrite 
auto rewrite auto rewrite auto rewrite auto rewrite auto rewrite auto rewrite auto rewrite auto rewrite 
auto rewrite 
auto rewrite auto rewrite auto rewrite auto rewrite auto rewrite auto rewrite 
auto rewrite auto rewrite auto rewrite auto rewrite auto rewrite nfe pre implies post 
nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post 
nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post 
nfe pre implies post 
nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post nfe pre implies post rewrite byte byte rewrite byte byte fig 

expanded nfe wp proof process method 
second wp implementation called fbi see section unable handle process veri cation 
crashes running day 
logical problem computation resources instance current pvs distribution version pvs process grow bigger 
similarly isabelle bounds 
crash happens fbi approach proof obligations collected saved giving prover eventually plate illustrates importance proper proof engineering 
topic continue 
options wp calculus theorem prover section illustrate di erent options choose wishes implement wp calculus theorem prover 
options highly relevant ultimate performance 
logical perspective essentially 
forward versus backward reasoning 
recall equation wp wp wp composition 
step decide continue rst second wp right hand side equation 
forward approach rst computes wp backward approach rst evaluates wp 
common rules prevents reasoning forward style 
sense intuitive follows ow control 
instance forward style computes wp wp leaves substitution continues calculating wp substitution 
pvs implementation substitution corresponds function application unproblematic 
theorem prover leave choice forward backward rewriting strategy theorem prover 
write dedicated strategy chooses particular approach 
nested versus wp applications 
right hand side wp wp composition rule sees nested applications 
large programs repeated application composition rule may lead large complicated proof goals dicult manage 
forward backward strategy rst relevant may wish atten nested applications develop slightly di erent wp calculus wp application 
obvious way realise lists statements wp hs single statement 
call approach opposed standard nested approach 
approach calculate backwards predicate rst statement list 
composition rule idea decompose statement atomic form ect immediately incorporated postcondition 
fair examples nfe crashes nesting goes deep fbi nishes proof 
examples rare 
shall see section language java ects expressions lists contain statements expressions 
external versus internal preconditions 
see order prove hoare formula fpg fqg prove implication wp 
precondition external wp formula 
completely standard 
theorem prover replaces implication turnstile wp precondition 
pn may simpli ed separately 
gives huge performance gains larger applications may easily attened separate assumptions 
written normal form loaded auto rewrites repetition subsequent proof branch 
certain rules especially loops convenient precondition external 
typically rules involve suitable invariant predicate decreasing variant function inserted subsequent wp calculations 
invariant minor variation addition existing precondition 
precondition fully decomposed turnstile easy get back wp function 
sense carry precondition wp calculations wp 
call internal approach 
essentially amounts calculating hoare triples 
mentioned performance gains external approach 
loop projects wp calculi implemented involving times di erent option rules strategies external nfe approach see section flat fbi approach see section 
nfe approach works ordinary wp applications wp fbi approach uses non standard format wp hs 

noted implementing wp calculus sequential java non trivial ort couple months 
wp rules calculus involve roughly handwritten pvs code proved separately 
furthermore appropriate associated pvs strategies written lisp evaluated examples 
combinations possible implemented versions nfe fbi sense 
describe wp calculi nfe fbi detail rst need explain bit semantic setting loop project 
java statements expressions hoare logic start explaining basic framework working 
concretely exists form pvs theories shall general type theoretic terms labeled product lab 
lab coproduct lab 
lab types hopefully self explanatory notation 
key ingredient java semantics loop project type om object memory various get put operations see 
java statements expressions translated functions om statresult om suitable output type result types de ned labeled coproduct called variant sum types statresult type def hang unit norm om abnorm type def hang unit norm ns om res abnorm labels hang norm abnorm corresponding termination modes java non termination normal termination abrupt termination 
notice normally termination expression returns state incorporating possible side ect result value 
indicated labeled product record type ns om res 
types abrupt termination subdivided di erently statements expressions type def excp es om ex reftype om break bs om blab lift string cont cs om lift string type def es om ex reftype type reftype containing null pointer memory location 
describes exception object case exception thrown 
lift type constructor adds bottom element bot arbitrary type keeps original elements break continue statements java label represented string 
basis representation statements expressions language constructs sequential java formalised type theory translation performed loop tool see instance 
various termination options java statements expressions incorporated special extended hoare tuples jml described 
translate jml speci cations pvs analogous structure 
recall main de nitions 
labeled product types hoare tuples type def diverges om boolean requires om boolean statement om statresult ensures om boolean signals om reftype boolean return om boolean break om lift string boolean continue om lift string boolean type def diverges om boolean requires om boolean expression om ensures om boolean signals om reftype boolean hoare tuple terms sbs ebs types meaning functions sb eb described 
ordinary partial hoare triple setting fpg fqg sb 
diverges true requires statement ensures signals true return true break true continue true says precondition holds statement terminates normally postcondition holds 
notice case true false says terminate normally case hold giving total hoare triple 
general tuples conveniently allow expressive program logic structure method speci cations jml nested forward external weakest precondition calculus section describes rst wp calculi java closest standard wp calculus 
starts exploration appropriate postconditions java statements expressions 
gives higher order de nition wp functions java statements tuples hoare logic closely correspond di erent termination options distinguished coalgebraic representation statements expressions result types statresult 
program logic follows structure program semantics 
sbs sb 
sbs boolean def om sbs requires 
cases sbs statement 
hang 
sbs diverges 
norm 
sbs ensures 
abnorm 
cases excp 
sbs signals 
es 
ex 
sbs return 
break 
sbs break 
bs 
blab cont 
sbs continue 
cs 
ebs eb 
ebs boolean def om ebs requires 
cases ebs expression 
hang 
ebs diverges 
norm 
ebs ensures 
ns 
res abnorm 
ebs signals 
es 
ex fig 

interpretation hoare tuples statements expressions 
java expressions satisfying analogues 
de nition standard properties wp function proved 
illustrated language constructs 
section discuss proof engineering nfe aspects 
previous section seen labeled product types containing appropriate entries reasoning jml speci cations 
extract entries relevant post condition types 
type def diverges om boolean ensures om boolean signals om reftype boolean return om boolean break om lift string boolean continue om lift string boolean type def diverges om boolean ensures om boolean signals om reftype boolean wp functions java statements expressions de ned functions wp 

sps wp 

eps om boolean sps eps 
functions wp wp compute precondition predicates type om boolean 
pvs simply overloaded notation wp functions shall explicit subscripts statements expressions 
aside non standard postconditions types combination di erent predicates di erent output modes java 
principle standard postconditions combine possible outputs single mode special auxiliary variables way looses clarity 
furthermore single mode composition rule wp wp null null wp special auxiliary variable exceptions non null exception thrown 
principle variable return break continue abnormalities 
means composition step proof goal grows considerably size 
may real problem 
avoided keeping di erent output modes logic 
om statresult sps wp 

sps om boolean def om pre om boolean pre 
sb 
diverges sps diverges requires pre statement ensures sps ensures signals sps signals return sps return break sps break continue sps continue om eps wp 

eps om boolean def om pre om boolean pre 
eb 
diverges eps diverges requires pre expression ensures eps ensures signals eps signals fig 

higher order de nitions wp functions statements expressions 
higher order impredicative de nition wp functions analogy 
direct consequence de nitions analogues de ning equivalence hold 
statements means 
sb 
diverges requires statement ensures signals return break continue om 
wp 

diverges ensures signals return break continue 
similarly expressions 
rules move hoare style proof wp proof 
wp wp functions done implication right hand side remains proved 
automatically done pvs special command called semantic assert 
involves dedicated strategies dealing typical patterns occur jml assertions modi able clauses 
semantic assert complete complicated proof goal additional user interaction needed 
entirely trivial appropriate properties wp functions proved de ned functions wp wp contrast setting deep embedding language properties hold inductive de nition 
derivable results exist setting java try catch nally switch new array access assignment method calls instance rule composition takes form wp 

sps 
wp 

sps ensures wp 

sps 
obvious record update operation 
rule requires predicate sps diverges constant form om boolean true false 
associated pvs strategy choose wp calculus forward continuing wp 
rewriting composition rule 
similarly translation pvs java return statement return om abnorm om statresult associated equation wp 
return 
sps 
sps return 
nal illustration rule java conditional conjunction operation follows constant predicate diverges clause 
wp 

diverges ensures signals 
wp 

diverges ensures 

false signals 
wp 

diverges ensures wp 

diverges ensures signals 
signals 
sees crucial property conditional second argument evaluated anymore case rst argument evaluates false 
rule conjunction right hand side leads subsequent proof goals evaluates false evaluates true nested wp 
brie discuss soundness proof rule 
direction de nition wp gives predicate pre pre 
eb 
diverges requires pre expression ensures signals 
outer wp functions right hand side rule unfold existential quanti cation 
instantiate predicate pre 
rst conjunct holds immediately 
second interesting case evaluates normally pair ns res true result true successor state case second nested wp unfolds existential quanti cation 
instantiated predicate direction assume wp conjuncts right hand side 
existential quanti ers give rise appropriate preconditions say pre pre instantiates left hand side pre 
pre 
job 
wp calculus includes rule method invocation 
rules void methods statements non void methods expressions 
follow standard formulation chapter 
instance assume non void method parameters speci cation 
om eb 
diverges requires 
expression ensures 
signals 
note speci cation contains logical variable capture 
needed jml post conditions may involve expressions old require evaluation pre state see 
postconditions really relations 
case non void method say result type type normal postcondition om om boolean 
similarly exceptional postcondition type om om reftype boolean reftype type exception objects 
associated wp rule call method 












wp 

diverges ensures 
signals 

applied upward direction leads subsequent subgoals 
proof engineering perspective note rst subgoal 
precondition usually easy prove 
subgoals consist quanti ed implications assumptions moved turnstile decomposed written normal form installed auto rewrites 
ecient immediately 
implications typically wp formulas computations continue forward style 
applied statement prove wp function wp equal existential formula analogously de nition 
associated standard result invariant predicate variant function statement put automatic external implementation explained section 
logical problem proof engineering 
currently limitation nfe approach 
flat backward internal weakest precondition calculus section describes second wp calculus working assertions form wp sequences statements internal precondition explained section 
turns infrastructure fbi calculus involved nfe previous section 
occupy section 
stress complicated infrastructure concern user hidden user applies high level pvs command 
diving technicalities shall try convey main idea informal notation 
suppose sequence statements command assignment structured expression wp rules situation follows 
wp hs ei wp hs ii means evaluates wp hs wp hs wp hs wp calculus single wp function working lists idea writing statement expression list atomic form ect incorporated postcondition 
simple idea works item list catch statement exceptions returns breaks continues 
case careful abnormalities arising preceding list arising body catch statement caught 
shall distinction creating call detour 
wp calculus complicated 
combining statements expressions mentioned brie section fbi calculus java involves lists statements expressions 
requires supertype statement expression results injected 
type called involves type variables various possible outcomes abnormal termination 
abstraction somewhat mysterious stage clear subsection realise required detour abnormalities 
type def hang om norm ns om rs boolean excp es om es rs om rr brk bs om blab cont cs om notice normal case output type boolean 
shall combine statements expressions functions single type om common codomain 
happens functions certain translation functions parameters 
te reftype tr unit tb lift string tc lift string 
te 
tr 
tb 
tc om statresult 
om def cases 
hang 
hang norm 
norm ns res true abnorm 
cases excp 
excp es es ex te 
ex 
rs tr 
break 
brk bs bs blab tb 
blab cont 
cont cs cs tc 
unit singleton type sole inhabitant 
notice true inserted irrelevant output normal case 
abnormal cases translation functions map outcomes appropriate parameter types similar function expressions 
requires translation function extra argument capture result expression 
te reftype 
te 
om 
om def cases 
hang 
hang norm 
norm ns ns res res abnorm 
cases excp 
excp es es ex te 
ex notice equation boolean output normal case 
binds result expression parameter time side ect expression passed 
hoare tuples lists earlier section mentioned wp functions wp formalising fact special hoare tuples 
seen combination types hoare tuples section 
combination called lists functions type om principle try de ne appropriate composition operation functions type om idea followed 
label ses statement expression stack type def diverges om boolean requires om boolean ses list om ensures om boolean signals om boolean return om boolean break om boolean continue om boolean meaning wp tuples seb 
describes states om satisfying precondition appropriate postcondition holds evaluation list statements expressions starting evaluation done special function de ned subsequently 
seb seb 
seb boolean def om seb requires 

seb ses 
assump true kind norm 
ns res true assump cases kind hang 
seb diverges 
norm 
seb ensures 
ns excp 
seb signals 
es 
ex 
seb return 
rs 
rr brk 
seb break 
bs 
blab cont 
seb continue 
cs 
function acts list functions om 
yields om extension call 
type records additional assumption obtained boolean result type 
type def assump boolean kind list list om term 
yields function 
de ned list map function acts single operation om 
om 
def cases kind norm 
cases 
ns norm 
assump res assump kind kind 
assump assump kind 

element kind nonnormal 
kind normal evaluated enclosed normal state 
kind evaluation appears result 
special case terminates normally boolean result added assumption 
point equation normal result added assumptions 
fbi rules subsection describe detail fbi wp rule sum expression java discussed informally section 
rule uses operation snoc adds element list 
fbi rules backward reasoning 
rule takes form 
seb 
diverges requires ses 
te 


te 

ensures 
signals return break continue seb 
diverges requires ses 
te 

ensures signals return break continue notice double line express rule valid direction 
interested upwards 
way read direction follows 
suppose stack statements expressions element addition expression lines 
order prove expression evaluates rst evaluate assume fbi calculations done backwards existing stack extended elements checks 
te 


te 

java evaluation strategy expressions left right 
backwards calculation continue 
te 

line 
automatic rewriting pvs proof goal line rule replaced goal line assumption 
way length stack increases complexity expression reduced 
time normal postcondition ensures clause may change 
general wp calculation stack continuously increases decreases length eventually empty 
point nal implication precondition implies adapted postcondition proved see subsection 
wp rule long small part relevant 
functions contribute readability 
shall omit irrelevant parts speci cations simply write section 
te 


te 
tr 
tb 
tc 
confusion 
way rule addition seb 
ses ensures 

seb 
ses ensures 
instance rule looks follows 
involves expected split 
seb 
ses true 
seb 
ses false 
seb 
ses 



tells statement continue upwards proof goals condition true statement false statement 
space restrictions prevent describing fbi rules 
selection 
remainder section describe special rules starting stopping atomic expressions catch breaks 
nal subsection brie describes automatic veri cation example involving loop 
start rules explained design goals wp calculi usable hoare proof 
seen proceed hoare tuple nfe proof wp wp 
give rules move hoare proof fbi proof 
done singleton sequences 
seb 
ses 
id id id id 
return om unit 

sb 
statement return 
change return label purely bureaucratic types match 
seb 
ses 
id 

ensures om 

return om unit false break om lift string false continue om lift string false sb 
expression ensures 
individual statements expressions hoare tuples translated singleton stacks fbi tuples 
associated translation functions simply identities 
expressions redundant labels return break continue lled constantly false predicates 
application initial rules structural fbi rules take wp proof 
special case composition statements java turned list composition 
rule proof branch ends list statements expressions exhausted application fbi rules 
thing left prove precondition implies adapted postcondition om 

sb 
requires ses ensures 
rule pvs automatically starts command semantic assert prove quanti ed implication lines 
mentioned section command nfe functions wp wp done 
notice application rule implicit precondition fbi approach decomposed rewritten 
happens proof branch 
atom rules far seen fbi rules decrease list statements expressions 
rules apply right item list atomic form 
rules skip break break label subsection 
shall consider cases constant eld expressions 
element type corresponding constant expression const 
om om norm ns res 
corresponding fbi rule follows 
seb 
ses ensures 

seb 
ses const 
ensures 
similarly eld om corresponding expression 
om de ned om norm ns res 

const upper ensures clause om 

fbi rules breaks salient features java exceptions mechanism 
fbi framework appropriate rules dealing try catch try catch nally semantics described 
wp rules fairly complicated 
shall describe rules breaks 
similar elementary rules exceptions 
recall break statement occur java string 
semantics pvs corresponding functions follows 
break om statresult def om break bs blab bot str string break label 
str om statresult def om break bs blab str function catch break translated labeled statements lab java lab catch break 
lab 

function performs layed quote 
labeled statement executed executing immediately contained statement 
statement labeled identi er contained statement completes abruptly break identi er labeled statement completes normally 
cases abrupt completion statement labeled statement completes abruptly reason 
prescription formalised follows 
ll lift string om statresult catch break 
ll 
om statresult def om cases 
abnorm 
cases break 
blab ll norm bs abnorm endif 
abnorm 
transforms break abnormality appropriate label normal termination 
fbi wp rules break break label surprising 
move predicate break slot ensures slot appropriate label seb 
ses ensures 

tb 
bot 
seb 
ses break break 
seb 
ses ensures 

tb 
str 
seb 
ses break label 
str break 
rule catch break complicated 
rst thought reverse exchange ensures break 
problem setup deal single catch break statement stack form catch break 
corresponding composition catch break 
situation statement principle create break abnormality caught subsequent catch break 
solution provide detour break abnormality thrown change type break abnormalities disjoint union inl inr way go left component ones caught right 
leads rule 
seb 
ses 
id 
id 
inl 
id 

te 
tr 
inr tb 
tc 
break om inl inr cases inl 



inr 

tb 
ll 


endif seb 
ses 
te 
tr 
tb 
tc 
catch break 
ll 
ensures break 
soundness rule requires function tb injective 
case 
function translation abnormality outputs 
rule list 
obtained iteration function acting single item 
fe fr fb fc 
fe 
fr 
fb 
fc om 
om def cases 
kind hang 
hang norm 
norm excp 
excp es es ex fe 
ex 
rs rs rr fr 
rr brk 
brk bs bs blab fb 
blab cont 
cont cs cs fc 
associated wp rule removes functions seb 
ses break om 

inl 

seb 
ses 
id 
id 
inl 
id 
break 
similar way abnormalities treated fbi framework 
fbi veri cation example nal subsection brie discuss example veri cations time fbi rules 
java jml code 
method sqrt involves loop 
calculates approximation square root positive natural numbers repeated additions 
wp veri cation requires explicitly loop invariant variant 
function state space natural numbers decreases cycle 
case invariant count count count sum count count variant count veri cation invariant added precondition 
done easily fbi approach precondition internal full control 
stage invariant variant inserted hand pvs translated java code 
ultimately written jml annotations handled automatically loop tool 
normal behavior requires modifiable ensures result result int sqrt int int count sum sum return count fig 

java code plus jml annotation fbi veri cation 
veri cation goes fully automatic apart insertion 
expanded 
fbi wp rule command clearly recognisable giving rise subgoals establishing invariant loop establishing postcondition loop establishing repetition statement maintains invariant decreases variant 
standard 
applied automatically fbi setting internal preconditions concluding remarks describes new veri cation techniques loop project di erent realisations weakest precondition calculus called nfe nested forward external fbi flat backward internal 
form nfe setting correctness loop proved manually instantiating invariant appropriate part external precondition 
currently strategy doing user interaction 
jml start rewrite sqrt annotation stat compose compose compose compose return wp wp assign wp wp catch break wp annotation wp break wp wp assign wp const wp wp assign wp const wp empty wp leaf assert int le wp wp wp empty wp leaf assert nil catch continue wp compose wp assign wp int plus wp int plus wp const wp int times wp wp const wp wp wp expr composition wp assign wp int wp wp wp continue wp int le wp wp wp empty wp leaf assert fig 

expanded proof tree fbi correctness proof 
non trivial extension classical involving appropriate wp rules language constructs sequential java 
concretely contributes new pvs commands nfe assert fbi assert proving translated jml speci cations java implementations 
existing hoare logic form powerful toolkit proving non trivial correctness assertions minimal user interaction 
crucial di erences seen nfe ecient fbi handle loops automatically 
toolkit program veri cation bit model checking nfe assert fbi assert completes proof branch great left long trace hard interpret debugging 
clear performance issues pvs run hours completing proof crash grows big 
ective approach larger programs appropriate combination hoare logic breaking proof goal supplying required intermediate predicates hand jml weakest precondition reasoning nishing resulting smaller subgoals 
background reported started discussion rustan leino jan possibilities wp calculus loop project 
tried success setting hoare logic jml exist time 
renewed investigations started development fbi calculus involve explicit 
terms performance real step forward 
soon discussion erik poll possibility higher order de nition came 
led development nfe calculus 
certain examples phone card section developed martijn martijn turned spectacularly ecient fbi 
large extend due clever rewrite strategies pvs developed joachim van den berg bart especially method calls 
current veri cations nfe popular 
summary go rustan erik constructive comments text martijn martijn joachim bart 

van den berg huisman jacobs poll 
type theoretic memory model veri cation sequential java programs 
bert choppy mosses editors trends algebraic development techniques number lect 
notes comp 
sci pages 
springer berlin 

van den berg jacobs 
loop compiler java jml 
margaria yi editors tools algorithms construction analysis systems number lect 
notes comp 
sci pages 
springer berlin 

van den berg jacobs poll 
formal speci cation veri cation javacard application identi er class 
th 
jensen editors java smart cards programming security number lect 
notes comp 
sci pages 
springer berlin 

de boer 
computer aided speci cation veri cation annotated object oriented programs 
jacobs rensink editors formal methods open object distributed systems pages 
kluwer academic publishers 


van den berg jacobs 
specifying verifying decimal representation java smart cards 
algebraic methodology software technology lect 
notes comp 
sci 
springer berlin appear 

chen 
java card technology smart cards 
java series 
addison wesley 

dijkstra 
discipline programming 
prentice hall 

gordon 
mechanizing programming logics higher order logic 
birtwistle subrahmanyam editors current trends hardware veri cation automated theorem proving pages 
springer 

gordon melham 
hol theorem environment higher order logic 
cambridge univ press 

gosling joy steele bracha 
java language speci cation second edition 
java series 
addison wesley 

gries 
science programming 
springer 

martin 
mechanically veri ed veri cation condition generator 
computer journal 

huisman 
reasoning java programs higher order logic pvs isabelle 
phd thesis univ nijmegen 

huisman jacobs van den berg 
case study class library veri cation java vector class 
int 
journ 
software tools technology transfer 

jacobs 
formalisation java exception mechanism 
sands editor programming languages systems esop number lect 
notes comp 
sci pages 
springer berlin 

jacobs martijn martijn 
formal veri cation simple payment applet 
manuscript 

jacobs poll 
logic java modeling language jml 
hussmann editor fundamental approaches software engineering fase number lect 
notes comp 
sci pages 
springer berlin 

leavens baker ruby 
jml notation detailed design 
kilov rumpe editors behavioral speci cations business systems pages 
kluwer 

leavens baker ruby 
preliminary design jml behavioral interface speci cation language java 
techn 
rep dep 
comp 
sci iowa state univ www cs iastate edu leavens jml html 

leino saxe stata 
checking java programs guarded commands 
jacobs leavens uller poetzsch ter editors formal techniques java programs 
proceedings ecoop workshop 
techn 
rep hagen 
technical note compaq systems research center palo alto 

meijer poll 
full formal speci cation java card api 
th 
jensen editors smart card programming security number lect 
notes comp 
sci pages 
springer berlin 

meyer poetzsch ter 
architecture interactive program provers 
graf schwartzbach editors tools algorithms construction analysis systems volume lect 
notes comp 
sci pages 
springer berlin 

owre rushby shankar von henke 
formal veri cation fault tolerant architectures prolegomena design pvs 
ieee trans 
softw 
eng 

poetzsch ter uller 
programming logic sequential java 
swierstra editor programming languages systems number lect 
notes comp 
sci pages 
springer berlin 

poll van den berg jacobs 
formal speci cation javacard api jml class 
computer networks 

loop project 
www cs kun nl bart loop 

rauch poetzsch ter 
predicate transformation proof strategy 
formal techniques java programs 
proceedings ecoop workshop 

extended static checker esc java 
compaq system research center 
www research compaq com src esc esc html 

