cooperative task management manual stack management event driven programming opposite threaded programming atul adya jon howell marvin theimer william bolosky john douceur microsoft research microsoft way redmond washington adya howell theimer bolosky microsoft com cooperative task management provide program architects ease reasoning concurrency issues 
property espoused recommend event driven programming multithreaded programming 
terms conflate issues 
clarify issues show get best worlds reason simply concurrency way event driven advocates recommend preserving readability maintainability code associated multithreaded programming 
identify source confusion programming styles conflation concepts task management stack management 
concerns define axis space multithreaded event driven programming diagonally opposite third sweet spot space combines advantages programming styles 
point pitfalls alternative forms stack management manual automatic supply techniques mitigate danger automatic case 
exhibit adaptors enable automatic stack management code manual stack management code interoperate code base 
team embarked new project faced question programming model 
team member burned concurrency issues past encountering bugs difficult reproduce identify remove 
chose follow collective wisdom community understood suggests event driven programming model simplify concurrency issues reducing opportunities race conditions deadlocks ous 
gained experience realized popular term event driven conflates distinct concepts importantly suggests gain reasoning concurrency cumbersome manual stack management 
separating concerns able realize best worlds 
section define distinct concepts conflation problematic touch related concepts avoid confusing central ideas 
key concept choose reasoning benefits cooperative task management sacrificing readability maintainability automatic stack management 
section focuses topic stack management describing software evolution exacerbates problems code manual stack management code automatic stack management 
show insidious problem automatic stack management alleviated 
section presents hybrid stack management model allows code automatic stack management coexist interoperate program code manual stack management model helped find peace group developers disagreed method 
section discusses experience implementing ideas different systems 
section relates observations summarizes 
definitions section define describe distinct concepts task management stack management response management conflict management data partitioning 
concepts completely orthogonal considering independently helps understand interact complete design 
tease apart concerns return look concepts popularly conflated 
task management divide program conceptually separate tasks task encapsulates control flow tasks access common shared state 
high performance programs written preemptive task management execution tasks interleave uniprocessors overlap multiprocessors 
opposite approach serial task management runs task completion starting task 
advantage conflict access shared state define inter task invariants shared state assured task running tasks violate invariants 
strategy inappropriate wishes exploit multiprocessor parallelism slow tasks defer tasks long time 
compromise approach cooperative task management 
approach task code yields control tasks defined points execution usually task wait long running approach valuable tasks interleave avoid waiting multiprocessor parallelism crucial application performance 
cooperative task management preserves advantage serial task management invariants global state need restored task explicitly yields assumed valid task resumes 
cooperative task management harder serial task local state depends global state yielding state may invalid task resumes 
problem appears preemptive task management releasing locks duration slow operation bir :10.1.1.112.4939
penalty adopting cooperative task management library function called wrapped blocking function initiates yields control task 
wrapper arrange task schedulable completes 
stack management common approach achieving cooperative task management organize program collection event handlers 
say task involves receiving network message reading block disk replying message 
receipt message event procedure handles event initiates disk receipt disk result second event procedure handles event constructs network reply message 
desired task management achieved tasks may progress task waiting disk call approach just described manual stack management 
argue section problem control flow single conceptual task state broken language procedures effectively discarding language scoping features 
problem subtle causes trouble software evolves 
important observe choose cooperative task management benefits exploiting automatic stack management afforded structured programming language 
describe section 
languages built facility transparently constructing closures scheme call obvious example 
facility obviates idea manual stack management altogether 
focuses stack management problem conventional systems languages elegant closures 
management focuses axes explicitly mention axes avoid confusing 
concerns question synchronous versus asynchronous management orthogonal axis task management 
programming interface synchronous calling task appears block call site completes resume execution 
asynchronous interface call appears return control caller immediately 
calling code may initiate overlapping asynchronous operations wait results arrive arbitrary order 
form concurrency different task management operations considered independently computation overlap access shared state computation 
code obeying forms task management call type interface 
furthermore right primitives build wrappers synchronous interfaces asynchronous ones vice versa just systems 
conflict management different task management approaches offer different granularities atomicity shared state 
conflict management considers convert available atomicity meaningful mechanism avoiding resource conflicts 
serial task management example entire task atomic operation shared state explicit mechanism needed avoid inter task conflicts shared resources 
limiting case preemptive task management tasks executing concurrently tasks ensure invariants hold shared state time 
general solution problem synchronization primitives locks semaphores monitors 
small atomic operations supplied machine runtime environment synchronization primitives construct mechanisms maintain complex invariants shared state hold 
synchronization mechanisms may pessimistic optimistic 
pessimistic mechanism locks tasks resources needs complete computation 
optimistic primitive computes results speculatively computation turns conflict concurrent task computation mechanism retries falling back pessimistic mechanism forward progress 
cooperative serial task management effectively provides arbitrarily large atomic operations code executed explicit yield points executed atomically 
straightforward build complex invariants safely 
approach analogous construction atomic sequences interrupt masking uniprocessor os kernels 
discuss section ensure code dependent atomicity stays atomic software evolves 
data partitioning task management conflict management address problem potentially concurrent axes frequently conflated 
access shared state 
partitioning state reduce number opportunities conflict 
example task specific state needs concurrency considerations explicitly partitioned shared state 
data transferred partitions value careful handle implicit value indexes array 
explicitly introducing data partitions reduce degree sharing shared state easier write reason invariants partition data partitioning orthogonal approach mentioned previously 
concepts relate described distinct concepts 
precisely orthogonal useful consider effects choices dimension separately 
importantly purposes task management stack management axes orthogonal see 
idea conventional concurrent programming uses preemptive task management exploits automatic stack management standard language 
hear point space referred term threaded programming 
second interesting point space event driven programming cooperative tasks organized event handlers yield control returning control event scheduler manually unrolling stacks 
organized observation choose cooperative task management preserving automatic stack management program ming language structured diagram point labeled sweet spot 
stack management diagram ask pros cons forms stack management 
address question 
principal advantages disadvantages form emphasizing software evolution exacerbates disadvantages 
technique mitigates principal disadvantage automatic stack management 
automatic versus manual programmers express task employing automatic stack management manual stack management 
automatic stack management programmer expresses complete task single procedure source language 
procedure may call functions block operations disk remote requests 
task waiting blocking operation current state kept data stored procedure program stack 
style control flow meaning associated term 
contrast manual stack management requires programmer rip code task event handlers run completion blocking 
event handlers procedures invoked scheduler response events initiation task response initiate event handler schedules request operation wait reply 
registers task specific object called continuation event handling scheduler 
continuation bundles state indicating left working task plus different event handler procedure encodes done requested completed 
having initiated registering continuation returns control event handling scheduler 
event representing completion occurs event handling scheduler calls passing bundled state argument 
style control flow associated term eventdriven 
illustrate stack management styles consider code function looks memory hash table specified id returns pointer corresponding object 
certificate authority entity issues certificates example users file system 
caid caid caid return suppose initially function designed handle globally known certificate authorities ca records stored memory 
refer function compute function pause need consider stack managed call automatic stack management supplied compiler appropriate 
suppose function evolves support abundance ca objects 
may wish convert hash table disk structure memory cache entries 
function may yield code evolves depends uses automatic manual stack management 
code automatic stack management implements revised function caid caid caid null node hash table return new blocks waiting disk complete 
caid caid return achieve goal manual stack management rip single conceptual function source language functions second function called event handler scheduler continue disk completed 
continuation object stores bundled state function pointer class continuation function called continuation scheduled run 
void function continuation cont return value set operation 
passed continuation 
void bundled state void arg arg original function parts function event handlers void caid caid continuation return result immediately cache caid null call caller continuation result function return buffer space disk read new save return address live variables continuation cont new continuation caid send request eh caid schedule event handler run reply registering continuation eh cont void continuation cont recover live variables caid caid caid cont arg cont arg continuation continuation cont arg object hash caid return results original caller function note signature different 
desired result available runs caller pass continuation invoke order return desired result continuation record 
manual stack management statement returns control value caller simulated function call continuation procedure 
stack conventional systems languages support closures programmer substantial amount manual stack management yield operations 
note function previous section parts call 
calls rips code 
situation gets worse presence control structures loops 
programmer language stack reconstructs heap reduces readability code process 
furthermore debugging impaired debugger stops call stack shows state current event handler provides information sequence events task performed arriving current event handler invocation 
theoretically manually recover call stack tracing continuation objects practice observed programmers hand optimize away tail calls stack goes missing 
summary routine programmer manually manage procedural language features normally handled compiler function scoping language functions represent single conceptual function 
automatic variables variables allocated stack language moved new state structure stored heap survive yield points 
control structures entry point basic block containing function block reachable continuation separate language level function 
conceptual functions loops pieces 
debugging stack call stack manually recovered debugging manual optimization tail calls may unrecoverable 
software evolution substantially magnifies problem function function evolves compute potentially yielding functions path function concurrency semantics changed root call graph may potentially 
precisely functions branch call graph function encountered call continuation passing form 
call phenomenon stack see primary drawback manual stack management 
note global evolutions functions call graph may maintained different parties making change difficult 
hidden concurrency assumptions huge advantage manual stack management yield point explicitly visible code level call graph 
contrast call hides potential concurrency 
local state extracted shared state call may need reevaluated call 
absent comment programmer tell function calls may yield local state revalidate consequence thereof 
manual stack management software evolution situation worse 
call yield yesterday may changed tomorrow yield function manual stack management evolves yield signature changes reflect new structure compiler call attention callers function unaware evolution 
automatic stack management change syntactically invisible affects semantics function calls evolved function directly transitively 
dangerous aspect automatic stack management semantic property yielding called procedure dramatically affects calling procedure written check calling procedure honoring property 
happily concurrency assumptions declared explicitly checked statically dynamically 
static check ideal detects violations compile time 
functions yield tagged yielding property block calling function assumes runs yielding marked atomic 
compiler static tool checks functions call yielding functions marked yielding calls yielding functions appear inside atomic blocks 
fact reasonably abuse exception declaration mechanism achieve 
dynamic check desirable static violations occur runtime 
useful violations cause immediate failure subtly corrupting system state way difficult trace back cause 
chose dynamic check quick easy implement 
block code depends atomicity begins call ends call 
function increments private counter decrements 
function tries block yield asserts counter zero dumps core 
note evolving code employing automatic stack management may modify function extending path call graph function concurrency semantics changed 
manual stack management implies affected function torn apart multiple pieces automatic stack management code may require changes far intrusive changes 
local state function depend yielding behavior called function calling function requires change 
calling function local state affected function modified revalidate state surgery usually local require substantial code restructuring 
hybrid approach project advocates styles stack management 
hybrid approach enables styles coexist code base adaptors connect 
hybrid approach enables project written style incorporate legacy code written 
windows operating system threads scheduled preemptively fibers scheduled cooperatively 
implementation achieves cooperative task management scheduling multiple fibers single thread time fiber active 
design scheduler runs special fiber called schedules manual stack management code event handlers automatic stack management code 
code written automatic stack management expects block runs fiber blocks yields control back scheduler selects task schedule 
compute functions course may run fiber may freely called context 
types stack management code scheduled scheduler windows fiber package supports notion explicitly switching fiber specified fiber notion generalized yield operation invokes default fiber scheduler 
implementing combined scheduler allowed avoid problem having potentially conflicting schedulers running parallel event handlers fibers 
ways styles code interact 
aimed simplicity preserve existing code base uses manual stack management 
solution ensures code written style call function implemented style aware stack management discipline exists 
illustrate hybrid approach show example includes calls styles directions 
example involves functions 
introduced section 
fetches security certificate calls order confirm validity 
turn calls order obtain ca verify certificate 
code look serial task management bool user user certificate cert get certificate data function certificate user user cert return false bool user user certificate cert get certificate authority ca information verify cert ca cert ca null return false return ca user cert certificate user user look certificate memory cache return answer 
fetch disk network lookup user cert return certificate certificate return certificate course want rewrite code cooperative task management allowing tasks run pauses different functions adhering form stack management 
suppose written automatic stack management remaining functions implemented manual stack management continuations 
define adaptor functions route control flow styles 
manual calling automatic sequence diagram illustrating code manual stack management calls code automatic stack management 
details call opposite direction momentarily obscured dashed boxes 
event handler calls function initiates operation entire stack accordance manual stack management 
reply arrives scheduler executes continuation returns function call second handler 
pure manual stack management 
function written manual stack management calls code automatic stack management reconcile styles 
caller code written expecting block callee expects block 
reconcile styles create new fiber execute callee code fiber 
caller resumes manually unroll stack soon burst execution fiber completes 
fiber may ti code manual stack management calls function written automatic stack management 
run block times finishes behalf caller executes caller continuation resume caller part task 
caller code block callee code block wishes 
example manual stack management function calls adapter automatic stack management function 
passes continuation pointing eventually regain control execute final part implementation 
code cfa adaptor call return parts cfa stands continuation fiber adaptor void continuation executed continuation new continuation fiber new fiber start executing control returns blocks void continuation executed 
scheduled done continuation continuation arg return original caller function adaptor function accepts arguments adapted function continuation stack frame calling task 
constructs continuation creates object called represents new fiber subclass fiber class object keeps track function arguments transfer control done 
performs fiber switch 
begins executes glue routine unpack parameters pass may block executed fiber call block actual verification 
verification complete 
schedule scheduler schedule start function simply calls function 
point yields switches control back call function call site shown routine 
control resumes continuation stack back scheduler 
hybrid task blocked initiated code automatic stack management ensuring event handler block 
completes resumed defer details resumption occurs 
performed control returns 
return value continuation schedules execute switches back final time 
point destroyed 
executes returns function call code manual stack management normally return value back adaptor caller continuation 
automatic calling manual discuss code interactions occur function automatic stack management calls function manually manages stack 
case function needs block function simply schedules returns 
reconcile requirements supply adaptor calls manual stack management code special continuation relinquishes control ti code automatic stack management calls function written manual stack management 
causing adaptor caller remain blocked 
completes special continuation runs resumes fiber blocked adaptor resumes original function waiting result 
fills missing details illustrate interaction 
example blocks calls function manual stack management 
calls adaptor hides management nature fca means fiber continuation adaptor boolean caid caid executed get continuation switches control fiber called cont new caid cont cont block 
return cont void continuation cont fiber manual stack mgmt code perform just mark short circuited fcont cont fcont true resumed simply switch control original fiber fiber fiber cont arg resume adaptor sets special continuation resume code 
passes continuation initiates operation returns immediately believes scheduler course case control returns 
scheduled short circuiting occur discussed section ensure control return achieve effect switches control 
continuation code started burst fiber execution returns times unroll stack scheduler runs 
eventually result arrives scheduler executes remaining 
fills local hash table recall implementation section returns control calling continuation 
case calls continuation passed 
notices blocked switches control back fiber bottom half adaptor extracts return value passes automatic stack management code called 
short circuit branch followed example handles case returns result immediately waiting allow control pass scheduler 
necessary caller optionally determine routine yielded control local state 
short circuit path important optimization associated design pattern describe section achieved 
illustrates short circuit sequence short circuit code detects case runs locally performs executes returns current continuation immediately 
detects executed directly scheduler sets flag prevent adaptor switching 
discussion important observation adaptors place style code unaware 
function written automatic stack management sees expects deep stack control may transfer away return stack intact 
likewise event handler scheduler tell calling just series ordinary manual continuations adaptors swap fiber stacks looking continuation 
integrating code styles straightforward fiber execution looks continuation event driven code continuation scheduler looks variation need perform fiber procedure oriented code 
adaptability enables automatic stack management programmers manual stack management programmers evolve manual stack management code base automatic stack management functions vice versa 
implementation experience employed cooperative task management systems farsite distributed secure serverless file system running desktops sbs wireless phone application handheld devices pdas 
farsite code designed run daemon process servicing file requests windows nt operating system 
system designed windows ce operating system client application runs ui audio support 
farsite system code initially written eventdriven style cooperative task management manual stack management enable simplified reasoning concurrency conditions system 
code base grew evolved period years came appreciate costs employing manual stack management devised hybrid approach discussed previous section introduce automatic stack management code system 
system uses automatic stack management exclusively 
farsite uses fibers cooperative threading facility available windows nt 
windows fibers task state represented stack control transferred simply swapping stack pointer setjmp longjmp 
fibers unavailable windows ce operating system uses preemptive threads condition variables achieve cooperative threading facility thread blocks condition variable scheduler ensures condition variable signalled moment 
thread yields blocks condition variable signals scheduler continue scheduler selects ready thread signals condition variable 
implemented hybrid adaptors direction series mechanically generated macros 
groups macros direction adaptation 
group variations account varying numbers arguments void nonvoid return type function called static function object method multiple macros necessary generate corresponding variations syntax 
macro takes arguments signature function adapted 
macros declare create appropriate fiber continuation objects 
experience systems positive subjective impression able preempt subtle concurrency problems cooperative task management basis 
task wrapping functions see section tedious automated paying front cost reduce subtle race conditions investment 
systems extra threads converting blocking operations non blocking operations scheduling operations done systems flash 
data partitioning prevents synchronization problems threads state shared cooperatively managed tasks 
cooperative task management avoids concurrency problems locks tasks complete having yield control task 
deal tasks need perform avoid need lock employing particular design pattern 
pattern call pinning pattern operations pin resources memory manipulated yielding 
note pinning exclusivity pinned resource held memory avoid need block access tasks run free manipulate data structures contains 
functions structured phases loop repeatedly tries execute potentially yielding operations completed yielding atomic block computes results writes shared state 
important detail design pattern may dependencies potentially yielding operations 
function may need compute results previously pinned resource order decide resource pin example farsite occurs traversing path directory tree 
fully general version design pattern check potentially yielding operation operation yield restarts loop top 
entire loop executed interruption know set resources pinned memory related way expect final pass loop executed atomically 
related birrell offers overview conventional thread ed programming model preemptive task management bir :10.1.1.112.4939
reasons concurrency cooperative task management help exploiting multiprocessors shortcoming mention section 
birrell advises associating piece data mutex consider cooperative task management limiting case advice 
complexity task yields effectively releases global mutex reestablish invariants resumes 
preemptive task management birrell comments want unlock mutex calling lower level abstraction block execute long time complexity introduced choice cooperative task management 
ousterhout points pitfalls preemptive task management subtle race conditions deadlocks ous 
argue threaded model conflates preemptive task management automatic stack management event driven model conflates cooperative task management manual stack management 
wish convince designers choices orthogonal ousterhout arguments really task management decision programmers exploit ease reasoning benefits cooperative task management exploiting features programming language automatic stack management 
system designers advocated non threaded programming models observe certain class high performance systems file servers web servers substantial performance improvements obtained reducing context switching carefully implementing application specific cache conscious task scheduling hs bdm 
factors especially pronounced high load situations number threads may large system starts thrash trying give thread fair share system resources 
argue context switching overhead user level threads fibers fact quite low measured cost switching fiber package times cost procedure call 
furthermore applicationspecific cache conscious task scheduling just achievable cooperative task management automatic stack management scheduler precisely opportunities schedule eventdriven code difference stack state kept stacks chains continuations heap 
classes applications processing partitioned stages lp 
partitioning system state disjoint stages form data partitioning addresses concurrency coarse grain 
stage designer system choose form conflict management task management stack management 
careful construction stages avoids calls stage case cooperative task management stage degenerates serial task management distinction arises stack management 
practice inter stage level single task strings multiple stages reads manual stack management 
typically stages monotonic task leaves stage returns 
avoids associated looping control structures 
lauer needham show programming models equivalent syntactic substitution ln 
describe models terms axes procedure oriented system preemptive task management automatic stack management process typically goal task monitors conflict management big data partition protected monitors 
message oriented system manual stack management task state passed messages conflicts manage due partitions state effectively concurrently shared 
notably message oriented system say nei ther procedural interfaces global naming schemes useful manual stack management undermines structural features language 
model uses cooperative task management regard models require identically detailed reasoning conflict management 
comparison decidedly models associate multithreaded event driven programming 
clarify ongoing debate eventdriven versus threaded programming models identifying separable concerns task management stack management 
separated assumes cooperative task management focuses issues stack management context 
choice task management strategy fundamental choice stack management left individual taste 
unfortunately term event driven programming conflates cooperative task management manual stack management 
prevents people considering readable automatic coding style conjunction cooperative task management 
software evolution important factor affecting choice task management strategy 
concurrency assumptions evolve may necessary global abstraction breaking changes application implementation 
evolving code manual stack management imposes cumbersome code restructuring burden stack evolving style code involves revisiting invariant logic due changing concurrency assumptions making localized changes functions order revalidate local state 
hybrid model adapts code automatic manual stack management enabling cooperation disparate programmers software evolution disparate code bases 
jim larus discussing topic length 
anonymous reviewers thoughtful comments 
william bolosky john douceur david ely marvin theimer 
feasibility serverless distributed file system deployed existing set desktop pcs 
proceedings acm sigmetrics conference pages june 
bdm gaurav banga peter druschel jeffrey mogul 
better operating system features faster network servers 
proceedings workshop internet server performance held conjunction acm sigmetrics madison wi 
bir andrew birrell :10.1.1.112.4939
programming threads 
technical report digital systems research center january 
daniel friedman christopher haynes eugene kohlbecker 
programming continuations 
pepper editor program transformation programming environments pages 
springerverlag 
haynes friedman wand 
continuations coroutines 
acm symposium lisp functional programming pages austin tx august 
hs hu schmidt 
jaws framework high performance web servers 
domain specific application frameworks frameworks experience industry 
wiley sons 
ln lauer needham 
duality operating system structures 
operating systems review january 
lp larus parkes 
cohort scheduling enhance server performance 
technical report msr tr microsoft research march 
mishra yang 
thread vs event implementation group communication service 
proceedings th international parallel processing symposium orlando fl 
ous john ousterhout 
threads bad idea purposes 
usenix technical conference invited talk austin tx january 
pai druschel zwaenepoel 
flash efficient portable web server 
usenix technical conference monterey ca june 
sbs shih bahl sinclair 
wake wireless event driven power saving strategy battery operated devices 
technical report msr tr microsoft research april 
matt welsh david culler eric brewer 
seda architecture conditioned scalable internet services 
proceedings eighteenth symposium operating systems principles sosp banff canada october 
