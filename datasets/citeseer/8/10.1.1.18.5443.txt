complexity agent design problems determinism history dependence paul dunne dept computer science university liverpool liverpool zf united kingdom 
agent design problem follows specification environment specification task possible construct agent guaranteed successfully accomplish task environment 
article study computational complexity agent design problem tasks form achieve state affairs maintain state affairs 
consider general formulations problems non deterministic deterministic environments differ nature viewed acceptable solution restrictive formulation limit placed number actions agent allowed perform attempting meet requirements specified task 
show resulting decision problems intractable sense non recursive recursively enumerable achievement tasks non recursively enumerable maintenance tasks 
second formulation decision problem addresses existence agents satisfied specified task number actions 
restrictive setting resulting decision problems pspace complete np complete 
final formulation requires environment history independent bounded 
cases polynomial time algorithms exist deterministic environments decision problems nl complete non deterministic environments complete 

interested building agents autonomously act accomplish tasks behalf complex unpredictable environments 
researchers similar goals developed range software architectures agents :10.1.1.119.2204
article focus underlying decision problems associated deployment agents 
specifically study agent design problem :10.1.1.43.7182
problem may informally stated follows specification environment specification task desire carried behalf environment possible construct agent guaranteed successfully accomplish task environment 
type task carried crucial study problem 
article address common types tasks encountered artificial intelligence achievement tasks agent required achieve state affairs maintenance tasks agent required maintain state affairs 
csd rep math ai tex proved general case agent design problem achievement maintenance tasks pspace complete :10.1.1.43.7182
research note extend results considerably :10.1.1.43.7182
formally defining mean agents environments introduce achievement maintenance design tasks 
consider number different requirements constitutes successful agent informally requirements pertain limit placed total number actions agent allowed perform order accomplish task 
achievement maintenance tasks turn equivalent logspace reductions setting upper limit placed number actions allowed unbounded environments may occur instances 
show section successful agents compelled complete tasks number steps agent design problems provably intractable intractable irrespective assumptions regarding classical open questions computational complexity theory np pspace section focus finite agent design problems agents achieve state affairs number steps finite achievement tasks maintain state affairs number steps finite maintenance tasks particular identify environmental characteristics affect complexity finite agent design problem determinism refers state environment uniquely defined history system date agent current action history dependence refers state environment simply function agent current action environment current state previous environment states actions play part determining state 
section discuss related 
article assume familiarity complexity theory 

agents environments runs systems interest consist agent situated particular environment 
agent interacts environment performing actions environment responds actions changes state 
assumed environment may finite set fe instantaneous states 
agents assumed repertoire possible actions available transform state csd rep math ai tex environment 
ac finite set actions 
behaviour environment defined state transformer function function allows non determinism environment number possible environment states result performing action apparently circumstances 
case simply function environment states actions sets environment states runs actions sets environment states 
allows behaviour environment dependent history system previous states environment previous actions agent play part determining environment behaves 
avoid excessive repetition notational conventions 
set defined relationship form denotes subset 

finite sequence denote element definition 
environment quadruple env ac finite set environment states distinguished initial state ac finite set available actions 
env denote sequences form 




initial state ac 
subset sequences state 
state transformer function total mapping ac wish focus subset representing possible sequences states actions arise certainly sequence having 
prefix result initial state 
order precise define concept run 
subset defining runs environment env env env env fe env env acj fr 
csd rep math ai tex env set histories result exactly actions initial state similarly env indicates set histories result actions initial state 
environment bounded env bounded bounded finite value unbounded 
denote ac set fr 
env slight abuse notation subsequently interpret total mapping ac 
run terminated actions ac 
env terminated form prefix run env subset env comprising terminated runs denoted env env set terminated runs 
note env bounded runs env terminated 
length run env total number actions states occurring denoted bounded environment runs length states actions 
noted environment env run env terminated actions 
action 
proper prefix non empty set runs env state transformer function represented deterministic turing machine program description characteristics takes input run ac state accepts jrj steps accepted input number steps 
worth commenting notion history dependence 
environments property 
example consider travelling salesman problem history dependence arises salesman allowed visit city twice 
note possible transform history dependent bounded environment history independent encoding information prior history environment state 
done expense increase number environment states 
intuitively history dependent environment state set associated set runs need create jr ej environment states 
jrj exponential size ac lead exponential blow size state space 
requirement reach decision jrj moves restrictive appears may admit programs require jrj steps decide constructing new environment pad env env runs env embedded runs length jrj pad env way pad pad computable jsj steps 
csd rep math ai tex view agents performing actions environment causing state environment change 
general agent attempting control environment way order carry task behalf 
environments may non deterministic agent generally partial control environment 
definition 
agent ag environment env ac mapping ag env ac symbol indicate agent finished operation agent may invoke terminated runs env event referred agent having allowable actions 
stress definition agent allow termination action invoked allowable action defined may unduly restrictive reflects fact agents may choose halt arbitrarily 
may noted agent ag having allowable action run ag env equivalent terminated ag env env general state transformer function domain ac nondeterministic describes set possible states environment 
interpretation exactly states result unpredictable 
contrast view agents deterministic env agent prescribes exactly action continue run 
definition 
system sys pair henv agi comprising environment agent operating environment 
sequence env ac called possible run agent ag environment env 



satisfies 
initial state ag 




ag 



non deterministic agent may number different possible runs environment 
csd rep math ai tex ag env denote set runs env possible runs agent ag environment env ag env subset ag env terminated runs belong env 
tasks agents build agents order carry tasks 
task carried specified 
discussion various ways specify tasks agents appears purposes article concerned just types tasks :10.1.1.43.7182:10.1.1.43.7182
achievement tasks form achieve state affairs 

maintenance tasks form maintain state affairs 
intuitively achievement task specified number goal states agent required bring goal states care 
achievement tasks probably commonly studied form task artificial intelligence 
known ai problems including blocks world instances achievement tasks 
just tasks characterised problems agent required bring state affairs classified problems agent required avoid state affairs 
extreme example consider nuclear reactor agent purpose ensure reactor enters state 
somewhat imagine software agent tasks ensure particular file simultaneously open reading writing 
refer tasks maintenance tasks 
wish express questions regarding suitable agent exists decision problems 
instance problem certainly encode environment env set states achieved avoided 
addition consider issue concerning constitutes successful agent 
consider restrictive setting question agent ag exists run eventually achieves avoids specified set states 
noted bounded environment run env forms prefix non empty set terminated runs env context forms instance decision problem assumed environment bounded actual bound value env encoded part instance 
define decision problems achievement maintenance tasks csd rep math ai tex definition 
decision problem achievement agent design ad takes input pair henv gi set environment states called states 
ad henv gi returns true agent ag value ag ag ag env ag ag env prefix occurs definition expresses requirement successful agent eventually finite number actions ag reach state run 
form decision problem applies unbounded bounded environments case simplify condition governing agent success ag env occurs terminated runs need considered 
definition 
decision problem maintenance agent design md takes input pair henv bi set environment states called bad states 
md henv bi returns true agent ag ag env occur successful agent avoid state run 
formulation achievement agent design decision problem applies unbounded bounded environments ag env occur condition governing success case 
decision problems ad md impose constraints length runs ag env course env bounded length finite 
turns significant computational difficulties arise formulations 
result consider restrictive notion success defined respect runs env decision problem formulations class choose supply value unary part instance 
prefer define decision problems runs involving je acj actions considered 
note formulation encompassing je acj bounded environments require instances bounded 
csd rep math ai tex definition 
decision problem finite achievement design fad takes input pair henv gi ad 
fad henv gi returns true agent ag je acj ag env je acj ag env definition 
decision problem finite maintenance design fmd takes input pair henv bi md fmd henv bi returns true agent ag je acj ag env occur observe concerning definitions fad fmd 
firstly examining agents runs je acj env appears restrictive limitation significant impact respect computational complexity suppose wished admit agents runs env values je acj defined variations fad fmd cases 
trivial reductions show fad log fad fmd log fmd instance henv gi fad simply create instance henv gi fad padding state set env sufficiently new states fn 
reachable initial state 
reduction increases size instance polynomially 
term critical run environment describe runs set env je acj env je acj env ag env critical runs agent ag env ag env je acj ag env je acj ag env second point note formulations quantifying je acj ag env je acj ag env requiring agent terminated je acj actions considering terminated runs je acj ag env ignoring runs terminate 
alternatives yield significant changes computational complexity specific design tasks examine 
finite agent design problems definition success employed corresponds finite achievement agent design agent reaches state je acj actions 
finite maintenance agent design agent manages avoid state je acj actions csd rep math ai tex consider variations achievement maintenance design problems depend environment deterministic state environment uniquely determined previous history environment current action performed agent non det ac maps runs sets possible states 
general context introduced definition non deterministic 
det ac maps runs state 
deterministic allowable continuation run action 
exactly state environment transformed 
notations ad md fad fmd det distinguish different settings 

provable intractability ad md results subsection indicate shall mainly consider finite agent design variants 
may unbounded required bounded environments 
theorem 
univ hm xi accepted turing machine mg deterministic single tape turing machine binary alphabet 
univ ad det proof hm xi instance univ form instance henv mx gi ad det hm xi univ ad det henv mx gi returns true 
mx fe accept ac mx mx defined follows mx 
accept env mx accepts exactly moves reject env mx rejects exactly moves csd rep math ai tex noting run env mx form 
turing machine mx program computing mx simply checks input run env mx simulates moves input machine easily compiled polynomially steps hm xi 
clear accepts agent achieves state env mx corollaries easily obtained theorem corollary 
ad det recursive 
proof language univ recursive see theorem shows univ reducible ad det deduce ad det recursive 
corollary 
md det recursively enumerable 
proof consider language univ fhm xi accept xg recursively enumerable 
henv mx bi instance md det env mx defined theorem 
md det returns true henv mx bi accept interesting note maintenance design problems unbounded environments solved finitely specified agents non trivial cases 
example set env ac ac fail st binary word formed sequence states visited st 
letting denote set non empty binary words state transformer 
fail fail 
st www st www st www consider maintenance design instance henv requiring specification agent avoids state 
notice agent unbounded runs fail state forced sequence states visited consecutive occasions 
csd rep math ai tex denote kth bit value binary word 

agent defined env jst odd jst st jst jst st sequence traversed 
sequence defined called thue morse sequence shown cube free contains subword form www property agent suffices show avoids state fail 
obvious action taken agent stage easily computable 
note historic application sequence context avoiding drawn positions chess arising german rule game drawn sequence moves occurs times succession 
corollary 
define language bounded bounded env bounded bounded recursive 
bounded recursively enumerable 
proof halting problem turing machines easily reduced bounded construction env mx theorem 
env turing machine program generates set env increasing point set empty env accepted 
theorem 
ad recursively enumerable 
proof instance henv gi ad non det loss generality non deterministic turing machine program performs actions 
fe 
fr contains gg 
accept henv gi 

csd rep math ai tex 
non deterministically choose ac 
reject henv gi 
fr 

go 
results indicate decision problems ad det md det provably intractable sense effective decision methods exist 

complexity fad fmd history dependent environments corollary theorem rules possibility computationally effective methods existing ad md subsection examine variants fad fmd 
recall problems agents perform je acj actions considered 
show loss generality suffice concentrate finite achievement problems 
theorem 
fad log fmd fad log fmd fmd log fad 
proof unnecessary prove different cases separately clear reductions 
henv si fad henv si fmd henv si run env occurs occur order prove theorem suffices show log henv si hhe ac si instance construct instance henv true returned henv si csd rep math ai tex true 
instance state set new states set actions start state instance set states setting env env fe env ac 
env env 
observe env occurs env terminated 
furthermore env je acj bounded env unbounded 
achievement task goal state maintenance task ag succeeds respect instance agent ag follows exactly actions ag witnesses positive instance hand ag agent showing instance accepted terminated runs agent agent behaves exactly ag reach state je acj actions respectively avoid state je acj actions 
observe env deterministic env deterministic uses additional states 
entire construction built logspace 
note construction theorem applies fad fmd case size critical runs arbitrary function je acj je acj je acj theorem 
state transformer function history dependent fad non det fmd non det pspace complete 
fad det fmd det np complete 
proof remarked earlier need consider achievement design problems 
recall runs je acj env relevant deciding fad henv gi 
part shown fad non det pspace ii known pspace complete problem polynomially reducible 
csd rep math ai tex give design non deterministic polynomial space turing machine program accepts exactly instances problem successful outcome 
inputs algorithm task environment henv gi run env algorithm decides successful agent continuing formally agent ag critical run ag env having prefix contains state called set initial state single run env 
algorithm input env follows 
ends environment state accepts 
allowable actions rejects 
je acj env rejects 
non deterministically choose action ac 
recursively call input 
env 
accept accepts rejects 
note may safely reject step accepted step continuation exceed total number actions agent allowed perform 
algorithm non deterministically explores space possible agents performing je acj actions guessing actions agent perform bring notice depth recursion je acj 
requires polynomial space 
follows fad non det non deterministic polynomial space 
remains note pspace fad non det pspace 
ii reduce known pspace complete problem fad non det problem choose determining player winning strategy game generalised geography pp 
refer problem gg 
instance gg triple hn ni set nodes directed graph node gg player game players ii take turns starting select arc arc current node start play move changes current node players allowed visit nodes visited play ends player loser moves available 
goal gg determine player winning strategy 
gg similar structure ad exploit produce simple mapping instances hn ni gg instances henv gi fad non det agent takes part player environment takes csd rep math ai tex part player ii 
setting ac add single element define singleton containing give je acj jnj jnj 
need define state transformer function environment idea directly encode arcs jnj jnj env ac 
fe fw rg fw rg 
construction requires little explanation 
case deals case agent illegal move case environment disallows moves game ends goal achieved 
second case player represented agent wins moves left player ii 
case environment returns indicating success 
third general case environment returns states corresponding possible moves 
construction exist agent succeed environment construct just case player winning strategy corresponding gg game 
nodes states revisited successful agent ag satisfies ag env env construction clearly takes polynomial time follows fad non det complete pspace done 
part part show fad det np 
non deterministic polynomial time algorithm deciding problem follows 
instance henv gi fad det non deterministically construct run je acj env done non deterministic polynomial time instance fad det accepted contains prove problem np hard give reduction directed hamiltonian cycle problem fad det 
instance directed graph hv vi aim determine contains directed hamiltonian cycle 
idea reduction encode graph directly state transformer function environment actions correspond edges graph success occurs hamiltonian cycle 
formally instance hv vi generate instance fad det follows 
create set environment states initial state follows create action corresponding arc ac hv fg 
set defined singleton 
je acj jvj jfj 
define parts 
case deals action agent csd rep math ai tex 
hv 
second case deals subsequent actions 

occurs 
succeed occurs 
hv agent succeed environment visits vertex original graph 
agent fail revisits vertex 
successful agent ag ag env jvj env construction clearly polynomial time done 
aside notice environment created reduction history dependent 
conclude section noting generalisation theorem 
function defined 
complexity class nexp time nexp time np nexp time fad extension fad runs je acj env interest fad fad 
theorem 
fad det nexp time complete 
proof omitted 
appendix 
complexity fad fmd history independent environments definition state transformer function non deterministic deterministic mapping ac sets states 
way outcome action may depend current state previous history environment led current state 
consider agent design decision problems examined context history independent state transformer functions 
nondeterministic case history independent environment state transformer function signature csd rep math ai tex ac deterministic environments ac environments represented directed graph state labels single vertex edge hu wi labelled ac non deterministic case deterministic 
note retaining environments bounded jvj env loss generality regard acyclic 
theorem 
state transformer function history independent fad det fmd det nl complete 
fad non det fmd non det complete 
proof part deciding history independent instance henv ad det equivalent deciding directed path succeed 
identical known nl complete problem graph reachability 
part fad non det follows algorithm label labels vertex true false successful agent starting initially vertices label unassigned 
labelled return label 
label true return true 
avail ag avail label false return false choose avail avail avail label 
ag label label true return true go csd rep math ai tex algorithm polynomial time follows fact edge inspected 
similar method applied fmd non det show monotone circuit value problem reducible logspace fad non det instance consists sequence triples ht 

triples called inputs form ftrue falseg 
remaining triples called gates take form op op boolean value defined follows input instance accepted true 
shown complete 
instance ht 

construct instance henv fad non det env hv ac history independent non deterministic directed acyclic graph edges labelled actions ac construction working space logarithmic number bits needed encode set fq 

ac 
edges associated actions accept true claim true agent succeeds reaching accept starting prove induction inductive base true input form true 
case edge labelled corresponding state state accept 
similarly edge accept true true 
assuming claim holds show holds consider triple gate op 
inductive hypothesis true agent succeeds reaching accept starting true agent succeeds reaching accept starting op true equal true 
choosing action state yield csd rep math ai tex agent achieving accept 
way agent starting succeeds action available case successful agents defined applying inductive hypothesis deduce true 
op true equals true 
true action chosen succeed action selected 
complete inductive step observe leads successful agent agent pass chosen chosen true 
recalling follows true agent reaches accept required 
similar construction may show log fmd non det state accept replaced state reject edges labelled directed false 
accepted agent defined avoids state 

related article shown depending properties environment agent design problem ranges undecidable recursively enumerable case maintenance design problem unbounded environments tractable nl complete case achievement maintenance design problems deterministic history independent environments 
ai literature closely related complexity planning problem 
bylander probably undertake systematic study complexity planning problem showed propositional strips planning problem pspace complete 
building variants planning problem studied examples include 
main differences ai planning follows notion agent function maps runs selected actions general notion plan commonly appears planning literature 
agents akin notion strategy game theory 
obvious advantage approach results bound particular plan representation 
obvious disadvantage having positive answer agent csd rep math ai tex design problems knowing exists agent carry task environment imply agent carry task implementable sense :10.1.1.52.5735
complexity results planning literature bound particular representations goals actions 
strips notation bylander example baral action description language littman representation chosen st 
cases clear results reflect complexity decision problem part artifact representation 
adopted general representations possible example representing achievement maintenance tasks sets states particular logical formalism consider possible representations environment 
complexity results planning assume simple deterministic history independent environments 
focus planning literature exclusively achievement tasks 
considered maintenance tasks considered richer task specifications 
computational complexity literature relevant problems determining player winning strategy particular player game 
pspace completeness appears characteristic complexity result problems pp 
issues demand attention 
relationship solving markov decision problems 
key problem determining extent positive polynomial time results exploited practice 
extending task specification framework allow richer complex tasks 

allen hendler tate editors 
readings planning 
morgan kaufmann publishers san mateo ca 

baral 
computational complexity planning approximate planning presence incompleteness 
proceedings sixteenth international joint conference artificial intelligence ijcai stockholm sweden 

bylander 
computational complexity propositional strips planning 
artificial intelligence 

dunne 
computability theory concepts applications 
ellis horwood 
csd rep math ai tex 

uber das proc 

akad 
amsterdam 
goldschlager 
monotone planar circuit value problems log space complete sigact newsletter 

hopcroft ullman 
automata theory languages computation 
addison wesley 

kaelbling littman cassandra 
planning acting partially observable stochastic domains 
artificial intelligence 

littman goldsmith mundhenk 
computational complexity probabilistic planning 
journal ai research 

morse 
solution problem infinite play chess 
bull 
amer 
math 
soc page 
papadimitriou 
computational complexity 
addison wesley reading ma 


sur quelques relations entre les des nombres 
acad 
sci 
paris ser 
page 

russell subramanian 
provably bounded optimal agents 
journal ai research 

thue 
uber 
vid 

skr 
mat 
nat 
kl pages 
republished selected mathematical papers axel thue ed oslo pages 
wooldridge 
computational complexity agent design problems 
proceedings fourth international conference multi agent systems icmas pages boston ma 

wooldridge dunne 
optimistic disjunctive agent design problems 
lesperance castelfranchi editors proceedings seventh international workshop agent theories architectures languages atal 

wooldridge jennings 
intelligent agents theory practice 
knowledge engineering review 
csd rep math ai tex appendix proof theorem decision problem denoted fad takes input pair henv gi returning true agent ag je acj ag env je acj ag env recall theorem stated fad det nexp time complete proof fad det nexp time follows turing machine program non deterministically guesses run je acj env checks contains state complete proof generic reduction languages nexp time fad det language nexp time 
loss generality may assumed instance encoded binary alphabet 
choice means non deterministic turing machine program ntm properties accepting computation function takes jxj moves accept follows deciding reduces decision problem fx accepting computation jxj loss generality may assume input uses single way infinite tape 
non deterministic state transition function prescribes exactly possible choices move halting states 
instance fq bg fl rg 
construct instance henv mx gi fad det env mx mx ac mx mx fad det env mx true csd rep math ai tex state set actions env mx mx fe ac mx fl rg mx padded jxj inaccessible states order ensure je mx ac mx jxj jxj increase size instance henv mx gi polynomially 
define mx possible runs environment simulate moves started input start input copied recovered run 
action copy ac mx purpose 
env mx mx 
copy hwrite env mx jxj hq bi env mx jxj hq jxj env mx jxj env mx copy action allowable action runs jxj env mx ac mx jxj env mx mx 
complete description mx define behaviour runs env mx jxj 
main idea run jxj env mx encode possible computation exactly moves 
accepting computation encoding appear je mx ac mx env mx order idea configuration associated run needed 
denoted defined run jxj env mx 
configuration describes non blank portion tape current state head position 
jxj env mx jxj 
jxj suppose jxj env mx bc 



csd rep math ai tex 
case corresponds input word empty 
case state possibilities head scanning blank symbol immediately left respectively right contiguous block non blank symbols 
third case non blank symbol scanned 
fq mx 
ac mx state transition function prescribes exactly possible moves hq ig fq bc 

bg hq ig 

cases allowable actions ac mx di fh ig mx 
di hq bi bc 
hq bc 
hq 
hq bi 
hq 

hq bi 

hq 

hq bi 

new configurations 
di 

bc 
hq bi 
bc 
hq 

hq 

hq bi 



hq 

hq bi 



hq 

hq bi csd rep math ai tex env mx configuration constructed jrj steps 
complete construction set fq claim true returned instance henv mx gi fad det defined 
suppose sequence 
configurations input results single move state indicated jxj 
construction env mx shows chose sequence actions agent ag configuration associated run jxj ag env mx furthermore run jxj ag env mx satisfies 
single terminated run ag equal state hq mx deduce sequence actions progress run fe env mx terminated run jxj jxj ag env mx defines agent accomplishing achievement task specified remains note jxj je mx ac mx 
similar manner henv mx gi positive instance ad det sequence actions performed successful agent ag run jxj ag env mx corresponds sequence moves reach accept state complete proof suffices observe turing machine program mx easily compiled turing machine input csd rep math ai tex csd rep math ai tex 
