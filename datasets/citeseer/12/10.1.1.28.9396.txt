appears st ieee conference data mining lpminer algorithm finding frequent itemsets length decreasing support constraint george karypis department computer science engineering army hpc research center university minnesota ee cs building union street se minneapolis mn fax technical report cs umn edu august years variety algorithms nding frequent itemsets large transaction databases developed 
key feature algorithms constant support constraint control inherently exponential complexity problem 
general itemsets contain items tend interesting high support long itemsets interesting support relatively small 
ideally algorithm nds frequent itemsets support decreases function length 
algorithm called lpminer nds itemsets satisfy length decreasing support constraint 
experimental evaluation shows lpminer orders magnitude faster fp growth algorithm nding itemsets constant support constraint runtime increases gradually average length transactions discovered itemsets increases 
data mining research years led development algorithms nding frequent itemsets large transaction databases :10.1.1.3.2424
itemsets nd association rules extract prevalent patterns exist transactions ectively di erent domains applications 
key feature algorithms control inherently exponential complexity problem nding itemsets occur su ciently large fraction transactions called support 
limitation paradigm generating frequent itemsets uses constant value support irrespective itemsets 
general itemsets contain items tend interesting high support long itemsets interesting support relatively small 
unfortunately constant support frequent itemset discovery algorithms nd longer infrequent itemsets generating exponentially large number short itemsets 
maximal frequent itemset discovery algorithms potentially nd longer itemsets algorithms generate large number short infrequent itemsets itemsets maximal 
ideally desire algorithm nds frequent itemsets support decreases supported nsf ccr eia aci army research ce contract da daag doe asci program computing research center contract number daah 
access computing facilities provided minnesota supercomputing institute 
function length 
developing algorithm particularly challenging downward closure property constant support constraint prune short infrequent itemsets 
property called smallest valid extension sve prune search space potential itemsets case support decreases function itemset length 
property developed algorithm called lpminer nds itemsets satisfy length decreasing support constraint 
lpminer uses proposed fp tree data structure compactly store database transactions main memory sve property prune certain portions conditional fp trees generated itemset discovery 
experimental evaluation shows lpminer orders magnitude faster fp growth algorithm nding itemsets constant support constraint runtime increases gradually average length transactions discovered itemsets increases 
rest organized follows 
section provides background information related research 
section describes fp growth algorithm lpminer 
section describe length decreasing support constraint exploited prune search space frequent itemsets 
experimental results algorithm shown section followed section 
background related works problem nding frequent itemsets formally de ned follows set transactions set items set support want nd subsets items occur jt transactions 
subsets called frequent itemsets 
years number cient algorithms developed nding frequent itemsets 
rst computationally cient algorithm nding itemsets large databases apriori nds frequent itemsets length previously generated length frequent itemsets 
key idea apriori downward closure property support constraint prune space frequent itemsets 
fp growth algorithm nds frequent itemsets data structure called fp tree compactly store memory transactions original database eliminating need access disks twice 
cient way represent transaction database vertical tid list database format 
vertical database format associates item transactions include item 
eclat uses data format nd frequent itemsets 
knowledge published nding frequent itemsets support decreases function length itemset developing itemset discovery algorithms multiple support constraints 
liu algorithm item minimum item support mis 
minimum support itemset lowest mis items itemset 
sorting items ascending order mis values minimum support itemset decreases length itemset grows making support itemsets downward closed 
apriori algorithm applied 
wang allow set general support constraints 
particular associate support constraint itemsets 
introducing new function called apriori property proposed apriori algorithm nding frequent itemsets 
cohen adopt di erent approach support constraint 
search similar itemsets probabilistic algorithms guarantee frequent itemsets 
fp growth algorithm section describe fp growth algorithm works approach algorithm 
description 
key idea fp growth data structure called fp tree obtain compact representation original transactions main memory 
result subsequent operations required nd frequent itemsets performed quickly having access disks 
fp growth algorithm achieves performing just passes transactions 
shows fp tree generation algorithm works input transaction database transactions total st scan tid transaction transaction database sort items transaction order nl nd scan item support sort support item support table node link nl flow fp tree generation null di erent items 
scans transaction database count times item occurs database get item support table step 
item support table set item name support pairs 
example item occurs twice database transaction tid tid support 
step items item support table sorted support 
result stored item name eld node link header table nl 
notice item included nl support item minimum support constraint step items transaction input transaction database sorted order items node link header table nl 
transaction tid sorted item discarded item infrequent need consideration 
step fp tree generated inserting sorted transactions 
initial fp tree root 
rst transaction inserted nodes represent item generated forming path root order 
count ofeach node set node represents transaction tid far 
second transaction inserted node representing item generated 
node generated reused 
case root node represents item count ofthe node incremented 
item child representing item current node new node item name generated child current node 
similar processes repeated sorted transactions inserted fp tree 
fp tree generated input transaction database algorithm mines frequent itemsets fp tree 
algorithm generates itemsets shorter ones longer ones adding items itemsets generated 
divides mining fp tree mining smaller fp trees item node link header table 
choose item example 
item generate new transaction database called conditional pattern base 
transaction conditional pattern base consists items paths parent nodes child nodes item name root node 
conditional pattern base item shown 
transaction conditional pattern base count occurrence corresponding count node item name original fp tree 
note item frequent itemset consisting item 
call frequent itemset conditional pattern 
conditional pattern base set transactions includes conditional pattern 
forget original fp tree focus conditional pattern base got just generate frequent itemsets include conditional pattern 
purpose generate smaller fp tree original conditional pattern 
new fp tree called conditional fp tree fp tree conditional pattern base conditional pattern item count item support node link nl null conditional fp tree conditional pattern single path fp tree conditional fp tree generated conditional pattern base fp tree generation algorithm 
conditional fp tree single path tree divide mining conditional fp tree mining smaller conditional fp trees recursively 
repeated obtain conditional fp tree single path 
recursively repeated processes selected items added conditional pattern 
obtain single path conditional fp tree generate possible combinations items path combine sets items conditional pattern 
example nodes conditional fp tree combinations item item bc ce eb bce 
obtain frequent itemsets conditional pattern base db dc de dbc dce deb 
lpminer algorithm lpminer itemset discovery algorithm fp growth algorithm itemsets satisfy particular length decreasing support constraint length itemset 
precisely satis es la lb la lb lb 
idea introducing kind support constraint support decreases length itemset may able nd long itemsets may generating exponentially large number shorter itemsets 
shows typical length decreasing support constraint 
example support constraint decreases linearly minimum value stays itemsets longer length 
problem restated nding itemsets located curve determined length decreasing support constraint 
simple way nding itemsets traditional constant support frequent itemset discovery algorithms support set discard itemsets satisfy support constraint 
approach reduce number infrequent itemsets discovered experiments show requires large amount 
discussed nding complete set itemsets satisfy length decreasing support function particularly challenging downward closure property constant support frequent itemsets 
property states order itemset length frequent subsets frequent 
result nd itemset length infrequent know longer itemsets include particular itemset frequent eliminate itemsets consideration 
problem support itemset decreases length increases itemset frequent subsets infrequent 
akey property regarding itemset support decreases function length 
particular itemset support jij min support length itemset example typical length decreasing support constraint minimum length itemset potentially frequent 
illustrates relation graphically 
length point line parallel axis intersects support curve essentially assume best case exists supported set transactions subset refer property asthe smallest valid extension property short 
lpminer uses property prune conditional fp trees generated itemset discovery phase 
particular uses di erent pruning methods combined substantially reduce search space runtime 
methods described rest section 
transaction pruning tp rst pruning scheme implemented lpminer uses smallest valid extension property eliminate entire candidate transactions conditional pattern base 
recall section frequent itemset generation fp growth algorithm builds separate fp tree transactions contain conditional pattern currently consideration 
cp conditional pattern length cp support 
cp infrequent know sve property order conditional pattern grow frequent cp 
requirement building corresponding conditional pattern eliminate transactions length shorter cp transactions contribute valid frequent itemset cp part 
refer transaction pruning method denote tp 
evaluated complexity method comparison complexity inserting transaction conditional pattern base 
parameters know prune transaction transaction inserted cp 
length transaction calculated constant time added original fp growth algorithm item transaction generated 
cp common values transactions conditional pattern base values need calculated conditional pattern base 
takes constant time added original fp growth algorithm calculate 
cp evaluating takes log jij execute binary search support table determined 
conditional pattern base tran 
complexity inserting transaction log jij 
assumption items contained value 
complexity method just constant time inserting transaction 
support node pruning np sve length itemset smallest valid extension sve second pruning method focuses pruning certain nodes conditional fp tree conditional pattern base generated 
consider node fp tree 
item stored node support item conditional pattern base height longest path root leaf node 
sve property node contribute valid frequent itemset length conditional pattern current conditional fp tree 
reason equation correct transactions go node longest itemset participate length 
support small requires itemset length greater itemset supported transactions go node equation hold node pruned fp tree 
node pruned decrease height nodes possibly allowing pruning 
refer node pruning method np short 
akey observation tp np methods prunes portions fp tree 
particular np methods prune node path longer cp item node lower support cp 
hand tp reduces frequency itemsets fp tree removing entire short transactions 
example consider transactions 
assume cp items support equal cp 
case np remove nodes tp eliminate second transaction 
order perform node pruning need compute height traverse node see violates equation 
node pruned height nodes longest path goes decremented support needs decremented take account removal time tree nodes pruned may eligible pruning 
particular rest nodes item needs aswell nodes height decremented removal initial experiments implementation showed cost performing pruning quite higher saving achieved conjunction tp scheme 
reason implemented approximate fast version scheme achieves comparable degree pruning 
approximate np algorithm initially sorts transactions conditional pattern base decreasing transaction length traverses transaction order tries insert fp tree 
transaction length 
inserted fp tree may share pre transactions fp tree 
soon insertion results new node created check see prune equation 
particular newly created node transactions inserted fp tree decreasing length 
pruned done new node eliminated insertion continues item 
items inserts new node pruned equation 
equation original length transaction length removal item previously pruned 
reason correct upper bound transactions inserted may length length current transaction modify height 
approach approximate elimination node ects nodes eliminated subsequent transactions nodes tree ii pessimistic bounds height node discussed previous paragraph 
approximate approach increase complexity generating conditional fp tree sorting transactions conditional pattern base 
length transaction falls small range sorted bucket sort linear time 
path pruning pp tree single path original fp growth algorithm generates possible combinations items path concatenates combinations conditional pattern 
path contains items exist total combinations 
sve property limit number combinations may need consider 
fi items ij ij 
way generating possible combinations grow incrementally follows 
create sets contains 
generate pair contains leading di erent sets 
continuing process total times obtain possible combinations items 
approach essentially builds binary tree levels edges nodes correspond possible combinations 
binary tree shown 
sve property prune certain subgraphs tree combinations explored consider particular internal node tree 
height node root height zero number edges path root words number items included far set 
sve property expanding tree node essentially states frequency current item set su ciently large number items frequent 
number items inserted set small plus number items left possible insertion su ciently large frequent itemsets generated branch tree pruned 
refer method path pruning pp short 
complexity pp binary tree log jij need evaluate items 
hand original fp growth algorithm complexity binary tree 
smaller large small analysis tells pp may cost saving 
experimental result suggests ect pruning pays price 
experimental results edge left child edge right child binary tree experimentally evaluated various search space pruning methods lpminer variety datasets generated synthetic transaction generator provided ibm quest group evaluating apriori algorithm 
experiments performed intel linux workstations pentium iii mhz gb main memory 
reported runtimes seconds 
classes datasets ds ds 
classes datasets contained transactions 
classes generated di erent problem instances varied average size transactions items items ds obtaining total di erent datasets ds ds items items ds obtaining ds ds 
problem instance ds ds set average size maximal long itemset increases dataset contains longer frequent itemsets 
di erence ds ds problem instance ds consists items problem instance ds consists items 
characteristics datasets summarized table 
parameter ds ds jdj number transactions jt average size transactions jij average size maximal potentially long itemsets jt jt jlj number maximal potentially large itemsets number items table parameters datasets tests experiments minimum support constraint decreases linearly length frequent itemsets 
particular ds datasets initial value support set decreased linearly itemsets length rest itemsets support kept xed 
left graph shows shape support curve ds 
case ds class datasets similar approach generate constraint minimum support 
right graph shows shape support curve ds 
lpminer dataset fp growth np tp pp np tp np pp tp pp np tp pp ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds table comparison pruning methods ds lpminer dataset fp growth np tp pp np tp np pp tp pp np tp pp ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds ds table comparison pruning methods ds support results support curve ds length patterns length patterns support curve ds ds support support curve ds tables show experimental results obtained ds ds datasets respectively 
row tables shows results obtained di erent ds ds dataset speci ed rst column 
remaining columns show amount time required di erent itemset discovery algorithms 
column labeled fp growth shows amount time taken original fp growth algorithm constant support constraint corresponds smallest support support curve ds ds 
columns heading lpminer show amount time required proposed itemset discovery algorithm uses decreasing support curve prune search space 
total di erent varieties lpminer algorithm di erent combinations pruning methods described section 
example column label np corresponds scheme uses node pruning section column labeled np tp pp corresponds scheme uses di erent schemes described section 
note values correspond experiments aborted long time 
number interesting observations results tables 
lpminer methods performs better fp growth algorithm 
particular lpminer uses pruning methods best requiring substantially smaller time fp growth algorithm 
ds times faster ds times faster ds times faster ds times faster ds 
similar trends observed ds performance lpminer times faster ds times faster ds times faster ds 
second performance gap fp growth lpminer increases length discovered frequent itemset increases recall ds ds length frequent itemsets increases 
due fact itemset space lpminer prune larger leading improved relative performance 
third comparing di erent pruning methods isolation see np tp lead largest runtime reduction pp achieves smallest reduction 
surprising pp prune itemsets late stages itemset generation 
runtime pruning methods increases gradually average length transactions discovered itemsets increases runtime original fp growth algorithm increases exponentially 
algorithm ciently nd frequent itemsets satisfy length decreasing support constraint 
key insight enabled achieve high performance smallest valid extension property length decreasing support curve 
agrawal srikant 
fast algorithms mining association rules 
vldb 
agarwal aggarwal prasad 
tree projection algorithm generation large itemsets association rules 
ibm research report rc nov 
cohen datar fujiwara gionis indyk motwani ullman yang 
finding interesting associations support pruning 
icde 
han pei yin 
mining frequent patterns candidate generation 
sigmod 
liu hsu ma 
mining association rules multiple minimum supports 
sigkdd wang han 
mining frequent itemsets support constraints 
vldb zaki 
scalable algorithms association mining 
ieee transactions knowledge data engineering zaki hsiao 
charm cient algorithm closed association rule mining 
rpi technical report 
zaki gouda 
fast vertical mining di sets 
rpi technical report 
