modal analysis staged computation rowan davies frank pfenning may cmu cs school computer science carnegie mellon university pittsburgh pa published fox memorandum cmu cs fox show type system intuitionistic modal logic provides expressive framework specifying analyzing computation stages context functional languages 
main technical result conservative embedding nielson nielson level functional language language mini ml addition partial evaluation supports multiple computation stages sharing code multiple stages run time code generation 
research sponsored defense advance research project agency title fox project advanced development systems software arpa order issued esd avs contract 

views contained document authors interpreted representing official policies expressed implied defense advanced research projects agency government 
keywords modal logic level languages partial evaluation run time code generation contents modal mini ml explicit formulation syntax typing rules operational semantics example power function explicit form implementation issues modal mini ml implicit formulation syntax typing rules examples implicit form translation explicit language level language syntax typing rules translation implicit modal mini ml equivalence binding time correctness modal correctness examples ackermann function inner products regular expression matching dividing computation separate stages common informal technique derivation algorithms 
example matching string regular expression may compile regular expression finite automaton execute automaton string 
partial evaluation divides computation stages early availability function arguments 
binding time analysis determines part computation may carried static phase part remains done second dynamic phase 
takes considerable ingenuity write programs way exhibit proper binding time separation computation pertaining statically available arguments fact carried 
programmer point view desirable declare expected binding time separation obtain constructive feedback computation may staged expected 
suggests binding time properties function expressed types prescriptive type system binding time analysis form type checking 
level functional languages nn partial evaluation gj hen shows view possible fruitful 
type systems motivated algorithmically explicitly designed support partial evaluation 
show motivated logically proper logical system expressing computation stages intuitionistic variant modal logic 
observation immediately gives rise natural generalization standard binding time analysis allowing multiple computation stages sharing code multiple stages communication binding time information module boundaries types 
extend curry howard isomorphism proofs programs intuitionistic logic intuitionistic modal logic obtain natural logical explanation computation stages 
world kripke semantics modal logic corresponds stage computation 
term type corresponds code executed current stage computation 
modal restrictions imposed type form guarantee function type carry computation concerned argument generating residual code type starting points investigation systems intuitionistic modal logic bdp pw level calculus nn 
augment recursion obtain mini ml show level functional language may fully faithfully embedded mini ml verifies mini ml conservative extension level language nn correctly expresses standard binding time separation 
pw sketch compilation mini ml related language mini ml operational semantics embodies separation evaluation multiple stages 
language mini ml contains constructs similar lisp backquote comma eval allowing existing program easily divided stages language mini ml expresses staging form may directly executed 
modal analysis staged computation modal mini ml explicit formulation section presents mini ml language combines elements mini ml modal calculus intuitionistic bdp pw 
presentation modal constructs differs form de constructing boxed values contexts typing rules 
avoids need syntactic substitutions alter essential properties system 
sake simplicity language explicitly typed treat type inference 
chosen include polymorphism issues regarding interaction type variables computation stages distract main point 
syntax types nat theta terms fix fst snd case box box contexts gamma delta gamma types gamma delta contexts variables assuming variable declared context 
bound variables may renamed tacitly 
omit leading delta contexts 
write result substituting renaming bound variables necessary order avoid capture free variables addition types mini ml introduces new term constructs box box elimination 
typing rules typing rules mini ml fragment explicit language completely standard 
problem typing modal fragment understood variant known systems bdp pw inspired zonal formulations linear logic girard lu gir 
formulation typing judgment contexts 
contains variables may appear represent code 
second contains variables available current computation stage including ordinary mini ml variables 
judgement delta gamma correspond delta gamma appropriate obvious translation note system property valid term unique typing derivation 
modal mini ml explicit formulation calculus fragment 
gamma tpe lvar delta gamma delta gamma tpe lam delta gamma delta gamma delta gamma tpe app delta gamma mini ml fragment 
delta gamma tpe fix delta gamma fix delta gamma delta gamma tpe pair delta gamma theta delta gamma theta tpe fst delta gamma fst delta gamma theta tpe snd delta gamma snd tpe delta gamma nat delta gamma nat tpe delta gamma nat delta gamma nat delta gamma delta gamma nat tpe case delta gamma case modal fragment 
delta tpe delta gamma delta delta tpe box delta gamma box delta gamma delta gamma tpe box delta gamma box note rule tpe box allow variables bound second context appear body box constructor rule tpe box binds variables context 
modal analysis staged computation operational semantics mini ml fragment system standard operational semantics 
modal part interpret box value containing frozen computation may carried stage 
evaluate box substitution residual code generated evaluating residual code evaluated evaluation necessary 
note 
unique 
mini ml property easy establish induction structure evaluation 
note omitted types terms rules irrelevant 
values hv box calculus fragment 
ev lam 



ev app 
mini ml fragment 
fix 
ev fix fix 


ev pair 
hv 
hv ev fst fst 

hv ev snd snd 
ev 

ev 


ev case case 


ev case case 
modal mini ml explicit formulation modal fragment 
ev box box 
box 
box 
ev box box 
note evaluation typed terms terms inside box constructor substituted box constructor 
example power function explicit form show define power function mini ml way type nat nat nat assuming closed term times nat nat nat definable mini ml fragment standard way 
power fix nat nat nat nat case box nat sz box nat times qx type nat nat nat expresses function evaluates depends argument type nat exponent return residual code type nat nat 
calculate operational semantics power 
box nat power 
box nat times nat power 
box nat times nat times nat modulo trivial redices variables variables result expect partial evaluation 
implementation issues operational semantics mini ml may implemented translation pure mini ml mapping unit box unit box unit may appear modal fragment mini ml redundant 
note type unit express binding time properties 
precisely distinction mini ml interesting type checker reject programs may execute correctly desired binding time separation violated 
modal operator property expressed consequently checked 
implementation method interpret data type representing code calculates value type code machine code source code intermediate language 
allow optimization specialization support operation output code separate program 
representation support substitution code fragment required ev box rule 
code machine code naturally leads idea templates run time code generation see 
deferred compilation approach ll provide sophisticated implementation supporting fast run time generation optimized code 
modal analysis staged computation modal mini ml implicit formulation define implicit version mini ml explicit mini ml pw implicit system defined 
system reasonable programming language explicitly stage computation required box operational semantics new system terms type preserving compilation explicit system 
development differs pw introduce term constructor pop 
means typing derivations valid terms unique compilation implicit explicit terms deterministic avoiding unpleasant problems concerning coherence 
syntax types nat theta terms fix hm fst snd case box unbox pop contexts gamma delta gamma context stacks psi delta psi gamma categories context stacks standard 
importance context stacks apparent typing rules 
typing rules section typing rules mini ml context stacks 
typing judgment form psi gamma term type local context gamma stack psi 
context stack enables distinguished variables depending relative position respect box operators enclose term typed 
intuitively element gamma context stack psi corresponds computation stage 
variables declared gamma ones values available corresponding evaluation phase 
encounter term box enter new evaluation stage frozen evaluation 
new phase allowed refer variables prior phases may available unboxed 
variables may looked current innermost context rule tpi var initialized empty enter scope box rule tpi box 
code generated current earlier stages may represented rules tpi unbox tpi pop 
modal mini ml implicit formulation calculus fragment 
gamma tpi var psi gamma psi gamma tpi lam psi gamma psi gamma psi gamma tpi app psi gamma mini ml fragment 
psi gamma tpi fix psi gamma fix psi gamma psi gamma tpi pair psi gamma hm theta psi gamma theta tpi fst psi gamma fst psi gamma theta tpi snd psi gamma snd tpi psi gamma nat psi gamma nat tpi psi gamma sm nat psi gamma nat psi gamma psi gamma nat tpi case psi gamma case modal fragment 
psi gamma delta tpi box psi gamma box psi gamma tpi unbox psi gamma unbox psi delta tpi pop psi delta gamma pop note may useful consider modal fragment implicit language statically typed analogue quoting mechanism lisp 
box corresponds backquote unbox pop delta comma 
unbox corresponds eval pop corresponds quoting expression generated comma 
note implementation compilation mini ml quite different lisp quoting 
modal analysis staged computation examples implicit form show define power function mini ml simpler form mini ml type nat nat nat 
unbox syntactic sugar unbox pop 
power fix nat nat nat nat case box nat box nat times unbox example show define function type nat nat returns box ed copy argument lift nat fix nat nat nat case box box unbox similar term type returns box ed copy argument exists exactly observable contains 
justifies inclusion lift primitive level languages gj fact realistic version language included primitive 
translation explicit language define operational semantics mini ml directly depend translation mini ml translation recursively extracts terms inside pop constructor binds result evaluation new variables bound box outside enclosing box constructor 
variables bound occur exactly 
compilation implicit explicit terms easily understood restrict pop occur immediately underneath unbox pop 
pure fragment terms follow grammar terms box unbox pops pop extension full language including recursion tedious trivial 
term transformed satisfying restriction replacing isolated occurrences pop box unbox pop pop 
compilation keeps track context term translated placed argument 
necessary encounter pop operator find matching box operator insert box binding resulting explicit term 
notation context hole filling hole written application 
implemented syntactic replacement intended capture variables level language free translation terms box box unbox nested pop operators translated traversing current context inside box operator 
cancels pop operator continues translation 
pop operators removed possibly introduce box continue translation 
argument accumulates body box eventually introduced 
pop pop pop pop pop pop pop box box pop box pop box pop box pop box box new occur exactly cases pop leave original term typed case arise 
important invariant remains recursive call 
formally proven translation maps typed explicit terms typed implicit terms 
related slightly complicated translation proven correct pw 
example translation maps definition power previous explicit 
important note operational semantics induced translation different natural defined directly mini ml mm simple reduction semantics system similar implicit system introduced reflect binding time separation way :10.1.1.57.1556
prove church rosser theorem strong normalization pure modal calculus 
level language section define mini ml level functional language close described nn 
define simple translation mini ml prove binding time correctness mini ml equivalent modal correctness translation mini ml language differs slightly nn inject run time types compile time types just function types 
follows gj restriction 
find convenient divide variables contexts run time compile time involves small change rules 
differences nn due minor differences underlying language mini ml 
modal analysis staged computation syntax run time types nat theta compile time types oe nat oe oe oe terms fix fst snd case oe fix oe fst snd case run time contexts gamma delta gamma compile time contexts delta delta delta oe typing rules run time typing gamma tpr var delta gamma delta gamma tpr lam delta gamma delta gamma delta gamma tpr app delta gamma delta gamma tpr fix delta gamma fix delta gamma delta gamma tpr pair delta gamma theta delta gamma theta tpr fst delta gamma fst delta gamma theta tpr snd delta gamma snd tpr delta gamma nat delta gamma nat tpr delta gamma se nat delta gamma nat delta gamma delta gamma nat tpr case delta gamma case delta delta gamma level language compile time typing oe delta tpc var delta oe delta oe oe tpc lam delta oe oe oe delta oe oe delta oe tpc app delta oe delta oe oe tpc fix delta fix oe oe delta oe delta oe tpc pair delta oe delta oe tpc fst delta fst oe delta oe tpc snd delta snd oe tpc delta nat delta nat tpc delta se nat delta nat delta oe delta nat oe tpc case delta case oe delta delta delta note remove run time assumptions rule nn done rule 
change justified structure rules assumptions compile time deduction 
translation implicit modal mini ml translation mini ml simple 
translate run time compile time mini ml fragments directly insert box unbox pop represent changes phases 
define mutually recursive functions delta run time translation delta compile time translation 
overload notation types terms 
write match term top constructor matches phase annotation 
run time types nat theta theta modal analysis staged computation compile time types nat joe oe joe joe joe joe theta joe kk run time terms kxk kx ek kk kek ke ke ke ek fix kk kek kh ik ke ki ek fst kek ek snd kek kzk ks ek kek case ke ke ke kek unbox pop jej compile time terms jyj jy ej jej je je je ej fix jej jh ij hje je ji ej fst jej ej snd jej jzj js ej jej case je je je jej box kek equivalence binding time correctness modal correctness section state main theorem binding time correctness equivalent modal correctness translation mini ml write derivation judgment theorem 
kek delta gamma deltaj gammak kk deltaj gammak deltaj gammak kk level language 
jej delta oe deltaj joej deltaj delta oe joej proof simultaneous induction definitions kek jej 
note take advantage strong inversion properties exactly typing rule term constructor mini ml mini ml plus rules connect judgements 
show cases involving definitions easy 
note variables need rely phase annotations 
case kek unbox pop jej 
show part note inversion delta delta gamma applying part induction hypothesis get get deltaj jej kk tpi pop deltaj gammak pop jej kk tpi unbox deltaj gammak unbox pop jej kk show part note reverse roles inversion proof construction part induction hypothesis 
case jej box kek show part note inversion delta delta delta applying part induction hypothesis get get deltaj delta kek kk tpi box deltaj box kek kk show part note reverse roles inversion proof construction part induction hypothesis 
modal analysis staged computation examining proof verify translation level term type checked tpi unbox tpi pop rules tpi unbox immediately follows tpi pop 
corresponds weaker modal logic drop assumption accessibility relation reflexive transitive mm :10.1.1.57.1556
fact define language mini ml replacing unbox pop constructors equivalent unbox mm :10.1.1.57.1556
mini ml closely models mini ml permits arbitrary number phases execute code generated immediately preceding 
similar idea level languages nn linearly ordered fact level version mini ml exactly equivalent mini ml natural extension level translation 
similar multi level generating extensions gj 
interesting consider transitivity assumptions model context staged computation 
essentially allow execute generated code time immediately 
difficult achieve extension level language separation levels achieved duplicating term type constructors 
consider mini ml appropriate language study general forms staged computation including run time code generation 
examples standard examples partial evaluation illustrate expressiveness language mini ml introduce non polymorphic top level definitions may considered syntactic sugar ackermann function program calculating ackermann function specializes argument 
program ackermann fix acker nat nat nat nat case nat sn nat case acker acker acker attempt directly insert modal constructors divide program stages get ackermann fix acker nat nat nat nat case box nat sn box nat case unbox acker unbox acker unbox acker examples unfortunately applied argument function generally won terminate 
common problem partial evaluation usual solution employ memoization specialization works programs 
simply note problem case recursive call acker calculating acker removed adding additional fix follows 
ackermann fix acker nat nat nat nat case box nat sn box fix nat case unbox acker unbox acker function terminate 
recursive applications appearing inside unbox constructors evaluated argument 
compilation function mini ml explicit ackermann fix acker nat nat nat nat case box nat sn box acker box acker box fix nat case notice acker unnecessarily calculated twice 
avoided memoization employed compilation 
inner products gj calculation inner products example program phases 
show example coded mini ml note assumed data type vector example function sub nat vector nat access elements vector 
inner product example staging expressed mini ml follows iprod fix ip nat vector vector nat nat case vector vector vector vector plus times sub sub ip modal analysis staged computation add box unbox get function computation stages 
assume function lift nat defined earlier function sub nat vector nat specializing version sub pre computes pointer arithmetic array index 
define staged version times times avoids multiplication specialization argument zero 
speed application iprod third argument particularly case second argument sparse vector 
times nat nat nat box nat case box nat box nat times unbox lift nat iprod fix ip nat vector vector nat nat case box vector box vector box vector box vector plus unbox unbox times unbox sub unbox sub unbox unbox ip iprod vector vector nat iprod iprod vector nat unbox iprod iprod vector nat unbox iprod lines show execute result specialization unbox pop corresponding eval lisp 
occurrence unbox indicates code third stage generated 
aspects expressed multi level language 
note erasure unbox box constructors iprod leaves iprod different version multiplication 
operational semantics programs course quite different 
regular expression matching program regular expression matching specializes particular regular expression 
full standard ml language augmented modal constructors 
program non specializing continuation function called remaining input current matching succeeds 
datatype regexp empty plus regexp regexp times regexp regexp star regexp const string val accept regexp 
string list 
bool 
string list 
bool examples fun accept empty accept plus accept orelse accept accept times accept fn 
accept accept star orelse accept fn 
false accept star accept const str str andalso accept const str nil false val accept regexp 
string list 
bool fun accept accept fn nil 
true 
false note recursive call accept star case accept star transform local definition similar fix introduced ackermann function example 
done specialization respect regular expression terminates 
resulting code case accept star fun acc orelse accept fn 
false acc acc add modal constructors get staged program types represent val accept regexp 
string list 
bool 
string list 
bool val accept regexp 
string list 
bool types indicate required staging achieved program 
inserting modal constructors requires breaking function arguments relatively straightforward 
unbox unbox unbox pop delta 
fun accept empty box fn 
fn 
accept plus box fn 
fn 
unbox accept orelse unbox accept accept times box fn 
fn 
unbox accept fn 
unbox accept accept star box fn 
fn 
fun acc modal analysis staged computation orelse unbox accept fn 
false acc acc accept const str box fn 
fn 
case 
str andalso nil 
false fun accept box fn 
unbox accept fn 
case nil 
true 
false compilation explicit language mini ml get equivalently staged program modal operators 
translate program pure standard ml staged way modal annotations 
replace unit 
case box applied values 
show program demonstrate staging described modal annotated program 
program mini ml potential efficient optimized code generated sophisticated implementation 
val accept regexp 
string 
bool 
string 
bool fun accept empty fn 
fn 
accept plus val accept val accept fn 
fn 
orelse accept times val accept val accept fn 
fn 
fn 
accept star val accept fun acc orelse fn 
false acc fn 
fn 
acc accept const str fn 
fn 
str andalso nil 
false val accept regexp 
string 
bool fun accept accept fn nil 
true 
false proposed logical interpretation binding times staged computation terms intuitionistic modal logic 
explicit language mini ml including recursion natural numbers pairs natural operational semantics 
language verbose practical continued defining implicit language mini ml syntactic sugar serve core extension language complexity standard ml 
operational semantics mini ml compilation mini ml generalizes nielson nielson level functional language nn demonstrated conservative embedding theorem main technical result 
level language consider mini ml directly nn stricter binding time correctness criterion example gj 
essentially restriction may traced fact underlying evaluation model applies closed terms gj require evaluation terms free variables 
gluck jrgensen gj multi level binding time analysis strict binding time correctness criterion practical motivations multi level partial evaluation treat higher order functions 
modal operator similar operator temporal logic looks promising candidate model looser correctness criterion develop line research 
language mini ml requires insertion box unbox pop coercions functional program 
may preferable coercions remain implicit language valid expressions longer unique principal types raising coherence problems 
intend study language modal types considered refinements usual mini ml types intersections express principal types see fp analogous non modal refinement types 
refinement type inference language form generalized polyvariant binding time analysis 
compilation type directed generating different versions functions appropriate different computation 
programmer control process refinement type constraints imposed functions type annotations 
type inference language need depend strongly subtyping implicit coercions refinement types 
operational semantics naive partial evaluation point view 
particular specialization 
semantics desirable serious implementation require restrictions side effects 
see bw description serious partial evaluator standard ml part inspired 
treat polymorphism cause problems 
expect type system interact ml module system 
fact part motivation provide programmer means specify staging binding time information signature propagate module boundaries 
modal analysis staged computation approach provides general logically motivated framework staged computation includes aspects partial evaluation run time code generation 
allow efficient code generated declarative style programming provides automatic check intended staging achieved 
implemented simple version mini ml logic programming language elf pfe 
date experimented small examples plan carry realistic experiments near 
gratefully acknowledge discussions lars birkedal olivier danvy despeyroux andrzej filinski greg morrisett morten hao chi wong regarding subject 
bdp gavin bierman valeria de paiva 
intuitionistic necessity revisited 
proceedings logic conference amsterdam holland december 
bw lars birkedal morten 
partial evaluation standard ml 
technical report diku report diku department computer science university copenhagen october 
dominique cl ement despeyroux thierry despeyroux gilles kahn 
simple applicative language mini ml 
proceedings conference lisp functional programming pages 
acm press 
fp tim freeman frank pfenning 
refinement types ml 
proceedings sigplan symposium language design implementation toronto ontario pages 
acm press june 
gir jean yves girard 
unity logic 
annals pure applied logic 
gj carsten gomard neil jones 
partial evaluator untyped lambda calculus 
journal functional programming january 
gj robert gluck jesper jrgensen 
efficient multi level generating extensions 
unpublished manuscript 
hen fritz henglein 
efficient type inference higher order binding time analysis 
hughes editor functional programming languages computer architecture th acm conference volume lecture notes computer science pages 
springer berlin heidelberg new york 
david keppel susan eggers robert henry 
case runtime code generation 
technical report tr department computer science engineering university washington november 
ll mark leone peter lee 
deferred compilation automation run time code generation 
proceedings workshop partial evaluation semantics program manipulation pepm orlando june 
earlier version appears carnegie mellon school computer science technical report cmu cs november 
mm simone martini andrea masini :10.1.1.57.1556
computational interpretation modal proofs 
wansing editor proof theory modal logics 
kluwer 
workshop proceedings appear 
nn flemming nielson hanne riis nielson 
level functional languages 
cambridge university press 
pfe frank pfenning 
logic programming lf logical framework 
erard huet gordon plotkin editors logical frameworks pages 
cambridge university press 
pw frank pfenning hao chi wong 
modal calculus 
brookes main editors proceedings eleventh conference mathematical foundations programming new orleans louisiana march 
appear electronic notes theoretical computer science volume elsevier 
