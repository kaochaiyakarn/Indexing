experimental evaluation assumption independence multi version programming john knight nancy lev department computer science department computer science university virginia university california charlottesville virginia irvine california version programming proposed method incorporating fault tolerance software 
multiple versions program prepared executed parallel 
outputs collected examined voter identical assumed majority correct 
method depends reliability improvement assumption programs developed independently fail independently 
inthis experiment described fundamental axiom tested 
versions program prepared independently specification universities subjected tests 
results tests revealed programs individually extremely reliable number tests program failed substantially expected 
results tests analysis faults programs 
background information programmers summarized 
experiment version programming care analysis reliability include effect dependent errors 
ke phrases multi version programming version programming software reliability fault tolerant software design diversity 
sponsored part nasa number nag part micro state california hughes aircraft 

multi version version programming proposed method providing fault tolerance software 
approach requires separate independent preparation multiple versions piece software application 
versions executed parallel application environment receives identical inputs produces version required outputs 
outputs collected voter principle 
practice may disagreement 
occurs results majority assuming assumed correct output output system 
separate development start different points software development process 
version software provide functional capability exist common form system requirements document 
coordination exist versions provide data voter especially intermediate data compared final output data 
obviously design specification redundant independent versions chance avoiding common design faults 
interesting approach dual specification ramamoorthy independent specifications written formal specification language formal mathematical techniques verify consistency specifications step development proceeded 
able detect specification faults redundancy repair separate software versions produced 
kelly avizienis separate specifications version programming experiment specifications written person independence syntactic different specification languages 
version programming faced practical difficulties implementation isolation versions design voting algorithms 
difficulties summarized comprehensively anderson lee discussed 
great benefit version programming intended provide substantial improvement reliability 
assumed analysis technique different versions fail independently faults different versions occur random unrelated 
probability versions failing input small 
assumption probability failure version system approximation proportional th power probability failure independent versions 
assumption true system reliability higher reliability individual components 
concerned assumption false 
intuition indicates solving difficult intellectual problem writing computer program people tend mistakes example incorrect treatment boundary conditions working independently 
parts problem may inherently difficult 
experiment described subjects asked questionnaire state parts problem caused difficulty 
responses surprisingly similar 
interesting note systems redundancy technique achieving fault tolerance common design faults source serious problems 
aircraft crashed common vibration mode adversely affected parts redundant system 
common failure mode analysis critical hardware systems attempt determine minimize common failure modes 
assumption independence born practice version software system cause analysis overestimate reliability 
shown small probabilities coincident errors cause substantial reduction reliability 
important practical problem version programming existing crucial systems planned 
instance dual programming flap control system airbus aircraft 
programs executed different microprocessors operating asynchronously 
outputs microprocessors compared continuously difference greater defined threshold causes system disconnect preset time delay 
onthe sufficient know failure backup procedures allow continued safe flight landing aircraft 
dual programming applied point switching signal control traffic control gothenburg area swedish state 
system programs show different results signal lights switched red 
dual programming proposed safety systems nuclear reactors 
proposed design reactor shutdown system serves purpose detecting cooling disturbances fast breeder reactor initializing automatic shutdown reactor case possible emergency 
ramamoorthy proposed elaborate dual development methodologies design nuclear reactor safety systems 
argument favor programming testing safety critical real time software simplified producing versions software executing large numbers test cases manual independent verification correct output 
output assumed correct long versions programs agree 
argument preparing test data determining correct output difficult expensive real time software 
assumed programs contain identical faults large number test cases run relatively short time large reduction effort required validation test results 
addition argued individual version software lower reliability necessary version produced 
higher required software reliability assumed obtained voting process additional cost incurred development multiple software versions offset reduction cost validation process 
suggested elaborate software development environments procedures unnecessary mail order software obtained programmers 
important point note arguments favor redundant programming hinge basic assumption probability common mode failures identical incorrect output input low independently developed software 
important know assumption correct 
previous experiments inv version programming focused issue independence 
independence assumed tested 
versions developed assumed correct outputs test cases agreed attempt verify independently correctness output 
common errors necessarily detected 
experiments common errors observed independence hypothesis tested design experiments draw statistically valid 
kelly avizienis report finding related faults common fault practical tests nuclear reactor project taylor reports common faults half practical redundant european software systems 
summary negative evidence raises doubts independence assumption experiment attempted study assumption manner clear evidence drawn 
independence assumption widely accepted potential importance issue terms safety carried large scale experiment version programming study assumption 
statistically rigorous test independence major goal experiment design decisions taken dominated goal 
note inthe hardware triple modular redundancy tmr systems idea version programming arises system reliability improved ifthe individual components sufficiently reliable 
fact incorporating redundancy system reduce system reliability due increased number components 
experiment results remainder 
insection describe experiment review backgrounds programmers activities experiment section 
results tests performed various versions section 
section contains model independence statistical test hypothesis model valid 
faults programs experiment described section various issues arising experiment discussed section 
section requirements specification experiment included appendix 

description experiment graduate senior level classes computer science university virginia uva university california irvine uci students asked write programs single requirements specification 
result total programs uva eighteen uci produce output input 
programs subjected randomly generated test cases 
order experiment realistic attempt choose application normally candidate inclusion fault tolerance 
problem selected programming simple realistic anti missile system came originally aerospace 
program required read data represents radar reflections collection conditions decide reflections come object threat 
decision object threat signal launch interceptor generated 
problem known launch interceptor problem various conditions decision depends referred launch interceptor conditions lic 
conditions heavily parameterized 
example condition asks set reflections contained circle radius radius parameter 
problem software engineering experiments 
version programming equal carried research triangle institute rti 
chose problem suitability able lessons learned experiment rti modify experiment 
rti prepared requirements specification experienced difficulties unexpected ambiguities similar problems 
able rewrite requirements specification light experience 
requirements specification carefully debugged prior experiment 
requirements specification tothe students asked prepare software comply 
software development methodology imposed 
required write program pascal specified compiler associated operating system 
uva university hull mode pascal compiler prime computers uci berkeley vax unix 
students explanation goals experiment principles version programming 
need independent development stressed students carefully instructed discuss project 
impose restriction sources 
application requires knowledge geometry itwas expected students consult texts mathematicians order develop necessary algorithms 
felt possibility students material different separate organizations sources commercial development environment 
expected development questions arose meaning requirements 
order prevent possibility information inadvertently transmitted informal verbal response questions submitted answered electronic mail 
question revealed general flaw inthe specifications response broadcast programmers 
student supplied fifteen input data sets expected outputs debugging 
program debugged tests tests student developed subjected acceptance test 
acceptance test set randomly generated test cases different set tests generated program 
different data sets program prevent general filtering faults common acceptance test 
acceptance test felt real software production environment potential programs submitted extensive testing demonstrated high level reliability 
data generated randomly test case generator written tailored application 
program passed acceptance test considered complete entered collection versions 
acceptance test represents realistic amount validation type software discussed section resulted highly reliable programs shown 
result earlier experiment rti difficulty machine precision differences versions 
programs computed amounted result different orders computation yielded minor differences gav impression versions failed 
prevent programmers experiment supplied function perform comparison real quantities limited precision 
programmers instructed supplied function real number comparisons 
versions passed acceptance tests versions subjected experimental treatment consisted simulation production environment 
test driver built generated random radar reflections random values parameters problem 
programs executed test cases determination success comparing output eighth version referred gold program 
program originally written fortran rti experiment rewritten pascal experiment 
part rti experiment gold program subjected test cases considerable confidence accuracy 
subjected extensive structured walkthrough uva translation pascal 
version larger number test cases executed possible manual checking outputs performed 
naturally undetected fault existed versions including gold version 
effect final results additional undetected common faults strengthen 
tests run versions written experiment gold program 
testing continuous ofthe machines total fifteen computers performing tests may september primes dual processor cdc cyber uva vax cdc cyber langley research center 

programmer backgrounds experiment programmers asked maintain simple logs fill questionnaires backgrounds 
section give general information programmers previous experience education effort level obtained logs questionnaires 
data provided summary form 
deliberately associate specific background information individual versions order protect identity programmers 
section questionnaires 
questionnaire programmer obtained analysis 
fourteen programmers working degrees prior degree masters degrees held degree doctoral degrees held masters degree 
held degrees mathematics computer science astronomy biology environmental science management science physics 
programmers taken number undergraduate courses mathematics computer science 
taken graduate courses computer science graduate mathematics courses 
number undergraduate hours varied computer science mathematics 
number graduate hours varied zero computer science zero mathematics 
programmers previous experience computer field varied years 
programmers worked months usually form vacation employment 
programmers asked rate knowledge pascal expert thorough fair limited 
ofthe rated knowledge expert eighteen thorough fair 
programmers asked estimate reliability programs 
gav estimates 
programs reliable programmers estimated 
effort level estimates obtained logs necessarily approximate maintained logs 
asked record time spent reading requirements specification designing implementing program debugging testing program 
reading time varied hours average design time hours average debugging time hours average 

experimental results test case executed program produces boolean array element boolean vector single boolean launch decision total results 
program calculates results simulated radar tracking data various parameters randomly generated test case 
launch condition true output application 
results really intermediate produced specifications require part determination launch condition 
programs written experiment results supplied driver program testing allow error detection 
record failure particular version particular test case discrepancy results produced version produced gold program version causes form exception negative square root raised execution test case 
quality programs written experiment remarkably high 
table shows observed failure rates versions 
failures recorded versions remainder successful tests 
successful tests 
table shows number test cases version failed input 
find surprising test cases occurred versions failed 
multiple failure occurred input natural suspect failures occurred versions supplied universities involved 
argued students university similar background tend cause dependencies 
exact opposite 
table shows correlation matrix common failures versions supplied universities 
table table versions numbered came uva versions numbered came uci 
entry location shows table version failure data version failures pr success version failures pr success table occurrences multiple failures number probability occurrences table correlated failures uva uci uva versions uci versions number times versions failed input 
table rows labeled uci version numbers columns uva version numbers 
non zero table entry show number common failures experienced uva version uci version 
preliminary analysis common faults involve versions schools 

model independence separate versions program may fail input fail independently 
failures dependent 
base probabilistic model experiment statistical definition independence tw ev ents independent conditional probability occurring occurred probability occurring vice versa 
pr pr pr pr 
intuitively aand independent knowledge occurrence way influences occurrence vice versa 
null hypothesis wish test derived statement 
examining faults flaws program logic revealed testing determine set programs contain correlated faults 
experiment intend part extensive analysis 
operational viewpoint matter programs fail input merely matters 
examining hypothesis independence examine observed behavior programs execution 
analysis hypothesis independence results tests carried evaluation faults programs source text 
giv en program assume probability failure test case 
reasonable prior testing knowledge presence faults test cases generated randomly 
ifthe programs fail independently individual probabilities failure versions probability failures test case 
probability exactly version fails test case pn pn probability versions fails particular test case total test cases executed number times versions fail input data 
hypothesis independent failures quantity binomial distribution parameter 


value sufficiently large normal approximation binomial distribution 
done quantity np np distribution closely approximated standardized normal distribution 
experiment null hypothesis model data 
estimate quantity observed probabilities failure shown table 
versions tests executed number tests version failed 
parameters statistic value 
greater point standard normal distribution reject null hypothesis confidence level 
conclude model hold 
clearly potential problem model derived assumption independent failures 
reject assumption 

analysis faults define fault instance program text particular version causes version fail program text executed test case 
various launch conditions computed similar description 
programmer mistake implementing different similar launch conditions record different faults 
faults detected program versions experiment 
numbers faults individual versions shown table 
faults table faults located version version faults version faults corrected 
corrective code installed selectively enabled extensive analysis faults undertaken 
ofthe faults unique individual versions occurred version 
refer non correlated correlated 
details faults quite complex complete description scope 
section description non correlated correlated faults illustrative purposes 
recall versions experiment required pass tests part acceptance procedure 
faults described section survived acceptance procedure 
non correlated faults describe recognized commonly occurring 
subtle important 
omission programmer assignment value function path function 
checked ofthe compilers experiment 
result executing particular path function function returned happened memory location allocated result 
effect implementation dependent implementations initialize storage 
effect time dependent result obtained acceptable calls 
test cases particular fault caused version containing fail times 
second non correlated fault wrong expression index 
occurred versions 
required expression usually single identifier fault usually consisted wrong identifier 
example function call sam pts wrong index expression fourth parameter 
correct function call sam pts particular fault caused associated version fail times tests 
find surprising major faults occur programs doing extensive manipulation arrays cause relatively failures 
correlated faults general far obscure 
example involves comparison angles 
number cases specifications require angles computed compared 
comparisons real quantities limited precision real comparison function cases 
fault assumption comparison cosines angles equivalent comparison angles 
arbitrary precision correct assumption course application finite precision floating point arithmetic precision limited comparison 
versions written incorrect assumption 
borderline cases assumption false caused associated versions disagree gold program 
number failures attributable fault varied various versions particular fault caused version fail test case occasions 
fault attributed specifications 
caused fundamental lack understanding numerical analysis 
solution lies thorough analytic treatment arithmetic machine involved algorithms computation angles cosines 
second correlated fault example involved assumption angle subtended points 
recall program required process simulated dimensional radar data 
data points plane expressed euclidean coordinates 
specifications problem require determination data points simulated radar lie straight line 
possible determine examining angle subtended points regarding vertex ofthe angle 
angle zero angle degrees points lie straight line 
shows general case figures show cases points lie straight line 
fault programmer omission second case 
fault attributed specifications 
caused lack understanding geometry 
clear fault prevented basically attributable incomplete case analysis 
fact fundamental fault version effects different caused different numbers failures affected versions 
version failed times fault second times 
second failed 
reason difference interaction fault algorithms different versions 

discussion important problem performing experiments universities obtaining programmers realistic experience level 
experiment size extremely expensive undertake professional programmers experimental subjects 
students criticized unrealistic point versions written graduate students high grade point averages returned university having worked professional programmers entering professional programming workforce high levels graduation 
programmers year programming experience outside degree programs years years programming experience 
note program written experiment experienced real time programmer worked jet propulsion laboratory oak ridge contained multiple faults common programs 
argued results biased fact experimental subjects came similar backgrounds 
fact case 
considerable diversity education experience students backgrounds 
geographically separate universities contributes diversity subjects 
versions ranged length lines code 
smaller real time systems may include millions lines code 
faults occur interconnection components large modular system results experiment relate duplication small pieces large system 
interesting experiment larger problem 
practical standpoint economic factors projects afford complete duplication software 
alternative critical functions identified separated critical functions fault tolerance features applied components greatest potential damage case failure 
respect problem experiment realistic 
argued experiment reflect realistic program development industry test cases reflect operational time programs type 
fact acceptance test equivalent elaborate testing process production programs type 
test cases represents unusual event seen radar 
time radar echoes identical scan occasional change due entry object field view 
producing realistic unusual events test production tracking program clearly expensive undertaking feel events realistic number 
test cases hours computer time version corresponds dealing unusual cases production 
practice events separated larger number executions usual events 
program executed second unusual events occur minutes tests correspond years operational 

particular problem programmed experiment conclude assumption independence errors fundamental analysis version programming hold 
probabilistic model independence results indicate model rejected confidence level 
important understand meaning statement 
conditional application 
result may may extend programs know 
experiments carried gather data similar order able draw general 
result suggest version programming crucial systems failure endanger human lives example deferred evidence available 
point result mean version programming 
means reliability version system may high theory predicts assumption independence 
implementation issues resolved particular version system required reliability achieved larger value coincident errors model predict reliability 
preliminary analysis faults programs approximately half total software faults involved programs 
surprisingly high implies programmers large number similar faults alternatively common faults remain debugging testing 
alternative hypotheses possible need explored 
certain parts problem just difficult lead faults different programmers 
fault distribution artifact problem programmer random 
possible hypothesis unique random faults tend caught compiler testing 
common faults may reflect inherently difficult semantic aspects problem typical human misconceptions easily detected standard verification validation efforts 
final possibility common faults may reflect flaws requirements specification document 
think case experiment great care went preparation requirements specification debugged earlier experiment 
furthermore particular common faults experiment quite subtle 
opinion involve ambiguity inconsistency inthe specification 
common faults shown experiments possible separately developed multiple versions software system relying random chance get diversity programs eliminate design faults may effective 
er mean diversity possible solution software fault tolerance problem 
imply research common faults may useful 
hardware designers rely simple redundancy independently generated diverse designs get rid common design faults 
sophisticated techniques determine common failure modes systematically alter designs attempt eliminate common failure modes minimize probability 
need equivalent techniques software 
unfortunately simple simple solution just exist undoubtedly difficult problem 

pleasure acknowledge students wrote versions tested experiment finch fitzgerald irwin watts wilson uva higgins milne nguyen peck ritter sargent thomas thompson wong uci 
pleased acknowledge academic computer center university virginia facility central computer complex langley research center providing computer time allow programs tested 
design experiment due lois st jean susan brilliant paul responsible testing activities 
indebted janet dunham earl allowing learn experience gained earlier version experiment jo mahoney comments statistical analysis 
supported part nasa number nag part micro university california hughes aircraft 
possible written excellent facilities provided arpa computer networks 
appendix requirements specification document experiment 
version uva 
minor changes names document version uci 
launch program requirements specification part hypothetical anti ballistic missile system write parameterless pascal procedure called decide 
generate signal determines interceptor launched input radar tracking information 
radar tracking information available instant procedure called 
sections names input variables delimited name 
terms delimited term defined glossary document 
values quantities parameters problem provided determine combination possible launch interceptor conditions lic relevant immediate situation 
interceptor launch button normally considered locked relevant combinations launch conditions met launch unlock signal issued 
procedure determine fifteen lic istrue input set planar data points representing radar echoes 
lic specified functional requirements section document 
indicate lic satisfied set points fifteen elements conditions met vector cmv assigned boolean values true false element cmv corresponds lic 
input logical connector matrix lcm defines individual lic considered jointly way 
lcm symmetric matrix elements valued andd orr 
cmv elements combined indicated lcm resulting boolean values stored diagonal elements preliminary unlocking matrix pum symmetric matrix 
diagonal elements pum output procedure 
pum diagonal elements input procedure represent lic matter particular launch determination 
diagonal element pum indicates diagonal values pum row corresponding element final unlocking vector fuv element vector 
values fuv true launch unlock signal generated 
actual reading writing physical devices take place 
inputs procedure available global variables outputs procedure placed global variables 
hardware hardware software support procedure written execute pr equipment academic computing center university virginia 
software software facilities may prepare procedure operating system software tools subsystem optional text editor available systems hull mode pascal compiler pr user guide revision third edition anne 
published pr computer framingham massachusetts 
commands guide alice landy 
published pr computer framingham massachusetts 
software tools subsystem user guide allen akin georgia institute technology atlanta georgia 
hull mode pascal compiler user manual version barry ian thomas university hull hull england 
pascal user manual report second edition kathleen jensen niklaus wirth 
published springer verlag new york 
functional requirements communication software calls procedure accomplished global variables constant defined section 
constant av procedure value global constant pi representing number radians degrees 
input variables values global variables available procedure numpoints number planar data points 
parallel arrays containing coordinates data points 
parameters record holding parameters lic lcm logical connector matrix 
pum diagonal elements preliminary unlocking matrix 
output variables values global variables set procedure pum diagonal elements preliminary unlocking matrix 
cmv conditions met vector 
fuv final unlocking vector 
launch final launch launch decision 
global declarations const global declarations follows pi type var connectors orr andd coordinate array real array connectors array boolean vector array boolean lt eq gt coordinate coordinates data points coordinate coordinates data points numpoints number data points parameters record length real length lics radius real radius lics epsilon real deviation pi lics area real area lics pts consecutive points lic quads quadrants lic dist real distance lic pts consecutive pts 
lic pts int 
pts 
lics pts int 
pts 
lics pts int 
pts 
lics pts int 
pts 
lic pts int 
pts 
lic pts int 
pts 
lics pts int 
pts 
lics pts int 
pts 
lic length real maximum length lic radius real maximum radius lic area real maximum area lic record parameters lcm logical connector matrix pum preliminary unlocking matrix cmv vector conditions met vector fuv vector final unlocking vector launch boolean decision launch launch function real compares real numbers see nonfunctional requirements required computations assumed input data parameters measured form units consistent units 
example lengths measured units define planar space input data comes 
unit conversion necessary 
parameter values global record parameters procedure decide evaluate launch interceptor conditions lics described set numpoints points numpoints numpoints numpoints conditions met vector cmv set results calculations global array element cmv set true ith lic met 
launch interceptor conditions lic defined follows exists set consecutive data points distance greater length length apart 
length exists set consecutive data points contained circle radius radius 
radius exists set consecutive data points form angle angle pi epsilon angle pi epsilon second consecutive points vertex angle 
point point coincides vertex angle undefined lic satisfied points 
epsilon pi exists set consecutive data points vertices triangle area greater area 
area exists set pts consecutive data points lie quads quadrants 
ambiguity quadrant contains point priority decision quadrant number ii iii iv 
example data point quadrant point quadrant ii point quadrant iii point quadrant point quadrant 
pts numpoints quads exists set consecutive data points 
exists set pts consecutive data points points lies distance greater dist line joining pts points 
points pts identical calculated distance compare dist distance coincident point points pts consecutive points 
condition met numpoints 
pts numpoints dist exists set data points separated exactly pts consecutive intervening points distance greater length length apart 
condition met numpoints pts numpoints exists set data points separated exactly pts pts consecutive intervening points respectively contained circle radius radius 
condition met numpoints pts pts pts pts numpoints exists set data points separated exactly pts pts consecutive intervening points respectively form angle angle pi epsilon angle pi epsilon second point set points vertex angle 
point point coincide vertex angle undefined lic satisfied points 
numpoints condition met 
pts pts pts pts numpoints exists set data points separated exactly pts pts consecutive intervening points respectively vertices triangle area greater area 
condition met numpoints 
pts pts pts pts numpoints exists set data points separated exactly pts consecutive intervening points 
condition met numpoints pts numpoints exists set data points separated exactly pts consecutive intervening points distance greater length length apart 
addition exists set data points different data points just mentioned separated exactly pts consecutive intervening points distance length length apart 
parts true lic true 
condition met numpoints 
length exists set data points separated exactly pts pts consecutive intervening points respectively contained circle radius radius 
addition exists set data points different data points just mentioned separated exactly pts pts consecutive intervening points respectively contained circle radius radius 
parts true lic true 
condition met numpoints 
radius exists set data points separated exactly pts pts consecutive intervening points respectively vertices triangle area greater area 
addition exist data points different data points just mentioned separated exactly pts pts consecutive intervening points respectively vertices triangle area area 
parts true lic true 
condition met numpoints 
area conditions met vector cmv conjunction logical connector matrix lcm form diagonal elements preliminary unlocking matrix pum 
entries lcm represent logical connectors pairs lics determine corresponding entry pum lcm represents boolean operator applied cmv cmv 
pum set result operation 
lcm pum set true 
lcm andd pum set true cmv cmv true 
lcm orr pum set true cmv cmv true 
note lcm symmetric lcm lcm 
example assume logical connector matrix shown logical connector matrix lcm lic 
andd andd orr andd 
andd andd orr orr 
orr orr andd andd 
andd orr andd andd 



assume entries cmv computed described giving results conditions met vector cmv condition value false true true true false 
false pum generated preliminary unlocking matrix pum lic 
false true false true true false true true true true true true true true true false true true true true true true true true true 
true true true true true 
diagonal elements input computed values 
explanation selected pum entries pum false lcm andd cmv cmv false 
pum true lcm orr cmv cmv true 
pum true lcm orr cmv cmv true 
pum true lcm andd cmv cmv true 
pum true lcm 
final unlocking vector fuv generated preliminary unlocking matrix 
input diagonal elements pum indicate corresponding lic considered factor signaling interceptor launch 
fuv set true pum false indicating associated lic hold back launch elements pum row true 
example assume pum appears follows preliminary unlocking matrix pum lic 
true false true false true true false false true true true true true true true true true true false true true false true true true true true true false true 
true true true true true false fuv generated explanation selected fuv entries final unlocking vector fuv condition value false true true true true 
true fuv false pum true pum pum false 
fuv true pum false 
fuv true pum true 
final launch launch decision fuv 
decision launch requires elements fuv true launch set true fuv true 
example launch false fuv false 
nonfunctional requirements functional requirements implemented parameterless pascal procedure named decide 
perform input output calling program provide input data global variables 
likewise decide store results global variables 
real numbers compared procedure decide comparison fixed amount precision 
program calls decide provide function called 
see function header declarations page 
function compares real numbers respect significant digits 
returns lt ifa decide call function comparisons real numbers 
information contained global variables subroutine called remain valid execution procedure 
feedback time series effects call decide multiple calls decide 
include input error checking 
assume calling program insures inputs complete specified range 
double precision complex variables 
constraints memory space execution time efficient structured code descriptive comments preferred 
writing subroutine language dependent software tools hull pascal compiler 
angle cmv consecutive glossary angle formed rays share common endpoint called vertex 
ray rotated vertex coincides ray amount rotation required measure angle 
points determine angle drawing ray second point point ray second point third point 
note different angles described ray rotated clockwise counterclockwise 
problem way lic defined 
conditions met vector cmv boolean vector elements correspondence launch interceptor conditions 
radar tracking data satisfy certain lic corresponding element cmv set true 
tw points consecutive adjacent input data vectors adjacent 
diagonal element fuv consider matrix rows columns 
diagonal elements matrix 
final unlocking vector fuv boolean vector basis deciding lcm lic matrix launch interceptor 
elements fuv true launch occur 
logical connector matrix lcm describes individual lic logically combined 
example value lcm indicates lic combine lic logical 
launch interceptor condition radar tracking data exhibit certain combination characteristics interceptor launched 
characteristic lic 
purposes problem matrix considered dimensional array 
diagonal element diagonal element matrix element diagonal element 
planar data points pum quadrant planar data points points located plane 
preliminary unlocking matrix element boolean pum corresponds element lcm 
logical connection dictated lcm element gives value true corresponding pum element set true 
axes cartesian coordinate system divide plane areas called quadrants 
labeled ii iii iv area coordinates positive radius ray vector vertex numbering counterclockwise 
length radius circle distance center circle point circle circumference 
straight line extends point 
purposes problem vector may considered dimensional array 
rays originate common point form angle point origination called vertex angle 
chen avizienis version programming tolerance approach reliability software operation digest papers ftcs eighth annual international conference fault tolerant computing toulouse france pp 
june 
ramamoorthy mok chin suzuki 
application methodology development validation reliable process control software ieee trans 
software engineering vol 
se pp 
nov 
kelly specification fault tolerant multi version software experimental studies design diversity approach ph dissertation university california los angeles 
kelly avizienis specification oriented multi version software experiment digest papers ftcs thirteenth international conference fault tolerant computing milan italy pp 
june 
anderson lee fault tolerance principles practice prentice hall international 
software safety security critical systems panel presentation compcon washington sept 
transcription panel session available albert friend washington 
eckhardt lee theoretical basis analysis redundant software subject coincident errors nasa technical memorandum nasa langley research center hampton virginia january 
martin dissimilar software high integrity applications flight controls software avionics conference proceedings pp 
january 
taylor letter editor acm software engineering notes vol 
pp 
january 
microprocessors safety oriented reactor shut system eds 
reliability electrical electronic components systems north holland pp 

inv methods production verification highly reliable software ed 
safety computer control systems proceedings pergamon press pp 

software diversity reactor protection systems experiment safety computer control systems proceedings pergamon press pp 

avizienis kelly fault tolerance design diversity concepts experiments ieee computer vol 
august 
microcomputer reliability improvement triple modular redundancy proceedings ieee vol 
pp 
june 
nagel software reliability repetitive run experimentation modeling prepared national aeronautics space administration boeing computer services seattle washington 
raff approximating point binomial amer 
statist 
ass vol 
brilliant analysis faults multi version software experiment thesis university virginia may 
st jean testing version independence multi version programming thesis university virginia january 

