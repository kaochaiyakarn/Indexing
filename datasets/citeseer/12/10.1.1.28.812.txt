proc 
acm symposium applied computing sac nevada march pp experience memory management open linda systems menezes florida institute technology department computer sciences west university blvd melbourne fl cs fit edu coordination systems particular linda established important tools developing applications open systems internet 
shows tackle forgotten crucial problem open coordination systems memory management 
system intends wide coordination systems address problems memory exhaustion memory nite resource 
rst explores separation coordination computation order clear problem memory exhaustion coordination systems solved garbage collection schemes implemented computation language garbage collection scheme exist coordination environment 
linda arguably successful coordination system focus linda family systems 
showing problem tackled linda expected solution coordination system implemented adapting method described 
keywords coordination systems garbage collection open systems linda 
linda surely caused impact computer science community 
proposal gelernter basic idea linda evolved point attracting attention industry 
major computer companies released commercial packages linda sun microsystems javaspaces ibm spaces 
path achieve recognition easy necessary nearly years research convince world linda abilities 
evolution linda changed model aimed parallel computing permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sac las vegas nv copyright acm model aimed distributed computing particular interesting open distributed computing 
rst implementations linda con ned closed controlled environments 
closed case problems little concern dealt compile time 
true open implementations linda 
existing problem handled compile time closed systems concern open case solutions implemented runtime involving dynamic recon guration data structures control race conditions 
additionally problems closed systems con ned boundaries single computation language hides idea coordination computation orthogonal concepts computation language de nes boundary coordination giving impression computation language deals coordination 
open systems situation di erent 
open applications implemented di erent languages di erent machines di erent operating systems complete heterogeneous environment 
heterogeneity stops computation languages able deal coordination problems problems break boundaries computation languages 
coordination problems need tackled coordination level coordination environment 
aim twofold 
develop way keeping information linda objects kernel optimizations implemented information 

describe information maintained tackle memory management problem linda 
garbage collection coordination objects performed computation language level 
garbage collection scheme implemented collect solely coordination objects 
multiple tuple spaces concept linda processes able create tuple spaces primitive provided 
open implementations linda tuple spaces remain forever system created 
argues implementation garbage collection system linda possible solution avoid memory exhaustion happening large applications implemented open linda systems 
divided follow 
section background discussed 
orthogonality argument gelernter carriero explained essential concept understanding memory resources coordination level managed computational languages 
brief linda models followed discussion open implementations model 
section explains memory exhaustion problem solved information available kernel level 
section shows information accessibility tuple spaces processes gathered distributed graph structure 
section shows go implementing garbage collection distributed graph kernel level 
section presents experimental results extracted implementation garbage collection described 
section presents 

background computation vs coordination orthogonality computation coordination may clear concept formally proposed 
linda model subsequent extension multiple tuple space model idea linda model exclusive parallel computing replaced idea having linda model distributed computing 
linda represent distributed system implementation embedded languages prolog 
gelernter carriero observing characteristic argued linda deal computation coordination aspects distributed system linda coordination model 
idea easily observed example processes generating number added third process coordination models interested addition carried numbers obtained operation coordination process managing dependencies distributed activities 
soon term coordination accepted computer science community existing models actors cham classi ed coordination models linda concerned computation 
reality gelernter carriero create term coordination described coordination idea introduced malone crowston applied design distributed computer systems 
described distributed language terms coordination computation shown coordination model language put computation language form complete distributed language 
linda coordination model linda coordination model concept generative communication distributed associative shared memories 
shared memories called tuple spaces behave bags unordered multi sets tuples 
direct communication processes communication done tuple spaces 
model provides processes primitives access tuple spaces storing retrieving tuples creating tuple spaces spawning processes 
tuples linda ordered lists valued objects actuals generative communication model associative matching implemented primitives 
matching implemented linda templates di erent tuples able non valued objects formals represented type 
instance template int hello matches tuple hello 
primitives provided stores tuple tuple space removes tuple tuple space matching template provided rd gets copy tuple tuple space matching template provided collect moves tuples matching template tuple space copy copies tuples matching template tuple space eval spawns new process 
primitives linda uni es concepts process creation communication synchronization implemented tuple space operations 
variants linda model called nowadays linda family models deserve mentioning bauhaus pagespace bonita 
despite di erences models su er problem implemented open environments memory exhaustion 
open implementations wonder memory exhaustion problem felt great extent far 
answer simple open implementations linda started appear ones available implementation large applications 
increase commercial open implementations linda javaspaces spaces short period time linda viable commercial product developing open applications 
example phenomenon observed sun microsystems jini includes javaspaces components 
jini perfect example javaspaces coordination con ned single computation language java 
open implementations coordination systems problems previously solved compile time required solved separately run time sub system 
matters worse vital information necessary implementation sub systems longer available 
instance closed system possible kernel built compile time structure containing information processes access tuple spaces 
information hand decisions optimizations garbage collection instance interfering execution system 
generally speaking say due existence information closed systems solutions possible problems easier 
words degree diculty problems open systems higher problems closed systems 
majority problems closed systems dealt compile time solutions stable passive structures containing information 
open systems information collect copy standard primitives concept bulk primitives accepted included 
maintained run time solutions careful information available right time information coherent state system 

memory exhaustion memory management large application developer 
computers cheaper systems tend larger memory resources 
bottom line memory nite resource utilization concern 
mentioned problem observed linda systems 
number reasons rst commercial implementations linda closed compile time optimizations implemented kernel level manage memory usage closed system orthogonality coordination computation observed concepts distributed parallel language large memory demanding applications implemented closed linda implementations demand open systems open implementations linda largely research prototypes small applications test programs implemented making memory management issue companies sun ibm started explore possibilities open linda implementations internet context implementation development large open applications 
applicability coordination systems web bene ts bring internet known accepted 
correct think long problem memory management start appear 
solutions implemented looks ahead identify core problem lack information system 

information gathering open implementations linda model nd means building information processes tuple spaces tuples kernel 
done instance pre processing active agents gathering information run time gathering information messages transit system 
pre processing cases build initial amount information allows optimization pre processing normally done single process point view help solution global problems problem memory management 
solution active agents elegant add undesirable overhead system 
explores solve problem memory management idea gathering information messages transit linda processes linda kernel 
trivial see information necessary build structure available sub system processes garbage collection transit linda case 
problem information volatile stored lost 
order add persistence information transit system distributed graph information processes access tuple spaces built linda kernel 
consideration tuples discussing graph build worth clarifying tuples considered 
naively think tuples basic elements stored retrieved linda memory management done tuple level 
reason doing tuples linda uniquely identi ed 
tuple just ordered list values processes keep 
processes keep tuple spaces bag tuples name process knowledge intends stored retrieve tuple 
solution worth mentioning idea leases javaspaces 
basic idea resources allocated xed period time 
instance tuple created expiration date 
freeman argue leases ideal unreliable distributed applications processes fail resources explicitly freed 
lease certain cases behavior application known behavior unpredictable 
asynchronous system process predict long tuple required system process delete tuple explicit due reason 
argues kernel free resources tuple level tuples accessed associatively handle tuple 
leases javaspaces tuples con ned single language represented java objects 
messages transit concentrates having graph information tuple spaces processes 
construction distributed graph concepts need introduced kernel information transit get lost 
process registration check kernel aware processes willing coordinate linda primitives 
process registration consists having process communicating kernel assign unique name 
point registration onwards processes internal names communication kernel 
dual process registration process check processes informs linda kernel intend linda facilities longer 
tuple monitoring tuple monitoring idea having linda kernel analyzing relevant information transit 
called tuple monitoring basic information transit linda tuples 
despite called graph name stands pictorial representation data structure containing information 
processes identi ed names tuple monitoring ective extracting information stored tuples 
implementation concepts linda power aware happening communications 
processes tuple spaces uniquely identi ed called distributed graph built hold information system 
implementation concepts crucial solution memory management problem just commodity implemented satisfy garbage collection scheme 
graph building information kernel available optimization run time systems 
creating distributed graphs clearly information available kernel concepts described section data structure built 
said intention build data structure pictorially seen distributed graph information tuple spaces usage processes 
due distributed characteristic graph rules clari ed existing tuple spaces processes represented graph representation process tuple space distributed components graph order observe distributed components part connected graph representation universal tuple space uts repeated components serve connection components processes hold tuple spaces tuple spaces store tuple spaces processes hold processes represented edges graph purpose garbage collection algorithm edges linking processes tuple space undirected edges linking tuple spaces directed outgoing tuple space contains directed edges weighted number stored outgoing tuple space directed undirected edges duplicated nodes maximum undirected edge directed edges direction 
described represent situation data structure locations component graph 
gure represents scenario processes executing aware existence uts edge undirected linking uts 
gure generally case linda systems medium communication known processes 
uts simple graph situation 
equivalent adjacency matrix ffp gg fp gg fp gg fp gg fp ggg 
ways get particular graph con guration 
shown may got con guration having processes starting soon kernel initialized 
initialization node uts created 
processes registers kernel name attributed processes node created representing necessary edges added case edge linking uts 
better understanding garbage collection algorithm nodes tuple spaces graph contains extra eld represents number objects tuple spaces processes tuple space 
uts case set represent uts nite number default processes know uts 
undirected edges weighted 
process active object knows tuple space generate tuple space handles likes 
undirected edges understood having nite weight 
complex graph shown 
numerous ways getting situation depicted 
explaining details structure built important convinced importance keeping information kernel 
graph holds important information normally available linda systems 
instance easy see tuple space ts process handle available tuple space 
basically tuple space garbage garbage collected kernel maintains information available 
observe system considered fully open tuple spaces accessed names impossible process get handle ts 
example suppose processes terminate 
happen representations removed graph causing tuple spaces ts ts ts unreachable processes consequently considered garbage 
consider just example shown 
scenario shows distributed graph help implementation mobility linda 
big interest mobile computing today mainly due availability web distributed network implementation systems span globe 
static techniques adapted local area networks lans rmi rpc corba successful fairly large wide area uts ts ts ts ts ts ts ts ts ts complex graph situation 
networks wans adapted web context 
mobility implemented linda information provided distributed graph considered utterly importance 
shows simple case process sole process accessing tuple space ts 
di erent location say mobile system ts migrate location alternatively process migrate location process accessing tuple spaces location 
location location uts ts simple case distributed graphs 
information put graphs depicted far available concepts described section 
process registration allows kernel create node process graph identify messages related process moment registration onwards 
registration links created existing tuple spaces process spawned receiving handles parameters 
tuple monitoring keep graph updated 
behaves independent process basically listens messages transmitted linda kernel processes vice versa 
messages transit potentially important possible messages identi ed types messages considered messages requesting process registration messages storing retrieving tuples containing handles messages requesting process check process registration check dealt separately tuple monitoring identify message registration check request 
messages marked mounted linda process side 
impose big overhead system occurs tuple packed sent server 
tuple monitoring update graph ways 
message storing tuple contains handle copy collect directed edge created graph represent dependency tuple spaces involved tuple space contains handle process access potential access retrieving handle 
directed edge exist linking tuple spaces weight modi ed accordingly weight represents number handles stored tuple space 
messages monitored ones retrieving handles tuple spaces rd copy collect handle removed tuple space weight updated re ect change weight directed edge gets zero edge removed altogether 
retrieval handles process access tuple space necessary directed edges updated necessary undirected edge th process tuple space created 
avoiding race conditions operations update graph done care order avoid race conditions 
observe instance case primitive 
suppose scenario depicted process removes tuple containing handle ts ts 
garbage collection scheme graph decide garbage race condition occur garbage collector update graph 
process removes handle automatically gains access ts order update links observed tuple space ts considered garbage 
edge linking ts ts removed linking ts created 
characteristics update method garbage created process termination 
removal directed edges circumstance generate garbage 
edges graph represent knowledge particular tuple space removed due process operation created modi ed terms weight 
particular tuple space lost due execution linda primitives 
hand process termination operation generate garbage may lost 
race conditions garbage collection graph update know problem distributed system solved various approaches developed years 
adaptation models linda case avoid race condition 
uses di erent approach adapting bulk primitives collect copy store retrieve tuples tuple spaces 
complex algorithms uses simple avoids race conditions guaranteeing time graph consistent system situation 
douglas described ordering problem showing problem solved linda coordination system 
problem consists guaranteeing order execution sequence outs tuple space order tuples appear 
solution avoiding race conditions graph seen extension problem ordering imposed checkout message sent linda processes 
race conditions removed system guarantees checkout message arrives kernel message process arrive 
experiments shown section show solution impose great overhead system 
argument show little overhead added extra ordering fact primitive needs considered ordering 
primitives return process ordering exists part semantics primitive 
instance suppose primitive primitive executed process checks 
returns tuple check operation immediately executed process side primitive completed guaranteeing ordering execution 
primitive return value consequently needs considered ordering termination check 

garbage collection garbage collection linda implemented kernel level way guarantee scheme restricted boundaries computation languages 
scheme implemented aims nding garbage tuple spaces consideration required garbage collect linda processes 
finding garbage tuple spaces information available kernel implementation garbage collection scheme nding tuple spaces longer necessary system simple 
popular garbage collection algorithms available variations basic methods counting mark sweep 
scheme implemented linda phase garbage collection 
rst phase uses counting nd tuple spaces required system 
basically tuple space counter eld number processes knowledge tuple space zero wasting memory space removed 
shows scenario tuple spaces ts ts removed garbage collector counters zero 
counting methods nd garbage cyclic structures cyclic garbage identi ed 
counting cheap implemented distributed environments justifying option implementing scheme phases 
phases implemented way counting runs frequently ideally location location uts ts ts ts ts ts ts ts ts uts ts ts ts ts ts ts counting identi es tuple spaces garbage 
collects garbage 
second phase important cyclic garbage collected 
mark sweep able collect cycles decide need object counter 
mark sweep traverses graph marking reached special nodes called roots 
linda uts nominated root represents boundary outside world non linda environment 
processes active objects act roots search linked uts necessary node reached process node reached uts 
mark sweep implemented concept sets 
marking step node reached included set represent nodes alive 
marking nodes left outside set considered garbage collected sweep step 
performing marking scenario depicted garbage shown 
clear tuple spaces identi ed garbage crossed phase garbage 
take instance case tuple spaces ts ts ts 
ts contains uts traversal started uts reach tuple spaces search respects direction edges 
processes accessing fact search uts reached tuple spaces 
mark sweep phase divided stages local global mark sweep 
representations tuple spaces graph contain information location objects access particular tuple space local global mark sweep 
scenario shown ts ts ts collected local mark sweep links locations ts location location ts ts ts ts ts ts ts ts ts ts ts uts ts uts marking identi es tuple spaces garbage sweep step collects 
ts collected global mark sweep view distributed graph 
considering active processes extending concept memory management resource management graph help garbage collecting processes running wasting processor time 
words possible process linda active communicate processes doing just waste time 
way linda usually implemented happen processes linked uts side ect processes 
surely condition relaxed having processes aware existence uts graph provide information garbage collection active processes done 
noticed concept garbage collection processes include garbage collection deadlocked processes instance blocked rd waiting tuple 
dealt garbage collection scheme semantics primitive foresee situation deal 
uts tuple space handles passed processes tuple spaces 
mean say assumption processes know default uts considered general unnecessary 
order garbage collect processes scheme described section processes considered roots graph linked uts 
active objects linked uts get access uts retrieving handle 
considered mark sweep phase need search graph starting processes nodes uts 
uts remains center algorithm 
search node garbage 
contained set generated search 
contained set uts element 
creation sets marking simple 
search started node nodes reached search elements set marked reached set set merge forming single set 
ts ts uts ts ts scenarios showing sets merge marking 
ts ts ts uts ts scenarios showing sets merge marking 
suppose scenarios figures feasible processes linked uts 
shows sets generated marking phase starting uts respectively 
gure objects garbage sets merge forming single set contains uts elements 
property described fts merge forming single set say means merge 
merge operations single set ts ts ts ts formed 
set represents nodes garbage 
shows marking phase nd garbage nodes 
similar case sets merge elements common 
set resulting merge say element common 
marking applies ts ts garbage belong set ts ts garbage uts element set belong uts node left graph 
side effect method described far question remains happens process linked uts intends display result screen 
fact common situation process px starts creates tuple space spawns process pz passing tuple space handle terminates 
pz turn access information display result 
surely want garbage collect processes doing linked uts anyway 
menezes wood shown coordination problem addressed coordination model 
authors described devices les abstracted terms tuple spaces allowing linda processes deal linda primitives 
context garbage collection represented adding tuple space represents model 
process handle tuple space process able operations words devices les tuple spaces 
slightly modi es concept garbage de ned section 
modi cation due existence new tuple space root graph node element set contain uts contains element considered garbage 
practical reason node reach tuple space linda model ect outside world non linda environment doing operations 
shows case tuple space exist 
scenario shown linked uts anyway garbage de nition garbage consider reachability tuple space way uts set formed search include element 

experimental results system described previous sections implemented java 
concepts described implemented linda kernel called ligia 
rst experiment described aims showing garbage collection fact avoiding early memory exceptions due existence unnecessary information memory 
ts ts uts ts ts ts ts ts graph showing uts tuple space process handles 
secs 
tuple spaces garbage collection garbage collection avoiding early memory exhaustion 
experiment described performed linda processes basically start create tuple spaces terminates 
new process starting number tuple spaces created incremented 
system con gured manner memory exhaustion happens tuple spaces stored memory 
shows garbage collector active memory exhaustion problem happens process create tuple space tuple spaces stored memory 
garbage collector active exception happen point garbage tuple spaces removed memory processes terminate 
garbage collector active exception occurs process start tries create tuple spaces 
capacity memory tuple spaces exhaustion happens created due concurrent nature garbage collector 
garbage collector running concurrently execution linda processes means garbage may memory exception happened 
avoided implementing exception handling system calls garbage collector free memory exception takes place 
system implemented java exception handled java 
overhead biggest concerns implementing garbage collection scheme 
demonstrates raw overhead garbage collector described previously 

tuples garbage collection garbage collection worst case overhead added garbage collector 
experiment shown performed having linda process storing tuples single tuple space 
process loops interaction increases number tuple stored 
tuples stored single processes single tuple space garbage created process terminates 
overhead observed accounts tuple monitoring overhead having garbage collector running 
process registration check considered happens process adds startup time uence process total running time 
average overhead observed bellow jones lins argued acceptable terms overhead due garbage collection 
worst case overhead observed system bene ting improvement done garbage collector 
natural believe system generates excessive amount garbage execution garbage collector improve performance system keeping memory tidy 
shows scenario opposite case 
process loops similarly previous case storing tuples single tuple space process spawns processes turn create tuple space store tuples terminate garbage created 
results shown may surprising noticed situation best case analysis garbage collection opposed case tuple spaces created garbage quickly 
garbage collection data structure tuple spaces tuples heavy operations take longer complete 
garbage collector running collecting garbage structure time clean operations take time complete 
secs 
tuples garbage collection garbage collection garbage collector improving system performance 
expect average case overhead added garbage collection scheme information gathering system minimum existing 
factors accounts results rst garbage collector runs low priority thread tries processors idle time run second tuple monitoring monitors tuples contains handles experience said operations involving handles commonest nally process registration check adds extra messages registration check process kernel long run adds practically total execution time process 

proposed ecient way gathering information open linda systems source information optimizations 
explored garbage collection implemented distributed data structure containing information gathered run time 
due way data structure maintained simpler garbage collection race conditions dealt level data structure construction 
results shown garbage collection add overhead open linda systems information gathering system uence performance 
argued solution expected di erent assumptions 
case worth mentioning models processes may maintain tuple spaces lookup services discover tuple spaces 
important realize tuple space required 
solution proposed easily adapt consider lookup services active processes tuple spaces 

acknowledgments alan wood university york uk support guidance development core described 

agha 
actors model concurrent computation distributed systems 
mit press 
berry boudol 
chemical machine 
acm editor proceedings seventeenth annual acm symposium principles programming languages pages new york ny usa 
acm press 

distributed garbage collection counting 
bakker editors proc 
parallel architectures languages europe pages 
springer verlag june 
lecture notes computer science vols 

cardelli 
wide area computation 
technical report microsoft research uk 
carriero gelernter zuck 
bauhaus linda 
ciancarini nierstrasz yonezawa editors object models languages concurrent systems volume lecture notes computer science pages 
springer verlag berlin 
ciancarini tolksdorf 
pagespace architecture coordinate distributed applications web 
proc 
th workshops enabling technologies infrastructure collaborative enterprises wet ice pages 
ieee computer society press june 
collins 
method overlapping erasure lists 
communications acm 
douglas rowstron wood 
linda parallel programming bags 
technical report university york april 
douglas wood rowstron 
linda implementation revisited 
nixon editor proc 
th world occam transputer user group pages 
ios press april 
freeman arnold 
javaspaces principles patterns practice 
addison wesley reading ma usa 
jini technology series 
gelernter 
generative communication linda 
acm transactions programming languages systems 
gelernter 
multiple tuple spaces linda 
proc 
parle pages 
springer verlag 
gelernter carriero 
coordination languages signi cance 
communications acm february 
hughes 
distributed garbage collection algorithm 

jouannaud editor proc 
acm conference functional programming languages computer architecture pages 
lecture notes computer science vol 


linda multiple tuple space 
technical report yale dcs rr yale university february 
ibm 
spaces programmer guide 
version 
www almaden ibm com cs tspaces 
jones lins 
garbage collection algorithms automatic dynamic memory management 
wiley 
knoblock ambite 
agents information gathering 
bradshaw editor software agents 
aaai mit press menlo park ca 
malone crowston 
coordination theory help design cooperative systems 
proceedings conference computer supported cooperative cscw pages 
mccarthy 
recursive functions symbolic expressions computation machine 
communications acm april 
menezes wood 
coordination distributed tuple space systems 
proc 
st hawaii international conference system sciences volume vii pages big island hawaii usa 
ieee computer society 
menezes wood 
garbage collection linda tuple monitoring process registration 
proc 
th international conference parallel distributed computing systems pages las vegas nevada usa 
acta press 
menezes wood 
ligia java linda run time system garbage collection tuple spaces 
technical report department computer science university york september 

indirect counting distributed garbage collection algorithm 
rem 
editors proc 
parallel architectures languages europe pages 
springer verlag june 
lecture notes computer science vols 

rowstron wood 
bonita set tuple space primitives distributed coordination 
el patt editors proc 
th hawaii international conference system sciences volume pages 
ieee computer society press january 
scienti computing associates incorporated 
paradise user guide manual 
scienti computing associates incorporated 
linda example 
available scienti computing associates incorporated century tower new haven ct 
sherman 
linda manual 
scienti computing associates new haven connecticut 
sun microsystems speci cation june 
revision 
sun microsystems jini architecture speci cation january 
revision 

prolog linda embedding linda 
technical report university western australia 
