page average case analysis algorithms data structures analyse en des algorithmes des structures de donn ees jeffrey scott vitter philippe flajolet 
report contributed chapter handbook theoretical computer science north holland 
aim describe main mathematical methods applications average case analysis algorithms data structures 
comprises parts basic combinatorial enumerations symbolic methods asymptotic methods emphasis complex analysis techniques singularity analysis saddle point mellin transforms 
show apply general methods analysis sorting searching tree data structures hashing dynamic algorithms 
emphasis algorithms exact analytic models derived 
esum 
ce rapport est un qui dans le handbook theoretical computer science north holland 
son est de les ethodes applications de analyse de complexit en des algorithmes 
il deux parties 
tout nous une pr esentation des ethodes de qui sur utilisation de ethodes ainsi que des techniques fond ees sur analyse analyse de es ethode du col transformation de mellin 
nous application de ces ethodes analyse du tri de la recherche de la manipulation du des algorithmes 
accent est mis dans cette pr esentation sur les algorithmes pour existent des hh mod eles ii 
dept computer science brown university providence usa 
research done author sabbatical inria rocquencourt france ecole normale sup erieure paris 
support provided part nsf research dcr nsf presidential young investigator award matching funds ibm faculty development award research fellowship 
inria domaine de voluceau rocquencourt le chesnay france 
page ii table contents 


combinatorial enumerations 

overview 

ordinary generating functions 

exponential generating functions 

generating functions counting 

asymptotic methods 

generalities 

singularity analysis 

saddle point methods 

mellin transforms 

limit probability distributions 

sorting algorithms 

inversions 

insertion sort 

shellsort 

bubble sort 

quicksort 

radix exchange sort 

selection sort heapsort 

merge sort 

recursive decompositions algorithms trees 

binary trees plane trees 

binary search trees 

radix exchange tries 

digital search trees 
ii 
hashing address computation techniques 
bucket algorithms hashing chaining 
hashing open addressing 

dynamic algorithms 

integrated cost history model 

size dynamic data structures 

set union find algorithms 

index glossary 
iii page average case analysis algorithms data structures jeffrey scott vitter philippe flajolet 
analyzing algorithm means broadest sense characterizing amount computational resources execution algorithm require applied data certain type 
algorithms classical mathematics primarily number theory analysis analyzed eighteenth nineteenth century mathematicians 
instance lam showed euclid gcd algorithm requires log oe division steps oe golden ratio applied numbers bounded similarly known quadratic convergence newton method way describing complexity accuracy tradeoff 
chapter presents analytic methods average case analysis algorithms special emphasis main algorithms data structures processing data 
characterize algorithmic solutions number essential problems sorting searching pattern matching register allocation tree compaction retrieval multidimensional data efficient access large files stored secondary memory 
step required analyze algorithm define input data model complexity measure 
assume input data certain type 
commonly data type carries natural notion size size array number elements size file number records size character string length 
input model specified subset inputs size probability distribution example classical input model comparison sorting algorithms assume inputs real numbers independently uniformly distributed unit interval 
equivalent model assume inputs form random permutation ng 

main complexity measures algorithms executed sequential machines time utilization space utilization 
may raw measures time nanoseconds particular machine number bits necessary storing temporary variables measures number comparison operations number disk pages accessed 
average case analysis algorithms data structures 
methods average case analysis algorithms 
consider algorithm complexity measure worst case best case complexities algorithm defined obvious way 
determining worst case complexity requires constructing extremal configurations force restriction large possible 
average case complexity defined terms probabilistic input model ef prf kg ef denotes expected value prf denotes probability respect probability distribution frequently finite set probabilistic model assumes uniform probability distribution case takes form kj nk ji nk number inputs size complexity algorithm average case analysis reduces combinatorial enumeration 
step analysis express complexity algorithm terms standard functions ff log fi log log fl ff fi fl constants analytic results easily interpreted 
involves getting asymptotic estimates 
steps give route followed average case analyses appear literature see 
recur determine probabilities expectations exact form start setting recurrences relate behavior algorithm inputs size behavior smaller similar inputs 

solve solve previous recurrences explicitly classical algebra 

standard real asymptotics estimate explicit expressions 
section 
important way solve recurrences generating functions 
translate recurrences equations involving generating functions 
coefficient nth term generating function represents particular probability expectation 
general obtain set functional equations 

expand solve functional equations classical tools algebra analysis expand solutions get coefficients explicit form 
methods bypassed powerful methods emphasize chapter 
symbol bypass recurrences translate set theoretic definitions data structures underlying combinatorial structures directly functional equations involving generating functions 

complex complex analysis translate information available functional equations directly asymptotic expressions coefficients generating functions 
symbolic method symbol direct advantage characterizing special functions arise analysis natural class related algorithms 
complex method provides powerful tools direct asymptotics generating functions 
intrinsic advantage cases providing asymptotic estimates coefficients functions known implicitly functional equations 
sections develop general techniques mathematical analysis algorithms emphasis symbol complex methods 
section devoted exact analysis combinatorial enumeration 
primary methods obtain counting results analysis algorithms emphasis symbolic methods symbol 
main mathematical tool generating function associated particular class structures 
rich set combinatorial constructions translates directly functional relations involving generating functions 
section discuss asymptotic analysis 
briefly review methods elementary real analysis concentrate complex analysis techniques complex 
analytic properties generating functions recover information coefficients 
methods applicable functions known indirectly functional equations situation presents naturally counting recursively defined structures 
sections apply general methods analysis algorithms especially developed sections analysis large variety algorithms data structures 
section describe important sorting algorithms apply statistics inversion tables analysis iteration sorting algorithms 
section extend approach section consider valuations combinatorial structures analyze trees structures tree recursive decomposition includes plane trees binary multidimensional search trees digital search trees quicksort radix exchange sort algorithms register allocation pattern matching tree compaction 
section unified approach hashing address calculation techniques occupancy problems 
section devoted performance measures span period time expected amortized time expected maximum data structure space algorithm 
average case analysis algorithms data structures general 
background sources combinatorial enumerations symbolic methods include jackson 
general coverage complex analysis appears applications asymptotics discussed bender olver bender de bruijn 
mellin transforms covered limit probability distributions studied feller billingsley 
additional coverage average case analysis algorithms data structures reader referred knuth seminal art computer programming knuth knuth knuth flajolet greene knuth sedgewick purdom brown flajolet 
descriptions algorithms analyzed chapter knuth books gonnet sedgewick 
section 
overview 
combinatorial enumerations main objective section introduce useful combinatorial constructions translate directly generating functions 
constructions called admissible 
section examine admissible constructions ordinary generating functions section consider admissible constructions exponential generating functions related enumeration labeled structures 

overview elementary structures may enumerated sum product theorem sum product rule 
sets cardinalities theta delta number binary strings length number permutations ng 
order difficulty explicit forms replaced recurrences structures defined terms 
example number coverings interval disjoint segments length 
considering possibilities segment get recurrence gamma gamma initial conditions 
classical theory linear recurrences find fibonacci numbers expressed terms golden ratio oe oe gamma oe oe oe sigma example illustrates recurrence methods recur derivation explicit solutions solve 
example shall discuss detail section number plane binary trees internal nodes knuth 
considering possibilities left right subtrees get recurrence gamma gammak gamma initial condition 
solve introduce generating function gf eq 
get sum notation represent union 
average case analysis algorithms data structures solving quadratic equation get gamma gamma taylor expansion gives 


case started recurrences recur introduced generating functions leading solving expanding expand gave explicit solutions 
example dates back euler called catalan numbers 
symbolic method symbol going applied example follows class binary trees defined recursively equation fl theta theta fl represent external nodes internal nodes respectively 
standard lemma asserts disjoint unions cartesian products structures correspond respectively sums products corresponding generating functions 
specification translates term term directly generating function equation delta delta agrees 
definition 
class combinatorial structures finite countable set integer valued function called size function number structures size finite 
counting sequence class integer sequence fc ordinary generating function ogf exponential generating function egf class defined respectively 
coefficient expansion function simply nth coefficient written 

generating functions expressed fl jflj fl jflj jflj 
checked counting number occurrences sums 
shall adopt notational convention class say counting sequence say associated ordinary generating function say section 
ordinary generating functions associated exponential generating function say bc named group letters 
basic notion symbolic method admissible construction counting sequence construction depends counting sequences components see jackson flajolet greene construction translates generating functions 
induces operator simple form formal power series 
instance classes structures theta cartesian product 
size ordered pair defined jwj juj jvj counting possibilities get gammak corresponding ordinary generating function equation combinatorial set theoretic construction translates manner called admissible 

ordinary generating functions section catalog admissible constructions ordinary generating functions 
assume size element disjoint union inherited size original domain size composite object product sequence subset sum sizes components 
theorem fundamental sum product theorem 
disjoint union cartesian product constructions admissible theta proof 
recurrences kn gammak alternatively eq 
yields cartesian products jwj juj jvj juj delta jvj class structures positive size 
class called sequence class class denoted composed sequences class finite powerset class denoted consists finite subsets fu distinct 
average case analysis algorithms data structures theorem 
sequence powerset constructs admissible gamma phi phi gamma gamma delta delta delta proof 
ffl denote empty sequence 
sequence class ffflg theta theta theta delta delta delta delta delta delta gamma gamma delta gamma powerset class equivalent infinite product ffflg fug juj un computing logarithms expanding get log log gamma delta delta delta constructions shown admissible 
diagonals subsets repetitions 
diagonal ug theta written delta theta satisfies 
class multisets subsets repetitions class denoted 
isomorphic fug ogf satisfies psi psi delta delta delta 
marking composition 
formed atomic elements nodes letters determine size define marking denoted fug consist elements individual atom marked 
nu follows dz 
similarly composition denoted defined class structures resulting substitutions atoms elements gamma delta examples 

combinations 
fixed integer mg element having size 
generating function mz 
class set combinations theorem generating function number combinations set elements phi exp mz gamma mz mz gamma delta delta delta exp gamma log delta section 
ordinary generating functions extracting coefficients find expected 

gamma 
similarly class combinations repetitions gamma gammam gamma gamma 
compositions partitions 
having size sequence class called set integer compositions 
gamma gamma gamma delta gamma gamma gamma gamma class rfn set integer partitions ff fffg gamma 
formal languages 
combinatorial processes encoded naturally strings finite alphabet regular languages defined regular expressions equivalently deterministic nondeterministic finite automata 
illustrated theorems chomsky schutzenberger 
applications appear berstel boasson 
theorem regular languages rational functions 
regular language ogf rational function polynomials 
counting sequence satisfies linear recurrence constant coefficients 
finite set constants polynomials 
proof sketch 
deterministic automaton recognizes set words accepted started state satisfy set linear equations involving unions concatenation letters constructed transition table automaton 
generating functions translates set linear equations polynomial coefficients solved cramer rule 
theorem context free languages algebraic functions 
unambiguous context free language ogf algebraic function 
counting sequence satisfies linear recurrence polynomial coefficients family polynomials jm gammaj average case analysis algorithms data structures proof sketch 
language unambiguous counting problem equivalent counting derivation trees 
production grammar abba translates generating function associated nonterminal obtain set polynomial equations reduces single equation gamma delta elimination 
obtain recurrence theorem see flajolet corresponding asymptotic estimates 

trees 
shall study trees great detail section 
trees rooted plane trees subtrees node ordered non plane trees unordered 
class general plane trees node degrees allowed satisfies equation fl theta signifying tree composed root followed sequence subtrees 
gamma gamma gamma gamma gamma class general non plane trees fl theta satisfies functional equation delta delta delta closed form expressions 
complex analysis methods possible determine asymptotically 

exponential generating functions exponential generating functions essentially counting labeled structures 
structures composed atoms size structure number atoms atom labeled distinct integer 
instance labeled graph size just graph set nodes ng 
permutation respectively circular permutation viewed linear respectively cyclic directed graph nodes labeled distinct integers 
basic operation labeled structures partitional product jackson flajolet chapter greene 
partitional product consists forming ordered pairs theta relabeling possible ways preserve order labels precisely labeled structure size function qg rg defines relabeling denoted label replaced 
labeled structures respective sizes partitional product denoted consists set possible relabelings gamma delta mg ng ng ng satisfy 
monotone increasing functions 
preserves order structure 

ranges disjoint cover set ng 
section 
exponential generating functions partitional product classes denoted union theorem sum product theorem labeled structures 
disjoint union partitional product labeled structures admissible proof 
obvious unions 
products observe mq gammam binomial coefficient counts number partitions qg sets cardinalities gamma dividing 
get 
mq um 
gammam gamma 
partitional complex denoted hi analogous sequence class construction defined hi ffflg delta delta delta egf gamma gamma delta gamma kth partitional power denoted hki abelian power denoted collection sets fae ae ae ae ae ae hki words order components taken account 
write symbolically 
hki egf 
hki 
abelian partitional complex defined analogously powerset construction ffflg delta delta delta theorem 
partitional complex abelian partitional complex admissible hi gamma examples 

permutations cycles 
class permutations class circular permutations cycles 
theorem gamma gamma 
permutation decomposes unordered set cycles log gamma gamma delta gamma 
construction shows egf permutations having cycles log gamma gamma delta nth coefficient stirling number kind 
average case analysis algorithms data structures class permutations cycles size fixed points 
class cycles size 
log gamma gamma gamma gammaz gamma similarly generating function class involutions permutations cycles lengths 
labeled graphs 
class labeled graphs class connected labeled graphs 
gamma log prove 
occupancies set partitions 
define urn size structure formed unordered collection integers ng urn size defined empty set 
denote class urns class hki represents possible ways throwing distinguishable balls distinguishable urns egf kz anticipated hki similarly generating function number ways throwing balls urns urn empty gamma number ways 
gamma equal 
stirling number second kind 
class nonempty urns element size corresponds partition set ng equivalence classes 
number partitions bell number fi 
exp gamma vein egf surjections hi surjective mappings ng initial segment mg integers gamma gamma gamma labeled structures define marking composition constructions translate 
greene defined useful boxing operator denotes subset obtained retaining pairs label construction translates egf dt section 
generating functions counting 
generating functions counting previous section saw generating function equations written directly structural definitions combinatorial objects 
discuss go functional equations exact counting results indicate extensions symbolic method multivariate generating functions 
direct expansions generating functions 
gf explicitly product composition known gfs get explicit form coefficients gf classical rules taylor expansions sums 
examples related previous calculations catalan numbers numbers bell numbers gamma gammaz gamma kn gamma 
exp gamma gamma 
method obtaining coefficients implicitly defined gfs method indeterminate coefficients 
coefficients sought translate coefficients functional relation 
important subcase order linear recurrence gamma solution iteration summation factors gamma gamma gamma gamma gamma gamma delta delta delta solution methods functional equations 
algebraic equations gfs may solved explicitly low degree solutions expanded see catalan numbers section 
equations higher degrees transcendental equations lagrange inversion formula useful theorem lagrange inversion formula 
defined implicitly equation gamma delta series 
coefficients powers arbitrary composition gamma delta related coefficients powers follows gamma gammak gamma delta gamma examples 

abel identities 
gamma expansion ze coefficients fff fif ff fi get abel identity ff fi ff fi gamma fffi ff gamma gamma fi gammak gamma 
ballot numbers 
letting zb related defined zb see section find gamma delta ballot numbers 
average case analysis algorithms data structures differential equations occur especially relation binary search trees shall see section 
order linear differential equation dz variation parameter integration factor method gives solution gammab dt du lower bound chosen satisfy initial conditions 
functional equations iteration bootstrapping may useful 
example suitable formal analytic convergence conditions solution gamma fl delta gamma fl delta jk gamma gamma fl delta fl denotes kth iterate fl fl delta delta delta fl delta delta delta fl cf 
eq 

general arsenal algebra generating functions methods represent commonly techniques 
equations escape exact solution asymptotic methods complex analysis extract asymptotic information gf coefficients 
multivariate generating functions 
need count structures size certain combinatorial characteristic having value try treat parameter see examples stirling numbers 
corresponding counting sequence 
may consider bivariate generating functions 
extensions previous translation schemes exist see 
instance stirling numbers 
exp gamma log gamma gamma delta gamma gammau 

gamma gamma multisets 
extension symbolic method multisets carried flajolet 
consider class structures oe multiplicity oe 
pair called multiset generating function definition oe oe joej cumulated value structures size extension useful obtaining generating functions expected cumulated values parameters combinatorial structures translation schemes admissible constructions exist multisets 
shall encounter extensions analyzing shellsort section trees section hashing section 
section 
generalities 
asymptotic methods section start elementary asymptotic methods 
complex asymptotic methods singularity analysis saddle point integrals allow cases direct derivation asymptotic results coefficients generating functions 
introduce mellin transform techniques permit asymptotic estimations large class combinatorial sums especially involving certain arithmetic number theoretic functions 
conclude discussion asymptotic limit theorems probability distributions 

generalities briefly recall subsection standard real analysis techniques discuss complex analysis methods 
real analysis 
asymptotic evaluation elementary counting expressions may done directly useful formula regard stirling formula 
gamma gamma delta delta delta instance central binomial coefficient satisfies gamma delta euler maclaurin summation formula applies expression involves sum regularly spaced points riemann sum continuous function sum approximated corresponding integral formula provides full expansion 
basic form theorem euler maclaurin summation formula 
integer gamma dx jm gamma 
gamma gamma gamma gamma delta gamma 
dx 
ze xz gamma bernoulli polynomial bernoulli number 
derive formulae summing 
fxg denotes fractional part jn gamma dx jm gamma 
gamma gamma gamma gamma delta gamma fxg 
dx average case analysis algorithms data structures expresses difference discrete sum corresponding integral 
change scale small setting hx obtain asymptotic expansion riemann sum step size tends jh jh dx gamma 
gamma gamma gamma gamma delta examples 

harmonic numbers defined delta delta delta satisfy log fl delta delta delta 

binomial coefficient gamma gammak delta asymptotically equal central coefficient gamma delta times exp gammak follows estimating logarithm 
gaussian approximation special case central limit theorem probability theory 
laplace method sums classical approach evaluating sums dominant term 
determine rank dominant term 
show smooth functions oe gamma gamma delta small 
conclude applying euler maclaurin summation oe 
example asymptotics bell numbers defined de bruijn page number involutions knuth page 
extensions multiple sums involving multivariate euler maclaurin summations 
complex analysis 
powerful method computationally simple complex analysis go directly generating function asymptotic form coefficients 
instance egf number regular graphs page gammaz gammaz gamma sought 
bivariate laplace method feasible 
simpler notice analytic complex 
singular expansion holds gamma gamma 
general theorems going discuss section transfer approximation function approximation coefficients gamma gamma gamma gamma gamma gamma delta gamma section 
singularity analysis 
singularity analysis singularity point function ceases analytic 
dominant singularity smallest modulus 
known function positive coefficients entire dominant positive real singularity 
cases asymptotic behavior coefficients function determined singularity 
location singularities 
classical exponential order formula relates location singularities function exponential growth coefficients 
theorem exponential growth formula 
analytic origin nonnegative coefficients ae smallest positive real singularity coefficients satisfy gamma ffl ae gamman ffl ae gamman ffl 
means infinitely infinitely values means finitely values 
examples 

cos egf alternating permutations gamma egf surjections 
bounds apply ae ae log respectively 

solution functional equation ogf trees odlyzko 
setting oe functional equation formal solution obtained iteration see eq 
oe oe mth iterate oe 
sum converges geometrically jzj smallest positive root ae equation ae oe ae infinite ae 
smallest possible root ae oe oe golden ratio 
gamma ffl ffl bound asymptotic expansion odlyzko obtainable explicit expression coefficients 
see theorem 
nature singularities 
way expressing theorem follows ae gamman subexponential factor larger decreasing exponential smaller increasing exponential 
common forms ff log fi constants ff fi 
subexponential factors usually related growth function singularity 
singularity may taken equal normalization 
average case analysis algorithms data structures method singularity analysis 
assume dominant singularity asymptotic expansion form oe oe oe standard set functions include gamma log gamma constants general conditions eq 
leads oe oe applications principle variety conditions function giving rise methods 
transfer methods require growth information remainder term approximation established region complex plane 
transfer methods largely originate odlyzko developed systematically flajolet odlyzko 

theorems assume eq 
holds real gamma require priori side conditions positivity monotonicity satisfied coefficients restricted general types growth 
see feller page greene knuth page combinatorial application 

method assumes smoothness conditions differentiability remainder term page 
transfer method approach easiest apply flexible combinatorial enumerations 
need asymptotic growth coefficients standard singular functions 
oe gamma gammas newton expansion nth coefficient taylor expansion gamma gamma delta gamma gamma 
standard singular functions gamma gamma log gamma gamma may summation explicit form coefficients contour integration find oe gamma log need transfer coefficients remainder terms 
theorem transfer lemma 
analytic jzj ffi ffi possible exception sector arg gamma ffl ffl gamma gamma delta real gamma gammar gamma delta proof proceeds choosing contour integration part circle jzj ffi boundary sector small notch diameter 
furthermore gamma need assume function analytic jzj 
examples 

egf regular graphs eq 

expand exponential get gammaz gammaz gamma gamma gamma gamma gamma 
section 
singularity analysis function analytic complex plane slit eq 
holds vicinity 
transfer lemma gamma gamma gamma gamma gamma gamma 
egf surjections shown gamma gamma analytic jzj simple pole log local expansions show log delta gamma log log log 
functional equation 
ogf certain trees polya delta delta delta known functional equation gamma zf checked analytic origin 
dominant singularity simple pole ae determined cancellation denominator aef ae 
ae aef ae gamma zf ae gamma dz zf fi fi fi fi ae cae gamma find kae gamman precise expansions exist coefficients functions functions poles ones examples example see knuth flajolet odlyzko 
instance error approximation gamma 
ogf trees amenable transfer methods extraction singular expansions appreciably difficult odlyzko 
conclude subsection citing lemma heart method page classical theorem feller page 
theorem method 
analytic jzj continuous jzj times continuously differentiable jzj instance gamma analytic jzj ffi theorem obtain 
theorem usually applied derive expansions coefficients functions form gamma analytic larger domain 
functions treated directly transfer methods theorem 
average case analysis algorithms data structures theorem theorem hardy littlewood 
assume function radius convergence satisfies real gamma gamma gamma function varying slowly infinity log 
ff monotonic gamma gamma application function greene knuth page function represents egf permutations distinct cycle lengths 
function natural boundary jzj amenable transfer methods 
singularity analysis extensively sections asymptotics related sorting methods plane trees search trees partial match queries hashing linear probing 

saddle point methods saddle point methods extracting coefficients entire functions analytic entire complex plane functions grow fast dominant singularities exp gamma gamma delta play important role obtaining limit distribution results exponential tails discrete probability distributions 
simple bound 
assume entire positive coefficients 
cauchy formula gamma dz refer cauchy coefficient integral 
take contour gamma circle jzj get easy upper bound maximum value jf jzj 
bound valid 
particular minr ff gamman find minimum value setting dr gamma gamman delta gamma gamma delta gamman gives bound theorem saddle point bound 
entire positive coefficients section 
saddle point methods smallest positive real number complete saddle point analysis 
saddle point method refinement technique derive 
applies general integrals depending large parameter form gamma dz point oe called saddle point owing topography je oe perpendicular directions oe integrand je local minimum oe called axis saddle point integrand local maximum oe 
principle steps saddle point method follows 
show contribution integral asymptotically localized fraction gamma ffl contour oe traversed axis 
forces ffl small 

show suitably approximated oe gammaoe oe 
imposes conflicting constraint ffl large 
points established approximated gamma ffl exp oe gamma oe oe dz oe oe classes functions saddle point estimate applies cauchy coefficient integrals called admissible described authors harris odlyzko richmond 
cauchy coefficient integrals put form log gamma log saddle point root equation dz gamma log gamma log delta gamma 
method get estimate theorem saddle point method cauchy coefficient integrals 
positive coefficients class admissible functions dz log fi fi fi fi gamma saddle point smallest positive real number examples 

get stirling formula letting saddle point theorem 
average case analysis algorithms data structures 
number involutions 

gamma dz saddle point delta delta delta 
choose ffl gamma re gamma gamma 

gamman asymptotics bell numbers done way de bruijn page 

function finite singularity 
gammaz theorem gives exp gamma ff similar method applied integer partition function gamma gamma natural boundary estimates characteristic functions logarithm pole singularity 
specializing results define inductively class admissible functions follows denotes arbitrary polynomial positive coefficients 
ii arbitrary functions delta applications saddle point methods appear section analysis maximum bucket occupancy extendible hashing coalesced hashing 

mellin transforms mellin transform tool originally developed analytic number theory useful analyzing sums arithmetic functions appear nontrivial periodicity phenomena occur 
sums expectations combinatorial parameters generating functions 
basic properties 
function defined real 
mellin transform function complex variable defined gamma dx continuous ff fi mellin transform defined fundamental strip gammaff gammafi denote gammaff gammafi instance mellin transform gammax known gamma function gamma section 
mellin transforms fundamental strip transform nk gammax gamma fundamental strip gammak gammak 
inversion theorem la fourier gammai gammas ds taken arbitrarily fundamental strip 
important principle asymptotic analysis mellin transform correspondence terms asymptotic expansions respectively singularities left respectively right half plane 
see assume small sigmai polar singularities 
close contour integration left right derive cauchy residue formula oe res gamma gammas oe delta gammad 
gamma oe res gamma gammas oe delta gammad 
sum equation extended poles oe oe gammaff sum second equation extended poles oe gammafi oe relations character asymptotic expansions observe kth order pole oe residue form gamma log gammaoe gamma polynomial degree gamma 
important functional property mellin transform gammas 
transforms sums called harmonic sums decompose product generalized dirichlet series transform basis function gammas asymptotics sums 
standard usage mellin transforms combination eqs 
theorem mellin asymptotic summation formula 
assume transform exponentially small sigmai polar singularities dirichlet series finite order 
asymptotic behavior harmonic sum respectively sigma oe res gammas gammas oe asymptotic expansion sum respectively sign respectively gamma sum taken poles left respectively right fundamental strip 
average case analysis algorithms data structures examples 

arithmetical sum 
harmonic sum gammak number divisors making fact transform gammax gamma gamma gammas gamma gammas defined fundamental strip 
left strip simple pole double pole 
expanding gamma get gamma log fl gamma log 

sum hidden periodicities 
harmonic sum gamma gammax 
transform defined fundamental strip gamma find gamma gamma ks gamma gamma gamma expansion determined poles right fundamental strip 
double pole denominator gives simple poles ki log 
simple pole contributes fluctuating term gamma exp ki log asymptotic expansion 
collecting fluctuations log log gammad periodic function period convergent fourier expansion 
mellin transforms primary tool study tries radix exchange sort section 
useful study certain plane tree algorithms section bubble sort section interpolation search extendible hashing section 
section 
limit probability distributions 
limit probability distributions general section feller billingsley 
recall real valued random variable rv distribution function prfx xg mean variance oe var efx gamma respectively 
kth moment efx independent oe oe oe nonnegative integer valued rv probability generating function pgf defined prfx kg mean variance respectively oe gamma gamma delta known pgf sum independent rvs product conversely product corresponds sum independent rvs 
problem naturally presents analysis algorithms follows class combinatorial structures trees permutations parameter structures size path length number inversions determine limit asymptotic distribution normalized variable gamma oe simulations suggest limit exist typical cases 
limit distribution usually provides information plain average case analysis 
transforms important tools study limit distributions 
characteristic functions fourier transforms defined rv oe efe gamma df nonnegative integer valued rv oe 

laplace transforms defined nonnegative rv efe df transform gammat called moment generating function essentially egf moments 
nonnegative integer valued rv gammat 
limit theorems 
appropriate conditions distribution functions sequence rvs converge pointwise limit point continuity 
convergence known weak convergence convergence distribution denote lim billingsley 
theorem continuity theorem characteristic functions 
sequence rvs characteristic functions oe distribution functions 
function oe continuous origin lim oe oe distribution function lim function distribution function rv characteristic function oe 
theorem continuity theorem laplace transforms 
sequence rvs laplace transforms distribution functions 
average case analysis algorithms data structures jtj limit lim distribution function lim function distribution function rv laplace transform 
similar limit conditions exist moments converge moments rv provided moment problem unique solution 
sufficient condition efx gamma 
generating functions 
nonnegative integer valued rvs define sequence prfx kg problem determine asymptotic behavior distributions fp associated cumulative distribution functions 
simple cases binomial distributions explicit expressions available treated real analysis techniques section 
cases horizontal gfs vertical gfs explicit expressions complex analysis methods extract coefficients asymptotically 
bivariate generating function explicit form stage method employed 
univariate problems 
known application univariate techniques central limit theorem 
delta delta delta sum independent identically distributed rvs mean variance tends normal distribution unit variance 
classical proof feller page uses characteristic functions characteristic function oe oe oe characteristic function converges gammat characteristic function normal distribution 
proof provides information rate convergence densities nonnegative integer valued uses saddle point method applied prfx kg dz pgf greene knuth 
general principle univariate problems solved continuity theorems complex asymptotics singularity analysis saddle point applied vertical horizontal generating functions 
examples 

horizontal generating function 
probability random permutation elements cycles 
gamma section 
limit probability distributions basic central limit theorem characteristic functions saddle point methods establish normality limiting distribution goncharov theorem 
normality result holds distribution inversions permutations 
jn gamma gamma inversions studied section connection sorting 

vertical generating function 
probability random binary string length run length gamma gamma singularity analysis knuth dominant singularity gammak gamma gamman bivariate problems 
bivariate problems explicit bivariate gfs stage approach may useful 
get approximation cauchy coefficient integral dz treating parameter applying singularity analysis saddle point method 
second real close example gammat close may able conclude analysis continuity theorem laplace transforms 
complex juj try continuity theorem characteristic functions 
instance bender obtained general normality results distributions corresponding bivariate generating functions form gamma ug ug results useful correspond distribution number components sequence partitional complex construct abelian partitional complex construct respectively 
little known bivariate gfs defined implicitly nonlinear functional equations notable exception jacquet jacquet 
multivariate analytical techniques analysis random graph models bollob 
average case analysis algorithms data structures 
sorting algorithms section describe important sorting algorithms including insertion sort shellsort bubble sort quicksort radix exchange sort selection sort heapsort merge sort 
sorting algorithms naturally described iterative fashion naturally described recursively 
section analyze performance iterative sorting algorithms unified way basic notions inversion tables lattice paths apply combinatorial tools section study inversions left right maxima techniques section derive asymptotic bounds 
defer analyses sorting algorithms recursive nature section exploit close connections recursive structures tree models studied section 
class sorting algorithms distribution sorting described analyzed section 
purposes average case analysis sorting assume input array input file forms random permutation elements 
permutation set elements mapping set 
typically represent set elements ng 
notation oe oe oe oe denote permutation maps oe input data model justified practice key values generated independently common continuous distribution 

inversions common thread running analyses sorting algorithms connection running time algorithm number inversions input 
inversion permutation oe order pair oe oe elements oe oe number inversions measure amount disorder permutation 
define rv number inversions number inversions particular permutation oe denoted oe 
concept introduced centuries ago means computing determinant matrix det oe sn gamma oe oe oe oe denotes set 
possible permutations 
definition 
inversion table permutation oe oe oe oe ordered sequence fi fi oe gamma oe kg fi fi oe gamma denotes inverse permutation oe oe gamma denotes index oe 
words equal number elements permutation oe precede value number inversions expressed terms inversion tables follows oe kn section 
inversions easy see correspondence permutations inversion tables 
inversion table property gamma combinations possible 
view inversion tables cross product kn gamma kg associate inversion table monomial bn define generating function gamma oe sn bn sum monomials 
permutations 
possibilities correspond term delta delta delta gammak get fundamental formula play central role analyses theorem 
generating function defined satisfies gamma delta delta delta gamma theorem powerful tool obtaining statistics related inversion tables 
example define number permutations elements having inversions 
theorem ogf delta delta delta gamma monomial bn contributes delta delta delta 
convert pgf phi dividing js phi 
kn delta delta delta gammak gamma expected number inversions variance var equal phi gamma var phi phi gamma gamma phi delta gamma mean equal half worst case value note phi product individual indicates section expressed sum independent rvs 
suggests way looking derivation decomposition question obvious average case analysis algorithms data structures inversion table delta delta delta pgf 
eqs 
follow summing var generalization central limit theorem sums independent rvs follows gamma oe converges normal distribution 
rv important sorting analyses number left right minima denoted permutation oe oe number elements oe preceding elements oe 
terms oe fi fi oe gamma gamma fi fi define number permutations elements having left minima 
theorem ogf gamma contribution term gamma theorem gamma 
pgf prfl 
kn gamma derivatives get var gamma gamma delta gamma nth harmonic number kn kn mean worst case value look derivation way suggested product decomposition decompose sum independent rvs delta delta delta oe oe left right minimum 
pgf summing var gives 
central limit theorem shows normalized converges normal distribution 
information suffices purposes analyzing sorting algorithms interesting point theorem applications 
example number permutations oe oe oe left right maxima 
theorem ogf yz xz delta delta delta gamma section 
shellsort 
insertion sort insertion sort method card players typically sort card hands 
kth loop gamma elements sorted order st element inserted proper place respect preceding elements 
simplest variant called straight insertion correct position successively comparing gamma element 
intervening elements simultaneously bumped position right room 
simplicity assume dummy element value gamma element 
values input file distinct number comparisons kth loop equal plus number elements precede input 
terms inversion table equal summing find total number comparisons straight insertion sort permutation oe oe gamma 
theorem follows directly theorem 
mean variance number comparisons performed straight insertion sorting random permutation gamma gamma respectively 
alternative straight insertion store sorted elements binary search tree kth loop consists inserting element tree 
elements inserted sorted order obtained inorder traversal 
balanced binary search tree insure log worst case time performance overhead balancing operations slows algorithm practice 
tree required balanced little overhead average running time faster 
defer analysis discussion binary search trees section 

shellsort main reason straight insertion relatively slow items inserted sequentially comparison reduces number inversions theta average 
average running time theta 
shell proposed efficient variant appropriately called shellsort insertion process done passes successive refinements 
input size passes determined increment sequence gamma 
pass consists straight insertion sorts delta delta delta delta delta delta early passes increments typically large elements displaced far previous positions comparisons passes fine tune average case analysis algorithms data structures placement elements 
pass consists single straight insertion sort entire array know section fast number remaining inversions small 
ordered permutations 
average case analysis shellsort pass version increment sequence 
assume input random permutation 
measure complexity total number inversions encountered course algorithm 
simplicity restrict case 
pass easy analyze consists independent straight insertion sorts size 
call permutation ordered gamma pass permutation ordered randomness assumption easy see gamma delta possible ordered permutations equally 
analysis pass consists determining average number inversions random ordered permutation 
theorem 
mean variance number inversions random ordered permutation size gamma gamma delta var gamma proof 
starting point proof important correspondence set ordered permutations elements set monotone paths upper left corner bottom right corner lattice 
kth step path appears odd position permutation appears position 
path typical permutation oe 
sorted permutation staircase path shown dotted lines 
important property representation number oe inversions oe equal area staircase path oe path 
easy heuristic argument show theta intuitively steps random path random walk similarly steps 
transition probabilities slightly different random walk complete path constrained exactly moves moves 
known random walks tend theta units away diagonal steps suggesting area walk staircase path theta 
extension notions admissibility section provides elegant precise way count area cumulated possible ordered permutations 
define set possible paths length point diagonal subset arches paths meet diagonal endpoints positive length 
path decomposed uniquely concatenation zero arches language theorem sequence class example path consists paths 
reasons symmetry section 
shellsort 
correspondence ordered permutations elements monotone paths 
dark path corresponds permutation oe 
dashed line staircase path represents sorted permutation 
number inversions oe equal shaded area oe path staircase path 
useful look paths stay side say right side diagonal 
restrictions right side diagonal denoted respectively 
path number moves moves 
define size path denoted jpj number moves parameter interest area staircase path call area weight denote kpk 
size weight functions linear fi fi pq fi fi jpj jqj kpk kqk pq denotes concatenation paths respectively number paths respectively jpj kpk define ogf define similarly 
mean variance expressed readily terms gamma delta fi fi fi fi gamma gamma delta fi fi fi fi var gamma gamma average case analysis algorithms data structures generalize admissibility approach theorem handle variables lemma 
sequence construct admissible respect size weight functions gamma gamma proof lemma 
equivalent definition ogf kpk jpj nontrivial path decomposed uniquely concatenation nontrivial paths linearity size weight functions delta delta delta delta delta delta kpk jpj gamma proof identical 
lemma gives formulae relating 
decomposition gives relations closes cycle lets solve path decomposed uniquely path size weight functions related jsj ksk jsj 
ksk jsj jsj uz ksk uz jsj uz uz path reflection diagonal call refl 
refl bs refl bs gamma gives refl ksk jsj ksk jsj ksk jsj equations viewed types admissibility reductions similar lemma case weight functions linear relations weight functions involve size function introducing uz arguments right hand sides 
section 
shellsort relations allow solve 
substituting gives uz substituting result get gamma uz zs delta express fi fi fi fi need terms derivatives evaluated turn calculated 
calculations straightforward best done symbolic algebra system 
alternate proof 
prove part theorem elegant way studying file decomposed pass sorted express gamma delta jn gamma total number inversions involving ith element gamma ordered permutations elements gamma 
total number ordered permutations gamma gamma gamma gamma gamma simple calculation shows contributes ji gamma jj inversions substituting get gamma delta jn gamma ji gamma jj gamma gamma gamma gamma gamma rest derivation consists manipulation binomial coefficients 
derivation variance similar 
increment sequence interesting practice pass takes quadratic time average 
generalize derivation show average number inversions random ordered permutation gamma 


gamma gamma bn hc mod hunt 
allows determine large larger best pass increment sequence 
pass insertion average case analysis algorithms data structures sorts size total number inversions average 
approximate average number inversions encountered second pass hn total number inversions passes hn average minimized resulting expected running time 
passes interesting phenomenon occurs sorted file sorted file remains sorted 
yao shows combine fact extension approach analyze increments form constant values known average case increment multiple 
case running time reduced ffl ffl gamma number increments 
pratt discovered get log time algorithm worst case increments form 
maximum efficiency increments need decreasing order precede particular approach typically practice number increments number passes log 
sequences log increments result ffl running time reported sedgewick 
lower bounds worst case sorting time various types increment sequences log increments weiss sedgewick cypher 
example shellsort requires omega log log log worst case time increment sequence monotonically decreasing cypher 
possible application shellsort construction efficient networks sorting 
sorting networks operate sequence pairwise comparison exchanges choice pair elements compare independently outcomes previous comparisons 
comparison exchanges involve different elements done parallel network operations done simultaneously parallel step 
sorting networks require omega log parallel steps depth 
developed practical sorting networks depth odd merge bitonic sort networks knuth 
ajtai koml os szemer edi solved longstanding open problem constructing sorting network depth log complete coverage pippenger 
aks sorting network theoretical breakthrough terms practicality network useful coefficient implicit big oh term huge 
log time shellsort possible modify yield sorting network depth log practical 
lower bound result quoted cypher shows order find log time shellsort increment sequence fundamentally different practice 
section 
bubble sort 
bubble sort bubble sort algorithm works series passes 
pass final portion array known sorted order largest element initial part array right sequence gamma pairwise comparisons gamma comparison elements exchange place order 
value reset largest comparison required exchange pass starts 
bubble sort algorithm useful practice runs slowly insertion sort selection sort complicated program 
analysis provides interesting inversion statistics asymptotic techniques 
running time bubble sort depends quantities number inversions number passes number comparisons analysis section 
theorem knuth 
average number passes comparisons done bubble sort random permutation size gamma gamma gamma log gamma fl log gamma delta proof 
pass bubble sort reduces nonzero entries inversion table 
passes algorithm entry original inversion table number inversion tables obtained theorem substituting ffi ik gives 
gammak notation ffi denote relation true 
plugging definition expected value get gamma 
kn 
gammak summation shown equal gamma application euler maclaurin summation formula theorem 
average number comparisons determined similar way 
moment restrict attention jth pass 
number comparisons done jth pass 
gamma upper index subarray processed pass characterize position array pass contains element moved left slot previous pass 
denote value element position follows elements positions value noted earlier nonzero entry inversion table decreases pass 
number inversions element jth pass gamma element located array position gamma 
gives gamma average case analysis algorithms data structures priori knowledge calculate formula max fi gamma gamma condition gamma restricts attention elements move left place pass gamma easy see term maximized correct define number inversion tables gamma gamma evaluate theorem substituting gamma gamma 
simple calculation gives 
gamma gammaj gamma definition expected value 
jn kn gammaj gamma gamma gamma delta gamma 
jn kn gammaj gamma 
sn 
gammas intermediate step follows summation parts 
summation simplified euler maclaurin summation formula series sums form 
gamma 
gamma gamma 
applying stirling approximation find summand decreases exponentially ffl reduce problem approximating gammak gamma 
derivation carried laplace method sums euler maclaurin summation formula see section things get complicated case gamma 
elegant derivation mellin transforms 
function harmonic sum mellin transform gamma gamma defined fundamental strip 
asymptotic expansion follows computing residues left half plane 
simple poles gamma gamma term gamma 
gamma gamma gamma terms combine contribute double pole 
gamma contributes simple pole gamma simple pole 
putting find 
sn 
gammas log fl log formula follows immediately 
section 
radix exchange sort passes bubble sort algorithm number elements known final place typically larger variable set small possible minimize size array considered pass 
fact log implies number comparisons large significantly naive algorithm process kth pass done subarray gamma 

quicksort get efficient exchange sorting algorithm divide conquer approach 
quicksort method due hoare element chosen say element file file partitioned part part half sorted recursively 
recursive decomposition analyzed sophisticated tools develop section binary search trees similar decomposition defer analysis section 
expected number comparisons log analysis techniques results quicksort knuth sedgewick 
quicksort extremely general purpose sorting routine 
big drawback version described worst case performance requires theta time sort file sorted nearly sorted 
way guard guaranteed bad behavior choose element random element current case analysis applies 
method choose median elements say middle elements 
effect reducing average number comparisons log smaller processed partition recursion stack contains log entries 
clever programming simulate stack constant amount space slight increase computing time huang knuth 
analysis quicksort presence equal keys sedgewick 

radix exchange sort radix exchange sort algorithm exchange algorithm uses divide andconquer different way quicksort 
recursive decomposition individual bits keys 
pass keys partitioned groups group kth significant bit group kth significant bit 
partitioning done stable manner relative order keys group partitioning 
group appended group pass begins 
passes number bits keys algorithm terminates 
case recursive decomposition identical radix exchange tries shall study general context section statistics interest sorting expressed directly terms corresponding parameters tries 
defer details section 
average case analysis algorithms data structures 
selection sort heapsort selection sort respects inverse insertion sort order elements processed output order input order 
kth pass gamma kth smallest element selected put final place 
straight selection 
simplest variant called straight selection sort kth smallest element sequential scan changes places current 
insertion sort algorithm stable elements value output reverse order appear input 
number comparisons performed gamma gamma delta delta delta gamma number times new minimum number data movements kth pass number left right minima gammak encountered minus 
permutations fx equally 
average number updates minimum course algorithm kn gamma gamma gammak gamma delta gamma log fl gamma log variance difficult compute contributions gammak individual passes independent 
contributions independent variance log yao shows relating variance geometric stochastic process variance ffn gives constant ff explicitly summation form 
heapsort 
sophisticated way selecting minimum called heapsort due williams notion tournament elimination 
gamma elements consider kth pass stored heap priority queue 
heap tree value root subtree equal values elements subtree 
particular smallest element root 
heaps heapsort nice property tree perfectly balanced possibly rightmost part level 
allows represent heap array need pointers root element children element stored 
kth pass heapsort consists deleting array element stored gamma moved filtered correct place log time 
creation initial heap done linear time 
worst case time sort elements log 
average case analysis complicated lack randomness heap start kth pass random heap gamma elements 
heaps types priority queues discussed section mehlhorn 
section 
merge sort 
merge sort sorting program executed electronic computer divide conquer approach known merge sort file split equal size nearly equal size sorted recursively sorted merged obvious linear fashion 
done bottom algorithm consists passes pass sorted paired pair merged 
linear nature merging process ideal input files form linked list external sorting applications file fit entirely internal memory stored external memory disk tape best accessed sequential manner 
typically merge higher order example time merged just 
considerations number comparisons rewind time tapes seek time disks affect running time 
encyclopedic collection variants merge sort analyses appears knuth 
merge sort algorithms optimal external sorting multiple disks discussed aggarwal vitter nodine vitter 
simplicity restrict attention number comparisons performed binary order merge sort 
comparisons take place merges 
gamma merges pairs sorted size gammak gamma assume 
permutations equally easy see far relative order concerned merge form random ordered permutation independent merges 
number comparisons merge random sorted length gamma number elements remaining output exhausted 
probability probability largest elements denotes falling power gamma gamma 
total number comparisons merge sort average gamma kj gamma gammak gammak gamma log gamma ffn ff average case analysis algorithms data structures analysis power involves arithmetic functions binary representation knuth 
odd merge bitonic sort networks construct sorting networks depth log analyzed knuth sedgewick 
merging algorithms covered mehlhorn 
section 
binary trees plane trees 
recursive decompositions algorithms trees section develop uniform framework obtaining average case statistics classes trees binary plane trees binary search trees radix exchange tries digital search trees 
statistics include number trees number nodes height path length numerous applications analysis tree searching symbolic processing algorithms sorting algorithms analysis deferred section quicksort binary tree sort radix exchange sort 
approach parts 
classes trees recursive formulation lends naturally symbolic generating function method described section 
statistic interest tree corresponds naturally valuation function vf 
key idea unifies analyses extension admissibility concept section recursive definition vf translates directly functional equation involving generating function 
type generating function ogf egf type functional equation results depend particular nature recursion 

determine coefficients gf functional equation resulting step 
explicit closed form obtained typically apply asymptotic methods section particular approach depending nature functional equation 

binary trees plane trees binary trees plane trees provide natural representation types symbolic expressions recursive structures 
section studies statistical models trees size equally 
models applicable study binary search trees radix exchange tries digital search trees cover sections enriched slightly provide models algorithms operating expression trees term trees lisp structures clark 
considering class binary trees defined section fl theta theta represents external node fl internal node 
size binary tree number internal nodes tree 
cartesian product decomposition suggests represent statistic interest ogf 
motivation choice eqs 

represent valuation function applied tree define cumulated value jtj trees size ogf recursive decomposition leads directly fundamental relations average case analysis algorithms data structures theorem 
sum recursive product valuation functions admissible class binary trees left delta right delta delta left right denote left right subtrees proof similar theorem 
importance theorem due fact provides automatic translation vf ogf vfs interest 
examples 

enumeration 
standard trick shall section counting number trees size certain class unit vf 
example number binary trees internal nodes 
definitions simply equal ogf equal 
solve theorem recursive definition ffi jtj left delta right composition types vf expressions handled theorem 
ffi denotes relation true 
ogf ffi jtj 
theorem translates zb solution gamma gamma follows quadratic formula 
expanding coefficients get gamma delta section 
internal path length 
standard recursive tree traversal algorithm uses stack keep track ancestors current node traversal 
average stack size amortized course traversal related internal path length tree divided vf corresponding cumulated internal path lengths binary trees nodes expressed form suitable theorem jtj gamma ffi jtj left right jtj gamma ffi jtj left delta right left delta right computed ffi jtj example ogf size vf jtj easily seen nb zb 
applying theorem zb gamma gives zb gamma gamma zb gamma gamma gamma gamma gamma get expanding 
result asymptotics follow stirling formula 
section 
binary trees plane trees theorem 
cumulated internal path length binary trees nodes gamma expected internal path length asymptotically gamma 
theorem implies time traversal leaf root random binary tree average 
similar derivation knuth considers bivariate ogf number binary trees size internal path length satisfies functional equation zb uz cf 

expected internal path length variance formed usual way terms coefficients derivatives evaluated 
examples illustrate general philosophy useful compute standard catalogue valuation functions handle large variety statistics 
important vfs clearly 
important class trees class plane trees known ordered trees 
tree consists root node arbitrary number ordered subtrees 
suggests recursive definition fl theta fl represents node fl theta sequence class defined section 
size tree defined number nodes 
interesting subclass class omega plane trees degrees nodes constrained subset omega nonnegative integers 
require omega trees infinite 
class special case omega omega set nonnegative integers 
possible mimic get corresponding representation fl theta omega shall see just simple deal directly appropriate vf restrict degrees 
important correspondences 
set binary trees size isomorphic set plane trees size 
standard technique data structures illustrates correspondence represent general tree nodes binary tree right subtree binary tree internal nodes left subtree left link denotes child right link denotes sibling 

think bottommost nodes trees external nodes get correspondence binary trees size plane trees degree constraint size 
theorem generalizes straightforward manner average case analysis algorithms data structures theorem 
sum recursive product valuation functions admissible class plane trees ffi deg omega deg omega ik deg represent subtrees attached root examples 
enumerations 

number plane trees nodes obtained unit vf plane trees non empty jtj 
theorem get gamma gammai delta implies gamma gamma zb illustrates correspondence mentioned 

number trees size degree constraint omega gamma apply constrained unit vf omega ffi ffi deg omega omega special case omega theorem gives omega zi omega solution quadratic equation omega gamma gamma zb illustrating correspondence 
define class ary trees fl theta 
binary trees special case 
number ary trees obtained generalizing derivation section 
derivation comes generalizing correspondence staying framework plane trees ary tree corresponds plane tree dn nodes degree constraint omega dg 
derivation preceding example gives zi lagrange inversion get dn dn dn dn gamma dn delta dn dn examples functional equation involving ogf simple ogf solved explicit closed form inversion theorem applied easily coefficients powers easy determine 
advanced asymptotic methods needed example determine number plane trees arbitrary degree constraint omega gamma assume simplicity omega aperiodic omega consists sequence positive integers greatest common divisor 
count start second example 
applying theorem get gamma delta omega lagrange inversion little help terms take approach 
singularities algebraic nature 
know section asymptotic behavior coefficients section 
binary trees plane trees related dominant singularities ones smallest modulus 
find singularities regard solution equation gamma function defined implicitly function implicit function theorem solution analytically denotes partial derivative respect singularities values analytic values ae ae gamma ae ae gamma ae 
gives ae 
root equation gamma denote dominant singularity positive real line ae unique corresponding value 
ae follows real 
omega aperiodic examining power series equation corresponding see unique real solution solution larger modulus 
point ae dependence locally form ae gamma ae delta gamma yy ae gamma smaller order terms iteration bounding coefficients show form gamma ae analytic ae ae gamma 
ae gamma ae gamma ae theorem shows contribution insignificant 
applying transfer lemma theorem get final result theorem meir moon 
omega aperiodic cae gamman gamma constants ae 
ae smallest positive root equation gamma 
brevity expanded terms easily expanded get full asymptotic expansion periodic case considered meir moon generating function dominant singularity contributions dominant singularities added 
rest section show parameters trees analyzed making partial approach 
asymptotics determined techniques described sections 
average case analysis algorithms data structures height plane trees 
example consider expected maximum stack size recursive tree traversal 
earlier considered expected stack size amortized course traversal 
maximum stack size simply height tree length longest path root node 
theorem de bruijn knuth rice 
expected height plane tree nodes tree equally proof sketch 
number plane trees height corresponds vf defined height 
recursive formulation right form apply theorem 
get gamma note similarity generating function plane trees satisfies gamma gamma delta easy transform gamma zf polynomials chebyshev polynomials 
linear recurrence satisfies express rational function 
applying inversion get expression gamma gamma gamma gamma gamma gamma expected tree height gamma gamma gamma substituting see evaluation related sums form gamma oe number divisors stirling approximation approximate gammak problem evaluate asymptotically 
expansions section mellin transforms gamma log fl gamma log 
theorem follows appropriate combination terms form 
section 
binary trees plane trees theorem flajolet odlyzko 
expected height plane tree degree constraint omega omega aperiodic tree equally constant depends omega proof sketch 
analogy vf ffi height th vf expressed recursively ffi deg omega theorem gives gamma delta omega generating function cumulated height trees equal gamma way regard simply iterative approximation scheme fixed point equation determines 
delicate singularity analysis leads result 
analysis need examine behavior iterative scheme near singularity ae example singular iteration problem 
find neighborhood ae gamma ae log gamma ae appropriate constant 
theorem follows directly 
methods similar proof theorem odlyzko prove theorem odlyzko 
number balanced plane trees external nodes oe log oe golden ratio continuous periodic function 
result extends families balanced trees search structures guaranteed log access time 
occurrence golden ratio theorem surprising discussion section equation satisfied ogf pattern matching 
important class algorithms trees deals pattern matching problem detecting occurrences pattern tree inside larger text tree occurs symbolic manipulation systems 
simpler case string matching linear time worst case algorithms known conjectured linear time algorithm exists tree pattern matching 
straightforward algorithm called sequential matching quadratic running time worst case shown run linear time average 
node tree compare subtree rooted node pattern tree doing simultaneous preorder traversals 
mismatch preorder traversal aborted node tree considered 
preorder traversal successfully finishes match 
average case analysis algorithms data structures theorem steyaert flajolet 
expected running time sequential matching algorithm applied fixed pattern trees size cn function degree constraint omega structure pattern uniformly bounded absolute constant proof sketch 
proof depends lemma probability occurs random node tree asymptotically gamma ae numbers internal external nodes algebraic part proof lemma direct application method theorems applied multisets trees 
generating functions number pattern matches simple expressions terms singularity analysis finishes proof 
type analysis applied large variety tree algorithms semi automatic way 
illustration theorem flajolet steyaert 
set theta operators delta differentiation rules expanding rule average case complexity symbolic differentiation algorithm asymptotically cn constant depends theta delta 
tree compaction 
different kind singular behavior occurs problem known common subexpression elimination tree compaction tree compacted directed acyclic graph avoiding duplication identical substructures 
applications compaction lisp programs code optimization 
theorem flajolet steyaert 
expected size maximally compacted dag representation random tree size cn log log constant depends omega dominant singularity case form gamma log gamma gamma theorem shows space savings expected compacting trees approaches percent convergence slow 
register allocation 
register allocation problem consists finding optimal strategy evaluating expressions represented tree 
optimal strategy due ershov requires log registers evaluate tree size theorem determines coefficient average case evaluating expressions involving binary operators theorem flajolet vuillemin kemp 
expected optimum number registers evaluate random binary tree size log log periodic function period small amplitude 
proof sketch 
analysis involves combinatorial sum gamma number decomposition prime factors 
normalize approximate binomial coefficient exponential term section 
binary search trees compute approximation mellin transform gamma gamma set regularly spaced poles ki log corresponds periodic fluctuations form fourier series 

binary search trees denote bst binary search tree formed inserting sequence elements 
recursive decomposition bst ae omega bst bst ff jsj jsj element subsequence elements 
subsequence elements empty binary search tree represented external node search element proceeds follows starting root current node compare set left child set right child process repeated successful search external node reached unsuccessful search 
note process finds element value elements values distinct problem left path searched leaf element smaller value reached 
insertion done inserting new element tree point unsuccessful search ended 
importance binary search trees sorting range queries linear time inorder traversal output elements sorted order 
known data structures trees avl trees red black trees search trees extra ensure insert delete query operations done log time size tree 
cases times logarithmic worst case case logarithmic amortized sense 
balanced trees discussed mehlhorn 
section show logarithmic bounds hold average case need balancing overhead 
probability model assumes sequence elements picked random sampling real interval equivalently far relative ordering concerned elements form random permutation size dynamic version problem corresponds average case amortized analysis appears section 
define bst class binary search trees corresponding permutations bst oe oe denote random variable describing size average case analysis algorithms data structures left subtree js js gamma gamma probability model splitting probabilities kg gamma 
consequence trees bst equally occur 
example perfectly balanced tree nodes occurs oe oe twice occur tree oe 
powerful valuation function method introduced section applies equally binary search trees 
case nature recurrence suggests cumulative values equivalently expected values 
vf expected value trees size define ogf theorem 
sum subtree product valuation functions admissible class bst binary search trees delta dt denote left right subtrees subtree product vf typically results integral equation differentiation put form differential equation 
differs equations resulted theorems section binary plane trees 
illustration techniques compute expected number probes successful search random binary search tree size assume elements equally object search 
easy see equal expected internal path length divided plus suffices compute recursive definition corresponding vf jtj gamma ffi jtj jtj gamma ffi jtj delta delta unit vf ogf gamma 
size vf jtj ogf nz gamma theorem translates gamma gamma dt differentiating get linear order differential equation gamma gamma gamma gamma solved variation parameter method get gamma log gamma gamma gamma gamma gamma log gamma gamma ogf harmonic numbers 
theorem results extracting section 
binary search trees theorem 
expected internal path length random binary search tree internal nodes gamma log fl gamma logn theorem shows average search time random binary search tree percent longer perfectly balanced binary search tree 
short ad hoc derivation random binary search tree ancestor element fs jg jg jg inserted tree happens probability ji gamma jj 
jn ji gamma jj readily yields desired formula 
expected internal path length direct application statistics interest 
example expected number comparisons sort sequence elements building binary search tree performing inorder traversal 
expected number probes unsuccessful search average number probes insertion insertions preceded unsuccessful search average external path length ep divided 
known correspondence ep ip external path length ep internal path length ip binary tree internal nodes leads readily yields expression theorem 
derive directly 
alternative ad hoc proof combines different linear relation gamma eq 
follows observation possible successful searches tree size retrace steps taken unsuccessful searches done elements originally inserted 
quicksort 
apply valuation function machinery analysis quicksort mentioned section 
average number comparisons quicksort sort elements 
quicksort works choosing partitioning element say element dividing file part part recursively sorting 
process remarkably similar recursive decomposition binary search trees 
version quicksort knuth sedgewick uses comparisons split file parts 
gamma comparisons needed extra comparisons help speed rest algorithm actual implementations 
initial conditions 
corresponding vf jtj gamma ffi jtj gamma ffi jtj jtj gamma ffi jtj gamma ffi jtj delta delta average case analysis algorithms data structures jtj gamma gamma translation theorem get gamma gamma gamma gamma gamma dt gamma gamma gamma linear differential equation solved variation parameter method get gamma log gamma gamma gamma gamma gamma gamma gamma gamma extract get gamma log fl gamma log practice quicksort optimized stopping recursion size parameter algorithm terminates final insertion sort done file 
know section insertion sort efficient number inversions small 
analysis quicksort modified give average running time function optimum determined function done knuth sedgewick shown optimum typical implementations gets large 
average number comparisons derived truncated vf ffi jtj jtj delta delta cf 

truncated unit vf ffi jtj truncated size vf sm ffi jtj jtj gamma nz gamma gamma mz delta gamma respectively 
rest derivation proceeds done symbolic algebra system result cf 
gamma hm height binary search trees 
analysis height binary search trees involves interesting equations generating functions 
analogy denote probability random binary search tree size height corresponding vf ffi height th form ffi jtj delta theorem translates dt section 
binary search trees gamma 
sequence fg forms sequence picard approximants 
ogf expected height gamma natural conjecture singular expansion gamma log gamma constant succeeded far establishing directly 
devroye determined asymptotic form theory branching processes theorem devroye 
expected height binary search tree size log root equation theorems point clearly random binary search tree fairly balanced contrast random binary trees studied section 
expected height path lengths binary search trees log log theorem corresponding quantities binary trees 
interesting problems average case analysis arise connection balanced search trees interest usually focused storage space running time 
example fringe analysis yao brown derive upper lower bounds expected storage utilization number balanced nodes random trees trees 
techniques extended get better bounds computations prohibitive 
multidimensional search trees 
binary search tree structure generalized various ways dimensions 
obvious generalization called quad trees uses internal nodes degree 
quad tree sequence inserted elements defined ae omega 

ff jsj jsj 
element dimensional number quadrants determined denoted 

quad trees support general range searching particular partially specified queries form find elements 
search proceeds recursively subtrees range overlaps query range 
theorem flajolet 
expected number comparisons partially specified query quad tree size bn gamma positive real number 
proof sketch 
splitting probabilities quad trees simple form determined readily 
appropriate vf get gamma average case analysis algorithms data structures terms ogf zc second order differential equation gamma gamma gamma clear solve explicitly get asymptotic estimates fact gamma gammaff positive real ff 
determine closed form general type problem ff determined substituting gamma gammaff get equation ff ff gamma positive solution ff gamma 
transfer lemma theorem gives final result 
quad trees generalized dimensions degrees nodes large practical 
better alternative called trees binary search tree splitting node level ordinate mod element stored 
theorem flajolet puech 
expected number elementary comparisons needed partially specified query tree size fields specified gammas root equation gamma gamma gammau gamma 
proof sketch 
proof proceeds developing system integral equations expected costs appropriate vfs applying theorem 
reduces differential system order gamma solved explicitly terms standard transcendental functions singularity analysis done get result generalization approach quad trees 
data structures multidimensional search applications computational geometry yao 
heap ordered trees 
conclude section considering heap ordered trees value root node subtree values elements subtree 
discussed classical array representation perfectly balanced heap connection heapsort algorithm section 
heap ordered trees provide efficient implementations priority queues support operations insert find min delete min 
additional operations include merge decrease key viennot vuillemin direct implementation heap ordered trees support merge operation 
sequence elements define hot canonical heap ordered tree formed recursive definition hot ae omega hot left min hot right ff jsj jsj 
min index rightmost smallest element left initial subsequence min gamma right final subsequence min section 
radix exchange tries assume probability model random permutation elements 
analysis parameters heap ordered trees similar analysis binary search trees equivalence principle due burge burge vuillemin theorem 
pair inverse permutations oe oe gamma bst oe shape hot oe gamma shape means unlabeled trees associated trees identical 
purposes analysis parameter permutations defined inductively associated heap ordered tree analyzed admissibility rules theorem binary search trees 
heap ordered trees form cartesian trees handle variety dimensional search problems vuillemin 

radix exchange tries radix exchange tries binary search trees elements stored external nodes navigation trie level ith bit search argument 
bit means go left bit means go right 
assume simplicity element real number infinite precision 
trie tr set elements defined recursively tr omega tr fl tr ff jsj jsj jsj defined follows take elements bit throw away bit get elements left subtrie 
set elements right subtrie defined similarly elements starting bit 
elements stored external nodes trie 
single element trie consists external node value empty trie represented null external node 
size trie number external nodes 
trie tr depend order elements inserted quite different case binary search trees order big difference shape tree 
tries shape trie distribution elements values 
probability model values elements independent uniform real interval 
define class tries tr 
probability trie elements left subtrie size right subtrie size gamma bernoulli probability suggests expected values represent trie statistics 
denote expected value vf trees size egf 
admissibility theorem takes form average case analysis algorithms data structures theorem 
sum subtree product valuation functions admissible class tr tries delta represent left right framework analysis tries valuation functions flajolet 
typical cases vfs encounter form difference equations iterate 
expected number bit inspections successful search trie external nodes equal expected external path length divided theorem shows search times logarithmic average balancing done 
theorem knuth 
average external path length random trie size log gamma fl log log delta periodic function small amplitude period mean value 
proof 
vf corresponding external path length jtj gamma ffi jtj delta delta unit vf egf size vf jtj egf nz ze theorem translates ze gamma iterating recurrence extracting coefficients get gamma gamma gamma gamma gamma easy verify natural approximation np harmonic sum gamma gammax derived asymptotic expansion mellin transforms 
result follows immediately 
theorem generalizes biased case bits element independently probability probability gamma average external path length asymptotically log entropy function gammap log gammaq log case unsuccessful searches similar approach shows average number section 
radix exchange tries bit inspections log variance fluctuation unbiased case jacquet 
variance estimates range problems involve interesting connections modular functions 
variance increases log constant biased case jacquet 
limiting distributions studied jacquet 
height trie mean log variance flajolet 
limiting distributions height studied flajolet 
important statistic tries search time storage space 
binary search trees amount auxiliary space tries measured terms number internal nodes variable 
theorem shows average number internal nodes trie percent number elements stored trie 
theorem knuth 
expected number internal nodes random unbiased trie external nodes log gamma log delta periodic function small amplitude period mean value 
proof 
vf corresponding number internal nodes ffi jtj delta delta theorem translates gamma gamma iterating recurrence extracting coefficients get gamma gamma gamma gamma gamma gamma gamma approximate natural way gamma gammax jj equation harmonic sum mellin transform computed readily gamma gamma fundamental strip gamma gamma 
result follows computing residues right half plane gamma 
simple pole due gamma poles gamma ki log due denominator 
average case analysis algorithms data structures biased case expected number internal nodes variance unbiased biased case includes fluctuating term jacquet distribution number internal nodes normal jacquet 
theorem number results tries generalizes case external node trie represents page secondary storage capable storing elements 
tries generally called tries 
analysis uses truncated vfs second quicksort example section recursion subtrie elements 
result applies equally extendible hashing scheme fagin trie built hashed values elements elements 
extendible hashing considered section 
theorem knuth 
expected number pages capacity needed store file records tries extendible hashing gamma log delta gamma log delta periodic period mean value 
patricia tries 
external node trie size sibling generally case internal nodes 
compact form tries called patricia tries obtained collapsing internal nodes sibling 
statistics patricia tries analyzed knuth 
radix exchange sorting 
accident radix exchange tries sorting algorithm common name 
radix exchange sorting related tries way similar quicksort related binary search trees relationship closer 
average case analyses section carry analysis radix exchange sorting distribution number partitioning stages radix exchange sorting sort numbers distribution number internal nodes trie distribution number bit inspections done radix exchange sorting distribution external path length trie 

digital search trees digital search trees tries elements stored internal nodes equivalently binary search trees branching level determined st bit full element element comparison 
digital search tree dst sequence inserted elements defined recursively dst ae omega dst dst ff jsj jsj element sequence elements left subtree formed elements gamma fs bit throwing away bit 
sequence right subtree defined symmetrically elements bit 
binary search trees size tree number internal nodes shape sensitive order elements inserted 
section 
digital search trees empty digital search tree denoted external node probability model tries probability tree elements left subtree size right subtree size gamma gamma gamma gamma delta gamma class digital search trees denoted dst nature decomposition suggests expectations analysis section admissibility theorem takes different form theorem 
sum subtree product valuation functions admissible class dst digital search trees delta dt denote left right subtrees tries preferred practice digital search trees element comparison done node digital search tree takes longer bit comparison done trie elements trie kept sorted order 
space manuscript include relevant analysis refer reader knuth newman flajolet sedgewick 
key difference analysis digital search trees analysis tries section equations result theorem typically difference differential equations mellin techniques worked tries applied directly 
asymptotics come application due rice classical formula calculus finite differences proof formula easy application cauchy formula 
theorem 
closed curve points analytic inside gamma gammaz dz gamma gamma gamma classical beta function 
theorem knuth newman 
expected internal path length random digital search tree log fl gamma log gamma ff log fl euler constant ff delta delta delta periodic function period small amplitude 
average case analysis algorithms data structures 
hashing address computation techniques section consider known hashing algorithms including separate chaining coalesced hashing uniform probing double hashing secondary clustering linear probing discuss related methods interpolation search distribution sorting 
machine independent model search performance hashing number probes hash table search 
primarily interested expected number probes search cases consider distribution number probes expected maximum number probes searches table 
hashing searches performed constant time average regardless number elements hash table 
hashing algorithms pre defined hash function hash fall possible mg assigns hash address elements 
hashing algorithms differ resolve collision results element hash address occupied 
main techniques resolving collisions chaining links explicitly link elements hash address open addressing search path table defined implicitly 
study classes hashing algorithms sections 
bernoulli probability model average case analysis assume possible sequences hash addresses hash sequences equally 
simulation studies confirm reasonable assumption designed hash functions 
discussion hash functions including universal hash functions appears mehlhorn 
assume unsuccessful search slots hash table equal probability object successful search equally elements table 
insertion typically preceded unsuccessful search verify element table simplicity shall identify insertion time time unsuccessful search 
denote expected number probes unsuccessful search insertion hash table elements expected number probes successful search section 
bucket algorithms hashing chaining 
bucket algorithms hashing chaining separate chaining 
obvious techniques resolving collisions link elements hash address list chain 
generic name technique separate chaining 
variant shall study stores chains auxiliary memory ith slot hash table contains link start chain elements hash address particular variant typically called indirect chaining hash table stores pointers elements 
search time clearly depends number elements chain searched 
refer set elements hash address ith bucket 
define simply bernoulli model rv describing number elements bucket model called urn model distribution called occupancy distribution 
distributions sort appear analyses chaining algorithms consider section serve unify analyses 
urn models discussed section 
unsuccessful search chain length probe element plus probe find link chain 
allows express expected number probes unsuccessful search ae im oe symmetry expected values efx restrict attention particular bucket say bucket 
simplicity shall abbreviate 
eq 
simplifies successful searches chain length contributes delta delta delta probes 
expected number probes successful search ae im oe efx compute unified way pgf prfx eqs 
expressible simply terms derivatives shall determine extending admissible constructions developed section urn model 
approach especially useful analyses average case analysis algorithms data structures section maximum bucket occupancy extendible hashing coalesced hashing 
consider hash table ary partitional product individual buckets delta delta delta new twist elements table marked rule 
shall explain shortly relates separate chaining 
number hash sequences elements marked denote egf 
analogy theorem theorem shows partitional product translates product proof similar theorem omitted brevity 
theorem 
number marked elements bucket function number elements bucket egf decomposed delta delta delta bm 
number marked elements bucket elements bucket interested number elements bucket adopt marking rule elements bucket marked elements left unmarked 
terms theorem uz bucket buckets substituting theorem gamma obtain egf dividing term equivalently replacing combining gives 
gamma gamma gamma get theorem substituting expressions term ff called load factor 
section 
bucket algorithms hashing chaining theorem 
expected number probes unsuccessful successful search indirect chaining elements hash table slots ff gamma ff derive ad hoc way decomposing sum independent rvs delta delta delta ith element goes bucket 
distribution pgf clearly gamma pgf sum independent rvs equal product get eq 

derive formula noting eq 
binary search trees holds separate chaining 
examples 

direct chaining 
efficient version separate chaining called direct chaining stores element chain directly hash table 
shortens successful search time probe expected unsuccessful search time reduced prfx gamma gamma gamma gamma gammaff probes 
get gamma gammaff ff gamma ff 
direct chaining relocation 
variant wasteful hash table slots auxiliary space store empty slots available hash table 
reason load factor ff defined true indication space usage 
method direct chaining relocation stores elements directly hash table 
special situation arises element hash address hash collides insertion element element chain inserted empty slot table linked chain 
start chain relocated empty slot order room link predecessor chain updated 
successful search time 
unsuccessful searches start middle chain chain length contributes probes 
search starting gamma empty slots takes probe 
gives hash gamma ff main difficulty algorithm overhead moving elements expensive large record elements allowed pointers elements outside hash table 
updating previous link requires bidirectional circular chains recomputing hash address links reached 
alternatives attractive shall soon consider better alternative called coalesced hashing nearly number probes search overhead 
average case analysis algorithms data structures distribution sorting 
bucketing sort efficiently linear time values elements smoothly distributed 
suppose simplicity values real numbers unit interval 
distribution sort algorithm works breaking range values buckets gamma elements partitioned buckets values 
bucket sorted selection sort cf 
section simple quadratic sorting method 
sorted buckets appended get final sorted output 
selection sort uses gamma delta comparisons sort elements 
average number comparisons distribution sort ae im oe im ae gamma oe im gamma values elements independently uniformly distributed 
done algorithm takes time gives linear time sorting algorithm choose theta 
note contradict known omega log lower bound average sorting time comparison model comparison algorithm 
assumption values independently uniformly distributed easy justify case hashing hash function scramble values partitioning elements raw values 
suppose elements independently distributed density function 
analysis suggested karp knuth devroye assume dx assures behaved 
choose ff positive constant ff 
define dx probability element falls ith bucket gamma 
general eq 
gamma gamma delta im im dx summation bounded application jensen inequality treating rv uniformly distributed im dx im mx im mx dx section 
bucket algorithms hashing chaining show upper bound asymptotically tight computing corresponding lower bound 
im dx dx mp histogram approximation converges 
fatou lemma get lower bound lim inf dx ff lim inf dx ff lim inf dx ff dx substituting approximation find average number comparisons ffn dx coefficient linear term proportional dx large 
erratic behavior due nonuniform alleviated level recursion algorithm sort individual buckets assume number elements bucket sort bucket breaking range gamma proceed 
surprising fact shown techniques similar bounded limit regardless assuming course assumption dx satisfied 
theorem devroye 
expected number comparisons done level bucketing sort elements independently distributed density function satisfies dx gammaf dx variance higher moments number probes small 
unit interval assumption valid values elements bounded redefine interval min max apply basic idea 
analysis little complicated details appear devroye 
actual implementation hashing scheme separate chaining store elements table 
sorting linear probing discussed section 
application bucketing fast sorting associative secondary storage devices appears lindstrom vitter 
randomized algorithm optimal sorting multiple disks vitter shriver 
interpolation search 
newton method secant method known schemes determining leading bits zero continuous function log iterations 
zero mean solution equation 
starting initial approximation methods produce sequence refined approximations converge zero assuming behaved 
discrete analogue called interpolation search elements sorted array goal find element particular value variants method discussed mehlhorn 
average case analysis algorithms data structures theorem yao yao gonnet rogers george 
average number comparisons successful search interpolation search sorted array log log assuming elements values independently identically distributed 
bound similar continuous case think accuracy log number bits needed specify array position detailed probabilistic analysis connecting interpolation search brownian motion appears 
proof sketch 
restrict considering upper bound 
gonnet rogers george show probabilistic arguments probability probes needed find bounded ik gamma gammat gammai log 
expected number probes bounded expressed terms harmonic sum gamma gammat gammai gamma sum harmonic sum mellin transforms applied get log ff log ff constant periodic function associated poles ki log 
log log bound follows substituting log 
maximum bucket occupancy 
interesting statistic lies average case worst case search times expected number elements largest bucket known maximum bucket occupancy 
special significance parallel processing applications elements partitioned randomly buckets buckets processed parallel linear time case expected maximum bucket occupancy determines average running time 
product decomposition theorem count number hash sequences give hash table elements bucket 
mark elements bucket bucket elements elements section 
bucket algorithms hashing chaining left unmarked 
terminology quantity interest simply number hash sequences marked elements 
theta 

gamma delta delta delta bm delta nb 
sum truncated exponential denote 
number hash sequences elements bucket 
gamma delta denote probability random hash sequence puts elements bucket 
convert enumeration probability replacing 
jj close relation egf bernoulli statistics corresponding poisson statistic theorem 
egf measure example probability expectation moment bernoulli model gammaff ff corresponding measure total number elements delta delta delta xm poisson mean ff 
proof 
measure poisson model conditional expectation measure bernoulli model prfx delta delta delta xm ng gammaff ff 
gammaff bg ff shall theorem direct attention poisson model number elements bucket poisson distributed mean ff total number elements poisson rv mean mff 
analysis bernoulli case handled way shall handle analysis extendible hashing section covering poisson case different perspective 
ff denote maximum number elements bucket poisson model ff denote probability ff theorem ff gamma gammaff ff delta average case analysis algorithms data structures derived directly noting buckets independent poisson probability bucket elements gammaff ff 
want compute expected maximum bucket occupancy ff ff gamma gamma ff gamma ff shall consider case ff log basic principles analysis apply ff 
common occurrence occupancy rvs sharp rise distribution ff central region near mean value 
intuitively approximation mean value ff sufficiently away 
choose value ff gammaff ff 
gammaff ff 
ff theta easy see gamma gamma log log log 
gamma gamma denotes inverse gamma function gamma 
define left hand side gammaff ff 
particular ff 
bound illustrates sharp increase ff function vicinity ff gamma gammaff ff delta gamma gammaff 
ff 
gamma gammaff ff 
gamma ff gammaff approximation valid uniformly gamma delta expression gamma ff continues decrease exponentially 
maximum bucket size equal probability gamma probability gamma gamma net effect get asymptotic approximation ff approximating gamma ff step function step ff 
techniques applied general ff 
asymptotic behavior ff bernoulli poisson models 
theorem 
bernoulli model elements inserted buckets ff poisson model occupancy bucket section 
bucket algorithms hashing chaining independent poisson rv mean ff expected maximum bucket occupancy ff log log log ff theta ff log ff ff log 
ff gets large ff log bucket occupancies fairly uniform difference ff gamma ff converges probability ff log provided ff extendible hashing 
quantity related maximum bucket occupancy expected directory size extendible hashing hash table allowed grow shrink dynamically fagin larson 
slot hash table models page secondary storage capable storing elements 
bucket overflows number buckets table successively doubled bucket elements 
directory acts trie infinite precision hash addresses elements cf 
section 
reason analyses directory size trie height closely related 
time directory size equal number buckets table power 
probability directory size 
jj identical case parameter varies bucket capacity stays fixed 
derive admissibility theorem tries theorem probability height random trie egf satisfies gamma jj follows 
theorem flajolet 
bernoulli model expected directory size extendible hashing bucket size elements gamma gamma gamma delta log 
log periodic function period mean value 
proof sketch 
express average directory size terms way similar gamma gamma gamma average case analysis algorithms data structures step derivation apply saddle point method section 
omit details brevity 
maximum bucket occupancy probabilities change quickly central region case log saddle point get uniform approximation exp gamman 
bh jh gamma hj log log log log approximation longer valid terms gamma continue decrease exponentially respect substitute approximation affecting leading terms get gamma 
delta harmonic sum gamma gammax bh mellin transform gamma gamma gamma bs fundamental strip gamma gamma bi 
asymptotic expansion poles right strip 
simple pole due gamma simple poles gamma ki log due denominator 
result follows immediately 
theorem shows leading term oscillates log intuition oscillation summation 
sum samples terms gamma nonnegative integer exponential weight function value approximation changes quickly close integer value log close integer providing periodic effect 
interesting note theorem directory size asymptotically superlinear directory larger file large 
fortunately convergence slow nonlinear growth noticeable practice large say 
similar results poisson model appear 
techniques apply analysis expected height tries gamma gamma gamma weight factor 
trie height grows directory size doubles 
theorem flajolet 
expected height bernoulli model random trie elements log fl gamma log gamma 
delta log log section 
bucket algorithms hashing chaining periodic period small amplitude mean value 
biased case occurs probability occurs probability gamma gamma pz delta gamma qz gives kh gamma gammak delta cf 

multidimensional versions extendible hashing studied 
coalesced hashing 
bypass problems direct chaining relocation hashing coalescing chains simply coalesced hashing 
part hash table dedicated storing elements collide inserted 
redefine number slots hash table 
range hash function restricted mg 
call slots address region bottom gamma slots store comprise 
collision occurs insertion element hash address occupied element inserted largest numbered empty slot hash table linked chain collided 
means colliding record stored full 
empty slots element ends address region 
case elements inserted collide element chains coalesce 
size chosen accommodate coalesced hashing reduces separate chaining 
somewhat surprising average case performance improved choosing smaller size coalescing usually occurs 
intuition making address region larger hash addresses elements spread larger area helps reduce collisions 
offsets disadvantages coalescing typically occurs 
tempted go extreme eliminate completely variant called standard coalesced hashing performance deteriorates 
theorem gives expected search times function load factor ff address factor fi theorem determine optimum fi 
turns fi opt function ff type search compromise value fi gives near optimum search performance large range ff recommended general 
theorem vitter 
expected number probes search coalesced hashing slot table address size fim ffm elements gammaff fi ff fi ff fi fi ff fi gamma gamma gamma fi gamma ff fi gamma ff fi average case analysis algorithms data structures ff fi ff fi fi ff ff fi gamma gamma gamma ff fi gamma gamma fi ff fi gamma fi ff ff fi unique nonnegative solution equation gamma fi 
method described formally known late insertion coalesced hashing 
vitter chen analyze methods called early insertion coalesced hashing varied insertion coalesced hashing 
colliding element inserted immediately hash address chain rerouting pointers 
uses rule slot chain element hash address case element linked chain immediately slot chain 
requires slightly fewer probes search variants appears optimum possible linking methods 
deletion algorithms implementation issues covered vitter chen 
proof sketch 
consider unsuccessful search case 
count number probes needed perform possible unsuccessful searches possible hash tables elements 
chain length elements call chain contributes ffi gamma gamma gamma gamma delta delta delta ffi gamma probes gamma probability hash address element unoccupied number chains 
second term easily seen nm elements hash table 
evaluations term third term gamma similar brevity restrict attention 
closed form expression develop recurrence substitute get gamma jn gamma gamma number hash sequences elements yield full 
terms probabilities probability full insertions 
section 
bucket algorithms hashing chaining provides link occupancy distributions studied earlier 
define rv number elements collide inserted hash table elements 
full insertions gammam probabilities get gamma mg expresses tail probability distribution determine distribution applying theorem 
number hash sequences elements elements marked 
marking rule elements collide inserted marked bucket hash address elements gamma ffi marked elements 
theorem 
im gamma ffi 
uz gamma substituting get uz gamma allows solve gamma mg kg 
theta gamma 
gammam gamma gamma get asymptotic estimates saddle point method analysis extendible hashing chernoff bounds vitter vitter chen details omitted brevity 
distribution increases sharply central region gamma expected number collisions 
theta fi fi fi fi gamma gamma solve value satisfies combining ratios ff fi gamma ff ff fi average case analysis algorithms data structures way similar approximate step function step get gamma jn gamma gamma summed easily 
error approximation shown negligible analysis maximum bucket occupancy extendible hashing 
analysis term similar ideas omitted brevity 
case successful searches formula follows formula similar eq 
binary search trees separate chaining gamma gamma term 
unified analysis variants coalesced hashing vitter chen 
maximum number probes search searches table special case standard shown log gamma log log probability successful searches log gamma log log probability unsuccessful searches gamma gammaff 

hashing open addressing alternative chaining probe implicitly defined sequence locations looking element 
element search successful open empty slot encountered search unsuccessful new element inserted empty slot terminated search 
uniform probing 
simple scheme analyze serves approximation practical methods uniform probing 
probing sequence element random permutation hm mg 
unsuccessful search probability probes needed elements table gamma gamma gamma gamma gamma oe kp gamma delta gamma gamma gamma section 
hashing open addressing split parts gamma gamma handle separately gamma term gets absorbed binomial coefficient 
gamma delta gamma gamma gamma gamma gamma delta gamma gamma gamma gamma gamma gamma gamma delta gamma gamma gamma gamma gamma delta gamma gamma successful search time open addressing algorithms satisfy relation similar gamma putting get theorem theorem 
expected number probes unsuccessful successful search uniform probing mff elements hash table slots gamma gamma ff hm gamma hm gamman ff log gamma ff asymptotic formula gamma ff ff ff intuitive interpretation probability ff need probe probability ff need probes 
expected maximum search time hash table studied gonnet 
double hashing secondary clustering 
practical limitation uniform probing computing hash functions expensive 
performance uniform probing approximated just hash functions 
double hashing method ith probe slot ih mod gamma probe sequence starts slot steps cyclically table step size 
simplicity table slots gamma 
value second hash function relatively prime probe sequence gives full permutation 
guibas szemer edi show interesting probabilistic techniques ff number probes search asymptotically equal uniform probing extended fixed ff lueker 
faster practice hash function define implicitly terms 
example prime set ae gamma 
useful approximation variant secondary clustering model initial probe location uniquely determines remaining probe locations hm form random permutation gamma slots 
average case analysis algorithms data structures theorem knuth 
expected number probes unsuccessful successful search hashing secondary clustering mff elements hash table slots gamma ff gamma ff log gamma ff log gamma ff gamma ff proof generalization method analyze linear probing 
number probes search secondary clustering slightly double hashing uniform probing slightly linear probing 
linear probing 
simplest implementation open addressing extension called linear probing unit step size 
causes primary clustering table elements hash address follow probing sequence 
theorem knuth 
expected number probes unsuccessful successful search linear probing mff elements hash table slots gamma delta gamma gamma delta ff constant bounded away gamma ff gamma ff full tables um gamma cm proof 
derivation exact formulae exercise combinatorial manipulation 
number hash sequences slot empty gamma decomposing hash table separate parts find number hash sequences position empty positions occupied position empty gamma gamma gamma section 
hashing open addressing probability probes needed unsuccessful search formulae kn gamma terms gamma follow applications abel identity cf 
section 
ff bounded evaluate asymptotically approximating summations ff interesting case far analysis concerned full table ff 
convenient define new notation gamma link new old notation gamma note functions finite number nonzero terms 
powerful theorem provides asymptotic expansions choices fb theorem knuth 

gamma gamma delta defined implicitly equation ze proof theorem 
proof uses application lagrange inversion theorem applied 
motivation fact sums form associated implicitly defined function natural way number labeled oriented trees vertices gamma egf 
section derive abel identity abel identity derive 
applying lagrange inversion right hand side get 
gamma gamma delta 
gamma gamma um gamma 
gamma gamma um gamma 
gamma km gamma gammak gamma gamma gamma 
km gamma gamma average case analysis algorithms data structures sequences fb corresponding gamma gamma generating functions gamma gamma corresponding log gamma gammau delta gammau 
applying theorem get gamma 
gamma log gamma gamma 
gamma gamma follows method theorem count number plane trees degree constraint omega dominant singularity implicitly defined expansion gamma gamma ez gamma ez 
dominant singularity log gamma gamma delta get directly log gamma log gamma ez gamma log gamma ez approximation cm follows extracting coefficients 
formula um gamma obtained analysis right hand side directly counting number probes needed unsuccessful searches hash table empty slot 
completes proof theorem 
length maximum search table fixed ff shown theta log average 
knuth consider variation linear probing called ordered hashing cluster elements table kept order occur elements inserted increasing order element value 
elements relocated cluster necessary insertion 
average number probes unsuccessful search decreases gamma linear probing sorting way similar distribution sort described earlier elements stored linear probing hash table buckets 
elements range inserted table hash function gamma gamma elements compacted sorted insertion sort 
hash table size chosen somewhat larger say insertion times linear probing fast 
related sorting method described gonnet munro uses ordered hashing keep elements sorted order final insertion sort needed 
section 
integrated cost history model 
dynamic algorithms section study performance measures reflect dynamic performance data structure interval time operations may occur 
section consider priority queue algorithms analyze performance integrated sequence operations 
techniques apply data structures including dictionaries lists stacks symbol tables 
section analyze maximum size attained data structure time important applications resources 
conclude section probabilistic analysis union find algorithms 

integrated cost history model dynamic data structures lists search trees heap ordered trees analyzed dynamic context effect sequences operations 
knuth considers various models means deletions preserve randomness applied study various data structures example see vitter chen 
proposed model called history model amounts analyzing dynamic structures possible evolutions order isomorphism 
combinatorial interpretations continued fractions orthogonal polynomials flajolet data structures including dictionaries priority queues lists stacks symbol tables analyzed model flajolet vuillemin 
section shall overview theory special emphasis priority queues 
priority queue see section supports operations inserting element queue denote deletion minimum element denote 
example particular sequence operations dd sequence consists schema see causes queue size increase 
restrict attention structures operate comparison elements effect initially empty queue fully characterized information second operation inserts element smaller third operation inserts element falls previous ones 
define history associated sequence consist schema operation labeled rank element operates relative current state structure 
convention ranks numbered starting delete minimum operations labeled insert labeled size priority queue time insert 
history associated denote set histories containing inserts delete minimum operations subset length define jh average case analysis algorithms data structures theorem 
ogf priority queue histories continued fraction expansion gamma delta gamma delta gamma delta gamma delta delta delta delta theorem special case general theorem flajolet expresses generating functions labeled schemas terms continued fractions 
special case enumeration plane trees section 
returning priority queue histories classical theorem gauss concerning continued fraction expansion quotients hypergeometric functions applied continued fraction find theta theta theta delta delta delta theta gamma 
set histories explicit simple counting expression 
define height history maximum size priority queue attains course operations 
theory follows ogf histories height bounded integer kth convergent closely related hermite polynomials 
possible determine generating functions extended sets histories set histories hki start size size find number times operation performed priority queue structure size course histories expressions involve continued fraction 
priority queue structure compute integrated cost defined expected cost random history ci respectively cd individual expected cost insert respectively delete minimum operation priority queue structure size gamma ci delta ni cd delta nd delta ni respectively nd number times operation insert respectively delete minimum occurs size inside histories manipulations possible express final result simple form 
instance histories simple expression 

gamma section 
size dynamic data structures main theorem gfs ci cd 
ogf individual costs modified egf integrated costs normalization closely related theorem 
gfs defined satisfy gamma gamma plug ogf corresponding particular implementation priority queues extract coefficients get integrated cost implementation 
instance histories length sorted lists sl binary search trees bst sl bst log variety dynamic data structures including dictionaries lists stacks symbol tables analyzed history model techniques 
data type associated continued fraction form class orthogonal polynomials laguerre meixner chebyshev poisson charlier related transformation analogous describes transition gf individual costs corresponding gf integrated costs usually expressed integral transform 

size dynamic data structures model effect insertions deletions size dynamic data structure regarding ith element subinterval unit interval ith element born time dies time living 
time data structure store elements living time natural think data structure statistical queue far size concerned 
denote number living elements time size 
think elements horizontal intervals size just number intervals cut vertical line position applications vlsi artwork analysis example number living elements time tends square root total number elements purposes storage efficiency data structure dead elements 
hashing lazy deletion data structure assume element unique key 
data structure supports dynamic searching elements key value useful applications 
elements stored hash table buckets hash addresses keys 
typically separate chaining 
average case analysis algorithms data structures distinguishing feature element deleted soon dies lazy deletion strategy deletes dead element insertion accesses bucket 
number buckets chosen expected number elements bucket small 
time efficient doing deletion cost storing dead elements 
expected queue sizes 
define number elements data structure time size waste waste number dead elements stored data structure time consider queueing model births form poisson process lifespans intervals independently exponentially distributed 
theorem feller van wyk vitter 
stationary model size gamma identically poisson distributed mean birth rate intervals average lifetime element 
proof 
define notation waste ng 
model deltat gamma gamma deltat gamma deltat deltat delta gamma gamma deltat gamma gamma deltat gamma deltat deltat delta gamma ffi gamma deltat deltat delta gamma deltat expanding exponential terms rearranging letting deltat get gamma gamma gamma ffi gamma stationary model probabilities independent lefthand side 
notational simplicity shall drop dependence rest derivation proceeds considering multidimensional ogf equation gamma gammap zp provides distribution size mg gamma 
find distribution replace causes left hand side 
get kg zp rest follows 
section 
size dynamic data structures maximum queue size 
interesting statistic direct application matters storage preallocation maximum values size time varies entire unit interval 
orthogonal polynomials arise interesting way considering general model stationary birth death process markov process transitions level allowed levels gamma 
infinitesimal birth death rates level denoted deltat size kg deltat deltat deltat deltat gamma deltat 
special case model delta delta delta model delta delta delta delta delta delta theorem mathieu vitter 
distribution max fsize expressed simply terms chebyshev polynomials process polynomials process 
types linear birth death processes form ffk fi flk ffi expressed terms laguerre polynomials meixner polynomials second kind 
interesting note orthogonal polynomials arose similar way section 
formulae referred theorem calculate distributions max fsize numerically yield asymptotics directly 
rely different approach theorem mathieu vitter 
stationary probabilistic model assuming omega phi max fsize psi ln ln constant defined implicitly constant ln gamma gamma 
case ln phi max fuse psi ln theorem says expected maximum value size respectively asymptotically equal maximum expected value 
example vlsi artwork applications average number living elements time theorem expected maximum data structure size asymptotically 
mathieu average case analysis algorithms data structures vitter study expected maximum history models section probabilistic models 
accident theorem structurally similar theorem maximum bucket occupancy 
quantity max fsize regarded continuous counterpart maximum bucket occupancy 
proof relation 
proof sketch 
brevity consider analysis phi max fsize psi shall concentrate primarily case ln 
lower bound follows immediately theorem phi max fsize psi get desired upper bound looking discretized version problem consider hash table slots integer slowly 
jth slot represents time interval gamma gamma element place entry slot associated time interval intersects element lifetime 
define number elements slot get upper bound max fsize max jg fn slot occupancies poisson distributed mean 
independent analysis maximum bucket occupancy theorem apply case 
main point proof showing lack independence significantly alter expected maximum phi max jg fn psi gives desired upper bound completes proof case 
formula phi max fuse psi derived way 
approach applied cases theorem gives upper bounds phi max fsize psi factor 
get asymptotic bounds different techniques involving probabilistic arguments distribution max fsize peaked central region mean 
technique similar spirit section analyses extendible hashing maximum bucket occupancy coalesced hashing 
probabilistic analysis maximum size successfully carried variety combinatorial data structures dictionaries linear lists priority queues symbol tables history model discussed section 
section 
set union find algorithms 
set union find algorithms set union find data type useful computer applications computing minimum spanning trees testing equivalence finite state machines performing unification logic programming theorem proving handling common blocks fortran compilers 
operation union merges equivalence classes simply components containing chooses unique representative element combined component 
operation find returns representative component set creates singleton component fxg representative union find algorithms studied extensively terms worst case amortized performance 
tarjan van leeuwen give matching upper lower amortized bounds theta gamma mff delta problem number makeset operations number finds ff denotes functional inverse ackermann function 
lower bound holds separable pointer machine model upper bound achieved known tree data structure weighted merges path compression 
extensive discussion appears mehlhorn 
section study average case running time simple minded algorithms called quick find qf quick find weighted 
data structure consists array called rep slot element rep representative element find done constant time 
addition elements component linked list 
qf algorithm union implemented setting rep rep component 
algorithm component smaller take quicker route set rep rep component 
auxiliary array keep track size component 
finds take constant time shall confine attention union operations 
consider gamma unions performed set elements single component size performance measure denote qf total number updates slots rep unions 
consider models random input 
random graph model 
probably realistic model proposed yao random graph model erdos enyi 
gamma delta undirected edges vertices fires independently governed poisson process 
order firings equally 
edge fx yg fires execute union different components 
theorem knuth bollob simon 
average number updates done qf random graph model qf gamma log delta cn log shall restrict showing qf derivation knuth 
techniques bollob simon average case analysis algorithms data structures needed determine coefficient get better bounds second order terms 
addition bollob simon consider sequences fewer unions 
show average qf performs gamma ffl unions log time unions time proof sketch 
proof intuition erdos renyi probability gamma log random graph vertices log cn edges constant consists giant connected component size gamma log log set isolated vertices 
graph connected probability gammae gammac terms union operations unions joined giant component singleton components cost union qf 
proof theorem consists showing behavior extends entire sequence unions 
find recurrences asymptotic approximations expected number times component size merged size minfk km portion sum applies bound 
rest range sum bounded element merged component size size analysis qf similar 
combinatorial algorithms designed analyzed random graph model 
example babai erdos selkow give algorithm testing graph isomorphism runs average time known algorithms require exponential time worst case 
random spanning tree model 
sequence union operations corresponds union tree directed edge hx yi means component representative merged component representative random spanning tree model possible union trees equally gamma possible unoriented trees gamma 
firing orders edges tree 
theorem yao knuth 
average number updates done qf random spanning tree model qf log log acknowledgment proof sketch 
admissibility argument similar section allows compute probability union merge components sizes gamma gamma gamma gamma gammak gamma easy show kp qf minfk gamma 
symmetry kp arguments similar theorem show minfk gamma 
recurrence special linear form allows solve repertoire solution sum solutions find basis different solved easily solve qf linear combinations basis functions 
turns basis case set functions gamma studied connection linear probing section 
random components model 
simplest model realistic assume time pair existing components equally merged 
union tree framework random binary search tree studied extensively section 
admissibility arguments lead directly result theorem doyle rivest 
average number updates done qf random components model qf gamma log nh gamma nh bn gamma dn log acknowledgment don knuth helpful comments suggestions 
average case analysis algorithms data structures aggarwal vitter 
input output complexity sorting related problems communications acm september 
knuth 
ordered hash tables computer journal may 
ajtai koml os szemer edi 
log sorting network proceedings th annual symposium theory computer science boston may 
babai erd os selkow 
random graph isomorphisms siam journal computing 

sorting networks applications proceedings afips spring joint computer conference 
bender 
central local limit theorems applied asymptotic enumeration journal combinatorial theory series 
bender 
asymptotic methods enumeration siam review 
bender 
advanced mathematical methods scientists engineers 
mcgraw hill 
berstel boasson 
context free languages handbook 
billingsley 
probability measure academic press 
bollob 
random graphs academic press new york 
bollob simon 
expected behavior disjoint set union algorithms proceedings th annual symposium theory computing providence may 
brown 
partial analysis random height balanced trees siam journal computing february 
burge 
analysis tree sorting method properties set trees proceedings st usa japan computer conference 

central local limit theorems coefficients binomial type journal combinatorial theory series 
chomsky sch 
algebraic theory contextfree languages computer programming formal languages edited hirschberg north holland 
clark 
measurements dynamic list structure lisp ieee transactions software engineering se january 

calcul des coefficients de taylor une fonction alg math ematique 

advanced combinatorics 
reidel dordrecht 
cypher 
lower bound size shellsort sorting networks proceedings st annual acm symposium parallel algorithms architectures santa fe nm june 
de bruijn 
asymptotic methods analysis 
dover new york 
de bruijn knuth rice 
average height planted plane trees graph theory computing edited 
read academic press new york 
devroye 
note height binary search trees journal acm 
devroye 
lecture notes bucket algorithms birkhauser boston 

der laplace transformation 
volumes 
birkhauser verlag basel 
doyle rivest 
linear expected time simple union find algorithm information processing letters 

quicksort stack proceedings th annual symposium mathematical foundations computer science lecture notes computer science 
erd os enyi 
evolution random graphs publ 
math 
institute hungarian academy sciences 
fagin nievergelt pippenger strong 
extendible hashing fast access method dynamic files acm transactions database systems september 
feller 
probability theory applications volume wiley new york third edition 
feller 
probability theory applications volume wiley new york second edition 
ph 
flajolet 
combinatorial aspects continued fractions discrete mathematics 
ph 
flajolet 
analyse algorithmes de manipulation de cahiers du buro 
ph 
flajolet 
performance evaluation extendible hashing trie searching acta informatica 
ph 
flajolet 
analytic models ambiguity context free languages theoretical computer science 
ph 
flajolet 
mathematical methods analysis algorithms data structures trends theoretical computer science edited borger computer science press 
ph 
flajolet vuillemin 
sequence operations analysis dynamic data structures journal algorithms 
ph 
flajolet gonnet puech robson 
analytic variations quad trees draft 
average case analysis algorithms data structures ph 
flajolet odlyzko 
average height binary trees simple trees computer system sciences 
ph 
flajolet odlyzko 
singularity analysis generating functions siam journal discrete mathematics 
ph 
flajolet puech partial match retrieval multidimensional data journal acm april 

ph 
flajolet 
vuillemin 
number registers required evaluate arithmetic expressions theoretical computer science 
ph 
flajolet sedgewick 
uses mellin integral transform analysis algorithms combinatorics words springer nato asi series volume berlin 
ph 
flajolet 
algebraic methods trie statistics annals discrete mathematics 
ph 
flajolet sedgewick 
digital search trees revisited siam journal computing august 
ph 
flajolet 
steyaert 
analytic variations common subexpression problem proceedings th annual international colloquium automata languages programming icalp warwick england july 
published lecture notes computer science springer verlag berlin 
ph 
flajolet 
steyaert 
complexity calculus recursive tree algorithms mathematical systems theory 

la erie en dans les probl emes enum eration series montreal university press 

de rairo inform 
theor 

viennot vuillemin 
description analysis efficient priority queue representation proceedings th annual symposium foundations computer science ann arbor october 
gonnet 
expected length longest probe sequence hash code searching journal acm april 
gonnet handbook algorithms data structures 
addison wesley reading 
gonnet munro 
linear probing sort analysis proceedings th annual symposium theory computing milwaukee wi may 
gonnet rogers george 
algorithmic complexity analysis interpolation search acta informatica january 
jackson 
combinatorial enumerations 
wiley new york 
greene 
labelled formal languages uses stanford university technical report stan cs 
greene knuth 
mathematics analysis algorithms 
birkhauser boston second edition 
guibas szemer edi 
analysis double hashing journal computer system sciences april 
harris 
asymptotic expansions coefficients analytic functions illinois math 


generalization stirling formula reine und angewandte mathematik 

applied computational complex analysis 
volume 
wiley new york 

applied computational complex analysis 
volume 
wiley new york 

huang knuth 
way quicksort algorithm bit 
hunt 
bachelor thesis princeton university april 
sedgewick 
improved upper bounds shellsort journal computer system sciences 
ph 
jacquet 
trie partitioning process limiting distributions proceedings caap lecture notes computer science 
ph 
jacquet 
normal limiting distribution size tries performance proceedings th international symposium computer performance brussels december 
kemp 
average number registers needed evaluate binary tree optimally acta informatica 
kemp 
fundamentals average case analysis particular algorithms 
teubner wiley stuttgart 
mathieu vitter 
general methods analysis maximum size data structures proceedings th annual international colloquium automata languages programming icalp italy july 
published lecture notes computer science springer verlag berlin 

results digital search trees proceedings th annual international colloquium automata languages programming icalp rennes france july 
published lecture notes computer science volume springer verlag berlin 

applications formulae ramanujan analysis algorithms preprint 
knuth 
average time carry propagation mathematicae 
knuth 
art computer programming 
volume fundamental algorithms 
addison wesley reading ma second edition 
average case analysis algorithms data structures knuth 
art computer programming 
volume sorting searching 
addison wesley reading ma 
knuth 
deletions preserve randomness ieee transactions software engineering se 
knuth 
art computer programming 
volume semi numerical algorithms 
addison wesley reading ma second edition 
knuth sch 
expected linearity simple equivalence algorithm theoretical computer science 

random allocations 
winston sons washington 
newman 
note growing binary trees discrete mathematics 

larson 
dynamic hashing bit 
lindstrom vitter 
design analysis bubble memory secondary storage ieee transactions computers march 

brownian motion neglected tool complexity analysis sorted table manipulation rairo theoretical informatics 
lueker 
analysis double hashing proceedings th annual symposium theory computing chicago il may 
mathieu vitter 
maximum queue size hashing lazy deletion proceedings th annual symposium interface computing science statistics reston va april 
mehlhorn 
data structures handbook 
meir moon 
altitude nodes random trees canadian journal mathematics 
nodine vitter 
greed sort optimal sorting multiple disks technical report cs brown university february 
odlyzko 
periodic oscillations coefficients power series satisfy functional equations advances math 

odlyzko richmond 
asymptotic expansions coefficients analytic generating functions mathematicae 
olver 
asymptotics special functions academic press 
pippenger 
communication networks handbook 

paths random digital tree limiting distributions advances applied probability 

linear probing probable largest search time grows logarithmically number records journal algorithms june 

probabilistic analysis coalesced hashing algorithm annals probability july 

fur und acta mathematics 
translated read combinatorial enumeration groups graphs chemical compounds springer verlag new york 
purdom brown 
analysis algorithms 
holt rinehart winston new york 

average height trees digital search dynamic hashing information processing letters 

analysis grid file algorithms bit 

nauka moscow 
sedgewick 
quicksort equal keys siam journal computing june 
sedgewick 
analysis quicksort programs acta informatica 
sedgewick 
data movement odd merging siam journal computing august 
sedgewick 
mathematical analysis combinatorial algorithms probability theory computer science edited academic press london 
sedgewick 
algorithms 
addison wesley reading second edition 
shell 
high speed sorting procedure communications acm july 

steyaert ph 
flajolet 
patterns pattern matching trees analysis information control 
tarjan van leeuwen 
worst case analysis set union algorithms journal acm april 

theory functions oxford university press london second edition 
van wyk vitter 
complexity hashing lazy deletion algorithmica march 
vitter 
analysis search performance coalesced hashing journal acm april 
vitter 
chen 
design analysis coalesced hashing 
oxford university press new york 
vitter shriver 
optimal parallel block transfer proceedings nd annual symposium theory computing baltimore md may 
vuillemin 
unifying look data structures communications acm april 
average case analysis algorithms data structures weiss sedgewick 
tight lower bounds shellsort technical report cs tr princeton university february 

yao 
average behavior set merging algorithms proceedings th annual acm symposium theory computing 

yao 
random trees acta informatica 

yao 
analysis shellsort journal algorithms 

yao 
straight selection sort technical report cs tr princeton university october 

yao yao 
complexity searching ordered random table proceedings th annual symposium foundations computer science houston october 
yao 
computational geometry handbook 
page index glossary index term followed list sections relevant term 
large number sections relevant sections included typically term defined 
admissible constructions 
analysis algorithms 
asymptotics 
average case 
dynamic 
enumerations 
hashing 
sorting 
searching 
trees 
analytic function 
asymptotic analysis 
average case complexity 
binary trees 
binary search trees 
bubble sort 
bucket algorithms 
characteristic functions 
coalesced hashing 
combinatorial enumerations 
complex analysis 
complexity measure 
continued fractions 
counting 
method 
data model 
data structures 
digital search 
direct chaining 
distribution sort 
double hashing 
dynamic data model 
enumerations 
extendible hashing 
euler maclaurin summation formula 
fourier transforms 
functional equations 
generating function gf 
exponential generating function egf 
ordinary generating function ogf 
hash function 
hashing 
coalesced hashing 
extendible hashing 
hashing lazy deletion 
direct chaining 
double hashing 
linear probing 
maximum bucket occupancy 
open addressing 
separate chaining 
heaps 
heapsort 
history model 
insertion sort 
integrated cost 
interpolation search 
index glossary inversions 
trees 
labeled combinatorial structures 
lagrange inversion 
laplace method 
laplace transforms 
limit distribution 
linear probing 
load factor 
maximum bucket occupancy 
maximum size data structures 
mellin transforms 
merge sort 
functions 
moment generating functions 
multidimensional search 
networks 
occupancy distribution 
open addressing 
path length 
patricia tries 
pattern matching 
permutations 
priority queues 
probabilistic analysis 
quad trees 
quicksort 
radix exchange sort 
register allocation 
saddle point method 
searching 
search trees 
selection sort 
separate chaining 
set union find 
shellsort 
singularity 
sorting 
bubble sort 
distribution sort 
heapsort 
insertion sort 
merge sort 
networks 
quicksort 
radix exchange sort 
selection sort 
shellsort 
stirling numbers 
stirling formula 
symbolic differentiation 
theorems 
taylor expansion 
transfer lemma 
trees 
tree compaction 
tries 
urn model 
valuation function vf 
