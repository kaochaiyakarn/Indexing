complexity higher order matching tomasz university aw june standard encoding boolean values simply typed lambda calculus develop method translating sat problems various logics higher order matching 
obtain way known np hardness bounds order new result fourth order matching nexptime hard 
consider normalized simply typed lambda terms closed contain free variables 
higher order matching problem known pattern matching range problem instantiation problem decide exists substitution free variables reducible matching special case unification restriction closed removed solution substitution equal modulo conversion 
order problem highest functionality order free variables occurring time writing decidability higher order matching unbounded order open question years problem explicitly stated time conjectured decidable difficult 
interest investigate problem order bounded constant 
higher order matching studied lewis baxter gerard huet phd theses 
baxter showed second order matching np complete reduction sat problem 
time case independently investigated huet 
huet devised semi decision algorithm undecidable second order case unification problem 
analysis behavior termination running time algorithm modifications source couple results decidability complexity special cases matching 
gilles dowek proved decidability third order matching suggested control huet algorithm obtain doubly exponential decision procedure 
time david wolfram gave proof np hardness third order pure constants matching 
surprisingly turned exact bound hubert comon yan designed np algorithm problem 
showed proof np hardness second order case binary constant reduction sat problem 
proc 
th int conf 
automated deduction cade trento italy july harald ganzinger ed lecture notes artificial intelligence springer verlag berlin 
supported 
term pattern multiple meanings theory higher order unification introduced dale miller avoid speaking unification arbitrary term closed ground 
tomasz complexity higher order matching order decidable 
lower bound upper bound nlogspace np complete np complete nexptime hard nexptime 
elementary recursive table decidability complexity higher order matching algorithm fourth order case case shown decidable year padovani suggested may probably improved run nexptime formally proved 
show case nexptime hard 
seventies higher order matching name range problem investigated richard statman reduced decidability decidability lambda definability 
decidability higher order matching called delta functions equivalent decidability lambda definability 
unfortunately ralf loader gave negative answer question 
matching delta functions undecidable 
extensions matching known undecidable matching odel system girard system 
statman author theorem stating deciding equality simply typed lambda terms elementary recursive 
result immediately prove lower bound higher order matching noted sergei 
mentioned facts summarized table 
statman showed th order unification problem containing constants order greater may transformed order max empty signature 
general constants alter complexity matching 
second order case lower bound proved assumption binary second order constant 
removing constant statman construction results pure problem third order 
proof may obvious way changed apply pure language 
lower bounds shown table apply pure languages constants upper bounds hold arbitrary signatures 
show second third order matching np complete third order case somewhat harder sense second order matching ptime number unknowns bounded constant third order case np hard unknown variable 
self contained 
section recall needed definitions basic facts simply typed lambda calculus higher order unification 
section contains detailed description method coding sat problems various logics higher order matching 
section contains proof main result proof nexptime hardness fourth order matching 
definitions basic facts types built base type type types small greek letters 
stand arbitrary types 
drop parentheses assume tomasz complexity higher order matching associates right means 
order type defined follows order order max order order type infinite set term variables type 
arbitrary elements denoted 
assume disjoint different types 
variables considers pairwise disjoint disjoint sets variables possibly empty sets constants type 
union types called signature 
formation rules lambda terms terms short variable term type 
similarly constant term type 
term type term type mn term type 
term type term type 
letters 
denote arbitrary lambda terms 
better readability save space drop type superscript bound occurrence term variable parentheses rule 

mm shorter 
mm stands 


mm 
notation stands term 
times type times write 
base type 
nn mn 
nn notation usually connected called long form 
assume lambda terms long form define notion 
notions free denoted fv bound variables term type preserving simultaneous substitution denoted 

mn shortly conversion reduction equality denoted normal form term denoted nf defined usual see 
term closed contain free variables 
notion order extended lambda terms order term highest order types subterms 
particular order variable order type 
note lambda terms may types exponential size comparing size type erased terms formulation term variables explicitly decorated types 
special care needed order avoid exponential blow term size 
elegant way doing representing types directed acyclic graphs trees types polynomial size type erased lambda terms 
order types bounded constant tree size types polynomial 
unification problem pair terms type normal form possibly containing free variables written solution problem substitution 
order problem highest order free variables occurring speaking equation equivalently speak collection equations solvable exactly single equation 

unification problem empty signature called pure problem 
matching problem unification problem term closed 
second order unification presence binary symbol undecidable 
contrary matching known decidable order conjectured decidable unrestricted order 
tomasz complexity higher order matching cardinality type notation card number normal inhabitants number closed terms normal form type 
type inhabited exists closed term type card 
fact statman consider lambda terms empty signature constants 
type 

order card 
order card 
order card card 
type inhabited inhabited inhabited 
cardinality type may calculated 
order absence constants closed terms functions order greater card 
see part note exactly different modulo conversion closed terms type form 

providing constants language 
consider normal form term type starts binder 
contains body type abstraction 
consider head body 
variables binder constants term closed 
variable base type function applied constitute body term 
term form 
type prove part sufficient show inhabited type order possesses see pair terms type type terms equal 
choose term normal form type 
exists assumed inhabited 
type may uniquely written form order exists function type 
term 
base type prefixing appropriate lambda binder may build terms type closed containing free occurrences variables 
particular types 
term 



forms 
example type term 
choosing term type say may generate terms type incidentally happen inhabitants 
note way able list infinite number normal inhabitants type 
little care list way example inhabitants type 
huet procedure higher order unification fact systematic way listing normal inhabitants types unknown variables checking solutions unification problem 
part fact may easily proved induction structure type 
fact implies decidability pure second order unification 
nave np algorithm second order unification problem guess solution check reducing sides normal forms may computed polynomial time 
see term normal form containing free variable opposed curry style implicitly typed lambda calculus calculus infinite number base types problem pspace complete 
tomasz complexity higher order matching term normal form type normal form computed polynomial time 
may contain subterms form 
terms 
type substituting leads redex 
providing starts abstraction contracting create new redexes arguments 
type functions applied 
note number variables occurring problem bounded constant problem soluble ptime list possible solutions check deterministically 
corollary second order pure unification particular matching np 
second order pure unification particular matching bounded number variables ptime 
section show corresponding lower bounds problems 
second order pure matching problems finite number different solutions finite number different terms second order type solutions may unique terms type 
solutions 
substitutions 

unrelated order unification general unifiers notion complete set general unifiers may defined higher order cases sets may infinite 
fact suggests third higher order matching problems may infinite number unrelated solutions type order greater inhabited possesses infinitely normal inhabitants 
example substitution solution sides instance matching problem normal form may suggest computational complexity reduction process show solving problem 
redexes may stay latent searching solutions begins 
turns matching hard testing equality simply typed lambda terms known non elementary theorem statman simply typed closed lambda terms second normal form 
elementary recursive decide normal form theorem immediately implies corollary higher order pure matching elementary recursive 
terms matching problem normal form need just hide redexes 
terms second normal form 
fresh variables suspend resembles suspension operator eager programming languages simulate lazy evaluation range pairs types exists subterm 
transform hiding redexes follows redexes may hidden similar way tomasz complexity higher order matching set equations term may generated time polynomial size clearly formed instance higher order matching unbounded order order may arbitrarily large solution exactly normal form fact st order matching hard testing equality simply typed lambda terms order roughly technique coding sat problems section write lambda terms testing equality hard hide redexes way described 
hard find computational power inherent matching essentially reduc tion 
easy see able achieve nondeterministic lower bounds leaving objects guessed substituted free variables 
hand trick help simply reduce order unknown variables 
coding sat problems higher order matching section develop method coding sat problems various logics higher order matching 
propositional formulas expressions built infinite set propositional variables 
unary negation symbol binary connectives 
quantification propositional variables allowed expressions called quantified boolean formulas 
satisfiability problem sat short propositional formulas np complete quantified boolean formulas pspace complete :10.1.1.32.420
usually boolean values logical connectives encoded lambda calculus way true false abbreviations defined build instance third order matching problem solution substitutes corresponding right hand sides free variables definition solution closed substitute term normal form unique solution 
variables define parts constructed matching problem 
note ready known fact third order pure matching np hard 
tomasz complexity higher order matching code sat problem propositional formulas transform formula way propositional variable choose fresh term variable define transformation follows clearly propositional formula third order matching problem true constructed time polynomial size solution exactly satisfiable 
note variables play essential ole coding second order variables type encode boolean values 
third order variables auxiliary 
take variable closed terms normal form type true false 
solution true 
similarly solution false 
variables equation solutions substituting different values type equation forces negation vice versa 
similar way able encode boolean functions 
take propositional formula 
propositional variable choose fresh term variable compound single variable subformula choose fresh term variable define lambda terms way observe substitution solution true true true 
similarly boolean connectives 
second order matching problem true subformula variable true soluble exactly formula satisfiable 
equation restricts set substitutions making formula true 
implicit fact second order pure matching np hard 
irrelevant identical subformulas assigned term variable 
may depend way formula represented tree directed acyclic graph 
essential ensure occurrences propositional variable associated term variable tomasz complexity higher order matching recall second order pure matching bounded number variables ptime 
contrary third order case np hard variable 

set free variables occurring previous coding 
choose fresh third order variable substitute 
variable previous coding 
resulting third order problem contains variable soluble exactly previous see solution previous system 
nf uv 
uv satisfies transformed nf normal form conversely substitution satisfying transformed problem nf 
satisfies original system 
reduction church rosser 
fact third order pure matching variable np hard 
interesting note trick applies undecidability proof third order unification problem 
statman recalls third order pure unification variables type undecidable encoding th hilbert problem variables known problem variables decidable 
know answer question easy see third order unification problem variable type undecidable 
get back coding described section 
easily extended quantified boolean formulas price raising order 
formula means true false means true false define qb true false true false variables fourth order 
extend translation follows evident fourth order matching problem qb true solution exactly quantified boolean formula satisfiable 
exciting fact fourth order pure matching pspace hard 
note construction fact may unknowns left guessed part solution matching problem 
complexity problems constructed caused just complexity finding normal form lambda term 
see take quantified boolean formula 
closed write appropriate number existential quantifiers bind free propositional variables occurring 
translation previous construction 
lambda term third order contains free variables lambda term tomasz complexity higher order matching terms construction true false true false fifth order reduces true false validity formula 
fact testing equality simply typed lambda terms order greater pspace hard 
essentially proposition page 
explains impression kind cheating pspace hardness bound matching showing hardness matching focused complexity reduction 
section refine previous translation order nontrivial unknown variables matching problem going code sch bernays formulas test satisfiability finite domain 
fourth order matching nexptime hard infinite set individual variables 
collection constants 
predicate letters 
fixed arity 
atomic formula form 
constants variables ary predicate letter 
predicate formulas built atomic formulas negation symbol binary connectives quantification individual variables 
adds function symbols allowing building complicated atomic formulas equality symbol 
sat problem predicate calculus undecidable general case special cases decidable 
formula called sch bernays formula denoted form 

prenex form existential quantifiers precede universal quantifiers formula built constants predicate letters function symbols equality 
problem deciding formula model decidable nexptime complete 
key idea showing decidability case follows lemma bernays sch bernays formula satisfiable model exactly elements length formula 
fact formula unsatisfiable model cardinality number existential quantifiers occurring 
need size model easily calculable formula 
absence equality formula models greater cardinality particular cardinality increase size model pick arbitrary element model replace number copies presence equality impossible sentence models contains exactly elements expressible 
way fixing size model relativization 
details see 
abbreviates type inhabited elements 
assumed represent numbers 
known encoding predicate 
definable lambda term example binary predicate choose fresh term variables tomasz complexity higher order matching 
define 



predicate simply 
lambda term applied values works follows substituted th selector picks th row substituted picks th element row happens exactly defined depending reduces true true false 
particular equality predicate definable encoding enrich sch bernays formulas equality known alter complexity sat problem lemma longer valid 
coding may extended arbitrary ary predicates 
note length encoding 
may define quantification elements way qd 



variables fourth order 
note right hand sides normal form size qd 
choosing element set possible model sch bernays formula length may define translation individual variable choose fresh term variable constant choose fresh term variable ary predicate letter choose fresh variable define 

note may code way full order predicate calculus function symbols equality 
irrelevant main problem size model able build checking satisfiability expressive power language 
sch bernays formula 
clearly fourth order matching problem qd true may constructed time polynomial size solution satisfiable lemma model cardinality code model elements lambda calculus way described key point predicate definable 
hand solution solution immediately model key point direction lambda term type 

sat problem nexptime hard proved tomasz complexity higher order matching fact fourth order pure matching nexptime hard 
final remarks status higher order matching known order 
fifth order case known decidable partial results obtained 
huet conjecture stating decidability matching general case true importance practical applications complexity higher order cases grows quickly practical point view problems nexptime hard difficult undecidable ones 
suggest higher order matching tractable huet procedure shown useful say theorem provers unification general undecidable 
turns undecidability obstacle solving problems practice 
result implies hope find fast sound time complete algorithm higher order matching 
acknowledgments anonymous referees critical comments oskar mis long interesting discussions 
henk barendregt lambda calculi types handbook logic comput 
sci vol 
abramsky gabbay maibaum eds clarendon press oxford 
lewis baxter complexity unification ph thesis university waterloo 
paul bernays moses sch zum entscheidungsproblem der mathematischen logik math 
annalen 
egon erich gradel yuri gurevich classical decision problem springer verlag 
hubert comon yan higher order pattern matching tree automata proc 
th int workshop comput 
sci 
logic csl aarhus denmark august nielsen thomas eds lncs springer verlag 
gilles dowek third order matching decidable proc 
th ieee symp 
logic comput 
sci lics santa cruz california june annals pure applied logic 
gilles dowek undecidability pattern matching calculi primitive recursive functionals representable theoret 
comput 
sci 
referees suggested common agreement reasons complexity theory diverges practice statement sufficiently justified 
stress personal opinion follows experience problem theoretically proved hard time efficiently solvable practice ml type system 
ml typability decision problem type reconstruction task explicitly writing type program dexptime hard practice type reconstruction turns solvable nearly linear time real life programs consist syntax tree nodes type reconstruction invoked procedure running time impractical 
types real life programs short meaningful programmer practical experiments show fact trivial average size matter large program theory allows types dag size ml compiler fails compile line artificial program type exponential dag size 
probably status matching analogous meaningful theorems proofs short understood humans practical applications theorem provers complexity matching unification exploited 
tomasz complexity higher order matching cynthia dwork paris kanellakis john mitchell sequential nature unification logic programming 
warren goldfarb note undecidability second order unification problem theoret 
comput 
sci 

gerard huet unification algorithm typed calculus theoret 
comput 
sci 
gerard huet resolution equations dans des langages ordre 
de doctorat etat university paris 
gerard huet bernard lang proving applying program transformations expressed second order patterns acta informatica 
ralph loader undecidability definability church memorial volume anderson eds kluwer acad 
press appear 
harry mairson simple proof theorem statman theoret 
comput 
sci 
dale miller logic programming language lambda abstraction function variables simple unification logic comput 
vincent padovani ordre phd thesis universite paris vii 
christos papadimitriou computational complexity addison wesley :10.1.1.32.420
john alan robinson machine oriented logic resolution principle acm 
schubert linear interpolation higher order matching problem technical report institute informatics warsaw university tr proc 
th int joint conf 
theory practice software development tapsoft lille france april bidoit dauchet eds lncs springer verlag 
richard statman intuitionistic propositional logic polynomial space complete theoret 
comput 
sci 
richard statman typed calculus elementary recursive theoret 
comput 
sci 
richard statman completeness invariance definability symbolic logic 
richard statman existence closed terms typed calculus ii transformations unification problems theoret 
comput 
sci 
sergei hardest natural decidable theory proc 
th annual ieee symp 
logic comput 
sci lics warsaw poland june july 
david wolfram decidability higher order matching proc 
th int workshop unification dagstuhl germany july 
david wolfram clausal theory types cambridge tracts theor 
comput 
sci 
vol 
cambridge university press 

