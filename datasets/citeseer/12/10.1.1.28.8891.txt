universal dynamic synchronous self stabilization paolo boldi sebastiano vigna dipartimento di scienze dell informazione universit di milano italy contents guiding example basic definitions preliminaries graph theoretical definitions 
model 
behaviours predicates classes networks 
self stabilizing view construction anonymous networks views 
making view construction self stabilizing protocol 
infinite state protocol 
graph theoretical characterizations attainable behaviours graph fibrations lifting lemma 
minimum bases 
deducing minimum base view 
characterization theorem 
lower bound 
finite state universal self stabilization self stabilizing clocks 
finite state characterization theorem 
case unique identifiers examples part results appeared proceedings rd workshop self stabilizing systems santa barbara california 
contact author 
dipartimento di scienze dell informazione universit degli studi di milano milano mi italy 
email vigna dsi unimi 
tel 
prove existence universal synchronous self stabilizing protocol protocol allows distributed system stabilize desired behaviour long protocol stabilizing behaviour exists 
previous proposals required drastic increases asymmetry knowledge protocol additional knowledge require symmetry breaking conditions available stabilizing respect dynamic changes topology 
prove optimal quiescence time synchronous network processors diameter protocol finite state negligible loss quiescence time 
optimal protocol case unique identifiers 
consequence provide effective proof technique allows show self stabilization certain behaviour possible wide range models 
keywords self stabilization anonymous networks graph fibrations synchronous systems 
system self stabilizing initial state finite number steps deviate specified behaviour 
self stabilization distributed systems introduced dijkstra celebrated important framework study fault tolerant computations 
adversarial choice initial state extremely difficult devise self stabilizing protocols 
overcome problem attempts literature build general self stabilizing protocols called extensions superimposed distributed protocols underlying behaviour self stabilizing solve classical problems election spanning tree construction self stabilizing way 
instance katz perry propose combination self stabilizing global snapshots resets purpose afek kutten yung awerbuch patt shamir varghese local conditions initiate global local correction respectively dolev israeli moran randomization assign unique identifiers 
previously mentioned methods require additional asymmetry knowledge self stabilizing extension requires distinct processor knowledge number processors network may available 
protocol described needs unique identifiers power randomization requires ability distinguish incident links 
major open problem theoretical importance establish prove impossible existence universal deterministic self stabilizing protocol universal mean protocol able self stabilize behaviour self stabilizing protocol exists conditions asymmetry knowledge 
particular protocol uniform processors presence possibly unique identifiers explicitly assumed 
prove surprising apparently unnatural result viz protocol exists synchronous dynamic networks tight quiescence time number processors system diameter 
possible modify protocol finite state negligible loss quiescence time 
widely accepted tenet self stabilization difficult coordination problem independently resources available 
show contrary strong bounds imposed resources quiescence time coordination part problem trivial synchronous case sense completely solved universal protocol 
model general network just directed graph possibly parallel arcs loops coloured nodes arcs 
colouring encode identity information represents degree port awareness network ability processor distinguish incident links 
results assumption particular class networks study particular assume bidirectionality major difference existing literature processor communicate immediately neighbours particular distribution identifiers unique identifiers unique distinguished processor 
hand synchronous activation model processors take step time 
step new state processor depend arbitrarily states neighbours bound amount information exchanged links 
protocols tolerate dynamic changes network structure time adversary change topology network corrupt identifiers processors long resulting network fits knowledge assumed characteristic particular far know achieved protocol 
quiescence time desired behaviour restart 
prove results exploit mix classical techniques self stabilization series results theory anonymous networks 
network anonymous processors identical start initial state assumptions indistinguishable 
systematic study networks initiated angluin continued yamashita kameda complete characterization computable networks problems election function computation 
fact characterizations processors identifiers long initial states observation key proofs 
clearly link anonymous networks self stabilizing systems possible choices adversary start processors state 
sense precise way network self stabilize compute anonymously 
obtain results turning classical algorithms theory anonymous networks self stabilizing protocols 
dynamic mean protocols tolerate modifications network topology insertion deletion processors links 
terms uniform anonymous synonyms literature 
propose processors identically programmed said identifiers addition processors forced start state think important tell potential actual indistinguishability 
behaviours consider modeled suffix closed set infinite sequences excerpts global states set depends network problems topology reconstruction specified 
definitions self stabilization adopted requires finite time behaviour network belongs selected set 
results mainly theoretical interest large amount information exchanged processors 
provide time general upper lower bounds self stabilization 
obtain characterization behaviours self stabilization possible 
result provide proof technique allows show self stabilization certain behaviour possible wide range models 
proof technique effective class networks examination finite desired behaviour finite state technique turns recursive procedure provides self stabilizing protocol behaviour counterexample 
section discuss informally simple possibility problem solution guide development 
section define basics model computation 
section discuss briefly known notions theory anonymous networks particular view show view construction 
side section provide corresponding negative results stating graph theoretic terms necessary conditions self stabilization conditions turn match positive results self stabilizing view construction giving characterization attainable behaviours solving guiding problem 
section details proof self stabilizing view construction protocol finite state losing generality providing characterization time finitestate attainable behaviours 
section approach special extremely relevant case networks unique identifiers showing fundamental gap general case bounds case tight depend diameter number processors 
conclude section examples show theory allows characterize exactly knowledge necessary perform certain task describe informally protocols obtained specializing universal ones 
guiding example suppose interested determining exist self stabilizing leader election protocol works class networks depicted 
words produce synchronous uniform protocol program processors self stabilizes election global state protocol network class informally speaking processors just know live networks depicted know exactly position network 
questions kind considered literature specific problems specific models specific network classes classic result says instance serialized activation election possible rings prime size 
stated main goal factor common part results give completely general certain disagreement literature exact definition self stabilization 
instance different increasingly restrictive definitions 
election 
criterion establish im possibility results 
shall example depicted case study 
basic definitions preliminaries graph theoretical definitions directed multi graph nonempty set 
nodes set arcs functions specify source target arc arc node coloured graph set colours graph endowed colouring function denote disjoint union 
write arc source target shorthand 
denote dg distance nodes graph dg diameter 
subscripts dropped confusion possible 
directed tree graph selected node root node exactly directed path root 
tree write height length longest directed path 
tree consider maximal paths length equal height 
write tree truncated height eliminate nodes distance greater root 
trees partially ordered prefix iff partial order augmented bottom element definition strictly monotonic 
infimum partial order denoted common prefix common prefix exists 
supremum exists iff comparable 
need manage infinite trees allow node set tree fact considering trees isomorphism technically just preorder 
nontrivial property relating order height min min 
model network shall mean strongly connected coloured graph 
nodes graph called processors 
computations network defined state space transition function specifying processor change state activated 
new state depend course previous state states neighbours marked colours corresponding processor incoming arc incoming arcs different colours processor distinguish neighbours possess distinct colours 
new state depend colour processor 
sake simplicity discuss case arcs nodes fact coloured colours significant conceptual difference 
formally protocol set local states transition function set finite multisets intuitively new state processor depends previous state component cartesian product states multisets neighbour state 
global state processors respect protocol vector synchronous computation protocol network processors infinite sequence global states 
state obtained applying multiset behaviours predicates classes networks classes networks specify knowledge larger class smaller knowledge class networks corresponds knowledge singleton maximum knowledge 
common situations studied literature include knowledge network underlying graph number processors graph theoretical property 
instance knowledge available number processors specify self stabilizing protocol working networks nodes 
class networks 
behaviour set assignment nonempty suffix closed set infinite sequences sg predicate behaviour sequences constant identified assignment set sg colours nodes act identifiers colours arcs define communication model 
choosing suitable encode properties presence unique identifiers distinguished outgoing incoming links 
note importance identifiers appear section shall exploit identifier uniqueness improve bounds 
instance behaviour containing graph sequence 



suffixes specifies synchronized infinite state clock predicate containing tuples 
exactly nonzero defines known leader election problem 
token circulation topology reconstruction easily described similar way see section 
say self stabilize iff protocol state space network property computation 
sequence 
sg smallest called quiescence time denoted self stabilization finite state iff computations networks ultimately periodic note state finiteness imply finite finite part computation 
usually studying self stabilization spite dynamic run time changes network topology strengthens definitions take consideration additional constraint 
mentioned protocols described knowledge provided class topology modified resulting network belongs automatically guarantee convergence desired behaviour quiescence time course depend new topology 
point need pursued 
self stabilizing view construction network anonymous processors start initial state run program 
clearly connection theory anonymous networks self stabilization possible choice initial state set processors state sense self stabilizing way anonymously 
main goal part show implication reversed bounds amount information exchanged processors essentially advantage able choose initial local state local states forced equal 
words worst thing adversary choosing initial state set processors state 
anonymous networks views classical tool study anonymous networks concept view introduced bidirectional networks extended directed case true concept view seminal partially disguised mathematical notion graph covering 
view processor tree gathers topological information processor obtain exchanging information neighbours 
formally view processor network tree built follows nodes finite paths root empty path arc node node obtained adding arc tree infinite strongly connected arc trivial anonymous protocol allows processor compute view truncated desired depth 
step protocol processor gathers neighbours views truncated depth combining compute view truncated depth 
start state node tree 
example view construction show steps view construction processors simple network 
example view construction reason views important state processor steps anonymous computation may depend view truncated depth return property 
making view construction self stabilizing protocol section going describe infinite state self stabilizing protocol allows processor build view desired depth 
main idea protocol processor build view gathering information neighbours classical case processors interested eliminating garbage introduced arbitrariness initial state aim achieved mitigating amount new information introduced step 
processor holds tree value time denote contain truncation view interested growing correct levels describe protocol set shorthands denote tree obtained combining trees definition view root child arc coming corresponding subtree source necessary resulting tree truncated maximal paths length consequence min set 
note built level number levels shares classical anonymous view construction algorithm just set control amount new information introduced find fruitful set truncate new information level maximum number levels shares old 
useful facts min min 
statement depends trivially definition second statement proved noting case min min observing min min min preserves binary infima comparable trees min min min min min min definition assuming 
infinite state protocol protocol infinite state case extremely simple informally processor compares candidate new view current view finds greatest trees truncated depth takes candidate new view just levels 
processor trusts trees passed controlled way 
graphical display updated rule 
infinite state protocol update rule 
inequality base proof self stabilization establishes number correct levels height grows time 
immediate prove lemma min min 
lemma claims minimum number correct levels grows time 
growth just half need necessary show time trees entirely correct 
obtain result proving trees immediately short correct property inherited neighbours correctness spreads network steps 
shall proof technique frequently formalize proposition 
computation protocol function min 
min proof 
processor min prove induction min base case straightforward induction hand distance induction hypothesis min min min come main proof section 
basic idea due update rule adopted processor minimum number correct levels scrambled information correct step 
theorem exists integer steps protocol processors possess correct truncation view depth 
proof 
min minimum correctness level node minimum correctness 
necessarily share levels step 
tree height function satisfies hypotheses proposition height hand lemma thesis follows 
table shows steps execution algorithm network table contains value step 
observe step truncated views correct 
please ignore time column 
graph theoretical characterizations attainable behaviours previous section shown build processor views self stabilizing way 
know desired behaviour just depends truncation view realize protocol 
hand theory anonymous networks tells protocol attain behaviour depend exclusively view remarked informally previous sections 
principle characterized mathematically attainable behaviours 
clear knowledge help solving automatically problem stated section 
importantly clue turn protocol finite state 
reason going study deeper detail constraints behaviours self stabilizing network 
graph fibrations lifting lemma recall graph morphism pair functions commute source target functions undefined undefined table execution infinite state algorithm network 

subscripts usually dropped 
words morphism maps nodes nodes arcs arcs way preserve incidence relation 
express combinatorial characterization attainable behaviours shall exploit notion graph fibration 
fibration formalizes idea processors connected processors behaving way behave alike generalizes usage graph coverings angluin original concept similarity processors introduced 
definition fibration coloured graphs morphism arc node satisfying unique arc called lifting fibration called base fibration 
shall say fibred 
fibre node set nodes mapped denoted 
intuitive characterization fibrations concept local isomorphism 
fibration induces equivalence relation nodes classes precisely fibres 
nodes equivalent fibre bijective correspondence arcs coming arcs coming sources related arcs equivalent 
sketched fibration graphs 
note lifting property described definition black nodes exactly incoming arcs dotted arc going white node continuous arc going grey node 
words neighbour structure black nodes 
main raison tre fibre fibration 
fibrations allow relate behaviour protocol networks 
claim precise need notation fibration global state obtain global state lifting global state definition modified handle coloured case consider morphisms preserve colours nodes arcs 
graph theoretical ideas introduce adapt smoothly condition 
fibre see 
essentially starting global state obtain global state copying state processor fibrewise 
state lifting 
lemma lifting lemma fibration 
protocol computation 

computation proof 
network fibred processors fibre state processor mapped fibration processors fibre behave identically 
happens local isomorphism property says processors fibre arc terminating starting processor fibre association bijection arcs entering sequence local states processors fibre exactly equal sequence states processor lie 
lemma suggests network fibration certain constraints behaviours self stabilize 
precisely compute sequence lifted global states computing sequence global states lift result 
words computation resumes compact way computation possible initial global state processor local state hope self stabilize behaviour lifting behaviour consideration may trivial applied single network tricky class involved 
different networks class fibred common base find single behaviour lifted give cases desired behaviour 
observation sufficient show self stabilizing protocol election set networks 
bottom networks common base shown 
graphs common base numbers represent node component respective fibrations 
noticed networks common base 
behaviours attain liftings behaviours means election impossible class 
choose predicates lifted give rise unique leader main point notice shall see election possible 
words processors know live self stabilizing election knowledge denied self stabilizing election impossible course fortiori impossible class depicted 
example shows essential find networks class fibred common base 
interesting features synchronous model search reduced particular kind fibration network possible 
minimum bases say graph fibration prime fibration isomorphism smaller network fibration theorem properties hold 
graph exactly fibration prime graph called minimum base fibred 
common base 
iff consequence distinct nodes fibration prime graph different views 

fibration prime graph uniquely characterized set views nodes 
ways build partition set algorithm similar finite state automata minimization 
hand take nodes note coloured case depend structure graph colours 
distinct views put arc views view level child second 
show number networks corresponding minimum bases 
node component minimal fibration represented numbering nodes 
examples minimal fibrations minimum bases 
fibrations called minimal 
usually minimal fibration coincide nodes property theorem denote map arcs relevant 
instance graph minimum base previous theorem highlights deep link fibrations views processors view lie fibre know lifting lemma processors fibre fibration behave differently means hand processors view state hand deduce view lifting lemma characterize possible behaviours 
fundamental fact shall intensively proofs considerations involve infinite objects isomorphism infinite trees described means finite entities theorems theorem strongly connected graph fibration prime graph minimum number nodes satisfying dg words network candidate minimum base check minimum base finding processor processor share dg level views checking network nodes property 
fact enable recover minimum base sufficiently deep truncation view suitably enumerating fibration prime graphs 
theorem norris iff 
previous theorem tells distinguish different views network just check isomorphism levels 
observe fibred view fact connection deeper view processor network tree fibred root mapped processor view processor mapped processor decide sufficiently deep view node minimum base mapped minimal fibration 
deducing minimum base view immediate consequence lifting lemma data need self stabilize behaviour possible self stabilize minimum base network node component minimal fibration plus synchronized clock clocks course unnecessary case predicates 
situation similar typical scenario anonymous network processors build sufficiently deep truncation view apply theorem 
want protocol able run knowledge instance knowing bound number processors provide way deduce minimum base truncated views 
obtain optimal quiescence time want deduction early possible 
purpose introduce partial function allows processors extract truncated view candidate minimum base network protocol running assuming knowledge 
precisely assigns tree fibration prime graph way prefix view 
set way contain information undefined 
formally definition tree 
set fibration prime dg nonempty graph set having number nodes graph unique isomorphism theorem choose fixed representative isomorphism class 
undefined 
note easily computable enumeration finite 
immediate prove theorem fed sufficiently deep truncation view returns correct minimum base proposition graph 
node particular statement true dg fundamental property shall need described proposition defined unique node tree proof 

existence follows definition theorem node general rule write understand defined case definition isomorphism identity 
table show trees height indegree defined corresponding output value arcs trees course oriented root 
invite reader look back table column shows value view processor 
table values small trees 
characterization theorem theorem class behaviour protocol self stabilizes iff fibration prime graph sequence 
tg tg sg case self stabilize quiescence time max dg 
proof 
just need prove positive part negative part trivial application lifting lemma 
processors build view protocol step apply function obtain guess minimum base node minimum base mapped set part state space th component current height view processors current view height synchronized clock 
result part sequence global states quiescence time consequence theorem proposition 
previous theorem twofold side gives necessary sufficient condition discover class self stabilize behaviour side proof universal self stabilizing protocol works behaviour attainable 
note part protocol depends behaviour sequence associated minimum base part processors contain control logic essentially oracle different oracles give rise possible attainable behaviours 
characterization implied statement theorem may daunting really boils simple procedure 
find minimum bases networks 
try find sequence global states satisfying statement theorem sequence lifted network represent desired behaviour 

previous step possible behaviour attainable chosen sequences fed universal protocol giving rise self stabilizing protocol behaviour 
apply technique example 
standard computations show just minimum bases networks 
looking notice second network remaining networks minimum base 
obstacle election predicate base lifted network gives incorrect behaviour 
hand networks give problems exactly processor mapped processor base 
conclude self stabilizing election possible class shown eliminating node network bigger networks self stabilizing election possible 
reader easily compute sequences universal protocol 
simple corollary theorem gives attainable predicates corollary class predicate protocol self stabilizes iff fibration prime graph sg case self stabilize quiescence time dg lower bound show bound quiescence time tight 
base proof fact bound dg theorem tight authors proved fibration prime graphs nodes diameter property isomorphic level level difference families positioning dotted arc 
words processors living networks need long time steps understand kind network belong 
class networks described class networks nodes 
theory anonymous networks know lemma processor network processor network state steps anonymous computation computation processors start state 
immediate state processor time depends view truncated depth theorem protocol self stabilizes predicate 
quiescence time networks 
note essentially predicate mb forces processor compute network topology identity network networks fibration prime 
proof 
network underlying graph stabilizes steps lemma network stabilize steps 
corollary protocol self stabilizes larger class particular class fibration prime graphs predicate mb quiescence time infinite networks 
finite state universal self stabilization point clear computing minimum base node processor mapped predicate 
defined section need self stabilize attainable predicate 
synchronized clock necessary self stabilize generic behaviour 
note require state finiteness computation ultimately periodic similarly behaviours ultimately periodic 
finite state modular clock sufficient 
networks similar views 
unfortunately protocol discussed uses unbounded number states views growing 
problem instance bound number processor known case safely truncate views say twice number processors obtain correct guess minimum base 
resulting protocol finite state coupled synchronized clock described section give rise universal finite state self stabilizing protocol 
clearly behaviours synchronized clock requires necessarily infinite state important problems election principle finite state self stabilizing solution 
overcome problem introduce guess processor keep height control 
shall set protocol way small locally checkable conditions true forcing update guess 
certain number local checks corrections necessary fact increase quiescence time 
parameterize protocol respect update function show loss quiescence time arbitrarily small choosing update function growing quickly 
course tradeoff space protocol 
strictly increasing strictly inflationary function function 
denote th iterate define min 
easy show choosing suitably grow slowly desired 
finite state protocol self stabilizing mb max max 
intuition protocol proceed infinite state case keep just levels candidate view 
step processors check current idea minimum base neighbours idea changed update 
happen guess increased function proof correctness protocol complex 
delicate part consists showing processors idea minimum base going change step idea right 
prove number lemmata lead main theorem 
show number correct levels tree increases step lemma bounded way expect grow step truncated basis guess 
lemma min min 
min 
min 
min min proof 

case immediate 
min min min min min 

case immediate min min min min min min min 

note certainly min min min min min theorem guarantees suitable conditions number correct levels increase 
show time trees correct 
proof theorem obtain result showing trees minimum correctness correct step correctness inherited neighbours 
lemma proof 
min minimum correctness level node minimum correctness 
step min lemma apply proposition tree height obtain hand min lemma thesis follows 
prove processor applies state satisfying predicate 
said local conditions check guarantee globally processors computing minimum base correctly 
lemma proof 
prove statement building fibration common value drop superscript proof course minimal 
define unique proposition node proposition fibration mapping arc corresponding arc recall nodes paths arc arises unique arc 
define arcs follows arc corresponds uniquely arc coming root identify map 
show graph morphism prove commutes source target maps 
case immediate noting 
case 
extension level subtree necessarily 
definition view 
fact fibration follows easily definition arcs obtain consequently course need show conditions satisfied remain true forever 
purpose lemma properties true proof 
min min definition proposition proposition shows protocol self stabilizing certainly finite state stabilization applied finite time processors enter fixed point truncated height grow anymore 
give bounds quiescence time 
purpose firstly show stabilization reached applied lemma min letting kd statements true 

max proof 
statement stable lemma prove claim induction assuming true false 
max processor applies statement true recall 
min min lemma 
general case note certainly min true max max lemma min min min min min max min prove second main result finite state counterpart theorem theorem protocol finite state self stabilizes class networks predicate mb quiescence time dg dg dg network proof 
notation lemma min 
lemmata obtain result 
note stabilized time lemma lemma obtain thesis 
note respect infinite state case loss diameter times arbitrarily slow function factor due time necessary detect locally guesses small time subsequently necessary spread knowledge network 
clearly resulting bound ng precise space bound required loss quiescence time reduced arbitrarily gap lower bound corollary arbitrarily small 
conjecture universal finite state protocol self stabilizing predicates quiescence time 
self stabilizing clocks protocols previous sections allow self stabilization predicates 
second ingredient need order self stabilize arbitrary behaviours synchronized clock 
infinite state case clock provided self stabilization equal grows exactly step 
results self stabilizing clock synchronization literature 
results survey see 
known results sufficiently general applied case instance results unidirectional networks rings 
going describe finite state self stabilizing protocol provides processor clock modulo constant 
protocol processor integer variables clock value purposes stabilization consider mod guess find large multiple clocks stabilize quickly 
strictly increasing inflationary update function protocol parameterized choice denoting values clock guess time define protocol follows min mod max max 
basic idea synchronization shall keep incrementing point space largest clock value smallest modulus 
note soon clocks value modulo property remain true mod mod mod 
condition extra delay necessary guesses equal fact clocks 
onwards min assume loss generality 
note step processors neighbours minimum clock value set clock min steps upper bound propagate processors course clocks increase unit step 
formally clock value satisfies hypotheses proposition min pm sake simplicity defined state space way contain pairs guesses clock values 
reader ease choice equivalently substitute rule minimize mod just prove lemma statements true 
ii 
min 
proof 
min statement ii true 
statement stable inductive step assume statement ii true statement false clocks different values modulo time kd processor processor satisfying apply step take processor minimizing processor shortest path 
processors apply time kd min steps time kd lower bound propagate processors min 
theorem protocol finite state synchronizes modulo clocks steps 
proof 

time kd clocks equal modulo lemma case pm kd kd pg kd pd guesses nondecreasing time kd kd clock values wrap proposition time kd clocks value min finite state characterization theorem theorem class networks behaviour finite state self stabilize fibration prime graph exists periodic sequence 
sg case strictly monotonic inflationary self stabilize quiescence time dg dg dg proof 
condition necessary lifting lemma fact finite state behaviour necessarily ultimately periodic 
sufficiency run parallel finite state protocol stabilizes network predicate mb finite state clock synchronization protocol period sequence associated current candidate minimum base undefined choice period immaterial 
soon protocol reached stabilization period correct value additional quiescence required clocks synchronize self stabilize required behaviour analogously theorem 
precisely step processor applies function obtain guess minimum base node minimum base mapped sets part state space th component current clock value modulo period sequence associated final statement immediate consequence theorems 
case predicates theorem class networks predicate finite state self stabilize fibration prime graph exists sg case self stabilize quiescence time dg dg dg strictly monotonic inflationary function 
case unique identifiers previous sections assumption nature node colouring extreme case uniform case processors indistinguishable transition function 
papers self stabilization assume processors unique identifiers section want focus attention special case network unique identifiers iff node colouring function injective property equivalent saying processors different different transition function 
shall see moment fruitfully presence unique identifiers improve efficiency algorithms reduce quiescence time 
fact evidences possibility identifying processor unique manner may reduce time needed self stabilize system improvement turns particularly dramatic network small diameter 
theorem behaviour admits protocol 
presenting modified algorithm comments order 
unique identifiers necessarily fibration prime theorem may rephrased case follows typically studying topology reconstruction note self stabilizing topology reconstruction processors identical class fibration prime graphs classes 
note asymmetry requirements papers self stabilization networks fibration prime 
reason prove self stabilization desired behaviour 
theorem strongly connected graphs unique identifiers dg 
graph nodes satisfies property proof easy unique identifiers assumption conditions imply theorem applied 
consequence give slightly different definition function tree defined unique theorem graph minimum number nodes set unique identifiers dg set empty case undefined 
function property special stronger version proposition proposition graph unique identifiers tree 
undefined happens iff dg proof 
proof follows theorem existence smallest graph imply undefined dg 
implication trivial 
finite state protocol follows 
prove self stabilization mb introduce definition set min quantity measures minimum amount correct levels time assumes sufficiently deep correct trees infinite number correct levels 
lemma 
proof 
possible change state processor truncation tree leaves untouched 

assume note processor sets clearly hand sets neighbours correct levels 
show processors fall case 
assume contradiction smallest correctness necessarily 

min 
theorem protocol finite state self stabilizes class networks unique identifiers predicate mb quiescence time dg network proof 
assume contradiction 
update rule sets apply proposition tree height function obtaining usual step trees correctness truncated height 
hand lemma theorem contradicting assumption 
state finiteness immediate stabilization max grow 
bound tight suitably assigning unique identifiers family graphs shown easy see isomorphic level 
note infinite state case synchronized clock provided update rule min clock self stabilize steps 
running protocols parallel obtain theorem class networks unique identifiers behaviour self stabilize quiescence time dg network hand finite state case theorem class networks behaviour finite state self stabilize sg contains periodic sequence case self stabilize quiescence time dg network proof 
run parallel protocol finite state clock synchronization protocol 
step current guessed minimum base set periodicity sequence associated theorem obtain synchronized clock dg steps stabilization mb dg case 
examples section provide number examples showing classical non classical problems easily characterize classes self stabilization possible undefined choice immaterial 
give informal specialization universal protocols showing solve problem practice course may possible obtain refinement efficient versions protocols 
assume specified 
quiescence times easily derived results previous sections 
leader election 
problem reach state exactly processor leader processors know 
sg tuples containing exactly 
necessary sufficient condition existence self stabilizing protocol fibration prime graphs node satisfying 
condition satisfied fibration prime graph associate tuple containing exactly position satisfying theorem 
hand condition true choice produce vector zero lifted note particular condition true classes fibration prime graphs networks unique identifiers cases special 
protocol computes minimum base necessarily unique processor mapped node condition elected 
token teleportation mutual exclusion 
processors teleport token way single token exists time processor receives token exactly steps 
sg contains iterates sequence 



sequences obtained index permutation 
note constraint satisfied topology allow intuitively pass token link 
problem solvable exactly classes fibration prime graphs graph exists sequence item position theorem satisfied 
hand just set tuple containing exactly position mod 
protocol computes minimum base course isomorphic establishes synchronized clock modulo finite state case 
clock processor mod holds token processor mod step 
complete topology reconstruction 
processor reconstruct network running select case pairs networks natural numbers 
detail sg contains tuples 
isomorphism problem solvable exactly classes fibration prime graphs graph exists choice give lifting tuple natural number appears times second component 
hand fibration prime graphs predicate superset mb attainable 
topology reconstruction 
processor reconstruct network running required selects 
may strange classes problem solvable previous case 
problem solvable exactly classes fibration prime graph reader able build proof time 
processor clearly obtain network minimum base 
weak leader election 
case require processor enter third state leader election impossible network protocol running 
sg tuples containing exactly leader election possible tuple 

necessary sufficient condition existence self stabilizing protocol leader election impossible fibration prime graph impossible reader easily check condition weaker needed example see 
condition holds set 
election impossible example election possible 
hand fibration prime graph election impossible possible assignment suit sg resulting protocol computes minimum base election impossible processors proceed example 
lower bounded synchronized clock 
processors required hold synchronized clock increasing unit step value greater precisely sg sequence 


suffixes 
clearly class self stabilize behaviour interesting point quiescence time general greater maximum theorem realized 
fact true protocol particular argument shows consider arbitrary protocol self stabilizing class unidirectional uniform rings 
ring processor starting state obtain sequence states 
certain 
self stabilization ring processors impossible steps easily see starting computation local initial state equal processors 
note choosing function faster squaring enlarge gap arbitrarily 
organic theory self stabilization synchronous networks 
table summarize bounds obtained universal protocols 
far minimum base construction concerned bounds tight general finite state case asymptotically nearly optimal bound upper bound ng arbitrarily slow lower bound 
relevant open problem prove disprove conjecture finite state universal protocol quiescence time fact protocols arbitrarily close bound suggests task easy 
natural question arises possibility emulating protocols described asynchronous message passing system 
standard equivalence result synchronous shared memory asynchronous message passing anonymous networks proved yamashita kameda easily extended level generality adopted minimum base construction clock synchronization phase infinite states tight infinite states unique id tight finite states finite states unique id tight table summary bounds quiescence time 
extension self stabilizing systems require design self stabilizing simulations shared memory described require additional information distinguished incoming links 
knowledge protocols exist time 
synchronous scheduler assumed powerful interleaved central daemon scheduler assumed literature guarantees exactly processor activated step property introduce asymmetry rings prime size self stabilizing leader election algorithms interleaved activation synchronous activation 
asynchronous message passing synchronous shared memory systems general emulate powerful feature shown case anonymous networks fortiori self stabilizing systems 
course difference immaterial unique identifiers assumed created randomness 
note distribution unique identifiers allow faster protocols section existing algorithms knowledge bidirectionality assume applied class consideration satisfies additional necessary requirements 
proved minimum base construction protocols completely asynchronous scheduler prove optimality quiescence time 
theory similar outlined pursued networks asynchronous interleaved scheduler fibration theoretic notions described 
case computability results classes anonymous networks bounded size turned immediately results self stabilization substituting computation minimum base uses knowledge size bound assumes correct views guess function characterizations specific problems abovementioned papers easily turned characterization self stabilization 
final note particular conditions colouring arcs behaviours attainable 
instance happens common model links bidirectional locally distinguishable processors simple presence leader network fibration prime see 
case presence single distinguished processor possible self stabilize behaviour 
longer true processors distinguish outgoing links immediate check tools described 
yehuda afek geoffrey brown 
self stabilization unreliable communication media 
distributed computing 
yehuda afek kutten moti yung 
memory efficient self stabilizing protocols general networks 
proc 
international workshop distributed algorithms number lecture notes computer science pages 
springer verlag 
yehuda afek kutten moti yung 
local detection paradigm application self stabilization 
theoret 
comput 
sci 
dana angluin 
local global properties networks processors 
proc 
th symposium theory computing pages 
awerbuch patt shamir george varghese 
self stabilization local checking correction 
proc 
nd symposium foundations computer science pages 
paolo boldi bruno peter gemmell janos simon sebastiano vigna 
symmetry breaking anonymous networks characterizations 
proc 
th israeli symposium theory computing systems pages 
ieee press 
paolo boldi sebastiano vigna 
fibrations graphs 
appear discrete math 
paolo boldi sebastiano vigna 
computing vector functions anonymous networks 
danny peter widmayer editors 
proc 
th international colloquium structural information communication complexity volume proceedings informatics pages 
carleton scientific 
extended appeared brief announcement proc 
podc acm press 
paolo boldi sebastiano vigna 
self stabilizing universal algorithms 
ghosh ted herman editors self stabilizing systems proc 
rd workshop self stabilizing systems santa barbara california volume international informatics series pages 
carleton university press 
james burns mohamed gouda raymond miller 
stabilization 
distr 
comput 
edsger dijkstra 
self stabilizing systems spite distributed control 
cacm 
dolev 
possible impossible self stabilizing digital clock synchronization general graphs 
journal real time systems 
dolev 
optimal time self stabilization uniform dynamic systems 
parallel process 
lett 
dolev amos israeli shlomo moran 
resource bounds self stabilizing message driven protocols 
siam comput 
dolev amos israeli shlomo moran 
uniform dynamic self stabilizing leader election 
ieee transactions parallel distributed systems 
ralph johnson fred schneider 
symmetry similarity distributed systems 
proc 
th conference principles distributed computing pages 
shmuel katz kenneth perry 
self stabilizing extensions message passing systems 
distr 
comput 
nancy norris 
universal covers graphs isomorphism depth implies isomorphism depths 
discrete appl 
math 
yamashita kameda 
computing functions asynchronous anonymous networks 
math 
systems theory 
see 
yamashita kameda 
computing anonymous networks part characterizing solvable cases 
ieee trans 
parallel distributed systems 
yamashita kameda 
erratum computing functions asynchronous anonymous networks 
theory computing systems math 
systems theory 

