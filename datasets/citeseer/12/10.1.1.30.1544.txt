theory partial order programming mauricio universidad de las americas departamento de en sistemas sta 
mexico bharat jayaraman department computer science state university new york buffalo buffalo ny david plaisted department computer science university north carolina chapel hill chapel hill nc mail contact bharat cs buffalo edu shows partial order program clauses lattice domains declarative programming 
paradigm particularly useful expressing concise solutions problems graph theory program analysis database querying 
applications characterized need solve circular constraints perform aggregate operations capability clearly efficiently provided partial order clauses 
novel approach declarative operational semantics correctness operational semantics 
declarative semantics model theoretic nature model function classical intersection models greatest lower bound upper bound respective terms defined function different models 
operational semantics combines top goal reduction memo tables 
partial order programming framework memoization primarily needed order detect circular circular function calls 
general need simple memoization functions defined circularly terms monotonic functions 
cases accumulate set functional constraints solve general fixed point finding procedure 
order prove correctness memoization straightforward induction length derivation suffice presence memo table 
entries table grow monotonically identify suitable table invariant captures correctness derivation 
partial order programming paradigm implemented examples shown tested implementation 
revised expanded version partial order programming revisited appeared proceedings algebraic methodology software technology conference pp 
ed montreal july 
equational program clauses equational reasoning lie heart functional programming development modern functional languages ml miranda haskell strongly influenced principles 
describe functional language principal building blocks partial order program clauses lattice data types 
partial orders lattices functional language surprising concepts fundamental semantics 
motivation practical nature show partial order clauses lattices help obtain clear concise efficient formulations problems requiring ability take transitive closures solve circular constraints perform aggregate operations 
basic forms partial order clause terms expression terms expression clauses define functions require variable occuring expression occur terms 
terms constants variables data constructors expressions addition user defined functions appear head left hand sides partial order clauses 
informally declarative meaning clause ground instantiations replacing variables ground terms function applied argument terms respectively ground term denoted expression right hand side 
general multiple partial order clauses may defining function define meaning ground expression terms equal upper bound respectively greatest lower bound resulting terms defined different partial order clauses practice lattice domains commonly occur applications sets subset ordering numbers numeric ordering 
case lub glb operations set union intersection respectively case operations numeric greater respectively 
operations implemented quite efficiently shown 
show partial order clauses help render clear concise formulations problems involving aggregate operations recursion database querying 
topic considerable interest literature 
aggregate operation function maps set value maximum minimum set cardinality set summation members considering problems various semantic approaches van gelder notes problems aggregates proposed concept subset really necessary 
proposed paradigm provides natural efficient realization concept monotonic aggregation 
fact aggregate operations functions predicates suggests query language supporting functions natural framework expressing aggregate operations 
approach permits natural means stating monotonicity requirements aggregate operations 
order couple extensional database relations partial order clauses introduce class conditional partial order clauses term extensional database relations means database relations relation defined explicitly tuples relation holds 
usual meaning relation relational database terminology 
terms expression condition terms expression condition variable expression occurs terms condition condition conjunction literals may form terms terms terms term extensional database predicate 
semantics resulting programs straightforward generalization unconditional partial order clauses 
setting show various examples discussed deductive database literature clearly concisely formulated 
resulting language may thought functional query language 
main technical results declarative operational semantics partial order programs especially correctness respect 
declarative semantics model theoretic nature follows intuitions fixed point theory function definition defined semantics monotonic functions respect appropriate partial orders 
requirement monotonic functions severe seek liberal condition defined semantics 
show program unique model stratify partition program clauses levels function calls level depend level monotonic functions may depend calls lower levels non monotonic functions 
contrast equational programs partial order programs model obtained classical intersection models classical fixed point glb denoted terms different models ground functional atom terms 
order support new notion model develop operational semantics combines top goal reduction memo tables 
memo tables traditional functional languages equational programs detect dynamic common subexpressions 
partial order programming framework memoization primarily needed order detect circular constraints circular function calls 
general need simple memoization functions defined circularly terms monotonic functions 
cases need accumulate set functional constraints solve iterative procedure computing greatest fixed point 
order prove correctness operational semantics note straightforward induction length derivation possibility cyclic function calls inductive proof requires function call reducible strictly smaller calls reduction relation 
noted detect cyclic calls memo table 
entries table grow monotonically identify suitable table invariant captures correctness derivation 
order bridge gap operational semantics model theoretic semantics provide constructive characterization declarative semantics terms notion dependency graph function call terms 
declarative semantics interprets functions total functions operational semantics incomplete technical sense 
operational declarative semantics coincide exactly terminating partial order programs 
note partial order clauses generalization extension concept subset clauses described previous papers 
significance generalizing subset clauses partial order clauses provides simple efficient way programming aggregate operations 
showed translate partial order clauses normal program clauses meaning formalized extended founded semantics 
considerably extends previous papers providing complete treatment declarative procedural semantics including correctness proofs treats monotonic aggregation monotonic memo tables 
rest organized follows section gives syntax terms expressions explains examples informal meaning partial order clauses section gives declarative semantics partial order clauses section presents operational semantics correctness results section introduces conditional partial order clauses shows defining aggregate operations databases section presents comparisons related 
assume familiarity basic concepts semantics logic programs 
introductory treatment relevant concepts text lloyd 
partial order clauses informal syntax informal semantics discuss unconditional partial order clauses form terms expression terms expression variable expression occurs terms 
discuss conditional partial order clauses section 
syntax terms expression term variable constant terms terms term term terms expression term exprs exprs exprs expression expression exprs lexical convention constants lowercase letters variables uppercase letters 
symbol stands constructor symbol stands non constructor function symbol called user defined function symbol 
terms built constructors stand data objects language 
ground term term contain variables 
constructors language framework may constrained equational theory special case set constructors described 
constructors require matching ground term pattern non ground term produces finite number matches 
consider complete lattices finite terms language framework 
special interest complete lattice finite sets partial orderings subset superset union intersection stand lub glb respectively empty set fg element 
order meet requirements complete lattice special element introduced greatest element 
notation match set fxg set removed 
example matching fa cg pattern yields different substitutions fx fb cgg fx fa cgg fx fa 
left hand sides program clauses allows decompose set strictly smaller sets 
presenting examples informally describe operational semantics clauses provide reader intuition language help appreciate formal semantics section 
remembered partial order clauses essentially constitute functional programming paradigm functions called ground terms arguments 
term query refer top level function call syntax ground terms 
general case multiple partial order clauses define function 
presence constructors equational theories left hand sides program clauses multiple matches function call left hand side clause 
multiple partial order clauses define function matches function call terms left hand sides clauses defining instantiating corresponding right hand side expressions depending partial order clauses lub glb respectively resulting terms taken result 
case clauses match call result respectively lattice 
refer failure failure assumption 
assume function defined clauses 
reason restriction mixing types clauses function definition result inconsistency 
example consider trivial program non trivial lattice domain distinct elements respectively greatest elements lattice 
clearly impossible provide interpretation satisfying clauses 
restriction partial order program consistent model shown section 
restriction guarantee program defined unique model 
achieve desired property need place semantic requirement circularity function definitions occur monotonic functions 
illustrate point example elaborate section 
examples example 
definition shows simple multiple partial order clauses define lub glb elements lub glb lub glb example 
definition set intersection shows set patterns left hand sides partial order clauses perform iteration sets intersect fxn fxn fxg function works follows function call intersect assertions intersect intersect 
lub obtain intersect 
note argument sets fg resulting set fg 
example 
remainder sets set matching illustrated function definition takes input collection propositional clauses set set literals returns set resolvents resolvents fnot ns note fa bn abbreviation gg constructor 
example illustrates power conciseness afforded set patterns 
refer reader examples illustrating set patterns partial order clauses 
discusses efficient implementation techniques set patterns terms instructions closely related warren machine prolog 
examples illustrate circular function calls arise briefly describe handled intended operational semantics 
example reach 
definition transitive closure operations natural clauses 
consider function reach takes set nodes input finds set reachable nodes set re formulate example section edge predicate 
reach reach fxn reach edge edge edge notice top level query reach result call reach turn result circular call reach 
detect loop memo table return empty set tentative answer approximation circular call 
doing result set tentative answer top level query reach 
re evaluate circular call reach revised tentative answer approximation 
results set new answer top level query 
fixed point reached declare answer query 
may noted problem solved having incur circular calls possible keeping set nodes visited consulting set making subsequent calls 
technique feasible implement example requires nontrivial memoization successive approximations 
example data flow analysis 
partial order clauses carrying sophisticated flow analysis computations illustrated program computes reaching definitions busy expressions program flow graph 
information computed compiler optimization phase 
example shows monotonic functions 
reach reach pred kill reach gen reach reach busy busy succ def busy busy busy program kill gen pred def succ predefined functions specifying relevant information program flow graph basic block set difference operator monotonic argument bodies functions reach busy legal 
reach reach functions defined circularly busy busy memoization needed avoid infinite loop result underlying program flow graph cycles 
may noted functions absent program definitions reach example final answer obtained having compute successive approximations tentative answer top level query correct answer 
presence monotonic functions iteration required general 
declarative semantics section model theoretic semantics partial order clauses provide constructive characterization semantics 
simplicity presentation consider clauses section treatment clauses symmetric 
noted consider definition function combination clauses 
consequence semantics clauses modular way possibility interference clauses vice versa 
consider functions argument results carry straightforward general case 
note argument general term simulate multi argument function list loss generality assumption 
preparation semantics flattened form clauses goals 
idea flattening mentioned places literature 
follow definition illustrate simple example 
example 
assuming user defined functions remaining function symbols constructors flattened form clause follows 
flattened clause follow prolog convention notation commas 
variables understood universally quantified head clause customary definite clauses 
general form flattened clause head body head terms body form user defined function symbol new variable head term equivalent argument original program clause 
formula body called basic goal sequence basic goals called goal sequence 
order basic goals listed right hand side flattened clause leftmost innermost order reducing expressions 
note flattened form query similar body 
order capture failure assumption assume function symbol program augmented clause 
model theoretic semantics herbrand interpretations herbrand universe program consists ground terms referred herbrand base program consists ground equality atoms form user defined function ground term ground term belonging complete lattice domain 
henceforth symbol stand user defined non constructor function symbol 
develop model theoretic semantics details specific lattice domains sets numbers allows presentation focus essentials clauses discuss axiomatizations equational theories specific data domains 
full treatment logical foundations set constructors described section refer reader sources information 
giving examples illustrate certain points semantics need specific data domains 
intuitive understanding domains suffices examples 
due equational theories constructors predicate defines equivalence relation herbrand universe 
contract model called normal model defines identity relation follows take domain set equivalence classes determined domain herbrand interpretations denotes domain quotient structure 
refer elements equivalence class element order text readable refer elements just keeping mind formally working equivalence classes details explained 
assume interpretation includes certain equality inequality atoms form fixed intended interpretation program 
assume interpretation interpreted total function ii definition 
program 
interpretation model denoted ground instance clause fe exists atom briefly motivate approach model theoretic semantics 
basically define semantics function call ground term glb greatest lower bound terms defined different herbrand models definition model 
see need take glbs consider trivial program assume result domain lattice totally ordered numbers 
model interprets constant function 
intended model function obtained classical set intersection models terms defined different models 
example course min operator numbers 
theorem partial order program consistent 
proof assume clause program inequality 
take interpretation function evaluates top element complete lattice 
direct verify interpretation model program 
case similar 
syntactically formed programs defined meaning 
circularity function definitions allowable long occurs monotonic functions 
consider program familiar negation operator non monotonic respect boolean lattice false true program models fa true trueg fa true falseg fa false trueg glb terms defined respectively models gives fa false falseg clearly model 
conclude non monotonic functions permissible circular definitions functions 
motivates interest stratified partial order programs 
discussion topic strongly stratified programs defined continue discussion general stratified programs section 
definition strongly stratified programs 
program strongly stratified exists mapping function level set user defined non constructor function symbols finite subset natural numbers clauses form term term permitted 
ii clause form term expr user defined functions level greater equal level level greater level user defined function symbol occurs expr 
iii form clause permitted 
note definition non flattened form program clauses definition easier understand way 
program different level mappings assume select image set consecutive natural numbers includes 
example reach program shown example function edge level function reach level 
definition stratification sense restrictive requires function level directly defined terms functions level 
instance programs examples strongly stratified 
relax requirement section introduce general stratified programs 
introduce strongly stratified programs operational semantics requires simple memo tables functional constraints 
definition 
set strongly stratified program clauses 
define clauses user defined function symbols left hand sides level definition 
interpretations program define exists say construct model theoretic semantics strongly stratified program level level 
defining models level functions levels models uniquely specified 
interpretations clauses level contain atoms function level reason overload meaning function level notation level refer level head function symbol atom definition 
interpretation level kg 
definition 
interpretations program ff function symbol definition 
set interpretations ux natural generalization previous definition 
proposition 
set models program levels gamma gamma ux model 
definition 
program levels define model theoretic semantics ufm ufm gamma gamma definition 
program levels goal sequence say substitution correct answer 
general stratified programs strongly stratified language defined section permits definition function directly terms function level lower level 
general stratified language defined permits definition function terms function level monotonic functions 
definitions assume functions argument 
definition 
function monotonic 
definition general stratified programs program general stratified exists mapping function level set user defined non constructor function symbols finite subset natural numbers clause definition permitted 
clause form called clause stands strongly stratified 
ii clause form terms expr monotonic function level greater level level greater equal level level greater level function symbol occurs expr 
clause form called clause stands general stratified 
iii form clause permitted 
definition note necessarily different 
non monotonic dependence occurs respect lower level functions 
fact liberal definition composition monotonic functions monotonic function syntax replaced composition monotonic functions 
second suffices ground instances program clauses stratified manner 
idea course analogous local stratification working functions predicates 
clear presence monotonic functions call alteration model theoretic semantics 
operational semantics modified incorporate monotonically updatable memo tables illustrated example 
note general decidable syntactically check function definition monotonic 
certain domains sets possible detect monotonicity property cases simple syntactic check possible functions operate element time arguments remainder sets pattern matching 
functions section examples possess property 
note requirement sufficient necessary function resolvents example monotonic remainder sets pattern matching 
note remainder sets inner level 
constructive semantics give constructive description subsequently useful proving correctness operational semantics 
purpose exploit syntactic form gen eral stratified programs noted earlier fact order equalities bodies flattened clauses reflects leftmost innermost order reducing expressions 
definition 
consistent general stratified program model theoretic semantics 
define dependency graph set nodes set edges follows ff delta delta delta ground clause instance ground clause instance pg 
example 
program reach example reach ground instance program edge reach 
edge reach reach reach edge reach ground instance program reach reach edge reach 
definition 
dependency graph ground expression subgraph dependency graph includes reachable nodes 
general stratified programs correct answer basic goal ground got considering reachable nodes dependency graph associated ground terms lub terms 
formalize intuition 
definition 
general stratified consistent program set edges dependency graph ground term define border set chain node called border set minimal graph closed operations ff called initial border set node chain 
ii bs bs fw belong border set ng bs bs fvg bs bs bs 
different border sets border set chain say path passes example 
program reach border set chain reach border sets ff reach ff gg 
ff reach ff gg 
may noted example correct answer simple goal reach obtained particular border set reach border set ff gg 
lemma 
consistent general stratified program basic goal ground variable bs border set border set chain 
name sense literature 
lub fu bs fu bs ug 
proof straightforward induction relation border set nodes border set chain program 
base case applies node ff proof immediate 
induction hypothesis assume node bs lub fu bs fu bs ug 
induction step suppose border set bs related bs direct edge 
definition bs bs fh ground expression removed bs set added 
definition bs bs constructing dependency graph definition border set node equivalent omit ground expressions belong chain removal affect answer lemma holds bs operational semantics define lub reduction ground query expression respect general stratified program starting flattened form order equalities bodies flattened clauses reflects leftmost innermost order reducing expressions 
order necessary arguments function calls ground reduced 
definition 
general stratified program ground query ground term define lub reduction respect quadruple follows assume usual variables distinct clause variants different 
ff clause variant matches ff clause variant matches cat fb fb delta fy lub fu ground instance unit cat fb delta delta delta concatenating order immaterial clauses head empty 
separate goal sequence equality constraints involving monotonic functions different operational strategies solve 
note match 
require number matches finite 
note affected 
example 
program flattened form clause clause fxn fx clause lub reduction wrt fp fz gamma 
lub reduction wrt maintains result query 
operational semantics strongly stratified programs strongly stratified programs component lub reduction ground expression empty absence clauses 
definition 
memo table set assertions form user defined function ground term term 
definition 
extended goal form goal sequence memo table 
initial extended goal form oe user defined function ground term variable 
final extended goal form goal sequence empty 
note loss generality assuming initial extended goal consists single function call 
order model query expression user defined function simply expression body new function say definition initial extended goal oe 
definition 
strongly stratified program define reduction relation follows 
goal remaining goal sequence 
defined follows reduce table lub reduction wrt quadruple oe fy delta delta delta 
define fx delta delta delta delta delta concatenation operator goal sequences 
define fg 
table lookup define defined follows fx wg occur fx sty gamma ty assuming form sty gamma tx ty example derivation sequence 
illustrate derivation sequence example reproduce flattened form reach reach fxn edge reach edge edge assume top level query flattened reach ans 
show reduction sequence query 
goal sequence substitution memo table reach ans oe edge ans reach reach edge gg edge edge reach reach reach edge reach edge gg edge reach edge gg note memo table look occurs step derivation 
computed answer variable ans top level query obtained memo table seen 
lemma strongly stratified program oe extended initial goal 
extended goal entry form delta delta delta delta delta delta ground occurs proof proof induction length derivation 
base case immediate table empty 
induction step assuming satisfies property prove satisfies property 
definition obtained reduce table lookup step 
cases assume selected goal 
reduce step derive eliminating variable substituting term ty ty goal sequence memo table definition lub step new variables appear entries memo table desired property 
table lookup step eliminate goal sequence memo table introduce new goals new variables 
note solution equation assuming memo table obtained new variables introduced 
entries memo table desired property 
consequence lemma final extended goal variables memo table variable associated goal sequence lemma impossible final goal sequence empty 
definition computed answer 
strongly stratified program oe extended initial goal terminates final extended goal 
computed answer fx sg briefly outline strategy soundness proof proving computed answer correct 
noted section possibility circular function calls prove soundness straightforward induction length derivation customary logic programs 
key soundness proof identification suitable memo table invariant 
invariant states entry memo table functional atom related certain way border set 
establish lemma table invariance implies suitable instantiation entry memo table correct model theoretic semantics 
establish lemma reduction relation preserves table invariance 
lemmas pave way soundness proof 
definition 
strongly stratified program 
extended goal correct answer 
said table invariant condition holds entry form delta delta delta tx delta delta delta tx ground occurs fs delta delta delta phi fx delta delta delta ff non initial border set border set chain phi fx delta delta delta fg ng 
example 
illustrate table invariants reduction steps third fourth derivation sequence shown example 
correct answer extended goals 

consider 
reach edge gg 
note phi ff reach border set border set chain reach 

consider 
edge reach edge reach note phi ff gg border set border set chain reach 
ff reach border set reach 
lemma 
strongly stratified program 
extended goal correct answer 
table invariant entry table form delta delta delta tx delta delta delta tx ground term ground term 
proof definition table invariance entry form delta delta delta tsm tx delta delta delta ground occurs fs delta delta delta phi fx delta delta delta ff non initial border set bs border set chain 
lemma lub fu bs fu bs ug 
lub fu bs lub fu bs ug 
delta delta delta lub fu bs ug 
delta delta delta tsm lub fu ng 
removal set immaterial get delta delta delta lub fx ng 
lemma strongly stratified program oe extended initial goal terminates final extended goal tm 
extended goal derivation table invariant 
proof syntactic conditions table invariant property ensured lemma 
semantic conditions proved induction length derivation 
base case trivial table empty 
induction step prove table invariant table invariant 
suppose 
table invariant form delta reduce table lub reduction wrt quadruple fy delta delta delta 
fx delta delta delta delta ff xg 
correct answer fsg fg ff immediate border set successor ff border set chain 
safely replace sty delta delta delta ty resulting extended goal table invariant 
table lookup suppose delta correct answer delta delta delta tsm tx delta delta delta tx variable variables occur table entry 
loss generality assume hypothesis extended goal table invariant follows fs phi non initial border set border set chain 
clearly fs phi nff border set lemma lub fs js mg fx ng true 
safely replace delta delta delta tx ts delta delta delta tsm resulting extended goal table invariant 
theorem soundness strongly stratified programs strongly stratified program oe extended initial goal terminates final extended goal 

computed answer correct 
general stratified programs necessarily true proof similar different variable xn proof lemma extended goals emanating table invariant table invariant 
final extended goal follows variables lemma entry true 
computed answer goal extracted table entry true follows computed substitution correct 
clause shows general completeness fxg 
notice query computed answer function call nonterminating correct answer fz fgg element set lattice 
functions interpreted total functions declarative semantics 
incompleteness arises diverging nonterminating computations practical problem paradigm 
memoization detect nontermination due circular function calls 
due undecidability halting problem devise operational semantics detects forms nontermination 
operational semantics general stratified programs operational semantics general stratified programs require just memoization main addition strongly stratified programs processing functional constraints 
start simple example flattened form serve illustration point 
example 
consider function definitions 
note monotonic respect subset ordering 
show steps derivation top level query ans goal sequence substitution memo table ans oe ans ff fm fm ff fm fm ff fm derivation find elements goal sequence sets fm fm refer set functional constraint functions appear functional constraint monotonic 
note argument monotonic function step remains nonground goal processed 
general need provision defer functional constraints combine related constraints solve resulting set unit appropriate stage derivation 
develop operational semantics starting formal definition functional constraint 
definition 
functional constraint set simple goals ff delta delta delta monotonic lub variables possibly ground term 
furthermore form delta delta delta jm fx jm fx ground term occurs say functional constraint simple 
fx jm empty just definition 
functional constraint ff delta delta delta define level defines ng 
notion minimal substitution required approach see 
definition function ars refer domain substitution 
definition 
substitutions define ars ars set substitutions say substitution minimal minimal element set ordered defined 
proposition 
simple functional constraint correct answer 
proof suppose functional constraint form ff delta delta delta domain assumption complete lattice 
cartesian product theta theta taken times defines complete lattice 
induces monotonic function 
clearly correct answers fixed points fx correct answer iff fixed point complete lattice monotonic fixed point answer desired 
definition note continuous fixed point computed iterative procedure 
develop procedure 
definition simple functional constraint ff delta delta delta computed answer procedure oe fx repeat oe oe fx sg computed answer definition oe return definition need obtain computed answer basic goal definition 
definitions mutually recursive recursion founded monotonic functions constraints strictly lower levels 
define derivations strongly stratified programs allowing goal sequence include functional contraints basic goals reduction relation 
definition 
general stratified program define reduction relation follows 
element remaining goal sequence 
defined follows reduce form table lub reduction wrt quadruple fy delta delta delta 
define fx sty delta delta delta ty delta delta fg 
table lookup form define fx wg occur fx ty gamma ty assuming form ty gamma tx ym defer constraint functional constraint delta delta variable say occurs define delta delta solve constraint functional constraint case delta delta functional constraint common variable computed answer definition 
definition defer constraint operation ensures related functional constraints involve common variables combined 
definition 
extended initial goal terminates final extended goal 
define computed answer follows 
oe ground computed answer fx sg 
oe simple functional constraint computed answer computed answer definition 
extended goal program computed answer modulo renaming variables 
continue derivation shown example starting step derivation 
goal sequence substitution memo table fm ff fm ff fm ff fm gg fm ff gg ff gg derivation defer constraint operation case definition performed step causing functional constraint fm placed fm 
step functional constraint solved definition 
proposition 
computed answer simple functional constraint correct answer proof definition computed answer definition computed answer definition 
level lower level induction level program know computed answer correct 
procedure terminates substitution computed correct prove soundness operational semantics general stratified programs 
need general definition table invariance strongly stratified programs 
definition 
general stratified program 
extended goal correct answer 
said table invariant condition holds entry form delta delta delta delta delta delta ground occurs fs delta delta delta phi fx delta delta delta ff non initial border set border set chain function phi defined 
definition say proposition 
lemmas analogous lemmas respectively 
need change strongly general correct answer correct answer statements new lemmas 
lemma general stratified program 
extended goal correct answer 
table invariant entry table form delta delta delta tx delta delta delta tx ground term ground term 
proof analogous proof lemma 
lemma general stratified program extended goal extended goal derived relation invariant 
proof proof induction founded order imposed level program 
reduce table lookup cases lemma 
new cases solve constraint defer constraint consider 
defer constraint step merely reorganizes goal sequence easy see invariant maintained 
consider solve constraint step 

simple level remaining goal sequence 
definition follows computed answer proposition correct answer correct answer agree respect variables reduction step introduce new variables statement immediately true 
theorem soundness general stratified programs general stratified program oe extended initial goal terminates final extended goal 

computed answer correct 
proof similar proof theorem show induction table invariant induction step follows lemma lemma 
table invariant final variables 
lemma follows entry true 
computed answer goal extracted table entry true follows computed substitution correct 
monotonic aggregation show section paradigm partial order programming ideally suited formulation database queries especially recursive aggregate operations 
purpose introduce conditional partial order clauses terms expression condition terms expression condition variable expression occurs terms condition condition general conjunction relational equational goals defined follows 
condition goal goal condition goal terms terms terms term predicate appearing terms extensional database predicate defined ground unit clauses 
formed program satisfies generalized local stratification condition section 
declaratively speaking meaning conditional clause ground instantiations partial order asserted true condition true 
procedurally condition processed expression evaluated 
literals condition processed left order 
new variables appear condition left hand side require left right processing functional calls terms negated goals terms result ground arguments 
requirement necessary functions reduction narrowing equation solving functional languages negation failure may unsound nonground arguments 
note compiler perform groundness analysis order certify formedness programs check incorporated compiler 
conditional partial order clauses may may contrasted flattened form unconditional partial order clauses discussed sections 
unconditional clause form terms expression leftmost innermost order flattening expression produce sequence literals left right processing guarantee function called ground arguments 
conditional clauses automatically enjoy property 
reasons treat separately 
paradigm conditional clauses permits predicate definitions database facts feature paradigm unconditional clauses 
examples explain conditional partial order clauses 
table summarizes various forms clauses examples 
type partial order greatest element lub glb oe 
union lub max int 
min glb false 
lub implemented language flexible programmer declare function definition greatest element 
max int table chosen programmer suit problem hand 
possible syntax declaration follows function short max int possible principle user specify definitions lub glb operations current implementation support 
table min minimum integers 
may seen specifying greatest element similar notion defaults terminology sudarshan specifying lub glb corresponds notion firstorder aggregate operations sense van gelder 
furthermore inductive aggregates user definable restricted fixed set built aggregate operations 
example reachable nodes 
reach fxg reach reach edge program reformulation reach function section edge relation extensional database 
definition amenable efficient memoization argument reach constant set 
difference execution top level query program essentially identical program section 
example shortest distance 
short edge short short edge definition short similar reach aggregate operation min 
relation edge means directed edge distance non negative 
default distance nodes max int 
operator monotonic respect numeric ordering program defined 
logic shortest distance problem clearly specified program 
computational model reduction monotonically updatable memo tables provides better efficiency dynamic programming algorithm top control avoids solving unnecessary subproblems 
best control strategy shortest distance problem 
specifying underlying lattice ordering total ordering min distributes possible mimic dijkstra style shortest path algorithm 
annotations distribution discussed supported implementation support annotations specify total ordering 
example controls 
controls gt sum holdings holdings fs shares holdings fs shares controls true example illustrates inductive aggregate operation sum 
function controls returns true controls false 
relation shares means holds shares cyclic holdings possible may directly holdings vice versa 
see recursion aggregation controls sum ownership ownership companies controlled exceeds 
percentages non negative sum monotonic respect subset ordering 
function gt stands numeric greater monotonic argument respect ordering false true 
conditions satisfied defined semantics 
note default value controls false 
syntax programs section making fact composition monotonic functions monotonic 
clause controls gt sum holdings legal gt sum monotonic 
related partial order clauses lattice domains provide concise elegant means programming problems involving circular constraints aggregation 
problems arise deductive databases program analysis related fields 
language unconditional partial order clauses purely functional language provision conditional clauses shows clauses integrated extensional database relations 
resulting language seen functional query language 
elegance framework attested simple modeltheoretic operational semantics 
computational model partial order programs combines top goal reduction memo tables proven sound 
implementation partial order clauses carried moon program examples tested implementation 
main technical results providing model semantics partial order programs ii providing proof soundness operational semantics 
results novel model obtained standard intersection models logic programs soundness proof obtained standard induction length derivation 
development soundness proof difficult part research may regarded main contribution 
facilitate proof developed constructive description model theoretic semantics terms notion dependency graph function call 
needed devise suitable table invariant captured correctness derivation despite presence circular function calls 
function sum defined sum fg sum fs sum 
concept partial order programming closely related proposed parker seminal 
essentially paradigm program set clauses form continuous goal minimize parker presents number elegant examples illustrating paradigm 
high level essentially proposing 
important differences partial order clauses define functions clauses conditional non monotonic functions modulo stratification 
important features solving problems involving circular constraints aggregation best understanding discussed parker framework 
provided logical semantics set constructors logic programs shown set constructors behave finite sets zf set theory 
broader scope deals general structures just sets 
sets subset clauses important special case partial order programming framework 
declarative approaches sets includes structural recursion sets clp formulation sets 
basically structural recursion sets provides typed approach combining relational algebra equation functional programming 
contrast try combine extensional database relations partial order functional programming 
comparison clp approach finite sets note goal formalize semantics finite sets clp framework address formulation aggregate operations aggregation meta level concept respect standard clp framework 
distinguishing feature set constructor matches set gamma fxg 
ability form remainder set unique approach crucial writing recursive definitions 
related includes col ldl 
col ldl give semantics program ancestors parents ancestors direct translation clause partial order clause gives ancestors ancestors parents fz program similar reach example section strongly stratified 
defined semantics agrees provided 
allows atoms complete set terms right hand side clause belong lower level 
consider call strongly stratified programs 
considers set lattices provide operational semantics 
language flavor functional logic language important differences partial order clauses equational clauses functional expressions reduced matching narrowed unification 
provision partial order clauses memo tables crucial formulating monotonic aggregation features easily simulated functional logic languages nontrivial changes semantics 
recognize programming situations appropriate equations general relations partial orders compute cardinality set test set membership partial order programming framework described combined equational language defining functions ml language defining relations prolog 
integrated language called sure implemented practical tool prototyping applications involving sophisticated data querying 
acknowledgments research supported part national science foundation ccr 
abiteboul grumbach rule language functions sets acm transactions database systems 
aho ullman principles compiler design addison wesley 
breazu tannen buneman naqvi structural recursion query language proc 
rd intl 
workshop database programming languages 
beeri naqvi shmueli tsur set constructors logic database language journal logic programming 
dix framework representing characterizing semantics logic programs proc 
rd intl 
conf 
princ 
knowledge representation reasoning pp 

rossi embedding extensional finite sets clp proc 
intl 
symp 
logic programming pp 
mit press 
levi palamidessi complete semantic characterization leaf logic language functions proc 
th intl 
conf 
logic programming seattle pp 
mit press august 
hanus integration functions logic programming theory practice logic programming 
holldobler foundations equational logic programming lnai springer verlag 
semantics subset logic languages ph dissertation department computer science suny buffalo august 
jayaraman set constructors finite sets logical semantics appear journal logic programming 
jayaraman implementation subset equational programs journal logic programming 
jayaraman plaisted functional programming sets proc 
third intl 
conf 
functional programming computer architecture pp 
springer verlag 
jayaraman plaisted programming equations subsets relations proc 
american conf 
logic prog pp 
mit press 
kemp stuckey semantics logic programs aggregates proc 
intl 
symp 
logic programming pp 
mit press 
liu typed extension datalog sets tuples proc 
intl 
symp 
logic programming pp 
lloyd foundations logic programming ed springer verlag 
manna mathematical theory computation mcgraw hill publishers 
mendelson mathematical logic nd ed wadsworth 
michie memo functions machine learning nature 
moon implementation subset logic languages ph dissertation department computer science suny buffalo february 
semantics logic programs sets ph dissertation department computer science suny buffalo august 
jayaraman aggregation founded semantics proc 
th intl 
workshop non monotonic extensions logic programming pp 
lnai dix pereira przymusinski eds springer verlag 
parker partial order programming proc 
th symp 
principles programming languages pp 
acm press 
przymusinski declarative semantics stratified deductive databases logic programs proc 
foundations deductive databases logic programming minker ed pp 
morgan kaufmann 
ross sagiv monotonic aggregation deductive databases proc 
th symp 
principles database systems pp 
acm press 
sudarshan srivastava ramakrishnan beeri extending founded valid semantics aggregation proc 
intl 
symp 
logic programming pp 
mit press 
suppes axiomatic set theory dover ny 
van gelder founded semantics aggregation proc 
th symp 
principles database systems pp 
acm press 
warren prolog instruction set tech 
note sri international menlo park 

