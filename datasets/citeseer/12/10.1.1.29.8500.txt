computing accumulated delays real time systems rajeev alur courcoubetis thomas henzinger 
verification algorithm duration properties real time systems 
simple real time properties constrain total elapsed time events duration properties constrain accumulated satisfaction time state predicates 
formalize concept durations introducing duration measures timed automata 
duration measure assigns finite run timed automaton real number duration run may accumulated satisfaction time state predicate run 
timed automaton duration measure initial final state arithmetic constraint duration bounded reachability problem asks run automaton initial state final state duration run satisfies constraint 
main result optimal pspace decision procedure duration bounded reachability problem 
past decade model checking ce qs emerged powerful tool automatic verification finite state systems 
model checking paradigm extended real time systems acd hnsy afh 
description finite state system timing assumptions algorithms test system satisfies specification written real time temporal logic 
typical property specified real time temporal logics time bounded causality property response obtained pressed continuously seconds 
standard real time temporal logics ah limited expressiveness specify timing properties may want verify system 
particular allow constrain accumulated satisfaction times state predicates 
example consider duration bounded causality property response obtained pressed possibly intermittently total duration seconds 
preliminary version appeared proceedings fifth international conference computer aided verification cav lecture notes computer science springer verlag pp 
extended version appeared formal methods system design pp 

bell laboratories murray hill new jersey department computer science university crete institute computer science forth greece 
partially supported bra esprit project react 
department electrical engineering computer sciences university california berkeley partially supported onr yip award nsf career award ccr nsf ccr ccr afosr contract arpa nag 
specify duration property need measure accumulated time spent state models pressed 
purpose concept duration operators state predicates introduced calculus durations chr 
axiom system proving duration properties real time systems 
address algorithmic verification problem duration properties real time systems 
formalism timed automata ad representing real time systems :10.1.1.43.9418
timed automaton operates finite control finite number fictitious time gauges called clocks allow annotation control graph timing constraints 
state timed automaton includes apart location control real numbered values clocks 
consequently state space timed automaton infinite complicates analysis 
basic question timed automaton time bounded reachability problem initial state oe final state interval run automaton starting state oe state total elapsed time run interval 
solution problem relies partition infinite state space finitely regions connected transition time edges form region graph timed automaton ad :10.1.1.43.9418
states region equivalent respect standard questions 
particular region graph testing emptiness timed automaton ad checking time bounded branching properties acd testing bisimilarity states cer computing lower upper bounds time delays cy :10.1.1.43.9418
unfortunately region graph adequate checking duration properties duration bounded causality property runs start different states region may satisfy duration bounded causality property 
new technique needed analyzing duration properties 
introduce concept durations timed automaton associate finite run nonnegative real number called duration run 
duration run defined inductively duration measure function maps control locations nonnegative integers duration empty run duration measure location gives rate duration run increases automaton control resides location 
example duration measure means duration run stays unchanged time spent location accumulated duration measure means duration run increases rate time time spent location accumulated duration measure means duration run increases twice rate time 
time bounded reachability problem generalized duration bounded reachability problem initial state oe final state duration measure interval run automaton starting state oe state duration run interval 
show duration bounded reachability problem pspace complete provide optimal solution 
algorithm verify duration properties real time systems modeled timed automata duration bounded causality property 
briefly outline construction 
region final state path region graph show lower upper bounds durations runs start state follow chosen path written linear expressions variables represent clock values start state 
step provide recipe computing called bound expressions 
step define infinite graph bounds graph vertices regions tagged bound expressions specify set possible durations path final state 
final step show infinite bounds graph collapsed finite graph solving duration bounded reachability problem 
duration bounded reachability problem timed automata timed automata formal model real time systems dil ad 
automaton finite set control locations finite set real valued clocks 
clocks proceed rate clock measures amount time elapsed started 
transition timed automaton taken current clock values satisfy constraint associated transition 
taken transition changes control location automaton restarts clocks 
formally timed automaton triple components ffl finite set locations ffl finite set clocks ffl finite set transitions form source location target location clock constraint clock clock constraint positive boolean combination atomic formulas form clock nonnegative integer constant configuration timed automaton fully described specifying location control values clocks 
clock valuation assignment nonnegative reals clocks state oe pair consisting location clock valuation write sigma infinite set states time elapses values clocks increase uniformly time changing state state time ffi assuming transition occurs state ffi ffi clock valuation assigns ffi clock state may change transition transition taken state location clock valuation satisfies constraint 
transition instantaneous 
transition automaton state location new clock valuation clock associated transition reset value clocks remain unchanged 
possible behaviors timed automaton defined successor relation states transition successor states sigma transitions satisfies 

time successor states sigma time increments ffi ffi 
ffi 
state successor state written 
iff exists nonnegative real ffi ffi 

successor relation defines infinite graph state space sigma transitive closure successor relation called reachability relation true true sample timed automaton example sample timed automaton shown 
automaton locations clocks 
edge labeled clock constraint clock reset 
state automaton contains location real numbered values clocks sample pairs successor relation shown 







depending application timed automaton may augmented additional components initial locations accepting locations transition labels synchronization timed automata atomic propositions location labels 
useful label location clock constraint limits amount time spent location hnsy 
chosen simple definition timed automata illustrate essential computational aspects solving reachability problems 
standard definition timed automaton allows possibly empty set clocks reset transition 
requirement precisely clock reset transition affect expressiveness timed automata 
clock regions region graph review standard method analyzing timed automata 
key solving verification problems timed automaton construction called region graph ad :10.1.1.43.9418
region graph timed automaton finite quotient infinite state graph retains information answering certain reachability questions 
suppose timed automaton equivalence relation states sigma oe sigma write oe sigma equivalence class states contains state oe 
successor relation extended equivalence classes follows define oe iff state oe oe state nonnegative real ffi oe ffi nonnegative reals ffi oe oe 
quotient graph respect equivalence relation written graph vertices equivalence classes edges successor relation 
equivalence relation stable iff oe states oe oe state oe back stable iff oe states state oe oe oe quotient graph respect back stable equivalence relation solving reachability problem equivalence classes equivalence classes state oe state oe 
equivalence relation back stable answer reachability problem affirmative iff path quotient graph region graph timed automaton quotient graph respect particular equivalence relation defined 
largest constant clock compared clock constraint ffi denote integral part ffi ffi denote fractional part ffi ffi ffi 
freely constraints bxc clock nonnegative integer constant clock valuation satisfies constraint bxc iff bc 
states region equivalent written iff conditions hold 

clock bc bd 
clocks valuation satisfies iff valuation satisfies 
clock valuation satisfies iff valuation satisfies 
clock region sigma equivalence class states 
region fully specified location integral parts clock values ordering fractional parts clock values 
instance contains clocks region contains states satisfies 
region write bxc say location satisfies constraints bxc finitely regions exact value integral part clock recorded smaller number regions bounded jsj delta delta 
delta pi jx number clocks 
region graph timed automaton finite quotient graph respect region equivalence relation region equivalence relation stable back stable ad :10.1.1.43.9418
region graph solving reachability problems regions solving time bounded reachability problems acd 
useful define edges region graph explicitly 
region boundary region iff clock satisfies constraint 
region boundary region called open region 
boundary region define predecessor region pred open region states time increment ffi ffi nonnegative reals ffi similarly define successor region succ open region states time increment ffi gamma ffi nonnegative reals ffi gamma state timed automaton belongs boundary region instantaneously 
just instant state belongs pred just instant state belongs succ 
example boundary region bxc pred open region bxc succ open region bxc edges region graph fall categories transition edges 
edge region region time edges boundary region edge pred edge succ 
addition region self loop ignored solving reachability problems 
duration measures duration bounded reachability duration measure timed automaton function locations nonnegative integers 
duration constraint form duration measure bounded interval nonnegative real line endpoints integers may open half open closed 
duration measure extend state space evaluate integral runs extended state pair oe consisting state oe nonnegative real number 
successor relation states extended follows transition successor extended states transitions satisfies define 

time successor extended states time increments ffi define ffi 
ffi ffi delta 
consider duration bounded reachability problem regions regions timed automaton duration constraint state oe state nonnegative real ffi oe 
ffi 
refer duration bounded reachability problem tuple 
example recall sample timed automaton 
suppose duration measure defined 
initial region singleton final region duration constraint answer duration bounded reachability problem affirmative sequence successor pairs justification component denotes value integral 






hand duration constraint answer duration bounded reachability problem negative 
reader verify 
ffi ffi 
duration measure constant function locations integral measures total elapsed time duration bounded reachability problem regions called time bounded reachability problem 
case oe 
ffi ffi states oe oe state real number ffi oe ffi 
region graph suffices solve time bounded reachability problem 
true general duration measures 
solution duration bounded reachability problem bound labeled regions bounds graph consider timed automaton regions duration measure determine set possible values ffi oe 
ffi oe compute lower upper bounds integral path region graph refine graph labeling regions expressions specify extremal values integral 
define infinite graph vertices form region linear expressions clock variables boolean values 
intended meaning bound expressions moving state state final region set possible values integral infimum supremum functions current clock values bit infimum included set possible values integral excluded 
similarly bit supremum included set possible values excluded 
example left closed right open interval gives possible values integral bound expressions associated region special form 
suppose fx set clocks states clock valuation satisfies delta delta delta clock smallest fractional part clock largest fractional part 
fractional parts clocks partition unit interval subintervals represented expressions gamma 
gamma gamma gamma gamma bound expression positive linear combination expressions bound expression form delta delta delta delta delta nonnegative integer constants 
denote bound expressions tuples coefficients write bound expression delta delta delta delta delta bound expression clock valuation write denote result evaluating clock values time advances value bound expression changes rate gamma region satisfies constraint boundary region coefficient irrelevant satisfies coefficient irrelevant 
henceforth assume irrelevant coefficients set 
bound labeled region timed automaton consists clock region bound expressions bits 
construct bounds graph duration measure final region vertices bound labeled regions special vertex outgoing edges 
define edges target edges bound labeled regions 
edges target correspond runs automaton reach state passing regions 
suppose open region duration measure location 
final region reachable state remaining gamma time units 
integral increases rate lower bound integral value states upper bound delta gamma 
lower bound possible value integral upper bound supremum possible values 
add edge bounds graph 
boundary region time spent bounds 
case add edge 
look paths reach final region passing regions 
edge region graph bounds graph exactly edge bound labeled region form bound labeled region form 
consider example understand determination lower bound corresponding bit upper bound bit determined similarly 
suppose fx zg boundary region satisfies labeled lower bound bit means starting state lower bound integral reaching state delta delta gamma delta gamma consider open predecessor region satisfies duration measure time edge region graph 
want compute lower bound label lower bound label starting state state ffi reached time ffi gamma ffi ffi gamma gamma ffi gamma gamma ffi gamma gamma ffi gamma furthermore state integral value delta gamma entering region new lower bound delta gamma delta gamma delta gamma delta gamma label 
see 
lower bound possible value integral depends original lower bound possible value integral starting bit labeling bit labeling consider boundary region successor region region satisfies time edge region graph 
reader verify updated lower bound label simplified boundary region 
see 
updated bit immediate delayed process repeats consider time edges consider transition edge region region resets clock assume region open duration measure satisfies consider state suppose transition happens time ffi ffi gamma state transition ffi ffi lower bound corresponding scenario value integral transition delta ffi added value lower bound state delta delta gamma delta gamma obtain value lower bound state need compute infimum choices ffi ffi gamma desired lower bound inf ffi gammax fb delta ffi delta delta gamma delta gamma substituting ffi ffi simplifies delta delta gamma inf ffi gammax delta ffi delta gamma gamma ffi infimum monotonic function ffi reached extreme points 
ffi transition occurs immediately value delta delta gamma delta gamma ffi approaches gamma transition occurs late possible value delta delta gamma delta gamma satisfies gamma gamma gamma lower bound label minimum see 
need deduce bit indicates lower bound possible value integral 
lower bound obtained ffi possible iff possible lower bound obtained ffi approaching gamma possible iff possible 
formally define edges bound labeled regions bounds graph 
suppose region graph edge duration measure bounds graph edge iff bound expressions bits related follows 
various cases consider depending edge time edge transition edge time edge boundary region pred open region largest index satisfies gamma gamma time edge boundary region succ open region transition edge boundary region open region clock th smallest fractional part reset transition edge boundary regions clock th smallest fractional part reset case illustrated 
completes definition bounds graph 
reachability bounds graph state oe bound expressions bits define bounded interval oe nonnegative real line follows left endpoint right endpoint interval left closed left open interval right closed right open 
lemma states fundamental property bounds graph 
lemma timed automaton duration measure region state oe nonnegative real ffi state oe 
ffi iff bounds graph path bound labeled region oe ffi oe 
proof 
consider state oe nonnegative real ffi 
suppose oe 
ffi definition region graph sequence oe ffi 
oe gamma ffi gamma delta delta delta 
oe ffi 
oe ffi 
ffi successors extended states oe oe ffi oe region graph contains edge region containing oe region containing oe claim exist bound labeled regions region component bounds graph edge ffi gamma ffi oe 
claim proved induction definition edges bounds graph 
conversely consider sequence bound labeled regions bounds graph edge 
claim oe ffi oe exists oe 
ffi 
proved induction definition edges bounds graph 
bound labeled region denote union oe oe intervals 
difficult check set bounded interval nonnegative real line integer endpoints 
left endpoint infimum choices clock valuations consistent inf rg 
irrelevant coefficients bound expression infimum equal smallest nonzero coefficient left point coefficients 
similarly right endpoint supremum choices consistent supremum equal largest coefficient type interval determined follows 

ffl left closed left open 
ffl right closed right open 
instance consider region satisfies 
open interval irrespective values lemma implies lemma timed automaton duration constraint regions states oe real number ffi oe 
ffi iff bounds graph path bound labeled region region component 
solve duration bounded reachability problem construct portion bounds graph special vertex reachable 
done backward breadth fashion starting final region particular path bounds graph region may appear different bound expressions 
infinitely distinct bound expressions backward search terminated finitely steps coefficients bound expressions sufficiently large relative actual values irrelevant 
shown section 
collapsing bounds graph nonnegative integer constant define equivalence relation bound labeled regions follows 
nonnegative integers define iff bound expressions define iff bound labeled regions define iff conditions hold 


coefficient greater 
coefficient greater lemma states equivalence relation bound labeled regions back stable 
lemma bounds graph contains edge bound labeled region region exists bound labeled region bounds graph contains edge proof 
consider bound labeled regions clock region 
clock region region graph edge unique bound labeled region bounds graph edge unique bound labeled region bounds graph edge remains shown cases consider rules edges bounds graph 
consider case corresponding transition edge 
corresponds case boundary region open region clock th smallest fractional part reset 
duration measure establish coefficient greater case upper bounds similar 

rule follows min min 
cases consider 
case recall boundary region 
coefficient equals gamma coefficient exceeds 
ii case follows values exceed coefficient requirement different 
cases iii iv similar analysis 
equivalence relation back stable checking reachability bound labeled regions bounds graph suffices look quotient graph lemma indicates suitable choice constant solving duration bounded reachability problem 
lemma consider bound labeled regions bounded interval integer endpoints 
right endpoint iff 
proof 
consider bound labeled regions easy check left points equal exceed see rules determining left point 
need show left points left open left closed 
trivially true 
suppose know coefficient exceeds left point smaller know nonzero coefficients 
case intervals left open irrespective bits similar analysis right points shows right points exceed equal intervals right open right closed 
bound expression constrained nonnegative integer iff coefficients 
clearly bound expression exists unique constrained bound expression fl fl 
bound labeled region constrained iff constrained coefficient coefficient 
bound labeled region exists unique constrained bound labeled region fl fl 
distinct constrained bound labeled regions equivalent follows equivalence class contains precisely constrained bound labeled region 
constrained regions represent equivalence classes 
number constrained expressions clocks region number constrained bound labeled regions form delta bound number clock regions obtain bound number constrained bound labeled regions equivalently number equivalence classes regions 
lemma timed automaton location set clock set number clocks clock compared constant larger nonnegative integer number constrained bound labeled regions delta jsj delta 
delta delta delta pi consider duration bounded reachability problem right endpoint interval lemma number constrained bound labeled regions exponential length problem description 
combining lemmas obtain exponential time decision procedure solving duration bounded reachability problem 
theorem right endpoint interval answer reachability problem affirmative iff exists finite sequence constrained bound labeled regions 
bounds graph contains edge bound labeled region fl 
bounds graph contains edge bound labeled region fl 
clock region constructing backward breadth fashion portion bounds graph special vertex reachable need explore constrained bound labeled regions 
constrained bound labeled region construct predecessors number predecessors finite corresponds number predecessors clock region region graph 
predecessor constrained bound labeled region replaced equivalent constrained region fl 
duration bounded reachability property holds bound labeled region 
search terminates generating new constrained bound labeled regions answer duration bounded reachability problem negative 
time complexity search proportional number constrained bound labeled regions lemma 
space complexity search pspace representation constrained bound labeled region predecessor computation requires space polynomial length problem description 
corollary duration bounded reachability problem timed automata decided pspace 
duration bounded reachability problem timed automata pspace hard unbounded reachability problem clock regions pspace hard ad :10.1.1.43.9418
discussion solved duration bounded reachability problem specified clock regions 
construction solving related problems 
clear initial final region replaced specific state rational clock values specific location set clock regions 
instance suppose initial state oe final state duration constraint asked decide oe 
ffi real number ffi assuming oe assign rational values clocks choose appropriate time unit regions oe singletons 
follows duration bounded reachability problem rational states solvable pspace 
second example duration property decide 
real time system modeled timed automaton nonnegative integers want verify time interval length system spends accumulated time units set locations 
instance railroad crossing similar appears various papers real time verification algorithm check interval hour gate closed minutes 
verification duration property depends various gate delays minimum separation time consecutive trains requires accumulation time gate closed 
third final example recall duration bounded causality property 
assume location timed automaton labeled atomic propositions denoting pressed denoting response 
duration measure defined label 
labeling locations atomic propositions extended regions bound labeled regions 
desired causality property hold iff initial region final region labeled bound labeled region bounds graph path passes regions labeled duration bounded reachability problem studied independently 
approach taken quite different 
problem solved case discrete time transitions timed automaton occur integer time values 
shown cases discrete integer valued time dense real valued time answer provided conditions met clock constraints timed automata positive boolean combinations non strict inequalities inequalities involving duration constraint sided form 
requirement ensures runs timed automaton closed digitization rounding real numbered transition times relative arbitrary fixed fractional part ffl hmp 
second requirement rules duration constraints 
approach proving discrete time dense time answers duration bounded reachability problem coincide gives simpler solution admits duration measures assign negative integers locations 
requirements essential approach 
note timed automata single clock gives algorithm checking complex duration constraints different duration measures equipping timed automata duration measures general approach extends timed automata variables measure accumulated durations 
variables called integrators watches may advance location time derivative clock time derivative changing value 
clocks integrators reset transitions automaton constraints guarding automaton transitions test integrator values 
reachability problem locations timed automaton integrators undecidable ach single integrator cause undecidability 
cases practical interest reachability problem timed automata integrators answered symbolic execution automaton ach 
contrast integrators real numbered values part automaton state achieved decidability separating duration constraints system treating properties 
distinction strengthening model strengthening specification language duration constraints essential decidability resulting verification problem 
expressiveness specification languages increased 
example possible define temporal logics duration constraints integrators 
decidability model checking problem logics remains open problem 
model checking formula need compute characteristic set contains states satisfy formula 
particular initial region final state duration constraint need compute set states oe exists real number ffi oe 
ffi 
bound labeled region reachable bounds graph contributes subset foe oe general infinitely contributions possibly singletons know description decide model checking problem 
contrast discrete time characteristic sets formulas integrators computed bes 
dense time characteristic sets approximated symbolically 

sergio yovine careful reading manuscript 
acd alur courcoubetis dill 
model checking dense real time 
information computation 
ach alur courcoubetis halbwachs henzinger 
ho nicollin olivero sifakis yovine 
algorithmic analysis hybrid systems 
theoretical computer science 
ad alur dill :10.1.1.43.9418
theory timed automata 
theoretical computer science 
afh alur feder henzinger 
benefits relaxing 
journal acm 
ah alur henzinger 
logics models real time survey 
de bakker huizing 
de roever rozenberg editors real time theory practice lecture notes computer science pages 
springer verlag 
alur henzinger 
ho 
automatic symbolic verification embedded systems 
ieee transactions software engineering 
bes bouajjani sifakis 
model checking real time properties durations 
proceedings eighth annual symposium logic computer science pages 
ieee computer society press 
ce clarke emerson 
design synthesis synchronization skeletons branching time temporal logic 
workshop logic programs lecture notes computer science 
springer verlag 
cer 
decidability bisimulation equivalence parallel timer processes 
von probst editors cav computer aided verification lecture notes computer science pages 
springer verlag 
chr hoare ravn 
calculus durations 
information processing letters 
cy courcoubetis yannakakis 
minimum maximum delay problems realtime systems 
larsen skou editors cav computer aided verification lecture notes computer science pages 
springer verlag 
dil dill 
timing assumptions verification finite state concurrent systems 
sifakis editor cav automatic verification methods finite state systems lecture notes computer science pages 
springer verlag 
henzinger puri varaiya 
decidable hybrid automata 
proceedings th annual symposium theory computing pages 
acm press 
hmp henzinger manna pnueli 
digital clocks 
kuich editor icalp automata languages programming lecture notes computer science pages 
springer verlag 
hnsy henzinger nicollin sifakis yovine 
symbolic model checking real time systems 
information computation 
kesten pnueli sifakis yovine 
integration graphs class decidable hybrid systems 
grossman nerode ravn rischel editors hybrid systems lecture notes computer science pages 
springerverlag 
qs sifakis 
specification verification concurrent systems cesar 
dezani ciancaglini montanari editors fifth international symposium programming lecture notes computer science pages 
springer verlag 

