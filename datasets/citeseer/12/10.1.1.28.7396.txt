siam comput 
society industrial applied mathematics vol 
pp 
balanced allocations yossi azar andrei broder anna karlin eli upfal 
suppose sequentially place balls boxes putting ball randomly chosen box 
known done fullest box high probability ln balls 
suppose ball choose boxes random place ball full time placement 
show high probability fullest box contains ln balls exponentially 
furthermore show similar gap exists infinite process step ball chosen uniformly random deleted ball added manner 
discuss consequences related theorems dynamic resource allocation hashing line load balancing 
key words 
urn models occupancy problems line algorithms resource allocation hashing load balancing ams subject classifications 
pii 


suppose sequentially place balls boxes putting ball randomly chosen box 
properties random allocation process extensively studied probability statistics literature 
see 
classical results area asymptotically process terminated high probability probability fullest box contains ln ln ln balls 
gonnet proven accurate result 
consider variant process ball comes possible destinations chosen independently uniformly random 
destinations necessarily distinct 
ball placed full box possible locations 
surprisingly process terminates fullest box ln ln ln balls 
apparently minor change random allocation process results exponential decrease maximum occupancy location 
analysis process summarized follows theorem 
suppose balls sequentially placed boxes 
ball placed full box time placement boxes chosen independently uniformly random 
balls placed high probability number balls fullest box ln ln ln received editors july accepted publication revised form august published electronically september 
www siam org journals html department computer science tel aviv university tel aviv israel azar math tau ac il 
research supported israel academy sciences 
digital systems research center lytton avenue palo alto ca broder src dec com 
department computer science university washington seattle wa karlin cs washington edu 
ibm almaden research center san jose ca department applied mathematics weizmann institute science rehovot israel eli wisdom weizmann ac il 
weizmann institute supported part norman cohen chair computer science 
balanced allocations particular high probability number balls fullest box ln ln ln line strategy places ball randomly chosen boxes results stochastically balls fullest box 
interesting study infinite version random allocation process 
step ball chosen uniformly random removed system new ball appears 
new ball comes possible destinations chosen independently random placed full box possible destinations 
analysis case infinite stochastic process simple location ball depend locations balls system 
stationary distribution high probability fullest box log log log balls 
analysis case significantly harder locations current balls depend locations balls longer system 
prove stationary distribution fullest box ln ln ln balls high probability 
exponential gap holds infinite process 
theorem proven section 
theorem 
consider infinite process starting time arbitrary state 
constant fixed cn log log fullest box time contains high probability ln ln ln balls 
stationary distribution high probability box contains ln ln ln balls 
karp luby meyer auf der heide notice dramatic improvement switching hash function context pram simulations 
fact possible result derive weaker form static upper bound 
details see :10.1.1.28.7396
preliminary version appeared :10.1.1.28.7396
subsequently adler analyzed parallel implementation balanced allocation mechanism obtained interesting communication vs load tradeoffs 
related question considered broder 
model set choices placement results maximum load equal 
question analyze expected maximum load random order insertion greedy strategy 
results balanced allocation paradigm appeared 

applications 
results number interesting applications computing problems 
elaborate 

dynamic resource allocation 
consider scenario user process choose number identical resources line choosing server servers network choosing disk store directory 
find loaded resource users may check load resources placing requests 
process expensive requires sending interrupt resources 
second approach send task random resource 
approach minimum overhead users follow difference load different servers vary logarithmic factor 
analysis suggests mean strategy probability number balls fullest box greater probability number balls fullest box greater greedy strategy 
see corollary 
azar broder karlin upfal efficient solution 
user samples load resources sends request loaded total overhead small load resources varies log log factor 

hashing 
efficiency hashing technique measured parameters expected maximum access time 
approach suggests simple hashing technique similar hashing chaining 
call way chaining 
expected log log maximum access time 
random hash functions 
hash functions define possible entries table key 
key inserted full location time insertion 
keys entry table stored linked list 
assume keys sequentially inserted process table size shown section expected insertion look time analysis summarized immediately implies high probability maximum access time ln ln ln vs log log log time random hash function 
advantage scheme known techniques reducing worstcase behavior hashing uses hash functions easy parallelize involve rehashing data 
commonly schemes partition available memory multiple tables different hash function table 
example fredman scheme perfect hashing uses different hash functions get worst case access time line algorithm broder karlin uses log log hash functions achieve log log maximum access time line 
karp luby meyer auf der heide studied hash functions context pram simulations 
pram simulations multiple hash functions developed analyzed 

competitive line load balancing 
consider line load balancing problem set servers sequence arrivals departures tasks 
task comes list servers executed 
load balancing algorithm assign task server line information arrivals departures tasks 
goal algorithm minimize maximum load server 
quality line algorithm measured competitive ratio ratio maximum load achieves maximum load achieved optimal line algorithm knows sequence advance 
load balancing problem models example communication heterogeneous networks containing workstations devices servers correspond communication channels tasks correspond requests communication links devices 
network controller coordinate channels channel heavily loaded 
line load balancing studied extensively worst case adversaries 
permanent tasks tasks arrive depart azar naor rom showed competitive ratio greedy algorithm log algorithm better 
temporary tasks tasks depart unpredictable times works azar broder karlin azar show algorithm competitive ratio algorithm better 
interesting compare high competitive ratios obtained inputs generated adversary competitive ratio randomly generated inputs 
results show reasonable probabilistic assumptions balanced allocations itive ratios permanent temporary tasks significantly better 
case permanent tasks set servers task executed small set constant size chosen random competitive ratio decreases log log log 
case temporary tasks assume time step randomly chosen existent task replaced new task fixed time ratio maximum line load maximum line load log log high probability 
details section 
definitions notation 
consider stochastic processes finite process infinite process 
finite process 
boxes initially empty balls 
ball boxes chosen independently uniformly random 
balls arrive placement algorithm decide line knowing choices available balls box put ball comes 
decisions irrevocable 
subsequently refer setup asa problem 
infinite process 
boxes initially containing balls arbitrary state 
example balls box 
step random ball removed new ball added new ball allowed go boxes chosen independently uniformly random 
placement algorithm decide line knowing choices available balls knowing ball removed time box put arriving ball 
decisions irrevocable 
notations random variables associated placement algorithm note state time refers state immediately placement tth ball 
called load box number balls box time resulting algorithm 
number boxes load time number boxes load time 
ha called height ball ball arrives time number balls time box ball placed 
words ball placed particular box height second ball height 
number balls height time number balls height time ai 
omit superscript clear algorithm considering 
constants chosen convenience attempts optimize 
algorithm greedy assigns ball box lowest load random choices 
superscript greedy 
basic intuition proofs follow simple pi available choices ball independent roughly average disregarding conditioning pi implies doubly exponential decrease pi 
course truth strongly dependent complex machinery required construct correct proof 
azar broder karlin upfal 
finite process 
notation denote binomially distributed random variable parameters start standard lemma proof omitted 
lemma 
xn sequence random variables values arbitrary domain yn sequence binary random variables property yi yi xi similarly pr yi xi pr yi pr pr yi xi pr yi pr 
turn analysis finite process 
follows omit argument process terminates 
interest clearer exposition start case general case theorem subsumes 
theorem 
maximum load achieved greedy algorithm random problem ln ln ln high probability 
proof 
choices ball independent pr ht nd ei event exposed 
clearly ei implies fix consider series binary random variables yt yt 
yt height ball despite fact number boxes load represent choices available jth ball 
clearly pr yt def pi 
apply lemma conclude pr yt pr pi 
observe conditioned ei wehave yt 
pr ei pr yt ei pr yt pr ei combining obtain balanced allocations pr ei pr ei pr pi pr ei bound large deviations binomial distribution formula see instance appendix inspires set pr pi pin 
nd choices holds certainty provided pin lnn 
follows pin lnn pr ei ei pr ei pr ei pr ei ei pr ei pr ei pr ei pr ei 
finish proof smallest nd lnn notice ln ln ln ne di di di pr lnn lnn lnn ei pr pr ei pr ei pr lnn pr ei 
pr lnn pr ln pr lnn ln pr lnn azar broder karlin upfal markov inequality pr ln nd pr lnn 
combining obtain pr ln implies high probability maximum load achieved greedy ln 
prove matching lower bound 
theorem 
maximum load achieved greedy algorithm random problem ln ln ln high probability 
proof 
fi event exposed 
time suffices say 
want compute pr fi fi 
aim range zt defined zt observe box tth ball placed load exactly time 
means choices ball pointed boxes load choice pointed box load exactly represent choices available jth ball 
pr pr pr pr pr pr pr view observation derive pr zt fi applying lemma get pr zt fi pr pi 
choose def pi 
nd pi 
pr np np see instance appendix follows pr pi provided pin ln largest integer holds 
clearly ln 
balanced allocations observe definition zt event zt implies fi 
view pr fi fi pr zt fi pr fi pr fi fi pr fi fi pr pr completes proof 
turn showing greedy algorithm stochastically optimal model assume ball destinations chosen uniformly random balls equal weight 
optimality preserved condition violated 
suffices consider deterministic algorithms randomized algorithms considered distribution deterministic algorithms 
say vector vn vector written permutations 
lemma 
positive integer vectors un ith unit vector proof 
sj sum largest components vector notice sj sj sj 
hypothesis sj sj 
prove lemma show sj sj 
fix sj sj sj sj 
assume sj sj 
cases consider case 
sj sj sj sj 
case 
uj ui 
uj ui follows sj sj sj sj sj sj 
case 
uj uj ui 
observe sj sj sj sj sj sj vj uj vj uj 
vj vj uj uj vj 
azar broder karlin upfal conclude vj uj vj uj sj sj 
repeating argument obtain vj uj vj uj vi ui sj sj sj sj 
set possible choices ball set sequences choices balls 
theorem 
line deterministic algorithm correspondence vector box loads associated greedy acting written vector box loads associated acting 
proof 
simplify notation assume 
proof larger analogous 
proof proceeds induction length sequence 
base case obvious 
assume theorem valid ft mapping fix sequence suffices show refine ft obtain correspondence possible step extensions loss generality boxes permutation ft ft ft 
choices ball 
define ft ft represents extension sequences 
clearly ft 
need show ft notice sequence extended step algorithm exactly component vector changes increases 
assume ft ft inequality follows lemma second due fact ft ft 
corollary 
fixed balanced allocations pr max ai pr max gi 
ready discuss general case finite process 
theorem 
maximum load achieved greedy algorithm random problem high probability ln ln ln 
proof 
start replaying proof theorem account fact balls 
ei event define pi nd proof theorem derive pr ei pr pi pr ei suppose value set em show ex holds high probability di continuing obtain pr 
em di pr ln 
remains shown taken ln ln ln 
assume increasing function ln ln ln 
claim take em 
consider placement algorithm denoted puts ball box corresponding choice offered 
entirely equivalent case classical occupancy problem 
load box process binomial random variable probability load box exceeds em bounded consider height tth ball denoted probability box tth ball placed load greater em expected number balls height em satisfies markov inequality pr em 
claim theorem implies em em em pr pr azar broder karlin upfal suppose outcome greedy exactly boxes load greater equal proof theorem boxes 
ft corresponding outcome algorithm permutation ft ft ft 
ft theorem implies ft 
considering outcomes obtain 
pr em pr em em em pr em pr em em em em satisfied 
remove assumption simply imagine number balls increased max nw 
corresponding value max nw ln ln ln 

infinite process 
section consider infinite process 
analogously theorem possible show greedy algorithm minimizes expected maximum load box 
analyze performance 
main theorem section 
theorem 
assume infinite process starts arbitrary state 
greedy constant fixed cn log log pr ln ln ln 
stationary distribution maximum load ln ln ln high probability 
proof 
simplicity presentation state prove results 
proof assumes time cn log log process arbitrary state cn log log loss generality 
balanced allocations definition process number balls height change time step 
random variable viewed random walk integers proof bounding maximum values taken variables studying underlying process 
define integer decreasing sequence follows log log smallest log 
clearly ln ln ln 
observe define increasing sequence times ti ti 
ti log log 
denote event similarly denote event define events ci follows ci ti 
note holds event implies ti shall prove inductively pr ci implies event ti occurs probability high probability ln completes proof main part theorem 
show stationary distribution pr log log 
set states log log 
state chain time previous observation implies pr 
stationary distribution pr jo azar broder karlin upfal completes proof theorem assuming 
prove show conditioned ci high probability time ti 
shown lemma time high probability larger 
shown lemma facts imply ci holds high probability ti ci holds 
base case 
base case straightforward pr pr 
induction 
suppose pr ci 
state time easy verify bounds underlying transition probabilities 
pr pr obtain transition probabilities satisfy view clearly pr def pr def qi define new binary random variables follows xt iff yt iff pr xt pr yt define fi event fi event fi balanced allocations def ti ti fi ti ti 
lemmas necessary order conclude pr ci lemma 
inductive hypothesis pr fi ci proof 
notice conditioned ci sum ti ti xt number times increased interval ti ti similarly interval ti ti yt equals number times decreased interval 
conclude pr fi ci pr yt ti ti ti ti pr ci pr ti ti ti ti xt yt ti ti ci xt view lemma chernoff type bounds imply pr xt pr pr ti ti yt constant hand view conclude pr pr fi ci pr ci constant inductive hypothesis ci completes proof 
lemma 
inductive hypothesis pr ci ci fi 
azar broder karlin upfal proof 
pr pr get pr ci ci fi pr ci fi ci pr ti ci pr ci ti ti pr ci pr ti xt pr yt ci xt fix 
consider cases 
pr xt log pr xt en log yt 

log large deviation bounds fact log obtain pr yt pr xt eq log proof case fact log cases pr xt yt induction hypothesis pr ci ti balanced allocations pr xt yt returning proof induction hypothesis lemmas law total probability complete induction follows pr ci pr ci ci pr ci pr ci ci pr ci apply ih pr ci ci pr ci ci fi pr fi ci apply lemma pr ci ci fi pr fi ci apply lemma 
hashing 
define simple hashing algorithm called way chaining analogy popular direct chaining method 
random hash functions 
key hash functions define indices table 
table location contains pointer linked list 
new key arrives compare current length lists associated key key inserted shortest list 
direct chaining method corresponds having associated random index 
searching hash values computed linked lists searched alternate order 
checking ith element list check ith element second list element list 
shorter list exhausted continue searching longer list exhausted 
fact deletions allowed checking element longer list 
analysis immaterial 
assume keys sequentially inserted process table size theorem analysis implies high probability maximum access time bounded twice length longest list ln ln ln versus log log log time random hash function 
generally keys stored table hash functions maximum access time scheme ln ln ln 
show average access time way chaining twice average access time standard direct chaining method 
customary discuss average access time separately successful searches unsuccessful searches 
denoted bounded twice expected cost checking list chosen uniformly random 
successful searches cost cg cg hi azar broder karlin upfal notations section 
know eventually decreases doubly exponentially bound cg inequality cg achieve better bounds majorization theorem 
start 
lemma 
vn un positive integer vectors 
lemma special case known theorem majorization see completeness proof 
proof 
vector denote inner product 
consider linear program maximize subject 
easy check feasible point optimal solution 
consider program objective function 
feasible point optimal solution 
consider standard direct chaining method 
terminology corresponds random placement algorithm known cost successful search direct chaining ex 
cr applying lemma obtain cost successful search way chaining satisfies cg 
competitive line load balancing 

preliminaries 
line load balancing problem defined follows 
set servers machines supposed run set tasks arrive depart time 
task associated weight load arrival time set servers capable running 
distinguish variants problem case permanent tasks tasks arrive depart case temporary tasks tasks depart system time unknown advance 
soon task arrives assigned exactly servers capable running assigned transferred different server 
assigned server starts run task immediately continues run task departs 
balanced allocations task arrives assignment algorithm select server assign task 
load server time denoted la sum weights tasks running server time assignment algorithm sequence task arrivals departures time arrival 
cost ca assignment algorithm sequence defined ca max la 
line assignment algorithm assign arriving task time server knowing past current state servers decision knowledge arrivals departures 
optimal line assignment algorithm denoted opt assigns arriving tasks knowing entire sequence task arrivals departures way minimizes cost 
worst case behavior line algorithm characterized competitive ratio defined supremum sequences ratio ca copt 
characterize average behavior ca resp copt expected cost algorithm resp opt sequences generated distribution competitive ratio line algorithm distribution defined ratio ca copt 
greedy algorithm formally defined follows 
algorithm greedy 
arrival task assign server current minimum load ties broken arbitrarily 

permanent tasks 
permanent tasks azar naor rom shown competitive ratio greedy algorithm log algorithm better 
bring problem framework results case task set servers run consists servers chosen uniformly random replacement number requests equals weights equal 
pd associated probability distribution request sequences 
lemma 
probability copt pd 
proof 
show high probability assignment cost case 
fortiori result true 
problem reduced showing random bipartite graph node random edges assignment value 
arbitrarily break pieces size 
show pieces contains perfect matching 
hall theorem probability assignment bounded probability set size pieces neighborhood size facto probability azar broder karlin upfal standard approximations binomial coefficients rewriting simplifying yield en en delicate analysis shows maximum load achieved line case high probability 
lemma 
high probability pd log log log proof 
proof follows immediately theorem 
obtain theorem 
theorem 
competitive ratio greedy algorithm distribution pd log log log algorithm better 
proof 
proof follows lemmas corollary 

temporary tasks 
temporary tasks results azar broder karlin azar showed algorithm competitive ratio algorithm better 
difficult construct natural distribution task arrivals departures 
approximation consider stochastic process tasks arrive task set servers run consists servers chosen uniformly random replacement 
repeats forever random task departs random task arrives may served random servers 
clearly infinite sequence eventually tasks served server trivial reasons competitive ratio long sequences 
state competitiveness result way theorem 
la maximum load server time tasks arriving stochastic process assigned algorithm la maxi la 
fixed high probability log log 
proof 
proof follows lemma theorem 
experimental results 
bound proven theorem term formula upper bound maximum load weak case practical values constant term dominates ln ln ln term 
experiments indicate case fact small values maximum load achieved substantially smaller maximum load achieved 
values considered increasing limited effect 
value ran experiments 
results summarized table 
balanced allocations table experimental maximum load 










acknowledgments 
wish martin dyer alan frieze greg nelson useful discussions 
adler chakrabarti mitzenmacher rasmussen parallel randomized load balancing proc 
th annual acm symposium theory computing pp 

alon spencer probabilistic method john wiley sons new york 
awerbuch azar plotkin throughput competitive line routing th annual symposium foundations computer science palo alto ca ieee piscataway nj pp 

awerbuch azar plotkin waarts competitive routing virtual circuits unknown duration proc 
acm siam symposium discrete algorithms siam philadelphia pa pp 

azar aspnes fiat plotkin waarts line routing virtual circuits applications load balancing machine scheduling assoc 
comput 
mach pp 

azar broder karlin line load balancing theoret 
comput 
sci pp 

azar broder karlin upfal balanced allocations proc :10.1.1.28.7396
th annual acm symposium theory computing montreal quebec canada pp 

azar plotkin waarts line load balancing temporary tasks algorithms pp 

azar naor rom competitiveness line assignments algorithms pp 

broder frieze lund phillips reingold balanced allocations azar broder karlin upfal tree inputs inform 
process 
lett pp 

broder karlin multilevel adaptive hashing proc 
st annual acm siam symposium discrete algorithms siam philadelphia pa pp 

randomized allocation processes proc 
th annual ieee symposium foundations computer science miami beach fl pp 

dietzfelbinger karlin mehlhorn meyer auf der heide rohnert tarjan dynamic perfect hashing upper lower bounds siam comput pp 

fredman koml szemer di storing sparse table worst case access time assoc 
comput 
mach pp 

frieze personal communication 

gonnet expected length longest probe sequence hash code searching assoc 
comput 
mach pp 

johnson kotz urn models application john wiley sons new york 
karp luby meyer auf der heide efficient pram simulation distributed memory machine proc 
th annual acm symposium theory computing victoria british columbia canada pp 

knuth art computer programming vol 
iii sorting searching addison wesley reading ma 
random allocations john wiley sons new york 
mackenzie plaxton rajaraman contention resolution protocols associated probabilistic phenomena proc 
th annual acm symposium theory computing montreal quebec canada pp 

marshall inequalities theory majorization applications academic press new york 
mitzenmacher load balancing density dependent jump markov processes proc 
th annual symposium foundations computer science burlington vt pp 

mitzenmacher power choices randomized load balancing ph thesis university california berkeley 
parallel balanced allocations proc 
th annual acm symposium parallel algorithms architectures padua italy pp 

