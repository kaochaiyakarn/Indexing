walkthru editor realistic effective interaction virtual building environments richard master project direction carlo computer science division department electrical engineering computer science university california berkeley november thesis describes development walkedit object placement editor berkeley architectural walkthru system 
addition incorporating editing operations commonly model editors new major results achieved 
system simple natural direct manipulation objects created 
system call object associations software framework provides unified method designing implementing convenient direct manipulation behaviors objects virtual environment 
combination nearly realistic behavior idealized goal oriented properties disambiguate mouse actions display screen appropriate natural object motion virtual world determine valid desirable final locations objects manipulated 
objects selected relocation actively look nearby objects structures associate align 
automated implicit grouping mechanism falls process 
concept structure implementation framework 
second realism walkthru real time rendering system enhanced addition physical simulation software 
set routines provides virtual user adjustable eye height dynamically maintained combination feedback control techniques discrete time physical simulation 
gives natural feeling moving building allowing user look walking permitting realistic stairs elevators 
separate experiment lin canny closest features algorithm fast contact force computation algorithm integrated object associations system allowing true collision detection pseudo static simulation moving objects 
implementation tradeoffs success experiment discussed 
contents background previous general interactive direct manipulation techniques hardware screen widgets constraint systems physics dynamics systems combined techniques virtual environment frameworks applications direct manipulation architectural environments walkthrough editor prototype selection transformations menu operations deficiencies prototype editor new walkthrough editor general transformation mode motivation having general transformation mode properties desirable general transformation mechanism desired manipulation process general transformation mode object associations overview relocation procedures association procedures stacking multiple associations interactive automated grouping user interface issues software engineering issues undo redo knapsack motivation creating knapsack knapsack mechanism event handling walkthrough unigrafix writeback motivation naming issues writeback process transformation consolidation realism motion manipulation simulated gravity physical object simulation motivation integrating lin canny algorithm collision detection moving objects contact force computation pseudo static simulation contact forces testing setup results extensions supporting modification structure hierarchical models virtual environments simulation training easy comprehensive modeling systems remain elusive difficult devise 
fact modeling problem provides difficulties rendering problem 
people frequently asked long take render picture 
rarely questions relating duration modeling tasks arise 
donald greenberg jan berkeley building walkthrough program walkthru intended provide user ability move real time models large buildings fully populated furniture 
goal realized conceptual design walkthru include techniques creating building model place 
modeling process base model berkeley new soda hall long difficult requiring months manual calculations determine precise floating point locations dimensions walls furniture 
building elements entered text files hand compiled unigrafix compiler pre processed visibility routines displayed screen 
result contained poorly placed walls objects intersected floated space 
problems resolved manually estimating errors object positions correcting numerical offsets text file 
entire hours long recompilation process repeated alignment problems inevitably visible requiring iterations modify recompile process 
level modern interactive technology reason model construction arduous text process 
thesis describes development walkedit interactive editor walkthru system allows users walkthru manipulate contents building models interactively virtual building environment 
walkedit project began years ago effort brown add standard editing operations walkthru environment 
new techniques added allow user pick move copy manipulate furniture objects interactively intuitively real time rendering environment original walkthru application 
interaction facilitated newly developed manipulation paradigm called object associations provides intuitive object behaviors 
influence object associations books cups move tandem desks stacked furniture slides floor floating air wall re orient move lie flush supporting walls 
user motion walkedit modified user virtual body behaves physically realistic fashion 
virtual body obeys set pseudo physical rules simulate normal movement buildings allowing user walk elevators naturally 
contribute great deal realism walkthrough experience 
experimenting enhancements dynamic simulation solid object interactions enhance realism usability user interface 
background previous creating fully equipped accurate model environment purpose graphics cad modeling arduous task 
assuming availability interactive geometry editor friendly efficient user interface tasks inherently difficult drafting editing dimensions 
portion section discuss challenges inherent direct manipulation task modern computer hardware approaches taken past meet challenges 
focus chosen problem domain manipulation architectural environment 
general interactive direct manipulation techniques hardware seemingly obvious solution problems direct manipulation displays degree freedom dof input devices 
approach eliminates mismatch dimensionality popular display input technology screens mice dimensionality virtual environment 
unfortunately level development technologies provide cost effective practical solution direct manipulation task 
current display technology tends rely crt shutter goggles head mounted stereo displays 
shutter goggles provide sense immersion virtual world give immediate perceptual benefit user move head realistically examine object different angles 
affordable head mounted displays slow poor resolution field view proximity eye 
tracker radius limitations wiring cords bulky heavy equipment physical interference user real body objects real world physically cumbersome 
dof input devices dataglove mice awkward extended period time expensive typical user 
tend lower sampling rates far higher noise jitter devices due limitations today tracking technology 
fundamentally fail solve problems placement 
precise placement objects dimensions hard real world get help physical conceptual interactions objects want place surroundings 
consider positioning picture frame millimeter front wall touching wall frame hands visual feedback satisfactory job 
noisy slow inaccurate tracker picture frame sink wall surface tactile feedback user quickly frustrated 
screen widgets due limitations displays dof devices great deal research directed software techniques manipulating objects standard low cost input output devices 
challenge approach design method controlling dof object user input 
direct manipulation solutions implicitly explicitly assume widget sets 
widget auxiliary graphical construct set axis aligned arrow handles rotation sphere added screen display object see examples widgets 
construct directly manipulated mouse move object clearly constrained way specific widget type 
olsen provide overview earlier widget techniques transformation rotation handles 
improved widgets removed hysteresis earlier crystal ball manipulator explored new specialized widget types brown widget classes deformation constraint linkages 
commercial direct manipulation systems true cad systems silicon graphics inventor modeling system widgets provide direct manipulation capabilities 
tendency widgets dominate direct manipulation legacy older direct manipulation problem established proven set constraints widgets provide easy easy generate direct manipulation interfaces 
implicit assumption techniques worked equally 
chen supports idea showing combination input devices widgets accurate harder modern dof input devices manipulation tasks 
latest widgets long way go widget set virtual environment rival completeness ui toolkit direct manipulation widgets application domain 
standard widgets perform manipulation tasks geometrically simple involving translations rotations clearly defined axes local global coordinate axes 
complex actions required widgets cumbersome widget set simple requiring user widgets sequentially simultaneously perform task widget set large complex requiring user find select set menus lists widget widgets appropriate situation 
widget sets inherit problems dof input devices fail consider interactions objects user performing manipulations generalized requiring multiple widgets actions conceptually simple manipulations 
attempt address shortcomings major categories direct manipulation techniques explored constraint systems physics dynamics systems 
constraint systems constraints second lasting theme manipulation design 
widgets attempt disambiguate mouse motion motion forcing user point auxiliary handles object constraints attempt perform disambiguation allowing user specify object object class level degrees freedom user permitted manipulate changes degrees freedom alter constrained degrees freedom 
allows system user identify particular object move attaching widgets 
furthermore constraints properly specified automatically take care local alignments dof manipulators widgets fail deal 
pictures backs constrained lie plane wall angle constrained vertical properly aligned dimensions user manipulate pictures position real degrees freedom parallel wall plane 
major problems approach documented 
constraint systems difficult solve interactive rates forcing designers limited solution techniques constraint sets provide functionality want 
improving techniques constraint solutions open mathematical problem outside scope thesis :10.1.1.54.763
second onerous task user manually specify maintain constraint networks needed direct manipulation 
just internal constraint structure needed create cube contains distinct constraint relationships number constraints necessary specify relationships objects average office large user may break individually order move objects 
attempted address problem 
brad myers attempts solve constraint maintenance problem having system try guess constraints user wishes impose ideally reduces problem matter user saying computer guesses 
unfortunately answering computers constant requests confirmation annoying system inevitably constraints sends user back manual entry 
takes different approach allowing user feed system snapshots configuration objects manipulated system infers applies possible constraints invalidated snapshot 
myers approach prone underestimation computer doesn guess constraint case user go back explicitly add 
likewise goes extreme overestimates 
snapshot system constrained completely user wishes break constraint deactivate constraints go cad mode move desired alignment take snapshot give system example re activate engine 
probably impossible create system automatically determine maintain constraints user situations systems object associations system attempt best possible guesses minimize amount dialogue necessary user correct computer assumptions guesses 
physics dynamics systems third major theme manipulation addition partial complete physics simulations force objects behave properly pushed pulled manipulated 
techniques attempt take advantage user real world intuition object user virtual hand applies force object 
interesting done determine aspects real world helpful direct manipulation virtual environments 
smith identifies balance functionality physical magic non physical behavior xerox parc virtual reality kit 
notes real world behavior comes free ui user familiar physical behavior real life needs little training virtual environment 
virtual magic tools eric bier snap dragging come learning curve requiring users familiarize new paradigm interacting objects 
figueiredo identifies fast collision detection critical physical aspect intuitive interaction virtual objects presenting usability results various techniques interacting objects collision detection toy environments 
important direct manipulation scheme address balance physical simulation magic approaches snap dragging 
purely physical system force user go unnecessary accomplish task easily expressed simple constraint example system allows users arrange furniture dropping items gravity simulation 
approach worked tables chairs books difficult affix pictures shelves walls 
physical simulation augments methods replace 
major problem physical dynamics systems tend limited small environments room objects order maintain interactive speeds 
relationship usability speed established order maintain usable frame rates interaction fastest modern cpus advanced simulation techniques 
available hardware software components powerful support dynamics extended interactive models :10.1.1.139.265
combined techniques virtual environment frameworks approaches combine subsets basic techniques provide complete structured direct manipulation system 
example van emmerik combines cad views constraints type widget provide complete solution dof positioning direct manipulation 
bier combines constraints snapping behavior widgets provide alignment solution direct manipulation 
methods advantage providing user ability manipulate objects mouse permitting precise relative positioning aligning lines planes geometries easily pure constraint system 
disadvantages van emmerik system cad style orthographic display necessary making unclear generalize techniques perspective window virtual environment systems suffer profusion modes auxiliary user familiar order perform basic manipulation tasks 
direct manipulation design efforts concentrate providing vr frameworks direct manipulation techniques embedded reasonable fashion 
unfortunately non trivial vr systems far interaction methods basic walkthru unc walkthrough various commercial walkthrough systems open interface supports attaching widgets widgets implemented nontrivial context 
virtual environment system fully supports direct manipulation nontrivial world 
applications direct manipulation architectural environments body direct manipulation mechanical architectural models relatively limited 
consider cad environments autocad direct manipulation interfaces tools manipulation numerical entry operations offset vectors constraint alignments offering natural manipulation building contents structure 
architectural environments offer number contextual advantages direct manipulation 
objects building tend specific context object dependent set valid positions environment 
example picture floats freely space rest sticking degrees room rests back flush wall surface 
likewise cups books common objects sit supporting surface 
users shown marked tendency comfortable restrictions placed manipulation object behave 
user interface study example describes users told lay chair side responding phrase chair 
advantage expected properties allow system better disambiguate user intentions better anticipate user needs limit command set easier user deal 
example applied system gleicher system provides intuitive method objects natural ways 
unfortunately requires extensive descriptions objects manipulated descriptions may defined terms limited set linear constraints interesting things defined simple objects lamps movements objects chairs cups normally involve plane plane constraints change depending moved place place capabilities system adapt new constraint types 
systems gotten problem going physical simulation virtual room construction software provides user dof tracked wand pointer objects picked dropped force enforces reasonable resting pose object 
unfortunately gravity system fails objects light fixtures supposed sit ceiling floor pictures likewise sit wall 
cases system forces user go back cad style non direct manipulation interface 
apple user interface research group provides easy approach degree parallels object association system 
series user interface studies attempt develop manipulation technique suitable arranging furniture virtual rooms 
identify number ease properties manipulating objects furniture virtual room including 
objects want move plane tables chairs floor plane pictures wall plane 

interactions furniture types translation aforementioned plane orientation rotating normal plane lifting stacking objects placing atop 

creating composite mode allowing easy access rotation plane normal translation plane allows users repetitive position adjustments smooth manner 

reducing number possible degrees manipulation freedom context specific constraints contributes ease user feeling control environment 
uses bounding box attached narrative handles iconic handles shapes represent handle action widget 
user manipulates object handles implicitly selecting manipulation mode chosen handle 
results mirror results object associations research 
extended research devising new techniques build precepts 
deal objects simple surface objects glosses user stack objects move piles objects 
solved problems providing flexible complete framework development additional context specific direct manipulation properties 
note systems mentioned toy environments small collection objects single room 
physical simulation systems slow dealing handful objects systems simply tested large environment 
important aspects walkedit project fact manipulating database built specifications real building results prove applicability techniques real world manipulation problems demonstrating robustness context large architectural model contains polygons objects 
walkthrough editor prototype brown wrote prototype walkedit masters project 
prototype attempted provide basic techniques direct manipulation detail objects walkthru model ended raising issues solved 
complex operations fully implemented initial approach user interface proved satisfactory 
simple transformations necessary basic editing operations worked constraint system operated properly intuitively 
objects move unpredictable manner cases detailed knowledge experience system required order perform simple tasks stacking books desk 
section discusses capabilities shortcomings original system provided basis discussion new solutions developed current walkedit environment 
selection object selected manipulated 
user holds shift key white bordered bounding box dynamically generated current object mouse pointer pointing 
box indicates exactly object chosen selection button pressed selecting small objects single object midst large number objects helpful feature 
user selects object shift left clicking view window 
selection point object highlighted small octahedron chosen visibility angle bounding box black 
user re grasps object shift click selection point changed newly indicated point 
multiple selection implemented alt key fashion shift key 
shift selection implicitly selected object objects 
alt selection simply toggles state object selected selected 
design allows user select sets objects 
user initiates manipulation selected object clicked focal object selection point group defined focal object 
transformations walkedit prototype special purpose modes rigid body transformations planar translation major axis plane crystal ball style rotation mode scaling mode see complement general transformation mode 
special modes specific constraint map mouse motion screen object motion model space 
major axis translation selection single multiple objects 
left plant selected note octahedron indicating selection point axis aligned hint lines 
right chair alt clicked add selected group chair focal object carrying selection point 
mode maps mouse motion screen motion selected major axis plane projecting ray eye point mouse pointer world 
ray intersected constructed plane parallel selected major axis plane passing initial selection point object moved selection point brought coincidence intersection 
resulting object transformation satisfies properties object translation vector lies axis plane selection point object remain coincident mouse pointer 
special transformation modes somewhat simpler crystal ball rotation mode maps motion mouse theta phi rotation object scaling mode maps motion mouse scaling object 
general transformation mode system applies special motion constraints dynamically depending mouse button drag object 
constraints mathematical manipulation mode widgets available walkedit 
left major axis translation mode handles visible chair middle crystal ball rotation mode handles shown right scaling mode handles applied 
motion handle user eyepoint screen motion plane initial cursor ray final cursor ray schematic drawing showing cup move major axis translation mode 
cup grabbed xy plane motion handle system moves cup parallel xy axis plane maintain coincidence handle mouse pointer ray 
note interaction cup objects table affect motion 
functional nature intended simplify manipulation specific types objects 
prototype implemented special constraints called horizontal designed objects normally sit floor objects vertical designed objects hang wall surfaces 
special constraints object selected motion plane established selection point 
motion plane horizontal plane parallel floor case horizontal vertical plane parallel nearby wall case vertical 
constraint forces object move motion plane way major axis translation mode moves object selected major axis plane 
special constraint move object motion plane certain circumstances 
horizontal object translation move supporting surface object special constraint add motion straight object rests nearby support surface 
vertical translation move object corner walls meet special constraint rotate motion plane parallel new wall rotate object back remains parallel motion plane 
special constraints automatically provide desirable alignments ordinarily applied manually objects desks books moved horizontal sit support pictures moved vertical rotate properly moved wall 
unfortunately special constraints suffered problems 
rules horizontal determine object move unintuitive buggy making difficult get objects align properly 
vertical prototype testing difficult 
routines hard coded system menus making difficult add change 
simple automated grouping mechanism accompanied special motion constraints 
applied object horizontal returned object identifier supporting surface selected object came rest 
user selected object general transformation mode system search local space applying special motion constraints objects vicinity try determine local objects sitting selected object 
objects grouped selected object moved 
motion plane user eyepoint screen user eyepoint screen mouse cursor rays mouse cursor rays horizontal general transformation mode 
left cup table selected moved surface point point dragging mouse cursor screen 
motion plane shown dotted line 
right cup moves point edge table point mode adds vertical component cup position fall floor point 
wall rays wall user eyepoint screen user eyepoint mouse cursor ray motion plane initial motion plane screen mouse cursor vertical general transformation mode 
left user selects picture system defines motion plane parallel nearest wall 
right user moves picture corner picture rotates new motion plane established new wall 
sees floor cup ray projection sees box ray projection box sees table user eyepoint screen table motion plane sees floor ray projection cup mouse cursor rays table ray projection automatic grouping process 
horizontal procedure projects ray cup downward hits floor procedure projects ray box downward hits tabletop procedure projects ray cup downward hits box table moved cup grouped box box grouped table box cup move table cup remains stationary 
menu operations prototype editor implemented operations available menus 
user toggle selecting objects face intersections bounding box intersections increase interaction speed 
simplified representations selected object transparent optimal expensive rendering technique wireframe bounding box allowed user adapt display slower computers 
user elect hint lines drawn selection point parallel major axes provide positioning feedback object moved 
toggle select scaling mode available normally scaling disabled rigid body transformation normal operation perform manipulating furniture real world 
exact positioning operations dialog allows object moved numerically entering offset values current position 
prototype copy button making multiple copies object 
user select object press copy time object moved copy object left location copy button pressed 
original copy available transformations 
simple undo function provided allowed user undo rigid body transformation 
deficiencies prototype editor ways prototype editor raised questions solved 
general transformation mode buggy wasn clear objects move major plane motion horizontal unpredictably stack unstack objects manipulation 
provision long distance motion objects 
order move chair side building user slide step step door hallway new room repositioning eyepoint step 
literally way move objects floors entering numerical offset object explicit transformation dialog box 
grouping mechanism unnecessarily duplicated large amount computation cache selection selection implemented batch mode forced user wait process finish object moved long heavily populated areas model 
copy place scheme caused number problems difficult error prone execute created problems grouping mechanism copy desk cup place copy desk cup grouped 
selection mechanism copy begins exactly aligned original point 
furthermore obvious objects position 
undo system incomplete undo single button drag operation usually inadequate 
prototype missing provisions writing changes run time model back original ascii unigrafix database model constructed 
rendered prototype essentially useless real tool changes editor propagated back building model 
prototype focussed attention crucial issues editor practical easy great deal research programming done 
new walkthrough editor lessons learned original prototype new editor developed 
major goals second generation walkedit 
wanted complete debug functions prototype 
second wished add new capabilities system useful intuitive 
third wanted increase realism walkthrough experience 
sections new methods algorithms implemented enhance functionality system tradeoffs explored transition old prototype new improved walkthrough editor 
general transformation mode motivation having general transformation mode editing done general transformation mode 
early stages development decided interface non modal possible system easier 
advantages choosing non modal modal interface twofold provide fewer commands user remember requires physical activity button presses menu selections execute commands 
designing intuitive non modal interface difficult non modal system carefully designed disambiguate terse form user input 
process developing non modal general transformation mode examined different methods helping user move objects input devices 
wanted process moving furniture virtual environment quick easy moving cut cardboard pieces floorplan 
possible force objects align nicely walls operator chooses option 
goal bring capability general transformation mode possible making straightforward task common alignments simple single mouse actions left click drag 
accept possibility general mode may able handle cases encapsulate majority actions user wish perform general mode succeed reducing effort required perform modeling tasks large percentage 
remaining minority operations handled traditional cad style object manipulation tools 
properties desirable general transformation mechanism balancing realism goal oriented behavior solutions direct manipulation problem literature 
unfortunately solutions overlook important aspect problem tradeoff physical object behavior teleological goal oriented object behavior user interface 
previous tends focus exclusion generalized vs constrained physical 
physical behavior involves properties gravity solidity experiences real world help disambiguate location object projection complete information 
example see top table floorplan know exact position table real world physically table sit squarely floor 
want position real table real room don worry pushing surface table force sit floor rely gravity handle dof push table sideways 
virtual environment include property unnecessarily added dof user explicitly control 
approaches snap dragging provide degrees freedom generality motion necessary task hand controlling extra dofs forces unnecessary cognitive overhead user aligning setting orientation frames grouping objects hand 
consequence treating objects wholly geometries 
build useful physical properties objects manipulating 
note properties primarily local come interactions objects proximity object moved natural effects gravity involve objects 
ideally manipulation paradigm allow take advantage expected properties avoid unnecessary user control overhead 
downside enforcing physical properties 
may remove certain unnecessary dofs user control simultaneously limit generality motions allowed 
user wishes place virtual grand piano virtual room shouldn worry fitting piano doorway 
cases may wish impose teleological physical behaviors objects 
behaviors treat object merely geometric entity providing actions convenient necessarily realistic 
certain operations simpler don worry strong move object introduce snapping behavior force objects align 
hand object behavior may making life difficult 
physical simulation methods system provide automated alignment table aligns floor forces torques caused mass automatic grouping objects table stay table moving friction effects objects behave expected ways 
conceptually simple operations difficult impossible 
example system allow pictures shelves moved attached walls physical simulation doesn allow unsupported objects modeling hooks system capabilities 
modeled reason force user go realistic procedures objects simple magical glue surfaces operation solves problem elegantly 
overly generalized mechanisms lose intuitive easy positioning mechanisms disambiguating knowledge learned children overly physical systems bring mechanisms back force deal problems real world computer get away 
try best worlds mechanism provide structure encourage interface programmer provide proper tension realism virtual world magic 
applying physical teleological balance walkedit walkedit primarily concerned keeping objects supported gravity having attached properly aligned ceiling walls vertical surfaces objects having objects aligned respect 
achieved remarkably small set physical paradigms motion 
key paradigms manipulation behavioral aspects objects building desirable populating soda hall model furniture summarized ffl user selected objects follow mouse pointer point place integral intuitive operation 
ffl objects typically float mid air rest supporting surface 
cursor points surface desk bookshelf implied user wants move selected object particular surface 
ffl alternatively things picture frames light fixtures attached walls vertical surfaces 
ffl implicit associations objects objects maintained object moves changed ways breakable objects lifted surface easily moved 
software engineering side key aspects general transformation mode ffl ease easy user assign behaviors objects classes objects 
furthermore easy programmer user create new behaviors 
ffl flexibility description behavior nearly easy encode behavior describe 
ffl generality desired behavior representable 
desired manipulation process general transformation mode generic editing operation interactive environment grab object place objects grouped 
walkedit user selecting object explicitly chooses object selection point object natural handle object manipulation 
object selection point established user apply local motion dragging mouse pointer remote operation picking object placing different location 
find useful match manipulation mechanism human natural tendency combination gross fine positioning 
human real world follows basic phases repositioning object 
object picked grabbed convenient handle 
second quick gross positioning step put large hand body motion get object place 
step characterized avoidance collisions physics intent get object vicinity goal position quickly easily possible 
third fine tuning step motion small motions applied adjusting final position allowing physical behavior gravity take hold object rest 
final step physical properties interactions applicable useful movement nears completion 
model manipulation derive similar phase process virtual world manipulation 
selection phase described 
implement teleological phase intermediate path object vicinity goal position direct possible relaxing physical restrictions follow goal oriented directive user 
object nears goal position pseudo physical phase object resting pose tuned realistic defined simulation constraints virtual environment 
shows example model handle task moving piano room 
piano piano piano get 
cares 
room hallway step pseudo physical interaction step teleological motion hallway room push wall slightly exaggerated example model object manipulation moving piano room 
left user selected piano teleological step move piano doorway 
user doesn care piano gets physical interaction useless actively annoying 
right piano close desired position pseudo physical step entered push piano inches wall 
step interactions gravity collision wall floor essential easily place piano flush 
non interactive motion admits similar solution teleological step consists user pointing location intent put object 
interpretation move object directly location warping regard physical obstructions trying lift gravity applying desired local physical behavior determine valid final resting position 
ability rotate object desired rotations generally preferred axis 
identify axis priori situation intuitive provide user simple click slide type rotation mouse offset directly proportional amount rotation 
object associations section describes software framework call object associations developed meet needs general transformation mode 
object associations support simple practical manipulation objects devices special types programmer supplied procedures implicit grouping behavior 
model gives programmer ability specify object dependent methods disambiguating gestures world allows association suitable local behavior database objects precise default placement easy 
associations usually fall physical simulations mathematical constraints formal flexible 
approach borrows heavily paradigms developed realm interactive computer graphics past decades 
notions snap dragging need explicitly dealing visible alignment manifolds alignments provided automatically association procedures explicitly user 
second emulate behavior physical simulation objects environment constraining day world objects pass remain physically impossible non equilibrium positions control suitable associations may application specific may depend editing mode :10.1.1.54.763
third associations described constraints system require rigid formality associated solution machinery mechanism editors underlying geometric constraint systems 
novel feature emerges naturally approach automated implicit grouping mechanism uses relationships established objects reposition respect environment 
overview object associations mechanism phase approach moving selected object 
relocation phase object follows trajectory free physical behavioral restrictions suitable disambiguation path specification screen space motion world space 
second association phase object uses possibly physical pseudo physical association rules determine nearby position best satisfies stated behavioral conditions object rest state 
object associations implemented types small procedures invoked object selected 
object assigned relocation procedure may number prioritized association procedures 
relocation procedure local interactive motion disambiguate gestures mouse pointer defines mapping incremental mouse motion incremental object motion 
association procedures local remote placement apply additional motion components object objects area order preserve desired object behavior 
addition objects dynamically link objects respect aligned typically follow movements objects 
object assigned relocation procedure may carry number ordered association procedures 
user add remove extra association procedures existing set selected objects interactive walkthrough mode 
object selected attributes determine relocation procedure applies object association procedures determine final placement object 
integrated procedures user interface layer controls major editing functions selection dynamic grouping dragging detailed placement 
far implemented relocation procedures horizontal procedure designed objects move primarily horizontally surface procedure designed objects attached potentially non horizontal support surface 
routines object moves piecewise continuous polyhedral manifold space specific shape manifold view object dependent 
left mouse button translates object manifold changing orientation relative manifold 
middle button rotates object line center bounding box normal manifold section object rests 
addition association procedures wall procedure pseudo gravity procedure anti gravity procedure wall procedure 
wall forces objects manipulated remain current view 
pseudo gravity simulates objects normally rest horizontal support surface 
anti gravity attaches light fixtures smoke detectors objects ceiling 
wall pictures white boards wall clocks objects hang vertical surfaces 
currently implemented walkedit association searches type ray probing mechanism find alignment objects 
ray probes find nearby objects affect alignment selected object 
relocation procedures local motion paradigm dragging object mouse basic editing move position object moving objects short distances 
user selects object moves mouse pointer desired direction 
generate frame motion animation relocation procedure called convert cursor position constrained position suitable auxiliary manifold depends type association carried selected object 
relocation procedure moves object manifold way selection point maintains coincidence cursor 
relocation procedure determines base motion relevant association procedures run determine additional motions object perform maintain desired behavior 
association procedures normally move object degrees freedom controlled mouse constraining motion desired may restrict motion surface manifold 
instance association procedure may force object move path dragged invisible rubber band mouse selection point 
user initiates interactive motion holding shift control key clicking mouse button relocation procedure called arguments corresponding current screen coordinates mouse user view frustum particular drag mode translate rotate selection point object original mouse screen coordinates object selected 
priori selection preferred dofs controlled directly unambiguously mouse parameter input device naturally reflect basic motion selected object 
simple invisible auxiliary dimensional manifold plane cylinder sphere established requirement auxiliary manifold projection view window maps points screen points manifold manifold typically go near selection point 
object moved mouse control way selection point stays manifold 
mapping cursor motion screen relocation selection point virtual world obtained intersecting cursor ray eye point auxiliary manifold 
gives intuitive behavior direct control object grabbed user selected handle follow projection mouse movement reasonable restricted manifold 
general manifolds piecewise continuous object move predictable local way small movements mouse 
shows example manifold surface procedure described look 
manifold horizontal procedure simply horizontal plane selection point 
translation mode eye cursor ray intersected plane equation original coordinate selection point 
ray plane intersection returns point procedure returns translation vector gamma rotation mode eye cursor ray ignored offset mouse pointer screen angle 
rotation angle plane normal returned 
surface uses complex manifold composed piece wise planar offset surface segments situated front faces visible surfaces scene 
translation mode procedure uses geometric database intersect eye mouse ray surface hits 
intersection point ray surface determined translation vector gamma returned initial coordinate selection point 
algorithm computes rotation angle manifold surface normal selection point new point returns rotation maintain orientation object back respect manifold 
wall follow changes wall orientation wall hanging moved corner rotation causes turn back new wall moves 
surface rotation mode simply rotates object normal manifold 
relocation manifold invisible region wall user eyepoint screen relocation manifold sight lines sight lines relocation manifold view frustum edge view frustum edge contribution invisible region contribution example relocation manifold surface relocation procedure 
dashed line shows edges view frustum 
dotted segments show piecewise planar segments visible portions walls contribute manifold 
solid rays show sight lines note wall surfaces contribute exactly visible user 
note version visible portions floor ceiling contribute manifold 
sliding object alignment manifold relocation procedure returns offset vector space representing difference original pose object selected new pose indicated mouse motion represents fundamental teleological motion intended user 
offset position passed association procedures object 
association procedures offset position association procedure needs find closest valid rest position orientation moving object object supposed obey particular behavior 
step find possible candidates alignment 
association procedures currently rely relocation manifold wall user eyepoint screen view frustum edge view frustum edge initial ray moved ray offset vector selection point moving picture surface relocation procedure 
user selected picture wall initial ray shows mouse cursor ray object selected selection point indicated intersection relocation manifold 
user moves mouse new moved ray intersected relocation manifold producing offset translation shown heavily dashed line rotation returned relocation procedure 
new location picture shown note rotation computed maintain picture orientation relative manifold surface normal 
ray projections 
pseudo gravity anti gravity cast rays vertically downward upward selection point respectively objects hit rays objects respect selected object position adjusted causing selected object fall respectively 
wall association casts rays major horizontal axis directions original definition object closest object directions alignment object falls sideways closest vertical surface 
pseudo gravity procedure pseudo code 
object changed height iteration project ray selection point object downward hit face object determine bounding box object smallest bounding box null visible drop bottom bounding box height lift bottom bounding box height top bounding box 
return total motion associate general procedure place selected object top user points combination visibility cues interference tests see section discussion visibility issues 
shows examples pseudo gravity operation 
anti gravity procedure objects stick ceiling surfaces identical pseudo gravity vertical directions reversed upward downward bottom top 
wall procedure additional assumptions 
object attach wall needs notion back side moved coincident closest vertical support surface 
soda hall object descriptions carry notion explicitly assume object defined back surface normal major horizontal axis directions object local coordinate system 
directions checked closest vertical surface pseudo gravity algorithm run corresponding axis 
user brings object soda hall environment needs placed close wall side supposed act back side 
similar reasons pseudo gravity pseudo procedures assume object defined bottom extreme negative local axis top extreme positive local axis respectively 
assumptions object defined allow procedures align object properly rotating object appropriate local coordinate system major axis parallel support surface normal object rest support surface moving object local axis aligned bounding box extrema touch surface 
move generated offset vector relocation manifold association procedures decide local fix motions new position implement desired local behavior object falling supporting surface case gravity 
association procedure computes local components motion commensurate desired object behavior 
motion generated association procedures may cause object change supporting manifold motion generated relocation procedure move object edge current support solid object 
association determined local objects forces affect motion selected object offset vector relocation procedure modified reflect local motion visible projected ray offset ray pseudo gravity association user eyepoint user eyepoint screen screen point visible pseudo gravity association offset ray user eyepoint screen user eyepoint screen user eyepoint screen point invisible projected ray point situations pseudo gravity 
upper sequence cup begins inches table view pseudo gravity casts ray finds table surface moves object 
lower sequence cup embedded block visible 
second frame association finds tabletop cup cup placed tabletop selection point invisible 
checking upward association finds top block closest valid support 
cup moved top block bounding box visible bottom resting top block 
back local coordinate frame local origin properly defined picture frame 
local origin back local coordinate frame improperly defined picture frame 
defining objects wall association object back normal major axis directions 
left back defined normal valid 
right back degree angle coordinate axes wall position object properly 
similar restrictions apply pseudo gravity objects bottom normal pseudo objects top normal rotation match surface normal initial ray projection determination resting point association procedures align object support surface object rotated bring appropriate major axis parallel support surface normal 
box comes rest ramp pseudo gravity 
association rotates box intersection point ray straight selection point ramp top face 
rotation calculated bring bottom box parallel contact support surface 
table association new floor user eyepoint screen user eyepoint screen motion plane association example object changing supports 
case cup moves edge table 
old support surface table determined ray projection straight selection point cup say cup associated table 
cup moved table ray projection indicates floor 
pseudo gravity adds necessary downward component motion drop cup floor cup associated floor 
new vector returned association procedure 
procedure may optionally return set new local associations selected object nearby objects help determine final position table supports cup 
associations implicit grouping mechanism see section determine objects grouped manipulated 
user motion releasing selected object new associations replace original associations effect object selected 
stacking multiple associations multiple association procedures may come play single objects 
example objects book cases supposed obey pseudo gravity simultaneously fit walls 
may reduce dofs object just zero 
case object may jump desirable location user moves mouse pointer association procedure selects closest location fits desired behavior 
multiple associations attached object type explicitly ordered 
corresponding procedures called chain receiving cumulative associations offsets generated 
systems programmer assigning combinations associations certain types objects consider possible interactions 
interactions potentially complicated associations described functionally mathematically association procedure conceivably 
difficult impossible object association framework generically resolve conflicts combinations procedures 
associations implemented walkedit simple orthogonal particularly tailored rectilinear axial environment soda hall interactions easy predict problematic 
individual adjustments associations gathered single cumulative transformation uniformly applied selected object dependent associated objects dynamically group 
shows associations pseudo gravity wall file cabinet 
shows flow control inputs object association mechanism output screen user eyepoint total screen user eyepoint screen user eyepoint returned pseudo gravity association vector step pseudo gravity second step wall association vector returned wall final position bookshelf association vector file cabinet pseudo gravity wall 
cabinet moved drops floor selected location upper left positions back indicated wall upper right 
result cumulative transformation satisfy associations lower right 
object relocation procedure association procedures 
input side user selects object upper box moves mouse pointer lower box 
selecting object launches implicit grouping search see section proceeds simultaneously operations 
original position object motion mouse sent relocation procedure uses initial position mouse motion determine offset sent chain association procedures 
association procedure modifies offset sends procedure outputting associations 
procedure outputs final motion object space applied list objects output implicit grouping search 
object space object space offset object motion database move current position pseudo gravity map pointer intersection manifold space screen mouse motion initial position selected object surface nearest vertical move object back wall association object object offset vertical surface set closest association object object output object space offset relocation procedure association procedures input offset screen space grouping search associated objects flowchart showing various procedures object obeys wall pseudo gravity 
interesting algorithmic question raised cyclic constraints arising mutual associations objects 
imagine placing wall objects back back middle room 
object associate forming cycle 
object selected object dynamically group want rigidly follow motion object object want move surface object association sees closest vertical surface 
objects moved away joint back back alignment plane 
similar situation may arise ceiling light attached table obeying 
current solution involves breaking loops detected point large object associates smaller object 
approach provides right feel building environment general answer problem 
interactive automated grouping basic principles walkedit selection performed shift clicking object 
may objects previously associated selected object objects positioned respect selected object moved 
example object identified pseudo gravity association surface selected object came rest 
position object influenced position selected object sense implicitly group maintain relative positioning object moved 
means associated objects grouped new object selected grouping maintained duration motion 
object multiple associations move objects moves 
moved cursor ray user eyepoint screen initial cursor ray initial cursor ray user eyepoint screen moved cursor ray implicit grouping 
blocks table assigned pseudo gravity association 
table moved upper picture blocks move associated table 
bottom block moved lower picture top blocks associated move table associated floor remains associations permanently maintained constraints applied object currently moved 
associations determined selected object potential objects opposite direction valid associations objects may change motion third unrelated object 
example alignment association concave objects may leave space third object inserted breaking previous association 
allow changes ensure robust behavior object association framework time object selected perform local search associated objects dynamically real time store separate data structure 
efficiency candidates objects known associated selected object previously checked 
general search started vicinity selected object relying cell spatial subdivision structure visibility precomputation observer tracking 
association procedures see called objects incident subdivision cells occupied selected source object see associated object returns set association links links form graph objects region 
search efficiently calculates local closure graph obtain group objects linked directly indirectly selected object 
keep virtual environment interactive response mouse directed motions instantaneous delay interactive manipulation original selected object carry association search background 
soon associated object subjected cumulative set manipulation transformations applied far source object 
approach somewhat startling effect user grabs moves fully loaded desk objects desk may remain suspended mid air catch new desk position seconds associated desk 
users quickly accept behavior 
minimize effect association closure graphs constructed cached memory moves group objects truly instantaneous 
closure process may safely interrupted closure complete user decides move chosen object selects different 
cache holds portion graph completed potentially useful saved time object area selected system simply pick search left 
implicit grouping mechanism replaces explicit grouping mechanism editors functional grouping resulting setting constraints objects 
mechanism keeps user focused actual positioning desired object automatically making grouping connections user hand classical methods 
furthermore breaking connection objects implicitly associated simple grasping dependent associated object moving new location point association old object broken new established 
course give user power override automatic grouping mechanism turning perform grouping manually alt clicking objects explicitly add subtract current group 
grouping mechanisms active simultaneously adding object group alt clicking add associated objects group 
dynamic gathering closure graph associations objects computed dynamic gathering algorithm 
basic dynamic gathering step takes input set selected objects cell explored objects associated selected objects 
association procedures object cell called turn determine objects may may cell object associated 
objects object associated list selected objects object added selected list 
objects cell explored fashion newly selected objects checked see lie partially cells cell cells searched run dynamic gathering algorithm process recurses cells new list selected objects 
termination algorithm results complete list objects associated sequence association links original set selected objects 
basic procedure coded called small steps 
dynamic gathering initiated function call sets data structures returns immediately 
user calls stepping function function returns value done point gathering example grouping search action 
dotted lines indicate subdivision cell boundaries solid arrows show associations objects 
table selected search begins rooted cell blocks cell table associations checked block associated table 
block cell cell added search queue causes block checked block association block adding cell queue 
cause blocks checked 
block block associated object group recursion terminates checking cell complete 
step computes associations single object callback may registered invoked time new object associated growing group 
done allow gathering backgrounded initiating gathering operating system event queue grouping step event inserted events called rate determined busy cpu handling user input 
user doing grouping gets cpus attention user trying manipulate growing group mouse events handled come grouping step executed mouse keyboard event handled 
caching associations early design dynamic grouping step obvious association graph closure performed determine objects group particular object discarded great deal useful information 
closure associations objects cell touched computed parts grouping closures objects 
users typically perform consecutive operations group cell room area database example setting desk office inefficient discard partial closures recompute scratch object manipulation 
mechanism devised efficiently storing partial closure information object data 
object contains pointers parent pointer child pointer sibling pointer 
parent pointer points object selected object associated 
sibling pointer points sibling circularly linked list objects associated parent 
child pointer points objects associated selected object 
selected object moved grouping search touches associations computed 
associations exist selected selected object parent pointer set associated object 
associated object child pointer traversed selected object linked sibling list 
way constant increase object size pointers bytes save association information computed grouping search object 
grouping search conducted time new object added selected objects list child pointer traversed gathering objects pointed child siblings children recursively 
objects simultaneously added list guaranteed associated selected object 
environment walkedit caching mechanism nearly caches entire set objects associated selected object causing desired group instantly selection 
simplifying assumptions heuristics basic assumption dynamic gathering algorithm relies correctness 
objects associated objects incident common spatial subdivision cell 
assumption reasonable associations constructed bring objects close contact pseudo gravity bring object contact support surface 
easy posit association procedures assumption invalid example consider procedure pushes objects specified distance wall 
algorithm needs improved handle cases 
consider assumptions set objects re manipulating object associated object object may slid associated objects break association 
assumptions association caching scheme outlined provably need touch database cell dynamic grouping algorithm 
assumption may asserted options menu walkedit active cells marked dynamic grouping step searches cell encountered grouping step ignored 
greatly accelerate average completion time dynamic grouping step user spends long time manipulating objects limited area 
common assignments association procedures objects simple pseudo gravity wall assumption default walkedit 
user interface issues start desirable paradigms see section define user interface object manipulation virtual world situations put principles conflict obvious right answer 
tricky problems raised section current solutions discussed 
limitations object associations paradigm reasonably expect simple relocation association procedures take care editing needs building environment 
expect user system deal dozens different sets procedures appropriate time 
goal solve problems direct manipulation single approach object associations tailored typically encountered operations easy natural 
special purpose editing needs access traditional editor functions pull menus 
needs exact rotation degrees opens rotation operator menu wants create perfect row chairs familiar replicate menu perfectly appropriate 
hand finds special task supported classical editor menu commands pushing furniture corners pays write new association procedure corner 
procedure probes directions finds closest objects wall alignments directions trying satisfy time 
frequently wants crowd furniture regular formations time develop accurate pseudo physical collision detection mechanism add collection association procedures 
depending types objects need manipulated may simply bounding boxes file cabinets may sophisticated algorithm handle concave objects needed grand 
currently experimenting prototype implementation collision detection routine lin canny algorithm quickly finds closest features pairs convex shapes :10.1.1.54.763
visibility information main cues disambiguate depth coordinate object manipulation intersection cursor ray visible support surface 
moving object obeying pseudo gravity typically grab near foot looking downwards supporting surface 
establishes relocation manifold reasonable intersection angle cursor ray gives user interactive control motion 
raises issue happen object dragged visible range support surface outside extent support altogether 
raises issue lift object support surface place book higher shelf 
illustrates typical situation 
possible slide coffee cup underneath table simply lift top table bounding boxes cup table start intersect 
visibility information pointing paradigm resolve issue 
long sight ray selection point clears table top cup stays floor 
part table cup floor cup intersecting table association procedure difficulties settling cup valid position floor 
ray intersects part table bounding boxes cup table intersect cup gets lifted top table 
association procedure relocation manifold screen user eyepoint key motion user relocation procedure selected cup dragged table 
visibility information determine rises tabletop 
solid arrows show user mouse motions dashed arrow shows relocation procedure moves object mouse motions dotted arrow shows position adjustment association procedure selection point obscured table edge relocation 
critical situation shown 
cup dragged edge table top non physical situation occurs 
resolved ways 
system try place cup cursor ray hits valid support surface 
ray may hit table top vertical surface lead useful answer 
sense give priority physical view world drop cup straight spot left table top floor acts new support surface 
situations interesting interplay teleological physical view virtual world visibility information intersection cursor ray particular object key relocation manifold user eyepoint screen motion user relocation procedure association procedure selected cup dragged table supporting surface 
cup falls lower surface 
additional cues infer intent user 
mouse cursor correspondence key paradigm desired user interface object follow cursor directly possible 
principle violated situations ones establishing physically valid position may result dramatic vertical adjustment 
long association procedure doesn add motion object relocation procedure usually maintains correspondence 
association procedure responsibility maintain connection mouse pointer selection point 
raises issue situations cursor stay user moved warped extra motion object association procedure 
generally preferable keep cursor point attached handle established selection point object consequence cursor object may disappear screen altogether 
consider situation cup moved back table cursor ray hits suitable support 
gravity procedure drop cup table possibly sight cursor may vanish floor lies lower edge viewport 
fall happens quickly user know cup cursor gone done bring back 
problems related fact association procedure mouse cursor position screen interested placing object valid local position 
direct relationship counterintuitive general case artificially force mouse cursor follow result association procedure adjustment object position 
user controls mouse cursor cursor move response user direct command 
furthermore relative motion mouse user control directly reflects motion relocation manifold primary method controlling object warp cursor association procedure correspondence cursor relocation manifold lost detriment user ability determine object move small relative cursor motion applied 
warp cursor follow results relocation association procedures information relative motion selection point mouse cursor user able determine object move response mouse input 
result decision object lost mouse pointer association procedure adds large offsets object position 
ensured redundant escape routes user situation 
bring object back view user move cursor back relocation manifold invisible cup moves back bounding box table jumps back table top object motion hysteresis see section details 
alternatively user may go new location cup visible continue moving current location floor table 
object totally lost readily brought knapsack selected placed directly current cursor position 
keyboard shortcut permits warp object directly possibly hidden position cursor position single ctrl click 
operation efficient way quickly populate room furniture 
takes mouse operations place object desired spot click select ctrl click warp neighborhood desired spot shift click drag operation fine tune final position 
hysteresis manipulation mouse cursor correspondence visibility problems contain question hysteresis interactive motion mouse pointer interactive motion moved point point screen moving object path space cursor moved back screen path object follow exact reverse path space follow different path 
furthermore object original position correspondence point object initial position lost soon mouse cursor moved 
question clearly evoked moving object edge table grab object table point move mouse cursor screen moving object table surface falls point 
object floor re associate object floor instant wait entire motion complete 
move cursor back screen object remain floor cursor ray obscured tabletop point return surface table demonstrates distinct hysteresis object floor tabletop mouse cursor reaches point 
hand re associate cup jump back table immediately cursor begins backtracking cup began motion position cursor motion resulted sliding table 
solution shows hysteresis cup follow precise path reverse returning cursor followed 
tests hysteresis cause confusion solved 
current object key relocation procedure association procedure mouse positions screen motion user observer view frustum relocation manifold selected cup moved back table falling completely view window 
mouse cursor simultaneously track selection point remain window boundaries 
user eyepoint screen motion plane motion plane hysteresis example effect hysteresis manipulating cup table 
suppose cup selected point mouse cursor ray mouse cursor moved screen cup reached point mouse cursor ray point cup dropped table point system dynamically re associated cup point requiring mouse cursor warped position association procedure cause user experience hysteresis moving mouse cursor back screen cup stay floor move point mouse cursor ray due fact selection point remain visible cup slides back table 
association procedure re associate mouse cursor remain position cup move position mouse cursor moved back position position cup follow original path backwards association system re associate objects current manipulation object completed user released mouse button 
means option backtrack object available provides subtle convenient trivial undo capability user undo motion simply moving mouse cursor back started 
software engineering issues flexibility extensibility providing desired object behaviors virtual worlds principle easy task 
problems concerning data structures efficient representations addressed order keep environment truly interactive 
creating cohesive framework object associations attempt keeping overhead concentrated place amortized easily systems programmer new object behavior introduced user flexibility easily choosing types behaviors object appropriate manipulation tasks hand 
descriptions association relocation procedures soda hall walkthrough look simple pseudo code 
important note pseudo code close level actual code implemented procedures 
walkthru program system provides rich set libraries including complete geometric computation package operates vectors rays points planes objects 
provides mechanisms easily search local area object objects find objects bounding boxes contain point quickly find object intersected space ray 
lines pseudo code convert lines actual code making implementation straightforward 
environment object associations naturally implemented additional routines language flexible powerful higher level geometric scripting language design 
implementing relocation association procedures object associations system coded walkedit designed easily accept new relocation association procedures caveat adding procedures current system requires recompilation walkedit program 
new procedures registered assigning unique identifying number adding name number prototype procedure header file 
done walkedit recompiled new procedure appear run time lists may assigned objects interactively line object properties file called necessary object association package 
relocation procedure called system converts mouse positions screen vector eyepoint relocation procedures operate object space screen space 
furthermore system chooses selection point object 
object directly manipulated user selection point original intersection point cursor ray object 
object directly manipulated example dynamic grouping test performed object editor run batch mode selection point defaults object center mass relocation procedure takes mouse position screen integer window eyepoint mouse vector space object selection point object mouse button pressed left right middle 
procedure return dof rigid body transformation 
initial dof rigid body transformation determined system builds special structure called association data packet adp 
adp data type represents current position associations object 
procedure query adp initial positions object selection point current position object selection point 
procedure wishes add motion object adp current position changed functions translates object rotates arbitrary axis 
changes propagated current positions stored adp 
association process system queries adp time get final transformation object 
adp contains information database cell object 
adp allows procedures modular making queries object current position easier making modifications position straightforward 
association procedure takes pointer adp 
applied necessary local position changes object adp procedure returns modified adp list new associations object local objects 
internally object association system provides piece local storage relocation association procedures freed object manipulations procedure local storage store information calls interactive motion 
example horizontal relocation procedure stores initial mouse screen manipulation began compute rotation difference current value original value mouse 
undo redo user manipulating large building database changes editing session inevitably mistakes vital editor kind allow user gracefully back bad operation 
prototype editor possible undo mouse operation done currently selected object 
new object selected done ability undo operation old object lost 
user undo entire motion object moved twice impossible undo second operation 
limitations due original construction undo procedure wrote script file transformations 
transformation object finalized mouse button released written script file script write log 
prototype undo operated storing old transformation matrix associated current set selected objects matrix initialized original position object selection time copied current position undo button pressed 
obviously storing matrix doesn take account renaming copying deleting objects operations undone prototype 
allow better undo capability necessary store transformations internally copying file 
linked list stores atomic transformations performed individual objects 
list written file user explicitly selects write script function file menu 
node keeps complete information perform undo operation designated node 
pair general routines take node input undo operation node 
undo operation simply strips node list undoes operation node reverses transformation deletes copied object deleted object 
list implemented infinite undo trivial time undo pressed node stripped undone 
structure supports straightforward redo operation redo simply takes undone node operation places node back undo list 
efficiency undo redo don perform specified operations completely 
example performing deletion delete object store complete copy geometries data comprising object undo list node 
object unlinked visibility list operation finalized writing database file user quitting editor object deallocated destroyed 
frees undo redo allocating deallocating copying data block structured binary database simply add subtract pointers visibility lists 
interaction groups objects node structure proved problematic 
efficiency representation undo node represents single transformation single object 
time user moving set objects single mouse motion 
undo button pressed user wishes undo single mouse gesture single atomic motion 
solve problem special marking mechanism called chunk marker added undo node 
undo button pressed nodes undone node chunk marker node node undone 
similarly redo button pressed nodes redone marked node encountered 
chunk marks inserted operation list user releases mouse button 
chunk marks system requires node classes transform copy delete rename node instance operating single object 
infinite undo redo system delete nodes undone 
user undo operation operations want operations disappear forever 
default delete nodes redo list permanently time new operation performed 
prevents user undoing operation pressing redo button find just accidentally redone move desk long ago 
conceivable user may want insert operation undo set operations perform modification modifications redo original set 
automated deletion redo list disabled explicitly rare cases behavior desired 
useful property new format scripts loaded saved independently writing changes database ug files 
new script format loaded editor redone binary walkthrough database 
scripts moves saved reloaded propagated back ug files time sent compact modification format applied binary ug databases 
system baseline parameterized macro operations databases 
knapsack motivation creating knapsack way move user viewpoint manipulating object 
prototype editor meant object translated point view 
moving object visible point straightforward select object drag warp 
unfortunately user wishes move object long distance say middle building terrace roof paradigm breaks 
requires iterations intermediate positions order get object roof may require extensive amount planning user get constrained object final position may require navigating stairs elevator object continually constrained closest available surface 
fact may possible move object arbitrary position dragging 
example object constrained vertical surface connecting wall points may way slide object wall surfaces get new position 
intent prototype editor copy button user select object copied press button menu 
selection object create copy object original location dragged mouse original 
problems arose approach 
naming problem copy called 
original program change copy name database maintained consistent manner copy unique name 
approach keep counter number objects type new copy name object number number incremented 
guarantees unique names requires maintenance large number counters reconstruction counters loading new database 
counter maintenance problem compounded script update scheme user create script session save script exit program leaving database unmodified 
user reloads database new modifications re counter numbers generated script subsequently re loads script conflicts names created new session names script 
conflicts exist regardless single global counter multiple class counters 
method generating unique names append random number count object type 
disadvantage guaranteed provide unique name requires counter maintenance large random number fail 
second approach implemented caused problems 
second problem paradigm 
copy performed method necessarily delayed copy object moved 
copy immediately appear inside exactly coincident original object impossible select reliably 
unfortunately means object store flag tells system object needs copied time moves 
flag checked object moved altered making code expand great deal 
user wanted copies count kept flag 
example user wish populate room full desks computer workstations 
nice paradigm select object press copy command multiple times strip copies put desk 
long distance transformations objects problem direct manipulation paradigm interact badly copy paradigm 
user wishes large number copies object place places 
placing desks empty floor example user grab desk replicate times room 
difficult object dragged position object type 
knapsack mechanism solution problems provide inventory knapsack user 
feature follows known cut paste paradigm common editing interfaces inventory paradigm common computer adventure games 
classical inventory user places objects infinitely large carries place place cluttering viewport 
walkthrough editor knapsack dialog box set buttons scrolling list 
object selected main window user click cut copy buttons knapsack window 
pressing cut button object disappears main window entry appears scrolling list name selected object 
objects grouped selected object removed view grouped objects stored internally identified selected object appear list 
copy button leaves selected grouped objects main window copies objects name copy selected object appears scroll box 
user add new objects defined external unigrafix files directly knapsack 
button knapsack menu allows user load unigrafix file containing number definitions instances objects 
class created definition object created instance inserted knapsack 
selection points set default center bounding box object 
loaded objects classes may normally 
user object knapsack name selected object appears scroll list object effectively removed database resides knapsack 
object retains original position selection point object association data tagged invisible intangible interacted way 
rename button allows user rename objects knapsack object name picked list new name typed 
called copy function rename newly copy 
deletion objects database accomplished similar fashion object group cut knapsack group selected list delete button knapsack menu selected destroys objects group 
user moves normal walkthrough fashion area group put view 
user select group objects scroll box press paste paste copy buttons remove group knapsack place back database 
procedures initiate object association warp operation selected object 
paste operation removes objects knapsack list re marks visible tangible 
paste copy produces set copies objects group warps set copies desired location 
originals left knapsack 
event handling walkthrough non interactive walkthru program multiple parallel processes improve frame rate 
initialization database manager launches secondary frame drawing process offloaded second cpu 
cull process generates cull frames data type includes pointers objects drawn frame plus necessary information view frustum eyepoint 
cull frames placed queue 
draw process operates queue rendering frame double buffer mode fetching drawing polygons specified objects 
process poses problems objects deleted time frame placed queue time frame drawn 
unfortunately modifications performed editor back queue cull process 
causes problems editor deletes object certain object referenced frame queue user probably looking object immediately deleting 
furthermore editor continually creates deletes shadow objects performing dynamic grouping searches 
interaction causes segmentation faults draw process attempts draw nonexistent objects 
solution quite simple disable separate drawing process 
obviously slows walkthrough slowdown generally perceptible 
better solution editor store objects deleted cull frame structure draw process finished drawing frame delete marked objects 
object appear frames frame deleted solves problem disabling separate draw process 
walkedit solution 
unigrafix writeback motivation editor virtual environment useless changes editor permanently entered database files represent environment 
propagation changes editor database nontrivial task walkthrough 
result fact walkthrough uses database formats binary unigrafix 
formats different purposes different ways 
basic format walkthrough database set floors 
floor represented set unigrafix ug ascii files special file describes walls floors file room major subdivision hallway describing contents room subdivision 
organization allows database construction preprocessing algorithms determine proper polygons spatial subdivision visibility computations file containing wall floor polygons 
serves localize room hall contents simplify manual modification database textual modification ug files 
note ug files store geometry organizational visibility information 
binary format running walkthrough stores objects packed data structures contains visibility spatial subdivision information needed real time interactive rendering 
database compiled wk binary file generated various ug files subdirectories 
single wk file run time database format editor standard walkthru program generating ug files take hours cpu time 
binary format file database editor sees loaded building 
run time modifications including editor operations binary database 
modifications show current editor session propagated back wk file editor shut 
automatically propagated back ug ascii database files basic data exchange format graphics programs 
address issue set routines propagating binary database changes back original ug ascii files necessary 
naming issues binary format associates unique textual name object database 
names generated instance statements ug files describing floor construction binary database ug database root ug filename instance statement object encountered prepended name object 
example sphere called sphere instance statement file included database file ug called sphere binary database 
nominally names serve identify file exact instance statement manipulated object derived 
ug format allows arbitrary nesting include files 
instance statement creating object descendant file included root file specified object name 
system needs track filenames included explicit include statements ug file filenames may contain instance statements objects derived 
filenames may may different directories original ug file finding files problem 
writeback process input walkedit ug writeback process sequence elementary operations include transforming object copying object renaming object deleting object 
operations assumed legal sequence time example object exist copy event handled 
input list condensed set modifications 
modification consists old object name original ug database potentially identical new name object single transformation object position old object transformations final resting place new object transformations editing session flag indicating delete object database 
modification node exists object final database 
modification list ug ascii database files sequentially scanned 
initial queue ug files processed union filename prefixes objects modification list 
file scanned statements instances includes ignored 
include file adds name included file file queue scanned 
instance statement checked see object old object modification nodes 
statement replaced set new instance statements modification node object parent flagged deleted 
new statement new name modification nodes instance name body statement replaced old statement body plus modification node transformation 
process generates modified ug ascii file 
modified file changed original way original replaced modified version modified file simply deleted 
process repeated file queue empty 
features help reduce amount necessary part user 
paths stored object names system able find file current directory tries open 
forcing user specify filename full path time needs open file databases hundreds files system keeps working directory list initially contains current working directory 
time instance statement processed path instance statement added directory list time user forced enter path path added directory list 
new file needs opened system attempts open path directory list forced ask user file usually files small set directories 
theory bookkeeping allows system ask user directory database files stored 
practice behavior better pathnames stored include statements system normally asks user single pathname get root file necessary paths deduced system 
transformation consolidation feature ug writeback system instance statement compression 
human user generates ug files hand especially editor tendency produce multi line instance statements redundant rotations transformations 
leads huge cluttered files 
furthermore ug writeback simply worked stated transformations line editor cause instance statements grow 
file sizes ug database expand unnecessarily 
remedy provide compression switch writeback process compression active default 
compression active system reads processes instance statement single transformation matrix 
transformation modification node added matrix produce single matrix transformation world origin 
transformation described parameters unigrafix instance statement stored matrix output set mirrors scaling translation rotation parameters major axes 
instance statement file matter long reduced single zero parameter statement newly generated ug file 
beneficial results editor compression mode results ug file explosion old ug files human trial error substantially reduced size simply running editor writeback procedure 
transformation consolidation takes place sweep update pass ug ascii files 
consolidation performed instance statement object modified left instance statement object modified transformation matrix modification existing instance statement 
consolidation performed instance line rebuilt 
reconstruction performed computing transformation matrix instance line gives initial object position database new transformation initial matrix 
complete transformation matrix decomposed single set mirrors scales rotations translations axis instance line rewritten single orthogonal set operations 
realism motion manipulation simulated gravity real world gravity major element daily life 
bodies objects manipulate obey physical constraints impossible create believable interactive environment providing newtonian behavior user objects world 
original walkthrough modes user motion 
normal mode constrained user particular height universe height set initial value loading database way change height pressing keys moved user fixed amount usually inches 
mouse allowed walking forward back rotating plane floor 
aside obvious deficiency allowing user look mode prevents simple realistic motion standing top objects moving floors 
mode called mode allows user spin vertically horizontally move straight ahead current view vector 
provides standard fly capability user may point direction rotating direction may go pointing desired location moving forward 
realistic standard mode user floats air miniature space ship inertia gravity flying story drops 
easy get lost mode vertical freedom motion difficult simply walk hallway user ends drifting ceiling floor changing height unnatural way 
want behavior combines steady height floor walking hallway ability look normal height walk stairs take elevators generally move building manner approximating way real person move real building 
latest implementation walkedit provides gravity approximation yields behavior 
database model allows editor project rays point space returns intersection ray solid object 
attempt simulating gravity insert process continually projects ray user eye point straight negative 
call process stores initial distance closest surface eye point 
distance height user 
subsequent calls system projects ray subtracts height user get current height error 
height error nonzero user height adjusted reduce error 
error negative user eye close floor 
case user needs stand 
normal human muscular system provides smooth motion move person position standing position motion initially rapid slows extent legs reached 
simulate process proportional correction method borrowed control theory 
cycle large percentage user selectable defaults percent error height eliminated user height increased percentage error 
provides smooth rise rapid slowing proper height reached 
positive error user fall appropriate height 
done simple discrete time acceleration simulation user vertical velocity maintained cycle cycle fixed acceleration term selectable applied velocity cycle 
velocity applied change height frame 
note velocity positive negative case user fly parabolic arc thrown upward 
user large downward velocity height error frame negative user fallen struck floor 
case damping term applied velocity reflected floor surface 
small fall result velocity cancelled damping term example stepping short platform dias bounce stepping second story result perceptible pogo stick action 
numerical instability observed near user set height due relatively long virtual time interval iterations process 
cure problem small downward steps user height error positive half user height proportional adjustment applied gently lower observer floor 
adjustment interacts damping term provide gentle smooth landing preventing vertical oscillation near proper height 
method provides realistic motion nondegenerate continuous floor surfaces 
user walk stairs simply moving user steps smoothly stair 
moving rapidly small vertical steps walking staircase doesn allow system fully process step encountered result vertical motion corresponding period spacing steps 
elevator moving lift handled process observer rises falls floor elevator 
fact elevators revealed problem approach 
elevator doors finite thickness inch 
meant floor interior elevator small crack width elevator door 
tiny crack wouldn bother person finitely large footprint real elevators crack fraction inch wide 
unfortunately observer projects infinitely thin ray stepping crack user fell elevator shaft 
problem result arbitrarily tiny crack floor small numerical error modeling 
reaction problem create finitely large footprint user portion footprint get hold user won fall crack 
system supports ray projections projections inexpensive small number rays footprint 
furthermore rays may problems cases instance rays projected front user user runs face wall front ray projected side wall resulting height error odd 
problem cracks floor user crossing cracks perpendicularly ray projected distance front user able find available patch floor available 
system projects second ray fifth height user front eye point straight 
projection yields error estimate height 
error estimate avoid falling cracks estimate error user eyepoint indicates fall 
user eyepoint height error stable indicates rise value 
eyepoint height error shows fall forward height error shows lesser fall rise forward error 
stops user falling cracks prevents problems user stepping close edge provides ability get surfaces just ahead user 
practice gravity system produce desired behavior 
physical object simulation motivation design construction walkedit wanted ability various degrees physical simulation 
part goal object association technique able objects behave similarly ways behave real world objects behave naturally manipulation objects far intuitive 
unfortunately true collision detection dynamic simulation time consuming algorithmic processes dominated cases 
walkthrough incompatible higher goal interactive frame rates discounted dynamics viable alternative 
past algorithms techniques appeared literature support realtime collision detection dynamics 
specifically berkeley lin canny developed algorithm maintain quickly update closest feature convex polytopes 
algorithm doing limited dynamic simulation possible maintaining frame rates walkthrough program interactive 
capability reach level realism interactive techniques 
research realistic rendering visualization techniques ongoing effort walkthrough 
ability dynamic simulation objects settle properly table pair legs air table longer float floor fall natural resting position 
cup sitting incline stay slide lower surface 
book hanging edge table fall hit floor 
events walkthrough realistic experience 
research interactive manipulation techniques benefit dynamic simulation capability 
ability true collision detection enable pseudo gravity association settle objects supporting surface realistically 
user interface research able dynamics collision detection example implement dragging interface object mouse produces force drags object cursor position 
force approach movement advantages alignment objects 
aligning desks example easy pressing torques generated collision force rotate press backs evenly 
new approaches negate need user explicit constraint objects necessary absence collision detection 
possible design buildings construction 
possible move piano staircase 
dynamics collision detection find trying drag 
section thesis describes preliminary effort integrate lin canny algorithm fast wall wall wall wall desk wall wall desk wall wall desk desk example collision detection force simulations benefit object manipulation 
user wants put desk corner 
user simply pulls desk upper wall 
desk moves linearly mouse collision detector finds impact wall 
torque produced contact point circle frame forces table rotate back wall 
sliding contact wall ellipse frame keeps table aligned back wall allows user slide desk corner applied force 
sliding contact achieved collision detector finds impact side wall ellipse 
desk stops moving dof removed physical contacts input force properly corner 
note user grab drag 
contact force computation algorithm special standalone testing version walkedit called walkthrough collision modeling 
algorithms integrated object association system initial results indicate approach shows promise tool interactive realistic manipulation objects virtual environment 
integrating lin canny algorithm object representation representing objects simulation problem walkthrough 
spatially partitioned preprocessed run time binary walkthru database wk database generated ug source code maintain ug winged edge data structure actual walkthrough 
wk database object represented list unrelated facets separate list vertices 
representation compatible lin canny algorithm requires convex decomposition database object winged edge structure convex 
furthermore simulation requires storage center mass mass inertia tensor object 
due fact walkthrough lin canny algorithms different object data needs maintains second runtime database called physical database 
object class wk database physical database contains convex decomposition object subparts winged edge format relative poses subparts physical parameters object center mass mass inertia tensor object local coordinate frame 
database initialized auxiliary files precomputed object directory wk database load time 
auxiliary files holds winged edge convex pieces contains simulation information inertia tensor mass center mass convex decomposition information class 
load time physical information gathered set data structures called structures 
structure wk object class containing physical data class 
simulation algorithms need operate wk database object request representation object physical database 
separate utility program written assist creation files 
object converter takes input original ug file wk database creates winged edge structure center mass mass object class file 
data written auxiliary files format required 
center mass polytope computed finding point inside polytope mass weighted average centers mass pyramids formed point facet polytope 
currently converter perform convex decomposition compute inertia tensor efforts simulation require coding algorithms 
object linking closest feature maintenance lin canny algorithm dynamically maintains closest pair features convex polytopes 
features defined points edges facets polytope 
algorithm incremental main procedures 
procedure initializer simulation begun initializer called determine closest features stored caller 
initializer runs linear time number facets polytopes 
objects moved incremental procedure called previous set closest features starting point 
procedure walks surface polytope old closest features new closest features returns 
flat geometry wk instance wk instance wk class hash hash table physical db inertia tensor relative position relative position convex center mass mass convex 
winged edge geometry lin canny 
wk class wk class wk class simulation link simulation link wk db object classes object instances data features 
organization run time databases simulation 
wk database original walkthrough database unstructured object definitions walkthrough object class data 
physical database contains structured winged edge object definition plus simulation oriented object data center mass moment inertia 
old features starting point finding new features fast objects moved small amount small motion assumption run time incremental update expected constant 
brian mirtich implementation algorithm ported walkthrough environment integrated 
representation uses mirtich structures convex translation layer involved library directly call mirtich functions relevant subpart find closest features 
order provide maximum performance closest feature determination pair objects system maintain closest features convex subparts objects calls closest feature finder 
closest features maintained linking mechanism implemented simulation library 
user wishes database objects interact simulation library function called allocates link objects 
wk database object single additional pointer added external data field points singly linked list simulation links 
simulation link part linked lists object linked 
link contains pointers objects pointers elements respective lists matrix closest features call lin canny algorithm 
matrix contains nm entries number objects 
entry single void pointer points feature object class representation making link compact possible 
link structure object links object links object links object links part part part part part part example link structure represented convex weights convex cylinder connecting 
link member link lists contains matrix closest features labeled 
lin canny algorithm accessed rest system function call takes database objects transformation matrix 
link objects function retrieves previous closest features link structure uses starting point find nm new closest features pairwise transformed object current pose matrices 
smallest distance smallest distance 
smallest distance returned link updated new closest features 
linkage system interface provides transparent closest feature determination granularity potentially concave database objects rest walkthru system 
linking strategy collision detection algorithm invoked object planned path object object links traversed find objects world possibly interact selected object 
programmer control extent interactions objects making deleting links objects move object moves different room example unlinked objects old room objects considered collision moved object 
allows system take advantage cell subdivision structure greatly reduce number objects included collision tests moving particular object interactively 
callback registered object associations grouping function link object touched grouping search selected object 
provided satisfactory local linking may inadequate longer distance movements objects 
current version unlinking implemented 
collision detection moving objects links established user may collision detection routine database object 
current collision detector takes database object motion vector object maximum time value 
motion vector complete element velocity vector linear velocity component angular velocity component angular velocity specified object center mass function computes starting object current position maximum value max object move vt velocity vector object collides object linked 
function uses numeric solver minimum distance moving object linked object function time find max ffi numerical stability objects may get closer preset small ffi values tests inch 
creating function properties lin canny algorithm important 
algorithm handle interpenetration contact objects condition occurs infinite loop created 
imperative collision detector conservative computing value result interpenetration contact 
achieve behavior stepping algorithm 
start attempt step forward time possible iteration remaining absolutely safe 
velocity vector rigid linear know compute time step bound step step step maximum delta time point object move time 
translational velocity greater angular velocity radius bounding sphere object write vt step art step step ar collision detection algorithm pseudocode works roughly follows 
set 
max ffi compute step distance vt art vt illustration computing conservative maximal timestep avoids collision moving convex polyhedron stationary polyhedron 
large demonstrates polyhedron linear velocity angular velocity largest distance point polyhedron move time vt art 
lower figures show qualitative examples terms relate collision distance time 

cases pair hypothetical polyhedra 

closest distance objects interval equal art collide collide time step collision 
fact approximation arbitrarily equal equal collide approaches 
similarly 
vt collide 
combining equations gives vt collide art collide collide ar pick time step equal ar time step guaranteed smaller time collision 
step max max 
max return 
set valid time ffi 
ffi ffi compute step distance gamma ffi step 
return loop attempts advance max loop fails collision occurs second loop backtracks attempts step close possible ffi distance objects returning value 
note program loop called objects selected object linked 
motion attempted culling step performed bounding sphere selected object swept velocity vector compared bounding spheres linked objects 
linked objects bounding spheres intersect selected object bounding sphere path tested main loop 
provides large advantage efficiency bounding sphere computation fast done tends remove linked objects consideration blockers 
relatively simplistic approach produce interactive collision detection objects dragged mouse 
approach similar approaches collision detection literature focus preliminary bounding shape cull step spatial subdivision reduce number potential collisions tractable set 
combine spatial cull form linking phase bounding sphere cull 
approaches spatial cull step literature focus structures octrees automatically partition objects groups algorithm simply uses precomputed cell structure wk database 
bounding sphere cull similar simpler approaches literature dimensional sweep volumes spatial tiling techniques 
large degree complex culling techniques unnecessary existing wk cell structure produces comparable result approaches practice 
potential collisions quickly pared objects cull step numerical solution takes time inversely proportional closest distance passes objects motion 
standard numerical method improve performance concerned infinite loop problem mirtich implementation approach sacrifices efficiency guarantee non intersection 
newer public domain implementation lin canny algorithm called collide avoids problem cohen replacing mirtich code collide system near 
contact force computation physical simulation need contact force computation algorithm collision detector 
implemented contact force computation algorithm taken david baraff siggraph 
points model contact forces polyhedral frictionless rigid objects point forces major types 
vertex face contacts generate force vertex face intersection point direction purely normal face 
edge edge contacts generate force intersection edges direction cross product direction vectors edges 
specify directions forces frictionless nature problem implies contact forces purely normal contact surfaces 
types contact may decomposed primitive types 
example face face contact may modeled considering region overlap faces vertices polygonal overlap region vertex face edge edge contact set contacts completely describes contact force faces 
face face contact vertex face contact edge edge contact major types contact objects vertex face left edge edge middle 
right example type contact face face decomposed types 
diamond shaped faces touching produce edge edge contacts vertex face contacts 
contacts circled picture 
compute contact points colliding objects takes advantage available convex decomposition 
pairwise closest features objects stored link structure 
valid contact points exist pair immediate neighbor features closest features 
example vertex convex polytope closest face convex polytope valid contacts edges vertices facets incident edges vertices face mn pairs lin canny closest features need consider neighbor features closest features find possible contacts 
expected mn neighbors reduced number comparisons features necessary compute contact points pairwise comparison features object comparison mn features substantial savings 
furthermore trivial reject pair performed case stored distance closest features smaller ffi 
full set contact points force vectors contact point determined baraff algorithm comes play 
define vector quantities relative acceleration contact force contact point relative acceleration bodies positive value means objects moving apart zero value means sliding pushing 
positive objects pushing zero objects moving apart 
description clear objects moving apart pushing 
physics af matrix representing masses inertial forces vector representing external forces gravity 
conditions define linear complementarity problem lcp 
baraff siggraph gives algorithm solving 
solution forces multiply previously determined contact force direction times values apply forces center mass giving single force torque vector represents total force object instant time 
total translational rotational force mass inertia tensor determine acceleration body ff newton euler equations ma iff 
limits dynamics simulation pseudo static conditions described section momentum velocity need include full formulation euler equation iff theta includes angular velocity 
pseudo static simulation contact forces provided functions generate simulated dynamic motion objects 
call contact force computation routine returns net force object 
call routine converts acceleration 
acceleration object mass compute instantaneous velocity vector passed collision detector determines far object move direction acceleration 
object move stable simulation completed 
object move moved far possible process repeated new location general entirely new set contact forces 
interaction collision detector pseudo static force computation algorithms simulation loop causes difficulties 
math subject small numerical fluctuations accelerations really applied properly accelerations continuously updated velocity vector collision detector cause objects get stuck 
usually happens sliding contact indicated algorithms 
sliding contact involves motion exactly parallel surfaces 
double precision arithmetic velocity vector exactly parallel surface object tend try move infinitesimally surface 
collision detector object performing motion motion cause objects get tiny bit closer ffi object doesn move contact forces don change object gets position 
solution problem contact forces repel object slightly 
repulsive force proportional user set constant times mass object times inverse square distance objects applied contact point 
tends cause objects want separate slightly contacts giving collision detector slack allowing object slide surface 
solution gets stuck un stuck increasing repulsion value 
suggests adaptive algorithm checks see collision detector forcing object remain unbalanced position increases value repulsion slowly collision detector lets go object 
algorithm part intended 
testing setup specially modified version walkedit integrates simulation library normal walkedit user interface 
new control panel options menu controls 
checkbox turns collision detection normal interactive motion 
option active motion user applies object standard editor operations collision checked collision detected object moved far collide 
demonstrates speed interactivity collision detection linking mechanisms 
second control activates simulation 
user may click hold object object subjected simulation loop user releases mouse button 
user cause blocks settle fall bricks tip surfaces 
third control numerical entry box allows user control repulsion force parameter increasing objects get stuck decreasing objects bouncing happens repulsion gets large 
results unfortunately due lack convex decomposition routine able test collision detection pseudo static physics algorithms real soda hall environment 
run simple environment containing geometric objects constructs inertia tensors decompositions determined simple mathematics 
environment things clear collision detection algorithms definitely quick interactive applications pseudo static force simulation computations clearly quick cycle times force computation algorithm seconds 
research done gravity contact force computation successfully object associations system 
collision detection algorithms interactively association prevents user dragging object holes gaps object realistically fit 
algorithms sufficiently robust handle wide variety contact situations bit help job simulating frictionless interactions objects 
extensions supporting modification structure walkedit allows manipulate building contents furniture 
creating building structure walls floors ceilings scratch modifying existing structural elements open problem virtual environments 
truly interactive virtual design tools structure buildings 
furthermore tools exist primarily cad tools fail force user geometrically valid models autocad example easily create model looks reasonable plan views elevations totally useless input computational geometry walkthrough environment 
berkeley walkthru user lay walls building text editor unigrafix file 
obviously logical extension walkedit allow interactively add move delete structural elements walls floors doorways windows 
capability walkedit complete interactive virtual environment creating architectural walkthrough models 
number problems associated achieving capability 
fall classes user interface problems primary focus walkedit far algorithmic problems involving real time visibility processing 
set user interface problems quite large fundamentally different problem moving building contents people move furniture real life normally push walls ceilings new configurations 
natural way single person quickly change room configuration rectangular carve new doors windows walls 
interactive structure manipulation task open problem 
top user interface problem fundamental difference manipulating structure manipulating contents walkthru environment 
contents building generally affect visibility processing walkthru considered major occluding surfaces 
moving consists simply removing pointer contains list cell adding contains list cell 
wall moves cell structure altered 
moving major occluding surface propagate changes cell boundaries way root tree rendering visibility preprocessing instantly useless changing cell subdivision data 
need ways dynamically change cell structure perform new visibility processing fly 
open problems group seth teller group mit working solutions 
hierarchical models levels objects walkthru system objects occluders 
objects rigid entities may manipulated single body walkedit occluders wall surfaces moved 
reality objects best defined multiple pieces move constrained ways respect 
example desks file cabinets move onedimensional space anchored base unit 
doors move degree freedom respect frames 
able package hierarchies objects form relative object associations define motions 
adding hierarchical models involve large scale changes way walkthru represents objects problem scope masters 
promising route change walkthrough unigrafix basis advanced object representation system silicon graphics open inventor format 
shift raise questions basic wk cell partitioning object instancing structure object associations interaction methods take account ambiguity selection manipulation subparts hierarchical groups 
virtual environments simulation training years ago usefulness virtual environments primarily limited visualization tasks 
technologies begun propagate design tasks autocad visualization proposed construction home improvement programs shelves software stores frame walkthroughs small room additions houses 
interactive walkthrough technology improves computers speed virtual environment systems berkeley walkthru useful simulation environments design environments 
may see virtual environments train combat building fires setting foot near flame determine changes lighting affect comfort levels occupants building 
examples ways combination simulation virtual environment technology challenges visualization interface techniques stand 
providing suitable virtual environments single user distributed multi user simulations single world require research variety frontiers 
addition moving furniture constrained motions user needs carry order set exact state simulation 
doors windows need opened closed blinds may lowered drawn file cabinets may pulled open partially set initial conditions simulation 
need find simple efficient ways create models permit constrained movements interface paradigms models interactive virtual environments 
furthermore walkthru provides potential improving visualization results simulations 
outputs modern simulators devoid graphics focusing tables numbers dimensional graphs 
difficult visualize conditions multi room environment quantitatively qualitatively set graphs 
natural instructive set view simulations virtual environment 
need develop tools help build virtual simulation environments buildings 
established suitable framework interactive simulations virtual building models technology readily extended environments mine shafts factories air craft carriers 
reasonably environment relatively confined visibility observer positions visibility preprocessing techniques caching schemes give real time rendering performance mid range graphics workstations 
virtual environment applications naturally involve person single environment need look providing distributed environment multiple users located individual workstations visualize interact real time building simulation environment 
involves extending virtual simulation environment distributed concurrent program scenarios displayed various workstations properly synchronized 
environment contexts allow teams develop collaborative techniques help building designers collaboratively new designs allow personnel training control maintenance complicated environment aircraft practicing techniques wide variety simulated conditions name examples 
interactive multi user virtual environment place provides real world demonstration feasibility environments 
goal walkedit project construct placement editor real time interactive walkthrough large building databases 
wanted design walkedit shelf input display hardware goal requiring software framework allow user perform unambiguous manipulation devices 
walkedit manipulation techniques primarily object associations framework provides flexibility combine pseudo physical properties convenient teleological behavior mixture tailor particular application domain special set tasks 
mixture magical capabilities geometric editing systems partial simulations real physical behavior attractive easy editing system virtual environments 
combination goal oriented alignments snap dragging application specific physical behavior gravity solidity reduce degrees freedom user deal explicitly maintaining convenience geometrical drafting program 
practical separate types procedures mapping pointing motion enforcement desired object placement behavior 
procedures clearly defined easy implement small add functions geometric database toolkits allow high level coding ease modification 
object associations normally cause little computational overhead walkthru system 
important concern keeping response time system fast interactive crucial aspect usability user friendliness 
result technique object placement quick accurate works drag drop cut paste interaction techniques provide desirable local object behavior automated grouping facility greatly reduces need multiple editing modes user interface 
resulting environment devoid fancy widgets sophisticated measuring bars multiple view windows 
novice user happening objects simply follow mouse reasonable realistic locations 
ideally additional indication paradigm pushed full potential 
issues remain fully resolved dealing association loops prototype demonstrates approach provides simple flexible practical approach constructing easy manipulation interfaces 
object associations mechanism combined set traditional tools knapsack mechanism cut copy rename paste capabilities objects groups objects infinite undo redo capability ability import new object models unigrafix files set standard manipulator widgets 
package tools defines complete suite editing functions populating architectural model detail objects quick easy intuitive task computer novices 
addition manipulation mechanisms physical simulation capabilities explored 
gravity simulation simulates height user ground greatly enhance walkthru experience allowing user look walk allowing take elevators natural way 
secondly interactive collision detection attempted objects helpful cases placing objects 
physics simulation needs explored refined useful tool interactive manipulation walkedit environment 
result efforts resulted building contents editor provides simple intuitive tools populating building model 
major step development interactive design tools 
additional manipulation structural elements believe extended true start finish building model generation environment basis new generation simulation design virtual environment cad tools 
example scene constructed minutes walkedit 
scene contains objects properly aligned arranged hand 
done guidance carlo advisor mentor friend years 
unique combination enthusiasm tackling new challenges earth sensibility important life research consider extremely fortunate students 
am grateful walkthrough research group seth teller tom funkhouser ongoing colleagues simmons randy keller rick lewis laura downs give assistance insight support 
special laura course reasons entirely unrelated academics continues primary mathematical resource lab 
mark topics including masters theses ben jerry thing 
generally berkeley computer science department great bunch people 
special bob miller terry smith kathryn crabtree helping take care administrative details right mind want deal 
academic research gets far support 
national science foundation excellent year fellowship program gave freedom pursue endemic graduate students take teaching gsr positions pay room board 
national project center nec providing support research computer graphics virtual reality berkeley 
ultimately family especially parents richard maria grandparents guy virginia agostino richard helen remain supply support inspiration course grief level success possible 
john increasing update rates building walkthrough system automatic subdivision potentially visible set calculations 
ph thesis unc chapel hill 
john john frederick brooks jr image realism interactive update rates complex virtual building environments 
acm siggraph special issue symposium interactive graphics 
autocad manual release 
baraff fast contact force computation rigid bodies 
proc 
siggraph orlando fl jul pp 

barlow mice input devices 
computer aided engineering apr pp 

walkthru animation visualization system 
promotional literature 
bier snap dragging dimensions 
proc 
symposium interactive graphics snowbird ut mar pp 

borning programming aspects constraint oriented simulation laboratory 
acm trans 
programming languages systems pp 

borning constraint hierarchies applications 
ieee compcon spring digest papers 
ieee computer society press los alamos pp 

brooks jr frederick walkthrough dynamic graphics system simulating virtual buildings 
proceedings workshop interactive graphics 
brown interactive object displacement building walkthrough models 
master thesis computer science division eecs university california berkeley 
richard carlo 
object associations simple practical approach virtual manipulation 
proc 
symposium interactive graphics monterey ca april pp 

cameron collision detection dimensional interference testing 
proc 
international conference robotics automation pp 

chen sellen study interactive rotation control devices 
computer graphics august pp 

lewis ling wang norton sweeney turk interactive simulation multi person virtual world 
proc 
acm conference human factors operating systems chi monterey california may pp 

cohen lin manocha ponamgi collide interactive exact collision detection system large scale environments 
proc 
symposium interactive graphics monterey ca april pp 

lux high level user interface toolkit graphical applications 
computers graphics march april pp 


walk planned cs building 
master thesis computer science division eecs university california berkeley 
faigle fox simoni integrating virtual environments high performance computing 
proc 
ieee annual virtual reality international symposium seattle washington pp 

generation smooth trajectories planning 
nist internal report ir national institute standards technology gaithersburg md september 
figueiredo bohm teixeira advanced interaction techniques virtual environments 
computers graphics november december pp 

funkhouser adaptive display algorithm interactive frame rates visualization complex virtual environments 
proc 
siggraph anaheim ca aug pp 

funkhouser thomas database display algorithms interactive visualization architectural models 
ph thesis computer science division eecs university california berkeley 
gleicher constraint drawing program 
proc 
acm conference human factors computing systems chi monterey ca may pp 

gray de bear foley coupling application design user interface design 
proc 
acm conference human factors operating systems chi monterey california may pp 

greenberg accurate simulations faster rates 
ieee computer graphics applications january pp 

hahn realistic animation rigid bodies 
computer graphics aug pp 

helm huynh lassez marriott linear constraint technology interactive graphic systems 
proc 
graphics interface vancouver bc canada may pp 

iterative design interface easy direct manipulation 
proc 
acm conference human factors operating systems chi monterey california may pp 

hubbard interactive collision detection 
proc 
ieee symposium research frontiers virtual reality october 
feiner inferring constraints multiple snapshots 
acm transactions graphics october pp 

lin canny fast algorithm incremental distance calculation 
international conference robotics automation ieee may pp 

lin efficient collision detection animation robotics 
ph thesis department electrical engineering computer science university california berkeley december 
mirtich canny impulse simulation rigid bodies 
proc 
symposium interactive graphics monterey ca april pp 

myers creating user interfaces programming example visual programming constraints 
acm trans 
programming languages systems apr pp 

nelson constraint graphics system 
proc 
siggraph san fransisco ca jul 
computer graphics jul pp 

nielson olsen direct manipulation techniques objects locator devices 
proc 
workshop interactive graphics chapel hill nc oct pp 

shaw liang green sun decoupled simulation model virtual reality systems 
proc 
acm conference human factors operating systems chi monterey california may pp 

shoemake user interface specifying dimensional orientation mouse 
proc 
graphics interface vancouver bc canada may pp 

smith experiences alternate reality kit example tension magic 
ieee computer graphics applications september pp 

herndon robbins conner van dam deformations explore widget design 
proc 
siggraph chicago illinois july 
computer graphics july acm siggraph new york pp 

strauss carey object oriented graphics toolkit 
proc 
siggraph chicago illinois july 
computer graphics july acm siggraph new york pp 

teller visibility preprocessing interactive walkthroughs 
proc 
siggraph las vegas nevada jul aug 
computer graphics jul pp 

teller seth visibility computations densely occluded polyhedral environments 
ph thesis computer science division eecs university california berkeley 
van emmerik direct manipulation technique specifying object transformations input device 
computer graphics forum december pp 

van emmerik interactive design models geometric constraints 
visual computer september pp 

facile direct manipulation 
proc 
acm conference human factors computing systems chi amsterdam netherlands apr pp 

walkthrough 
promotional literature 
ware balakrishnan reaching objects vr displays lag frame rate 
acm transactions computer human interaction december pp 

nakamura direct manipulation interface development system 
computers graphics march april pp 

zeleznik herndon robbins huang meyer parker hughes interactive toolkit constructing widgets 
proc 
siggraph anaheim ca aug pp 

zyda michael david pratt james monahan wilson 
constructing virtual world 
acm siggraph special issue symposium interactive graphics march 

