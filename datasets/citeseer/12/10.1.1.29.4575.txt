generalising monads arrows john hughes november distinguishing features functional programming widespread combinators construct programs 
combinator function builds program fragments program fragments sense programmer combinators constructs desired program automatically writing detail hand 
freedom functional languages provide manipulate functions program fragments class citizens supports combinator programming directly 
combinators known list processing operators map filter encapsulate generally useful program constructions may appear functional program 
tailored particular application areas collected libraries enable applications area built quickly easily 
example parsing application area extensively studied 
appropriate library parsing combinators parser grammar programmed haskell hud ph gram symbol cat gram cat symbol symbol note syntax haskell function application written brackets symbol denotes call function symbol argument function arguments may infix operator enclosing back quotes 
example symbol function constructs parser accepts just token cat binary operator combines parsers parser runs sequence binary operator combines parsers tries alternatives entire declaration recursive definition parser gram recognises non terminal follow fairly widespread convention long operator names typeset characters overlapping look single name 
reality just 
idea programming combinators quite old design combinator libraries profoundly influenced years wadler concept monad functional programming wad wad wad 
shall discuss monads fully section suffice say monad kind standardised interface data type program fragments 
monad interface suitable combinator libraries extensively 
numerous benefits flow common interface take just example haskell extended special constructions monads particularly convenient 
matter concern libraries emerge fundamental reasons monad interface 
particular swierstra duponcheel developed interesting library parsing ll grammars sd avoids known inefficiency monadic parsing libraries combining construction parser static analysis program constructed 
swierstra duponcheel optimisation incompatible monad interface 
believe library just isolated example demonstrates generally useful paradigm combinator design falls outside world monads 
shall look closely idea section 
inspired swierstra duponcheel library sought generalisation monad concept offer standardised interface libraries new type 
proposal call arrows subject 
arrow interface turned applicable kinds non monadic library example fudgets library graphical user interfaces ch new library programming active web pages 
applications described sections 
arrows little convenient monads significantly wider applicability 
bring benefits monad programming wider class applications 
background library design monads monad 
haskell monad interface defined class class monad return 
read follows parameterised type monad supports operations return pronounced bind types 
intuitively think value type representing computation result type program fragment 
return operation constructs trivial computation just delivers argument result 
operation combines computations sequence passing result argument second type second argument function constructs second computation just computation 
example monad manage failures example consider type defined data just declaration introduces new parameterised type constructors just 
value type form just component type form 
type represent possible failure function intuitively returns result type may fail defined return result type represents failure 
idea conveniently define combinator library take care failure handling 
declare type monad give implementations return type 
haskell write instance monad return just case just fails immediately calling argument fails 
combinators write functions handle failure properly explicit tests just 
example function adds possibly failing integers failing argument add int int int add return layout suited monadic programs may confusing body expression extends entire right hand side 
complete useful library failure handling add combinator cause failure example fail fail treat type write programs cause propagate failures just operators fail return explicit dependence way failures represented 
example monad manage state example updateable state modelled purely functional language passing function current contents state additional parameter returning possibly modified state part function result 
hand tedious error prone fortunately encapsulate state passing mechanism combinator library monad 
case represent computation result type state type value type newtype statemonad sm 
haskell newtype declaration introduces new type isomorphic existing constructor names isomorphism 
state type partially applied type statemonad denotes parameterised type remaining parameter monad instance monad statemonad return sm 
sm sm sm definitions write programs pass state just terms return need manipulate state explicitly 
notice pass modified state returned argument second original state return modified state returned second argument part result 
attempts pass state hand combinators easy forget strange bugs result 
complete library state passing provide combinators reading modifying state 
example fetch statemonad fetch sm 
store statemonad store sm 
statemonad type stateful programs written just terms combinators 
example function increment counter tick statemonad int int tick fetch store return monadic parsing combinators practice combinator libraries usually monads providing combination features 
example parser values type represented type newtype parser type represent symbols parser input haskell notation type list 
parser invoked applying representation list symbols parse result indicates parsing successful event success contains value parsed remaining unparsed input 
example parser recognises particular symbol defined symbol parser symbol xs case xs xs just xs parser fails input empty begins wrong symbol succeeds symbol consumed input 
representation parsers supports combination failure handling state passing state unparsed input 
declared monad just statemonad types see wadler articles details 
combinators added build complete library parsing monad 
monads 
seen monads basis combinator libraries 
monads ubiquitous haskell programs today 
reason course monads simplifies code dramatically 
clear writing parser explicit tests failure explicit passing input labour intensive writing terms symbol return 
advantage combinator library encapsulate coding details argue monads particular 
reason monads offer design guideline combinator libraries start defining suitable monad 
example fairly clear library parsing include combinator invoke parsers sequence possible ways combinator handle parsers results 
early parsing libraries results paired sequencing combinator took extra parameter function combine results 
monadic operator general may easily defined terms converse true 
basing parsing library monad designer gives user flexibility ad hoc alternatives 
know experience monadic interface gives library user great power 
hand monad interface gives implementor combinator library flexibility possible implementations 
seen examples monads fact monad transformers kw systematically construct infinite variety monads 
systematic approach monad design helps implementor find appropriate type base combinator library helps library proof 
extension library require change representation say parsers implementor rest assured myriad alternatives 
put way monad interface constrain choice monad type exposes little internal workings library rest program 
consequently monads help library maintainer upgrade combinator library forcing changes code uses 
fact monad operations return overloaded haskell permits write generic monadic code library monad 
growing collection functions provided standard haskell library 
example generalise add function adding possibly failing integers generic function applies binary operator results computations 
liftm monad liftm op return op monad type liftm context means function may monad type 
cat operator parsers saw defined simply cat liftm haskell concatenation operator lists 
generic code sort represents functionality designer individual combinator library longer needs provide simply basing library monad gains access host useful functions free 
turn may significantly reduce required produce new library 
taken arguments provide compelling reasons monads combinator design wonder ubiquitous 
parsing combinators pursue example combinators parsing little 
things parser fail enable express define combinator fails 
fact monads support notion failure useful overload failure operator just overloaded monadic return 
haskell done predefined class class monad zero read follows parameterised type monad additionally supports operation zero 
implementation zero parsers defined instance parser zero monads support failure support choice combinator tries alternative ways perform computation second fails 
haskell defines predefined class class monadplus implementation parsers instance monadplus parser case just just fundamental building blocks parsing library interesting grammar defines non terminals alternatives 
unfortunately definition contains serious space leak 
causes retention data garbage collector longer naively anticipate result parsers built operator space reasonably expect 
problem inherent backtracking parsers 
inspection input parsed garbage collected parser running eventually fails passed lazy language haskell act running parser forces list tokens constructed reading file 
provided fails quickly forcing evaluation elements little space 
succeeds parsing large part input great deal space may hold parsed tokens just case eventually fails needs invoked 
ironically practice usually recognise quite different syntactic constructs succeeds parsing symbols certainly fail soon invoked 
saving input costly unnecessary 
problem known combinator libraries parsing proposed wadler example gives partial solution wad 
solutions known monadic parser libraries partial depend programmer additional combinator similar prolog cut operator declare parser need backtrack certain point 
monadic parser libraries quite practice fundamental problem remains unsolved really unsatisfactory 
swierstra duponcheel parsing library swierstra duponcheel different way solve problem 
restrict attention ll parsers choices alternative parses resolved looking token input 
implementation choose immediately need save input case alternative needs tried 
space leak parsing libraries suffer completely cured 
implement idea swierstra duponcheel need able tell parser tokens accept input accept empty sequence tokens 
means parsers longer represented functions previous section 
represented combination static information computed parsing begins parsing function optimised basis static information 
paraphrasing swierstra duponcheel define data sp bool newtype dp 
data parser component parser tells matches empty string tokens accept second component function actual parsing 
example combinator accepts particular symbol defined symbol parser symbol sp false dp xs 
xs dynamic parsing function need test empty input check symbol invoked preconditions expressed static part satisfied 
static information define choice combinator efficiently instance monadplus parser sp empty starters dp sp empty starters dp sp empty empty starters starters dp xs case xs empty xs starters xs starters xs empty xs xs clear definition choice invoke directly revised need retain pointer input consequently space leak just operator computes starter symbols potential emptiness parser constructs combinators 
cases straightforward unfortunately case turns impossible 
see recall type case parser 
parser parser static properties result depend static properties second argument example combination match empty sequence arguments 
definition access static properties argument obtain static properties second applying value type values constructed parsing swierstra duponcheel idea useful compute static parts definition completely realistic 
assumes user library really write ll parser starters starters disjoint 
real implementation course checked 
expensive tests form starters avoided choosing representation parsers see swierstra duponcheel article details 
parsers parsing begins 
simply impossible find definition 
swierstra duponcheel solution problem abandon monad defined different sequencing operator type 
parser parser parser operator perfectly adequate expressing parsers poses problem far computing static properties advance parsing concerned 
need abandon monad signature worrying reasons discussed 
useful swierstra duponcheel parsing library stands example generic monadic functions 
isolated case simply ignore 
swierstra duponcheel idea clearly widely applicable optimise combinator library redefine combinators collect static properties computations construct static properties optimise dynamic computations 
think library defining domain specific language constructions represented combinators swierstra duponcheel idea implement language combination static analysis optimised dynamic semantics 
may clearly wish 
time type impossible monadic interface 
observation motivated search generalisation monads generic interface combinator libraries fits wider class applications 
introduce generalisation section 
category theory short digression subject category theory 
concept monad developed category theorists long eventually application functional programming 
find surprising category theory turn useful concrete programming 
category theory sense unsatisfying definitions theorems turns category look long say category say little 
true categorical concepts possible instantiations say example monad say little 
extreme generality reason hard beginner develop intuitions category theory hardly surprising category theory developed theory framework different mathematical structures fit 
theory programming 
answer simple computer scientists value abstraction 
design interface software component want reveal little possible implementation 
want able replace implementation alternatives instances concept 
design generic interface program libraries important interface choose wide variety implementations 
generality monad concept value highly category theory concepts useful programming 
hardly surprising generalisation monads close connection category theory 
stress purpose practical implement category theory find general way structure combinator libraries 
simply fortune mathematicians done 
arrows returning problem recall swierstra duponcheel unable implement parser 
parser parser second argument function thing function apply 
lacking suitable value type apply extract static information construct static part result 
solution simply change representation argument 
function type parser type call arrow solve swierstra duponcheel problem choosing representation arrows static properties immediately accessible 
fact need types monad type arrow type 
purely arrows 
general arrow type parameterised type parameters supporting operations analogous return 
just think monadic type representing computation delivering think arrow type application parameterised type parameters representing computation input type delivering arrows dependence input explicit 
just haskell defines monad class shall define arrow class analogous operators 
dependence input explicit 
return operator type merely converts value computation analogue arrows type converts function input output computation 
analogue just composition arrows 
define class arrow arr 
monad functions type potential arrows 
give type name newtype kleisli implement arrow operations follows instance monad arrow kleisli arr return 
shows arrows generalise monads monad type corresponding arrow type 
categorically speaking just constructed kleisli category monad 
course see non monadic implementations arrow signature 
arrows pairs case monads operators return need writing useful code arrows analogous operators arr 
sufficient 
simple monadic addition function saw earlier add monad int int int add return expressed arrow form 
making dependence input explicit see analogous definition take form add arrow int 
int 
int add combine sequence 
sequencing operator available right types composed 
add function needs save input type computation able supply input likewise result saved computation results eventually added returned 
arrow combinators far introduced give way save value computation alternative introduce combinator 
extend definition arrow class follows class arrow arr 
new operator converts arrow arrow pairs applies argument component leaves second component untouched saving value computation 
implement kleisli arrow instance monad arrow kleisli return define combinator applies argument second component second arrow second arr swap 

arr swap swap combinator processes components pair arrow 
second combinator builds pair results arrows arrow arr 
definitions add function easily completed add arrow int 
int 
int add 
arr just abstracted idea applying binary operator results monadic computations going define liftm generalise arrow version likewise lifta arrow lifta op 
arr op point reader categorical background may formed impression arrows extended interface implement category products 
construct arrows pair type construct projection arrows arr fst arr snd 
beware 
fact reason expect haskell pair type categorical product category arrows expect categorical product exist 
require properties 
arr fst hold general arrows usually represent computations sort effect laws sort simply false 
case side effects lost right hand side 
reader may wonder chose take primitive say resembles known categorical operator 
main reasons choice 
ffl firstly general arrows represent computations effects evaluation order difference 
definition explicit effects composed effects order evaluation left right 
definitions algebraic laws programmer laws capture evaluation order 
contrast taken primitive designer arrow library choose right right left evaluation result evaluation order probably differ case case 
behaviour arrow libraries predictable reduce number useful laws arrow combinators satisfy 
ffl secondly simpler operator general implementation half size 
practice implementations arrow combinators quite complex making choice reduce required build new arrow library appreciably 
arrows interpreters awkward program arrow combinators monadic ones 
expressive combinators case kinds program expressed return written terms arr 

answer questions looking fragments interpreter arrows vs monads 
write interpreter program fragments certain language interpreted arrows know kind program expressible interpreted language expressed terms arrow combinators 
shall consider tiny language variables addition 
represent expressions datatype data exp var string add exp exp value expression integer anticipation making extensions introduce separate type values anyway data val num int require type environments type env string val monadic interpreter maps expressions computations represented monad introduce evaluation function eval exp env val define eval var env return lookup env eval add env liftm add eval env eval env add num num num arrow interpreter hand maps expressions computations represented arrows 
input arrow denoting expression 
analogy monadic case natural take input expression environment 
arrow interpreter arrow type give eval type eval exp env val define eval follows eval var arr lookup eval add lifta add eval eval add num num num see small example arrow code means awkward monadic code 
user monadic combinator library works derived operators liftm operators monad signature 
analogous operators defined arrows arrow programs essentially monadic ones 
interpreting conditionals pursue interpreter example little add conditional expression interpreted language 
extend expression value types follows data exp exp exp exp data val bl bool monadic interpreter easy extend add new case eval env eval env bl eval env eval env arrow interpreter difficult 
certainly define eval eval eval eval 
arr bl doesn properly capture meaning conditional expression branches evaluated just choose results 
course intention evaluate just branch depending value boolean 
crux problem arrow combinators provide way choose arrows basis input 
obliged add new combinator 
time choose define new class arrowchoice enlarge existing arrow class 
doing retain freedom define arrow types support dynamic choice combinator simply fail instances new class 
new combinator want choose arrows basis input sense input haskell sum type data left right define jjj pass left inputs right inputs type jjj jjj arrowchoice just chose define arrow primitive choose simpler operator jjj primitive method arrowchoice class 
define class arrow arrowchoice left left invokes left inputs leaves right inputs unchanged 
usual check implement left kleisli arrows instance monad arrowchoice kleisli left case left return left right return right introduced left define right arr mirror 
left 
arr mirror mirror left right mirror right left 
left 
right jjj 
arr left right returning interpreter define interpretation conditionals eval eval arr id 
arr bl env left env right env 
eval jjj eval little awkward monadic code simplified introducing combinator especially testing predicates test arrow bool test arr id 
arr left right combinator sufficiently useful reasonable include arrow library case interpreter complicated monadic version eval test eval 
arr bl eval jjj eval interpreting calculus combinators introduced go write arrow interpreter complete order functional language 
interpret higher order functions 
consider adding expressions call value application interpreted language 
extend type expressions follows data exp lam string exp app exp exp extend type val decide represent function values 
calling function may effect interpret functions values type val val 
monadic interpreter functions result computation data val fun val val arrow interpreter naturally represent functions arrows data val fun val val monadic eval function easily extended handle new cases eval lam env return fun eval env eval app env eval env eval env arrow version proves difficult 
interpreting expressions unproblematic eval lam arr env fun arr 
env 
eval application harder 
try define eval app eval 
arr fun eval 
app suitable definition app find app invoke arrow receives input way combinators far introduced 
introduce new class class arrow app definition eval works 
implementation app write interpreter calculus express arrow programs higher order style 
easy implement app kleisli arrows instance monad kleisli app seen monad define corresponding arrow type kleisli supports combinators introduced far 
conversely turns arrow type supports app define corresponding monad type definition simply newtype void void haskell point type element undefined 
monadic computation simply arrow ignores input 
define monad operations instance monad return arr 
arr undefined 
app need app order invoke arrow second argument produces 
draw arrow types support app just expressive monads 
principle eliminate concept monad haskell altogether replace arrows supporting app 
draw arrows supporting app really little interest 
motivation find generic interface combinator libraries monad 
clearly library supports arrow type app equally monadic interface 
rest interested arrow types instances 
swierstra duponcheel parsers arrows introduced number arrow classes return swierstra duponcheel parsers 
recall defined parser type data sp bool newtype dp 
data parser unable parser monad arrow type 
need add extra type parameter arrow types take parameters monad types take 
intention static properties parser depend parse time inputs change type dynamic parsing function newtype dp 
data parser implementing arrow combinators type straightforward instance arrow parser arr sp true dp 
sp empty starters dp 
sp empty starters dp sp empty empty starters union empty starters dp ffi sp dp sp easy modify definitions section symbol failure operator zero choice combinator handle arrows input appropriately 
course zero overloaded names monad operators names corresponding operators arrows 
introduce arrow classes class arrow zeroarrow class declare parser instance classes 
having done go define operators interface swierstra duponcheel terms arrow operations introduced 
example sequencing operator definable 
parser parser parser 
lifta fx fx user arrow parsing library exactly way swierstra duponcheel original library addition combine parsers generic arrow code 
arrow classes arrowchoice 
moment thought shows parsers support signatures 
choice operator jjj supposed dynamic choice arrows basis input implies possible starting symbols jjj depend arrow input 
deliberately designed parser type value input affect static component 
follows jjj 
similar argument shows app arrow type supports app support choice see give definition left terms app 
luckily matter rare want write parser decides grammar accept basis previously parsed values 
see arrow interface lets programmer finer distinctions monad interface distinguish types computations permit dynamic choices calls dynamic functions types computations 
swierstra duponcheel parsers 
contrast declare type monad open possibility doing 
monadic interface restrictive 
stream processors processes arrows seen monad gives rise corresponding arrow type natural way swierstra duponcheel parsers generally combinators collect static information computations represented arrows 
section show notion computation process fits naturally arrow framework 
concern time processes input channel output channel 
processes modelled purely functional language stream processors 
stream processor maps stream input messages stream output messages represented data type 
sp type stream processors inputs type outputs type stream processors constructed operators put sp sp constructs stream processor outputs behaves second argument get sp sp constructs stream processor waits input passes function argument behaves result 
simplicity shall consider non terminating recursively defined stream processors add operator construct stream processor halts 
stream processors represented different ways quite choice datatype put get constructors data sp put sp get sp put put get get write single processes put get put processes need combinators 
arrow combinators turn represent natural operations processes 
readability separately large instance definition 
arr operator builds stateless process just applies function inputs produce outputs 
arr get put arr 
operator connects processes series sp 
put sp put sp 
sp put sp 
get sp 
get 
get get 
get notice define process composition lazily composition blocks waiting input constituent processes 
operator builds process feeds components inputs argument process second components bypass argument process recombined outputs 
argument process produce output input 
solution buffer inputs corresponding outputs produced 
function bypass takes additional argument queue second components waiting bypass bypass bypass ds get get bypass ds bypass ds put sp put bypass ds sp bypass put sp get put bypass sp definition combines parallel synchronising output streams produce stream pairs synchronising joint output input stream 
generic arrow combinators write stream processors 
example stream processor outputs fibonacci numbers put put lifta stream processors support natural notion failure failing process simply produces output 
define zeroarrow instance sp zeroarrow get zeroarrow define run parallel merging outputs 
instance sp put sp sp put sp sp sp put sp put sp sp get get get take care define parallel composition lazily blocks waiting input 
definitions satisfy laws zeroarrow zeroarrow strong indication reasonable 
stream processors support dynamic choice 
stream processor left sp simply passes messages tagged left sp passed directly 
instance arrowchoice sp left put sp put left left sp left get get case left left right put right left get definition jjj regarded kind parallel composition routes inputs tagged left inputs tagged right fact stream processors input output channel model processes multiplexing channels 
example regard channel carrying messages type representation channels carrying carrying bs 
viewpoint jjj combines parallel yield stream processor input channels multiplexed merges output channels 
wish combine merging outputs copy input channel output channels arr left arr right define parallel combination output channels copies input channel processes arr left arr right write stream processor input channels output just copies input channel discards second vice versa arr id jjj zeroarrow zeroarrow jjj arr id surprisingly combining processes discarding output channel equivalent 

properties categorical interpretation tell type weak categorical product category stream processors 
weak way define equations hold definition favours case produce outputs simultaneously 
deep sense type behaves product pair type stream processors 
channel carrying sum type corresponds closely pair channels channel carrying pairs 
arrow class shown implement 
turns sensible definition app sp sp app receive new stream processor invoke input real sense stream processors passed receive stream inputs supply input 
really unnatural 
stream processors support natural definition app fitted monadic framework 
give second example useful kind computation represented monad 
recalling may play role product type stream processors app consider looking function type dyn sp sp natural definition type dynamic stream processor dyn receives stream processors input channel passes inputs second input channel stream processor received receives stream processor replace 
implement dyn zeroarrow put sp put sp get get case right left sp sp stream processors just amusing toys heart fudgets combinator library programming graphical user interfaces ch 
fudget stream processor extra hidden communication channels window manager 
fudget exchange high level messages fudgets manage part screen 
fudget appearance behaviour useful structuring complex user interfaces 
fudget type implemented stream processor high low level communication channels multiplexed just way described 
fudgets just stream processors declared arrows supporting operations 
interestingly operations discussed section appear fudgets library dyn course appear different names instances general framework 
functors new arrows old attractive features monads designed systematically called monad transformers 
monad transformer monad parameterised monad computations parameter monad lifted computations new 
example state monad section generalised monad transformer newtype sm general monad operators new type defined terms monad operators parameter monad case instance monad monad return sm return sm sm sm lifting computations defined passing state unchanged monad sm return new monad supports fetch store operations just original state monad fetch monad statemonad fetch sm return store monad statemonad store sm return new monad supports computations parameter monad lifting addition manages state 
composing monad transformers build monad providing desired combination features 
example want monad manages state handles failures type 
section show arrows property define arrow transformers map simpler arrow types complex ones 
important monad transformers arrow transformer counterparts describe handling failures state continuations 
arrow transformer analogy monad transformer just arrow type parameterised arrow type arrows second type mapped arrows 
fact corresponds closely standard categorical notion functor shall word functor arrow transformer 
note briefly concepts monad transformers functors formalised classes overloading lifting operations requires powerful class system haskell currently supports 
refrain doing 
functor arrow type lifted arrow type supporting failures functor newtype mf arrows result indicate failure 
lift arrows type arrow mf 
arr just arrow operations need handle failures means need dynamic decisions 
require parameter arrow type supports choice instance arrowchoice arrow arr arr mf 
mf mf 
arr case just left right 
jjj arr id mf mf 
arr case just just arrows formed support failure failure handling course instance arrowchoice zeroarrow mf arr instance arrowchoice mf mf mf arr id 
arr case just left right 
arr id jjj surprisingly support choice instance arrowchoice arrowchoice mf jjj mf mf jjj underlying arrows support application arrows produced instance arrowchoice app mf arr mf 

app state functor arrow type lifted arrow type supporting state passing functor newtype sf lift arrows type arrow sf arrow operations just pass state expect instance arrow arrow arr arr sf 
sf sf 
sf sf arr 


arr 
course arrows produced support fetch store operations fetch arrow fetch sf arr 
store arrow store sf arr 
stateful arrows inherit ability support dynamic choice failure failure handling parameter arrow instance arrowchoice arrowchoice left sf sf arr case left left right right 

arr left jjj arr right instance zeroarrow sf zeroarrow instance sf sf sf underlying arrow type supports application stateful arrows instance app sf arr sf 

app state functor defined course closely related state monad transformer advantage defining functors arrows transformers monads apply arrow types correspond monad 
example reader invited behaviour arrows type sp derived adding state passing stream processors 
cps functor third known monad transformer adds continuation passing monad 
monadic world define newtype cps ans cps ans ans computation represented function continuation result monadic function answer type computation answer 
world arrows represent continuation arrow function continuation passing arrow function continuation result continuation argument newtype ans cps ans 
ans lifting arrow cps type straightforward arrow ans cps 
order define basic arrow operations cps arrows find need application underlying arrow type 
instance arrow ans arr arr cps 
cps cps cps cps arr 
arr 


app define cps invoke continuation result second component argument 
scope arr binds name second component 
construct arrow representing continuation arrow continuation argument arrow forces app invoke 
way continuation passing higher order programming really surprising 
cps arrows inherit ability support failures failure handling underlying arrow type course support dynamic choice application 
give definition 
show define jump operator invokes continuation supplied input jump ans ans jump cps app combinator callcc passes current continuation argument arrow callcc ans ans ans callcc cps cps seen continuation passing arrows support application underlying arrow type supports application 
argument resulting arrow types correspond monads 
cps functor general cps monad transformer shown entirely arrows want continuation passing style 
arrow laws point ignored matter laws 
fact presentation monads section little oversimplified implementation return constitutes monad called monad laws satisfied return return laws state sequential composition associative return unit complicated slightly need pass values computation 
programmer relies implicitly monad laws time uses monad library worrying bracket sequential compositions 
place similar requirements implementations arrow combinators 
arrow combinators monadic ones require larger collection laws 
laws state section satisfied kleisli arrows 
simplify statements laws little noting ordinary function type declared arrow instance arrow 
arr 
ffi 
instance arrowchoice 
left left left left right right instance 
app course require composition associative preserved arr 


arr 
arr 
arr require extensionality principle arrows arrows behave inputs really equal 
formulate law follows arr 
arr 
oe dually 
arr 
arr oe follows arr id 

arr id composing side arr id id 
categorically speaking know arrows form category arr functor category haskell functions category arrows 
laws correspond sense monad laws go state laws arrow combinators required satisfy 
call arrow pure equal arr pure arrow side effects 
shall require combinators behave pure arrows functions arr arr left arr arr left furthermore require combinators preserve composition 

left 
left 
left similar properties second right follow easy consequences 
notice follow 

order differs sides 
reason favour left primitives usual binary counterparts laws satisfy simpler state 
formalise property depends components pairs follows 
arr fst arr fst 
general true 
arr snd arr snd right hand side side effects lost 
formalise intuition second component pair unaffected law allows function second component moved 
require function pure avoid potentially changing order side effects occur 
law 
second arr second arr 
dual statement second interchanged follows easy corollary 
note passing categorical properties products fail presence side effects 
example reader expect 

true pure side effects duplicated right 
laws serve models laws left require arr left 
left 
arr left right arr 
left left 
right arr note change order left right know pure change order side effects 
arrows supporting application require firstly currying applying identity arrow equivalent identity pairs arr arr 

app arr id secondly require kind parametricity property app permits operations moved applied arrow arr 
app second 
app arr 

app app 
laws prove analogue conversion applying constant arrow app equivalent arrow arr 

app currying applying arrow equivalent arrow arr arr 


app prove monad laws hold defined section 
remaining arrow classes just require associative zeroarrow unit 
stronger conditions example zeroarrow 
zeroarrow overly restrictive property fails stream processors example may produce outputs independently input 
general conflict desire hand state laws making possible prove strong properties generically kind arrow wish hand leave open possibility different implementations arrow signature 
believe laws stated section minimal set reasonable arrow type satisfy 
active web pages cgi programs arrows shown arrow interface generalise variety existing combinator libraries 
section shall discuss library currently developing inspired concept arrows 
application library addresses constructing active web pages pages may appear differently time visited 
active web pages represented programs may run client browser applets web server 
quite different technologies case concern programs run web server 
programs query database held server allow clients upload new data 
simple programs useful example enable students book meetings teacher researchers submit articles conferences 
active web pages sort implemented called cgi programs stored server 
client accesses url program run server output program usually html sent back client browser 
couple different mechanisms sending data client cgi program consider sends encoding fields html form web server request run program 
cgi stands common gateway interface protocol governing form data sent fro client server 
unfortunately mechanism awkward practice 
normally implementor cgi program wishes lead remote client series interactions example asking student identify offering choice meeting times confirming time booked 
interactions client take place runs cgi programs 
ask client question cgi program output question html form terminate 
client answers question filling submitting form general different cgi program run accept process answer 
leads poor modularity format form field names known program creates program interprets contents 
severe problem state cgi program lost interaction 
necessary save state cgi program explicitly interaction 
done server 
means certain client submit reply state saved server remain waiting reply came 
hand client submit reply back button browser reply question 
second subsequent replies handled properly state discarded reply received 
solution store state cgi program client question 
client submits answer state returned permitting cgi program pick point left 
think state kind continuation cgi program wishes ask client captures current continuation sends question client client replies continuation returned server invoked handle reply 
html provides mechanism handling data html form contain hidden fields contents returned unchanged server form filled submitted 
unfortunately html fields contain function values find different way represent continuations idea 
combinator library am developing takes care suspension computations saving state restart point 
lets cgi programmer view interaction client procedure call arrow ask cgi string string maps question client answer 
programs conduct series interactions implemented simply 
example consider program asks client question 
expecting reply old 
asks client question client answer sending client result answer old 
program implemented arrow arr question 
ask 
arr id ask 
arr answer choose arrow interface monad interface problem 
key observation guiding choice combinators need save entire state program ask operation difficult part program state may held free variables 
need concerned variables bound results computations may different value time program run 
monadic interface permits variables scope computations particular ask operations means values part saved state 
arrow interface permit way bind variable result computation arr combinator scope variable extend ask operation 
cgi arrows represented 
arrow invoked may terminate normally producing result may suspend ask operation 
suspension arrow produce state save question ask 
cgi arrow entered different ways may entered normally argument may resumed ask 
case supply state resume answer question 
natural representation cgi arrows newtype cgi cgi state string state string general cgi program may side effects server type allow 
shall represent cgi arrows arrows types practice arrows perform shall parameterise definitions underlying arrow type define cgi functor newtype cgi state string state string define type cgi kleisli io definition ask operation easily defined suspends entered normally delivers answer result resumed 
state needed resume ask operator assume state type includes constructor empty data state empty define ask follows ask arrowchoice string string ask cgi arr right empty jjj arr empty left alternative handles normal entry suspends ask question second alternative handles resumption delivers answer arrow result 
arr operator easily defined pure arrow suspend resumed need consider left summands 
arr arrow arr cgi arr left left define arrow composition need state 
composition arrows may suspend arrow second state save record case applied 
similarly resume composition arrows need know arrow resume 
shall extend state type record information data state empty state state definition composition 
arrowchoice cgi 
cgi cgi arr left 
jjj arr case left right right right 
jjj arr left 
jjj arr right arr left jjj arr right case 
handles initial entry composition just initial entry second case handles resumption tests see resumed sends resumption state appropriate 
arrow invokes terminates normally initial entry suspends hand records suspension occurred left operand 
arrow similarly records suspension occurred right operand 
record arrow suspension occurred resumption return point 
define combinator need state different way 
need record suspension occurred suspends arrow preserve second component input unchanged resume suspension need know value second component 
save state 
difficulty values saved different types different occurrences 
shall convert type saving states eventually embedded html fields convenient convert strings haskell standard function show 
resume state convert saved value back original type standard function read satisfies read ffi show id shall extend state type data state empty state state save string state define arrow show read cgi cgi arr case left 
left right save 
right read 

arr case left left right right save show initial entry just pass component input resumption reconstruct saved second component state 
final termination just pair output second component suspension save state 
notice type support read show operations types 
recorded type signature requires instance classes read show 
cgi arrows permit dynamic choices 
implementing left turns particularly simple left suspend input form left don need record additional information state allow decide invoke resumption 
left arrowchoice left cgi cgi arr case left left left left left right right right left right 
left 
arr case left left left left left right right right left right initial entry left pass inputs tagged left tagged right passed unchanged 
resumption left just resume terminates normally input tagged right left terminates 
suspends left state 
possible give appealing interpretation zeroarrow cgi arrows creates threads run parallel zeroarrow terminates thread 
mechanism enable cgi arrow ask questions interaction suspend 
omit details 
possible implement app 
difficulty types cgi arrows operate support read show intermediate values saved client 
cgi arrows implemented terms functions read written 
cgi arrow take cgi arrow input app defined 
library am developing ideas section necessarily little complicated 
oversimplification consider communication client consist single question answer multiple questions answers 
reality client sent html page containing html forms may contain fields 
full scale library includes combinators generating various html elements putting parts forms larger forms 
top level function cgi io takes arrow runs care encoding states hidden fields decoding data returning client 
major irritation far glossed cgi arrows instance arrow class defined 
problem lies types arrow methods section 
look back type requires type value saved instance read show classes 
type definition arrow class restriction 
implementation declared instance generic general 
attempt solve problem moving restriction different place 
define cgi arrow type applicable types classes newtype read show read show cgi state string state string categorical terms define new category arrows cgi arrows objects subset haskell types supporting read show 
implementation section constructs cgi arrow evident type support read show need explicitly require type 
result possible declare cgi arrows instance generic arrow class 
unfortunately 
haskell type system requires restrictions type declare satisfied cgi arrows 
haskell infer occurrence type cgi instances read show true way type restrictions datatype definitions interpreted 
consider defect haskell type system hopefully corrected version language 
absence correction obliged copy arrow library generic code uses difference type assigned arrow class required cgi instance 
doing benefit standard arrow interface cgi library combine cgi arrows arrow code program uses cgi library import special definition arrow class restricts arrows entire program types supporting read show 
frustrating 
note hindsight monadic interface 
define monad computations suspended resumed analogous way cgi arrows 
definition need record suspended value delivered suspension occurred concretely form state need carry extra component value problem recording free variables solved free variable ask operation bound result computation bound occurrence occurrence responsible saving value 
monadic interface possible believe efficient cgi programs 
monadic library suggest need save previously delivered value arrow library saves needed 
monadic library tend send information client 
course monadic library fall foul typing problem just discussed cgi monad declared instance haskell monad class 
consequently standard monadic functions haskell monadic syntax 
proposes replacement monads structuring tool combinator libraries arrows 
seen monadic library arrow interface kleisli arrows arrow interface strictly general 
seen monadic programming techniques analogues world arrows monad transformers functors standard monad constructions exceptions state passing continuations carry arrows generic monadic functions arrow analogue 
basing interface arrows monads permits finer distinctions distinguish kinds computation permit dynamic choices dynamic computations invoked 
advantage arrow interface wider class implementations monad interface general 
libraries data types simply monads arrow interface 
libraries include processes modelled stream processors fudgets libraries efficient parsing general library computes static properties computations advance running 
category includes number libraries highly useful practice 
giving arrow interface possible generic arrow code 
existing monadic libraries benefit replacing monads arrows 
motivation order introduce kind optimisation swierstra duponcheel 
believe may case conal elliot animation library eh als library hardware design 
short believe arrows offer useful extension generality generic library interfaces 
koen claessen mary sheeran singh 
lava hardware design haskell 
international conference functional programming baltimore 
acm 
ch carlsson 
fudgets graphical user interface lazy functional language 
fpca conference functional programming languages computer architecture pages 
acm press june 
eh conal elliott paul hudak 
functional reactive animation 
international conference functional programming 
acm sigplan 
hud paul hudak report programming language haskell non strict purely functional language march 
version 
sigplan notices may 
kw david king phil wadler 
combining monads 
glasgow workshop functional programming ayr july 
springer verlag 
sheng liang paul hudak mark jones 
monad transformers modular interpreters 
conference record popl nd acm sigplan sigact symposium principles programming languages pages san francisco california january 
ph peterson hammond 
haskell report 
technical report yaleu dcs rr yale university 
sd swierstra luc duponcheel 
deterministic error correcting combinator parsers 
john launchbury erik meijer tim sheard editors advanced functional programming volume pages 
springer verlag 
wad wadler 
replace failure list successes 
proceedings conference functional programming languages computer architecture pages nancy france 
wad wadler 
comprehending monads 
proceedings acm conference lisp functional programming pages nice france 
wad phil wadler 
essence functional programming 
proceedings symposium principles programming languages pages albuquerque new mexico 
wad philip wadler 
monads functional programming 
jeuring meijer editors advanced functional programming number lncs pages 
springer verlag may 

