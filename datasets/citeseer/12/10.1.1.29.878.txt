rice university linguistic reuse shriram krishnamurthi department computer science rice university houston tx usa thesis submitted partial fulfillment requirements degree doctor philosophy approved thesis committee matthias felleisen chairman professor computer science keith cooper professor computer science john dennis jr noah harding professor computational applied mathematics houston texas may linguistic reuse shriram krishnamurthi department computer science rice university houston tx usa programmers employ multitude languages build systems 
generalpurpose languages 
speci individual domains 
assist programmers di erent tasks domain modeling system validation representing general purpose program 
result programming languages key factors software engineering process 
rarely codi ed process treated systematically 
dissertation develops framework treat programming languages software engineering artifacts 
framework languages identi able reusable entities programmers compose link produce larger languages furthermore languages meet properties software components 
programmers augment lateral growth languages vertical growth producing languages synthesize languages 
software construction multiphase process 
phases programmers languages build programs earlier phases employ languages construct languages 
treatment languages artifacts addresses open questions 
acknowledgments chronological document privilege er 
parents love support sacri ce 
teachers helped get especially david john je conrad kent 
alejandro sch er bruce duba critical 
past members research group plt 
matthew flatt robby findler cormac flanagan teachers collaborators uence pervades 
people enrich department rice 
cartwright keith cooper peter druschel moshe vardi contributed immensely intellectual growth ann jean kept tasks check 
sunday morning crowd ian john paul gene kevin 
houston years memorable gerald phil margaret 
friends times places mihir greg ram 
dan friedman olin shivers phil wadler guidance perspective 
david applegate keith cooper john dennis serving dissertation examination committees 
john ames 
patience travels joy 
advisor matthias felleisen clari ed early nature research periodically corrected trajectory assembled superb group led example sure labor love 

contents ii acknowledgments iii language meaning intent uses language 
genesis domain modeling 
analysis system validation 
synthesis representing solution structure 
multi lingual programming 
deploying languages 
examples 
automata 
temporal programming 
software patterns 
presentation software 
summary criteria 
dissertation overview 
linguistic abstractions implementation principles 

macros 
conventional macros 
modular speci cations 
experience summary 
software components principles 
interaction linguistic abstractions 
linguistic abstractions components solution 
pragmatics 
programming unit lang 
component 
language reuse extension composition autonomous languages 
extension languages 
language composition 
macros 
compilers 
discussion 
expressive power unit lang temporal programming 
interaction languages 
languages implement language extension languages 
macro language composition languages 
communication channels 
macro de ning macros 
de ning complete languages lambda calculus 
interface languages 
vi datatypes 
signatures 
preserving linguistic abstractions related research limitations contributions bibliography chapter language meaning intent language surface thought 
john mccarthy uses language programming languages software engineering artifacts 
treat languages just software engineering artifacts 
create link extend compose independent fragments languages 
powers valuable critical 
valuable linguistic needs constantly grow evolve critical languages ective ways accomplishing important programming tasks 
result produce linguistic frameworks just programmers currently produce programming frameworks 
programmers instantiate specialize frameworks produce speci languages turn serve create actual programs 
features available programming language typically re ect ends language designed 
put di erently features delineate boundaries 
support programs fall boundaries complicate fall 
original ends control path evolution language 
short programming languages mirror preserve worldview designers users 
programming problems 
derive application domains di erent programming languages may demands cut languages 
result mismatch available languages problem 
cases usually bene cial adapt language suit current problem design implement complete programming language scratch 
genesis domain modeling domain modeling act capturing closely possible information problem domain 
languages model domains closely reduce potential programmers commit errors process information data 
process simplify task domain expert necessarily accomplished programmer capturing domain information 
consequently results computation terms easily understood domain experts 
short domain modeling simpli es interface user system 
historically programming languages designed domain speci re ect algol algorithmic notation fortran notation describing formulae cobol intended business applications lisp processing complex symbolic data 
languages evolved represent broader themes programming linguists sought understand principles underlie diverse collection languages 
lead period generalization 
bene ts period evident greater understanding unity diverse notations constructs approaches domain speci languages 
consolidation programmers speci city earlier languages attempted provide 
programming expands increasing number elds greater need languages closely re ect concerns speci elds 
analysis system validation domains application social demands software growing increasingly complex 
software expected protect privacy users identities secrecy information robustness computing environments 
demands virtually personal computers part single distributed potentially hostile network number computers grows daily new mobile embedded systems appearing continuously 
programmer provide guarantees 
problem validating computer systems essentially fold establishing policies enforcing 
creation policies broad social undertaking enforcement technical problem 
broadly forms enforcement post construction analysis construction time restriction 
analysis act validating existing artifact satis es speci cation 
typically axiomatic approach requires system builder construct appropriate proof methods prove artifact faithful sound complete requirements 
forms relatively simple common frequent type checking general problem extremely dicult practice intractable 
linguistic point view checks treated part language speci cation static dynamic checks implemented static dynamic semantic portions language 
example restrictive type system prevent construction programs terminate 
validation construction contrast constructive means construction limited valid artifacts built 
requires system builder identify construction process prove properties validity nally process construct software 
simple example technique structure editor allows construction syntactically correct programs 
interesting example programming language arbitrary looping constructs prevent non terminating programs 
synthesis representing solution structure programmer constructs implementation language accounting combination needs domain analysis software analysis ready build actual system 
process doing may reveal patterns language distinct patterns lead description language programmer may wish enforce 
short similar language design process resulting tasks performed entirely language 
describe abstractions restrictions programmer may construct linguistic layer atop chosen implementation language simpli es enhances language 
multi lingual programming preceding discussion mentions single language building system mono linguistic activity 
fact number domains numerous contributes modeling languages building suciently large system requires languages 
programmer task mix languages necessary implement system coordinate fragments written language 
shall see task induce design additional languages 
deploying languages specify language programmer minimum describe syntax semantics 
necessary sucient deployment semantics needs executable form language 
equally importantly programmer needs ability delimit scope language 
typical natural delimiter boundary separate compilation module smaller granularities broader ones dicult deploy 
mechanism deploy languages necessarily extensible respect set characteristics de ne language 
dissertation languages consist solely compilers run time systems 
production system programmers may want provide formal syntax speci cation type rules veri cation conditions describe language speci compiler optimizations forth 
mechanism described dissertation scales natural manner allow speci cations 
authors described domain speci little languages decades 
bentley especially uential presenting notion language abstraction programmers ectively construct software 
unfortunately literature follows established precise mechanisms describing reusing languages 
severely limits techniques large scale software development 
bentley described syntax rewriting tools awk implement little languages 
crucially ignore relationship syntax languages semantics 
particular silent di cult question state run time system 
problem source component translated equivalent existing language linked run time system user explicitly manage details linked singly shared manner depending shared state implementation policies left user implementation technique ers assistance process 
dicult impossible compose languages due potential interference run time systems 
problems programmers need tool support ective language 
implementation language tools syntax checkers program type checkers forth 
ective linguistic reuse strategy easy harness existing tools related new languages 
short successful language depends precise description syntax semantics support tools facilities growing combining languages ability embed language 
examples automata suppose programmer wants distribute code creates executes nite state automata 
programmer wish de ne library types procedures classes methods hides actual representation automata 
information hiding matters signi cantly di erent ways representing automata data structures executable values 
data structures useful manipulating automata data minimize 
run interpreter relatively inecient 
automata created solely run typically ecient translate directly executable code functions labeled statements 
library er way specify automata intuitive manner 
allow library client code contain expressions shown gure 
example uses new construct automaton de ne automaton starting state checks automaton state state error state state state state error state error state automaton description lambda input stream letrec state lambda case token input stream error state state raise new unexpected input exn state lambda case token input stream state error state raise new unexpected input exn error state lambda case token input stream raise new unexpected input exn state compiled automaton representation stream begins alternates strictly values 
speci cation gure translate scheme code shown gure 
represents automata procedures consume input stream 
states nested mutually recursive procedures 
procedure represents state transition relation 
unexpected inputs generate exception unexpected input exn transition relation transitions represents error state 
automaton attempts inspect past nite input stream di erent exception raised client handle observe successful completion 
programming languages scheme optimize calls tail position jumps goto state transitions example quick accumulate evaluation context colloquially stack space 
unfortunately library programmer de ne automaton procedure 
sub terms automaton expressions scheme terms distinct domain speci language 
furthermore automaton binding construct clari ed gure de ned procedurally 
automaton de ned terms traditional programming language constructs 
automaton library contain operations form 
instance may provide means interleaving execution automata 
enable client programmer write run alternating stream stream runs automaton stream stream stream strict alternation 
case sub expressions run alternating look legal scheme expressions scheme call value evaluation order rst run stream termination may occur begins run run alternating procedure call value language 
constructs illustrative class useful important abstractions help programmers write software ectively procedural 
de ne notations part language syntax 
cases require behavior di erent language semantics speci es 
temporal programming programming languages provide programmer means modify current state 
programmers mutations low level surrogate high level notion events 
state mutation represent occurrence event event observers inspect location determine event occurred 
event progression time 
state purpose programmer wish time explicit notion language build time model language 
presents simple example language time discrete periodic 
speci cally add keyword language value increases second 
language interesting property program sleep pauses seconds evaluates false program sequential single threaded 
numerous design decisions arise implementing language 
mundane questions include time change 
interesting clock synchronize gets charged computational resources consumed clock forth 
return discuss issues section 
interface void void class void fg void fg adapts class implements public void public void adapter pattern java version software patterns languages useful enforce structural properties programs 
section discusses samples structural properties integrate programming process 
applied design patterns design patterns sketch solution class related problems 
customizing pattern context programmer reuse solution 
patterns represent general architectures instantiated ectively di erent contexts 
researchers call architectures software patterns 
illustrates sample software pattern java 
code gure uses adapter pattern enables reuse existing class di erent interface 
speci cally suppose existing class implements desired functionality implement desired interface 
adapter acts surrogate class implementing desired interface forwarding requests instances existing class tailoring responses interface 
example interface represents output generators interface methods void void class methods void void adapter adapts elds methods public void public void adapter pattern speci cation version implemented actual generators various devices 
vendor provided performs graphical output implement interface 
gure programmer creates adapter class forwards requests instance 
brevity elide details actual methods 
relationship documented informally comment 
programmer mistake de ning class client type variable var assigning instance class client var new unfortunately class adapted interface adapted 
type checker ags assignment error message test java incompatible type new 
convert 
var new example illustrates ects programming directly terms pattern constituent constructs implementation adapter pattern terms plain classes interfaces obscures pattern identity decreases clarity program 
dicult readers understand structure intent code 
increases potential errors due volume code 
pattern code handles administrative tasks maintaining invariants programmer correctly implement initial development remember update maintenance 
simple example instance programmer remember implement interface declare type 
dicult replace code pattern instance improved version extensible ers better protection errors 
feedback reported terms individual units code programmer manually extrapolate error message original pattern design 
short programming directly constituents patterns potentially ect programmers stage implementation debugging maintenance 
programmers reduce complexity harnessing power patterns designing languages express relationships 
composition invariants smaragdakis batory approaches validating correctness module compositions 
express compositional requirements type system 
instance suppose implementation virtual machine include module tags memory representations data tag implements garbage collection gc 
furthermore suppose gc module requires tag module composition 
ensure tag module added gc declares dummy variable type name empty class declared tag module 
tag included composition hierarchy gc dummy variable declaration raise type error indicates erroneous composition 
alternative implement approach explicit constructs validating compositions 
ers advantages 
class variable declarations play role execution program 
obscure behavior potentially making dicult maintain 

invariants tricky implement 
safer implemented automatically program manually programmer 
especially important negative properties require quadratic number size program number properties dummy variable declarations 
new property introduced programmer add class hand 
properly designed language extension programmer establish single point control greatly reduce required specify program properties 

invariant violated programmer get error terms actual invariant just terms names represent source 
smaragdakis batory identify issue slide show 
slide setup role playing game kinds characters frogs subjects mythical kingdom population actions grow time 
presentation description major problems approach pg 


adding dummy variable declarations programmer accidentally choose name di erent purpose 
speci cations speci cation techniques fall rubric 
instance structure operators simplify process describing traversals recursively de ned types 
generated automatically type speci cation 
de ning recursive procedures types programmers compose high level operators translated regular recursive procedures 
translation raises issues name clash management feedback reporting handled framework 
presentation software presentations programs 
contain data content slide require control transitions slides animations 
commercial presentation software bu ers users linguistic nature talk 
powerful presentation tool presents user direct programmatic control content talk 
talk program consists primarily constructs data control 
data take form slides model slide slide simplicity stylized form html represent content slide 
slide show sequence slides slide show 
slide show construct creates new presentation window renders slide turn window 
contains excerpt slide show 
presenter wish combine various existing talks create new presentation 
presenter employ module system underlying language organize fragments 
na implementation system lead unintended results 
slide show constructs new presentation window presentation composed existing shows disjointed unwieldy 
programmer constructs presentation language needs create single shared state case presentation window modules containing slide shows 
arranging sharing tricky ad hoc remains crucial need language constructs 
summary criteria constructs described automaton run alternating simple examples linguistic abstractions 
typically main uses ect order evaluation 
instance run alternating requires delayed evaluation call value language 
implementation scheme wrap expressions procedures invoked control stepping 
create new binding constructs 
translation automaton procedures turns names states binding bound occurrences variables 
mask creation data structure 
straightforward implement automaton produces traditional data structure representation automata 
automaton example illustrates single abstraction may require capabilities simultaneously 
especially happen case data languages constructs supposed mask representation data client programmer 
linguistic abstractions especially important context way mask concrete representation ensuring representation independence 
languages instance impossible write expression dynamically generates procedure 
extremely dicult impossible write automaton abstraction means resorting limited sense interpretation 
dissertation overview having introduced motivated linguistic abstractions ask describe broad classes linguistic abstractions 
group linguistic abstractions delimit 
compose reuse groups abstractions 
reuse existing tools programming languages compilers type checkers language extensions 
chapters address questions 
chapter linguistic abstractions implementation macros executed read time 
alan perlis programming principles linguistic abstractions take forms established part programmers toolkits diverse domains 
shall rst consider particularly useful special case linguistic abstractions called macros 
macros scheme tree transformers rewrite concrete syntax trees 
traditional scheme programs program text interspersed macro de nitions 
macro preprocessor gathers de nitions source expands uses macros source reaches canonical form 
short macros serve language extension speci cation macro processor acts compiler macro enriched language base language 
macros express linguistic abstractions automaton run alternating described section 
framework creating languages automata 
explain series examples re ecting increasingly complex protocols 
examples intentionally simplistic illustrate principles independently details actual systems built techniques 
de ne macro automaton 
automaton start state state name input new state 
syntax lambda input stream letrec state name lambda case remove token input stream input new state 
raise object unexpected input exn 
start state automaton macro macros examples automaton run alternating expressible macros 
macros descendants lisp scheme 
transform tree shaped data manipulating data string processing macros pre processor 
short macros implement simple form extensible parsing 
parser conceptually table rules map syntactic shapes code 
input matches shape called trigger parser looks trigger transformation rule called elaborator uses produce syntax 
parsing table traditionally xed limiting input language parser recognize 
macro de nitions add rules parser table 
traditional parse rules macro rules directly generate syntax 
generate terms source language 
parser analyze generated term 
process continues program canonical form 
programmer de nes triggers pattern matching notation trigger really just pattern sense pattern matching di erent term avoid confusion design patterns 
de ne macro automaton 
automaton start state state name input new state 
syntax automaton rep start state list state rep state name transition rep input new state 
alternate automaton macro originally due kohlbecker wand 
input term matches trigger matcher generates pattern environment maps pattern variables corresponding source terms input 
invokes elaborator generate source term 
term parameterized sub terms input 
elaborator extracts input sub terms pattern environment 
presents concrete example macro automaton construct section 
keyword de ne macro followed set literals automaton may appear input 
literals followed trigger 
symbols trigger appear literal set pattern variables 
pattern followed ellipses 
matches zero instances pattern 
binds pattern variable sequence sub terms correspond pattern variable position matching instances 
ellipses nested arbitrarily deep 
macro de nition speci es elaborator keyword 
elaborator uses syntax construct new source term 
syntax form consumes template converts template term source language replacing pattern variables bindings implicit pattern environment 
output term start state state name input new state replaced corresponding source text input expression names inserted literally 
macros sort traditionally put main uses create new binding constructs 
procedural translation automaton turns state names binding bound occurrences variables 
mask creation data structure 
shows alternate implementation automaton represents automata data structures 
represent structural program properties uses design patterns 
ect order evaluation 
instance run alternating requires delayed evaluation call value language 
macro wrap expressions procedures invoked control stepping 
di erent applications choose alternate expansions mechanism described section intervention user speci es automata 
conventional macros conventional macros describe interesting linguistic abstractions powerful programming tasks 
generalizes macros ways 
key innovation equip generalized macros attributes propagate information program allow programmers attributes guide elaboration 
expansion parsing parsers type source ir document features useful practice macro writer specify guards structure sub terms 
de ne micro test lambda ir dispatch syntax test dispatch syntax dispatch syntax micro speci cation source type source expressions ir intermediate representation 
macros denote source source rewriting functions type source source cases programmers writing language extensions need power generate terms type ir directly 
allows programmers create called micros type source ir practice parsing process described section parts create ir dispatcher pattern matching invokes elaborator 
elaborator macro dispatcher applies parses output repeating process elaborator micro 
ect dispatcher called dispatch type source micro source term returns corresponding micro 
micros represented procedures arguments create ir type denote ir reason seemingly needless level indirection clear discussion 
output micros macros expanded de ne micro test lambda env ir dispatch syntax test env dispatch syntax env dispatch syntax env de ne micro lambda lambda lambda vars body lambda env lambda ir vars dispatch syntax body append vars env micros attributes type ir 
put di erently micro invoke dispatch reduce source terms ir 
shows micro de nition simple conditional construct 
de ne macro de ne micro followed list literals trigger pattern 
right keyword speci cation micro elaborator procedure arguments 
elaborator uses ir construct ir representation expressions 
invocation dispatch syntax test extracts source term corresponding test pattern environment uses dispatch obtain corresponding micro invokes micro procedure arguments generate ir value test attributes suppose programmer wants simple value inspection facility 
speci cally expression dump print names values variables bound lexical scope 
provided access names variables lexical context transformation associated dump quite straightforward 
mac allows programmers contextual information explicit associating attributes dispatcher 
programmer may wish de ne type micro env ir env type lexical environment 
micro inspect environment determine names bound variables 
type generalizes attr 
ir indicate attributes 
micro accept attributes propagate micro dispatches sub terms 
presents de nition lambda ects set lexical variables listed env revised de nition doesn 
application invoke dispatch source program supplying appropriate values attributes 
result invoking dispatch ir value program subsequent processing 
applications type source ir exploit attributes ability transform representations 
threaded attributes possible ir choose may set values language 
case parser may convert programs nal answers may really interpreter 
expect deal transformations 
useful prototyping small embedded domain speci languages optimizing code generators 
attributes represent various aspects language evaluation 
gure example environment maintains list names bound context interpreter environment map names locations values 
non trivial languages kinds attributes 
attributes environments functional meaning represent computational ects 
attributes threaded 
ected processing subterms order propagation processing sub term matters 
canonical example attribute store 
store passed sub terms side ects evaluation visible 
micros return updated values threaded attributes ir 
type micro interpreter implementation env store ir store general micros type shape 

ir 
micro programmer responsibility invoke provide arguments attributes accept nal ir value values threaded attributes process 
illustrate new form micro de nitions gure implement stateful language purely functional manner store passing style technique denotational semantics 
set 
scheme assignment statement 
code uses scheme multiple value facility return actual value potentially modi ed store 
modular speci cations far discussed kinds transformations programmers express 
section discuss programmers group transformations reusable units 
de ne micro set 
set set 
var val lambda env store values val value val store dispatch val env store values value void value new store extend store var val value de ne micro function applications literals fun arg lambda env store values fun value fun store dispatch fun env store values arg value arg store dispatch arg env fun store functions return value store pairs fun value arg value arg store threaded attributes de ne scheme exprs vocabulary de ne micro scheme exprs set 
set 
var val lambda vocab env store de ne micro scheme exprs fun arg lambda vocab env store de ne automata vocabulary de ne micro automata automaton 
automaton 
lambda vocab 
de ne micro automata run alternating run alternating 
lambda vocab 
vocabulary speci cations de ne compiler vocabulary de ne micro compiler var val 
body de ne micro compiler letrec letrec var val 
body de ne compiler language extend vocabulary scheme exprs compiler de ne analysis vocabulary de ne micro analysis 
de ne micro analysis letrec 
de ne analysis language extend vocabulary scheme exprs analysis tool dependent expansions vocabularies programming languages consist sub languages expressions statements types argument lists data 
programmer specify sub language micro extends 
provides vocabularies purpose 
vocabulary grouping related micros 
micros vocabulary satisfy type signature 
illustrates revised declarations earlier examples 
micro declares membership vocabulary just specifying literal set 
sum declarations vocabulary speci es syntax elaboration rules language 
put di erently vocabulary describes syntax table dispatch parameter dispatch 
update type dispatch section re ect source vocab micro change type dispatch forces update programming pattern micros 
recursive call dispatch pass vocabulary invoked micro accept 
describe micro may know vocabulary 
micros take vocabulary selected argument gure micro accepts vocabulary vocab rst argument process sub terms language alternatively choose di erent vocabulary sub terms languages 
instance function declaration may sub terms expression language language types 
micros type scheme vocab 

ir 
composing vocabularies allows programmers extend compose vocabularies construct new ones 
programmers divide language sets related features compose features build processor complete language 
programmer create extension vocabulary overrides de nitions base vocabulary tool speci constraints 
explains micro may know vocabulary non overridden micros base new composite vocabulary 
scenario analogous instance variables object oriented language reside class extensions 
vocabularies generate programs various interesting ways traditional transformation techniques limited applied macros templates usually restricted expression statement languages programmer write transformations sub language 
instance de ne abbreviations types extend language procedural parameters 
realistic programming environments di erent program processing tools di ering views underlying language 
example compiler translate binding construct creates non recursive local bindings local function application treating letrec intro duces mutually referential local bindings primitive 
contrast polymorphic type inference engine treat core form transform letrec primitive term 
distinctions easy express vocabularies shown gure 
function extend vocabulary extends language rst argument triggers second overriding clashes favor second 
languages allow programmers write lexically scoped macros 
easy de ne 
micro lexical macro construct creates temporary vocabulary populates local macro extends current language new macro 
local global changes language extension disappears body parsed terms outside lexical context una ected 
programmer vocabularies organize traversals program 
typically earlier passes synthesize information passes 
example programmer may want add rst class closures object oriented language java 
translator implements transformation need determine free variables closure body create class represent closure move de nition top level required languages rewrite creation uses closure 
series vocabularies solves problem elegantly 
rst maintains lexical environment traversing code gure encounters instance closure construct traverses body vocabulary computes set free variables 
list free variables ir vocabulary 
generate class de nition 
threaded attribute accumulates top level de nitions created internal contexts propagates outward 
vocabulary rewrites creation expressions 
determining uses done type information dynamic check depending target language 
larger language constructed composing smaller language layers programmers de ne restricted versions larger language leaving layers 
ability especially useful drscheme programming environment presents scheme programming language sequence increasingly complex sub languages 
hides complexity complete language student particular ags terms errors linguistic subset legal student expected full language 
provides better feedback environment just complete language considerably improves learning experience 
manner system builder provide safe subsets language security purposes language sans le system system call primitives web server evaluate potentially malicious foreign code fear destroying local les 
experience summary successfully implemented deployed drscheme programming environment 
implements features discussed section exploited run time system 
vocabularies provide teaching languages students full scheme language advanced programmers 
drscheme universities high schools worldwide routinely distributed cd roms 
student vocabularies compile programs advanced fragments language source preservation facilities ensure beginners confront advanced features interactions 
employed tools drscheme suite including compiler syntax checker static analysis engine 
chapter software components rogers said thing free variable 
alan perlis programming principles modules widely organize program fragments 
modules come forms especially interested properties 
module compiled separately modules 
object code distributed source code 

module explicitly states import dependencies designate modules satisfy imports 
modules satisfy dependencies selected link time 

module linkage hierarchical 
criteria call modules units semantic reuse correspond properties components 
term component programming refer construction programs linking modules properties 
linguistic constructs class extensions components 
discuss brie section section 
de ne database unit import export new add lookup keys de ne new null de ne add key value db cons cons key value db de ne lookup key db cdr key db de ne keys db map car db de ne customers unit import new db add db export mailing list de ne mailing list add db root add db bubba new db de ne spammer unit import db keys db lookup mailing list address export de ne spam key printf sending mail address db lookup key mailing list funny mast map spam db keys mailing list de ne spam operation compound unit import addr link db database addr customers db new db add spam spammer db keys db lookup addr mailing list addr export de ne sender spammer invoke unit spam operation sender units mzscheme combination macros components potent address di erent important programming needs 
understanding specifying interaction open problem 
combining components macros trivial macros ect component properties modules 
speci cally macros insert unbound names component source rendering impossible assign meaning component 
explore problems detail section 
document uses mzscheme unit construct principal vehicle component programming 
unit separately compilable code container 
units closed respect imports meaning xed relative meanings imports 
export values exports connected imports units 
process wiring exports imports creates compound units turn units 
unit implementation compiles unit de nition 
evaluation triggered satisfying unit imports explicitly invoking 
result value expression unit body extended compound units order linkage 
provides example syntax behavior units 
unit bound database de nes exports operations 
customers unit imports uses construct mailing list 
spammer unit imports uses generate messages 
exports invoked prints messages sending mail returns list printing operation return values 
compound unit bound spam operation links units 
constituent unit compound unit assigned internal label case db addr spam 
labels refer respective linked units 
compound unit links db exports linked units 
combination exports db addr compound unit import addr satisfy spam unit imports 
link addr uses external internal name list 
invoking compound unit evaluates code constituent units 
interaction linguistic abstractions traditional macro systems languages lisp program text interspersed macro de nitions 
macro pre processor gathers de nitions source expands uses macros source 
short macros serve language speci cation macro processor serves compiler enriched language base language 
resulting program processed standard suite tools base language compilers program analysis engines 
phase separation implies language macro de nitions distinct base programming language 
macro de nition language needs ability construct terms base language 
separation illustrated macro system macro de nition language obeys di erent lexical conventions base language pre processor separate application traditionally called cpp 
likewise language templates essentially functional language quite di erent 
macro de nition language underlying language traditional lisp implementations really thought distinct instances language running di erent phases 
phase separation unfortunately semantics macro 
interesting macros expand uses language primitives meaning depends machine executes program user de ned names meaning typically speci ed macro 
general name free macro generated source needs meaning 
consider macros de ne stack abstraction terms lists empty stack set 
cons empty stack null represents empty stack list token push set 
cons mutates variable representing stack pop verify stack non empty car set 
cdr uses auxiliary procedure verify stack empty check stack empty report error encapsulating macro de nitions inside component highlights subtle interactions give rise classes problems syntax resolution components closed macros de ned component explicitly imported 
macros de ned component exported authors components reuse macros 
macros imported exported syntax transformers ordinary values available compile time exports imports resolved link time 
name resolution macros resolved compilation names introduce cause diculties 
expansion pop introduces names verify stack non empty procedure built scheme expanded code closed verify stack non empty added unit imports 
meaning resolution expansion pop relies names built scheme including set associating explicit meaning names 
programmer re de nes locally re binds macros exhibit behavior di ers arbitrary ways intended designer 
mutations may non local inadvertent making programs extremely dicult debug 
situation exacerbated languages scheme primitive procedures syntax re de ned 
recognition problems macro systems implement property called referential transparency expects free names resolved scope macro de nition 
property address problems 
guard mutations 
second covers names framework meaning part syntax just identi ers altered 
importantly property de ned modular programming context authors leave extension 
syntactic closures similar goals similarly fails address interaction components 
apparent solution problem name resolution add required names component imports 
closes syntactically user macros know names macros introduce clients components burdened implementation details link names implementations macros change introduce di erent set names author clients noti ed change implementation component instantiated client undesirable reasons explained section 
worse third parties control linkage macro designer assume meaning linked implementations 
linking wrong unit hinder meaning resolution 
steps automated automation fails components rst class values units mzscheme 
languages programmer write arbitrary programs choose component run time statically determining undecidable 
impossible statically associate component implementation names macros 
chapter linguistic abstractions components things wish say programs known languages said poorly 
alan perlis programming chapter addresses problems raised previous chapter 
presents model combining linguistic abstractions presence component programming constructs 
solution dissertation addresses problem combining linguistic abstractions components introducing new language construct unit lang 
new construct conservatively extends mzscheme units 
syntax syntax unit lang declaration unit lang import 
export 

meta variables range identi ers expressions 

imports 
exports 
constitute body unit 
name speci es language unit written 
language speci es syntax semantics unit body 
unit lang expression position unit expressions allowed 
basic model call administrator unit lang lingo 
performs actions language registration lingo native language scheme implements scheme unit extensions 
programmers register languages lingo 
compilation lingo compiles non native language unit encounters 
lingo examines output compilation repeatedly compiles unit obtains native language unit 
execution lingo invoke programs units imports 
knows invoke programs native languages 
compilation units encounters 
actions lingo performs 
actions de ned language executed inside unit written language 
lingo rudimentary command shell interface 
languages user initiates lingo session lingo loads languages programmers registered unit de nitions 
simplicity elide details programmer registers languages lingo assume located xed directory 
registration lingo check language de nitions properties type correctness 
non native language de nition consists units compiler unit run time system unit 
units imports exports 
invoked return single procedural value compiler linker respectively 
lingo invokes unit language registration phase stores resulting compiler linker table type 
compiler alse linker alse name registered language types compilers linkers described 
eld table alse corresponding unit provided registration 
languages useful compilation rely presence run time system execution compiled code proceed absence compiler 
rationale 
implement compiler run time system units reasons 
de nitions compiler linker rely de nitions encapsulated conveniently unit 
distributed easily components 
compilation lingo encounters unit lang import 
export 

native language lingo uses compiler transform declaration linker language unit lang scheme import pc 
export unit lang tc import 
export ec 
bc subscript indicates term generated compiler 
imports 
name primitives rationale 
layer expansion binds primitives unit procedure units import values 
permits macro designers expose side ects units language 
type compiler expr list id list id list expr target list id list id list id list arguments represent source component body imports exports 
lingo applies compiler arguments 
returns result compilation values 
target language compilation 
body unit compiled 
names imports 
names exports 
names primitive values run time unit provides 
compilers general macros collection macros turned compiler convenient interface see section 
linking execution unit lang unit participates kinds link operations 
rst programmer speci es manually traditional unit linking compound unit shown gure 
contrast lingo automatically links units implementations primitives macro expansion introduces unit 
second type linking transparent programmer 
elaboration unit lang declaration rst extracts linker component lingo table linker language 
linker procedure type unit unit consumes unit outside box links primitives run time unit 
result satis es expected interface closed values primitives 
automatically linking values run time unit xes bindings names elaborated code 
names transparent programmer original unit programmer code alter values bound names 
language designer determines semantics language unit programmer inadvertently alter semantics 
rationale 
procedures natural way represent compiler linker 
languages procedures accept return units values outer term replaced directly code dynamic linking 
outermost expressions transformation represent curried application linker language scheme expressions 
lingo unit manager scheme evaluator expressions fall outside language understands 
language explicit transformation invoke unit unit lang scheme import export linker language unit lang scheme import 
export unit lang tc import 
export ec 
bc outermost unit exists solely assign meaning linkage expressions 
unit transparently invoked client programmers notice presence 
linker language procedure built scheme language implementation 
call transformed expression object form original unit 
pragmatics unit lang construct desirable bene ts program distribution programmers distribute unit lang units forms source code source program compile run implementations er compilers run time systems languages source 
object code object form closed program compiled distributed clients black box object code format 
instance lingo run object code needs run time system units compiler object form contains result applying source language compiler 
run time systems distributed component 
separate compilation design conservative extension units inherits properties units external linkage speci cations graphbased linking multiple dynamic linking 
particular original units compiled separately linking units de ned unit lang 
hygiene compilers free rename primitives imports exports 
may chosen names con ict target language import name reserved word 
commonly compiler may rename binding bound instances variables avoid inadvertent capture variables programmer source inserted macros 
called hygienic expansion 
supporting hygiene object form slightly elaborate ensure clients detect renaming invoke unit unit lang scheme import export linker language unit lang scheme import pc 
export unit lang tc import 
export ec 
syntax export speci cation unit renames internal name programmer speci ed external name units export name renaming necessary ensure external clients need handle internal renaming 
units import position similar renaming imports necessary 
particular choice renaming exports imports artifact de nition units vary depending component construct 
variable target languages compiler choose target language source generated code 
suppose optimizing compiler prove primitives unit applied arguments wrong kind 
generate code language provides versions primitives perform safety checks arguments 
di erent implementations target language checked primitives checked unchecked ones distinguished having di erent names presumably distinct implementations 
staging run time system state unit lang framework intrinsically supports levels run time system state language wide unit wide 
application writers may need create intermediate level state shared units written language 
unit lang scheme automata import export de ne automaton state state error state state state state error state error state error scheme automata easily express idea framework creating new language trivially maps original language run time system holds state common subset units 
illustrates broad applicability languages utility unit lang programmers employ general purpose language 
programming unit lang section illustrative example unit lang 
rst show users program unit lang describe language implementor support users 
transformed version example 
language automaton form translates sub expressions group mutually nested procedures representing states 
generated code raises exception illegal inputs 
type exceptions represented class unexpected input exn 
shows language scheme automata 
gure units scheme automata share values named producer de nes automata consumer consumes runs alternation 
units share values unit boundaries fashion depends semantics compound unit import link producer unit lang scheme automata import export de ne automaton state state error state state state state error state error state error de ne automaton state state state consumer unit lang scheme automata import stable export lambda stream run alternating stream stable stream producer producer export compounding scheme automata units unit lang scheme def syn import export de ne primitives unexpected input exn de ne syntax automaton syntax rules 
start state state name input new state 
lambda input stream letrec state name lambda case remove token input stream input new state 
raise new unexpected input exn 
start state de ne compiler generate compiler primitives compiler scheme automata compiler unit lang scheme import export de ne unexpected input exn class 
lambda invoke unit unexpected input exn scheme automata run time system loader language scheme automata unit lang scheme import unexpected input exn export unit lang scheme import export de ne lambda input stream expanded code letrec gure raise new unexpected input exn state scheme automata expansion run time system gives primitive values language revisit issue section 
language speci cation elaboration presents compiler unit scheme automata 
compiler unit returns actual compiler 
name primitive value unexpected input exn provided generate compiler generates compiler proper 
shows implementation run time system includes de nition unexpected input exn eventually linked implementation class required macro 
expression run time system linker scheme automata units 
links argument unit implementation primitive demanded scheme automata compiler 
lingo encounters unit written scheme automata gure feeds unit source scheme automata compiler links result implementation primitives 
core compiler generated object form shown gure 
compiler scheme automata written language scheme def syn scheme enriched macro de nition construct 
speci cally scheme provides new syntactic forms de ne syntax generate compiler 
scheme def syn compiler parses scheme automata compiler unit body accumulates de ne syntax macro de nitions table 
uses table replace invocation generate compiler expression evaluates compiler expands macros leaving code una ected 
compiler uses scheme target language 
scheme def syn language helps users ignore di erence macros compilation allowing traditional macro de nitions serve speci cation compiler 
language implementer responsible ensuring run time system provides correct values primitives compiler expects proper order 
component general component code container additional properties 
component written multitude languages provided carries suitable language annotation 
result imagine stable constructs similar unit lang component constructor 
general elaboration constructs similar avor model adjustments di erences units constructs 
de ner lambda lang instance function application place unit invocation link implementations primitives 
functions languages follow call value discipline fails provide implicit aliasing values unit import provides 
address shortcoming implementor lambda lang implicitly box values exported run time system implementations rewrite source unit body automatically unbox primitives disallow mutations primitives 
transformation languages implementations depend aliasing need implement 
constructs lambda lang added suitable base language 
consider program fragment unit lang import export lambda lang body outer unit expanded results unit lang import export loader language unit lang scheme import prims 
export lambda assuming compiler preserves informal meaning lambda lang alter body function 
host language lambda lang provide function application loader language primitive unit lang lambda lang box semantics described 
di erent base language built functions units core component model similarly implemented 
chapter language reuse extension composition understand write program get write 
alan perlis programming description unit lang chapter treats language descriptions monolithic entities 
practice language implementors want describe languages modular fashion 
compose reuse existing languages build new ones performing component language construction analogous component program construction 
section described construct called vocabulary 
vocabularies modular language descriptions de ned composition interfaces 
vocabularies programmers divide language sets related features compose features build processor complete language 
programmer create extension vocabulary overrides de nitions base vocabulary tool speci constraints 
combine languages programmers combine compilers run time systems 
arbitrary languages de nition combination ambiguous 
task de ning composition language designer extending unit lang mechanism expressing compositions 
words unit lang provides mechanisms atop language implementors implement policies appropriate languages 
autonomous languages simplest way reuse language target compilation language 
new language call autonomous inherits implementation tool support target language greatly reduce implementation burden 
importantly allows correctness guaranteed modular manner implementor new language exploit proven properties target language 
case corresponds traditional language implementation strategies translation assembler scheme autonomous language need syntactic similarity target compile 
typically requires speci cation complete compiler 
dependency implementation run time system 
suppose compiled run time system linked unit language result primitives run time system computationally meaningful unit 
run time system implemented language semantics compatible extension languages second technique reusing languages making new language extension existing language extended features map host language 
extension language shares possibly extends syntax existing base language 
say extends responsible remaining faithful syntax result compiler may implemented strategies directly extension compiler indirectly employing language describe extensions delegating responsibility faithful syntax implementation language provides guarantee preserving syntax run time system provide values compatible linking unit 
extreme case may add new syntactic features 
extension 
adding syntactic features equivalent adding compiler may list additional primitives de ned run time system 
basic demonstrates unit lang encompasses rudimentary form linguistic extension creation libraries framework 
creating libraries provides programmers unexpected power libraries exploit property run time system implementation unit evaluated exactly specify initialization code uses 
code contain mutational operations programmer clear guarantee number times evaluated 
contrast traditional unit linkage dicult preserve property client linking property forces evaluation way avoid know clients advance invert traditional design allowing number evaluations level abstraction determine linking structure 
language composition model section inhibits certain types extensibility 
speci cally compiler unit linker unit returns procedural value compiler linker 
sucient compiling unit provide information program attempting combine compiler language produce compiler compound language 
compiler unit returns values compiler language speci datum represents composition information 
linker unit similarly returns linker composition information 
exploited compilers linkers compound languages 
correspondingly compiler linker units accept import primitive look composition information language 
supporting language combination requires changes unit lang 
compilers run time systems compose slightly di erent ways compilers compilation take place single step 
language may di erent syntactic properties serial application compilers composing applying source program 
instance consider extensions simple lambda calculus language cons quote rst converts quote nested sequence cons interprets stack primitives 
consider program push quote push stack applying stack compiler knows quote transforms push quote set 
cons stack transcribed incorrect nal expression push list set 
list cons stack composite compiler generate push cons push cons cons empty stack compilers composed traditional functions compiler processes output 
code compiled compiler represents composition individual compilers 
run time systems run time systems di er compilers important ways provide values names applied serialized compiler 
run time system may contain state shared components written language composite languages derived run time system modi ed copied manner 
furthermore language implementation run time system 
run time systems serialized treated atomic unique language 
result compilers previously returned list identi ers return list list identi ers 
sub list identi ers corresponds provided run time system 
new types 
alse alse expr list id list id list expr target list id list id list id list list consider special cases language composition de ned macros follow particular compiler composition policy 
macros macro expander viewed program nite table rewriting rules applies program source rules apply 
view combining macro languages easy corresponds merging tables care detect resolve con icts due overlap triggers rules 
combining run time systems easy assuming con ict names names automatically renamed 
composition macro languages easily described revised unit lang framework 
exp interp exp num de ne interp expr error interp semantics expr exp num val plus lhs rhs de ne struct num val de ne struct plus lhs rhs interp exp num de ne interp expr cond num 
expr num val expr plus 
expr interp plus lhs expr interp plus rhs expr error interp semantics expr compilers writing composable compilers general intractable problem 
justify claim appealing long line research composing denotational semantics 
little discipline programmers write compilers composable compatible compilers 
illustrate programming pattern presenting series interpreters simple arithmetic language 
domain speci details computing answer opposed generating code computes obviously di erent interpreters denotational semantics solutions similar 
problem composition arises protocol assume yield control components protocol applies interpreters semantics 
exp num val plus lhs rhs minus lhs rhs de ne struct num val de ne struct plus lhs rhs de ne struct minus lhs rhs interp exp num de ne interp expr cond num 
expr num val expr plus 
expr interp plus lhs expr interp plus rhs expr minus 
expr interp minus lhs expr interp minus rhs expr error interp semantics expr exp interp exp num de ne interp expr error interp semantics expr exp 
num val plus lhs rhs de ne struct num val de ne struct plus lhs rhs interp exp num de ne interp interp interp interp exp num interp interp interp de ne interp interp interp de ne interp expr cond num 
expr num val expr plus 
expr interp plus lhs expr interp plus rhs expr expr interp extension exp 
minus lhs rhs de ne struct minus lhs rhs interp exp num de ne interp interp interp interp exp num interp interp interp de ne interp interp interp de ne interp expr cond minus 
expr interp minus lhs expr interp minus rhs expr expr interp extension exp interp exp num de ne interp pre interp pre interp interp exp interp num pre interp interp de ne pre interp expr int error interp semantics expr fun exp 
num val plus lhs rhs de ne struct num val de ne struct plus lhs rhs pre interp interp de ne pre interp interp pre interp interp exp num de ne interp pre interp pre interp interp exp interp num interp interp interp de ne interp interp interp de ne interp expr int cond num 
expr num val expr plus 
expr int plus lhs expr int int plus rhs expr int expr int interp fun extension exp 
minus lhs rhs de ne struct minus lhs rhs pre interp interp de ne pre interp interp pre interp interp exp num de ne interp pre interp pre interp interp exp interp num interp interp interp de ne interp interp interp de ne interp expr int cond minus 
expr int minus lhs expr int int minus rhs expr int expr int interp fun extension speci cally series interpreters series languages 
rst language sequence empty language inputs ags error 
second language introduces numbers addition 
third adds subtraction set operations 
interpreters written scheme extended mechanism called de ne struct de ning structures 
rst sequence called 
language gure rst interpreter empty 
raises error inputs 
second interpreter shown gure understands numbers addition operation 
gure processes subtraction 
sequence reuse code repeated stage 
remedy create second sequence reuses existing interpreters adds implementation new operations 
rst interpreter identical shown gure 
extensions handle added language features 
extension outer function interp gure interp gure accepts argument represents interpreter invoke unrecognized terms 
inner function de nes interpreter proper 
unfortunately sequence interpreters better perspective reuse equivalent 
speci cally term interp plus minus num num num results error recursive calls evaluate arguments addition operator invoke interp handle subtraction 
extensible version program respect solution problem fun sequence gure 
code sequence similar inner interpreter accepts arguments 
rst argument expression 
second argument interpreter recursive calls 
passed interpreter invoked unrecognized terms 
pre interp pre interp values corresponding inner function declarations 
programming pattern emulates properties inheritance argument interpreter dictates interpreter behavior inherits 
technically construction implements extensible conditional object oriented languages provide automatically means inheritance dispatching 
modularity interpreter provided second argument interpreter expected handle entire language 
interpreters need aware rest language long extended interpreter pass appropriately calls 
show fun sequence extensible respect members 
validates design pattern extensible functional interpreters 
preceding discussion discussed problem context scheme canonical functional programming language 
problems arise equally context languages paradigms object oriented programming 
problem arises java instance visitor pattern 
avoid casts required circumvent java lack type genericity non numeric scenario instance simple fantasy game adds players actions time 
presents initial game place initial interpreter gure shows addition kind player type extension equivalent adding new syntax form gure shows addition successful extensibility emacs widely extensible products uses hooks enable extensions 
understand hooks weak form protocol functional pattern 
interface object subject object subject object subject class subject public string name public object dispatch class prince extends subject prince string name public object dispatch return class princess extends subject princess string name public object dispatch return class extends subject subject sub sub string subject subject name sub sub public object dispatch return class speaker implements public object subject return name public object subject return name public object subject return name initial game class kissing implements subject kissing subject string kiss subject return name kissing name public object subject return kiss public object subject return kiss public object subject subject sub subject sub return string dispatch new kissing string dispatch new kissing game extension new behavior new operation similar adding new language processing behavior 
program contains error analogous scheme fragment 
invoked code prince pr new prince princess ps new princess shielded sh new shielded valiant pr sb new perfect sh ps ks new sh sb dispatch ks program aborts error exception thread main java lang kissing shielded dispatch interp java kissing interp java interface extends object subject class shielded extends subject subject sub shielded string subject su name sub su public object dispatch return class extends kissing implements subject super public object subject subject shielded sub return dispatch new kissing game extension new player dispatch interp java main main interp java problem underlying programs interfaces describe kinds information employed compiler language 
information fundamentally denotational monadic nature corresponding semantics source target languages compilation 
problems associated composing monads apply equally vocabulary compositions due monadic nature 
discussion studying composable fragments languages light properties components section reveals interesting property languages components 
unit lang viewed component constructor languages just unit component constructor programs 
result handle language growth extension familiar principles techniques developed managing programs 
development autonomous embedded languages demonstrates run time systems similar characteristics cases compilers di er greatly implementation strategy approach 
language development autonomous 
extension languages deeply valuable obvious implementation reuse engender profound practice design reuse 
experiences constraints lessons inform design base language automatically inherited extending language hopefully guide design extensions 
implementor autonomous language contrast views target language primarily source implementation design 
extension language bene ts having redesign poorly ad hoc fashion linguistic core extended language provides 
age old question asked language design library design language design 
interfaces little languages libraries implement interfaces library design form linguistic extension extremely rudimentary 
practice library design dicult hard problems library designers encounter balance hiding exposing functionality preserve invariants types create export opaque static dynamic scope operators provide forth really linguistic ones 
note design unit lang encompasses form language extension blurs distinction forms way traditional language extension mechanisms macro systems extensible grammars operator overloading 
chapter expressive power unit lang pun shakespeare know reminds power rests instabilities language language unstable part continuously gardens 
james wood new republic chapter presents series examples illustrating uses unit lang highlight di erent aspects semantics 
temporal programming section encountered language time discrete periodic current time bound variable 
section explore tradeo implementation 
simple way implement language time state variable updated second timer thread de ne thread lambda loop set 
sleep loop compiler time simply introduce code unit body bind unit body 
approach shortcomings base language time extends may threads mutation de nitions case code fail function 
approach inserts copy code time unit unacceptable want units share single universal clock 
clear problems implementation clock reside time language run time system 
export clock value user code adapt implementation clock de ne box box thread lambda loop set box 
box unbox box sleep loop equivalently value accessed invoking thunk 
language lists primitive box compiler rewrites instances user code unbox box 
guarantees updates clock value detected user burden user having know clock implemented box thunk means 
short appears satisfactory solution 
second solution subtle problem 
problem converts user intent dereferencing variable function application 
program running atop operating system accounts resource consumption charge user code function calls programmer unit import lookup language export de ne de ne start timer thread lambda loop set 
sleep loop start timer values lambda invoke unit dummy rts info time language run time system intended 
pricing model function calls quite reasonably cost variable accesses user program may prematurely exhaust allocated time resource 
fortunately solution problem easy encode units units export 
restore original implementation clock eliminate rewriting performed compiler add set primitives time obtain correct implementation language 
resulting run time system shown gure 
interaction languages lingo framework assumes code reside unit section 
modern programming environment true code user writes resides sort compilation unit 
exception code entered interactively read eval print loop repl 
section address code treated unit lang framework 
tempting wrap interactive expression user types scheme unit imports exports invoke immediately print resulting value 
instance user types expression interaction manager translate invoke unit unit lang scheme import export original expression evaluates 
simple solution insucient 
scheme units closed respect imports de nitions expression de ne sum squares square square fails criterion square bound expression generated repl syntactically illegal invoke unit unit lang scheme import export de ne sum squares square square user enter code followed de ne square legally sum squares repl 
transformation fails capture semantics repl 
individual expressions closed aggregate repl implementor enclose entire collection expressions scheme unit invoke unit unit lang scheme import export de ne sum squares square square de ne square print square attempt fails accommodate remaining free variables 
bigger concern happens user types expression 
entire aggregate expressions enclosed invoked repeats computation invoke unit unit lang scheme import export de ne sum squares square square de ne square print square sum squares wasteful resources repeats ects 
example repl prints value call square expression entered 
approach fails capture semantics repl 
underlying problem faulty assumption repl code behaves identically code scheme units 
fact roughly speaking scheme compilers automatically transform unbound identi ers dereferences global environment 
corresponds di erent semantics capture di erent language scheme interaction 
scheme interaction units import value corresponds toplevel environment 
compiler scheme interaction translates code scheme changes non primitive global variables rewritten dereferences name top level environment 
de nitions global variables rewritten augmentations toplevel environment 
ensures closure resulting component unbound identi er names replaced calls primitive quoted identi er name supplied argument 
de nitions likewise translated invocation primitive 
scheme interaction run time system responsible providing primitives 
implemented simply association lists 
run time system provide primitives initialize reset association list programming environment ability con gure user interaction space 
accurately mirrors repl semantics encapsulates precisely di erence compiled interactive scheme demonstrating reduction 
actual implementation shown gure somewhat di erent exploits built namespace facility mzscheme 
eval namespace second argument performs evaluation relative namespace 
language able simulate interactive namespace exploiting language feature 
ects automatically register namespace parameter conveys side ects scheme interaction units 
languages implement language extension languages section discusses extension languages mentions potential specialized languages implement compilers extension languages 
section language scheme def syn 
section explains creation similar simpler language scheme defmac 
scheme def syn permits pattern macro speci cations scheme defmac permits lisp style macros enables focus macro facilities elide details unit import lookup language export de ne compiler body imports exports length imports error scheme interaction units exactly namespace import interaction namespace name car imports values map compile interaction namespace name body imports exports de ne compile interaction ns lambda parameterize current namespace interaction ns eval values compiler dummy elab info scheme interaction language compiler unit import lookup language export values lambda invoke unit dummy rts info scheme interaction language run time system unit lang defmac compiler impl import lookup language export body source containing macro de nitions body source containing macro uses de ne defmac elab info class object defmac elab info body text public body text lambda body text sequence super init de ne prim accumulator gensym primitive accumulator de ne compiler body imports exports values body gensym body imports gensym imports exports gensym exports namespace gensym namespace see gure imports exports prim accumulator values compiler dummy elab info scheme defmac language compiler sca old values lambda body imports exports namespace namespace syntax parameterize current namespace namespace send prim accumulator clear eval de ne macro declare primitives lambda new prims send prim accumulator adjoin new prims map lambda eval body values map expand defmacro body imports exports list send prim accumulator get object defmac elab info body scheme defmac language compiler core unit import lookup language export de ne prim accumulator class object private prims public adjoin lambda prims set 
prims append prims prims get lambda prims clear lambda set 
prims sequence super init values lambda prim accumulator object prim accumulator invoke unit prim accumulator dummy rts info scheme defmac language run time system unit import lookup language export de ne compiler body imports exports values body imports exports defmac elab info values compiler dummy compiler info defmac compiler impl language compiler compound unit import lookup language link type require library unit compiler core types scm rts unit import elab info export de ne defmac elab info interface elab info body text values lambda invoke unit defmac elab info dummy rts info type elab info export defmac compiler impl language run time system pattern matching 
unit scheme defmac written scheme extended constructs de ne macro describes new macro form providing function serves expander 
declare primitives names list primitives provided run time system 
compiler scheme defmac traverses body consists scheme code extensions 
encounters macro de nition evaluates expander expression places result table 
encounters declaration primitives records table 
table implemented invoking primitive provided scheme defmac run time system 
goal scheme defmac compiler generate compiler extended scheme language ordinary scheme macros 
having traversed entire body accumulated macro primitive declarations compiler replaces body expression type compiler 
expression fact compiler understands syntactic structure scheme aware extensions declared language 
expression actual compiler extended language 
program written extended language evaluated unit lang invokes compiler program translates scheme program extensions 
ready linked primitives extended language 
presents compiler language gure presents run time system 
compiler written scheme written special purpose language designed purpose describing compiler called defmac compiler impl 
purpose language available scheme defmac compiler defmac elab info value intended shared macro de nition units combine macro languages 
defmac compiler impl run time system loads system library obtain value defmac elab info representation shared macro collections 
macro language composition languages programmers reuse macro de nitions composing build richer languages 
accomplish languages concert de ne primitive collections macros de ne composition languages 
languages de ned language composition requires protocol primitive compound languages 
section simple macro composition mechanism form languages defmac compound compiler defmac compound rts 
compiler language creates compilers composite languages de ned scheme defmac 
defmac compound rts similarly creates run time systems 
body defmac compound compiler unit stark simply lists sequence languages compose language name speci ed way 
constraint name valid argument lookup language 
particular defmac compound rts language permits expressions computation bodies 
defmac compound compiler language compiler shown gure 
scheme defmac unit generates table macros primitive names elaborator information 
defmac compound compiler compiler extracts tables composes create compiler compound language 
run time system gure contains routines accumulate names primitives 
defmac compound rts language de nes combined run time system 
run time systems may close state re invoked process compounding languages doing may instance destroy ability unit lang defmac compiler impl import lookup language export body list languages compose body source containing macro uses de ne prim accumulator gensym primitive accumulator de ne compiler body imports exports values body gensym body imports gensym imports exports gensym exports namespace gensym namespace prims list gensym prims list compiler bodies map lambda send lookup language compiler ext 
defmac elab info send body text error unit lang compose defmac family body see gure imports exports prim accumulator values compiler dummy compiler info defmac compound compiler language compiler sca old values lambda body imports exports namespace namespace syntax parameterize current namespace namespace eval de ne macro declare primitives lambda new prims send prim accumulator adjoin new prims prims list list map lambda compiler body send prim accumulator clear map lambda eval compiler body send prim accumulator get compiler bodies values map expand defmacro body imports exports prims list dummy elab info defmac compound compiler language compiler core unit import lookup language export de ne prim accumulator class object private prims public adjoin lambda prims set 
prims append prims prims get lambda prims clear lambda set 
prims sequence super init values lambda prim accumulator object prim accumulator invoke unit prim accumulator dummy rts info defmac compound compiler language run time system units base compound languages sharing values exchange 
run time units cached invocation defmac compound rts language compiler gure generates code sequentially applies cached run time unit values provide primitives compound language unit 
corresponding run time system provides primitives primitives come constituent units contains de nitions performs interesting actions gure 
note slightly alters model section unit lang mechanism handle list units single unit 
unit import lookup language export de ne gensym de ne compiler body imports exports values values lambda loop langs body null 
langs send lookup language car langs rts loop cdr langs dummy rts info imports exports values compiler dummy compiler info defmac compound rts language compiler unit import lookup language export values lambda invoke unit dummy rts info defmac compound rts language run time system communication channels traditional implementation coroutines uses linguistic constructs coroutine declaring coroutine resume resuming execution coroutines 
enables programmers specify initial arguments body coroutine 
resulting coroutine rst class value 
expects rst argument evaluate coroutine resumes coroutine computation second argument resumption parameter 
implementation resume follows 
coroutine local suspension procedure saves coroutine current continuation local state variable resumes speci ed coroutine resumption parameter 
value resume mutated re entry coroutine local 
de nition di erent lexical scopes name resume available global namespace 
problems implementation strategy 
exposes name resume inadvertent malicious mutation user may understand implementation coroutines channels private secure 
second requires user language may functions say continuations features necessary implement coroutine mechanism 
fails modular context coroutines dwell separately compilable units dependence global name 
name resume run time value communicate compile time syntactic forms known channel 
problem channels describe powerful programming paradigms avoiding characteristics unresolved nearly decades personal communication bruce duba matthias felleisen daniel friedman unit lang resolve problem similar section diculty 
macro de ning macros macro may expand de nition macro 
macro generating macros disallowed processed 
semantic decisions language designer 
choosing allow implementing resulting expander fact quite easy framework 
consider scheme def syn language described section 
described section language compiles scheme recognize macros macro generated macro handled correctly 
allow compiler implementor needs check generated code contains macros specify scheme def syn target language 
process continue scheme def syn target long macro de nitions source 
presumably pass eventually fail introduce new macros 
resulting body regular scheme program correctly fed scheme compiler 
example highlights strengths unit lang framework macro generating macros powerful programming technique easy support 
ability compiler choose target language unit content allows great exibility example illustrates permits reuse existing languages solve complex problems 
process expanding code uses macro generating macros need lose crucial phase separation 
explicit recursion form choosing current language de nition scheme def syn clear potential non termination macro generating macro process 
highlights condition necessary terminate recursion 
unit lang framework explicit highlighting value programming tool speci cation language 
contrast design decisions usually hidden deep details implementation traditional macro expander making dicult reason behavior 
de ning complete languages lambda calculus compilers rewrite body unit arbitrarily language implementors de ne syntactic abstractions powerful macros 
example implement language lc compiles lambda calculus lc scheme 
map lc procedures variables application scheme counterparts structures represent procedures provide interpretive support run time system 
traditional macros implement transformation reasons 
macros extend syntax existing language lc compiler de nes entire syntax disallowing non lc terms 
second macro systems support keyword expansion lc compiler needs examine terms including juxtaposition interpreted application 
programmers lc typically want lc procedures created lc unit usable imported 
lc implementor ensures making sure lc unit uses representation procedures 
disallow cross component usage implementor link di erent representation say tags generative datatypes distinguish time lc linker invoked 
contrast consider lc run time system units unit lang scheme import export compiler expressed expansion passing style elaborator :10.1.1.50.4332
de ne struct lam var body env lambda invoke unit lam lam var lam body lam env unit left creates structure registration supplies constructor selectors lc units 
contrast unit lang scheme import export lambda de ne struct lam var body env invoke unit lam lam var lam body lam env unit creates new generative structure application linker procedure 
semantic choice unit lang rightly places hands language implementor 
lc toy example underlying choice real applications 
application mred extension scheme de nes graphical high level operating system os 
mred thought language system 
compiler implements various language constructs control capabilities privileges programs graphical libraries 
run time system provides library support execution 
programs communicate mred values related os privileges graphics mred units 
keep communication protocols simple exible mred run time system uses representation values programs 
mred thought unit level mred applications 
client program linked explicitly mred run time system run time system instantiated program 
instantiation produce di erent representation values preventing mred units communicating ectively 
think mred existing individual mred unit invoked supplying representations unit 
representing mred language system clari es distinction implementation 
interface languages preceding discussion focuses languages components cover interfaces 
fact interfaces components simplistic examples suggest 
language take care disallow import certain kinds values particularly ones assign meaning harmful ects 
subsumes instances 
example import continuations language control operator import function terminate language terminating computations 
problem interoperability 
dissertation presents mechanisms policies linguistic frameworks 
attempts deal general problem translating data languages fail address dicult problem addressing perform reject data coercion request meaningful manner 
perspective unit lang problem easy express 
question happens data units conveyed linkage compound unit 
transformed representations boxed unboxed representations numbers allow programmers express regular program operations 
way address problem expressing transformations create new construct compound unit lang 
compound unit lang unit lang compound unit unit syntactic structure augmented annotation determines language expression positions compound unit 
expressions evaluate units participating linkage 
language wrap units adapter units perform data conversion 
languages data conversion languages implementation provide stable languages common pairs languages 
datatypes suppose programmer wants design new de nition language describing 
program uses language look de ne datatype exp num number 
plus le exp re exp de ne datatype construct introduces new structures selectors attributes hidden user 
programmers datatypes cases construct rst position speci es datatype exp followed sequence branches consisting pattern match expression pair 
programmer design language implement datatype writing units unit lang import 
export 
de ne datatype exp 
unit lang import 
export 
de ne datatype exp 
languages generate appropriate compiler run time structure de nitions 
bodies units identical 
units form compiler run time system new language scheme exp example inspired construct second edition essentials programming languages 
language compiler run time system 
run time system provide interesting primitives 
compiler uses scheme def syn target language turns unit scheme def syn unit unit lang scheme def syn import 
export 
de ne syntax cases cases expr clause 
expr clause test dissect vi declare primitives exp num num num 
plus plus le plus re plus 
language compiler run time system 
compiler turns datatype speci cation scheme unit unit lang scheme import 
export 
de ne struct exp de ne struct num struct exp 
de ne mk num number 
num error 
lambda invoke unit exp mk num num num 
corresponding run time system uninteresting primarily syntactic transformations 
re ready apparatus 
user writes unit lang scheme exp import 
export 
cases exp num 
plus le re 
compiler translates cond variant predicates selectors 
interface speci ed declare primitives 
interface satis ed closure returned run time system 
execution proceeds 
signatures units provide extremely powerful abstraction facilities laborious repeat names imports exports especially exports unit correspond imports 
problem intractable large libraries mred hundreds exports 
combat problem mzscheme ers layer atop units called signatures 
signature bundle names imports exports special units called unit sig indicating operate signatures individual names 
signatures simply syntactic abstraction existing mechanism possible de ne unit lang 
unfortunately de ned model described section 
problem signatures inherently alters import export lists unit 
contrast type signature compilers expr list id list id list expr target list id list id list id list implicitly speci es leave lengths import export lists permitted rename identi ers 
principle compilers allowed rename alter signatures units maximal expressive power 
modifying implementation permit easy 
extension permits description language features signatures 
linking signed units requires signature elaboration easily done compound unit lang 
instance link clause interpreter look compound unit lang import link rts han env han int han rts env export languages handle expansion signatures linking clauses 
chapter preserving linguistic abstractions ros playing 
words words 
re go 
tom dead programming languages accompanied host language processing tools compilers static analyzers debuggers 
translating new languages existing ones shown reuse existing language implementation technology including compilers run time systems 
consider problems arise reuse tools 
language designer de nes new language terms compilation existing language typically prefer reuse existing tools new language 
time programmers new language expect feedback terms source just terms generated code 
essential maintain abstraction boundary impression programmer coding new language destination language compiler 
understanding feedback terms destination language compilation especially dicult compilation process complicated introduces lot code correspond directly source program 
remedy problem considerably hamper inhibit linguistic abstraction 
section presents approaches addressing problems 
consider program gure 
shows program translated parenthesized version java adapter explicit adapter construct translated equivalent code gure 
adapter clear mismatch highlights overcome 
equivalent client java declaration class client elds var new results error message test cj incompatible assignment type 
convert 
created adapter test cj 
uses adapter declaration report error terms programmer pattern code just expanded constructs 
error message frees programmer having track manually construct introduce especially dicult expansion construct change time 
error message produced generic type checker parenthesized version java section describes information generated greater detail 
problem scheme exacerbated relatively large size language compared size core di erence syntactic abstractions 
experience particularly dramatic drscheme program beginner language level routinely expands programs advanced levels beginners shielded complexity 
instance simple beginner program de ne cond expands program features de ne values case lambda taught beginners reporting errors de ne values case lambda quote quote quote names arise hygienic expansion 
expect linguistic reuse encompass tool reuse framework provide suitable interface tools wish communicate programmer 
interface consists kinds information protocols process information 
kinds information source correlation term note source location phrase generated 
information maintained compilation process 
tool needs provide feedback term report terms source phrase programmer needs examine 
especially helpful conjunction graphical interfaces highlight appropriate source text 
elaboration tracking maintain history transformations applied elaborated term 
complex examples destination language term arise repeated compilation source term 
programmer explanation series transformations led error 
especially useful developer transformations 
providing appropriate interface tools need process information 
prototyped interface avor previous system gure shows ect features error reporting actual user programs 
wish de ne similar facility unit lang 
chapter related research man invented language satisfy deep need complain 
lily tomlin components typically de ned separately compilable externally connected independently deployable multiply instantiable units black box reuse 
mcilroy introduced concept factory software components 
components gaining prominence growing popularity protocols com corba javabeans provide form component reuse 
proponents technology envision component written language best suited task protocols providing ways exchange data components 
reality protocols tend extremely lowlevel re ect data languages speci low level computation models 
components promise grow importance mature 
essential study interaction syntactic abstractions powerful traditional notion abstraction 
szyperski ers thorough review standard component protocols identi es technical criteria characterize components suggest reasons popularity 
emphasizes vital importance page data safety components motivations enable language de ne notion safety may higher level underlying virtual machine 
macro systems support called referential transparency 
macro said referentially transparent free macro refer variables scope macro de nition 
referential transparency attempt meaning expansions example guarding re binding names de nition macro 
prevent mutations environment macro de ned 
unclear extend referential transparency systems meaning part syntax just primitive names altered 
authors considered interaction macros modules general components hard wire import dependencies modules deployed independently 
blume shows traditional tag implementations hygiene function properly presence modules especially export name shows modify hygiene algorithms avoid problems 
curtis rees module systems allow modules export macros 
free names macros refer bindings module macro de ned module export bindings 
macros meaningless component world component implicitly expect presence speci component particular de ned values referred macro run time 
waddell dybvig similar system require top level modules potentially implicit exports explicit address independence components 
queinnec describe exible system depends heavily rst order named packages components 
davis separate speci cation macros values needed macros choice client deeply tied rst order package system 
contrast systems unit lang units treated rst class values mzscheme instantiated multiple times 
bawden presents implementation rst class macros scheme 
terminology misleading 
macros rst class enclosing lexical environment rst class entity 
furthermore modules components namespaces just operations de ning interface namespace de ning namespace opening namespace 
constructs specifying imports exports modules linking modules form larger modules 
ort fails address core issues component oriented programming 
exploit popular speci cation methods macros templates parser generators simplify description compilers 
large corpus speci cations 
works ignore interaction components presume textual substitution le basis tradition cpp paying heed modular boundaries 
systems er di erent combinations pattern matching hygienic macro expansion type systems validate code expansions type correctness expanded code 
approach appear complex compared gure gure show de ning language terms macros procedures depend straightforward right abstractions 
programming environment mask di erences appearance approach traditional macro system generating part unit wrapper 
seen attempt add linguistic support highlevel operating systems 
projects attempted create high level operating systems 
centered primarily creating safe single address spaces 
directly address need create additional layers linguistic abstraction atop kernels 
similarly systems provide mechanism integrating multiple safe programming languages os 
orts identify criteria integration obey 
provide model adapted systems 
chapter limitations understand certainly trust 
doug mcilroy presentation discusses conducted context dynamically typed languages 
results typable exploit prescriptive uses types 
possible type declarations enhance utility results especially multi stage programming 
model dissertation toolkit accompanies model sparse 
particular limited evaluator 
realistic systems wide variety tools static dynamic 
believe may fruitful consider simple speci cation mechanisms set analysis construct domain speci type checkers program veri ers 
model just model 
languages grow number dicult create administer 
may useful model accessible unsophisticated programmers provide interface aids graphical interface simplify speci cation languages especially simple cases construction macro libraries 
speci cally improve granularity language de nitions 
individual programmers currently reuse components de ne compilers run time systems languages provide institutional policy doing 
able de ne language fragments combine create languages currently macro languages 
instance permit programmer combine extensions common base language language di erent combinations extensions di erent components program serve natural extension vocabularies 
chapter contributions player keep usual stu inside 
stage things supposed happen kind integrity look exit entrance 
tom dead components generative programming powerful software construction techniques 
components programmers increase reuse potential code create applications gluing components 
software generators ectively de ne domain speci little languages map existing languages promoting reuse language technologies 
marriage especially potent allows programmers incorporate modules written domain speci languages larger applications 
represents rst attempt consider semantic needs output generative programming 
process uni es linguistic extensions macros libraries shows interact 
lays mechanism general encompass existing generative programming techniques 
maps techniques prominently macros templates framework 
addressed concrete technical problems previously partially wholly unresolved 
ers rst explanation implement macro generating macros preserving phase separation 
extends solution creating towers languages closed semantics 
demonstrates run time system transparently communicate compile time entities 
structure solution document elegant property permitting towers languages 
examples shown de nition language may de nition languages turn depend language de nitions 
result programmers build arbitrarily deep layers abstractions just currently module systems 
unique feature shared prior linguistic abstractions 
addition implementation associated dissertation formed key bases drscheme hundreds institutions worldwide secondary school university education research projects 
bene ts distinguish drscheme accrue features implementation 
implementation reusable construct toolkits related languages xml 
believe potential widespread application 
barriers programming languages operating systems dissolve programmers increasingly confront question programming language new context 
dissertation answers question shows programmers create specialized languages de ned semantics re ect constraints various domains 
addressed practical implications large number languages interact intimately 
experience building systems addressed needs daily 
average user nd solution described unwieldy overly general 
designing system pragmatic preserving essence left 
neglected demands typed languages impose bene ts engender 
believe extensions results dissertation necessary fruitful 
bibliography aitken de moor richter 
transformation intentional programming 
microsoft research white september 
bawden class macros types 
acm sigplan sigact symposium principles programming languages 
bawden rees 
syntactic closures 
acm symposium lisp functional programming pages 
bentley programming pearls 
addison wesley 
bershad savage pardyak sirer becker fiuczynski chambers eggers 
extensibility safety performance spin operating system 
symposium operating system principles pages 
blume re ning hygienic macros modules separate compilation 
technical report tr atr human information processing research laboratories 
bray paoli sperberg mcqueen 
extensible markup language xml 
technical report world wide web consortium feburary 
version 
cardelli matthes abadi 
extensible syntax lexical scoping 
research report digital src 
cartwright felleisen 
extensible denotational language speci cations 
hagiya mitchell editors symposium theoretical aspects computer software pages 
springer verlag april 
lncs 
clinger rees 
macros 
acm sigplan sigact symposium principles programming languages pages 
curtis 
module system scheme 
acm symposium lisp functional programming pages june 
czarnecki eisenecker 
generative programming methods techniques applications 
addison wesley 
davis 
talking modules delivery 
acm symposium lisp functional programming pages 
dybvig friedman haynes :10.1.1.50.4332
expansion passing style general macro mechanism 
lisp symbolic computation january 
dybvig hieb bruggeman 
syntactic abstraction scheme 
lisp symbolic computation december 
findler clements flanagan flatt krishnamurthi felleisen 
drscheme programming environment scheme 
journal functional programming 
appear 
findler flanagan flatt krishnamurthi felleisen 
drscheme pedagogic programming environment scheme 
international symposium programming languages implementations logics programs number lecture notes computer science pages 
flanagan felleisen 
componential set analysis 
acm transactions programming languages systems 
flanagan flatt krishnamurthi weirich felleisen 
catching bugs web program invariants 
acm sigplan conference programming language design implementation pages may 
flatt plt mzscheme language manual 
technical report tr rice university 
flatt felleisen 
cool modules hot languages 
acm sigplan conference programming language design implementation 
flatt findler krishnamurthi felleisen 
programming languages operating systems revenge son lisp machine 
acm sigplan international conference functional programming pages september 
friedman wand haynes 
essentials programming languages 
mit press 
friedman wand haynes 
essentials programming languages 
mit press second edition 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley personal computing series 
addison wesley reading ma 
graham lisp advanced techniques common lisp 
prentice hall englewood cli nj 
hawblitzel 
chang czajkowski hu von eicken 
implementing multiple protection domains java 
usenix annual technical conference 
heintze set analysis ml programs 
acm sigplan international conference functional programming 
johnson yacc compiler compiler 
computing science technical report bell laboratories murray hill nj usa 
jones duponcheel 
composing monads 
research report yaleu dcs rr department computer science yale university new haven connecticut december 
kelsey clinger rees 
revised report algorithmic language scheme 
acm sigplan notices october 
kernighan ritchie 
programming language 
prenticehall 
kohlbecker friedman felleisen duba 
hygienic macro expansion 
acm symposium lisp functional programming pages 
kohlbecker wand 
macros example deriving syntactic transformations speci cations 
acm sigplan sigact symposium principles programming languages pages 
kohlbecker jr syntactic extensions programming language lisp 
phd thesis indiana university august 
krishnamurthi 
felleisen 
expressing structural properties language constructs 
european symposium programming number lecture notes computer science pages march 
krishnamurthi felleisen duba 
macros reusable generative programming 
international symposium generative component software engineering number lecture notes computer science pages september 
krishnamurthi gray graunke 
transformation example xml 
practical aspects declarative languages january 
marsh thompson walsh zilles 
xsl transformations version 
world wide web consortium working draft july 
mauny de 
parsers ml 
acm symposium lisp functional programming pages 
mcilroy mass produced software components 
naur randell editors report conference nato science committee pages october 
moggi view programming languages 
technical report laboratory foundations computer science university edinburgh edinburgh scotland 
perlis programming 
acm sigplan notices september 
queinnec 
modules macros lisp 
eleventh international conference computer science society pages october 
rees module system scheme 
scheme documentation 
dylan manual 
addison wesley longman 
sheard automatic generation structure operators 
acm transactions programming languages systems october 
smaragdakis batory 
scoping constructs program generators 
technical report department computer sciences university texas austin december 
smaragdakis batory 
implementing layered designs mixin layers 
european conference object oriented programming pages july 
stallman gnu emacs manual 
free software foundation cambridge ma 
steele jr editor 
common lisp language 
digital press bedford ma second edition 
steele jr building interpreters composing monads 
acm sigplan sigact symposium principles programming languages pages january 
dead 
grove press new york ny 
szyperski component software object oriented programming 
addison wesley 
taha sheard 
multi stage programming explicit annotations 
acm sigplan symposium partial evaluation semantics program manipulation pages 
trifonov shao 
safe principled language interoperation 
european symposium programming 
waddell dybvig 
extending scope syntactic abstraction 
acm sigplan sigact symposium principles programming languages january 
wadler essence functional programming 
acm sigplan sigact symposium principles programming languages pages january 
wahbe lucco anderson graham 
ecient software fault isolation 
symposium operating system principles pages december 
weise crew 
programmable syntax macros 
acm sigplan conference programming language design implementation pages june 
