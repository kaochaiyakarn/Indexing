survey strategies program transformation systems eelco visser institute information computing sciences universiteit utrecht box tb utrecht netherlands 
visser acm org www cs uu nl visser 
program transformation wide range applications including compiler construction optimization program synthesis refactoring software renovation reverse engineering 
complex program transformations achieved number consecutive modi cations program 
transformation rules de ne basic modi cations 
transformation strategy algorithm choosing path rewrite relation induced set rules 
surveys support de nition strategies program transformation systems 
discussion kinds program transformation choices program representation basic elements strategy system discussed choices design strategy language considered 
styles strategy systems provided existing languages analyzed 
program transformation applications areas software engineering compilation optimization refactoring program synthesis software renovation reverse engineering 
aim program transformation increase programmer productivity automating programming tasks enabling programming higher level abstraction increasing maintainability re usability 
systems program transformation exist specialized speci object language kind transformation 
systems share ideas program transformation similar techniques ad hoc respects 
ultimate goal achieve speci cation language family speci cation languages high level declarative speci cation program transformation systems generic language independent schemas transformation captured admits ecient implementation transformations scale large programs 
survey aims understanding similarities di erences systems program transformation analyzing existing systems basis publications 
aspects program transformation parsing pretty printing formulating basic transformations fairly understood 
survey concentrates transformation strategies control appear gramlich lucas alba editors proceedings workshop reduction strategies programming rewriting wrs 
may utrecht netherlands 
part transformation systems determine order application basic transformation steps 
structured follows 
section presents taxonomy program transformation 
section discusses choices program representations program transformation systems 
section discusses ingredients system speci cation program transformation rules strategies 
section discusses implementation program transformation number dedicated transformation languages 
section summarizes discusses areas research implementation transformation systems 
program transformation program structured object semantics 
structure allows transform program 
semantics includes extensional intensional behavior program gives means compare programs reason validity transformations 
programming language collection programs comply set structural semantic rules 
broad de nition intended cover proper programming languages operational interpretation data formats languages aspects programs control data ow 
programming languages clustered classes structural semantic similarities 
aims general framework program transformation de ne transformations reusable wide range languages possible 
example notions variable variable binding shared programming languages 
transformations dealing variables bound variable renaming substitution uni cation de ned highly generic manner languages 
program transformation act changing program 
term program transformation formal description algorithm implements program transformation 
language program transformed resulting program written called source target languages respectively 
program transformation areas software engineering including compiler construction software visualization documentation generation automatic software renovation 
applications distinguish main scenarios source target languages di erent translations 
main scenarios re ned number typical ect level abstraction program extent preserve semantics program 
re nement results taxonomy 
translation migration synthesis re nement compilation reverse engineering decompilation architecture extraction documentation generation software visualization analysis control ow analysis data ow analysis rephrasing normalization simpli cation desugaring weaving optimization specialization inlining fusion refactoring design improvement obfuscation renovation fig 

taxonomy program transformation translation translation scenario program transformed source language program di erent target language 
translation scenarios distinguished ect level abstraction program 
translations aim preserving extensional semantics program usually possible retain information translation 
translation scenarios divided synthesis migration reverse engineering analysis 
relations illustrated diagram 
synthesis program synthesis class transformations lower level abstraction program 
course synthesis design information traded increased eciency 
re nement implementation derived high level speci cation implementation satis es speci cation 
compilation form synthesis program high level language transformed machine code 
translation usually achieved phases 
typically high level language rst translated target machine independent intermediate representation 
instruction selection translates intermediate representation machine instructions 
examples synthesis parser pretty printer generation context free grammars 
migration migration program transformed language level abstraction 
translation dialects example transforming fortran program equivalent fortran program translation language porting pascal program reverse engineering purpose reverse engineering extract low level program high level program speci cation higherlevel aspects 
reverse engineering raises level abstraction dual high level language low level language analysis aspect language migration high level language synthesis reverse engineering high level abstraction low level abstraction rephrasing fig 

relation kinds program transformation synthesis 
examples reverse engineering decompilation object program translated high level program architecture extraction design program derived documentation generation software visualization aspect program depicted way 
analysis program analysis reduces program aspect data ow 
analysis considered transformation sublanguage aspect language 
rephrasing transformations transform program di erent program language source target language 
general try say thing di erent words aiming improving aspect program entails change semantics program 
main rephrasing normalization optimization refactoring renovation 
normalization normalization reduces program program sublanguage purpose decreasing syntactic complexity 
desugaring kind normalization constructs syntactic sugar language eliminated translating fundamental constructs 
example haskell language de nition describes constructs desugared kernel language 
examples module attening de nition ebnf constructs pure bnf done example sdf normalizer 
simpli cation general kind normalization program reduced normal standard form necessarily removing simpli ed constructs 
example consider transformation canonical form intermediate representations algebraic simpli cation expressions 
note normal form necessarily correspond normal form respect set rewrite rules 
optimization optimization transformation improves runtime space performance program 
example optimizations fusion inlining constant propagation constant folding common subexpression elimination dead code elimination 
refactoring refactoring transformation improves design program restructuring easier understand preserving functionality 
obfuscation transformation program harder understand renaming variables inserting dead code obfuscation done hide business rules embedded software making harder reverse engineer program 
renovation software renovation extensional behavior program changed order repair error bring date respect changed requirements 
examples repairing bug converting program deal euro 
program transformation systems program transformation system determined choices program representation programming paradigm implementing transformations 
section discusses considerations choosing representation programs 
remaining sections consider implementation transformations 
program representation systems directly text general textual representation adequate performing complex transformations 
structured representation systems 
programs written texts programmers parsers needed convert text structure needed convert structure text 
change intentional programming framework programs stored edited processed source graphs 
editing programs done structure editors 
number issues considered choosing program representation parse trees syntax trees trees graphs represent variables variable bindings exchange programs transformation components 
parse trees syntax trees parse trees contain syntactic information layout whitespace comments parentheses extra nodes introduced disambiguating grammar transformations 
information irrelevant transformation parse trees usually transformed syntax trees contain information 
applications software renovation refactoring necessary restore possible original layout program transformation 
requires layout stored tree preserved transformation 
especially aspect problematic clear generic manner insert comments transformed fragment program 
origin tracking useful 
applications certain optimizations compilation necessary carry type information tree 
requires extension tree format store type information preserve consistency types transformation 
trees graphs program structure represented means trees directed acyclic graphs dags full edged graphs cycles 
pure trees costly copying tree variable twice constructing new tree requires creating complete copy 
systems dags 
copying tree pointer tree gets copied sub trees shared multiple contexts 
advantage sharing reduced memory usage 
aterm library approach taken extreme constructing instance sub tree constructed achieving maximal sharing minimal memory usage 
sharing saves memory copying cheap case maximal sharing testing equality cheap 
downside sharing performing transformation tree requires re building context transformed tree 
attractive overwrite root node sub tree changed new tree updating contexts old tree 
valid general 
occurrences shared tree syntactically completely di erent meaning depending context 
meaning desirable change occurrences 
problem occurrence arises associating information nodes 
sharing syntactic equivalence annotations associated occurrences tree 
consider examples position information parse trees type annotations syntax trees conclude usually desirable 
full edged graphs useful represent back links tree represent example loops control ow graph links declarations 
updateable graphs easy attach new information nodes example results analysis 
problem destructive update versus copying doing transformation problematic graphs 
sub graph links entire graph may required reconstruct entire graph transformation necessary keep original graph 
speci purposes lazy evaluation functional programs possible graph updates transparent 
variable bindings particular problem program transformation handling variables variable bindings 
common approach variables variable bindings syntax tree treated just construct transformation system special knowledge 
requires implementation operations rename bound variables substitution transformations need aware variables means extra conditions avoid problems free variable capture substitution lifting variable occurrences bindings 
transparent handling variable bindings desirable 
higher order syntax hoas gives solution problems encoding variable bindings lambda abstractions 
addition dealing problem variable capture hoas provides higher order matching synthesizes new functions higher order variables 
problems higher order matching matches pattern requiring mechanism choosing 
freshml provides weaker mechanism dealing variable bindings transparently refreshes variable names solving capture problem 
substitution variables dealt explicitly 
hoas freshml require amount encoding syntactic structure lambda abstraction binding scheme 
far removed structure described grammar complex binding schemes 
approaches rename variables con ict requirements original names preserved required applications refactoring renovation 
problem addressed approaches discussed associating declaration information type declarations usage 
usually requires maintaining symbol table transformation distributing information tree annotating usage occurrences symbol information declarations 
way information needs kept consistent transformations 
exchange format program representation supported exchange format possible exchange programs transformation components 
example formats xml supports exchange tree shaped data annotated term format supports exchange dags maintaining maximal sharing 
see bibliography exchange formats 
implementation program transformation complex program transformation achieved number consecutive modi cations program 
level design useful rules xs es xs es xs dead extract xs xs xs hoist xs xs fig 

example transformation rules distinguish transformation rules transformation strategies 
rule de nes basic step transformation program 
strategy plan achieving complex transformation set rules 
example consider transformation rules 
inline rules de ne inlining function variable de nitions 
dead rule eliminates unused variable de nition 
extract rule abstracts expression function 
hoist rule de nes lifting function de nition variable de nition variable function 
set rules di erent transformations achieved 
example constant propagation strategy optimizer dead rules eliminate constant variable de nitions hand strategy refactoring browser extract hoist rules addition new function lift top level 
rules applied interactively programmer graphical user interface 
problem manipulations transformation reproducible decisions recorded 
automating transformation process series basic transformations repeatedly applied program 
generalizing sequence transformations combined transformation applied programs 
requires mechanism combining rules complex transformations 
section discusses basic ingredients speci cation rules strategies 
transformation rules rules semantics language 
rule generally preserves semantics program 
application rule program meaning 
usually observable behavior program preserved aspect changed 
optimizations example try decrease time space resource usage program 
applying constant propagation decrease need registers instance 
extracting function refactoring improve readability program 
rule consists recognizing program fragment transform constructing new program fragment replace old 
recognition involves matching syntactic structure program possibly verifying semantic conditions 
replacement rule consist simple term pattern function constructs new tree graph semantic action arbitrary side ects 
tree term representation term pattern matching 
order term patterns decompose terms simultaneously recognizing structure binding variables subterms expressed nested conditional expressions test tags select subterms 
rst order patterns treated rst class citizens poses limitations modularity reuse abstraction patterns provided may occur left hand side rewrite rule arms case heads clauses pattern matching odds data types exposes data representation rst order pattern span xed distance root pattern leaves necessary de ne recursive traversals data structure separately pattern get needed information 
reasons enhancements basic pattern matching features implemented considered languages 
example list matching asf sdf divide list multiple sublists possibly separated element patterns 
associative commutative ac matching obj maude elan supports treatment lists multisets 
higher order uni cation prolog allows higher order matching subterms arbitrary context turn allows matching subterms arbitrarily deep levels higher order variables explicit traversal structure involved 
views haskell proposed provide way view data structure di erent patterns represent 
overlays stratego pseudo constructors underlying representation actual constructors 
transformation strategies set transformation rules programming language induces rewrite relation programs 
relation con uent terminating unique normal form program 
case matter applying rules ecient way reach normal form 
program transformation usually case 
illustrated set transformation rules give rise nite branches inlining recursive function inverses transformation undone distribution commutativity rules non con uence program transformed di erent programs 
fig 

phenomena composition transformation rules nite branches inverses con uence non con uence depending goal transformation task path chosen rewrite relation 
speci program possible nd shortest path optimal solution speci transformation task 
transformation tasks process nding path needs automated optimal solutions approximated 
strategy algorithm choosing path rewrite relation 
set rules strategies achieving di erent goal 
hand general strategy applicable di erent sets rules 
strategy provided transformation engine nable 
range possibilities options fixed application order 
engine applies rules exhaustively built strategy 
examples innermost outermost reduction 
automatic dependency analysis 
engine determines strategy analysis rules 
examples strictness laziness analysis goal driven 
engine nds apply rules achieve user de ned goal 
strategy menu 
strategy selected small set 
example choose innermost outermost reduction annotate constructors laziness information 
completely programmable 
strategy apply rules programmed strategy language 
de ned user engine strategy needs expressed implemented formally 
rest section considers ingredients language de ning strategies 
sequential composition choose path rewrite relation basic rules combined transformations 
transformations combined consecutively applying transformations conditionally choosing transformations repeating transformations iteratively recursively 
non deterministic programming choosing paths properties current program limited 
necessary decide appropriateness choice applying transformations 
approach speculatively explore paths acceptable solution explore paths parallel choose best solution 
case speculative exploration kind non deterministic choice alternative paths needed 
failure paths path taken 
backtracking local choice chosen branches succeeds 
back tracking global failure point inside choice causes back tracking alternative path 
allows exploring full search space acceptable solution 
parallel exploration paths requires mechanism comparing solutions kind cost function 
problems dynamic programming techniques eciently apply transformations 
speculative parallel exploration goal exploration set constraints leads discarding paths inconsistent constraints 
structure traversal rewrite relation includes application rules context 
entails traversing program representation structure nd location rule applied applying rule rebuilding context 
addition sequential order application choice paths location rule applied determined strategy 
unattractive express locations means paths tree inecient traverse rebuild context rule application 
rules applied close tree 
mechanism needed traverse syntax trees apply transformation rules subtrees 
language speci traversal mechanism requires de nition traversals constructs language 
lead large speci cations large languages having complex syntax 
language generic traversal mechanism supports de nition generic traversals syntax trees 
requires exposing underlying representation model 
traversal mechanisms provide set xed traversals top bottom provide traversal primitives kinds traversals de ned 
information carrying strategies strategies may carry information making decisions paths take passing context sensitive information rules 
separation rules strategies distinguished rules conceptual level implementation level rules strategies intertwined rules hardwired de nition strategy 
alternatively rules strategies de ned separately entails strategies parameterized set rules 
separate de nition rules strategies leads clearer speci cations allow reasoning smaller entities rules strategies separately 
furthermore separate de nition enables reuse rules strategies generic implementation aspects transformation systems common class languages 
intertwining may required ef ciency reasons 
cases desirable intertwining done compiler speci er 
abstraction achieve reuse strategies general separation rules strategies particular abstraction mechanism needed allows abstraction rules strategies 
possible name parameterize rules strategies 
program transformation languages section discusses number languages designed speci cally implementation program transformation 
topics discussed interactive program transformation intentional programming tree parsing term rewriting number extensions basic term rewriting addressing problems standard rewriting strategies strategy annotations sequences canonical forms exploring reduction space non deterministic strategies guiding rewriting re ection rewriting traversal functions generic rewriting strategies 
interactive program transformation rst system support transformation high level domain speci programs executable code 
system supported de nition transformation rules optimizations re nements transform high level constructs lower level ones 
transformation rules re nements identi ed means names 
transformation rules application codes specify relative precedences 
application transformations re nements domain program controlled user interactive process 
process user select domain instance region syntax tree representing program locale node syntax tree 
transformations applied directly currently selected locale apply 
system examine tree suggest transformations apply 
transform command transformation rules certain range applied automatically 
transform command uses bottom traversal tree applying rules provided code range 
rules higher codes applied rst 
descriptions top traversal traversals apply best rules rst 
re nements applied individually try 
certain amount automation process possible means tactics 
intentional programming intentional programming meta programming system development microsoft research 
description intentional programming 
intentional programming program represented source tree source text 
node source tree declaration making tree source graph 
example occurrence variable link declaration 
likewise language construct intention corresponds tree node de nes 
intentions making links de nitions intentions 
example statement node children corresponding condition iteration statement link intention 
domain speci programming abstractions captured de ning new intentions 
source trees implemented reducing source trees code intentions 
code intentions basic constructs translated form machine code code generator 
part de nition intention method reducing code 
dependencies reduction methods computed interpreted intentional programming engine reduce entire program code 
simple tree parsing tree parsing analogous string parsing nding structure string goal nd structure tree covering tree patterns 
tree parser generator antlr language processing system 
generates tree walkers tree grammars 
tree grammar bnf notation de nition tree structures 
example grammar exp plus exp exp int describes expression trees composed integers addition 
tree translations transformations achieved associating actions grammar productions 
translations textual output achieved printing actions 
example grammar prints expressions notation 
exp plus exp exp int tree transformations achieved reconstructing trees returning results 
example grammar transforms expressions swapping arguments plus operator 
exp 
plus exp exp int grammar non terminals arguments actions productions 
non terminals return results 
tree grammar gives rise set mutually recursive functions non terminal de ne pass traversal tree 
patterns nested regular tree expressions alternatives lists 
transformation rules tree grammars embedded grammar productions 
separation rules strategies generic tree traversals supported 
tree parsing dynamic programming tree grammar ambiguous multiple parses tree possible 
parser needs decide parse take 
associating costs production disambiguation accumulated cost tree 
dynamic programming techniques compute possible parses traversal 
burg system code generation intermediate representation ir expression trees 
mapping ir trees machine instructions de ned means tree grammar 
production form de nes mapping tree pattern non terminal cost associated production action take production selected 
example proebsting gives example grammar 
grammar term fetch fetch plus reg int coverings corresponding derivations costs respectively 
illustrated example covering tree possible corresponding di erent ways generate code 
node di erent parses overlapping patterns chain rules 
costs associated productions express cost executing associated machine instruction 
goal code generator nd lowest cost covering lowest execution time intermediate representation expression tree 
bottom rewriting theory burs ir tree translated sequence instructions strategy 
bottom traversal lowest cost patterns match node computed associated goal reg reg plus reg reg reg reg addr reg reg int addr int reg fetch addr addr plus reg int fig 

example burg speci cation node 
involves matching right hand sides productions tree account earlier matches sub trees 
instructions selected top traversal driven goal non terminal root tree 
restricted form rewriting applied simple type inference problems checking tree formats tree simpli cations 
term rewriting term rewriting supported systems including obj elan asf sdf 
term rewriting attractive paradigm program transformation 
order terms describe syntax programs 
example consider declaration propositional formulae 
rewrite rule form declares transformation term matching pattern instantiation 
rewrite rules express basic transformation rules considered algebraic laws language 
example rewrite rules express basic laws propositional logic distribution rules rule double negation de morgan rules 
stronger forms pattern matching various instances equational matching ac matching list matching patterns capture complicated term con gurations 
furthermore conditional rewrite rules additional tests patterns stated 
redex subterm matches rewrite rule 
term normal form redices 
rewrite engines term rewrite systems compute normal form terms respect sets rules speci cations 
involves exhaustively applying rules subterms rules apply 
rewrite engine employ di erent strategies order application rules 
innermost rewriting subterms term normalized rules applied term 
outermost rewriting redices closest root term rewritten rst 
implies rules automatically applied term traversals syntax tree need de ned 
complete normalization approach rewriting turns adequate program transformation rewrite systems programming languages non terminating non con uent 
general desirable apply rules time apply rules circumstances 
example consider set rewrite rules 
rewrite system non terminating rules enable rules doar vice versa 
want de ne transformation normalize formulae disjunctive normal form discard rules doar 
part transformation conjunctive normal form required need di erent rewrite system 
possible combine rules rewrite system 
common solution kind problem introduce additional constructors functions achieve normalization restricted set rules 
shows rewrite system turned terminating rewrite system de nes normalization disjunctive normal form dnf 
normalize formula dnf function dnf applied 
normalization conjunctive normal form requires similar de nition 
signature sorts prop constructors false prop true prop atom string prop prop prop prop prop prop prop prop prop rules doar dn dma fig 

signature rewrite rules propositional formulae 
signature constructors dnf prop prop prop prop prop prop prop rules dnf dnf true true dnf dnf false false dnf dnf atom atom dnf dnf dnf dnf dnf dnf dnf dnf dnf dnf dnf default default fig 

rewrite system disjunctive normal form 
dnf function mimics innermost normalization strategy recursively traversing prop terms 
auxiliary functions apply distribution rules negation rules 
functional programming auxiliary functions known smart constructors 
de nition rules assumed arguments functions disjunctive normal form 
example arguments term term considered dnf 
solution original rules completely intertwined dnf transformation 
rules negation reused de nition normalization conjunctive normal form 
new transformation new traversal function new smart constructors de ned 
additional rules added traverse term nd places apply rules 
rules total rules needed 
rules default rules apply rules apply 
mechanism rules handle cases real transformation rules apply 
default rules introduced asf sdf 
kind problem illustrated example occurs frequently kinds transformations 
examples normalization sdf syntax de nitions kernel sdf desugaring programming constructs refactoring parts program may simpli ed may de simpli ed 
general trying overcome problems non termination uence leads encoding control terms additional rewrite rules variance goal separate rules strategies possible usually leads functional programming style rewriting overhead form traversal rules constructor signature intertwining rules function de nitions reuse rules impossible leads speci cations harder understand 
rewriting traversal functions asf sdf controlling application transformation rules recognized problem long time 
especially speci cation transformations large languages cobol overhead de ning traversals seen problematic factor 
solved generation default traversal rules overridden normal rules 
approach typically rewrite rules speci ed corresponding non default behaviour traversal 
number generated rules proves source overhead compiler programmer 
furthermore providing new traversal scheme requires addition new generator 
approach traversal functions supported directly rewriting engine avoiding compile time overhead generated rules 
illustrates approach applied problem normalization disjunctive signature constructors dnf prop prop traversal trafo bottom prop prop prop prop prop rules dnf dnf dnf dnf default default fig 

disjunctive normal form traversal function version normal form 
note example asf sdf syntax 
speci cation dnf function declared traversal function signature 
attribute traversal trafo bottom declares dnf performs bottom traversal argument 
means function rst applied direct subterms recursively subterms applied term 
rules need declared constructs transformed 
default behaviour reconstruct term original constructor 
example reduces speci cation traversal rules 
general signature constructors need handled special way saves rules 
overhead speci cation form dispatching traversal function smart constructors default rules smart constructors 
concise speci cation smart constructors 
style rule needed original rule 
problem style recursive calls right hand sides rules completely tree arguments normalized applying rules 
asf sdf provides limited set traversals 
traversal strategy choice top bottom 
explained 
top traverses tree stops soon rule applies 
addition traversal transformation trafo traversal accumulates information way accu 
traversal functions parameterized additional arguments contain static information traversal 
signature constructors dnf prop prop traversal trafo bottom rules dnf dnf dnf dnf dnf dnf dnf dnf dnf fig 

disjunctive normal form traversal function version advantage traversal functions default traversal behaviour need implemented manually 
similar default visitors objectoriented programming folds updatable fold algebras functional programming 
approach number limitations 
separation rules strategies 
rule bound speci traversal traversal function 
possible reuse rules di erent traversals example normalize di erent rule sets 
furthermore rules intertwined strategies making hard distinguish basic transformation rules traversal code argue correctness 
secondly traversal function schema provides limited range traversals 
bottom variant full traversal tree 
top variant stops soon rule application requires explicit de recursion rules 
possible implement wide range traversals requires gluing basic traversals ad hoc manner 
possible de ne new traversal schemas reusable way new traversal attribute 
require extending rewrite engine 
traversals provided language capture abstraction certain traversal schemata 
possibility language give abstractions alternative traversal schemata elaborate functionality involving traversals 
desirable building libraries language independent strategies 
example de ning substitution variable capture similar languages shape variables variable bindings 
extrapolating traversal function approach abstractions captured additional primitives rewrite engine 
point sense extend language mechanism specifying abstractions generically 
term rewriting strategy annotations problem term rewriting terms nite reduction paths resolved removing unnecessary rules 
example speci cation de nes computation factorial function imports integers signature sorts int constructors fac int int bool int int int rules fac fac eq mul fac sub ift true iff false ife fig 

rewrite system non terminating reduction path 
conditional 
pure innermost rewriting strategy term fac terminate arguments evaluated rules iff ift applied 
outermost strategy solve problem outermost harder implement eciently 
systems provide strategy annotations delay evaluation arguments 
note strategy annotations help rewrite systems terminating help respects program transformation 
example traversals syntax trees need de ned explicitly 
just time strategy annotations designed delay evaluation arguments guarantee term reached evaluation normal form respect rewrite system contains redices 
strategy annotation constructor list argument positions rule names 
argument positions indicate argument evaluate rule names indicate rule apply 
innermost strategy corresponds annotation strat 
constructor indicates rst arguments evaluated rules ri applied 
requiring argument positions rules constructor mentioned annotation guaranteed normal form reached 
just time strategy permutation argument positions rules rules applied early possible 
annotations non termination rewrite system solved means annotation strat ift iff ife declares rst argument evaluated applying rules ift iff 
strategy just time strategy deal rewrite systems normal forms terms 
example consider rules signature sorts nat list constructors nat nat nat cons list list strat inf nat list nat nth list rules inf cons inf nth cons nth cons nth fig 

speci cation strategy annotations 

terms form inf natural number normal form 
strategy cafeobj system uses extended form strategy annotations arguments need evaluated 
style strategy annotation list argument positions root position 
annotation declares order evaluation arguments 
root position indicates evaluation term root 
argument positions need declared 
undeclared argument evaluated 
example non termination solved strategy annotation indicates rst rst argument cons evaluated constructor 
second argument evaluated 
normal form nth inf 
term inf normal form cons inf 
laziness annotations strategy annotations discussed interpreted rewrite engine 
shown rewrite systems laziness annotations compiled rewrite systems evaluated innermost strategy 
laziness annotation indicates argument constructor lazy reductions performed subterms argument needed matching 
example rewrite system laziness annotation lazy cons achieve delay evaluation second argument cons 
rewrite system laziness annotations translated eager rewrite system thunks 
thunk auxiliary data structure stores structure term 
example term rewrite system trs transformed eager trs 
note thunk generic constructor representing thunks constructor indicating pattern vec constructor denoting vector length 
rules inf cons thunk vec nth cons nth cons nth inst inst thunk vec inf inst fig 

result translating speci cation laziness annotations eager speci cation 
note annotations depend application 
example verb inf constructor reason annotating second argument cons lazy 
sequences canonical forms stands transformation assisted multiple program realization system 
system seventies designed derivation ecient implementations speci cations transformations particular domain numerical programming 
speci cation consists series rewrite rules 
rewrite engine applies rewrite rules exhaustively reach canonical form 
problem non termination caused rules inverses encountered section solved organizing large transformation sequence consecutive reductions canonical forms di erent sets rewrite rules 
typically sequence starts preparatory steps bring program right form followed pivotal step achieves actual transformation followed post processing 
illustrated transformation polynomial equivalent polynomial achieved means sequence canonical forms sum right powers collected factored sum canonical form transforms polynomial xy commuting multiplications right canonical form achieved yx powers collected canonical form commutes additions bring power yx factoring powers desired form reached 
non deterministic sequential strategies elan language rewriting user de nable strategies special strategy language 
elan speci cation consists set unlabeled rewrite rules applied xed innermost strategy labeled rules applied user de ned strategies 
rewrite rules support matching modulo associativity commutativity 
strategy expression combines rule labels means strategy operators 
application strategy term leads set results 
empty set results denotes failure 
evaluation term involves normalizing term unlabeled rules applying strategy 
strategies exist levels elementary strategies built language apply labeled rules de ned strategies interpreted innermost rewriting 
example labeled rules elementary strategies de nition knuth bendix completion shown 
applications elan include constraint solving communication protocol testing 
identity strategy id succeeds returns singleton set containing subject term 
failure strategy fail returns empty set 
sequential delete compose reduce simplify reduce orient collapse reduce deduce cp completion repeat repeat repeat collapse repeat compose repeat simplify repeat delete repeat orient deduce fig 

example elan rules strategy knuth bendix completion 
composition strategies rst applies 
choice operators di erent back tracking properties 
operator dk en don know returns results strategies ei 
operator dc en don care returns results argument strategies long fail 
operator en returns results rst ei fail 
operators dc en en return result 
operator iterate iterate returns possible results iterating strategy zero times 
operator repeat repeat returns set results repeatedly applying fails 
operator normalize normalizes term respect strategy applying strategy subterms fails sub terms 
note operators apply labeled rules root 
support term traversal elementary strategies 
de ned strategies language speci traversal de ned congruence operators 
limited form genericity provided preprocessor mechanism language supports de nition speci cation schemas 
elan support language generic term traversal 
generating strategies re ection maude successors algebraic speci cation formalism obj 
maude supports kinds rewrite rules equations rules 
equations applied innermost strategy rules applied outermost strategy 
pattern matching equations rules matching modulo combinations associativity commutativity identity 
maude support operators de nition strategies 
language provides meta level speci cations manipulated re ection 
generic traversal strategies stratego language program transformation completely rewriting strategies 
stratego supports sequential programming local backtracking generic speci term traversal strategy abstraction rst class pattern matching 
gives examples uses strategies 
examples basic operators de ned strategies discussed 
strategies disj nf conj nf de ne normalizations disjunctive conjunctive normal form respectively rules 
eval strategy performs constant folding propositional formulae standard truth rules shown 
strategies impl nf de ne propositional formulae elimination implication equivalence desugaring normal form standard elimination rules shown 
strategies disj nf innermost dn dma conj nf innermost doar dn dma eval bottomup repeat topdown try defi impl nf topdown repeat defn fig 

various transformations propositional formulae 
strategies try repeat rec try rec try rec try rec fig 

generic iteration strategies 
sequential programming strategies programs attempt transform terms terms may succeed fail 
case success result attempt transformed term 
case failure result transformation 
strategies combined new strategies means operators 
identity strategy id leaves subject term unchanged succeeds 
failure strategy fail fails 
sequential composition strategies rst attempts apply subject term succeeds applies result 
non deterministic choice strategies attempts apply 
succeeds succeeds fails fail order tried unspeci ed 
deterministic choice strategies attempts apply order 
note higher precedence recursive closure rec strategy attempts apply entire subject term strategy rec occurrence variable test strategy test tries apply strategy succeeds succeeds reverts subject term original term 
fails fails 
negation succeeds identity transformation fails fails succeeds 
examples strategies de ned operators try iteration strategies 
term traversal combinators discussed combine strategies apply transformations root term 
order apply transformations term necessary traverse 
purpose stratego provides congruence operator sn ary constructor applies terms form tn applies si ti 
example congruences operator map de ned applies strategy element list 
congruences de ne traversals speci data structures 
speci cation generic traversals pre post order arbitrary structures requires generic operators 
operator applies children constructor application tn 
particular identity constants constructor applications children 
strategy applies child constructor application tn precisely failure strategy constants 
strategy applies children constructor application tn possible 
fails constants 
de nes various traversals operators 
instance tries nd application term starting root working way rst attempts apply fails application recursively attempted children subject term 
application traversal fails 
compare traversal nds outermost applications fails 
match build variable binding operators introduced far useful repeatedly applying transformation rules term 
actual transformation rules constructed means pattern matching building pattern instantiations 
match succeeds subject term matches term ect variables bound corresponding subterms subject term 
variable bound match binding succeeds terms 
enables non linear pattern matching strategies map rec nil cons conj rec topdown rec bottomup rec rec rec rec rec rec rec rec innermost rec try fig 

speci generic traversal strategies 
match succeeds arguments subject term equal 
non linear behavior arise operations 
example consecutive matches succeed exactly arguments equal 
variable bound unbound 
build replaces subject term instantiation pattern current bindings terms variables scope xn variables xi local strategy means bindings variables outside scope undone entering scope restored leaving 
operation applies strategy subject term 
successful restores original subject term keeping newly obtained bindings variables 
abstraction strategy de nition xn introduces new strategy operator parameterized strategies xn body de nitions recursive refer directly indirectly operator de ned 
recursion expressed explicitly means recursion operator rec 
labeled transformation rules abbreviations particular form strategy de nitions 
conditional rule label left hand side right hand side condition denotes strategy de nition xn 
body rule rst matches left hand side subject term attempts satisfy condition succeeds builds right hand side rule enclosed scope term variables xi occurring freely local rule 
stratego supports pattern abstraction means overlays 
generic strategies machinery stratego highly generic strategies de ned 
stratego library de nes wide range generic strategies including traversal strategies shown 
addition library de nes number higher level language independent operations collection bound variable renaming capture free substitution syntactic uni cation computing spanning tree graph 
operations parameterized relevant language constructs generically 
problem generic strategies lack knowledge computations done argument strategies may lead 
example innermost strategy arguments left hand sides rules right hand side 
shown repaired fusing generic innermost strategy arguments 
concluding remarks discussed strategies number systems 
focus analysis basic elements languages speci cation transformation strategies particular languages term rewriting 
styles strategy speci cation discussed simple tree parsing tree parsing dynamic programming exhaustive evaluation traversal functions strategy annotations sequence canonical forms non deterministic sequential strategies re ective strategies generic traversal strategies issues covered survey implementation transformation strategies general purpose programming languages constraint goal transformation strategies comparison di erent paradigms program transformation examples strategies complex program transformations 
overview various systems gives rise questions interesting combinations research topics dynamic programming dynamic programming style burg expressed general framework strategies obtaining eciency 
approach generalized complex cascading transformations 
words nd optimal sequence transformations 
complexities may involve highperformance computing context see 
types type system reconciles static typing generic strategies variables transparently deal variable bindings context sensitive issues 
interaction strategies higher order syntax 
graphs rewrite rules control ow graphs de ned temporal logic assertions 
role strategies graph transformation 
fusion generic strategies parameterized rules strategies renormalize terms 
optimization case generic de nition innermost 
general need fusion generic traversals 
aspects general fusion generic strategies rules seen form aspect weaving 
strategies formulated terms aspectoriented programming 
origins origin tracking term rewriting relates normalized term original term 
applications include error messages layout reconstruction 
compute origins system strategies 
systems clean separation rules strategies possible inheritance origin information transparent strategies 
survey part larger ort create overview theory practice program transformation online survey program transformation 
bernhard gramlich salvador lucas alba inviting write workshop reduction strategies rewriting programming 
jan heering johann jurgen gave comments previous version 

aho sethi ullman 
compilers principles techniques tools 
addison wesley reading massachusetts 

appel 
modern compiler implementation ml 
cambridge university press 

borovansk dubois kirchner kirchner 
moreau ringeissen vittek 
elan user manual 
loria nancy france edition january 

borovansk kirchner kirchner 
controlling rewriting rewriting 
meseguer editor proceedings international workshop rewriting logic applications volume electronic notes theoretical computer science asilomar paci grove ca september 
elsevier 

borovansk kirchner kirchner 
moreau vittek 
elan logical framework computational systems 
meseguer editor electronic notes theoretical computer science volume 
elsevier science publishers 
proceedings workshop rewriting logic applications 

boyle 
programming program transformation approach reusing programs 
perlis editors software reusability volume pages 
acm press 

boyle winter 
program transformation system simplifying development numerical software 
arge editors modern software tools scienti computing pages 
birkh auser 

van den brand klint 
term rewriting traversal functions 
draft march 

van den brand sellink verhoef 
generation components software renovation factories context free grammars 
science computer programming 

van den brand visser 
generation formatters context free languages 
acm transactions software engineering methodology january 

cross 
reverse engineering design recovery taxonomy 
ieee software 

clavel eker lincoln meseguer 
principles maude 
meseguer editor proceedings international workshop rewriting logic applications volume electronic notes theoretical computer science pages asilomar paci grove ca september 
elsevier 

clavel meseguer 
re ection strategies rewriting logic 
meseguer editor electronic notes theoretical computer science volume 
elsevier science publishers 
proceedings international workshop rewriting logic applications 

clavel 
re ection general logics rewriting logic applications maude language 
phd thesis universidad de facultad de espa na 

collberg thomborson low 
manufacturing cheap resilient stealthy opaque constructs 
acm sigplan sigact symposium principles programming languages popl pages san diego ca usa january 

czarnecki eisenecker 
intentional programming 
generative programming 
methods tools applications chapter 
addison wesley 

de moor 
higher order matching program transformation 
theoretical computer science 
appear preprint available web comlab ox ac uk oege papers match ps gz 

dershowitz 
jouannaud 
rewrite systems 
van leeuwen editor handbook theoretical computer science volume chapter pages 
elsevier 

van deursen heering klint editors 
language prototyping 
algebraic speci cation approach volume amast series computing 
world scienti singapore september 

elliott finne de moor 
compiling embedded languages 
semantics applications implementation program generation springer lecture notes computer science 

felty 
logic programming approach implementing higher order term rewriting 

eriksson schroeder heister editors extensions logic programming elp volume lecture notes arti intelligence pages 
springer verlag 

fokkink walters 
lazy rewriting eager machinery 
acm transactions programming languages systems january 

fowler 
refactoring 
improving design existing code 
addison wesley longman 

fraser hanson proebsting 
engineering simple ecient code generator generator 
acm letters programming languages systems september 

fraser henry proebsting 
burg fast optimal instruction selection tree parsing 
acm sigplan notices april 

goguen introducing obj 
technical report sri csl sri international computer science laboratory march 


exchange format bibliography 
workshop standard exchange format pages limerick ireland june 

heering 
implementing higher order algebraic speci cations 
miller editor proceedings workshop prolog programming language pages 
university pennsylvania philadelphia 
published technical report ms cis www cwi nl jan ho wlp ps 

huet lang 
proving applying program transformations expressed second order patterns 
acta informatica 

johann visser 
fusing logic control local transformations example optimization 
gramlich alba editors workshop reduction strategies rewriting programming wrs utrecht netherlands may 
appear 

kiczales lamping mendhekar maeda lopes 
loingtier irwin 
aspect oriented programming 
technical report xerox palo alto research center 

de moor 
imperative program transformation rewriting 
compiler construction cc lecture notes computer science 
springerverlag april 


moreau 
compilation de de de strat 
phd thesis universit henri poincar nancy june 

muchnick 
advanced compiler design implementation 
morgan kaufmann publishers 

nadathur miller 
overview prolog 
kowalski editor logic programming 
proceedings fifth international conference symposium volume pages cambridge mass usa 
mit press 

neighbors 
software construction components 
phd thesis department information computer science university california irvine 

neighbors 
users manual 
department information computer science university california irvine irvine ca usa june 
available www com manual htm 

neighbors 
approach constructing software reusable components 
ieee transactions software engineering se september 

ogata futatsugi 
implementation term rewritings evaluation strategy 
proceedings th symposium programming languages implementations logics programs plilp volume lecture notes computer science pages southampton 
springer verlag 

parr 

language translation pccts 
guide chapter pages 
automata publishing 
available www antlr org html 

parr 
overview simple tree parser generator 
www antlr org papers ps april 

peyton jones hughes report programming language haskell 
non strict purely functional language february 

pfenning elliot 
higher order syntax 
proc 
sigplan conference programming language design implementation pldi pages 
acm 

pitts gabbay 
metalanguage programming bound names modulo renaming 
backhouse oliveira editors proceedings th international conference mathematics programme construction mpc volume lecture notes computer science pages ponte de lima portugal july 
springer verlag 

proebsting 
burs automata generation 
acm transactions programming languages systems may 

sarkar 
automatic selection high order transformations ibm xl fortran compilers 
ibm journal research development may 

smith 
kids semiautomatic program development system 
ieee transactions software engineering 

van den brand de jong klint olivier 
ecient annotated terms 
software practice experience 

van der pol 
just time strategy annotations 
proceedings international workshop reduction strategies rewriting programming wrs 
appear 

van deursen klint tip 
origin tracking 
journal symbolic computation 

visser 
syntax de nition language prototyping 
phd thesis university amsterdam september 

visser 
strategic pattern matching 
narendran rusinowitch editors rewriting techniques applications rta volume lecture notes computer science pages trento italy july 
springer verlag 

visser 
language independent traversals program transformation 
jeuring editor workshop generic programming ponte de lima portugal july 
technical report uu cs department information computing sciences universiteit utrecht 

visser 
stratego language program transformation rewriting strategies 
system description stratego 
middeldorp editor rewriting techniques applications rta lecture notes computer science 
springer verlag may 
appear 

visser 
benaissa tolmach 
building program optimizers rewriting strategies 
acm sigplan notices january 
proceedings international conference functional programming icfp 

visser online survey program transformation 
www 
org 

wadler 
views way pattern matching cohabit data abstraction 
acm symposium principles programming languages pages munich january 
acm 

