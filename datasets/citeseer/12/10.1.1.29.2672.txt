developing meta theory calculus theory contexts marino miculan dipartimento di matematica informatica universit di udine italy miculan dimi 
case study formal development non trivial meta theory theory contexts coq proof assistant 
methodology underlying theory contexts reasoning systems hoas axiomatic syntactic standpoint 
feel main advantages approach requires low logical overhead 
object logic focus lazy call name calculus cbn untyped simply typed 
see formal fully detailed development theory cbn theory contexts introduces small sustainable overhead respect proofs 
allow comparison similar case studies developed approaches reasoning higher order syntax 
keywords higher order syntax induction logical frameworks 
years growing interest developing systems defining reasoning languages featuring conversion 
promising line approach focused higher order syntax hoas 
approach delegate type theoretic metalanguages burden dealing binders 
approach drawbacks 
equated metalanguage variables object level variables defined inductively introducing exotic terms 
similar difficulty arises contexts rendered functional terms 
reasoning induction definition recursion object level terms problematic 
various approaches proposed overcome problems different techniques functor categories permutation models zf 
logical framework reasoning systems hoas axiomatic syntactic standpoint 
system stems technique originally formally deriving coq metatheory strong late bisimilarity calculus 
framework consists simple types theory la church extended set axioms called theory contexts recursion operators induction principles 
experience framework expressive 
higher order logic allows impredicative definition relations possibly functional induction principles allow definition important functions partially supported italian murst project ec wg types 
properties contexts notably axioms theory contexts allow smooth handling schemata hoas 
fact feel main advantages axiomatic approach theory contexts requires low mathematical logical overhead 
course tradeoffs 
major theoretical problems concerning axiomatic approach consistency axioms 
fact possible prove theory context sound 
refer reader full proof consistency theory contexts model functor categories line 
practical point view applicability approach tested means cases studies 
particularly useful discussing pragmatic issues arise developing real proofs theory contexts addressing possible solutions suggesting directions developments 
precisely aim develop non trivial meta theory lazy call name calculus cbn untyped simply typed theory contexts coq proof assistant 
choose cbn object case study reasons 
wellknown logic works calculus skim quickly standard definitions basic proofs sweeping details rug 
see formal fully detailed development theory cbn theory contexts introduces small sustainable overhead respect proofs 
cbn owns features substitution terms variables typing system 
somewhat complementary calculus object large case study theory context 
variant calculus taken traditional benchmark example application approaches hoas literature see 
turns theory contexts quite successful handling metatheory cbn 
encoding syntax semantics type system straightforward delegate conversion metalevel 
encoding substitution immediate need represent relation 
allow state prove fundamental results functionality substitution usually taken granted informal works calculus 
proofs cast light limits suggest possible solutions theory contexts coq 
coq code available www dimi miculan hoas 
synopsis 
section recall briefly works done object system cbn 
section give brief presentation type theory cic implementation coq 
hoas encoding syntax semantics cbn formal development metatheory theory contexts described sections respectively 
practical issues arise developing proofs discussed possible solutions proposed 
section consider simple type system cbn leads modify slightly theory contexts order take account assumptions behaviour variables brought type system 
comparison related sections respectively 
object logic cbn section give intentionally brief somewhat sloppy definition lazy call name calculus cbn usually papers 
allow sections formal representation theory introduce substantial overhead despite high level detail required 
assume reader familiar basic notions calculus comprehensive development theory calculus see 
set terms cbn defined grammar mn 
range infinite set variables 
terms taken equivalence 
denote capture avoiding substitution contexts terms holes denoted 
term said value application 
notion free variables defined usual 
finite set variables define 
consider lazy operational semantics 
reduction small step semantics smallest relation defined rules denote reflexive transitive closure 
evaluation big step semantics smallest relation defined rules calculus inductive constructions calculus inductive constructions extension calculus constructions cc defined pts barendregt cube sorts prop set 
proposition types proofs terms paradigm isomorphism propositions intuitionistic higherorder logic types sort prop 
type prop represents logical proposition fact inhabited term represents fact holds 
term inhabiting represents proof hand sort set supposed type datatypes naturals lists trees booleans types differ inhabiting prop constructive contents 
cc similar type theories fruitfully general logic specification language logical framework lf 
lf represent faithfully uniformly relevant concepts inferential process logical system syntactic categories terms variables contexts assertions axiom schemata rule schemata instantiation tactics 
calculus inductive constructions cic implemented coq system extends cc special constants represent definition elimination inductive types 
instance definition natural numbers written coq specification language inductive nat set nat nat nat allows define terms case analysis function definition pred nat cases 
nat notation abstraction nat 
elimination schemata coq automatically states proves induction principle inductively defined type 
instance definition yields peano induction principle free nat ind nat prop nat nat nat notation dependent product nat feature extensively definition logical connectives need specify rules prove elimination rules elimination principle system automatically provides 
allowing inductive definition cic yield non normalizing terms invalidating standard proof consistency system 
inductive definitions subject positivity condition roughly requires type defining occur negative position type argument constructor 
condition ensures soundness system rules sound inductive definitions 
instance definition terms higher order syntax inductive set lam app formed due negative occurrence type argument lam 
problem arising higher order syntax inductive types exotic terms 
terms correspond object despite types correspond syntactic category 
exotic term generated type higher order constructor inductive type 
simple example fragment order logic inductive set zero inductive set ff eq forall definition weird forall cases zero ff eq zero zero 
term weird correspond proposition order logic formula syntactically equal ff respectively 
exotic terms problematic establishing faithfulness formalization usually ruled means auxiliary validity judgements 
approach section higher order constructors range types defined inductive cases 
common implementation cic coq interactive proof assistant developed inria institutes 
complete description refer 
coq editor interactively searching inhabitant type top fashion applying tactics step step backtracking needed verifying correctness typing judgements 
proof search starts entering lemma ident goal 
goal type representing proposition prove 
point coq waits commands user order build proof term inhabits goal proof 
coq offers rich set tactics application assumptions application rules previously proved lemmata elimination inductive objects inversion inductive hypotheses 
tactics allow user proceed proof search informally 
step type checking algorithm ensures soundness proof 
proof term completed saved command qed applications 
encoding theory cbn syntax 
hoas representation adopt parameter var set 
inductive tm set var var tm app tm tm tm lam var tm tm 
coercion var var tm 
declaring var coercion allows inject implicitly terms type var tm constructor may omitted terms 
key define var inductive set 
fact required definition syntax cbn reason bring unnecessary assumptions induction recursion principles 
unwanted principles harmless exploited defining exotic terms 
var inductive simply wrong 
notice lam higher order constructor takes functional term argument 
particular terms type var tm represent exactly capture avoiding contexts calculus 
technique allows inherit equivalence terms metalanguage inductive definition terms 
instance xx yy represented lam var app var var lam var app var var respectively term conversion 
time define functions order recursion case analysis syntax terms definition tm cases var true lam true app false 
adequacy encoding consequence theorem 

xn finite set variables define var 
xn var tm tm long normal form 
proposition 
finite set variables bijection tm bijection compositional sense var 
corollary capture avoiding context naturally encoded var fresh variable acts placeholder hole 
fact bijection proposition established contexts terms type var tm 
substitution 
drawback separate type variables differently delegate substitution metalanguage 
need define hand parametric relation contexts terms inductive subst tm var tm tm prop subst var subst var subst void var subst var subst app var tm tm subst subst subst var app app subst lam var var tm var tm var subst var subst var lam lam 
term syntactically equal substitution iff subst holds 
formally proposition 
finite set variables variable 
subst var semantics 
representation operational semantics straightforward 
substitution represented relation appears assumption simple function application 
inductive red tm tm prop red beta tm var tm subst red app lam red head tm red red app app 
inductive tm tm prop ref tm trs tm red tm 
inductive eval tm tm prop eval var var eval eval lam var tm eval lam lam eval app tm var tm eval lam subst eval eval app 
proposition 
finite set variables 
red 

eval dealing metatheory cbn encoding previous section faithful representation theory object logic cbn 
words deriving reductions evaluations quite easily small conceptual overhead respect done 
encoding completely satisfactory comes handle metatheory object logic 
section apply theory contexts order prove results cbn 
theory contexts signature syntax introduce appropriate theory contexts 
composed parts 
contains definitions occurrence predicates 
definitions immediately derived signature language pattern 
inductive notin var tm prop notin var var notin notin app tm notin notin notin app notin lam var tm var notin notin lam 
inductive isin var tm prop isin var isin isin app tm isin isin app isin app tm isin isin app isin lam var tm var isin isin lam 
thing need know names variables equality var decidable 
need full blown classical logic sufficient classical behaviour occurrence check predicates 
axiom lem oc tm var isin notin 
equivalent decidability eq var 
second part theory contexts consist set axiom schemata reflect theory level fundamental properties intuitive notion context occurrence variables 
informal meaning variables term contain variables exists variable occur free term extensionality contexts contexts equal equal fresh variable formally axioms theory contexts need axiom unsat tm ex var notin 
axiom ext tm var tm var notin lam notin lam axiom ext tm var var tm var notin lam var lam notin lam var lam 
described section coq similar systems provide support inductive types 
hold higher order types var tm 
words proof editors give induction principles case analysis inversion predicates similar tools reasoning contexts 
possible prove types form var tm recursion induction principles 
introduce principles simple axioms theory contexts 

axiom schema called expansion 
informally exp states term variable context occur 
times development metatheory calculus 
hand needed cbn 
possible motivation allowed higher order induction recover induction plain order terms 
useful application exp representation variable capturing contexts hoas 
general difficult bound variables accessible outside abstraction names 
theory contexts context capturing represented term type var tm tm instantiation requires expansion inserted term 
instance represented var tm lam var app var 
consider term free variable captured context obtained expansion appear free 
variable capturing instantiation rendered 
immediate consequences theory contexts induction principles tm 
lemma differ var ex var 
lemma isin notin absurd var tm isin notin false 
properties substitution capture avoiding substitution naturally defined function fact definition seldom full detail exception section 
definition usually intended formalized section deterministic priori requires arbitrary conversion bound variables context order avoid capturing free variables substituted term 
complex languages dynamic logic hoare logic may require nonstandard substitutions involving contrived notions conversion simply conversion 
representing substitution relation gives raise possibility may total 
fact definition give functional deterministic total relation property going prove explicitly theory contexts 
determinism substitution property want prove parameter tm 
lemma subst det var tm tm subst tm subst 
give proofs property 
goes induction derivation subst 
gives rise cases tm subgoal var tm tm subgoal subst var app subgoal lam dealt inverting hypothesis corresponding 
usually inversion eliminate automatically absurd cases terms discriminate higherorder 
case second argument subst type var tm 
inversion tactic gives cases goal trivially true absurd subgoal tm var tm tm subst var var var subgoal tm var tm tm subst var var var var absurd cases eliminated theory contexts particular axiom extensionality 
proof lines long dealing elimination absurd cases 
determinism substitution 
shorter proof obtained proving suitable higher order inversion lemma substitution 
coq inversion lemmata automatically synthesized proved fly recursion principles inversion tactic algorithm originally implemented murthy subsequent elaboration cornes 
algorithm fails give right inversion predicate datatype discriminate higher order usual inductive type theories recognize higher order type inductive 
know types form var tm recursion principles 
consistently introduce principles axioms definition recursive map needed inversion predicate parameter subst inv fun tm var tm tm prop 
axiom subst inv fun var tm subst inv fun var 
axiom subst inv fun var var tm subst inv fun var var 
axiom subst inv fun app var tm tm subst inv fun var app ex ex app subst subst 
axiom subst inv fun lam var var tm tm subst inv fun var lam ex lam var subst var 
higher order inversion principle mechanically claimed proved follows lemma subst inv var tm tm subst subst inv fun 
intros inversion clear rewrite subst inv fun var reflexivity 
rewrite subst inv fun var reflexivity 
rewrite subst inv fun app exists exists auto 
rewrite subst inv fun lam exists auto 
qed 
inversion lemma proof determinism substitution easier fact lift level context syntactic machinery inversion tactics coq provides level terms lemma subst det var tm tm subst tm subst 
induction intros 
generalize subst inv 
rewrite subst inv fun var trivial 
generalize subst inv 
rewrite subst inv fun var trivial 
generalize subst inv 
rewrite subst inv fun app intros 
inversion clear inversion clear inversion clear inversion clear 
rewrite rewrite assumption 
generalize subst inv 
rewrite subst inv fun lam intros 
inversion clear inversion clear inversion clear 
replace auto 
elim unsat app lam lam 
intros inversion clear 
apply ext tm auto 
qed 
see proof axioms theory contexts unsat ext tm 
totality substitution proof totality tricky due peculiarities cic 
lemma want prove lemma subst total var tm ex subst 
intent prove higher order induction fails case lambda abstraction appears follows tm var tm var var tm var ex tm subst var ex tm subst var lam suitable term obtained hypothesis coq allow eliminate proposition build term set tm 
eliminations strong types may lead inconsistencies ruled type theory cic 
solution adopt move proof set realm lift result prop 
introduce set typed version induction principle equivalently seen recursor dependent types axiom tm rec var tm set var var var var var tm var app var var tm var var var lam var tm 
prove totality set higher order dependent recursion lemma sit var tm tm subst 
intro pattern apply tm rec intros clear split apply subst var 
exists var apply subst void 
inversion clear inversion clear 
split app apply subst app assumption 
exists lam var proj sig tm 

apply subst lam intros 
apply proj sig 
qed 
notice case lambda require term built eliminating projecting type hypothesis instantiated locally bound fresh variable totality theorem just extraction logical part type sit lemma subst total var tm ex tm subst 
intros 
exists proj sig 
sit 
apply proj sig 
qed 
properties semantics substitution proved deterministic interesting properties small step big step semantics proved theory contexts 
properties determinism semantics equivalence big step small step semantics 
lemma red det tm red tm red 
lemma eval det tm eval tm eval 
lemma red eval tm red tm eval eval 
lemma eval tm eval 
lemma eval tm eval 
properties proved simple induction derivation red eval red eval respectively 
extending meta theory typing system section extend theory metatheory cbn adding simple types 
simple types defined grammar range type variables 
typing judgement form typing base finite set pairs 
xn usual typing rules syntax simple types encoded trivially dom parameter tyvar set 
inductive ty set tvar tyvar ty arr ty ty ty 
coercion tvar tyvar ty 
typing system bearing structure var 
previous section assumed var simply set required properties unsat axiom ultimately decidability equality 
typing system requires free variable type 
reflected encoding adding structure var assuming existence type assignment requiring fresh variable introduced unsat type parameter typevar var ty 
axiom unsat tm ty ex notin typevar 
encoding typing system straightforward inductive type tm ty prop type var var type var typevar type app tm ty type arr type type app type lam var tm ty var typevar type type lam arr 
notice unsat entails unsat results previously proved hold axiom 
important property need prove substitution preserves types terms lemma subst preserves types var tm tm subst ty type lam arr type type 
proved induction derivation subst unsat introducing fresh names right types lemma type invariance replacement free variables lemma type invar var tm ty var typevar type var typevar type 
lemma states property contexts natural proceed higher order induction 
unfortunately coq gives induction principles functional spaces know type var tm satisfies induction principle axiom tm ind var tm prop var var var var var tm var app var var tm var var var lam var tm 
higher order induction principle lemma type invar proved straightforwardly 
subject reductions properties simple consequences subst preserves types lemma sr eval tm eval ty type type 
induction clear intros try assumption 
inversion clear apply 
apply subst preserves types auto 
qed 
lemma sr red tm red ty type type 
lemma sr tm ty type type 
proofs properties similar related case study compared similar developments calculus hoas 
due lack space discuss briefly 
despeyroux adopted approach similar reasoning call value calculus 
main difference variables represented inductive set nat 
allows avoid assume properties theory contexts axioms price cope exotic terms 
ruled means formedness predicate valid arguments carried terms extensionally equivalent valid term 
cic extensional equivalence embedded valid explicitly 
dealing formedness introduces substantial overhead respect informal proofs conceivable means ad hoc tactics 
coq code covering syntax substitution big steps semantics typing system proof subject reduction lines long theory developed theory contexts takes lines 
hand ckl proved theory contexts calculus derived formedness predicates isabelle 
sense theory contexts seen core set basic properties capturing essence context assuming unnecessary assumptions 
case studies needed order verify expressive power approach 
pitts introduced nominal logic order logic specifically designed reasoning syntax involving variable bindings 
axioms nominal logic express key properties fm model syntax introduced 
main idea express deal properties validity invariant swapping names 
interesting see principles common nominal logic theory contexts names structural induction modulo 
exact connection theories investigated 
pointed nowadays proof editors particular type theory lack induction higher order types 
problem combining hoas induction avoiding arising exotic terms addressed radically modal calculi proposed metalanguages place usual type theories 
fact approach best seen step brand new generation proof assistants way dealing hoas nowadays proof editors theory contexts intended 
approaches reason objects metalogic cic hol 
metalogic 
different perspective add explicitly extra logical level reasoning 
meta metalogic higher order intuitionistic logic extended definitions higher order quantification simply typed terms 
induction types recovered induction natural numbers appropriate notions measure 
differently approach adopted possible delegate substitution metalanguage 
successfully reason typing evaluation judgements call name calculus case studies 
streamline logic programming tradition logical frameworks support notion proof object typical judgements types paradigm 
properties cbn proved proved theory contexts simple structural induction proofs 
due logic programming flavour suited complete automatization implementation theorem prover 
similar attitude different aims sch rmann constructive order logic edinburgh lf 
meta metalevel offers higher order induction recursion reasoning possibly open objects lf encoding 
aimed complete automatization implemented theorem prover twelf difficult compare interactive approaches ones previously discussed 
non trivial case study meta theory cbn theory contexts coq proof environment 
approach allowed smooth treatment syntax conversion substitution small step big step semantics typing system cbn 
formally proved properties functionality substitution determinism big step semantics equivalence big step small step semantics subject reductions semantics opinion case study successful 
logical overhead required user acceptable encodings user directly transpose intuition hand proofs proof editor 
development lines long 
case study pointed weak points theory contexts coq system particular connection higher order inversion principles 
shown means example suitable inversion principles higher order types stated derived 
focused coq system arguments applicable proof assistant inductive type theories close cic lego plastic 
hand theory contexts inconsistent axiom unique choice ac 

particular means approach adopted adopted isabelle hol description axiom ac 
comparison formalizations languages variable bindings isabelle see 
possible theory contexts classical hol see example metalanguage full classical higherorder logic proof consistency 

development metatheory cbn extended directions 
instance theory applicative bisimulation particularly appealing 
order prove equivalence contextual applicative bisimulation define measure proofs evaluation judgement changing judgement 
cic take advantage coinductive types 
theory contexts successfully conjuction coinductive types reasoning bisimulation calculus 
possible generalization inversion algorithms suitable higher order types 
practical point view particularly useful 
theoretical side interesting issues arisen 
needed theory contexts axiom expansion introduced 
point properties cbn dealt rely kind property 
second issue due soundness constraints imposed cic order prove totality substitution introduced higher order recursion dependent types 
known models theory contexts validate plain higher order recursion open question models extended dependent type theory 

abramsky 
ong 
full abstraction lazy lambda calculus 
information computation 

avron honsell mason pollack 
typed lambda calculus implement formal systems machine 
journal automated reasoning 

barendregt 
lambda calculus syntax semantics 
studies logic foundations mathematics 
north holland 

hofmann honsell miculan 
consistency theory contexts 
preparation 

coquand 
metamathematical investigations calculus constructions 
odifreddi editor logic computer science volume pages 
academic press 

cornes 
automating inversion inductive predicates coq 
berardi coppo editors proc 
types number lecture notes computer science pages turin mar 
springer verlag 

despeyroux felty hirschowitz 
higher order syntax coq 
proc 
tlca volume lecture notes computer science edinburgh apr 
springer verlag 
appears inria research report rr april 

despeyroux 
primitive recursion higher order syntax dependant types 
floc workshop trento italy 

despeyroux pfenning sch rmann 
primitive recursion higher order syntax 
technical report cmu cs school computer science carnegie mellon university pittsburgh pa aug 

fiore plotkin turi 
syntax variable binding 
longo pages 

gabbay pitts 
new approach syntax variable binding 
formal aspects computing 
special issue honour rod burstall 
appear 

gordon melham 
axioms alpha conversion 
proc 
number lecture notes computer science pages 

harper honsell plotkin 
framework defining logics 
acm jan 

hofmann 
semantical analysis higher order syntax 
longo pages 

honsell miculan 
higher order encoding calculus inductive type theories 
talk types annual workshop mar 

honsell miculan 
axiomatic approach metareasoning systems higher order syntax 
proc 
icalp lncs 
springer verlag 
appear 
available www dimi miculan papers 

honsell miculan 
calculus inductive type theory 
theoretical computer science 
appeared talk types annual workshop 

inria 
coq proof assistant 
coq inria fr doc main html 
longo editor 
proceedings fourteenth annual ieee symposium logic computer science trento italy july 
institute electrical electronics engineers ieee computer society press 

mcdowell miller 
reasoning higher order syntax logical framework 
acm transactions computational logic 
appear 

miculan 
encoding logical theories programs 
phd thesis dipartimento di informatica universit di pisa italy mar 

ambler crole 
comparison formalizations meta theory language variable bindings isabelle 
technical report university leicester 

paulin mohring 
inductive definitions system coq rules properties 
bezem groote editors proc 
conference typed lambda calculi applications volume lecture notes computer science pages 
springer verlag 

pfenning 
practice logical frameworks 
proc 
caap number lecture notes computer science pages 
springer verlag april 

pfenning elliott 
higher order syntax 
proc 
acm sig plan symposium language design implementation pages atlanta georgia june 
association computing machinery 

pfenning sch rmann 
system description twelf meta logical framework deductive systems 
ganzinger editor proceedings th international conference automated deduction cade number lnai pages trento italy 
springer verlag 

pitts 
order theory names binding 
ambler crole editors proc 
merlin pages siena june 
technical report department mathematics computer science university leicester 

ckl berghofer 
higher order syntax induction isabelle hol formalising calculus mechanizing theory contexts 
honsell miculan editors proc 
fossacs number lncs pages genova 
springer verlag 

