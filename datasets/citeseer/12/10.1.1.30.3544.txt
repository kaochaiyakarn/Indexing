parallelizing functional programs generalization 
sergei 
wilhelm institut fur informatik university sand tubingen university passau passau germany 
email fmi uni passau de 
list homomorphisms functions parallelizable divide conquer paradigm 
study problem finding homomorphic representation function theory lists 
previous proved pair leftward rightward sequential representations function cons snoc lists respectively representation homomorphism 
contribution method extract homomorphism representation pair sequential representations 
method decomposed generalization problem inductive claim solvable term rewriting techniques 
solve sound generalization procedure yields required representation terminates reasonable assumptions 
illustrate method procedure parallelization scan function parallel prefix 
inductive claim provable automatically 
addresses problem deriving correct parallel programs functional specifications 
builds rich body research done framework bird meertens formalism bmf :10.1.1.100.9674
parallelism tackled bmf notion homomorphism captures data parallel form divide conquer dc paradigm 
classification dc forms suitable static parallelization proposed 
homomorphisms design parallel programs tasks solved extraction function find representation homomorphism adjust customize homomorphic form 
implementation different classes homomorphisms find efficient way implementing parallel machines 
tasks aim systematic approach lead practically relevant parallel programming methodology :10.1.1.44.9840
systematic extraction method proposed proceeds generalizing sequential representations function cons snoc lists 
partially supported ku dfg university tubingen 
partially supported dfg project recur daad exchange programs arc 
called cs method cs cons snoc proven powerful class homomorphisms include famous problems maximum segment sum parsing multi bracket languages examples 
step solving extraction problem 
contributions precise formulation cs approach extraction problem term generalization second generalization procedure bird meertens theory lists cs method 
propose new algorithm generalization term rewriting desirable properties soundness reliability termination 
structured follows 
section introduces bmf notation notion homomorphism 
section introduces notion generalization formulates cs method homomorphism extraction generalization framework 
section derive generalization calculus theory lists term rewriting 
section shows apply generalization calculus cs generalization derives terminating deterministic procedure algorithm generalization 
section summarizes results outlines 
presentation illustrated running example scan function known parallel prefix 
practically relevant function demonstrate non triviality extraction problem show cs method works apply proposed generalization algorithm successfully extracts homomorphic form scan 
full version proofs claims 
bmf homomorphisms restrict non empty lists constructed starting singletons list concatenation 
bmf expressions built functional composition denoted ffi second order functions map map unary function map delta delta delta xn fx delta delta delta fxn red fi reduce binary associative operation fi red fi delta delta delta xn fi fi delta delta delta fi xn definition 
list function homomorphism iff exists binary associative combine operator fi lists fi value list depends particular way fi values pieces list 
computations independent carried parallel 
theorem bird 
function homomorphism iff exists binary associative combine operator fi red fi ffi map defined 
theorem provides standard parallelization pattern homomorphisms composition stages 
stage map fully parallel parallelization second reduction stage studied 
loosely speaking function homomorphism iff parallelizable 
example scan homomorphism 
illustrating example scan function associative fi list computes prefix sums 
list elements acts follows scan fi fi fi fi fi fi fi function scan surprisingly wide area applications including evaluation polynomials searching parallelization extensively studied belongs folklore parallel computing 
function scan homomorphism combine operator fi scan fi fi map fi scan fi scan fi called sectioning exploited fix argument fi obtain unary function fi mapped 
desired parallel homomorphic representations list concatenation traditional sequential functional programming constructors cons snoc 
notation delta cons attaches element front list delta snoc attaches element list 
goal sequential representations function extract parallel homomorphic representation 
definition 
list function called leftwards lw iff exists binary operation phi delta phi elements lists dually function rightwards rw iff omega delta omega note phi omega may non associative functions lw rw 
theorem combines called second third homomorphism theorems considered folk theorems bmf community 
theorem 
function lists homomorphism iff leftwards rightwards 
unfortunately pointed theorem provide method construct homomorphic representation function leftwards rightwards definitions 
extraction task formulated finding combine operation fi operations phi omega start imposing additional restriction leftwards rightwards functions 
definition 
function called left homomorphic lh iff exists fi arbitrary list element holds delta fi 
definition right homomorphic rh function dual 
evidently lh rh function lw rw resp vice versa 
function defined elements operation phi unique fi lh function arbitrary denote function lh fi similarly notation rh fi introduced 
write hom fi unique fi homomorphic function theorem 
hom fi lh rh lh fi rh fi 
vice versa lh fi rh fi fi associative hom fi 
prove slightly stronger proposition 
theorem suggests possible way find homomorphic representation construct cons definition function lh format dually find rh representation snoc lists prove combine operation associative 
simple method works function yields length list scan 
example continued extraction scan 
try simple method scan function introduced example 
sequential cons definition scan follows scan fi delta delta map fi scan fi representation match lh format scan allowed 
scan different possibilities express scan fi head scan fi scan fi 
unfortunately possible terms fi obtained instance head fi map fi defines non associative operation 
run similar problem cons definition 
believe shown problem extract homomorphism nontrivial 
scan function led errors published parallel algorithms required formal correctness proof 
cs method extraction generalization assume function homomorphism holds denotes term defines fi fi terms built substitutions fu 

fu 

semantically equal variants cons snoc representations respectively function fi fi homomorphism extraction problem formally specified follows cons definition delta snoc definition delta function lists 
wanted definition fi fi 
intend apply framework generalization problem 
definition 
term called generalizer terms equational theory substitutions oe oe oe oe denotes semantic equality conversion relation equational theory obviously general generalizer variable oe oe oe def fx 
oe def fx 
obvious people prefer special generalizer provided 
respect generalization dual unification called anti unification 
plotkin closely studied special case relation terms 
case empty general syntactic unifiers special syntactic generalizers 
contrast unification properties methods generalization nonempty hardly known 
generalization methods exercised inductive theorem proving systematic construction term rewriting system counting functions basis effective enumeration elements 
purpose extract homomorphisms simpler 
need adapt equational theory introduce new functions 
start presentation equational theory get generalization algorithm generalization calculus differs basically rewrite derivations conversions 
generalization applied yield wanted piece definition homomorphism 
illustrates relations terms dotted arrows indicate substitutions solid arrows indicate conversion steps 
substitution applied terms simultaneous generalization problem 
order established notion generalizer introduce fresh binary function symbol model pairs terms terms called rule terms 
encoding get view 
theorem 
theory lists fa 
bg 
rule terms fi fi generalizer fi oe fu 

oe fu 

tb fi gamma gamma gamma 
tc gamma gamma gamma 
th oe tl oe oe fi gamma gamma gamma 
th th oe oe fi gamma gamma gamma 
ts gamma gamma gamma 
th oe tr simultaneous generalization problem tb fi tc ye fi tl oe fi th oe fi tr ye fi ts rule term encoding fig 

relationships terms successful cs generalization oe fu 
tb 
oe fu 

operation fi defined associative cons snoc definitions define function 
function lh rh 
function homomorphism fi combine operation 
proof follows immediately theorem 
generalization theorem called cs generalization theory lists summarize considerations method finding combine operation proceeds steps 
cs method 
successful cs generalization applied rule terms fi fi yields rule term fi 
associativity fi defined proven inductively theorem fi desired combine operator 
example continued 
scan corresponding rule terms fi scan fi delta map fi scan fi scan fi fi scan fi delta scan fi fi cs generalization yields fi map fi prove operation fi defined fi map fi associative scan homomorphism fi defined 
practice advisable lw format rw format simplify necessary generalization 
difficulty writing rw lw definition function indicator function homomorphism 
expressing cs method term rewriting apply cs method practically generalization step method mechanized algorithm required yields special generalizer terms 
adopt term rewriting methods step embed fragment bird meertens theory lists term rewriting theory 
simple technical apparatus henceforth restrict firstorder terms suppress higher order parameters consider fixed associative operation fi 
renders necessary express fragment theory lists order functions term rewriting rules 
running example replace scan fi scn map fi mp 
rewrite rules conversion rules order account oriented replacement rewriting rewrite rule may replace term form form fact expressed indicate appears context system rewrite rules writes application rule yielding term relation equivalence closure smallest binary relation terms contains reflexive symmetric transitive 
able reason rewriting framework fix term rewriting systems term rewriting system conversion relation semantic equality term rewriting systems cons snoc conc versions definitions start oriented associativity rules fi fi fi 
fi fi fi 
symbols delta delta defining rules delta delta appear explicitly method 
replace delta delta respectively 
keep things simple assume mutually recursive call relation contain cycles length greater 
assume term rewriting system base contain suitable rules functions called may inductive argument assume auxiliary functions homomorphisms extraction done 
words function called means right hand side definition respectively 
functions parameter assume parallelization done parameter list 
term rewriting system base terms define term rewriting system describe conversion relation serve semantic equality term rewriting systems cons snoc conc reasoning cons snoc definitions respectively fi base fh fi cons ft fi snoc fh fi conc fu fi fa 
bg just term renamed example continued 
example scn calls functions mp 
base mp fi mp mp mp get accordingly mp scn scn scn fi 
scn scn scn fi scn cons fi scn mp scn snoc fi scn scn fi want conc defines function cons snoc speaking inductively valid equation 
ground term term contain free variable 
inductive theory term rewriting system set formal equations terms oe oe holds substitutions oe oe oe ground 
term rewriting system called conservative extension equation inductive theory terms signature inductive theory see inductive theorem proving rewriting 
theorem reliability 
term rewriting systems cons snoc conc defined 
rule terms fi fi generalizer fi substitutions oe fu 

oe fu 

properties hold 
conversion relations included conversion relation 
fi associative inductive theory conc conc conservative extension 
fi associative inductive theory conc inductive theories cons snoc conc coincide 
words generalizer certain shape inductive proof provide solution homomorphism extraction problem 
inductive proof associativity fi may carried mechanized inductive theorem prover 
example continued 
scn example semi automatic inductive prover tip produce proof associativity fi lemmas mp fi mp mp mp fi turn proof lemma 
proofs obtained rewriting induction user interaction 
leaves solve generalization problem 
custom introduce algorithm means calculus 
objects calculus keep triples oe oe maintaining invariant generalizer substitutions oe oe respectively 
starting triple fx 
fx 
general generalizer successively apply inference rules specialize inference rule applies 
basic idea repeat long possible step extract common row oe oe move step preserving generalization property adds speciality maximally special 
show inference rules 
formula gamma 
means rewrites zero steps rewrite step takes place root position substitutions oe fx 
xm 
fy 
yn 
disjoint union defined oek fx 
xm 

yn 
ancestor decomposition rule acts follows 
common variable domain substitutions selected 
shares root function symbol ancestor decomposition rule applicable void rewrite derivations gamma 
gamma 
oe 
oe 
oe oe fx 
fx 

fx 

fig 

ancestor decomposition rule oe 

ug oe 

vg oe 
ug oe 
vg fx 
fig 

agreement rule common function symbol broken splitting mapping 


fresh variables argument position likewise 
split 

common part 
transferred term gamma 
called ancestor enable conversion rules furthermore allow replaced ancestor thereof 
words allow non void rewrite derivations condition 
agreement rule acts follows 
mappings 

common right hand sides substitution split 



second substitution likewise 

split 
common part 
transferred occasionally justify application ancestor decomposition rule form gamma 
just rewrite derivation gamma 
void justify application agreement rule put agr 
fairly easy prove calculus sound sense theorem soundness 
inference step oe oe oe oe oe oe oe oe corollary 
generalizer term rewriting system oe oe oe oe inference step special generalizer example continued 
study scn example see calculus operates 
fi scn mp scn scn fi scn scn fi derivation listed 
generalization algorithm turn generalization calculus algorithm decide rule application strategy prove termination 
adopt strategy prefer agreement rule choose smallest index inference rule applies 
ancestor decomposition rule applies branch pair justifying rewrites 
certainly complexity may exponential way experience shows branching harmless rarely branch 
safe side replace condition ancestor decomposition rule gamma 
gamma 
gamma 
means rewrites exactly steps step takes place root position call resulting calculus restricted generalization calculus 
restricted generalization calculus opposed unrestricted ancestor decomposition rule finitely branching applicable instances computable provided contains erasing rules rules contains variable instance rule erasing left right hand side 
condition hard practice may 
observe instance derivations example restricted generalization calculus 
restricted generalization calculus complete simple fact function definitions need recursion unbounded number steps ancestor decomposition rule 
restricted generalization calculus non terminating derivations 
example 
successor predecessor integers rewrite rules get infinite derivation fx 
fx 
fx 
fx 
fx 
fx 
delta delta delta phi 
psi phi 
psi 
fi scn 
mp scn 
scn fi 
scn scn fi fi 

scn 
mp scn 
scn 

scn scn fi fi 

scn 

mp scn 
scn 

scn 
scn fi fi agr 

scn 
mp scn 
scn 

scn fi fi mp mp scn gamma gamma 
scn fi 

scn 

scn 
scn 

scn 
fi mp agr 

scn 

scn 

scn fi mp mp gamma gamma 


scn 

scn 

scn fi mp agr ae 

scn oe ae 
scn 
oe fi mp fig 

successful derivation scn standard way get finiteness derivations termination procedure take care derivations oe oe oe oe delta delta delta satisfy oe oe oe oe appropriate founded order triples 
term rewriting finiteness rewrite derivations ensured requirement rule suitable termination order founded order terms closed contexts substitution applications 
knowledge useless purposes need apply rules reverse direction 
realistic require property usually violated 
instance satisfy termination order term greater 
observe apply rule reverse direction strip top symbol left hand side 
stripping top symbol considered decrease provided reverse rule application harm 
definition 
order pairs terms 
term rewriting system called reversely guarded rewrite rule xm 
xm 
hold theorem termination 
founded order pairs terms closed substitution application extends component wise subterm order 
reversely guarded restricted generalization calculus admits infinite derivations 
term rewriting system contains erasing rules reversely guarded 
term rewriting system scn function reversely guarded 
argued condition sensible exclude erasing rules computability reasons 
example continued 
term rewriting system rnf reversely guarded 
prove assign function symbol weight non negative integer weight term defined sum weights function symbols relation pairs terms defined follows 

variable occurs straightforward show founded order closed substitution application contains component wise subterm relation 
show reverse show rule root symbol left weight assignment obviously job 
reasoning rule delta derivation restricted generalization calculus refuses rule finite obtain algorithm computes finite set generalizers 
extraction homomorphism cons snoc definition function lists systematic powerful technique designing parallel programs 
advantage direct intuition construction parallel solution clearly visible complex problems scan called homomorphisms considered lack space 
successfully applied techniques area term rewriting generalization rewriting induction attack nontrivial intriguing extraction problem 
rules cons snoc encoded terms generalizer certain form encodes definition homomorphism 
provided associativity result proven inductively automated inductive theorem prover 
prove reliability method extract homomorphism 
introduced simple sound calculus generalization terms 
impose strategy sensible restriction calculus obtain terminating deterministic procedure 
exponential upper bound worst case time complexity algorithm appears perform linearly practice 
best knowledge successful mechanization homomorphism extraction problem 
imagine improvements calculus rewriting modulo associativity powerful ancestor decomposition rule able jump number non top rewrite steps appropriately weakened application condition 
course step implementation algorithm 

chris lengauer anonymous referees helpful remarks 

leo bachmair 
canonical equational proofs 
research notes theoretical computer science 
wiley sons 

barnard schmeiser skillicorn 
deriving associative operators language recognition 
bulletin eatcs 

bird 
lectures constructive functional programming 
broy editor constructive methods computing science nato asi series computer systems sciences 
vol 
pages 
springer verlag 

blelloch 
scans primitive parallel operations 
ieee trans 
computers november 

hubert comon marianne jean pierre jouannaud 
cycle shallow theories 
inform 
computation 

ulrich heinrich 
term induction proofs generalization narrowing 
rattray clark editors unified computation laboratory unifying frameworks theories tools oxford uk 
clarendon press 


parallelizing functional programs term rewriting 
technical report mip universitat passau april 
available brahms fmi uni passau de cl papers html 


mechanized inductive proof properties simple code optimizer 
peter mosses mogens nielsen michael schwartzbach editors proc 
th theory practice software development tapsoft lncs pages 
springer 

gibbons 
third homomorphism theorem 
fun 
programming 


constructing list homomorphisms 
technical report mip universit passau august 


systematic efficient parallelization scan list homomorphisms 
robert editors europar 
parallel processing lecture notes computer science pages 
springer verlag 


systematic extraction implementation divide conquer parallelism 
swierstra editors programming languages implementation logics programs lecture notes computer science pages 
springer verlag 

bischof 
formal derivation divide conquer programs case study multidimensional fft 
editor formal methods parallel programming theory applications 
workshop ipps pages 

heinz 
lemma discovery anti unification regular sorts 
technical report tu berlin may 

jean pierre jouannaud 
syntactic theories 
editor mathematical foundations computer science pages 
lncs 

steffen lange 
set inference rules solving divergence knuthbendix completion 
klaus jantke editor proc 
analogical inductive inference pages 
lncs 

donnell 
correctness proof parallel scan 
parallel processing letters 

gordon plotkin 
lattice theoretic properties subsumption 
technical report memo mip univ edinburgh uk 

skillicorn 
foundations parallel programming 
cambridge univ press 

thomas phil watson 
solving divergence knuth bendix completion enriching signatures 
theoretical computer science 
article processed macro package llncs document class 
