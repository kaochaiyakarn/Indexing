hidden agenda joseph goguen dept computer science engineering university california san diego ca usa malcolm dept computer science university liverpool liverpool gl uk publicly reveals motivates surveys results ambitious hidden agenda applying algebra software engineering 
reviews selected literature introduces new perspective nondeterminism features powerful hidden coinduction techniques proving behavioral properties concurrent systems especially re nements proofs obj 
discuss modularization bisimulation transition systems combinations object logic constraint functional paradigms hidden agenda 
algebra useful di erent ways software engineering including speci cation validation language design underlying theory 
speci cation validation help practical production reliable programs advances language design help improve state art theory help building new tools increase automation showing correctness enterprise 
utility vitality growing links areas suggest existence signi cant emerging eld called algebraic engineering 
roots lie framework universal called general algebra pioneered birkho tarski part computer science 
research agenda involves extending universal algebra account realities modern software largely focused foundational aspects programme 
agenda includes broader task providing real support practical software engineering 
preprint submitted elsevier preprint march algebraic engineering object paradigm today software systems concurrent distributed interfaces encapsulate local states 
features core come called object paradigm may described comprising objects local state plus attributes methods classes classify objects inheritance hierarchy concurrent distributed operation 
basic important aspects include encapsulation distribution state overloading overwriting methods attributes including polymorphism dynamic binding nondeterminism closely related concurrency distribution reactivity message passing called deferred classes 
basic argued implicit proof orientation programme 
items constitute older notion machine supports data abstraction 
object paradigm adds support code reuse inheritance anity concurrency 
hidden algebraic engineering described body pays particular attention object paradigm 
emphasize results apply ordinary programs components regarded machines 
raises dicult challenges theory practice 
better understand situation useful distinguish designing coding verifying proving properties software systems 
literature addresses code veri cation exceedingly dicult practice 
empirical studies shown little cost software arises coding errors cost correcting programs comes design requirements errors 
important programs written obscure obsolete languages complex ugly semantics poorly documented large lines usually enormous ort verify rarely worth ort 
call area semantic swamp recommend avoided 
additional problem programs everyday evolving context evolving context includes computer hardware operating systems tax laws user requirements 
ort verifying yesterday version largely wasted small code modi cations require large proof modi cations proof discontinuous function truth 
suggests better focus design speci cation veri cation 
dicult properties people really want security deadlock freedom liveness ease ease maintenance complex may involve subtle interactions remote parts system 
formal semantics contribute solving problems 
known ort programming goes debugging maintaining improving updating programs 
done ease processes enormous economic potential 
step direction encapsulate data representations means actual data invisible provide access set operations retrieve modify hidden data structure 
implementing code changed having ect code uses 
contrary client code relies properties representation extremely hard track consequences modifying data structure say changing doubly linked list array client code may scattered program clear identifying marks may unexpected ways 
helps explain called year problem dicult 
encapsulated data structure accompanying operations called data type 
crucial advance recognize operations associated data representations exactly insight advanced algebra mere sets algebras sets associated operations 
software engineering insight due david parnas algebra pioneered garrett birkho see 
turns abstraction isomorphism algebras representing data values numbers vectors important problems software engineering need general notion behavioral abstraction models considered abstractly exhibit behavior 
usual sorted algebra rich distinguish sorts data values sorts states need behavioral notion satisfaction developed section 
line general discussion software methodology want prove properties speci cations properties code 
important property speci cation re nes speci cation sense model code realizing second model rst 
methodologically corresponds verifying design line previous paragraph want verify behavioral properties behavioral re nements usually easier verifying corresponding code 
behavioral re nement general ordinary re nement enormous variety clever implementation techniques occur practice require extra generality contrast re nement called model methods corresponds reducing nondeterminism inadequate verifying real designs 
section describes techniques verifying behavioral re nements showing reducing nondeterminism special case notion re nement 
important item agenda provide ective support proving behavioral properties systems including re nement 
believe hidden algebra allows simpler proofs formalisms exploit algebraic structure discarded approaches 
hidden algebra developed object paradigm mind supports combinations functional logic object paradigms see section appendix 
key combining di erent paradigms combine underlying semantics appropriate level abstraction especially logica advocated 
note ordinary imperative programming special case hidden algebra objects correspond program variables applies traditional concurrent sequential programming hidden sorts specify classes order sorted algebra provides natural way handle inheritance addition supports partial functions non terminating systems various kinds subtype error de nition recovery coercions overwriting multiple representations expository simplicity treats hidden sorted algebra 
module system parameterized programming gives forms inheritance plus power higher order functional programming rst order setting facilitates proving programming 
object logic languages provide weak support modularization code reuse surprisingly hard practice agenda includes empirical studies show real software development projects involve false starts prototypes patches 
idealized view design sequence re nements useful way organize document project retrospectively 
particular traditional pre post condition techniques extensively illustrated executable algebraic text semantics imperative programs shows order sorted algebra rewriting add greatly ectiveness 
discusses polymorphism dynamic binding overwriting discusses errors coercions discusses partial functions 
powerful modularization techniques sketched appendix constraints inherent hidden algebra new kind logic programming obtained just adding existential quanti ers 
constitutes new item hidden agenda combining functional object logic concurrent constraint paradigms 
surprising arti cial exclude concurrency nondeterminism local states objects classes inheritance constraints streams existential queries occur naturally hidden world 
examples obj express theories proofs style humans interesting high level obj boring computations 
course interesting automated certainly impossible general 
logical foundations approach summarized appendix assume familiarity basic sorted algebra obj 
relevant background appears places 
try avoid category theory cases section greater elegance power compelling resist 
section introduces hidden algebra section giving necessary suf cient conditions speci cation consistent section discussing nondeterminism 
hidden coinduction introduced section sections discuss relation labeled transition systems bisimulation generalization multiple hidden arguments 
coinduction applied correctness re nements implementations section section gives directions research 
part survey overlap papers inevitable especially section contains basic de nitions 
proofs appear short section new especially theorem proposition fundamental justi cation coinduction theorem section relationships state approaches sections 
appendix overview logical relations provide foundation theorem proving systems term rewriting obj appendix overview approach modularity combining multiple paradigms 
little literature adequate survey literature concurrency consume volumes literature object paradigm surely take logic functional constraint paradigms 
worse literatures growing fast individual keep 
situation remains unreasonable con ne attention mathematically rigorous 
consequently subsection considers research especially closely related uenced way 
modest task impossible beg sins omission request suciently annoyed send suggestions improvement 
unfortunately prior closely related beg reader overabundance self citation 
algebra 
algebra certainly part mathematics computing science contributions including simpli cation notation sorted algebra initial algebra semantics syntax data types order sorted algebra giving systematic approach subtypes allows specifying partial recursive functions partially de ned functions error de nition recovery coercions multiple representations tradition hidden sorted algebra hidden algebra short 
hidden approach di ers earlier approaches ways addresses concurrency nondeterminism xed universe data values behavioral satisfaction 
founding hidden builds earlier algebraic data types natural extension prior goguen meseguer called machines 
hidden algebra generalizes automaton theory long tradition computing science particularly mention pioneering eilenberg wright took categorical approach tree automata generalization state transition automata tree automata generalize strong traditional transition systems 
rst systematic exposition hidden algebra new ideas including approach concurrency 
problem combining hidden ordered sorts rst solved di erent solutions appropriate purposes 
order sorted hidden algebra developed shows handle overwriting methods special kind signature 
development coinduction began context correctness proofs re nements objects machines 
hidden approach uses behavioral satisfaction get algebraic treatment state abstracts away implementation details 
elegant idea introduced reichel context partial algebras see 
behavioral equivalence states generalization bisimulation appeared authors cris calude pointing early treatment behavioral equivalence moore 
rst recognized connection tree automata software engineering 
reichel notion behavioral theory developed various directions mainly partial algebras see survey 
order get powerful module type system parameterized programming necessary signatures morphisms models axioms form called institution 
call half institutions claims get full institution object paradigm behavioral satisfaction 
fail distinguish xed data values hidden states hidden signature maps vertical structure re nements hidden signature morphisms horizontal structure module composition 
explain kinds signature arrows appropriate di erent purposes show form institution morphisms fact see section 
rst ective algebraic proof technique behavioral properties context induction introduced developed bidoit 
research programme similar ways approach concerned semantics proofs context induction awkward apply practice see discussion diculties 
hidden coinduction eliminates awkwardness context induction 
reichel seminal behavioral satisfaction part motivated insight unify initial nal semantics 
behavioral nal semantics rst advocated montanari wand early contribution 
finality treating states places including elegant reichel algebraic semantics object paradigm 
sophisticated results computability initial nal algebras appear initiality results compatible hidden paradigm proved 
ood behavioral abstraction validates intuitions expressed long ago guttag 
wish emphasize hidden algebra embrace nal semantics takes loose approach modulo protection algebra data values 
hidden approach rst address concurrency ective proof techniques systems objects algebraic tradition certainly mention rewriting logic algebraic speci cation tradition builds obj 
elegant approach views actions inference steps rewriting logic essentially equational logic law symmetry 
strong point approach ability model di erent approaches concurrency natural simple ways 
treatment objects messages associative commutative ac cation operation raise substantial diculties proving properties large systems due computational complexity ac uni cation concrete level representation 
behavioral speci cation applied rewriting logic sophisticated semantic de nition behavioral satisfaction rewriting logic models conditional rules arises general institutional approach behavior developed 
called process algebras called concurrency calculi ccs acp csp typically systems equations 
equations di erently process algebra hidden algebra 
process algebra variables range processes algebraic operators combine processes 
consequently process algebra equations describe relations ways combining processes relations methods attributes hidden algebra 
emphases research groups di er csp group emphasized set theoretic semantics processes streams actions ccs group concerned equational axiomatization decision procedures acp group concerned equations rewrite rules di erent motivations intuitions led di erent equations 
noted abramsky babel formalisms suggests current methodologies concurrency constrained key ideas missing 
lack consensus suitable set equations discouraging suggesting laws concurrency may status laws nature physics despite occasional claims contrary 
process algebras treat special case disallows parameterized methods attributes explicit role data types 
course process algebra generalized fact hidden algebra seen generalization admits powerful algebraic proof methods opposed tedious search vast spaces 
refers metaphor rich soup objects messages contrast hidden algebra messages appear terms get blended objects 
means independent underlying logic applied order sorted algebra rewriting logic institutions 
technical term de ned section corresponds strong mentioned 
example integer stack push method represented nitely transitions integer single operation parameterized integers 
process algebras labeled transition systems see correspond special case hidden algebra structure proofs easier discarded explicit place data types attribute values 
transition systems generalized avoid limitations shown section additional structure represent attribute values 
despite limitations inspired deep insights mainstream concurrency research 
abramsky introduces interaction categories elegant categorical approach processes having similarities approach concurrency deserve exploration 
approach composite systems concurrent interacting objects discussed 
approaches set theoretic semantic models csp lead dicult proofs involving properties sets axioms set theory denotational semantic models better respect abramsky remarks really successful functional languages surprising denotational semantics strongly calculus 
ambitious veri er settheoretic denotational semantic de nitions lead dangerous semantic swamp mouth shark distinguished tradition research coalgebra 
thread tradition seeks show existence nal transition systems give rise notion bisimulation give semantics process algebras 
thread views coalgebra variation universal algebra applies functional programming automaton theory object paradigm 
interesting development combines algebra coalgebra describe denotational operational semantics 
reichel rst apply coalgebra explicitly object paradigm basic construction seen making precise assertion hidden algebra extends coalgebra generalized constants 
precisely extension allows treatment nondeterminism advocated 
fact dicult treat nondeterminism purely coalgebraic approach obvious move power objects de ning functor compromises ectiveness equational reasoning 
hidden algebra related elegant category theoretic approach constraint logic programming diaconescu xed data universe hidden algebra corresponds signature model builtins course algebraic laws shown hold rule set incomplete approach necessarily limited 
operations constitute extension logical signature hidden algebras di er constraint logic models builtins protected diaconescu constraint logic allows confusion technical sense footnote data elements disequalities may hold disequalities important real examples example alternating bit protocol correct bits distinct 
research described supported part fujitsu laboratories cec esprit bra working groups information systems correctness reusability compass comprehensive algebraic approach system speci cation development contract management information technology promotion agency ipa japan part industrial science technology frontier program new models software architectures sponsored new energy industrial technology development organization cafeobj project management ipa part advanced software technology programme 
members declarative group oxford ideas comments support project described possible addition members include corina diaconescu lutz hamel hendrik akira mori simone james worrell 
especially wish acknowledge contributions diaconescu author basic hidden papers helpful comments drafts jos meseguer author important pre hidden papers helpful comments draft 
grateful ro su nding bugs uwe wolter useful comments 
dedication behalf authors joseph goguen dedication prof john rhodes honor birthday graduate student berkeley pleasure classes john working krohn rhodes research institute 
algebraic engineering conference aizu pleasure giving opening lecture warm act john rst talk pleasure dedicating hoping new generations students bene ective style teaching 
hidden algebra important distinction data values attributes data internal states objects immutable platonic character mutable aristotelian character 
hidden algebra embodies fundamental distinction assigning visible sorts hidden sorts 
states hidden observed indirectly performing experiments technically contexts terms return visible data values 
visible hidden sorts respectively treated subsections contain basic concepts hidden algebra 
visible data values order components system communicate representations data share motivates xing single algebra data values shared 
practice multiple representations data translations assumption easily relaxed cover cases 
de nition xed data algebra signature sort set non empty interpreted convenience assume call visible data universe call sorts visible sorts 
condition just says xed notation names data elements quite usual data types attributes numerals names natural numbers 
note algebra need term model initial model 
de nition semantic avor veri ers need speci cations data values support ecient proofs especially convenient initial algebra semantics supports proofs induction needed lemmas software proofs 
example obj speci cation natural numbers examples precisely junk half initiality supports induction reachable algebras see de nition confusion half supports disequality proofs important practice 
obj nat sort nat op nat op nat nat prec 
op bool var nat eq eq eq eq endo nat name module nat name sort natural numbers 
keyword pair obj endo indicates initial algebra semantics 
characters indicate argument goes successor operator pre syntax inequality operator syntax 
rest obj syntax fairly self evident obj see 
convenient examples obj xed module data data values gives signature axioms says data just natural numbers adequate noting nat modules obj imports booleans default 
obj data pr nat endo cumulative signature data course de nition requires contains elements data algebra constant symbols practical harm relax assumption obj examples 
hidden algebra simply assumes xed data universe requirement nite presentation theory nat simply take elements initial term algebra 
general expects data types values computable encouraging recall computable algebra nitely speci ed initial algebra semantics 
potential data algebras computable real numbers captured initial algebra semantics uncountable number constants equations 
loose semantics explicitly giving properties needed noting algebra satisfying properties chosen xed data algebra 
hidden signatures hidden algebras de nition hidden signature pair set hidden sorts disjoint sorted signature lies hidden sort occurs may abbreviate just 
contains hidden sort called method attribute called generalized hidden constant 
hidden theory speci cation triple hidden signature set equations include equations may write short 
condition expresses data encapsulation hidden signature add new operations data items 
condition says methods attributes act single states objects relaxed section 
note operation hidden signature data operation method attribute generalized hidden constant 
generalized hidden constants pick initial states machines speci ed quite di erent methods attributes refer generalized constants emphasize distinction suggest really represent constants 
equations data equations allowed hidden speci cations equation needed lemma proved asserted separately included speci cation 
de nition allows calling parameters attributes methods generalized constants take strong just additional visible arguments 
de nition allows multiple hidden sorts useful jargon object paradigm complex attributes class valued attributes 
help clarify de nition 
uses obj syntax theories keyword pair th pr data indicates loose semantics protecting data explained detail little 
example obj theory speci es cell holds single natural number th sort state pr data op init state op getx state nat op putx nat state state var state var nat eq getx putx name module state name class objects de nes just cells hold natural number models ways implement cells example named called program variables 
constant init seen initial state attribute getx returns value cell method putx places number cell getx pre syntax 
add equation eq getx init set initial value attribute course initial value number left unde ned just giving equation see discussion section 
signature subsignature model algebra restriction provides functions methods attributes behaves satis es equations 
elements models possible states objects cells 
motivates de nition hidden signature hidden algebra sorted algebra aj hidden homomorphism sorted homomorphism identity visible sorts 
notice implies hidden algebra ground terms variables decide checking evaluating terms checking unique homomorphism 
de ne behavioral satisfaction equation intuitively terms look experiment consisting methods followed observation attribute 
formally experiment context term visible sort having free variable hidden sort de nition hidden signature hidden sort context sort visible sorted term having single occurrence new variable symbol sort context appropriate term sort matches write result substituting context denote indexed set contexts hidden variable hidden algebra behaviorally satis es equation appropriate context satis es equation write may drop subscript 
similarly behaviorally satis es conditional equation form assignment appropriate contexts appropriate contexts unconditional equations write model hidden theory hidden algebra behaviorally satis es equation model called algebra algebra write write implies hidden algebra hidden algebra reachable unique homomorphism initial term algebra surjective 
hidden algebra kind loose behavioral semantics xed data algebra contrary competition hidden semantics initial algebra semantics di erent purposes 
example contexts hidden theory example getx getx putx getx putx putx nite number contexts getx attribute 
give models theory way implementing cell denotes unique homomorphic extension 
example simplest model hidden algebra having natural number state state getx putx value init say illustrates nondeterminism discussed section 
complex implementation keeps complete histories interactions action putx concatenate front list numbers 
state lists natural numbers init empty list getx head getx say putx concatenation operation 
note especially isomorphic nite number non isomorphic variants 
visible equations di erence ordinary satisfaction behavioral satisfaction 
concepts di erent hidden equations equations terms hidden sort 
example nm nat state putx putx putx strictly satis ed model satis ed history model behaviorally satis ed models 
shows behavioral satisfaction appropriate computing science applications 
coinduction prove model satis es equation behaviorally 
simplest ways reason behavioral satisfaction justi ed proposition proving ordinary rules equational deduction valid including substituting behavioral equation course symmetry transitivity visible equations proofs 
equational deduction refers form explicit universal quanti ers introduced goguen meseguer diculties arise models having empty hidden carriers 
result easy prove useful 
example want prove nm nat state getx putx putx theory give obj red command asks term rewriting return normal form nds red getx putx putx obj treats variables constants gives correct result true see appendix powerful reduction coinduction needed prove equation nm nat state putx putx putx discussed section 
consistency unfortunately easy write theories models 
example add equation eq putx putx theory example prove contradicts data protection de nition 
motivates de nition hidden theory consistent model non empty carriers 
techniques guaranteeing consistent speci cations summarized theorem uses concepts de nition term local visible operations constants variables 
denote set local ground terms sort equation local left right sides local conditions terms set equations local constraint equation terms top operations non trivial local equation constraint 
constraints constrain values unde ned terms theory discussed detail section shows relates nondeterminism 
de nition set equations complete implies terms theorem equations hidden theory complete church rosser local rewrite rules theory consistent 
proof may 
examples shown consistent result 
sucient condition church rosser prop unfamiliar goguen meseguer explicit quanti er approach may wish note gets proved equation state true models including empty hidden carrier implies equation hidden carrier non empty 
erty equations nonoverlapping speci cation shown consistent ignoring nonlocal equations consistency constraints considered separately determining set constraints solution arbitrarily dicult unsolvable 
example hidden theory arrays proved consistent theorem th arr sort arr pr data op nil arr op put nat nat arr arr op arr nat nat var nat var arr eq nil cq put cq put nil empty array value index put puts hidden equations 
nondeterminism theories distributed programming need nondeterminism unrealistic assume nodes network know nodes going doing 
formalism intended useful modern software engineering treat nondeterminism simple natural way 
concurrency calculi treat nondeterminism complex unnatural ways sharp ongoing debates advocates various approaches obvious resolution sight nondeterminism nondeterminism inherent hidden paradigm arises attribute values determined speci cation 
understand may help view models possible worlds possible combination nondeterministic choices appears di erent world 
mean value occur world contrary conditional equations left sides may overlap conditions disjoint 
di erent kinds nondeterminism standard approaches major cause babel mutually inconsistent laws concurrency mentioned section 
model deterministic attributes take value time 
hidden speci cation may multiple models attributes completely di erent values 
de nition hidden theory hidden ground term de ned context appropriate sort unde ned 
ground terms de ned 
note unde ned simply means term constrained equal particular value quite di erent notion unde nedness partial functions 
unde nedness property holds level hidden speci cations hidden model de ne terms particular way 
term unde ned context term equal data value hidden model 
fact hidden theory visible term de ned visible ground terms de ned 
hidden generalized constants 
having unde ned ground terms corresponds guttag notion sucient completeness 
require condition claim unde ned terms useful system development run time 
having explicitly say unde ned simply de ne value consistent theory possible combinations values occur models theory 
hidden algebra avoids disputes nondeterminism simply delivers certain range implementation freedom form collection possible worlds 
example consider simple theory hidden sort natural number valued attribute hidden constant equations usual data naturals booleans th ex sort pr data op op nat exactly unde ned visible ground term 
theory calls nondeterministic choice natural number behavioral equivalence de ned section exactly reachable algebra choice natural number attribute 
nitely non reachable models worlds may arbitrarily unnamed unreachable junk objects natural number attribute 
add constraint eq nondeterminism restricted behavioral equivalence just reachable models world attribute object value 
unreachable models contain objects attribute value 
things get interesting methods attributes 
elements reachable element hidden algebra states arise applying methods element connected component elements consists states single object 
obligatory test drive new speci cation technology range stacks approaches done stacks convenient minimal benchmark comparing approaches 
rst specify nondeterministic stack 
limited sorted algebra handling errors weak better order sorted algebra 
example operation push nondeterministically puts new natural number top stack 
single operation corresponds countably nondeterministic transitions traditional state transition system 
th sort stack pr data op empty stack op push stack stack op top stack nat op pop stack stack var stack eq pop push eq pop empty empty terms top push empty unde ned unconstrained nondeterministic take value 
model speci cation deterministic represents possible way resolving nondeterminism 
behavioral satisfaction rst equation implies number pushed stack stays popped example follows eq top pop push top eq top pop pop push push top true top push pop top new number pushed may di erent old 
term top empty unde ned take value 
course value equation eq top empty constrain push just values adding equation example eq top push possible di erent nondeterministic push methods subject di erent constraints 
hidden semantics di ers sharply initial semantics terms top empty appear new elements sort nat di ers pure loose semantics terms new elements old data values 
hidden algebraic nondeterminism concurrent constraint programming paradigm speci cation describes possible states object isolation states occur determined objects interactions expressed constraints 
example speci cations array pointer describe possible states separately put implement stack states longer reachable hidden algebra naturally nondeterministic see suited nonterminating example concurrent reactive systems 
example hidden version traditional stack theory non unary deterministic push th stack sort stack pr data op empty stack details may context impossible array containing occur 
op push nat stack stack op top stack nat op pop stack stack var stack var nat eq top push eq pop empty empty eq pop push top empty unde ned ground term equality 
unde ned values obstruct initial hidden algebras shown theorem 
recalling denotes set local ground terms sort note algebra induces hidden algebra structure denote lm interpreting methods term building operations interpreting attribute lm hm suitable hm unique homomorphism similarly restricting hm local terms gives unique hidden homomorphism lm denote proofs results may 
proposition denote set local contexts sort involving variable hidden sort 
hidden algebra behaviorally satis es hidden equation satis es visible local context 
proposition hidden signature hidden homomorphism unconditional equation algebra equation lm hidden theory initial model initial model behaviorally satis es equation behaviorally satis ed hidden model theory 
ground equation reachable lm hidden homomorphism lm ln theorem hidden theory initial model denoted consistent 
system development consists part progressively reducing implementation freedom may involve reducing nondeterminism things 
reducing nondeterminism consistent software engineering practice operations program deterministic development stage programs may satisfy speci cation 
hidden nondeterminism appropriate re nement forms usually process algebra 
nondeterminism remain right implementation level consistent value may returned 
example set constraints may resolved run time di erent ways di erent times 
notion nondeterminism useful implementation freedom runtime choice 
hidden satisfaction logic paradigm easy de ne hidden satisfaction connectives rst order logic modal logics 
important existential quanti cation provides existential queries basis combined logic object paradigm de nition existential query sentence form behaviorally satis ed algebra assignment appropriate contexts combined logic object paradigm uses hidden herbrand theorem reduce reasoning arbitrary models object oriented databases reasoning single herbrand universe term algebra ordinary logic programming see precise statement corresponding result equational logic programming 
result theorem consistent hidden theory initial algebra behaviorally satis es query algebra behaviorally satis es real software development processes involve including constantly evolving requirements resulting need constantly evolve software 
choose canonical term algebra narrowing solve queries illustrated course ecient methods special cases 
applications paradigm may involve queries object oriented database resulting object just retrieved created 
example describe holiday package software package wants get tickets reservations executable code result query section extends horn clause logic equality applying construction reduces logic hidden equational logic see extending diaconescu 
gives paradigm uni es object paradigm equational logic programming traditional horn clause logic programming 
behavior hidden coinduction induction standard technique proving properties initial generally reachable algebras theory 
principles induction justi ed fact initial algebra proper subalgebras 
see nal terminal algebras play analogous role justifying reasoning behavioral properties hidden coinduction 
rst need de nition hidden signature hidden subsignature hidden algebra behavioral equivalence denoted de ned follows sort denotes function interpreting context operation de ned denotes free extension call just behavioral equivalence denote 
hidden congruence hidden algebra congruence identity visible sorts course may wish re ne constraints tickets printed credit card 
call hidden congruence just hidden congruence 
hard demonstrate fact hidden signature hidden subsignature hidden congruence hidden congruence implies behavioral equivalence hidden congruence 
key property theorem hidden signature hidden subsignature hidden algebra behavioral equivalence largest behavioral congruence result foundation coinduction 
probably common case generalization smaller useful example verifying re nements 
simple proof theorem called comma categories section generalizes result multiple hidden arguments 
coinduction theorem implies hidden congruence behaviorally equivalent 
justi es variety techniques proving behavioral equivalence see techniques varieties coinduction 
context relation may called candidate relation proved hidden congruence 
example model theory theory example state de ne getx getx data values 
equation gives implies putx putx course getx getx hidden congruence show state putx putx putx showing state getx putx putx getx putx elegant formulation appeared conversation malcolm rolf special case 
follows ordinary equational reasoning equation behaviorally satis ed algebra easy proof mechanically obj uses ordinary equational reasoning 
set proof opening adding necessary assumptions represents relation op state state bool var state eq getx getx ops state ops nat close new constants introduced stand universally quanti ed variables theorem constants 
line indicates module opened retention sense material added retained 
shows hidden congruence open eq getx getx red putx putx true close show algebras behaviorally satisfy equation red putx putx putx code runs obj reduction gives true 
proof simple possible atypical lemmas data algebra required 
simple example call hidden coinduction explained 
give results simplify proofs 
suppose 
letters 
intended suggest generators called constructors destructors called selectors respectively 
example 
contains getx contains putx 
corollary 

algebra preserved 
generally 

preserved 
information order sorted constructors selectors appears 
proof show general result 
fact 
hidden 
congruence contains behavioral equivalence 

preserved hidden 
congruence desired result follows theorem 
veri ers want little possible 
want bother want overlap 
want 

denotes disjoint union operations ordinary union sorts 
object paradigm natural 
contain attributes methods give simple syntactic de nition 
proposition 

consists attributes algebra de ne ar 

aw arity 

preserved 
behavioral equivalence 
proof de nition equivalent de nition 
operations 
visible 
shows de ned example really 
furthermore consists methods 
attributes equations satisfy certain common property 
automatically preserved de nition 
operations 
visible hidden set equations 
complete 

fxg prove hidden sort 
wh dw dw straightforward corollary proposition proposition 
operations 
visible hidden hidden algebra 
complete 
preserved 
behavioral equivalence 
special case equations involving form hidden sort 

fxg easy see 
complete 
result suggested diaconescu 
summarize hidden coinduction proof technique de ne relation show hidden congruence show behavioral equivalence terms showing congruent 
concepts results subsection generalized 
way de ne congruence relation coinductive proof dramatic ect proof applies models 
relation de ned inductively constructors model congruence de ned subalgebra generated constructors subalgebra reachable constructors 
speci cally proof candidate relation congruence proceed induction constructors case proved relation congruence subalgebra usually don care behavioral equation satis ed unreachable states states occur machine run 
restriction hidden algebra reachable models studied 
coinduction example parallel connection see section cells kind de ned speci cation example speci ed follows th xy sort state pr data op init state ops getx gety state nat ops putx nat state state var state vars nat eq getx putx eq gety eq getx getx eq gety putx gety operations cells tagged respectively 
note values initial state init 
equations say operations cells interfere intuitively stronger noninterference assertion putx putx hold 
equation strictly hold models xy hold behaviorally proved coin duction 

contain getx gety contain putx 
verify equation proposition corollary follows xy op state state bool var state eq getx getx gety gety ops state ops nat close show congruence open eq getx getx eq gety gety red putx putx true red true close check equation red putx putx reduction yields true equational behaviorally satis ed models xy 
course example chosen expository simplicity coinduction complex proofs including correctness sophisticated optimizing compiler distributed concurrent truth maintenance protocol 
number examples web www cse ucsd edu groups tatami 
finality advocate nal algebra semantics semantics hidden theories loose behavioral semantics standard interpretation data 
practice best implementations initial nal 
nal hidden algebras important theoretical development particular play key role justifying hidden coinduction 
construction nal algebra follows help intuition grasp going 
hidden signature generalized hidden constants recall hidden operations hidden arguments hidden carriers magical formula product sets functions contexts data values appropriate sort 
elements thought states represented functions contexts returning data values resulting evaluating state context kind continuation 
appears way interprets attributes hw attribute dw de ne function contexts data values applying context gives data value resulting experiment 
methods interpreted similarly hw method dw element de ne slight abuse notation state result get looking context result gives context 
theorem hidden signature generalized hidden constants nal hidden algebra 
proof preceeding paragraph shows hidden algebra 
hidden algebra hidden homomorphism family mappings sends 
straightforward check unique 
hidden algebra unique homomorphism takes hidden state observable behaviors thought evaluating attributes states reached state 
example signature example unique homo morphism algebra maps state state set assignments boolean values contexts getx getx putx getx putx getx putx putx getx putx putx getx putx putx example class nite streams numbers speci ed follows th stream sort stream pr data op hd stream nat op tl stream stream hd gives rst value stream tl gives remainder stream 
nal algebra theory set nite lists numbers unique homomorphism stream algebra nal algebra maps nite list numbers hd hd tl hd tl tl show theorem generalizes give nal models consistent theories 
de nedness exactly allows constants interpreted nal model 
need de nition hidden signature denote hidden constants removed 
algebra denote viewed algebra 
theorem equation hidden theory variable hidden sort nal model denoted consistent 
proof suppose consistent algebra unique hidden homomorphism nal algebra hidden algebra interpreting generalized constants dw note hidden homomorphism 
fa image factor composition surjective fa inclusive fa 

surjective lemma implies fa greatest subalgebra behaviorally satis es fact union images fa hidden algebra equation variables variable hidden sort assignment assignment fa algebra noted fa subalgebra behaviorally satis es contained shows domain lies nal 
concludes direction proof 
converse proof theorem 
proposition surjective hidden homomorphism equation implies 
hidden homomorphism 

proof form 
surjective second assertion means second assertion second assertion de nition 
equivalent 
equivalent 
identity visible sorts homomorphism turn equivalent 
de nition 

dual construction initial algebra theory quotient congruence de ned equations nal hidden algebra theory greatest subalgebra satis es equations unique homomorphism nal algebra thought mapping state observations 
get function arbitrary algebra forgetting certain hidden elements named hidden constants 
motivates proposition elements hidden algebra behaviorally equivalent map element unique homomorphism nal algebra 
proof follows straightforwardly de nition behavioral equivalence magic formula de nes words behavioral equivalence algebra kernel unique homomorphism nal algebra 
quotient equivalence exists model 
issue categorical treatment 
gives algebra de ne behavioral satisfaction 
constructions initial nal machines similar rst literature 
bisimulation transition systems section considers relationship hidden theories certain classes labeled deterministic transition systems show models hidden theories correspond labeled transition systems additional structure handle attributes bisimulation proofs coinduction proofs 
traditional state transition systems process algebras consider systems single global state just kind data correspond specializing hidden paradigm just hidden sort say just visible sort say may write capture traditional notion discard algebraic structure unary operations allowed replace operation hw collection operations dw visible sorted argument 
possible nally forget algebraic structure means structural facts pop push expressed play useful role veri cation 
hidden algebra isn enrich traditional transition system additional structure attributes 
de nition signature hidden signature hidden constants just sorts hidden visible operation argument argument hidden signature transition system set states state transition function output function 
morphism transition systems 
function 
traditional transition systems visible essentially sequence transitions called trace precisely trace sequence transition labels 
attributes explicit considered inferable traces 
example cookie vending transition system number cookies follows contains constants 
left machine calculated number give cookie transitions trace 
de nition transition system di ers tradition having output function gives attribute values states 
de nition di ers transitions total deterministic state transition leads precisely new state 
problem argued hidden nondeterminism powerful elegant standard approaches idea single nondeterministic machine collection possible deterministic machines 
signature algebra get transition system na na unique homomorphism nal algebra hidden homomorphism gives morphism transition systems na 
na 
transition system gives rise hidden algebra methods de ne attributes de ne 
straightforward proposition de nes correspondence hidden algebras transition systems 
signature nal transition system ft denotes identity function 
unique transition morphism nal transition system finality ft gives rise traditional bisimilarity relation deterministic transition systems way gives rise behavioral equivalence relation hidden algebras de nition signature bisimulation trans system relation implies rst condition says bisimulations coherent respect observations second standard bisimulation condition deterministic transition systems 
example obtained signature example converting parameterized operation putx nite family operations putx 
transition system putx de ned recursively contexts follows getx putx getx getx bisimulation 
note hidden algebra corresponding transition system getx corresponds attribute getx state example shows states model behaviorally equivalent getx values relation example corresponds bisimulation proof hidden congruence shows bisimulation 
conditions de nition state bisimulation congruence particular rst condition ensures extend bisimulation sorted relation identity visible sorts 
means bisimulation transition system gives rise hidden congruence corresponding hidden algebra conversely hidden congruence hidden algebra gives rise bisimulation corresponding transition system 
results hidden congruences translate correspondence give results bisimulations 
standard terminology states called bisimilar related bisimulation words bisimilarity maximal bisimulation just behavioral equivalence maximal hidden congruence 
states transition system bisimilar behaviorally equivalent system viewed hidden algebra 
bisimilarity arises morphisms nal transition system way behavioral equivalence arises homomorphisms nal algebra cf 
proposition proposition signature transition system states bisimilar unique morphism nal transition system nal algebra maps states element 
words transition system states bisimilar 
way looking coinduction states transition system bisimilar states behaviorally equivalent transition system viewed algebra hidden signature cf 
theorem 
hidden algebras nondeterministic transition systems related adjunction giving best hidden algebra behaviour nondeterministic system vice versa 
alternative approach nondeterministic transition systems transition systems returns sets states method interpreted action gives nondeterministic choice result states possibly result returns empty set 
transition systems nondeterministic systems think returning singleton set hidden algebra gives nondeterministic transition system 
construct hidden algebra nondeterministic transition system note hidden contexts sequences methods form transition system takes context method returns singleton set nondeterministic transition system construct hidden algebra carrier set set functions hidden contexts preserve transitions set functions contexts methods 
algebra interprets method mapping function function 
hidden contexts transition preserving functions contexts correspond deterministic paths nondeterministic transition system hidden algebra constructed thought largest deterministic subsystem 
unfortunately veri cation general dicult hidden algebra setting uniformities expressed equations lack lost set theoretic representation 
summarize main points hidden algebra generalizes traditional transition systems signatures capturing additional algebraic structure methods attributes states bisimulation special case hidden coinduction extra structure hidden algebra veri cation easier hidden nondeterminism graceful veri cation friendly traditional transition systems 
re nement hidden coinduction applied correctness proofs re nements section summarize main de nitions results demonstrate utility coinduction purpose 
simplest view re nement assumes speci cation implementation asks generalization behavioral satisfaction signi cant allows treat subtle implementation tricks act correct data structure overwriting machine interpretation 
unfortunately trying prove directly dumps semantic swamp described 
rise speci cation actual model may object maneuver isolates actual code de ne operations preventing verifying code 
contend isolation advantage 
empirical studies show little proof far easier advantage proof apply model satis es prove semantic terms means satisfying satis es signi cantly means hidden coinduction proof 
sophisticated view re nement allows concrete implementation rename identify sorts operations giving rise hidden signature map concrete signature de nition hidden signature map 
signature morphism preserves hidden sorts identity 
hidden signature map re nement algebra denotes viewed algebra 
shown re nement visible consequences speci cation hold concrete speci cation proposition hidden signature map 
re nement visible context equation denotes equation 
consequences corollary justify applying hidden coinduction proving correctness re nements see details examples 
correctness proofs re nements involve showing concrete speci cation desired behaviour generally concrete equations 
asked approach re nement relates called model approaches vdm follow hoare de ning re nement relationship models concrete mapping variables concrete model objects represent 
believe complex structure concrete models set theoretic nature model correctness proofs unnecessarily dicult 
approach uses theories concrete levels proofs axiomatic setting designed facilitate reasoning 
particular notion allows stepwise re nement choosing concrete representations variables choice corre diculty software development lies code diculty lies speci cation design approach addresses directly assuming heavy burden messy programming language semantics 
course algebraic semantics verify code wish extensively illustrated 
maneuver achieves signi cant separation concerns 
sponds xing model engineering practice delay heavy commitment long possible 
verifying correctness subtle representation changes eased behavioral satisfaction 
implementation correct model concrete theory verifying easier showing satis es speci cation structures closer 
surprising fact mappings go opposite directions speci cations models explained level theory institutions demonstrating natural duality model notions re nement 
examples re nement give example illustrating notion re nement encompasses nondeterminism reduction model approaches see discussion section comparison model approaches re nement see 
show cell theory xy implemented enrichment arr theory nite arrays means model array yields independent cells 
initial values cells determined initial values array determined re nement involves reduction nondeterminism re nement data structure 
th pr arr sort arr state op nil init 
ops getx gety state nat ops putx nat state state var state var nat eq getx eq gety eq putx put 
eq put 
proof open op state op nat red getx putx red gety nondeterminism completely eliminated course easy nd examples hidden re nement nondeterminism reduced completely eliminated 
red getx getx red gety putx gety close phrase arr sort arr state renames sort arr module arr state op nil init renames operation nil init 
obj total rewrites proof 
equation theory implemented strictly satis ed concrete theory coinduction needed 
re nement proof require coinduction web www cse ucsd edu groups tatami coinduction proof parallel connection pointer array re nes stack theory appears uses total rewrites 
concurrency section brie summarizes concurrency hidden paradigm originating notion independent sum developing notion concurrent connection 
concurrency natural hidden paradigm order execution speci ed hidden theories particular concurrent execution legal possible 
recalling cell speci cation example specify cell replacing respectively 
concurrent connection speci cation hidden sort operations semantics interfere 
speci cation xy section exactly combining identifying sorts adding equations express noninterference 
special case general construction provides synchronizing objects 
main result far says certain universal characterization sense category theory th concurrent connection useful proving general laws 
result concurrent system deadlock free concurrent connection consistent deadlock means equations expressing synchronization models 
hidden coinduction powerful tool proving properties systems de ned concurrent connection communication protocols provide suitable examples 
non monadic operations ro su goguen show restriction monadic operations de nition necessary properties hidden algebra hold restriction dropped 
ro su goguen consider speci cations behavioral equivalence determined xed subsignature de nition 
section brie discuss consequences particularly respect behavioral speci cation nondeterministic behaviors 
de nition uses xed data universe section 
de nition behavioral speci cation tuple set hidden sorts disjoint sorted signatures lies set equations 
operations called behavioral 
behavioral speci cations hidden speci cations condition de nition xed hidden subsignature de ne behavioral equivalence cafeobj language 
contexts de ned behavioral speci cations de nition may contain non monadic operations behavioral equivalence de ned de nition equality contexts built operations 
de nition behavioral model algebra aj behaviorally satis es equation behaviorally satis es equation form assignment 
consequence hidden subsignature de ne behavioral equivalence equational deduction longer sound hidden coinduction method shown behavioral equivalence models behavioral speci cation 
see consider nondeterministic stacks example suppose subsignature contains operations top pop 
means states stack behaviorally equivalent tops equal tops pops equal 
model speci cation satisfy equation pop push empty empty contexts built top pop necessarily contexts containing push 
example equation top push pop push empty top push empty follows equation equational deduction behaviorally satis ed models behavioral speci cation 
just rst equation context top push context 
explicit counterexample model stack pairs consisting list numbers number 
de ne top rst element empty pop tail empty list empty push added start empty 
model left side equation right side 
terms discussion nondeterminism section model nondeterministically pushes value stack choosing larger numbers incrementing 
hidden model sense de nition precisely satisfy equation behavioral model sense de nition 
see ro su goguen de nitions allow strictly larger class models models allow form internal nondeterministic choice insofar need satisfy 
describe equation intuitively follows start empty stack nondeterministically push number stack call number gives right side 
pop number stack nondeterministically push number stack equation says number chosen relaxing de nition satisfaction equations de nition allows models free pick number push stack second time 
categorical hat trick antagonistic ignorant category theory skip subsection 
remaining readers nd brief elegant proof theorem 
sense proof generalizes known construction minimal machine quotient term algebra behavioral equivalence relation usually called nerode equivalence context 
hidden theory algebra unique homomorphism nal algebra factor surjective injective 
denote category factorizations surjective 
factorization nal proper quotients 
saying congruence de ned kernel maximal proved theorem case general case follows algebra algebra 
futures hidden agenda disclosed ambitious hope evidence feasible meet goals necessary groundwork done 
admit surprising hidden approach general ective regard proofs traditional process algebra transition system approaches really simpli cations introduced approaches proofs dicult 
surprising initially focused object paradigm avoid constraint logic concurrent paradigms nondeterminism nite data values 
module system parameterized programming see appendix obtain power higher order functional programming rst order setting 
course great deal done meet challenge set enormous orts established approaches put exploring applications developing mechanical support 
feel hidden algebra natural step evolution algebraic speci cation carrying forward intentions founders simple elegant way realities modern software 
initial algebra semantics remains appropriate data values hidden algebra allows handle systems objects machines concurrency constraints streams existential queries wish explore potent combination paradigms apply problems real practical value 
experimenting ways organize hidden proofs active websites html java javascript produced proof assistant cum website generator called provides direct support hidden coinduction automatically generates entire website proof including executable obj proof scores links background material explanation pages 
considering integrating decision methods special domains canonical term rewriting theories presburger arithmetic 
topic traceability important con complex new proofs explore hypermedia tool purpose 
generally talked hidden theories speci cation 
theories directly executed certain restrictions form equations implemented obj foops 
hidden theories directly small medium sized applications prototyping large applications 
worthwhile developing tool support 
restricts attention hidden sorted algebra 
extension hidden order sorted algebra really dicult trivial covers nonterminating systems partial recursive functions multiple inheritance error de nition handling coercion overwriting multiple representation details appear done 
wish explore connections approaches including coalgebra concurrent logic programming 
samson abramsky 
interaction categories communicating sequential processes 
william roscoe editor classical mind essays honour hoare pages 
prentice hall 
peter aczel mendler 
nal coalgebra theorem 
pitt editor category theory computer science 
springer 
lecture notes computer science volume 
pierre america jaco de bakker joost kok jan rutten 
denotational semantics parallel object oriented language 
information computation 
jan baeten weijland 
process algebra 
cambridge 
cambridge tracts theoretical computer science volume 
michael barr 
terminal coalgebras founded set theory 
theoretical computer science 
michel bidoit rolf martin wirsing 
behavioural speci cations 
science computer programming vol 

garrett birkho teh structure algebras 
proceedings cambridge society 
barry boehm 
software engineering economics 
prentice hall 
rod burstall 
programming modules typed functional programming 
proceedings international conference fifth generation computing systems 
rod burstall diaconescu 
hiding behaviour institutional approach 
william roscoe editor classical mind essays honour hoare pages 
prentice hall 
rod burstall joseph goguen 
putting theories speci cations 
raj reddy editor proceedings fifth international joint conference arti cial intelligence pages 
department computer science carnegie mellon university 
graham button wes sharrock 
implementing development methodologies 
marina joseph goguen editors requirements engineering social technical issues pages 
academic 
corina 
semantic study object paradigm 
transfer thesis programming research group oxford university 
corina 
coalgebra semantics hidden algebra parameterized objects inheritance 
th workshop algebraic development techniques june 
diaconescu 
logic horn clauses equational 
technical report prg tr programming research group university oxford 
written 
diaconescu 
category semantics equational constraint logic programming 
phd thesis programming research group oxford university 
diaconescu 
category equational logic semantics constraint programming 
haveraaen olaf owe ole johan dahl editors trends data type speci cation lecture notes computer science pages 
springer 
diaconescu 
foundations behavioural speci cation rewriting logic 
proceedings international workshop rewriting logic applications 
asilomar california september 
north holland 
diaconescu futatsugi 
cafeobj report volume amast series computing 
world scienti 
diaconescu joseph goguen petros 
logical support modularisation 
gerard huet gordon plotkin editors logical environments pages 
cambridge 
hartmut ehrig hans org kreowski bernd mahr peter 
algebraic implementation data types 
theoretical computer science 
hartmut ehrig fernando orejas felix michael 
behaviour module speci cations 
technical report technische universit berlin 
samuel eilenberg jesse wright 
automata general algebras 
information control 
marie claude gaudel igor 
context induction exercise 
technical report lri universit de paris sud 
ugo montanari 
observability concepts data speci cations 
proceedings conference mathematical foundations computer science 
springer verlag 
lecture notes computer science volume 
joseph goguen 
semantics computation 
ernest manes editor category theory applied computation control pages 
springer 
lecture notes computer science volume proceedings symposium university massachusetts amherst pages 
joseph goguen 
parameterized programming 
transactions software engineering se september 
joseph goguen 
suggestions organizing libraries software development 
steven editors proceedings international conference supercomputing systems pages 
ieee computer society 
supercomputing systems steven eds elsevier 
joseph goguen 
principles parameterized programming 
ted alan perlis editors software reusability volume concepts models pages 
addison wesley 
joseph goguen 
higher order functions considered unnecessary higherorder programming 
david turner editor research topics functional programming pages 
addison wesley 
joseph goguen 
formal approach software environments 
proceedings symposium formal approaches software environment technology 
joint system development tokyo japan january 
joseph goguen 
types theories 
george michael reed andrew william roscoe ralph wachter editors topology category theory computer science pages 
oxford 
proceedings conference held oxford june 
joseph goguen 
approach situated adaptive software 
proceedings international workshop new models software architecture pages 

joseph goguen 
requirements engineering reconciliation social technical issues 
marina joseph goguen editors requirements engineering social technical issues pages 
academic press 
joseph goguen 
parameterized programming software architecture 
proceedings reuse pages 
ieee computer society april 
invited keynote address 
joseph goguen 
stretching rst order equational logic proofs partiality subtypes retracts 
maria paola ulrich furbach editors proceedings workshop order theorem proving pages 
johannes kepler univ linz 
schloss austria october report revised version appear journal symbolic computation 
joseph goguen 
theorem proving algebra 
mit appear 
joseph goguen rod burstall 
cat system structured elaboration correct programs structured speci cations 
technical report csl sri computer science lab october 
joseph goguen rod burstall 
institutions model theory speci cation programming 
journal association computing machinery january 
joseph goguen diaconescu 
oxford survey order sorted algebra 
mathematical structures computer science 
joseph goguen diaconescu 
algebraic semantics object paradigm 
hartmut ehrig fernando orejas editors proceedings tenth workshop data types pages 
springer 
lecture notes computer science volume 
joseph goguen malcolm 
proof correctness object representation 
william roscoe editor classical mind essays honour hoare pages 
prentice hall 
joseph goguen malcolm 
situated adaptive software object paradigm 
proceedings international symposium new models software architecture pages 
information technology promotion agency 
joseph goguen malcolm 
algebraic semantics imperative programs 
mit 
joseph goguen malcolm 
hidden coinduction behavioral correctness proofs objects 
appear mathematical structures computer science 
joseph goguen malcolm 
higher order programming obj 
joseph goguen malcolm editors algebraic speci cation obj case studies 
appear 
joseph goguen malcolm tom kemp 
hidden herbrand theorem 
palamidessi glaser meinke editors principles declarative programming pages 
springer 
lecture notes computer science volume 
joseph goguen jos meseguer 
universal realization persistent interconnection implementation modules 
nielsen schmidt editors proceedings th international conference automata languages programming pages 
springer 
lecture notes computer science volume 
joseph goguen jos meseguer 
completeness sorted equational logic 
houston journal mathematics 
joseph goguen jos meseguer 
equality types generic modules logic programming 
douglas degroot gary lindstrom editors logic programming functions relations equations pages 
prentice hall 
earlier version appears journal logic programming volume number pages september 
joseph goguen jos meseguer 
order sorted algebra solves constructor selector multiple representation coercion problems 
proceedings second symposium logic computer science pages 
ieee computer society 
joseph goguen jos meseguer 
unifying functional object oriented relational programming logical semantics 
bruce shriver peter wegner editors research directions object oriented programming pages 
mit 
joseph goguen jos meseguer 
order sorted algebra equational deduction multiple inheritance overloading exceptions partial operations 
theoretical computer science 
drafts exists early 
joseph goguen jos meseguer david plaisted 
programming parameterized objects obj 
domenico ferrari mario joseph goguen editors theory practice software technology pages 
north holland 
joseph goguen kai lin akira mori ro su sato 
distributed cooperative formal methods tools 
michael lowry editor proceedings automated software engineering pages 
ieee 
joseph goguen akira mori 
semiotics distributed cooperative proving 
appear proceedings user interfaces theorem provers sophie antipolis france 
joseph goguen 
module composition system design object paradigm 
journal object oriented programming february 
joseph goguen james thatcher eric wagner 
initial algebra approach speci cation correctness implementation data types 
raymond yeh editor current trends programming methodology iv pages 
prentice hall 
joseph goguen james thatcher eric wagner jesse wright 
initial algebra semantics continuous algebras 
journal association computing machinery january 
joseph goguen tracz 
implementation oriented semantics module composition 
submitted publication 
joseph goguen timothy winkler jos meseguer futatsugi jouannaud 
introducing obj 
joseph goguen malcolm editors algebraic speci cation obj case studies 
appear 
technical report sri international 
robert goldblatt 
logics time computation nd edition csli lecture notes number center studies language information stanford university 
andrew gordon 
bisimilarity theory functional programming 
electronic notes theoretical computer science 
john guttag 
speci cation application programming data types 
phd thesis university toronto 
computer science department report csrg 
john guttag 
data types development data structures 
communications association computing machinery june 
hagino 
typed lambda calculus categorical type constructors 
pitt rydeheard editors category theory computer science pages 
lecture notes computer science volume 
springer 
lutz hamel 
behavioural veri cation implementation optimizing compiler obj 
phd thesis oxford university computing lab 
rolf 
context induction proof principle behavioural abstractions 
editor proceedings international symposium design implementation symbolic computation systems volume lecture notes computer science pages 
springer 
hoare 
proof correctness data representation 
acta informatica 
hoare 
communicating sequential processes 
prentice hall 
bart jacobs 
cofree coalgebras 
maurice nivat editor algebraic methodology software technology amast pages 
springer 
lecture notes computer science volume 
bart jacobs 
objects classes 
freitag cli jones lengauer 
schek editors object orientation parallelism persistence pages 
kluwer 
bart jacobs 
invariants bisimulations correctness coalgebraic re nements 
technical report csi computer science institute university nijmegen march 
malcolm 
data structures program transformation 
science computer programming 
malcolm 
behavioural equivalence bisimilarity minimal realisation 
haveraaen olaf owe ole johan dahl editors trends data type speci cations 
springer pages 
lecture notes computer science volume 
malcolm joseph goguen 
proving correctness re nement implementation 
technical monograph prg programming research group university oxford 
submitted publication 
jos meseguer 
conditional rewriting uni ed model concurrency 
theoretical computer science 
jos meseguer joseph goguen 
initiality induction computability 
maurice nivat john reynolds editors algebraic methods semantics pages 
cambridge 
robin milner joachim parrow david walker 
calculus mobile processes parts ii 
technical report ecs lfcs computer science department university edinburgh 
edward moore 
experiments sequential machines 
automata studies pages 
princeton 
lawrence moss jos meseguer joseph goguen 
final algebras algebras degrees unsolvability 
theoretical computer science 
original version march 
fernando orejas navarro ana anchez 
algebraic implementation data types survey concepts new compositionality results 
mathematical structures computer science 
david parnas 
information distribution aspects design methodology 
information processing 
proceedings ifip congress 
francisco pinheiro joseph goguen 
object oriented tool tracing requirements 
ieee software pages march 
special issue papers 
horst reichel 
behavioural equivalence unifying concept initial nal speci cations 
proceedings third hungarian computer science conference 

budapest 
horst reichel 
behavioural validity conditional equations data types 
contributions general algebra 
teubner 
proceedings vienna conference june 
horst reichel 
approach object semantics terminal algebras 
mathematical structures computer science 
ro su 
birkho axiomatizability result hidden algebra coalgebra 
proceedings workshop coalgebraic methods computer science cmcs lisbon portugal march volume electronic notes theoretical computer science 
elsevier science 
ro su joseph goguen 
hidden congruent deduction 
ricardo editors 
proceedings international workshop order theorem proving technische universit wien pages 
schloss vienna november 
appear lecture notes arti cial intelligence springer 
jan rutten 
universal coalgebra theory systems 
technical report cs cwi 
jan rutten daniele turi 
initial algebra nal coalgebra semantics concurrency 
jaco de bakker jan willem de roever rozenberg editors proc 
rex symposium decade concurrency pages 
springer 
lecture notes computer science volume 
donald sannella andrzej tarlecki 
formal development programs algebraic speci cations 
acta informatica 

design implementation evaluation declarative object oriented language 
phd thesis programming research group oxford university 
michael spivey 
understanding cambridge 
tracz 
parameterized programming 
proceedings second international workshop software reuse march 
italy 
daniele turi gordon plotkin 
mathematical operational semantics 
proceedings logic computer science ieee computer society press pages 
simone 
integrating static dynamic aspects speci cation open object distributed systems 
phd thesis oxford university computing laboratory 
van der 
history algebra 
springer 
mitchell wand 
final algebra semantics data type extension 
journal computer system sciences 
alfred north whitehead 
treatise universal algebra applications cambridge 
reprinted 
obj hidden algebraic proofs obj just kinds computation reduction rewrite rules general equational reasoning implemented reduce apply commands respectively 
combined obj declarative capabilities computations support surprisingly wide range proof techniques including reasoning loose initial hidden semantics discussed subsections 
easiest way explain works explicate various logical relations involved see 
discussion requires slightly sophisticated understanding algebra assumed body 
loose semantics loose semantics beautiful situation described birkho theorem equation true models provable equational deduction 
particular provable reduction true models 
converse hold reduction incomplete reduction tremendous advantage totally automatic 
important fairly simple problems require deductions 
applying non rewrite equation requires user control choose values variables precise point application get tedious 
obj allow sophisticated combinations application rewriting see section clear users prefer proofs pure rewriting possible 
introduce rst relation mean equation deduced equational reasoning explicitly write equational theory 
domain general equational reasoning note obj uses equality sign separate terms equation 
second explicitly means rewrites equations rewrite rules 
speci cation consists rewrite rules rewriting proofs sense notation equations transitive re exive closure third relation indicates step rewriting 
special properties church rosser termination needed relations consists rewrite rules domain meseguer rewriting logic 
practice obj obj general supports rewriting modulo associativity commutativity identity 
speci cations nearly consist rewrite rules far theoretical necessity 
relation transitive re exive symmetric closure goes rewriting logic 
fourth mean normal forms forms identical true rewrite term equational proof exists false don know holds 
note fail value non termination 
summarize implies implies normal form implies implications reversed 
initial semantics initial semantics intended interpretation speci cation class initial models 
equational logic know models exist isomorphic 
strictly speaking obj special computational provision initial semantics allow users declare intention certain speci cations interpreted initially loosely keyword pair obj endo pair th 
computational di erence convention reversed certain computations di erent signi cance initial semantics loose semantics 
particular canonical church rosser terminating ground terms holds initial algebra gives decision procedure initial ground equational satisfaction decides disequality equality 
reduction prove equations true initial models inductive proofs powerful valid necessary 
proof methods discussed previous subsection loose semantics valid initial semantics valid models certainly initial models 
inductive proofs valid assumptions form equations assumptions may course facilitate computations base step cases induction 
introduce relations mean initial algebra may write important fact reasoning techniques loose semantics valid expressed assertion implies particular implies course implies inductive lemmas loose deductions previously proved induction rewrite rule add computing somewhat informally doesn indicate exactly set rewrite rules involved th th denotes set equations true write proofs done way similarly write proofs reduction may inductive lemmas 
implies normal form imply relations represent convenient way inductive arguments 
hidden semantics hidden speci cation loose protecting extension de ned terms initially interpreted subtheory denote entire theory td denote initial subtheory 
de nition hidden models technically loose models restricted signature td initial model td initial models isomorphic loss generality assume body restriction particular initial model td relations behavioral equality de nition may write important note loose reasoning valid words implies implies implies behavioral lemmas hidden sorts inductive lemmas visible sorts loose deductions previously shown rewrite rule add computing inductive assertions data subtheory behavioral proofs expressed saying implies provided visible sort write fact inductive lemmas data needed behavioral proofs 
somewhat informally doesn say exactly rewrite rules involved indicate kind deduction writing similarly write proofs reduction may behavioral inductive lemmas 
implies implies relations represent convenient way carry behavioral proofs part coinduction 
ocial obj syntax allow declaring sorts hidden 
easy modify syntax compelling reason just distinction obj endo th computational ect easy introduce notational convention serves purpose just declare user intentions 
fact introduce convention new sorts declared theory modules containing line pr data hidden sorts declared data visible 
discussion doing coinductive proofs hidden conventions suggested just kinds sort hidden visible kinds computation obj provides rewriting general equational reasoning valid valid kind sort separately 
induction valid visible data sorts coinduction valid hidden sorts mental discipline necessary obj way necessary keep track signi cance computations conventions ect outcome computations 
discipline assertions outside obj seen assertions obj 
fact nearly relations carefully distinguished theoretical discussion denoted symbol obj syntax sense reasonable rst convenience inclusions relations discussed 
turning bit philosophy note mechanical theorem prover know doing program computer meaning computation supplied user information context 
modularity inheritance multiple paradigms approach modularity assumes signatures models axioms satisfy certain natural conditions de ne called institution 
gives powerful module facilities parameterized programming including generic modules take modules parameters may parameterized module expressions say interconnect modify modules proper account parameterization modules inherit 
hidden signature morphisms hidden signature maps see de nition appropriate signature morphisms horizontal structure modularity provides signature maps vertical structure introduced distinction vertical horizontal structure 
phrase sort arr state section 
analogy functional programming may help modules functions theories types evaluating typed module expression yields new module just evaluating typed functional expression yields new function 
fact parameterized programming gives power higher order functional programming purely rst order setting easier proofs write programs 
parameterized programming allows integrating speci cations executable code speci cation language conventional programming language case executing module expression builds new executable code speci cation code may textual compiled executable forms 
implemented module interconnection language ada extends parameterized programming information hiding hidden algebra 
shown practical bene real problems ight control software helicopters 
parameterized programming rst implemented obj builds ideas clear uenced module systems ada ml languages 
parameterized programming shows software architecture extends higher order modules views 
hidden algebra handles main features object paradigm clarify improve things bit cleanly separating data objects classes modules shown add powerful generic modules behavioral types speci cation declarative programming style 
ideas implemented foops language shown useful implementing multimedia requirements tracing system 
discuss approach inheritance uses order sorted algebra natural simple subclasses just subsorts having attributes methods 
integration functional logic paradigms language extended integrate object logic functional paradigms adding constraint paradigm 
idea associating code speci cations possibly software objects test cases documentation comes 

