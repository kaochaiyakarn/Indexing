automatic debugging computer programs thesis submitted faculty purdue university agrawal partial fulfillment requirements degree doctor philosophy august ii acknowledgments advisor rich demillo gave initial impetus look problem software debugging helped develop ideas dissertation 
am grateful advisor gene spafford expert advise particularly implementation issues indispensable 
am thankful office mate ed collaborated early stages development prototype debugging tool 
express ahmed elmagarmid bob horgan aditya mathur mehrotra hsin pan ryan venkatesh nok michal young fruitful discussions time time 
person am indebted able achieve father das agrawal fostered love learning despite supported academic endeavors 
wife words encouragement patiently tolerated absence long hours spent preparing dissertation 
support research provided part software engineering research center purdue university national science foundation industry university cooperative research center nsf ecd national science foundation ccr summer internship bellcore 
discard page iii table contents page list figures vi 
new paradigm debugging scope goals research contributions research organization dissertation 
debugging state art practice traditional debugging pictorial debugging debugging specifications algorithmic debugging knowledge debugging program slicing program dicing anomaly detection execution backtracking summary 
simple dynamic slicing notation preliminary definitions flow graph def sets reaching definitions data dependence control dependence iv page program dependence graph reachable nodes static slicing dynamic slicing execution history dynamic slicing approach dynamic slicing approach dynamic slicing approach dynamic slicing approach efficient reduction dynamic dependence graph summary 
complete dynamic slicing static slicing pointers composite variables intersection valued expressions static reaching definitions revisited dynamic slicing pointers composite variables def sets revisited dynamic reaching definitions revisited interprocedural dynamic slicing summary 
local global slicing local analysis global analysis dynamic data slice control slice dynamic program slice static slices summary 
fault localization combining dynamic program slices varying testcase argument varying variable argument varying location argument varying program argument combining data slices summary page 
execution backtracking simple execution backtracking execution history approach structured backtracking approach bounds space requirements extensions summary 
spyder prototype implementation tool screen spyder commands selection setting commands slicing commands fault guessing commands backtracking commands traditional debugging commands implementation modifications compiler modifications debugger summary 
directions limitations paradigm limitations current implementation lessons learned implementation directions fault prediction heuristics user interfaces extensions domains applications bibliography vita vi list figures page spyder screen sample source program debugging paradigm example program flow graph def sets data dependence graph flow graph control dependence graph program program dependence graph program static slice variable program example program dynamicslice program variable dynamicslice program variable dynamicslice program variable example program dynamicslice program variable example program dynamic dependence graph program reduced dynamic dependence graph program reduced dynamic dependence graph obtained dynamicslice variant program vii page static slice respect area line 
dynamic slice respect area line loop iteration 
dynamic slice respect area line second loop iteration 
approximate dynamic slice area line loop iteration 
approximate dynamic slice area line second loop iteration 
static slice respect line 
dynamic slice respect line 
dynamic slice respect line 
dynamic slice respect line 
storage layout program program execution testcase 
interprocedural dynamic program slice respect area line second loop iteration 
static reaching definitions area line dynamic reaching definition area line second loop iteration dynamic data slice respect sum line testcase 
static data slice respect sum line 
control slice respect statement line 
dynamic program slice respect area line second loop iteration testcase 
static program slice respect variable area line dynamic program slice sum line testcase 
dynamic program slice sum line testcase 
viii page dynamic program slice testcase minus testcase 
dynamic program slice testcase minus testcase 
dynamic program slice testcase minus testcase 
dynamic program slice testcase minus testcases 
intersection dynamic program slices sum line testcases 
result subtracting dynamic program slices sum line testcases intersection corresponding slices testcases 
dynamic program slice date day week line testcase month day year dynamic program slice date day year line testcase month day year result subtracting dynamic program slice date day year line testcase month day year corresponding slice date day week 
dynamic program slice area line loop iteration testcase 
dynamic program slice area line second loop iteration testcase 
result subtracting dynamic program slice area line loop iteration testcase corresponding slice second loop iteration 
dynamic data slice sum line testcase 
dynamic data slice sum line testcase 
result subtracting dynamic data slice sum line testcase corresponding slice testcase 
control slice line testcase 
ix page dynamic data slice class line testcase 
control slice line testcase 
dynamic data slice sqr line testcase 
program divide integers 
execution history program testcase saved def set values 
tool screen backtracking line line execution backtracking line line line snapshot spyder screen debugging session 
agrawal 
ph purdue university august 
automatic debugging computer programs 
major professors richard demillo eugene spafford 
programmers spend considerable time debugging code 
symbolic debuggers provide help task remains complex difficult 
breakpoints tracing tools provide little high level help 
programmers perform tasks manually tools perform automatically finding statements program affect value output variable testcase value variable control reached program location program differently testcase 
debugging tools provided explicit support tasks debugging process automated large extent 
dissertation propose new debugging paradigm easily lends automation 
tasks paradigm translate techniques called dynamic program slicing execution backtracking 
discuss techniques automated 
ways obtain accurate dynamic slices programs may involve unconstrained pointers composite variables 
dynamic slicing algorithms spanning range time space accuracy trade offs 
propose ways multiple dynamic slices may combined provide fault localization information 
new space efficient approach execution backtracking called structured backtracking proposed 
experiment techniques resulted development prototype tool spyder explicitly supports 

presence bugs programs regarded fundamental phenomenon bug free program theoretical concept absolute zero thermodynamics envisaged attained 
jacob schwartz sch 
pessimism unfounded 
computer program complex automaton 
size program grows complexity underlying automaton soon starts exploding 
increasingly difficult human mind perceive keep track possible state transitions complex state machine 
slight programmer part may result serious faults 
difficulty compounded programmers insufficient understanding problem solutions unfortunately case 
presence faults automaton may fail certain inputs 
incorrect output produced faulty automaton referred failure faults automaton cause failure referred bugs ans 
words fault cause failure symptom 
faults get introduced program errors committed programmers translating specifications implementations errors specifications 
testing problem finding inputs automaton cause fail debugging problem finding faults failure detected 
engaged serious programming knows software testing debugging hard problems 
percent total system development cost time may spent activities boe 
suggested best solution problem bugs ensure get program place 
effect argued program verification proving programs correct eliminate need testing debugging dij hoa nr 
program verification requires program behavior expressed assertions input output 
prove output assertion holds program executed input satisfies input assertion 
approach works theory problems arise practice dlp firstly real life programs characterizing behavior mathematically may feasible precluding mathematical reasoning 
constructing program proofs arduous task 
proofs generally difficult construct understand programs 
proofs bug prone 
proofs constructed respect program specifications 
specifications buggy 
shapiro explains sha matter language convey specifications bound mistakes 
sloppy advocates program methodologies may say fundamental reason know finite point time consequences current assumptions 
program collection assumptions arbitrarily complex behavior consequence assumptions general anticipate possible behaviors program 
principle manifests numerous undecidability results cover interesting aspects program behavior non trivial programming system hr 
fet fetzer goes far suggesting success program verification generally applicable completely reliable method guaranteeing program performance theoretical possibility 
structured programming solution cited cure bugs 
structured programming certainly helps improve program comprehensibility reliability naive think reduces need software testing debugging 
parnas points par highly structured systems surprise unreliability occur human mind able fully comprehend conditions arise interactions components 
thing evident escape testing debugging programs confidence 
precisely activities achieve increase confidence program furnishing evidence program works correctly testcases supplied extrapolation similar cases testcases selected judiciously 
research gone answering question select testcases judiciously see ab 
surprisingly done equally important topic localize bugs revealed testcases 
tools techniques available help programmers debug programs 
tools available basically provide breakpoints traces main debugging aids kat mb dun wei 
unfortunately traditional mechanisms inadequate task quickly isolating program faults 
dissertation new paradigm debugging dynamic program slicing fault guessing execution backtracking techniques 
importance paradigm lies step paradigm automated individually automating process lot tedium debugging process 
provides systematic approach debugging attempts introduce element science largely viewed art 
experiment techniques resulted development prototype tool explicitly supports paradigm 
new paradigm debugging program failed produce desired output go finding went wrong 
program important information usually available programmer input data erroneous output produced program 
program sufficiently simple analyzed manually input 
programs especially lengthy ones analysis difficult perform 
logical way proceed situations think backwards deduce conditions program produces incorrect output sch gou luk 
consider example program main window panel 
program computes sum areas triangles 
reads value followed lengths sides triangles 
values classifies triangle equilateral isosceles right scalene triangle 
computes area triangle appropriate formula 
program prints sum areas 
bug displayed program assignment line mistakenly computes sqr sides sides sides sides suppose program executed testcase sides triangles respectively 
sum areas triangles testcase incorrectly printed 
go locating bug 
looking backwards printf statement line find possibilities sum updated properly formulas computing area triangle incorrect triangle classified incorrectly lengths sides triangle read correctly 
statement line adds area sum thing may want examine state program point 
set breakpoint line program statement examine values variables sum area point 
suppose find area computed correctly loop iteration computed incorrectly second 
figures window system window dumps prototype debugging tool spyder operation 
testcase consists specific set runtime input values 
refer testcase testcase chapters 
spyder screen sample source program discover may decide examine value class second triangle determine formula computing area 
find class incorrect examine values sides triangle check read correctly 
examine statements lines determine class triangle 
distinct tasks repeatedly performed analysis 
determine statements code influence value variable observed location 

select statements examine program state 

recreate program state selected statement examine specific variables 
example performed tasks examining code assistance debugger 
third task set breakpoint code control stopped breakpoint 
debugging job easier debugger provided direct assistance performing tasks 
explicit support activities able pursue software debugging systematic fashion 
prototype debugger spyder provides user exactly assistance 
task variable program location determining statements program affect value variable location program executed testcase referred dynamic program slicing 
spyder find dynamic slices automatically 
provides mechanisms help programmers select appropriate statements examination 
restore program state desired location backtracking program execution having program 
depicts proposed systematic debugging paradigm 
step detection program failure translate external symptoms program failure corresponding internal symptoms terms data control problems program 
internal symptoms selected slicing criterion corresponding dynamic slice obtained 
examining slice statement selected examine program state program state restored control reached statement 
examining values variables restored state may reveal fault user may choose examine restored state guess new fault select new slicing criterion repeat cycle fault localized 
scope goals research dissertation primarily concerned automate step debugging paradigm outlined programs written sequential procedural programming languages pascal issues concerning debugging parallel distributed programs programs written functional logic programming languages debugging optimized programs addressed 
underlying goal research enhance state ofthe art software debugging enhance state practice 
important focus research develop techniques practicable techniques sound theory practical implement 
equally important goal develop techniques applied programs written realistic procedural languages pascal reason focussed techniques programs involved arrays pointers records unions procedures hard imagine real programs written procedural language language features 
show techniques proposed useful practical wanted implemented prototype tool explicitly supported 
goal build production quality tool demonstrate usefulness feasibility automating significant steps debugging paradigm proposed 
failure detected failure detected choose slicing criterion obtain dynamic slice guess fault restore program state fix fault fault detected 
examine restored state debugging paradigm contributions research main contributions research ffl slicing guessing backtracking paradigm observed think hypothesize verify cycle programmers follow debugging translated dynamic slicing fault guessing execution backtracking paradigm 
significance observation mentioned earlier lies fact step paradigm automated making possible largely automate debugging process 
ffl dynamic program slicing developed techniques perform dynamic program slicing programs may involve unconstrained pointers arrays records unions procedures 
designed number algorithms spanning range time space accuracy trade offs 
proposed new space efficient datastructure called reduced dynamic dependence graph obtaining dynamic program slices 
ffl data control slices oftentimes observing complete program slices may overwhelming introduced notions data control slices smaller program slices easier follow 
ffl combining dynamic slices dynamic slice obtained respect arguments program variable location testcase 
described ways fix arguments vary remaining argument generate multiple related dynamic slices may combined ways provide fault localization information 
ffl structured backtracking proposed new approach execution backtracking called structured backtracking space time efficient compared execution history approach 
ffl spyder prototype implementation implemented prototype debugging tool spyder explicitly supports slice guess backtrack paradigm 
tool works programming language including pointers arrays structures procedures 
interactive easy window system user interface 
organization dissertation rest dissertation organized follows chapter brief survey state art practice software debugging describe relates 
steps debugging paradigm mentioned discussed chapters 
chapter discusses approaches obtaining dynamic slices simple case program involves scalar variables 
chapter extends discussion handling composite pointer variables 
chapter introduce notions data control slices 
chapter examines multiple dynamic slices may usefully combined provide fault localization information 
chapter discuss approaches implementing execution backtracking 
chapter describe prototype debugging tool spyder explicitly supports debugging paradigm outlined 
chapter concludes dissertation discussion lessons learned research outlining ideas research 

debugging state art practice progress field measured rate new ideas developed perfected absorbed society wide spread quite area software debugging progress 
essentially techniques developed years ago debugging assembly language programs today 
quite surprising high cost terms programmer time associated debugging 
basic notion user controlled breakpoints commonly debuggers today introduced assembly language debuggers flit sd sw developed late 
come farther 
section brief survey state art practice software debugging outline relates 
traditional debugging core images analyze faulty program behavior somewhat faded away print statements prevalent debugging technique 
print statements placed strategic locations program display intermediate values important variables indicate flow control 
way users get visual feedback internal workings program helps localize fault 
technique simple effective cases 
comes free language 
tedious program recompiled time new print statements included 
print statements usually need deleted commented program bug detected fixed 
interactive symbolic debuggers allow runtime control display debugging information requiring user modify source code bea dun kat 
provide capability setting breakpoints program basic debugging facility 
user specify statements breakpoints control reaches locations program execution suspended control passed debugger 
user inspect program state displaying current values variables 
debuggers allow control stack displayed 
allow program state explicitly modified user execution 
examining possibly changing values user set new breakpoints continue execution 
tracing common facility provided symbolic debuggers 
user specify corresponding trace information displayed points 
trace information may include simple message control reaching may include values certain variables points 
control reaches corresponding trace information displayed execution continued 
note special case breakpoint specified trace information displayed execution continued automatically 
symbolic debuggers allow certain boolean conditions associated 
control reaches corresponding condition evaluated 
condition true specified trace information displayed execution continued execution resumed displaying 
similarly conditions associated breakpoints debuggers 
common facility provided interactive debuggers single stepping 
program executed statement time control returned debugger statement 
note single stepping special case breakpoints breakpoints set consecutive source statements 
symbolic debuggers provide limited control actions performed breakpoint reached 
dalek symbolic debugger built top gnu debugger gdb provides full programming language including conditionals loops blocks procedures functions variables program higherlevel actions performed breakpoints 
provides support events form high level abstractions program executions 
interpreted environments program source interpreted compiled provide greater degree flexibility debugging purposes 
integrated programming environments interlisp tei programmer assistant tei cornell program synthesizer tr provide integrated support program editing execution debugging 
error encountered program execution possible correct erroneous function immediately continue execution 
usual debugging cycle compiled programs edit compile execute debug considerably shortened systems 
window mouse symbolic debuggers bitmapped displays am pi car car bring significant improvement traditional command driven debuggers user interface perspective 
debuggers having type debugging commands user simply select mouse button clicks 
source code simultaneously displayed windows current control location highlighted arrow pointing statement executed 
am user select variables expressions source window help mouse request values displayed 
pi car provides context dependent pop menus variable names visible current scope selecting displaying values 
pictorial debugging debuggers iso si provide moh go step attempt control flow data structures pictorially user 
graphical representations screen updated dynamically program execution proceeds 
example stack integers may represented sequence rectangles containing numbers stack top may represented arrow pointing top rectangle stack 
arrow moves new rectangles added deleted numbers pushed popped stack 
debuggers infancy presently able handle small programs simple data structures 
research area algorithm animation bs bro ld offer respect 
debugging specifications debugging technique called dimensional pinpointing lst aims locating inconsistencies software structured levels 
requires formal specifications defining program desired behavior structural level provided 
technique works checking actual execution behavior program test sequence top level specifications 
inconsistency observed new top level specifications may added process repeated narrow search specific program unit 
new specifications may added process repeated lower level program unit specification violated top level 
process continues successive lower levels fault detected 
algorithmic debugging shapiro divide query interactive fault diagnosis approach sha uses kind binary search computation tree program localize bugs 
relies user verify correctness intermediate function calls input output values 
premise computation performed subprogram proc correct computations performed subprograms invoked proc correct 
hand computation performed proc incorrect subprograms invokes incorrect 
diagnosis algorithm works selecting node computation tree divides tree roughly equal parts 
user input output values function call asked check function computation correct 
incorrect algorithm recursively applied subtree rooted node subtree removed consideration algorithm applied rest tree 
cycle repeated fault located 
approach works particularly side effect free languages logic programming language prolog 
applied imperative languages pascal procedure call level 
approach fault localized procedure contains fault 
debugging techniques may localize bug procedure 
korel laski stad system testing debugging provides similar approach intra procedure level subset pascal kl kl asking users verify input output correctness procedure calls asks questions assignment correct reaching definition variable location control correctly reached location approach targeted find simple operator operand faults program 
knowledge debugging attempts apply artificial intelligence techniques debugging problem 
particular experimental systems developed knowledge approach see sev de 
systems presently handle restricted class bugs small programs 
discuss representative knowledge debugging systems 
program understanding debugging system luk maintains knowledge base simple programming schemas solving simple programming tasks swapping values finding maximum element array schema assertion describing function performed schema stored 
takes program assertion describing specifications searches code patterns program matching stored knowledgebase 
constructs assertion describing program behavior combining assertions fetched knowledge base 
constructed assertion matched assertion differ process traced back suggest possible bugs 
js uses opposite approach 
takes program formal specification program inputs tries synthesize program specifications trying match synthesized program program 
synthesis performed help knowledge base programming plans solving simple goals 
synthesis fails produce program matching program discrepancies analyzed possible faults suggested 
programmer apprentice rw uses similar approach 
plan intended program infers existence bugs program performing kind pattern matching plan program 
note systems perform static program analysis irrespective runtime inputs 
hand expects actual expected output program failed testcase supplied 
compares outputs tries infer fault differences help knowledge base error cause heuristics 
knowledge base stores list fault symptoms output discrepancies list possible faults symptom 
faults described terms prototype faulty code schemas 
system searches faults program corresponding output discrepancies observed 
performs pattern matching code schemas locate faults 
program slicing static slicing approach program debugging proposed weiser wei wei 
program slice helpful debugging presents user subset program may effect value erroneous variable 
debugging narrowing user attention code segments relevant fault 
slicing constitutes major component debugging paradigm addressed detail chapter 
weiser algorithm compute slices iterative solutions dataflow equations 
ottenstein ottenstein algorithm terms graph reachability program dependence graph considered intraprocedural case oo describe algorithm chapter context static slicing 
horwitz reps binkley extended program dependence graph representation call system dependence graph find interprocedural static slices graph reachability framework hrb 
carr defined information flow relations somewhat similar data control dependence relations obtain static program slices referred partial statements bc 
uses program slicing suggested applications program verification testing maintenance automatic parallelization program execution automatic integration program versions software metrics 
see wei bc hpr gl ot los 
program slice defined respect variable occurrence assumed control eventually reach corresponding program location 
issue non termination program execution addressed definition 
podgurski clark extended regular notion control dependence refer strong control dependence weak control dependence includes inter statement dependencies involving program non termination pc 
detect program faults infinite loops strong control dependence gives finer slices compared weak control dependence 
definition remains cases 
korel laski extended weiser static slicing algorithms dynamic case kl 
definition dynamic slice different see chapter 
require occurrence statement execution history included slice occurrences statement automatically included slice value variable question location unaffected occurrences 
examine consequences requirement chapter section 
people investigated semantic basis program slicing ven ry cf sel 
program dicing slicing uses information value variable incorrect narrow search fault 
information values variables may correct 
lyle weiser proposed notion program dicing lw attempts narrow search fault information gained testing variables program observed incorrect values correct values program executed various testcases 
search fault narrowed removing statements belong slices respect correct variables slice respect incorrect variable 
discuss approach chapter 
anomaly detection static anomaly detection approach program analyzed data flow analysis detect certain conditions program generally indicative errors inefficiencies fo 
example data flow analysis detect assignment statement variable variable assigned value assignments assign value variable var control flows encountering var possible static analysis determine path program feasible approach may find anomalies program arise execution 
dynamic anomaly detection techniques hand detect anomalous conditions arise actual program executions hua cc 
techniques instrument program extra code checks anomalous behavior conditions mentioned occur program execution 
anomalies detected way indicative errors inefficient program behavior 
time program instrumentation analyze actual program executions guarantee detection possible anomalies program 
execution backtracking debugging systems past supported execution backtracking facilities 
interactive debugging tool fortran developed late provided execution replay facility bal 
system complete history tape program debugged testcase saved 
program executed playback tape 
point program execution backtracked earlier location information saved history tape 
program stopped location possible change values variables executing forward simply replayed program behavior recorded earlier 
miller choi ppd mc performs flow back analysis uses notion incremental tracing portions program state checkpointed start segments program code called 
emulation blocks may generate corresponding segments execution history 
zelkowitz incorporated backtracking facility programming language pl adding retrace statement language 
statement execution backtracked desired number statements statement label program state matched certain condition 
incorporation backtracking facilities programming language useful programming applications alternate paths tried reach goal 
problems frequently arise artificial intelligence applications instance 
user program retrace statements code approach provide interactive control backtracking debugging 
interlisp tei cornell program synthesizer tr provide facilities undo operations 
systems maintain fixed length history list sideeffects caused operations 
new events occur existing events list aged oldest events forgotten 
returning points arbitrarily far back execution may possible 
chapter structured backtracking approach execution backtracking attempts overcome problem 
igor fb cope acs provide execution backtracking performing periodic checkpointing memory pages file blocks modified program execution 
approach suitable undoing effects programs may inefficient performing statement level backtracking 
summary gap state art state practice software debugging wide 
commonly available debuggers today restrict providing facilities described section traditional debugging 
basically provide variants breakpoint mechanism coupled display facility 
generally results substantial saving debugging time compared deciphering core images print statements 
debugging large programs decisions set breakpoint determine right balance trace information trace frequency may easy ones 
dissertation describe tasks commonly performed debugging may automated software debugging arduous 
problem debugging parallel logic functional optimized programs scope dissertation included related areas research carried areas see mh hen cou 

simple dynamic slicing debugging value variable var program statement observed incorrect 
program slice respect var gives set program statements directly indirectly affect value var observed wei 
notion program slice particular inputs revealed error 
concerned finding statements influence value variable occurrence inputs statements affect value current inputs 
unfortunately size slice defined may approach original program usefulness slice debugging tends diminish size slice increases 
examine narrower notion slice consisting statements influence value variable occurrence specific program inputs 
problem referred dynamic program slicing distinguish original problem static program slicing 
conceptually program may thought collection threads computing value program variable 
threads may compute values variable 
portions threads may overlap 
complex control structure program complex threads 
static program slicing isolates possible threads computing particular variable 
dynamic slicing hand isolates unique thread computing variable inputs 
debugging programmers generally analyze program behavior testcase revealed error generic testcase 
concrete testcase slice respect set variables may obtained union slices respect individual variables set 
exercised bug helps focus attention particular program contains bug 
consider scenario friend program discovers error 
finds value variable printed statement program incorrect 
spending time trying find cause luck comes help 
probably thing demand testcase revealed bug 
gave print statement variable incorrect value didn disclose particular inputs triggered error debugging task clearly difficult 
suggests debugging program probably try find dynamic slice program minds 
simple observation highlights value automatically determining dynamic program slices 
distinction static dynamic slicing advantages discussed section 
chapter examine approaches compute dynamic program slices 
discuss program representation called program dependence graph computing static program slices static slicing algorithm 
simple extensions static slicing algorithm compute dynamic slices 
algorithms compute slices may include extra statements dynamic slice shouldn 
data structure called dynamic dependence graph algorithm uses compute accurate dynamic slices 
size dynamic dependence graph depends length program execution general unbounded introduce mechanism construct call reduced dynamic dependence graph requires limited space proportional number distinct dynamic slices arise current program execution length execution 
efficient way construct reduced dynamic dependence graph 
say slice contains bug necessarily mean bug textually contained slice bug correspond absence slice missing statement statement outside slice inside discussed chapter 
approaches dynamic slicing span range solutions varying space time accuracy trade offs 
simplicity exposition restrict attention language composition assignment read write statements 
program gamma 
declarations stmt list 
stmt list gamma 
stmt stmt list ffl stmt gamma 
simple stmt stmt stmt simple stmt gamma 
stmt read stmt write stmt stmt gamma 
var exp read stmt gamma 
read var write stmt gamma 
write var stmt gamma 
predicate exp stmt list stmt list stmt gamma 
predicate exp stmt list predicate exp gamma 
exp exp gamma 
exp binary op exp unary op exp var const discussion easily extensible statement types case expressions side effects expressions pre post increment decrement operators 
techniques handling pointers arrays structures procedures discussed chapter 
notation sections construct adapted similar construct programming language ml mth 
consider generic declarations 
expression 
declarations 
consists sequence name bindings may inside expression 
scope bindings limited expression 
result evaluating expression 
returned value construct 
example expression evaluates 
names may bound pattern matching sides symbol 
example complex number represented tuple sum complex numbers complex complex may defined follows sum complex complex complex real imaginary complex real imaginary real real imaginary imaginary expression real imaginary real imaginary defined pattern matching 
notation denote set unions 
example fx may composed 
example fx fy write thing preliminary definitions flow graph flow graph flow program tuple en ex set vertices corresponding simple statements predicate expressions correspond non terminals simple stmt predicate exp grammar set directed edges vertices en ex distinguished entry exit nodes respectively 
arc node node control pass node node program execution 
define flow syntax directed manner follows flow program flow stmt list flow fsg oe simple statement flow flow en ex flow en ex ex en en ex flow flow en ex flow en ex ex new dummy node fp en en ex ex ex ex ex flow flow en ex fpg program optimization applications vertices flow graph correspond basic blocks program 
purposes convenient associate vertices simple statements predicates program 
en ex example consider program refer program times chapter 
symbols assignment statements denote unspecified side effect free functions presently concerned names variables computation relevant 
labels included part program 
shows flow graph program ignore node annotations moment 
node dummy exit nodes statements respectively 
def sets vertex flow graph def set associated 
set vertex consists variables referenced computation associated vertex def set consists variable computed vertex 
def defined syntax directed manner simple stmt predicate exp syntactic categories var exp exp def var exp read var oe def read var write var def write var oe predicate exp exp def predicate exp oe read write write 
example program flow graph def sets program exp binary op exp exp exp unary op exp exp var const oe def sets dummy vertices flow graph introduced exit nodes statements null sets 
example consider program 
shows def sets denoted respectively associated nodes flow graph ignore node annotations labeled moment 
statement example defines variable uses variable computing value assigned fxg fyg node 
reaching definitions flow graph node variable var define var set reaching definitions variable var node flow graph set nodes variable var assigned value control flow node node encountering redefinitions var precisely var en ex var def fxg var gammaf en ex example shows sets denoted nodes nonempty sets 
example consider node variable set 
definitions nodes definitions reach node paths respectively encountering redefinitions paths 
node 
data dependence data dependence graph program pair set vertices flow graph set edges reflect data dependencies vertices edge vertex vertex means computation performed vertex directly depends value computed vertex precisely flow en ex var var flow example consider program flow graph shown 
shows corresponding data dependence graph 
consider node example shown variable set set node 
data dependence edges node nodes respectively 
control dependence control dependence graph program tuple set vertices flow graph set edges reflect control dependencies vertices dummy initial node flow graph en ex belong places literature particularly related vectorizing compilers fow direction edges data dependence graphs reversed purposes program slicing definition suitable apparent 
data dependence graph flow graph 
edge means execution node directly depends boolean value predicate node defined syntax directed manner follows program stmt list fsg simple statement fpg fpg example shows control dependence graph program 
example statements immediately nested predicate statement control dependence edges nodes node 
statement immediately nested predicate statement edge node node control dependence graph 
control dependence graph program note vertex outgoing control dependence edge 
definition denotes predicate statement node control dependent 
precisely program fxg example control dependence graph get oe 
notice control dependence graph language corresponds exactly nesting structure statements program 
program dependence graph program dependence graph program obtained merging data control dependence graphs example shows program dependence graph program 
union data dependence graph shown control dependence graph shown 
dummy nodes omitted program dependence graph data control dependence edges associated purpose syntax directed construction program flow graph 
applications vectorizing compilers data dependence graph may include types dependence edges data control dependence anti dependence purposes program slicing suffice 
program dependence graph program reachable nodes graph vertex set vertices set edges set vertices reached edges equivalently fvg gammaf example consider node program dependence graph 
traversing graph starting node finding nodes reached get set node 
static slicing program simple statement predicate expression equivalently node flow graph variable var static slice respect variable var node subset input execution reaches node variable var value execution reaches node course means execution node reached exactly number times en ex flow graph static slice constructed finding subset consisting nodes execution possibly affect value variable var node call subset var 
var variable node node corresponds write var statement subset easily obtained traversing program dependence graph starting node collecting program may viewed ordered set statements statement uniquely identified location program line numbers 
sense set operations union intersection subset may applied programs 
nodes reachable 
variables var node need select outgoing edges node lead nodes defining var traverse program dependence graph 
var node need find reaching definitions var node flow graph program start traversing program dependence graph nodes 
var precisely defined follows var flow var example consider program 
suppose wish find static slice respect variable statement 
find set reaching definitions node flow graph program shown 
set consists nodes 
find set reachable nodes nodes program dependence graph program shown 
set consists nodes gives desired slice 
shows slice nodes belonging slice shown bold 
dynamic slicing previous example static slice program respect variable statement contains assignment statements assign value know program testcase statements may executed 
example testcase gamma statement executed 
case value wrong write statement error function statement error predicate statement responsible error 
purpose slice key slice static slice variable statement program dynamic slicing find subset program statements execution really affected value variable observed execution point testcase 
dynamic slice testcase gamma variable statement contains statements opposed static slice contains statements 
clearly debugging program error observed dynamic slice help localize bug quickly static slice 
dynamic slice include statements fact influence value variable question current testcase statements affected value testcase sections describe approaches compute successively refined dynamic slices 
purposes defining algorithms precisely need formalize notion execution history 
execution history flow graph program test testcase consisting specific set input values read program 
denote execution history program test sequence hist vertices appended order visited program execution 
execution history instance denotes partial program execution till instance 
example consider program 
testcase gamma get execution history 
consider program loop refer program section 
symbols statements respectively unspecified functions relevant current discussion 
testcase get execution history 
note superscripts distinguish multiple occurrences statement execution history 
read write 
example program definition hist denotes node hist prev hist denotes subsequence node hist gamma prev gamma gamma notation prev hist hist 
denote parts hist 
denotes empty sequence 
definition hist denotes occurrence node hist 
oe 
occurrence example execution history program testcase gamma 
oe 
program testcase 
definition var hist denotes occurrence node assigns value var sequence hist var 
oe var 
var def var example execution history program testcase gamma 

program testcase 
note result empty set implying occurrence desired node singleton consisting unique node desired 
execution history hist program testcase test variable var dynamic slice respect hist var set statements hist execution effect value var observed execution shall give precise definition dynamic slice section 
note static slicing slice defined respect location program define dynamic slicing respect execution history 
dynamic slice respect intermediate point execution desired simply need consider partial execution history point 
dynamic slicing approach program saw static slice respect variable statement contains assignment statements 
clearly testcase statements executed 
marked nodes program dependence graph get executed current testcase traverse marked nodes graph slice obtained contain nodes executed current testcase 
words take projection program dependence graph respect nodes reached program execution current testcase algorithm section projected dependence graph find desired slice dynamicslice hist var var hist project nodes hist project oe nodes 
oe nodes node 
nodes example program testcase gamma execution history 


traversing nodes occur execution history starting node program dependence graph get dynamic slice execution 
depicts nodes graph drawn dotted 
statements executed corresponding nodes graph solid 
graph traversed solid nodes node definition execution history 
nodes reached traversal bold 
set bold nodes case gives desired slice 
unfortunately dynamicslice find accurate dynamic slices 
may include extra statements slice affect value variable question execution history 
see consider program testcase yields execution history 
shows result applying algorithm dynamicslice program dependence graph program respect execution 
looking execution history 
carefully find statement assigns value statements appear execution history uses variable statement dynamic slice current testcase 
dynamicslice includes slice statement executed current testcase statement depends statement key executed executed slice executed slice dynamicslice program testcase gamma variable execution executed slice executed slice executed key dynamicslice program testcase variable execution data dependency edge statement program dependence graph 
section refinement approach avoids problem 
dynamic slicing approach problem dynamicslice approach discussed lies fact statement may multiple reaching definitions variable program flow graph may multiple outgoing data dependence edges variable program dependence graph 
selection node dynamic slice dynamicslice implies nodes outgoing data dependence edges selected nodes executed corresponding data definitions may reached current node 
example statement multiple reaching definitions variables definitions variable statements variable statements 
outgoing data dependency edges variables statements respectively control dependence edge node 
testcase statements executed inclusion statement slice leads inclusion statements data dependencies statement statement variable variable activated testcase loop iterated 
flow graph statement may multiple reaching definitions variable multiple execution paths leading statement paths may different statements assigning value variable 
single path reaching definition variable statement 
interested examining dependencies single execution path execution history testcase inclusion statement dynamic slice lead inclusion statements defined values current testcase 
suggests mark edges program dependence graph corresponding dependencies occur program execution traverse graph marked edges 
precisely dynamicslice hist var var hist edges hist edges 
oe edges 
var var edges activated activated slice slice key dynamicslice program testcase variable execution example consider executing program testcase 
applying dynamicslice execution history 
variable yields dynamic slice include statement 
depicted edges drawn dotted lines 
statements executed edges corresponding new dependencies occur drawn solid lines 
graph traversed solid edges nodes reached bold 
set bold nodes gives desired slice 
note statement included dynamicslice slice included dynamicslice programs loops approach yield accurate dynamic slices 
presence loops may include statements necessary slice 
consider program testcase values read gamma 
time loop statement part statement executed second time loop statement part executed 
suppose execution reached just past statement second time loop second value printed wrong 
execution history far 
dynamicslice find slice variable execution history statements included slice value case dependent statement 
shows segment program dependence graph statements effect executing dynamicslice data dependence edge marked iteration marked second iteration 
edges marked inclusion statement leads inclusion statements value observed second iteration affected statement 
mentioned earlier dynamicslice find accurate dynamic slices program loops 
statement appear execution history program loops 
occurrence statement execution history occurrence reaching definition variable occurrence 
statement occurrence variable occurrence corresponding node program dependence graph outgoing data dependence edge marked 
absence loops statement occur execution history outgoing data dependence edges statement marked 
node selected slice leads selection nodes affected current occurrence selected node 
start selection nodes inclusion dynamic slice selecting node directly affected value variable execution history obtain accurate dynamic slices 
say find slices program loops 
shows example dynamicslice obtains accurate dynamic slice program loop 
read read write 
example program key slice slice activated activated subset dynamicslice program testcase gamma variable may difficulty dynamicslice discussed disappear marking data dependence edges new occurrence statement execution history unmarked outgoing dependence edges marked statement 
scheme example unfortunately may lead wrong dynamic slices situations 
consider example program 
consider case loop iterated twice time statements second time statement skipping statement 
obtain dynamic slice execution statement slice statement 
statement reached second time loop dependence edge variable unmarked marked 
finding slice statement include statement defined value statement value defined statement included slice 
inclusion leads inclusion dependence edge unmarked second iteration 
value statement depends value defined statement iteration slice 
scheme previously marked edges new occurrence statement execution history 
scheme worse dynamicslice dynamicslice find supersets minimal dynamic slices may omit statements belong slice 
dynamic slicing approach dynamicslice saw may lead dynamic slices statement may multiple occurrences execution history different occurrences statement may different reaching definitions variables statement 
program dependence graph distinguish different occurrences inclusion statement dynamic slice virtue occurrence may times lead inclusion statements different read read write 
example program occurrence statement dependent 
words different occurrences statement may different dependencies possible occurrence contributes slice occurrence 
inclusion occurrence slice lead inclusion statements occurrence statement dependent occurrences may dependent 
suggests different nodes different occurrences statement execution history occurrence statement dependence edges statements specific occurrences particular statement occurrence dependent 
node dependence graph outgoing edge variable statement 
call new dependence graph dynamic dependence graph 
program different dynamic dependence graphs different execution histories 
section precisely define dynamic dependence graph built 
dynamic dependence graph dynamic dependence graph execution history hist tuple multi set flow graph vertices multiple entries element treated distinct set edges denoting dynamic data dependencies control dependencies vertices 
symbol denote disjunctive union elements constructs multi sets sets allowing multiple occurrences element 
defined follows 
oe oe 
var var example consider program testcase gamma gamma yields execution history 
shows dynamic dependence graph execution history 
middle rows nodes correspond iterations loop 
notice particular occurrences node rows 
third iterations depends node corresponds dependence statement value assigned node second iteration depends node corresponds dependence statement value assigned node 
constructed dynamic dependence graph execution history easily obtain dynamic slice variable var finding node corresponding definition var execution history finding nodes graph reachable node 
dynamicslice defined precisely follows dynamicslice hist var var hist hist example consider program testcase gamma gamma 
shows effect executing dynamicslice dynamic dependence graph variable execution 
nodes bold belong slice 
note statement belongs slice statement 
dynamicslice hand included statement 
algorithm accurately captures notion dynamic slicing discussed informally algorithm precise definition dynamic slicing definition dynamic slice variable var respect execution history hist defined dynamic dependence graph program testcase gamma gamma 
nodes bold give dynamic slice testcase respect variable execution dynamicslice hist var var hist hist contrast definition dynamic slice proposed korel laski kl 
definition may yield unnecessarily large dynamic slices 
require occurrence statement execution history included slice occurrences statement automatically included slice value variable question location unaffected occurrences 
dynamic slice obtained executable produces value variable question location original program 
purposes usefulness dynamic slice lies fact execute fact isolates statements affected particular value observed particular location 
example program loop iteration computes value computation totally independent computation performed iteration 
value variable particular iteration incorrect statements included slice affected value observed iteration previous iterations 
example testcase gamma gamma statements included dynamic slice respect definition statement affect final value way 
interesting note approach may yield dynamic slice obtain dynamic slice obtained definition 
dynamic dependence graph execution history contains node occurrence statement simple statement predicate expression execution history 
means need save entire execution history testcase able construct dynamic dependence graph find dynamic slices respect variables execution 
section discuss approach obtain accurate dynamic slices require entire execution history saved 
dynamic slicing approach size total number nodes edges dynamic dependence graph defined section general unbounded 
number nodes graph equal number statements execution history general may depend values run time inputs 
example consider program 
number statements execution history size dynamic dependence graph program testcase depends times loop statement iterated turn depends value read variable statement 
hand know program finite number possible dynamic slices contains finite number statements slice subset statements 
subset possible dynamic slices arise execution history 
suggests ought able restrict number nodes dynamic dependence graph size function length corresponding execution history 
address mechanism achieve 
reduced dynamic dependence graph reduced dynamic dependence graph creating new node occurrence statement execution history create new node node transitive dependencies exist 
maintain tables called defnnode prednode 
defnnode maps variable name node reduced dynamic dependence graph assigned value variable 
prednode maps control predicate statement node reduced dynamic dependence graph corresponds occurrence predicate execution history far 
need tables save execution history 
associate set reachablestmts node graph 
set consists statements occurrences reached node 
maintain reachable statements reachable nodes node statements eventually define dynamic slice individual occurrences 
time statement gets executed determine set nodes assigned values variables occurrence control predicate node statement 
reachablestmts set occurrence obtained union reachablestmts nodes node associated exists reachablestmts set associate new occurrence node create new node outgoing edges nodes defnnode table entry variable assigned updated point node 
similarly current statement control predicate corresponding entry prednode updated point node 
precisely reduced dynamic dependence graph tuple reachablestmts defnnode prednode sets nodes edges respectively reachablestmts defnnode prednode maps defined 

oe oe oe oe oe 
reachablestmts defnnode prednode var defnnode var prednode reachablestmts reachablestmts oe reachablestmts defnnode prednode defnnode var var def defnnode var prednode stmt occurrence stmt prednode stmt reachablestmts defnnode prednode oe reachablestmts oe reachablestmts fvg occurrence reachablestmts fvg reachablestmts reachablestmts defnnode prednode reachablestmts reachablestmts defnnode var var def fvg defnnode var prednode occurrence fvg prednode fvg reachablestmts defnnode prednode example consider program testcase gamma gamma yields execution history 
shows reduced dynamic dependence graph execution history 
node graph annotated set reachable statements node 
note occurrence node graph opposed occurrences dynamic dependence graph program testcase shown 
occurrences node set node created reduced dynamic dependence graph 
reduced dynamic dependence graph execution history obtain dynamic slice variable var find entry table defnnode var reachablestmts set associated entry gives desired dynamic slice 
don traverse reduced reduced dynamic dependence graph program testcase gamma gamma 
node annotated reachablestmts set statements reachable node dynamic dependence graph find slice 
dynamicslice defined precisely follows dynamicslice hist var hist reachablestmts defnnode prednode reachablestmts defnnode var example consider program testcase gamma gamma 
shows reduced dynamic dependence graph execution history testcase 
dynamic slice variable execution reachablestmts set associated node row node define value note approach really need construct graph edges reachablestmts sets associated nodes directly give corresponding dynamic slices need traverse edges 
require occurrence node defined variable need keep node statement 
means looking statement occurrence node similar reachablestmts set simply overwrite reachablestmts set unique node corresponding statement 
approach needed dynamic slices respect current execution history 
simplification obtaining dynamic slices respect prefixes current execution history difficult 
constructing reduced dynamic dependence graph requires step execution history determine set reachable statements associated new statement occurrence 
means union reachablestmts sets immediate descendent nodes new node performed step 
section variation graph reduction mechanism discussed performing expensive set union operation step need perform node time creation 
efficient reduction dynamic dependence graph section describe new scheme reduce dynamic dependence graph efficient described 
scheme new occurrence statement execution history need find set nodes new occurrence immediately dependent check node set direct dependencies exists 
node new node created defnnode prednode tables updated appropriately 
circular dependencies dependence graph scheme considering direct dependencies fine 
presence loops program may circular dependencies case graph reduction described occur iteration loop create new node occurrences 
avoid problem need create new node say statement determine immediate dependents say node dependency previous occurrence immediate dependents reachable easily done checking reachablestmts set associated new occurrence subset reachablestmts set associated merge new occurrence merge subsequent iterations loop search node immediate dependents succeed 
scheme expensive set union operations performed initial iterations loop new inter statement dependencies activated subsequent iterations old dependencies repeated 
previous scheme hand iteration required computation set unions 
new reduction scheme precisely defined follows 

oe oe oe oe oe 
reachablestmts defnnode prednode var defnnode var prednode defnnode var var def defnnode var prednode occurrence prednode oe reachablestmts defnnode prednode reachablestmts defnnode prednode oe oe fvg occurrence fvg oe true fxg false reachablestmts defnnode prednode fvg reachablestmts reachablestmts reachablestmts defnnode var var def fvg defnnode var prednode occurrence fvg prednode reachablestmts fng fvg reachablestmts defnnode prednode oe reachablestmts oe reachablestmts fxg reachablestmts fxg reachablestmts reachablestmts defnnode prednode defnnode var var def fv defnnode var prednode occurrence fv prednode reachablestmts defnnode prednode example consider program testcase gamma gamma yields execution history 
shows reduced dynamic dependence graph obtained applying execution history 
note second occurrence node merged immediate dependent node reachablestmts set subset 
third occurrence node execution history node node immediate dependents 
immediate dependencies contained merged node third occurrence node associated node 
dynamic slice variable execution reachablestmts set associated node row node define value summary conventional notion program slice set statements affect value variable occurrence totally independent program input values 
program debugging involves analyzing program behavior specific inputs revealed bug 
chapter addressed dynamic counterpart static slicing problem finding statements really affected value variable occurrence program inputs examined approaches computing dynamic slices 
prototype debugging tool spyder provides facilities displaying static dynamic program slices 
shows program similar array structure variables 
suppose program executed testcase sides triangles respectively 
shows static slice respect area line 
shows corresponding dynamic slice execution stopped loop iteration 
shows corresponding slice second iteration 
note static slice contains statement assignments sum lines assignment sum affect value area way round 
case dynamic slice statements relevant computation area equilateral triangle belong slice 
assignments lines executed included slice values compute contribute computation area equilateral triangle 
assignments included second dynamic slice values compute responsible incorrectly classifying second triangle right triangle scalene triangle 
clearly second dynamic slice provides finer error localization information compared static slice 
reduced dynamic dependence graph program testcase gamma gamma obtained dynamicslice node annotated reachablestmts set statements reachable node spyder provides facility obtain approximate dynamic slices approach discussed section 
shows approximate dynamic slice respect area line execution reaches loop iteration 
approximate slice obtained case exactly corresponding exact dynamic slice shown 
shows approximate dynamic slice variable occurrence second loop iteration 
compare corresponding exact dynamic slice shown corresponding static slice shown 
variant program static slice respect area line 
dynamic slice respect area line loop iteration 
dynamic slice respect area line second loop iteration 
approximate dynamic slice area line loop iteration 
approximate dynamic slice area line second loop iteration 

complete dynamic slicing previous chapter discussed approaches finding dynamic program slices programs involved scalar variables 
slicing useful debugging programs complex data structures involving pointers dependencies hard visualize manual examination source code 
chapter discuss techniques described previous chapter extended find slices programs involve pointers composite variables 
scalar variables relatively easy handle memory location corresponds scalar variable fixed known compile time vary course program execution 
statement modifies scalar variable statement scalar variable easy determine compile time statement memory location modified 
chief difficulty dealing indirect pointer array element memory location referenced expression general determined compiled time 
occurs inside loop memory location referenced may vary loop iteration 
difficulty compounded language permits integer arithmetic pointer variables 
techniques proposed cwz hpr lh may obtain conservative static approximations pointer point run time presence unconstrained pointers analysis limited usefulness 
case forced conservative assumption indirect assignment pointer regarding array single unit 
potentially define variable 
outcome assumption static slices programs involving pointers tend large instances include programs 
fortunately possible perform precise dynamic dependence analysis language strongly typed 
chapter approach obtain dynamic program slices language permits unconstrained pointers 
pointers composite variables arrays records unions handled uniformly approach 
allows precise interprocedural dynamic slicing performed 
section general framework obtain static slices presence pointers composite variables extend dynamic case section 
static slicing algorithm assumes indirect assignment may potentially modify variable dynamic slicing algorithm detects exact dependencies 
section discusses approach may extended interprocedural case 
static slicing pointers composite variables section defined reaching definitions scalar variables 
definition variable var statement reaches statement path flow graph program node path defines var happens defines array element uses array element defines field record uses record defines variable uses pointer dereference expression 
able handle situations introduce notion intersection valued expressions 
intersection valued expressions expression said valued expression memory location associated 
simple check find expression valued expression check appear left hand side assignment statement 
example expressions var valued expressions 
hand expressions valued 
presence pointers composite variables arrays records programming language requires def sets statements defined terms valued expressions 
expression said intersect def expression memory location associated may overlap associated identify types intersections valued expressions complete intersection intersection partial intersection 
complete intersection expression completely intersects def expression memory location associated totally contained associated example consider code fragment 
variable completely intersects definition 
code fragment 
field completely intersects definition record 
intersection consider situation 
intersects definition depends actual values variables statements respectively 
values expressions intersect 
refer intersections intersections 
pointer dereferencing causes intersections 
code fragment 
variable intersects definition pointer variable may may pointing variable partial intersection consider scenario 
record fields defined 
similar situation occurs array elements defined 
refer intersections partial intersections 
expression partially intersects def expression define portion memory location associated lies associated similarly define portion memory location associated lies associated static reaching definitions revisited boolean functions determine valued expressions complete partial intersections respectively 
extend definition defined section programs involving scalar variables involving pointers composite variables 
var def oe var gammaf def fvar gammaf var var fxg var var fxg var var var var var var var fxg var note partial intersections may occur 
example consider situation 
check intersection partial intersection takes precedence occur 
definitions data control program dependence static slice remain sections respectively 
new definition static reaching definitions described find data dependence edges program dependence graph 
dynamic slicing pointers composite variables dynamic slicing differs static slicing intersections 
implies scalar variable dynamic reaching definition composite variable dynamic reaching definition scalar components 
define dynamic slices presence composite variables pointers generalize notion valued expression memory cell 
def sets revisited memory cell tuple adr len adr represents address memory len represents length bytes 
memory cell corresponding valued expression tuple sizeof exp gives current address associated valued expression exp runtime sizeof exp gives number bytes required store value exp define def sets simple statements predicates terms memory cells valued expressions 
length component memory cells may determined compile time address components may smallest addressable unit computer word 
languages memory allocation variable necessarily contiguous definition memory cell may changed include set contiguous subcells 
determined runtime just corresponding simple statement predicate executed 
dynamic reaching definitions revisited determining intersection valued expressions check memory cells intersect 
formulation redefine function earlier defined section follows cell 
oe adr hist oe cell hist hist 
def oe cell def cell cell cell cell cell cell cell returns true overlap cells 
return non overlapping portions lie overlapping portion respectively 
possible portions may empty len 
case pre empty analogous complete intersection static slicing case non empty analogous partial intersection mentioned earlier intersections dynamic case 
advantage formulation usual problems associated handling pointers static case automatically taken care dynamic case def sets resolved terms memory cells ambiguity determining memory cells overlap 
case static slicing definitions dynamic dependence graph dynamic slice remain section 
definition dynamic reaching definitions changed 
interprocedural dynamic slicing dynamic slicing approach described easily extended obtain slices programs procedures functions 
consider case parameters passed value case simply need treat procedure invocation proc actual actual actual sequence assignments formal actual formal ith formal parameter proc 
set assignments computed terms memory cells just procedure invoked def set computed just control enters procedure 
memory cells correspond def sets belong current activation record proc stack 
note interprocedural static slicing hrb approach dynamic slicing require determine global variables referenced inside procedure variables may aliases need eliminate name conflicts variables different procedures 
call easier handle initial assignments formal parameters need 
address formal parameter variable automatically resolved corresponding actual parameter 
call result parameter passing handled making assignments actual formal just control returns calling procedure 
call value result handled similarly making appropriate assignments procedure 
summary static program slices tend large imprecise program debugged involves pointers composite variables arrays records unions see examples 
lose usefulness altogether language involved strongly typed permits unconstrained pointers 
chapter shown find accurate dynamic slices presence unconstrained pointers composite variables 
approach outlined provides uniform framework handling pointers various types composite variables 
require language strongly typed runtime checks bound array element illegal pointer dereference performed 
shows simple program involving pointers 
initializes elements array prompts user values increments ith jth kth elements array prints new values elements 
pointer variables point ith jth kth elements array respectively 
consider testcase program executed input values 
shows static program slice respect line 
shows corresponding dynamic slice 
note static slice contains indirect assignments pointers lines pointers possibly pointing 
turn requires assignments lines scanf statement line assignments lines included slice 
dynamic program slice hand contains indirect assignment line current testcase point 
means assignments lines assignment line included dynamic slice 
similarly assignments lines assignment ith array element slice assignments elements array belong slice 
obtain dynamic program slice line indirect assignments lines dynamic slice shown 
current testcase values equal making aliases array element 
shows variant program loop initialize array separate assignment array element 
execute program testcase get output 
printing value prints 
implies value got corrupted program execution 
obtain dynamic slice line expect line slice place program modified 
find loop lines included dynamic slice shown 
suggests variable clobbered execution loop 
examination reveals fault lies loop predicate iterates times array declared elements long array declaration declared elements long elements long 
shows memory allocation compiler variables contents program execution testcase note memory location corresponds variable overlaps 
situations precise dynamic analysis terms memory cells invaluable revealing fault 
program shows program segment code determines class triangle moved procedure 
shows inter procedural dynamic slice respect area line second loop iteration main program program executed testcase sides triangles 
memory allocation vary compiler compiler 
static slice respect line 
dynamic slice respect line 
dynamic slice respect line 
dynamic slice respect line 
address contents symbolic name storage layout program program execution testcase 
interprocedural dynamic program slice respect area line second loop iteration 

local global slicing chapters informally defined dynamic slice respect variable program location testcase set statements affect value variable location program executed testcase constructive definition dynamic slice 
chapter take look really means statement affect value variable location statement influenced control reaching certain location 
local analysis program fault manifests directly indirectly ways case 
value expression exp location observed incorrect 
case 
control incorrectly reached location reached 
case 
control didn reach desired location case value exp location incorrect possibilities case 
function computed exp incorrect exp gamma determined localized fault 
case 
value variables var exp incorrect value expression incorrect value incorrect 
case find dynamic reaching definition var note may static reaching definitions exp corresponding dynamic reaching definition 
having unique reaching definition erroneous variable var possibilities case 
value expression exp computed incorrect 
case back case respect value exp computed case 
wrong reaching definition var 
case possibilities case 
control shouldn reached case back case respect location case 
correct definition var missing missing assignment var path assignments path incorrectly assigning value wrong variable 
determined localized fault 
case 
control correctly reached didn reach correct definition var took wrong path case back case respect location 
case 
shouldn included program 
case discovered extraneous assignment localized fault 
case control shouldn reached location possibilities predicate enclosing immediately enclosed predicate pred 
var composite variable array record find reaching definition scalar component var wrong value 
case 
enclosed predicate 
control shouldn reached enclosed predicate prevented control reaching means missing predicate enclosing case localized fault 
case 
immediately enclosed predicate pred predicate 
possibilities case 
control shouldn reached pred 
back case respect location pred 
case 
control reached pred case possibilities case 
pred evaluated incorrectly case back case respect value pred 
case 
missing predicate path pred localized fault 
case control didn reach desired location immediately enclosed predicate pred prevented control reaching possibilities case case 
control didn reach pred 
case back case respect location pred 
case 
control correctly reached pred case pred evaluated incorrectly back case respect value pred 
case 
pred included program 
extraneous predicate case localized fault 
global analysis large programs step step analysis may tedious perform 
fault far removed location manifested may take long time find fault 
notice analysis times need recursively follow cases 
basis situations imply search ffl assignment statement compute incorrect function 
ffl predicate expression compute incorrect function 
ffl assignment statement assign value wrong variable 
ffl desired assignment variable missing 
ffl desired predicate expression guarding statement missing 
ffl extraneous assignment program 
ffl extraneous predicate program 
inductive steps require recursive application cases ffl find dynamic reaching definition variable location 
ffl find predicate immediately enclosing statement 
fault localization may expedited analysis combined successive recursive steps 
mind revisit cases discussed 
case revisited value expression exp location incorrect possibilities ffl exists incorrect assignment wrong value computed propagated value exp transitive closure reaching definitions 
ffl assignment computation propagated value exp missing program 
ffl assignment computation propagated value exp executed 
ffl assignment computation propagated value exp got executed 
ffl assignment computation propagated value exp included program 
ffl assignment inside loop got executed incorrect number times necessary 
case revisited control incorrectly reached location possibilities ffl missing predicate enclosing location necessarily enclosing immediately may enclosing nesting levels 
ffl predicates enclosing location evaluated incorrectly 
case revisited control didn reach location possibilities ffl predicates enclosing evaluated incorrectly 
ffl predicates enclosing included program 
dynamic data slice case global analysis need find assignments computations propagated current value exp done transitive closure dynamic reaching definitions variables exp location 
call set assignments belong closure dynamic data slice respect expression location testcase 
know current value exp incorrect examining dynamic data slice find relevant assignment missing assignments computes wrong function 
similarly examining dynamic data slice check assignments shouldn slice vice versa 
case missing incorrect assignment localized fault 
case wrong assignment reached correct assignment reached step closure finding fault continue search case global analysis respect new location 
hand examining data slice suggest cases indicates error caused assignment data slice executed incorrect number times 
fault lies execution frequency assignment assignment 
means loop predicates enclosing assignments data slice faulty 
may resort local analysis described detect situations 
control slice cases global analysis need find predicates enclose location 
done transitive closure control predicates starting location 
call set predicates belong closure control slice location 
know control incorrectly reached location examine control slice check relevant predicate missing predicates evaluated incorrectly 
case localized fault 
case step closer finding fault predicate evaluated incorrectly computes incorrect function arguments function wrong value 
case fault case continue search case global analysis respect incorrect argument 
dynamic program slice note global analysis keep alternating data control slices localized fault 
times fault manifests indirectly levels indirection away fault 
situations may possible localize fault quickly determined closure relevant data control slices 
give set statements assignments predicates effect variable location question 
find value expression location incorrect find dynamic data slice 
assignment data slice find control slice 
predicate control slice find dynamic data slice reach situation new statements added set 
call set statements obtained dynamic program slice respect expression location 
similarly find control incorrectly reached location control didn reach location find control slice location 
predicate control slice find dynamic data slice 
assignment data slice find control slice situation reached new statements added 
call resulting set dynamic program slice respect location 
dynamic program slice really transitive closure data control slices respect expression location dynamic data control slice respect variable location question 
static slices just defined dynamic data slice may define static data slice respect variable location transitive closure static reaching definitions variable location 
notice defining control slice word dynamic front 
reaching definitions statement predicate immediately enclosing 
narrowing enclosing predicates occur run time 
control slice respect location remains static dynamic cases 
control incorrectly reaches statement program execution examine predicates enclosing statement hand desired statement reached program execution examine set predicates 
transitive closure relevant static data slices control slices gives static program slice respect variable location question 
static program slice respect variable location includes statements affect value variable observed location program executed testcase 
dynamic slice static program slice property executable program 
evaluates variable question identically original program testcases wei 
summary program slice may viewed closure corresponding data control slices 
data slice closure relevant data dependencies control slice gives closure control dependencies 
depending size complexity program may better examine data control slices examining closure program slice 
hand person debugging program completely familiar program code fault indirections removed manifestation examining program slice may expedite fault localization 
token person familiar program code fault indirections away manifestation best course may follow direct reaching definitions examine enclosing predicate 
prototype debugging tool spyder provides mechanisms allow local global analysis performed 
program slices provides facilities displaying data control slices direct reaching definitions 
may obtained static dynamic cases 
example shows static reaching definitions variable area line 
shows unique dynamic reaching definition variable occurrence second iteration enclosing loop testcase 
shows dynamic data slice sum line testcase 
note assignment line computes area right triangle included data slice triangles testcase right triangles 
suggests pursue case respect line 
shows corresponding static data slice 
shows control slice respect assignment line 
statement incorrectly reached second loop iteration program executed testcase enclosing predicate line evaluates incorrectly evaluates true false value variable class examined predicate incorrect instance 
suggests pursue case respect value class line 
shows dynamic program slice area line execution stopped second loop iteration testcase 
note erroneous assignment line included slice 
note assignment line computes area triangle included slice case computation area loop iteration affect iteration 
obtained dynamic program slice respect sum line assignments lines included slice computation area iteration affects final value sum 
shows corresponding static program slice 
static reaching definitions area line dynamic reaching definition area line second loop iteration dynamic data slice respect sum line testcase 
static data slice respect sum line 
control slice respect statement line 
dynamic program slice respect area line second loop iteration testcase 
static program slice respect variable area line 
fault localization chapters discussed various techniques find dynamic program slices 
dynamic slice helpful program debugging highlights statements program relevant erroneous behavior program 
may able identify fault simply examining dynamic slice may notice statement slice computes incorrect function may find statement expected included slice included vice versa 
oftentimes simply examining slice need carry investigation program behavior localize fault 
chapter discuss narrow search fault combining multiple dynamic slices 
combining dynamic program slices chapter mentioned program dicing lw attempts reduce size relevant program text examined combining multiple static slices 
naturally extend approach dynamic slices static slices get finer error localization information 
dynamic slice arguments program variable location testcase varying variable argument vary arguments testcase location program generate multiple dynamic slices approach combine 
section explore observation derive heuristics help localize fault 
varying testcase argument testcase program said error revealing testcase produces incorrect output executed dm called revealing testcase produces correct output 
difference dynamic slices times situation program works correctly testcase fails 
words error revealing testcase non error revealing testcase way proceed situation ask question program differently examine difference program behavior way find difference see dynamic program slices respect differ 
dynamic slice program respect faulty variable var program location loc error revealing testcase denoted dps var loc respect non error revealing testcase denoted dps var loc heuristic examine set statements dps var loc gamma dps var loc simplicity write dps delta delta delta gamma dps delta delta delta omitting arguments dps means values fixed fourth argument varies 
example consider program 
shows dynamic program slice respect sum line testcase recall testcase lengths sides triangles respectively 
program incorrectly evaluates value sum testcase error revealing testcase 
program executed testcase lengths sides triangles respectively value sum output line correct 
refer testcase testcase 
testcase non error revealing testcase 
shows dynamic program slice respect sum line testcase 
shows difference dynamic slices dps sum line testcase gamma dps sum line testcase 
examining difference case lead faster localization fault line compared examining complete dynamic program slice shown 
cousins cc proposed similar approach find basic blocks referred decision decision paths program control reaches program executed error revealing testcase reached program executed non error revealing testcase 
basic block may contain statements totally unrelated fault approach yields coarser error localization information compared 
subtract dynamic slice respect non error revealing testcase respect error revealing testcase may left empty set 
times set non empty may find fault statements difference set 
cases generally indicative situations ffl predicate program fault causes statements incorrectly included slice respect error revealing testcase causes statements correctly included slice respect non error revealing testcase 
extraneous statements slice get included difference set 
ffl fault loop predicate causing loop body execute incorrect number times case error revealing testcase causes dynamic program slice sum line testcase 
dynamic program slice sum line testcase 
dynamic program slice testcase minus testcase 
loop body execute correct number times case revealing testcase 
faulty loop predicate belongs slices included difference set 
ffl faulty assignment statement affects value variable question coincidentally computing correct value case non testcase unable shield fault case testcase 
faulty assignment belongs slices belong difference set 
cases instances coincidental correctness involving coincidentally correct evaluation faulty predicate third involving faulty assignment program executed non error revealing testcase 
situations may able find non error revealing testcases cause problem 
faults may impossible find non error revealing testcase cause coincidental correctness 
oftentimes fault may program fails testcase try 
faults may able find non error revealing testcase 
situations may able apply strategy outlined may able localize fault strategies discussed 
success strategy depends judicious selection non testcase strategy try find non testcase similar example similar involved equilateral triangle 
hand non testcase common error revealing testcase examining difference corresponding slices may meaningful 
examined 
example consider non error revealing testcase testcase sides triangle 
subtracted dynamic slice sum line testcase testcase get little reduction relevant code examined 
shows resulting set performing subtraction 
union dynamic slices strategy outlined subtracted dynamic slice respect non error revealing testcase respect error revealing testcase 
situation program test fails specific testcase works correctly testcases 
error revealing testcase non error revealing testcases nq case may able get reduction relevant code examined subtracted dynamic slices respect non error revealing testcases dynamic slice respect single error revealing testcase 
examine dps delta delta delta gamma dps delta delta delta example program mentioned consider error revealing testcase testcase lengths sides triangles respectively total testcases program error revealing testcases viz 
non error revealing testcases viz 

shows set resulting subtraction dynamic slice respect non error revealing testcase respect error revealing testcase 
subtract dynamic slices respect non error revealing testcases smaller set statements examine shown 
intersection dynamic slices non error revealing testcase hard find erroneous program relatively easy find error revealing testcase program 
error revealing testcases debugging strategy dynamic program slice testcase minus testcase 
dynamic program slice testcase minus testcase 
dynamic program slice testcase minus testcases 
examine intersection dynamic slices respect testcases 
examine dps delta delta delta dps delta delta delta error revealing testcases ep check intersection dynamic slices respect testcases 
examine dps delta delta delta may try intersection strategy able find non testcases program 
example consider error revealing testcase testcase lengths sides triangles respectively program mentioned 
shows intersection dynamic slices respect sum line testcases 
resulting set case lead relatively faster localization fault smaller dynamic slice respect testcases 
intersection strategy may lead reduction size relevant code examined depending nature fault 
set error revealing testcases set non error revealing testcases may obtain intersection dynamic slices respect error revealing testcases subtract dynamic slice respect non error revealing testcase intersection 
error revealing testcases ep non error revealing testcases nq may examine dps delta delta delta gamma dps delta delta delta example shows result subtracting dynamic slices sum line non error revealing testcases intersection shown 
intersection dynamic program slices sum line testcases 
result subtracting dynamic program slices sum line testcases intersection corresponding slices testcases 
varying variable argument far combining dynamic slices fixed arguments dynamic slice varied fourth argument 
fix arguments vary 
testcase program location may find value variable incorrect correct 
case debugging strategy subtract dynamic slice respect respect examine difference 
words examine dps delta var delta delta gamma dps delta var delta delta var denotes variable value observed erroneous var denotes variable value erroneous 
strategy dynamic analogue program dicing strategy proposed lyle weiser lw example consider program 
reads date month day year finds corresponding day year day week 
program fault line right hand side assignment performs addition subtraction 
consider testcase date entered month day year 
program incorrectly computes day week date monday friday 
correctly computes day year 
shows dynamic slice respect date day week line testcase shows dynamic program slice date day year location testcase 
shows result subtracting 
clearly difference lead faster localization fault line compared dynamic slice shown 
just generalized strategies discussed section considering testcases multiple testcases generalize strategy considering variables multiple variables 
subtracting dynamic slice respect correct variable incorrect may subtract dynamic slices correct variables dynamic slice dynamic program slice date day week line testcase month day year dynamic program slice date day year line testcase month day year result subtracting dynamic program slice date day year line testcase month day year corresponding slice date day week 
incorrect variable 
similarly observe values variables incorrect may check intersection dynamic slices respect variables 
varying location argument debugging program may observe value variable correct instance incorrect 
example may find variable modified inside loop correct value iteration variable assumes incorrect value iteration 
situation may want examine difference dynamic slices respect instances variable testcase 
instance variable question assumes erroneous value denoted loc assumes correct value denoted loc strategy examine dps delta delta loc delta gamma dps delta delta loc delta example shows dynamic slice respect area line loop iteration testcase shows corresponding slice second iteration 
testcase area computed correctly iteration incorrectly second 
shows result slice subtracted 
done sections generalize strategy subtracting dynamic slices multiple correct instances variable testcase incorrect instance variable testcase 
similarly generalized intersections dynamic slices respect multiple incorrect instances variable testcase 
varying program argument oftentimes program development encounter situation correct program executed testcase computes dynamic program slice area line loop iteration testcase 
dynamic program slice area line second loop iteration testcase 
result subtracting dynamic program slice area line loop iteration testcase corresponding slice second loop iteration 
correct value output variable var changes add new functionality 
modified program executed produces wrong value var situations debugging strategy examine changes especially portions changes affect value var facilitated obtaining difference dynamic program slice respect var testcase corresponding slice examine dps delta delta delta gamma dps delta delta delta course requires keep track correspondence statements old new program 
changes consist addition new statements deletion old statements simple modifications old statements correspondence easy keep 
changes complex moving statements modifying time correspondence statements programs may clear 
situations correspondence statements remains largely intact strategy useful 
prototype debugging tool spyder presently keep track correspondence statements versions program currently support strategy 
combining data slices program slice contains assignments predicate expressions 
difference program slices may contain assignments predicates 
relatively easy reason presence absence assignment statement difference set doing predicate expression may difficult 
suppose assignment statement dynamic slice var program error revealing testcase absent difference set obtained subtracting corresponding dynamic program slice respect non error revealing testcase slice means value computed contributed computation var case coincidental correctness contain fault 
suppose predicate dynamic program slice respect absent difference set mentioned 
mean contain fault 
may case incorrectly evaluated true case producing wrong output correctly evaluated true case possible outcomes evaluating predicate true false relatively easy faulty predicates achieve coincidental correctness 
may helpful examining differences dynamic program slices examined differences dynamic data slices 
find value var incorrect program execution testcase apply strategies discussed section substituting dynamic data slices place program slices 
examining resulting set able localize fault find assignment incorrectly absent resulting set 
case examine control slice assignment 
able identify fault predicate control slice able identify variable var predicate control slice wrong value 
repeat process respect var apply strategy fault localization program testcase 
step obtain dynamic data slice respect sum line 
shows slice 
know value sum printed correctly testcase 
obtain corresponding dynamic data slice respect testcase 
shows slice 
subtract data slice 
shows resulting set 
contains assignment line indicating far value sum concerned thing program testcase testcase assignment line 
examining assignment reveals computes area right triangle 
testcase contain right triangle means assignment incorrectly reached program execution 
examine control slice line shown 
find line reached predicate line evaluates true 
happens class incorrect value instance 
localized problem class having incorrect value line 
examine dynamic data slice class line shown 
find assignment line slice assignment incorrectly reached 
shows control slice line 
examining slice find assignment line reached predicate line evaluates true 
indicates value variables referenced predicate incorrect 
examining variables find value sqr incorrect 
shows dynamic data slice sqr 
examining data slice quickly isolate fault line 
summary chapter proposed strategies fault localization examining difference union intersection combination operations dynamic program data slices 
emphasized strategies heuristics guaranteed situations 
provide mechanisms useful debugging situations programmer effectively 
dynamic data slice sum line testcase 
dynamic data slice sum line testcase 
result subtracting dynamic data slice sum line testcase corresponding slice testcase 
control slice line testcase 
dynamic data slice class line testcase 
control slice line testcase 
dynamic data slice sqr line testcase 

execution backtracking steps debugging paradigm outlined chapter restore program state attained program execution reached earlier statement 
easily achieved debugging tool provided execution backtracking facility 
chapter outline approaches implement statement level execution backtracking 
consider section facility may implemented simple programming language 
section discuss additional language features handled approaches 
simple execution backtracking time program execution state program consists things values variables program time location program control 
executing statement causes program state transformed 
type transformation depends type statement 
simplicity consider simple language chapter consists assignment conditional loop input output read write statements compositions 
assume moment scalar variables expressions cause side effects 
assignment statement modifies program state new state identical previous state things value variable left hand side assignment may different control location modified successor statement 
predicates hand modify control location 
execution statement essentially causes kinds effects program state modifies control location may change values variables 
backtracking statement require way undoing effects 
effect modifying control location easily undone simply record execution history control locations sequence statements visited program execution 
undoing control location effect simply require traversing sequence opposite direction 
second effect viz changing values variables easily undone executing statement save current values variables modified statement 
undoing effect simply require restoring previous values saved 
section discuss execution history saving approach backtracking 
section show constraining backtracking particular way implemented efficiently 
execution history approach section associated def set node flow graph program 
nodes flow graph correspond simple statements assignments reads writes predicate expressions conditions statements program 
def set assignment statement consists variable left hand side assignment def set predicate expression empty set 
language permits expressions side effects def sets assignments predicates may contain variables 
def set read statement includes variables read statement write statement empty set 
henceforth refer read statements assignment statements 
able backtrack statement arbitrarily far back execution need record complete execution history statements corresponding previous values variables def sets 
backtrack statement restoring previously saved values def set variables starting current location going backwards statement encountered saved execution history 
example shows execution history program testcase annotated saved def set values 
program state execution temp 
wish backtrack execution just loop statement started execution restore values def sets starting execution history going backwards including entry 
program state temp just control reached loop statement 
note statement nested loop body executed times loop iteration corresponding entries statement execution history 
programs long running loops execution history program grow long 
number times loop iterates may depend run time input length execution history may bounded compile time 
space required record execution history corresponding def set variable values may allocated advance 
having space problem approach time inefficient 
backtrack statement loop backtrack individually iteration loop 
section outline different approach disadvantages 
structured backtracking approach just defined def sets assignment statements predicate expressions define def sets composite statements set variables values modified execution statement 
example def set loop consist variables modified loop body executed times 
read temp temp temp temp temp 
temp temp div temp gamma temp write program divide integers 



temp 
temp temp temp temp execution history program testcase saved def set values 
def sets composite statements computed def sets constituent assignment statements 
denote source statements boolean expression cond def sets composite statements may computed follows def def def def cond def cond def def cond def cond def def def cond def cond def example def set loop statement fq temp rg statement statement fr qg 
assignment statements save values variables def set composite statement just executing statement 
backtrack statement simply need restore previous values variables def set undoing effect iteration loop reverse order 
restrict backtracking may directly backtrack statement outside composite statement statement nested inside avoid space time inefficiency problems execution history approach outlined 
structured backtracking approach statement simple composite debugger allocates space save just instance values variables def set 
time control reaches statement debugger saves current values variables def set space 
time statement loop body gets executed current values variables def set overwrite previously saved values 
possible backtrack statement loop body earlier statement loop body current iteration possible directly backtrack previous iteration loop 
illustrate backtracking constrained consider program segment 
cond 


cond 



instances backtracking allowed structured backtracking iteration iteration gamma valid instances structured backtracking iteration note backtrack statement inside loop statement outside 
restrictions analogous followed structured programming included modern language standards disallowing jumps statement inside loop outside allowing breaks inside loop outside 
restriction backtracking complete statements unduly constraining 
sense similar encouraging structured execution backward direction 
analyzing effects statements reverse order easier logical user needs consider complete statement time 
needs backtrack statement inside composite statement statement outside backtrack composite statement execute forward desired statement 
structured backtracking approach longer need save execution history 
statement amount space required save values variables def set fixed space required may allocated advance 
section derive bounds space requirements structured backtracking approach 
bounds space requirements assignment statement nested levels deep variables modified belong def sets statements gamma composite statements nested assignment statement 
total number assignment statements program size change set ith assignment statement nesting level ith assignment statement simplicity assignment statement nested composite statement assumed level assignment statement single enclosing statement assumed level 
sum sizes def sets statements program 
theta theta max theta max ff max fi max ff represents maximum nesting level program fi represents size largest change set assignment statements program 
theta ff theta fi length program number source lines 
assignment statements program gamma composite statements program 
composite statements increase nesting levels statements maximum nesting level assignment statement program gamma 
ff gamma theta gamma theta fi fi theta theta gamma right hand side equation function find maximum differentiating respect equating derivative zero 
gives substituting value get theta fi theta theta theoretical worst case upper bound 
practice observed ff fi usually small constants 
denoting product ff theta fi get theta number assignment statements program bounded program length combining get theta usual case sum sizes def sets statements program order length program 
particular size independent running time 
extensions previous section simple programming language describe approaches implement execution backtracking 
section examine language features records arrays pointers procedures handled 
simplicity presentation treat function continuous function discrete variable discrete function maximum occurs dl 
records easy handle simply need treat field record separate variable 
handling arrays pointers requires 
assignment array element indirect assignment pointer pointer differs assignment scalar variable var exact address memory location modified assignment case fixed known compile time case 
easily overcome problem recording address contents memory location modified assignment just executed 
execution backtracked assignment restoring contents address saved 
records arrays pointers uniformly handled defining def sets terms memory cells done chapter case dynamic slicing 
just executing assignment def cell contents def cell saved 
backtracking assignment means restoring saved contents appropriate memory cell 
indirect assignment pointer appears loop address memory location assigned may vary iteration 
case precise def set loop determined compile time 
constructed run time time loop address contents memory cell assigned added def set loop 
def cell added def set loop simply ignored 
size def set loop case may bounded compile time 
space bounds derived section hold case indirect assignment treat size complex data structure modified incrementally multiple occurrences statement program execution 
backtracking procedure call outside execution history approach requires recreating stack frame call 
structured backtracking approach procedure calls treated just composite statements may backtrack procedure call outside 
side effects procedure call constitute def set call 
loop indirect assignment executed inside procedure def set procedure call updated appropriately 
recursion handled saving def sets statements inside procedure current stack frame procedure 
backtracking operations poses special problems 
system undo things directly control 
actions effects outside boundary system system general retract 
instance way save state line printer allow backup state 
possible approach handling operations involves buffering operations similar operation programming language standard library 
way handle file record current offset file pointer start file just executing file statement 
backtracking read file entails restoring file pointer saved offset 
spyder prototype debugging tool employs technique system call unix 
summary chapter outlined approaches implementing execution backtracking 
prototype debugging tool spyder currently supports backtracking execution history approach outlined section just forward program execution suspended breakpoint encountered spyder execute program reverse direction continue executing backwards breakpoint reached 
way stopped breakpoint find error occurred earlier location wish examine program state location simply need set breakpoint execute backwards 
backward execution stops breakpoint spyder restored program state execution reached point 
conventional debuggers provide facilities step program execution statement statement 
spyder provides back stepping facility user step back program statement time 
example consider program testcase 
program execution stopped line discover value sum incorrect may set breakpoint line start backward execution 
loop iterated times testcase second iteration reached backward execution 
execution stops line program state exactly execution stopped normal execution second iteration loop 
examine value sum get value just assignment executed shown 
find previous value sum correct may conclude current value area incorrect 
wanted backup location previous iteration simply need continue backward execution 
breakpoint encountered iteration backward execution suspended reaches breakpoint line previous iteration 
shows example backtracking 
bottom output window shows tool output sequence debugging commands 
select testcase program execution automatically stopped executable statement line case 
examine value array time find elements value 
set breakpoint line continue program execution 
execution stops breakpoint line reached 
examine value array find expected elements array values respectively element zero execution stopped just assignment line executed 
may set breakpoint line start reverse execution 
reverse execution stops encountering breakpoint backing statement line 
examine value array notice elements values restored zero 
continue reverse execution control stops reaching start program line 
value element array restored back zero initial value 
continue program execution forward direction breakpoint line 
values elements respectively zero 
tool screen backtracking line line execution backtracking line line line 
spyder prototype implementation dissertation figures examples various types program slices 
figures screen dumps prototype debugging tool spyder action 
chapter discuss functions provided spyder order support slicing guessing backtracking paradigm debugging 
briefly discuss approach implement spyder 
tool screen shows snapshot spyder screen debugging session 
screen divided windows tiled vertically order top bottom ffl file label window ffl source window ffl commands window ffl output window ffl testcase label window file label window simply displays name source file currently displayed source window 
source window provides small viewing window source code program debugging 
contents window scrolled vertical scroll bar left source window 
vertical bar left scroll bar displays source line numbers 
line numbers snapshot spyder screen debugging session 
scroll source code 
slices displayed source window highlighting lines belong slice reverse video 
icon shape sign displayed left source line indicates breakpoint currently set 
multiple icons indicate multiple breakpoints set time 
arrow icon shape right pointing solid arrow left source line indicates control currently stopped line 
arrow icon displayed time 
commands window consists rows buttons issuing various slicing backtracking traditional debugging commands discussed section 
output window commands entered clicking buttons commands window displays spyder response commands notably print command 
testcase label window indicates id testcase currently selected 
dynamic slicing commands executed respect testcase 
spyder commands functions supported spyder classified categories ffl selection setting commands ffl slicing commands ffl fault guessing commands ffl backtracking commands ffl traditional debugging commands selection setting commands commands fall category corresponding toggle buttons top row commands window corresponding button labeled testcase bottom row 
exactly toggle buttons top row labeled static analysis approximate dynamic analysis exact dynamic analysis selected time indicating current slicing criterion selected 
buttons correspond static slicing dynamic slicing approach dynamic slicing approach discussed chapter respectively 
criterion selected specifies slices obtained buttons labeled slice slice slice defs second row static slices approximate dynamic slices exact dynamic slices 
case toggle buttons selected need specify id testcase dynamic slices obtained respect testcase 
done button labeled testcase bottom row commands window 
button clicked dialogue window pops prompting user specify testcase 
specified testcase current testcase remains new testcase selected 
testcase label window updated appropriately time testcase selection 
testcases specified separate tool called tcgen 
tool invoked executes program object code captures input supplied program saves testcase 
assigns id testcase refer current testcase selection process mentioned 
slicing commands slicing functions spyder provided buttons middle row commands window labeled slice slice slice defs 
button labeled slice obtain program slices 
buttons labeled slice slice obtain data control slices discussed chapter respectively 
button labeled defs obtain immediate reaching definitions variables valued expressions 
slices obtained static approximate dynamic exact dynamic depending toggle buttons row commands window currently selected 
variable argument commands specified selecting appropriate text source window mouse 
text selected clicking dragging mouse 
location argument specified implicitly case static approximate dynamic slicing location associated current selection source window case exact dynamic slicing location control currently stopped indicated right pointing arrow icon 
testcase argument case approximate exact dynamic slices specified testcase button discussed 
fault guessing commands spyder provides mechanisms guessing regions program contain fault combining slices various ways discussed chapter 
slice currently displayed source window saved accumulator clicking button labeled save 
button labeled union performs union currently displayed slice saved accumulator stores result accumulator 
adds currently displayed slice accumulator 
currently displayed slice remains unaffected 
button labeled inter performs intersection union similar fashion 
button labeled differ takes difference accumulator currently displayed slice stores result accumulator 
subtracts currently displayed slice accumulator 
wishes subtract saved slice currently displayed swap slices swap button differ button 
contents accumulator displayed time show button 
command replace currently displayed slice saved accumulator 
remain unaffected 
currently displayed slice cleared time clear button 
accumulator unaffected command 
wishes clear accumulator clearing display clear command storing accumulator save command 
backtracking commands spyder provides execution backtracking functions backup 
clicking backup button starts execution backtracking 
backtracking continues breakpoint reached control returned debugger program state restored time control reached location 
button labeled provides reverse single stepping 
currently spyder uses execution history approach execution backtracking discussed chapter execution backtracked locations inside composite statements 
execution backtracked procedure calls outside doing requires corresponding stack frame recreated 
back stepping procedure call restores program state state just procedure invoked 
traditional debugging commands mentioned earlier slicing guessing backtracking paradigm works conjunction traditional interactive debugging commands 
reason implemented basic traditional debugging functions breakpoints single stepping examining variable values spyder 
breakpoint easily set selecting text corresponding line source window mouse clicking button 
clicking delete button removes breakpoint currently selected line set 
values variables expressions printed selecting corresponding text source window clicking print button clicking continue button resumes forward execution 
execution single stepped forward direction step command 
execution resumed program run command 
debugging session spyder terminated clicking quit button 
values printed current values respect location control currently stopped respect location associated selection screen 
standard debugging commands supported spyder goal demonstrate usefulness slicing guessing backtracking functions implemented bare minimum functions needed 
implementation spyder built versions gnu compiler gcc sta gnu source level debugger gdb sta 
mentioned earlier intent write production quality tool demonstrate feasibility usefulness mechanisms 
decided modify existing compiler debugger write new system 
chose gnu tools availability ability run different hardware platforms 
choice led problems allowed rapidly develop prototype full ansi modifications compiler modified gcc produce program dependence graph object code program 
required making changes parser 
modified parser apart doing normal functions builds program flow control dependence graphs syntax directed manner described chapter 
graphs share set nodes different sets edges 
node annotated def sets consisting valued expressions defined respectively node 
parsing complete flow graph traversed compute data dependencies nodes third set edges belonging data dependence graph created 
aggregate graph consists flow control data dependence subgraphs written 
graph read debugger find various static slices 
modifications debugger gdb modified read aggregate graph consisting flow control data dependence subgraphs produced modified gcc 
code added traverse aggregate graph find static reaching definitions static data control program slices 
support dynamic slicing execution backtracking gdb modified record execution history program executes 
execution history consists list nodes aggregate graph appended order visited program execution 
entry list constitutes node dynamic dependence graph 
node annotated def sets consisting memory cells defined node respectively 
contents memory cells belong def sets saved node 
modified gdb captures information setting numerous transparent breakpoints program user see 
associates appropriate callback functions transparent breakpoints 
callback functions perform recording execution history determining def memory cells saving contents def memory cells def set annotations corresponding nodes static program dependence graph 
callback functions associated transparent breakpoint performed program execution resumed automatically 
program execution stops breakpoint reached newly built portion execution history traversed create dynamic data control dependence edges nodes newly added dynamic dependence graph 
dynamic dependence graph traversed find dynamic reaching definitions dynamic data control program slices 
perform execution backtracking execution history traversed reverse order previously saved contents memory cells def sets nodes encountered restored corresponding memory cells 
backtracking stopped node reached breakpoint currently set 
segments execution history may correspond program execution inside procedures 
care taken backtracking execution segments 
def sets nodes segments may contain memory cells belonged stack frame procedure may longer accessible 
contents memory cells restored backtracking currently support backtracking procedure outside 
def sets purpose finding dynamic slices 
major modification gdb provide window mouse user interface slices displayed highlighting corresponding source lines 
added hooks system traditional debugging functions supported spyder setting breakpoints performed simply selecting appropriate text source window mouse clicking appropriate command buttons 
athena widget set xt toolkit window system version release build interface 
summary chapter discussed prototype debugging tool spyder explicitly supports slicing guessing backtracking paradigm 
discussed various functions provided spyder possible programmer follow paradigm 
briefly discussed approach took quickly implement spyder 

directions debugging complex difficult activity 
person debugging program determine cause location program failure 
failure may manifested far away fault textually terms source lines temporally terms execution time 
providing facilities increase ability programmer identify location nature fault involved lead efficient debugging 
dissertation debugging paradigm prototype tool attempt provide precisely facilities 
experience paradigm tool far convinced quite useful applied properly result significant savings debugging time 
panacea 
provide useful mechanisms user effectively 
chapter list limitations techniques discuss lessons learned implementation conclude dissertation ideas research directions 
limitations paradigm chapter mentioned fault manifests directly indirectly terms data control inconsistency 
true requires programmer translates externally visible symptom fault internal program symptom terms data control problem techniques described may 
translation may easy 
example external symptom value program output incorrect corresponding internal symptom value variable expression incorrect print statement may easily determinable 
external symptom missing value list programmer may traditional debugging facilities find corresponding internal symptom techniques described may 
slices dependences multiple occurrences statement explicit 
example statement inside loop body included slice value computes iteration depends value computes previous iteration dependence explicit slice occurrences grouped displaying slice 
execution backtracking limitations 
backtracking statement requires side affects executing statement undone 
mentioned system undo things control 
executing statement effects outside boundaries program operating system outside agents affected cooperate debugging tool enable execution backtracking 
situations executing statement may effects outside controlling environment may feasible undo 
situations may accept partial backtracking resort program 
programmer techniques aware limitations 
limitations restrictive preclude 
contrary experience shown despite limitations techniques extremely useful quickly isolating program faults 
limitations current implementation mentioned built prototype tool top existing compiler debugger 
choice enabled quickly build working system experiment proposed techniques gain insight usefulness enforced limitations supported 
example gdb associate breakpoints expressions statements associate source lines 
transparent breakpoints capture information required dynamic slicing backtracking limitation requires correspondence smallest syntactic units slicing backtracking assignments predicates source lines 
current implementation requires source line contains assignment predicates assignments appear different lines 
program follow conventions results backtracking slicing may unpredictable 
course easy provide preprocessor converts program canonical form acceptable tool 
may noted limitations current implementation techniques 
limitations arose compiler debugger originally written support techniques 
arise implemented context wrote compiler debugger 
lessons learned implementation research faced question build compiler debugger order implement techniques proposed existing tools 
alternative rejected meant significant investment time energy building things focus research 
having decided second alternative question existing compiler debugger 
alternative build prototype top couldn lack availability public domain 
gnu tools hand factors favor ffl source code tools freely available ffl quickly portable multiple hardware platforms ffl support ansi factors ffl documentation implementation available ffl tools big terms number source lines ffl undergoing evolution frequent new releases bug fixes 
despite negative factors believed positive factors strong warrant 
hindsight certainly regret decision gnu tools 
believe rich functionality gdb important factor enabling quickly develop prototype 
decision modify compiler produce instrumented code gather runtime information necessary dynamic slicing backtracking debugger probe program execution collect information 
approaches advantages disadvantages 
decided approach believed easier implement experiment 
side benefit approach delaying instrumentation probes debugging time possible interactively control parts program instrument instrument 
approach possible start instrumentation static slicing techniques narrow search fault extent possible smaller region program 
successively increase program instrumentation approximate exact dynamic slicing techniques successively smaller smaller program regions 
way don pay cost associated instrumentation time 
debugged particular region procedure module program segment possible instruct debugger region 
approach mean pay cost instrumentation program execution repeatedly recompile program lesser lesser instrumentation 
consequence decision debugger perform instrumentation collect necessary runtime information lot time spent system context switching debugger processes 
processes heavyweight processes unix context switch process costly operation notice significant slow program execution long running programs constant context switching 
systems provide lightweight processes fast context switches overhead substantially smaller 
approach discussed paragraph restrict context switching small regions 
promising approach reduce context switching overhead debugger patch object code debugging process instructions necessary logging information required dynamic slicing backtracking purposes kra dkm 
directions conclude dissertation listing ideas extending preliminary thoughts research directions 
fault prediction heuristics chapter discussed heuristics combining multiple dynamic slices certain ways 
success heuristics depends judicious selection criteria generate slices combined 
selection usually programmer knowledge program behaved various testcases program testing 
promising research direction investigate tool capture wealth information generated testing recommendations criteria information 
user interfaces spyder uses simple user interface display slices program source displayed window source lines belonging slice highlighted reverse video 
instance fraction program visible source window 
wants examine portion program currently visible manually scroll text window 
interface may sufficient small programs obviously suitable large programs 
important line research investigate display slices large programs thousands lines code 
possible approach interface displays slices hierarchical manner 
example top level slice may simply consist names relevant modules affect chosen slicing criterion 
module expanded show level slice module 
example may simply consist names relevant functions procedures module 
procedure function turn expanded reveal corresponding intra procedural slice 
previous section mentioned limitation slices show inter occurrence dependences statement 
way overcome limitation construct interface multiple occurrences statement grouped 
interface may disadvantages traces may flood user information 
way handle combination interfaces 
extensions domains mentioned chapter scope research included examining proposed debugging paradigm context sequential procedural programming languages pascal obvious step examine techniques described extended parallel distributed programs programs written language domains functional logical object oriented programming languages 
idea dynamic slicing particularly appealing context parallel programs techniques static analysis dynamic analysis face problem exponential growth number possible state transitions parallel program 
dynamic analysis analyze events occur order occurred possible events orderings 
course aware dynamic instrumentation parallel program may modify timing characteristics possibly shielding timing related faults program 
limitation prevent exploring significant advantages techniques 
similarly idea dynamic slicing appealing object oriented programs simple reason object oriented program heavily relies dynamic binding messages sent object methods implement may message handlers message class hierarchy object 
dynamic slicing highlight relevant code handlers possible handlers 
dynamic slicing advantage case logic programs may clauses defining predicate logic program dynamic slicing analyze occurred unification analyzing possibly infinite search space 
applications research direction investigate put information gathered slicing backtracking uses debugging 
possibility examine perform fly code optimizations dynamic information gathered 
possibility investigate cases methods find static slices provide overly conservative information including program slice program unconstrained pointers union dynamic slices respect judiciously selected set testcases provide estimate corresponding static slice 
approach may useful program maintenance regression testset may available 
bibliography bibliography ab 
validation verification testing computer software 
acm computing surveys june 
acs james archer jr richard conway fred schneider 
user recovery reversal interactive systems 
acm transactions programming languages systems january 
am evan adams steven muchnick 
window symbolic debugger sun stations 
software practice experience july 
ans ansi ieee 
ieee standard glossary software engineering terminology 
ieee std ieee new york 
agrawal eugene spafford 
bibliography debugging backtracking 
acm software engineering notes april 
bal balzer 
extendible debugging monitoring system 
afips proceedings spring joint computer conference volume pages new jersey 
afips press 
bc jean francois bernard carr 
information flow data flow analysis programs 
acm transactions programming languages systems january 
bea bert 
vax debug interactive symbolic multilingual debugger 
proceedings software engineering symposium high level debugging pacific grove ca march 
acm sigsoft sigplan 
software engineering notes august sigplan notices august 
boe boehm 
software engineering economics 
prentice hall englewood cliffs nj 
bro brown 
algorithm animation 
mit press cambridge ma 
bs brown sedgewick 
techniques algorithm animation 
ieee software pages january 
car thomas 
debugger 
journal systems software december 
car thomas 
feel pi 
proceedings winter usenix conference pages denver january 
cc fun ting chan chen 
aida dynamic data flow anomaly detection system pascal programs 
software practice experience march 
cc james larry cousins 
automatic software fault location decision decision path analysis 
proceedings national computer conference pages 
cf robert cartwright matthias felleisen 
semantics program dependence 
proceedings acm sigplan conference programming language design implementation portland june 
acm sigplan 
sigplan notices july 
cou deborah coutant 
doc practical approach source level debugging globally optimized code 
proceedings sigplan conference programming language design implementation atlanta ga june 
acm sigplan 
sigplan notices july 
cwz david chase mark wegman kenneth zadeck 
analysis pointers structures 
proceedings sigplan conference programming language design implementation white plains new york june 
acm sigplan 
sigplan notices june 
de ducasse anna maria emde 
review automated debugging systems knowledge strategies techniques 
proceedings tenth international conference software engineering pages singapore april 
ieee 
dij dijkstra 
discipline programming 
prentice hall englewood cliffs nj 
dkm richard demillo edward aditya mathur 
compiler integrated program mutation 
proceedings fifteenth annual computer software applications conference 
ieee september 
dlp demillo lipton perlis 
social processes proofs theorems programs 
communications acm may 
dm richard demillo aditya mathur 
software artifacts evaluate effectiveness mutation analysis detecting errors production software 
technical report serc tr software engineering research center purdue university west lafayette march 
demillo mccracken martin 
software testing evaluation 
benjamin cummings publishing menlo park ca 
dun kevin dunlap 
debugging dbx 
unix programmers manual supplementary documents 
berkeley software distribution computer science division university california berkeley ca april 
fb stuart feldman brown 
igor system program debugging reversible execution 
proceedings workshop parallel distributed debugging madison wi may 
acm sigplan sigops 
sigplan notices january 
fet fetzer 
program verification idea 
communications acm september 
fo lloyd leon osterweil 
data flow analysis software reliability 
acm computing surveys september 
fow jeanne ferrante karl ottenstein joe warren 
program dependence graph uses optimization 
acm transactions programming languages systems july 
gl keith gallagher james lyle 
program decomposition scheme applications software modification testing 
proceedings second annual hawaii international conference system sciences volume ii software track pages january 
gou gould 
psychological evidence people debug computer programs 
international journal man machine studies january 
hen john hennessy 
symbolic debugging optimized code 
acm transactions programming languages systems 
hoa hoare 
axiomatic basis computer programming 
communications acm october 

functional program testing analysis 
mcgraw hill new york 
hpr susan horwitz phil pfeiffer thomas reps dependence analysis pointer variables 
proceedings sigplan conference programming language design implementation portland june 
acm sigplan 
sigplan notices july 
hpr susan horwitz jan prins thomas reps integrating noninterfering versions programs 
acm transactions programming languages systems july 
hr jr hartley rogers 
theory recursive functions effective computability 
mcgraw hill new york 
hrb susan horwitz thomas reps david 
interprocedural slicing dependence graphs 
acm transactions programming languages systems january 
hua huang 
detection data flow anomaly program instrumentation 
ieee transactions software engineering se may 
iso yuji ono 
visual debugger 
ieee software may 
js johnson soloway 
knowledge program understanding 
ieee transactions software engineering march 
kat 
sdb symbolic debugger 
unix programmer manual 
kuck kuhn padua wolfe 
dependence graphs compiler optimizations 
conference record eighth acm symposium principles programming languages pages williamsburg va january 
acm sigplan 
kl bogdan korel janusz laski 
dynamic program slicing 
information processing letters october 
kl bogdan korel janusz laski 
stad system testing debugging user perspective 
proceedings second workshop software testing verification analysis pages banff canada july 
acm 
kl bogdan korel janusz laski 
dynamic slicing computer programs 
journal systems software november 
kl bogdan korel janusz laski 
algorithmic software fault localization 
proceedings fourth annual hawaii international conference system sciences volume ii pages 
kra edward 
compiler integrated software testing 
phd thesis department computer sciences purdue university west lafayette 
ld london 
animating programs smalltalk 
ieee computer pages august 
lh larus hilfinger 
detecting conflicts structure accesses 
proceedings sigplan conference programming language design implementation 
acm sigplan july 
sigplan notices july 
los ott smith 
relationship program complexity slice complexity debugging tasks 
proceedings compsac 
ieee 
lst david luckham sriram sankar takahashi 
dimensional pinpointing debugging formal specifications 
ieee software pages january 
luk 
understanding debugging programs 
international journal man machine studies february 
lw james lyle mark weiser 
automatic program bug location program slicing 
proceedings second international conference computers applications beijing china june 
mb bourne 
tutorial adb 
unix programmers manual 
mc barton miller jong deok choi 
mechanism efficient debugging parallel programs 
proceedings sigplan conference programming language design implementation atlanta ga june 
acm sigplan 
sigplan notices july 
mh charles mcdowell david helmbold 
debugging concurrent programs 
acm computing surveys december 
moh thomas moher 
provide process visualization debugging environment 
ieee transactions software engineering june 
mth robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge ma 
nr randell editors 
software engineering 
scientific affairs div nato brussels belgium january 
ronald olsson richard crawford wilson ho christopher wee 
sequential debugging high level abstraction 
ieee software pages may 
leon osterweil lloyd 
dave validation error detection documentation system fortran programs 
software practice experience 
oo karl ottenstein linda ottenstein 
program dependence graph software development environment 
proceedings acm sigsoft sigplan symposium practical software development environments pa april 
acm sigsoft sigplan 
sigplan notices may 
ot ott 
relationship slices module cohesion 
proceedings eleventh international conference software engineering 
ieee may 
par parnas 
software aspects strategic defense systems 
communications acm december 
pc andy podgurski lori clarke 
formal model program dependences implications software testing debugging maintenance 
ieee transactions software engineering september 
rw charles rich waters 
programmer apprentice research overview 
ieee computer pages november 
ry thomas reps yang 
semantics program slicing 
technical report tr computer science department university wisconsin madison wi june 
sch jacob schwartz 
overview bugs 
randall editor debugging techniques large systems pages 
prentice hall cliffs nj 
sd dennis 
flit interrogation tape symbolic utility tx 
memo dept engineering massachusetts institute technology july 
sel 
rewriting semantics program dependence graphs 
conference record sixteenth acm symposium principles programming languages pages 
acm january 
sev rudolph 
knowledge program debugging systems 
ieee software may 
sha ehud shapiro 
algorithmic program debugging 
mit press cambridge ma 
si 
linked list visualization debugging 
ieee software pages may 
kamkar peter fritzson 
semi automatic bug localization software maintenance 
proceedings ieee conference software maintenance san diego ca november 
ieee 
sta richard stallman 
gdb manual third edition gdb version 
free software foundation cambridge ma october 
sta richard stallman 
porting gnu cc version 
free software foundation cambridge ma january 
robert william thompson paul johnson 
knowledge fault localization debugging 
proceedings software engineering symposium high level debugging pacific grove ca march 
acm sigsoft sigplan 
software engineering notes august sigplan notices august 
sw saunders wagner 
line debugging systems 
proceedings ifip congress volume pages 
tei warren teitelman 
automated programming programmer assistant 
afips proceedings fall joint computer conference volume pages new jersey 
afips press 
tei warren teitelman 
interlisp manual fourth edition 
xerox palo alto research center palo alto ca 
tr tim teitelbaum thomas reps cornell program synthesizer syntax directed programming environment 
communications acm september 
ven venkatesh 
semantic approach program slicing 
proceedings sigplan conference programming language design implementation toronto ontario canada june 
acm sigplan 
sigplan notices june 
wei mark weiser 
programmers slices debugging 
communications acm july 
wei mark weiser 
program slicing 
ieee transactions software engineering se july 
zelkowitz 
reversible execution diagnostic tool 
phd thesis dept computer science cornell university january 
marvin zelkowitz 
perspectives software engineering 
acm computing surveys june 
zellweger 
interactive source level debugging optimized programs 
technical report csl xerox palo alto research center palo alto ca may 
vita vita agrawal born june india 
received junior high school education bal india high school education public school india passed secondary school senior school certificate examinations respectively 
placed india merit lists awarded gold securing highest marks school exams 
pursued undergraduate studies institute technology science bits india obtained master science technology degree computer science 
received gold medal securing highest cumulative gpa scale achievement history institute 
graduating bits worked division cmc india year starting graduate studies purdue university august 
received master science doctor philosophy degrees computer science purdue respectively 
purdue received purdue university fellowship years awarded maurice halstead award software engineering 
