program comprehension tool requirements industrial environment von mayrhauser vans dept computer science dept computer science colorado state university colorado state university fort collins fort collins major portion maintenance effort spent understanding existing software 
integrated code comprehension model experiences industrial setting 
audio taped think aloud reports investigate integrated code comprehension model works industrial maintenance activities ranging code fixes enhancements code leverage reuse 
analyze tapes information needs maintenance activities derive tool capabilities accordingly 
significant portion maintenance effort involves code comprehension process 
typical tasks require understanding include troubleshooting code leverage reuse modification program enhancement 
step satisfying maintenance engineer information needs define model programmers understand code 
literature provides approaches comprehension cognitive models emphasize cognition program functional approach control flow approach emphasizes program works 
chapin software maintenance life cycle divides maintenance sub tasks depending type maintenance adaptive perfective corrective leveraging reusing code 
activity objective presumably effective method understanding code complete tasks 
existing cognition literature states cognitive results best code systematically understood level thorough detail 
large scale software feasible desirable 
need better model understand code cognition industrial setting 
investigated existing comprehension models soloway ehrlich top comprehension model pennington controlflow functional program understanding models bottom comprehension model 
model contains comprehension process information knowledge input processes mental representation program 
significant limitation models validation experiments done small programs 
soloway ehrlich experiments programs lines pascal code 
pennington experiments programmers studied line programs 
time requirements imposed artificial restrictions comprehension process experiments 
industry large scale programs prevalent focus maintenance activities 
observed maintainers frequently switch top bottom comprehension 
requires model includes types understanding processes 
reason believe cognition maintenance reverse engineering activity re builds existing design higher level model code design task 
guindon shown designers frequently switch levels detail design design progresses 
expect similar happen code cognition 
report describes integrated code comprehension model combining approaches 
rist programs complex construction mental representation program needs topdown functional bottom control flow understanding 
additional factors consideration model high level programmer expertise focus maintenance tasks industrial software model classification maintenance task 
section describes integrated model detail 
section explains experimental method 
section describes observations protocol analysis results 
describes need program understanding tools integrated model 
section lists tool capabilities derived observed cognition activities 
argue industrial experience integrated code comprehension model points need tools support cognitive process impose process programmers justified validated cognition model 
integrated model building blocks define comprehension model detailed identify specific maintenance tasks task sequences 
second step identifies information requirements tool capabilities task 
existing program understanding models agree comprehension proceeds top bottom combination 
observations indicate comprehension involves topdown bottom activities 
soloway ehrlich model forms basis top component domain model pennington model inspired program situation models 
integrated code comprehension model consists major components program model situation model top model domain model knowledge base 
comprehension processes 
fourth necessary successfully building models 
program situation top domain model building processes construct understanding code 
comprehension processes may activated processes 
beacons goals hypotheses strategies determine dynamics cognitive tasks switches models 
process component contains internal representation mental model program understood 
representation differs level abstraction model 
find strategy build internal representation 
knowledge base furnishes process information related comprehension task 
stores new inferred knowledge 
top model program understanding typically invoked comprehension process code type code familiar 
top model domain model represents knowledge schemas application domain 
example domain model operating system contain knowledge components os memory management process management os structure interact 
knowledge takes form specialized schemas including design pros cons come serve versus round robin scheduling 
obviously new os easier understand maintenance engineer knowledge 
domain knowledge provides motherboard specific product knowledge integrated easily 
lead effective strategies guide understanding understand high paging rates need understand process scheduling paging algorithms implemented system limits number pages allocated processes 
code understood completely new programmer pennington mental representation programmers build control flow abstraction program called program model 
example operating system code may understood determining control flow modules 
may select module content analysis scheduling model 
may implementation doubly linked list 
code representation part program model 
abstraction scheduling queue doubly linked list part situation model representation 
program model representation exists situation model developed 
representation built bottom uses program model create data flow functional abstraction 
integrated model assumes maintenance engineers unfamiliar domain start building program model 
assume full program model built abstracting situation domain level create cognitive overload software products ones saw professionals lines code 
expect abstraction program model information situation domain level helps programmer remember program works 
sub models may evoked time comprehension process 
programmer may recognize clues called beacons code indicating common task sorting 
beacon index knowledge text component knowledge 
beacon leads hypothesis sort performed switch top model 
programmer generates sub goals support hypothesis searches code clues support sub goals 
search section unrecognized code programmer jumps back building program model 
illustrates relationships sub models related knowledge 
definition integrated model allows refinement terms tasks tasks sequences comprehension processes 
find task strategies systematic bottom opportunistic top situation model systematic opportunistic task strategies 
systematic approach applies systematic order understanding code comprehension line time 
opportunistic approach studies code haphazard fashion logical order understanding 
littman programmers systematic approach comprehension successful modifying code understood programmers took opportunistic approach 
systematic strategy better safer unrealistic reasonably large programs 
just expect fully systematic approach understanding large scale code 
disadvantage opportunistic approach understanding incomplete code modifications understanding may error prone 
writing code designed opportunistic understanding solution problem 
building tools help opportunistic understanding error prone 
program model code completely new programmer pennington mental rep beacon may characteristic pattern value switches 
may name function qsort 
program model micro structure macro structure short term beacons situation model low level mappings mappings high level schema plan current mental representation program understanding process opportunistic rules discourse strategic plans tactical plans implementation 
control primes program text structure problem real world plan knowledge functional structures structures program model top structures situation model short term memory match documents documents code read memory documents beacons bottom opportunistic read process 
code comprehension model level rules programming plans plan knowledge knowledge 
algorithms 
control sequence 
data structures 
data flow slices 
syntax domain knowledge knowledge knowledge match process systematic top systematic bottom program model model code plans discourse knowledge domain resentation built control flow abstraction program program model 
vessey developed model debugging identified tasks mapped program model 
tasks include 
reading comments related documents 
micro structure current focus comprehender examines module text sequence 
logical micro structure development defined understanding statements interrelationships 

macro structure current focus comprehender examines module control flow sequence 
macro structure consists abstracted chunks micro structure components identified label structured correspond control flow program text 
analyzing module control flow sequence reasonable code examined building control flow abstraction part program model typically reside physically sequence 
examining control flow implies microstructure constructed known surrounding code control flow thread meaningfully followed 

data structures examined 

data slicing 
involves tracking changes variable contents program execution 
tasks constitute matching portion program model 
knowledge base matching process 
specific datastructure knowledge necessary examine datastructures code 

step involves chunking learned information simultaneously storing current mental representation long term memory knowledge base 
jump situation model possible 
illustrate program model building operating system process scheduling example sections code take job ready queue put running state monitor elapsed time remove job time quantum expired recognized abstracted label roundrobin scheduler 
information part situation model 
top model koenemann robertson show program comprehension goal oriented hypothesis driven problem solving process 
top model program understanding normally invoked understanding application area familiar 
instance suppose expert programmer specialty operating systems asked maintain operating system seen 
expert immediately decompose new system elements knows implemented code process manager file manager manager memory manager 
decomposed process management includes interprocess communication process scheduling 
process scheduling implemented round robin shortest job priority scheduling expert operating systems programmer continues top recognizes block code case precise process scheduling algorithm 
necessary re learn algorithm line line 
engineer recognize appropriate code exists 
tasks identified model map topdown element integrated model 
top understanding process consists 
gaining high level overview 

determining program segment examine 

determining relevance code segment current mental representation hypothesis 

generating revising hypothesis 
programmer generates hypotheses functionality program segments consideration scanning code 
jump situation model building occurs hypothesis confirmed 
situation model situation model constructed mapping functional knowledge acquired opportunistic understanding high level plans 
alternatively built bottom mappings program model form lower level abstractions actual program code 
knowledge structures model reflect real world knowledge grouped different domains pennington plan knowledge situation model 
knowledge domains brooks knowledge domains 
example domain level may picture process control block pcb types information contain 
situation model pcb may represented table 
program model level see structure updated code 
actual os modules program level recognized abstracted information situation model level 
knowledge structures knowledge base known long term memory usually organized schemas 
large triangle represents knowledge base 
schemas grouped partitions specifically related comprehension processes 
situation model structures associated situation model program model structures program model building top structures applied topdown construction 
example knowledge distinctive algorithms situation model information data structures program model building process knowledge objects real world domain information typically situation model 
specifically pennington text structure plan knowledge constructing program model 
soloway ehrlich strategic tactical implementation plans rules programming discourse developing top view program 
knowledge base acts repository new knowledge gained 
associate newly acquired knowledge corresponding model 
method model definition step model validation analysis experimental results 
audio taped sessions transcribed 
participants participants professional maintenance programmers working large size code lines code 
classified domain language experts domain experts language experts 
distinguished levels expertise types maintenance tasks accumulated knowledge code session started 
maintenance engineers considered experienced peers willing participate study 
gathered wide variety cognitive behaviors 
purpose explanation results explain cognition behavior participants 
prior programming session engineers asked find maintenance task included code comprehension component 
sessions involved debugging activities simple bug fix second debugging enhancement 
industrial perspective relatively small lines code 
compared existing cognition experiments large 
recorded hour session transcribed analysis 
engineers statements studied high level verification integrated model identification information needs 
debugging session involved fixing bug customer 
engineer just assumed responsibility system familiar domain program 
studied bug reports talked engineer responsibility system previously 
engineer lack domain expertise characterized session 
session part testing phase enhancement 
engineer expert operating system working 
language expert 
previously implemented enhancement operating system process testing enhancement bugs 
procedure participants asked think aloud working 
audio taped 
sessions typically hours long 
understand large scale software product 
decided find participants varying degrees prior experience code give widest degree coverage code comprehension process 
audio tapes transcribed 
protocol analysis divided 
enumeration cognitive activities relate integrated cognition model section 
analyzed possible new activities interactions model components 

segmentation protocols part integrated model involved code understanding domain situation program model 

identification information knowledge items aggregates 
included identification beacons domain schemas hypotheses strategies switches domain situation program model 
verbal protocol analysis exploratory observational technique research new domain 
study cognitive processes software maintenance evolution new domain 
similar faced issues determining validity generalizing results data maintenance situations 
task 
tasks code participants tried understand representative maintenance tasks commonly encountered industry 
participants doing task trying understand industrial strength code maintain 
understand cognition differs move specialized tasks explore situation better 

sampling participants 
representative participants larger population software engineers existing code need understand 
reliable answer current maturity field 
attempted get broad sampling maintenance tasks prior code programmer experience domain language 
point claim protocols represent full range cognition behavior population software maintenance engineers 
description population need assembled studies similar 

external validity 
concerns degree conditions data collected representative actual maintenance occurs 
code cognition maintenance purposes takes hours 
considered including different amounts prior preparation study 
tasks studied represent actual assignments 
strengthen generalizability findings 
observations give examples subjects report similar observations programming sessions 
subjects worked model levels domain situation programming model level 
table shows number model components 
identifies intermediate cognition goals support model building 
hours engineer performing bug fix great understanding bug result unable implement correction 
fact determined information received characterizing bug incorrect engineer previously responsibility understood bug 
engineer spent half time developing situation model lacked necessary realworld knowledge 
remaining time spent building program model components program model level drivers situation model construction 
contrast engineer working enhancement fixed bugs session able identify additional bugs know 
spent majority time developing program model substantially time situation model 
sense wrote faulty code needed revise program model 
function original program model developed enhancement implementation 
situation model necessary engineer expert domain algorithms question understanding operating system 
engineers referred top model infrequently 
expected nature debugging activity focusing specific problem developing high level view 
experiments especially general understanding engineers responsibility piece code top model referred third time 
hypotheses important drivers cognition 
drive investigation 
generating hypotheses code investigating hold important facet code understanding 
hypotheses may cause switch model level 
example analysis hypotheses failed debugging session hypotheses failed enhancement session 
integrated model assumes switches occur model components time 
specifically assume understanding built top full domain model going situation program model bottom full program model going situation model 
table shows integrated model correct 
find significant number switches levels 
illustrate switches levels example 
subjects developing elaborate theory function particular type data structure called debug control strings 
developed hypotheses levels abstraction switching situation program top model mental representations 
apparently things control routines 
reading comments gets confused 
building theory debug control strings print debugging output reason debug control strings state 
explains behave control flow language 
sentence appearing shell command line passed application programs confused bit 
guess really don understand 
tool capabilities maintenance engineers need build mental program model situation model domain model 
switch frequently levels 
understanding facilitated programmers domain language experience provide specialized schemas 
guides understanding process 
specialized schemas act motherboard acquired knowledge integrated 
specialized schemas support strategies building refining hypotheses 
facilitate retention retrieval knowledge code 
bug code process task fix ment opportunistic op gain high level overview program top op determine program segment examine op generate revise hypothesis functionality op determine relevance program segment op determine program segment needs detailed understanding op determine understanding strategy op investigate oversight op failed hypothesis op mental simulation top knowledge systematic sys read introductory code comments related documents program sys determine program segment examine model sys examine module sequence sys examine module control flow sys examine data structures definitions sys slice data sys chunk store knowledge sys generate hypothesis sys construct call tree sys determine understanding strategy sys generate new task sys generate question sys determine looking correct code sys change direction sys generate consider alternative code changes sys answer question sys add alter code sys determine location set breakpoint sys failed hypothesis sys determine error omitted code added sys mental simulation program model knowledge situation sit gain situation model knowledge model sit develop questions sit determine answers questions sit chunk store sit determine relevance situation knowledge sit determine info gained sit generate hypothesis sit determine understanding strategy sit determine error exists missing functionality sit failed hypothesis sit mental simulation situation model knowledge table task counts debugging enhancement maintenance engineers worked code significant size plus lines code cognitive limitations play big role understanding process 
need better tools alleviate capacity limitations short term memory 
need tools retrieval information long term memory reliable example representing domain model schemas situation model schemas user understandable form 
lack relevant specialized knowledge leads slower code cognition partly understanding proceed bottom small chunks 
slower strategies inefficient maintenance engineer higher level functional knowledge code supposed commonly implements 
precludes identifying strategies opportunistic understanding 
takes longer build hypotheses 
chunking small pieces leads layers program model situation model level reached 
cognitively 
lack specialized knowledge associated lack cognitive knowledge structures supporting memory cognitive activities 
example maintenance engineer needs remember postponed hypotheses tests results hypothesis tests 
tools maintenance engineers today emphasize support building program model 
reverse engineering tools support aspects domain situation models 
considered single level tools 
experience maintenance engineers frequently switch levels build test hypotheses find beacons trigger retrieval knowledge different level abstraction 
comprehension model allows understand programmers go comprehending number number model switches debugging model switches enhancement top situation program top situation program debugging enhancement model model model model model model model model top top situation situation program program table switches models code process productive 
tools needed support speed comprehension process 
tools quickly succinctly answer programmer questions extract information extraneous clutter represent information level programmer currently thinks 
tool information available program model situation model top model levels 
tool information accommodate relevant knowledge structures aid switching components code comprehension model 
unfortunately tools fall far short respects 
emphasize code analysis capabilities control data flow components useful program model stay higher levels abstraction case tools 
single modeling component frequently see relevant aspects tool supported defining hypotheses code identifying strategy recognize code 
information represented succinctly answer specific question full data flow table compared showing dataflow specific variable code highlighting code elision 
connections levels code comprehension commonly 
worse see attitudes reflected tool builders minds just teach programmers understand code way ought way tools understanding problem solved 
maintenance programmers levels abstraction 
argue cognition close reverse engineering cases develop higher level abstraction existing code 
current best bet supporting code understanding maintenance engineers situation domain level current state art reverse engineering tools 
table shows partial tool capabilities matrix extracted analyzing cognition behavior information needs 
detailed tools capability table see 
table observations reported contain domainspecific items 
information items need replaced domain specific items 
internal support routines utility functions change application domain consideration 
tools capabilities exist tool availability go situation domain model level 
mark tool capability table indicates tools exist 
find able support switches levels 
tools capable formulating keeping track hypotheses representation domain knowledge specialized domain schemas cognition strategies analysis hypothesis failure 
support natural process understanding code tools hinder 
information gained integrated model experiments developed tool capability matrix relates comprehension tasks individual tool capabilities 
maintenance tools designed enforce prescribed maintenance process 
suspect different styles programmers systematic study related information focused study information perceived related task hand dynamic execution program affect actual task sequence maintenance activities 
tools support maintenance processes defined terms task sequences tools may hinder understanding process 
tool capabilities nontrivial need function classification scheme textual crosses levels abstraction availability domain expert 
progress tool support maintenance engineers require facilities representing hypotheses switches domain situation program models 
represent strategies help maintenance engineers remember postponed hypotheses tests results testing hypotheses 
summary need better tools representing intermediate results dynamically defined steps code understanding 
research supported brooks theory cognitive processes computer programming international journal man machine studies pp 

brooks theory comprehension computer programs international journal man machine studies pp 

task sub task information needs tool capability gain study function call structure display call graph full system display high level determine file structure directory layout organization source text view include files main file support top files library files model general understanding maintenance manual info line documents high level project documents keyword search docs 
determine frequently count function calls function counts functions routines identify utility functions utility function list determine narrow organized functions list functions possibilities categories categorized module functions related 
specific cation scheme top call graph get rid extra pruning call tree model info relevant error specified routines functions categories specified category 
want see structure structure relevant functions pruning call tree irrelevant information different levels specified abstraction categories look function general classification list functions group functions get routines functions categorized idea understood specific classification functions group rest group scheme understood generate determine routine routines display domain hypothesis performs vital function application domain type 
applicable functions 
top determine function list internal support display internal model internal support function functions support routines 
gain situation recall previously learned situation knowledge scratch files model knowledge information code situation model determine nature bug bug behavior isolated line bug reports characterized 
duplicate bug duplicate bug simulate behavior steps reproduce include data develop determine specific term definitions terms concepts line docs questions means situation model application domain key word search situation model determine understand domain concept sources domain knowledge line access info gained knowledge ref manuals explaining situation model domain concepts domain expert generate determine meaning acronym acronym definitions acronym definitions hypothesis acronym functional situation model definitions determine search calling procedure object line cross program segment see object 
specific procedure 
examine return previous code segment place code history browsed program model preceding branch locations chunk store determine particular nesting level particular fan fan program model procedure fits procedure function function level surrounding adjacent procedures generate determine word reserved list reserved words line language hypothesis reserved word docs hypertext program model look object group general description line object uses get idea object including tation key object deviations expected word search construct call determine call tree structure call tree graph specific graphical display specific object 
object graph pruning program model specific object 
determine determine program list explanation constructs line language understanding language construct different deviate standard documents constructs similar program language stmts word search program model languages constructs hypertext determine calls objects frequency count source code metrics investigated particular object number entities determine best code segment direction follow intelligent agents examine confused known possible program give advise segments examine done 
table tool capabilities ned chapin software maintenance life cycle conference software maintenance pp 

program comprehension workshop csm workshop notes ieee computer society conference software maintenance november orlando florida 
edward curtis cook investigation procedure variable names beacons program comprehension tech report oregon state university 
guindon herb krasner bill curtis breakdowns processes early software design professionals empirical studies programmers second workshop eds 
olson sheppard soloway fl ablex publishing pp 

jurgen koenemann scott robertson expert problem solving strategies program comprehension acm 
march pp 

stanley letovsky cognitive processes program comprehension empirical studies programmers eds 
soloway iyengar fl ablex publishing pp 

david littman pinto stanley letovsky elliot soloway mental models software maintenance empirical studies programmers eds 
soloway iyengar fl ablex publishing pp 

katherine judith reitman knowledge organization skill differences computer programmers cognitive psychology pp 
paul oman curtis cook book paradigm improved maintenance ieee software january pp 

nancy pennington stimulus structures mental representations expert comprehension computer programs cognitive psychology pp 
nancy pennington comprehension strategies programming empirical studies programmers second workshop eds 
olson sheppard soloway fl ablex publishing pp 

robert rist plans programming definition demonstration development empirical studies programmers st workshop washington pp 

ben shneiderman software psychology human factors computer information systems chapter fl publishers pp 

elliot soloway kate ehrlich empirical studies programming knowledge ieee transactions software engineering september vol 
se pp 

elliot soloway beth adelson kate ehrlich knowledge processes comprehension computer programs nature expertise eds 
chi glaser fl lawrence erlbaum associates publishers pp 

iris vessey expertise debugging computer programs process analysis international journal man machine studies pp 
von mayrhauser vans code comprehension model technical report cs colorado state university fort collins von mayrhauser case care software maintenance need code processing procs 
case dec irvine ca 
von mayrhauser vans industrial experience integrated code comprehension model technical report cs colorado state university fort collins susan wiedenbeck processes computer program comprehension empirical studies programmers eds 
soloway iyengar fl ablex publishing pp 

