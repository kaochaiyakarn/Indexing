page extensible records pure calculus subtyping luca cardelli digital equipment systems research center lytton avenue palo alto ca extensible records introduced mitchell wand studying type inference polymorphic calculus record types 
describes calculus extensible records translated simpler calculus lacking record primitives 
independent axiomatizations extension show translation preserves typing subtyping equality 
expressive calculus extensible records directly give meaning languages 
show express standard benchmark examples appear literature 
record calculi proposed complex set rules calculi rules justified translation simple calculus 
argue thinking terms translations may help simplifying organizing various record calculi proposed generating new ones 
appears theoretical aspects object programming mitchell gunter eds 

src research report january 
revised october 
digital equipment 
may copied reproduced part commercial purpose 
permission copy part payment fee granted nonprofit educational research purposes provided partial copies include notice copying permission systems research center digital equipment palo alto california acknowledgment authors individuals contributors applicable portions copyright notice 
copying reproducing republishing purpose shall require license payment fee systems research center 
rights reserved 
page contents 

system syntax rules 
basic encodings booleans products enumerations tuples 
records simple records extensible records 
system syntax rules properties useful extensions recursive types label sets definitions examples 
translation 
translation preserves derivations 
page 
extensible records associated notion row variables introduced mitchell wand studying problem type inference polymorphic calculus record types wand row variable type variable ranging possible field extensions record type 
calculi row variables produced jategaonkar mitchell wand harper pierce cardelli mitchell imagined 
try increase expressiveness calculi axiomatization techniques divergent complex 
able compare discuss different calculi feel need fundamental framework 
suggests simple calculus subtyping basis studying complex calculi extensible records 
search unifying framework adopt working hypothesis reasonable calculus row variables reducible calculus row variables behaved translation 
purpose hypothesis eliminate row variables completely translated programs verbose useful purpose gain insights study calculi row variables 
working hypothesis turns false may distinguished easier features translated complex ones 
carry plan need fix suitable target calculus translation 
studying type variables choice secondorder calculus system girard reynolds 
express idea translation behaved require basic soundness properties preservation typing subtyping equality relations 
order preserve subtyping relations need translate target calculus notion subtyping gain little insight complex subtyping relations induced extensible records 
similar reason interested untyped target calculi translations easily obtainable 
target calculus extension subtyping called sub studied curien ghelli curien ghelli cardelli 
fact translation extensible records possible gives new evidence expressiveness reinforces feeling regarded canonical calculus subtyping 
main discussion briefly review motivations led notions row variables extensible records 
calculus records program may contain expressions denotes record value label denotes field record record selection denotes value field labeled record expression infer type form rcd record type having field labeled type type determined 
expression program infer type form rcd 
page form typing insufficient considering record updates 
expression la denotes record similar value component updated consider program la assuming type infer typing rcd rcd record value rcd having fields labeled respective values consider legal expression rcd argument fields required type expression receives type rcd typing 
unfortunately typing forgotten argument result component labeled 
unsatisfactory 
capture kind polymorphism required record update operation introduce row variables 
record types extended general form rcd row variable intended represent fields record type case fields ones labeled assign program informative type rcd rcd rcd row variable bound row type producing expected result type rcd substitution form type inference keep track constraints row variables fact example come contain components duplicate label 
constraints manifest adopting type system featuring explicit polymorphism program receives typing xl rcd rcd xl means undefined label bound row types components 
appropriate types rows explicitly supplied arguments rcd satisfactory typing practical reasons may require type inference avoid writing type arguments 
discuss type inference consider pragmatic variation basic calculus 
wand original view developments harper pierce row variables type variables different kind 
contrast cardelli mitchell studied explicitly polymorphic type system row variables type variables instances second order type variables unifying concepts 
go back original view page row variables separate show ultimately expressed ordinary type variables 
outline shows calculus row variables represented simpler calculus row variables translation 
independent axiomatizations extension prove translation behaved preserves typing subtyping equality 
organized follows 
sections recall definition expressive power borrowing cardelli 
section gives main intuitions encoding extensible records section describes section gives translation section shows translation sound 
examples expressive power comparisons calculi delayed section 
show express standard benchmark examples appear literature 
encourage readers examine examples convenient 
readers wish learn language records interested translation may confine sections 
system section describe target calculus translation follow 
translated turn trivial extension called 
known translations preserve subtyping martini reinforces point translating informative translating directly obtained extending notion subtyping allows remain pure calculus 
introduce basic types structured types normally associated subtyping programming languages 
show programming types obtained encodings pure calculus 
particular encode record types subtyping relations cardelli 
syntax syntax extends syntax follows 
new type constant top denotes supertype types 
second order quantifiers acquire subtype bound bounded quantifiers cardelli wegner 
ordinary second order quantifiers recovered setting quantifier bound top top type top subtype bound polymorphic functions syntax types page type variable top supertype types ab function space bounded quantification values value variable top canonical value type top function application bounded type function type application subtyping judgment added judgments 
equality judgment values relative type important values types values may may equivalent depending type values considered possessing 
judgments env formed environment type type subtype type equal members type dom set variables defined environment usual identify terms renaming bound variables xd substitution xy xy identifications directly syntax knowing terms involved product formal derivations system 
adopting identifications avoid need type equality judgment 
environments identified renaming variables domains environment variables kept distinct construction 
formal approach de bruijn indices free bound variables de bruijn 
rules inference rules listed comment interesting aspects 
subtyping judgment reflexive transitive relation types subsumption property member type member supertype type 
type subtype top 
function space page operator antimonotonic argument monotonic second 
bounded quantifier antimonotonic bound monotonic body 
rules typing judgment corresponding rules extension bounded quantifiers 
additional typing power hidden subsumption rule example allows function take argument having subtype function input type 
equivalence rules ab unremarkable 
provide congruence syntax equivalences 
rules stand 
top collapse states terms equivalent seen type top 
operations available members top values indistinguishable type fact interesting consequences sequel 
second eq appl congruence rule polymorphic type application giving general conditions expressions equivalent type rule intriguing consequences explored 
described cardelli 
environments env env env type type env env types type type top env type top type type type type type type ab type subtypes sub refl sub trans type sub sub top type sub sub ab values page subsumption val val top env env top top val fun val appl ab ab val fun val appl xa equivalence eq symm eq trans eq eq collapse top top top eq fun eq appl bb bb ab aa ab eq appl eq fun bb xa xa eq eta eq eta ab ab eq beta eq beta xa xa xa calculus extracted pierre louis curien cardelli wegner studied giorgio ghelli curien ghelli name refinement achieved extending eq appl rule 
studied cardelli 
derived rules needed 
proofs follow lemmas listed section 
lemmas hold restricted syntax page lemma subsumption equivalence subsumption rule extends equality judgment eq subsumption lemma domain restriction ab equivalent restriction smaller domain seen type 
eq fun bb lemma bound restriction equivalent restriction smaller bound eq fun bb 
basic encodings extension express standard encodings algebraic data types possible berarducci 
clear interest obtained subtyping rules involve apparently useless type top simple rules section show fact encode rich subtyping relations familiar data structures 
section encodings involved increase complexity motivates switch independently axiomatized system section 
booleans sequel section concentrate inclusion structured types sense need show non trivial inclusions level basic types 
investigate type booleans process illustrate interesting consequences rules 
starting encoding church booleans define subtypes bool follows cf 
fairbairn bool aaa true false page true looking closed normal forms elements types true bool bool false bool bool true true true top false false false top obtain elements type bool addition usual true bool false bool extra true true false false type bool subsumption 
show true bool true true provably equivalent type bool domain restriction lemma eq fun section 
top aa eq fun top aaa top aaa true true true bool bool similarly show false false false bool bool 
really different values bool 
products standard encoding pairs exhibits useful subtyping properties ab abc occur monotonic positions ab twice left arrow obtain expected monotonic inclusion products derived rule ab operations pairs defined usual pair abab abc fst aba ab snd abb ab abbreviations disambiguated context ab pair fst fst ab fst page snd snd ab snd enumerations enumeration types finite sets form collection base types interesting inclusion relations 
describe show interesting top type hint encoding tuples section 
enumeration zero elements defined type closed normal forms elements 
enumeration element defined type just closed normal form atop fst atop enumeration elements defined type closed normal forms fst fst snd subsumption find elements 
booleans prove equal point pattern enumeration types clear times distinct elements 
tuples tuple type tuple denotes iterated product type 
slot filled type 
type variable extensible tuple type 
top simple tuple type 
tuple tuple 
page tuple tuple tuple derived rule 
tuple special case obtain rule simple tuples 
type 
type tuple top top example tuple top top monotonic 
note type top assumes useful role allowing longer tuple type subtype shorter tuple type 
intuition longer tuple value regarded shorter tuple value forgetting additional components possible forgotten top 
tuple values tuple tuple 
tuple tuple tuple derived rules 
tuple tuple 
ab tuple tuple tuple basic tuple operations ai dropping components tuple selecting th component defined iterating product operations abbreviations ai drop snd sel fst ai precisely drop sel top fst top drop top drop snd drop page sel top fst top drop top 
obtain derived rules tuple tuple ai 

tuple tuple example tuple tuple tuple tuple tuple top tuple top tuple top tuple top developed necessary techniques encoding record types subject section 

records general plan carried sections axiomatize rules records independently provide translation encoding calculus records 
section bit informal discuss encoding record types discussing derived type rules 
pathologies caused approach disappear 
simple records countable set labels enumerated bijection 
indicate superscript th label enumeration 
need refer list distinct labels enumeration subscripts may example precisely stands injective 
record type form rcd final type normally top type variable 
enumeration set labels fixed record type encoded tuple type record components allocated tuple slots determined index labels 
component label allocated th tuple slot remaining slots filled top padding 
example rcd tuple top record type components canonically sorted encoding record types differ order components equal encoding 
consider record components unordered 
page artifact encoding missing record field label equivalent field top 
type rules situations differ case extraction label allowed 
record type final component top called simple record final component type variable called extensible record simply record 
situations allowed type rules records example notice rcd rcd meaningful translation 
encoding derive familiar rule simple records cardelli 
type 
type rcd top top holds additional field absorbed top padding right final top 
example rcd top tuple top rcd top record values similarly encoded example rcd tuple top obtain rules simple records 
rcd top rcd top 
rcd top rcd top rcd top record selection encoded follows rule rcd top subsumption derived rules 

rcd top rcd top 


rcd top rcd top rcd top rcd top page second rule particularly interesting 
expresses form observational equivalence records equivalent type coincide components observable type 
ultimately values equivalent type top 
interesting question simple records remains equivalent operator tuples 
answer turn extensible records 
extensible records section fully axiomatize system row variables understand axiomatization better may useful idea translation follow 
section sketch main ideas translation reader skip section point 
done tuples place type variable record capture additional components 
tuple represents tuple components rcd represents record components translating records tuples see achieve desired effect final type variable split set type variables 
symbol mean informally translates 
rcd tuple bound single record type bound labeled collection types fills slots exactly 
call collections type rows row type variable 
consider example rcd row variable instantiated type row contain components labeled accounted 
example instantiated type row top 
express constraint instantiations saying kind reads undefined exactly cover exactly 
constrained row variable xl translated sequence type variables gaps example xl xl xl xl xl xl step extending row types allow constrained row variables environments page xl 
xl translate xl rcd type tuple type proper order 
manipulate type rows row variables introduce new judgment form described detail section type row including row variable set labels covered row general need translate just records rows may missing components row missing st th 
row variables allowed environments give rise naturally quantifiers xl binders xl 
row quantifiers row binders decompose translation sequences type quantifiers type binders 
example xl rcd tuple come important issue translation matching number arguments row type function xl number parameters row type application xl rl 
application form function xl shape rl xr rl xr row substitution row variable top rcd rcd seen translations xl xl convert single parameter xl sequence parameters length depend call length dimension translating application rl produce sequence applications size irrespectively actual parameter may require regrouping components argument row example xl yl xl yl tuple page second case wrong group tuple match parameters expected uniformity translation take parameter tuple tuple case tuple say informally row variables translate rows variables row types rows types row quantifiers rows quantifiers row applications rows applications main difficulty translation ensure rows match properly 
precise relation row rl dimension discussed section 
turn formal system intuitions translation records tuples developed section 

system extend records row variables discussed section resulting system called syntax types augmented record types rcd row type defined labels row function types rl input row type rl output type row variable quantifications xl set labels undefined 
row type constant standing empty row precisely unnamed extension current row type type variable standing extension current row type extending row type field type label values augmented records rcd row value defined labels row functions accepting row value row type rl row type functions xl accepting row type undefined record selection record defined row function applied rl row value undefined row type function instantiated rl row type undefined row value constant standing empty row unnamed extension current row value row variable extension extending row value field value label restriction producing row value undefined record syntax label set 
types plus rcd record type page row function space xl row quantification row types row type variable empty row type row type plus field labeled 
values plus rcd record value record selection row value function rl row value application xl row type function rl row type application row values row value variable empty row value row value plus field labeled row value record fields discussed section identify terms renaming bound variables xl yl xy xl xl xy xy identify rows reordering labeled components identify terms permutation label set xl xl rl xl xl rl rl rl rl identifications legitimate depend syntax terms derivations 
identification label sets adopt notational convention inference rules ll add judgments rows involve set rows undefined 
judgments page 
judgments plus row type covering rar row type rl covering ar equal row type rl important notice information preserved exactly derivations sense derivable ll judgments 
say row undefined mean undefined exactly rules indicate judgments distinguish judgments rules consist copy rules replaced plus ones listed 
briefly comment rules 
row type formed starting row variable xl row prefixing fields ll step discarding note assumed lack set labels start 
informally imagine element collection empty slots filled element infinite row gaps corresponding components filled error value 
record type formed complete row lacking labels 
call complete finite information labels example complete entirely unknown 
completeness requirement probably essential gives simpler calculus record types carry positive information row variables carry negative information harper pierce 
judgment mainly auxiliary define subtyping records 
judgment row componentwise subtyping fields having label 
longer row shorter row corresponding components subtype relation 
rows type variables length assuming xl 
rows distinct type variables unrelated information labeled types may substituted variables 
record values created complete rows discussed 
record rcd select component record rcd extract row rl removing components labels values equivalent top 
similarly row values equivalent environments env env page env env xl env types type rcd type type type xl type rcd type type xl type row types type type type cons xl env env type xl subtypes sub rcd sub sub xl rcd lb xl xl type sub row refl sub row trans sub sub cons values val rcd val sel rar rcd rcd rcd val fun val appl rar rl val fun val appl xl xl xl xl rl xr row values row subsumption val rar env page ras val val cons val restr env rar rcd value equivalence eq rcd eq sel eq eval sel aa rcd rar aa rcd rcd rcd rcd eq fun eq appl bb bb rr ar rl eq fun eq appl xl xl xl bl xl xl rl rl xr eq beta eq eta rr ar xr yl eq beta eq eta xl xl xl rl xr xr yl yl xl row value equivalence eq row symm eq row trans star eq row subsumption eq row collapse rr ar rr eq eq eq cons env rr ar aa eq restr eq eval restr aa rcd rr ar 
rcd example derivations env xl env type xl type page type xl type xl rcd type xl rcd type properties state basic lemmas properties derivations implicitly derivations 
noted proven induction derivations proofs long straightforward done order indicated 
notation type sas cc ss lemma renaming stand xm ym 
assume dom 
env xx env xx xx lemma implied judgments env env env env env type type env type env env lemma bound change type type type type type lemma weakening stand xl 
assume env env env assume env dom dom env env lemma implied judgments sub type type type lemma bound weakening page stand 
assume env env lemma type substitution assume xd env xd xd assume xm env xs env xm xs xs lemma value substitution assume env env xd assume tat env env xt lemma value strengthening assume cc env env xd assume rr ar env env lemma implied judgments val type type sas eq val cc ss sas lemma subsumption equivalence cc cc proof subsumption beta see cardelli lemma implied judgments val eq cc sas lemma exchange stand ym 
stand 
assume env 
page env env show observational equivalence rule records derivable 
rule asserts record values equal type fields observed type equal 
proposition observational equivalence records 
rar sas rcd rcd rcd proof rar env implied judgment rar implied judgment sub rar subsumption equiv 
env eq eq row collapse sas similarly eq trans rar sas 
eq row cons rcd rcd rcd eq rcd useful extensions preparation examples section discuss useful extensions system recursive types label set variables definitions 
extensions treated formal part 
recursive types order introduce recursive types need add type equivalence judgments system rules omitted making type equivalence congruence syntax type equivalent types equivalent row types recursive type syntactically term contractive written 
means ax immediately identify recursive types renaming bound variables xy page rules recursive types amadio cardelli unfold type type type type type type contract xa type xb type type type type recursive value syntactically term identification xy standard rules recursive values ab label sets extension involves variables ranging sets labels 
allow environments assumption contain labels env 
env env rules involve label sets extended require sure formed 
define quantifiers functions label set variables know translate label set variables definitions 
definitions extend system various flavors definitions 
simplest definitions value row value definitions xa page xr kinds type level definitions may give definition type variable row type variable label set variable scope type row type value row value label set 
compress cases abbreviations type row type label set variables types row type label sets aa bb cc values row values types row types label sets pred type omit aa means may occur aa aa stands aa xb type row type label set definitions various scopes rules bb bb ak bb pred ak bb pred xk bb pred xk bb bb pred note value definitions require xk bb pred typeable 
introduce parametric type level definitions example 



omit obvious technically complicated definitions 
top level declarations way stands similarly 
useful features turn examples 
examples examples section adapted canning harper pierce cardelli mitchell 
start list standard test cases compare calculi 
extracting field record known possess 
select rcd nat nat rcd nat select rcd true nat page extracting field record known possess 
typing error calculi proposed 
removing field record known possess 
restrict xx rcd nat 
xx rcd nat 
row context restrict nat rcd true removing field record known possess 
crucial feature cardelli mitchell 
possible translation section requires exact knowledge missing fields 
adding field record known possess 
applicable records complete 
add field row known possess 
row context adding field record known possess 
applicable records complete 
rows knowing sufficient condition adding field 
operation possible wand cardelli mitchell 
updating field record known possess 
adding field conditions possible records complete problem updating 
note type information additional input fields preserved 
example motivated cardelli mitchell 
replace xx rcd top xx rcd top rcd replace bool string rcd true str rcd str true rcd string bool restricted version called consistent updating preserves type field updated 
update xx rcd xx rcd rcd interesting example update occurs moving field point 
case want preserve type field subtype int may additional fields 
input type field proper subtype int corresponding output type int exceed range move zx rcd int rcd int zx rcd int rcd rcd color page move color rcd int color challenging task update deep structure preserving type information input 
achieved follows second level boolean update 
deep update xy xx yy rcd rcd bool rcd rcd bool xx yy rcd rcd bool rcd rcd xy nat nat rcd rcd true rcd rcd false rcd rcd bool nat nat updating field record known possess 
knowing sufficient condition 
renaming 
renaming possible general 
consider example rcd rcd constraint 
pass standard examples class hierarchies methods 
parametric type definitions explained section model record type extension harper pierce 
technique compensates point lack type operations cardelli mitchell 
points color points point components int int color point component color 
challenge define colorpoint type values reusing point type values 
reuse types steps defining parametric version type 
similarly values 
instance powerful generator technique widely employed cook 
zx rcd int int point rcd int zx color rcd int color colorpoint rcd int color zx zx zx rcd origin point page zx zx zx color white colorpoint total orders record type total orders 
ordering represented method leq compares element self value 
type recursive input type method 
definition done steps introduce generator open recursion self type parameter generator derived recursion closed actual type 
general steps obtained uniformly 
technique bit complex seen standard way translating class written amenable language 
self rcd leq toplus self self self rcd leq toplus self rcd leq define total order naturals reusing self val add self val nat add rcd leq val nat add val add self self self rcd leq val nat add self rcd leq val nat add zero rcd val add leq val methods zero specialized inherited problem amended defining value generator open recursion example leq self val 
discover obtained adding components subtype rules recursive types 
unpleasant situation operations defined may apply particular total orders 
page solution define operations toplus 
pointed harper pierce done bounded quantification canning calculus negative information 
say subclass toplus cook 
min toplus toplus toplus toplus toplus leq specialize min min val nat add leq see typechecks compute toplus val nat add self self val nat add self rcd leq val nat add step formula formula proceeds follows rules recursive types section 
unfolding rcd leq val nat add bb rcd leq val nat add bb consider contractive context rcd leq val nat add bb ab contract rule 
step schema give type definitions things moved 
added flexibility step defines row type record type label set parameter explained section 
self move move self rcd self self rcd move movable self rcd move translate dx int dy int move dx dy page see case movable useless type 
interesting definition instantiated 
combine points zx rcd int int point rcd int int self xx move self rcd int int move xx move self self self rcd int int move self rcd int int move move xx move zx move self dx int dy int rcd self dx self dy self self rcd move move move self translate int int move note successfully reused definitions points 
move inherited subclasses opposed subtypes defining appropriate generators 
concatenation record concatenation handled adapting technique 
extra level encoding record concatenation modeled function composition system idea realized follows 
define segments extensible records parameterized potential extensions seg zl zl rcd seg zl rcd field segment extracted segment record seg segments distinct sets labels seg zl zl rcd seg zk zk rcd define concatenation follows page zl top top top top seg possible axiomatize extension segments concatenation define translation extended calculus 
translation section define promised translation calculus rows rows 
basic idea row variables row types row values row judgments rows sequences respectively variables types values judgments 
start familiar notation previous sections notation set labels bijection fixed enumeration labels label index fixed enumeration finite sets labels size finite set define set indices set labels maximum index definition indices maximum index set labels il ll max il finite sets labels contexts describing labels row lacks 
need talk labels row consider complement 
infinite set part uninteresting 
natural take interesting finite prefix kl definition finite complement prefix finite set labels kl central concept sequel dimension tuple translation row 
take row undefined row tuple translation sketched section gaps labeled components right gap contiguous collected single tuple call result normal row 
dimension row gaps defined number components corresponding normal row 
emphasize row rar dimension depends structure defined simply page definition dimension row undefined kl adding new item row row dimension changes depending new item fills gap row 
case set components may compacted final tuple dimension decreases case dimension increases 
lemma formulated terms adding removing gap 
lemma row dimension 
need notation describing complex sequences rows purpose notation similar set comprehension 
example denote sequence order idea superscript index increased monotonically generate elements sequence 
notation sequences length sequence sequence concatenation sequence comprehension sequence generated increasing elements 
row sequence labeled elements sorted label index length greater zero 
element row special discussed section rest row 
bookkeeping purposes special label element intuitively index uninteresting part row see row structure lemma 
notation rows type row sequence form value row sequence form size membership sorting br sorting br define basic sequences rows translation 
dimension definition basic sequences rows ikl ikl top ikl top page ikl ikl top ikl top ikl examples top top top top top top defining full translation need auxiliary translation converting row types row values rows types values respectively 
results unnormalized sense may dimension greater final components results need grouped tuple 
auxiliary translation refers back proper translation exposition purposes 
definition translation part auxiliary row translation base cases row type translation produce rows top size compute additional gap sort result 
similarly row value translation 
addition produces row record selections idea eliminating selecting reassembling components 
type rules ensure typed 
example translation size size greater provide kind normal form row types translations typing assumptions 
seen translation returns rows length depends may exceed normal form reveals portion fact gaps collected tuple form single th element 
similarly value rows 
page lemma row structure assume shape ikl assume shape ikl considering previous example size th item ready full translation 
translation fragment uninteresting list completeness 
definition translation part fragment environments values env env top top types type type top top value equivalence ab subtypes give translation proper judgments terms 
judgment sequence size judgments 
row variable xl environment sequence type variables 
domain row function space sequence domains similarly rl sequence applications 
row quantifier xl nesting type quantifiers similarly abstraction xl rl nesting type applications 
record types values translated applying respective rows normalizing results size page definition translation part proper environments continued xl types continued rcd xl type rows type 
type tuple 
values continued rcd rl xl rl value rows rar 
tuple value row equivalence 
examples xa rcd top tuple xa rcd top tuple top tuple xl xa rcd tuple xl xa rcd tuple tuple page row structure lemma show translation welldefined provided translated terms typed 
lemma translation dimensions rar rar lemma translation judgment derivable translation defined 
assumptions translation sizes rows justified 
row structure lemma key row analysis lemma proof technical lemmas section 
row analysis lemma describes detail happens single element added row removed 
lemma row analysis assume 
ikl 
tuple 
assume rar 
ikl 
tuple 
assume lar 
ikl 
tuple page 
translation preserves derivations section show translation sound 
judgment derivable judgments sequence derivable 
group lemmas hardest cases soundness proof 
lemmas complicated fact translations defined typing assumptions 
lemmas regarding rows structure inference rules concern translation rules 
lemma soundness row inference rules type row cons assume type 
type 
sub row cons assume 
row cons assume rar rar ral 
selection assume rcd 
rcd 
restriction assume 
eq cons assume aa aa eq selection assume aa rcd 
aa rcd 
eval selection assume rar aa rar aa rcd 
eq restriction assume la la la 
page eval restriction assume 
rcd 
assume rcd rcd rcd 
substitution lemmas possible combinations variables terms 
lemma soundness substitution type type assume type 
xa defined 
xa 
type row type assume xa defined 
xa 


row type type assume xl type 
xr defined 
xr 
row type row type assume xl xr defined 
xr 
type value assume xa defined 
xa 
type row value assume xa defined 
xa row type value assume xl page xr defined 
xr 
row type row value assume xl xr defined 
xr 
value value assume xa defined 
xa 
value row value assume xa defined 
xa 
row value value assume xr defined 
xr 
row value row value assume xr defined 
xr soundness theorem divided mutual induction groups 
theorem soundness env env type type page proof proof simultaneous induction derivations lemmas hard cases 

defined calculus row variables translated simpler calculus subtyping constraints imposed translation forced restricted subset features proposed calculi extensible records express benchmark examples 
particular mixture features chosen uniquely determined 
example attempted incorporate bounds row quantifiers record concatenation sketched section 
point possible variations described evaluated single basic framework 
underlying variations bridging extended recursion 
approach provide fundamental unified framework study complex features objectoriented languages 
martn abadi careful reading draft 
page amadio cardelli amadio cardelli subtyping recursive types 
acm transactions programming languages systems appear 
berarducci berarducci automatic synthesis typed programs term algebras 
theoretical computer science 
breazu tannen breazu tannen coquand gunter scedrov 
inheritance explicit coercion 
proc 
th annual ieee symposium logic computer science 
canning canning cook hill mitchell 
bounded polymorphism object oriented programming 
proc 
acm conference functional programming computer architecture 
acm press 
cardelli cardelli semantics multiple inheritance 
information computation 
cardelli mitchell cardelli mitchell operations records 
mathematical structures computer science 
cardelli cardelli mitchell martini scedrov 
extension system subtyping 
proc 
theoretical aspects computer software 
lecture notes computer science 
springer verlag 
cardelli wegner cardelli wegner understanding types data abstraction polymorphism 
computing surveys 
cook cook 
denotational semantics inheritance 
ph thesis computer science dept brown university 
curien ghelli 
curien ghelli 
subtyping extensionality confluence bh reductions proc 
theoretical aspects computer software 
sendai japan 
lecture notes computer science 
springer verlag 
curien ghelli 
curien ghelli coherence subsumption minimum typing type checking mathematical structures computer science 
de bruijn de bruijn lambda calculus notation nameless dummies 

math 

fairbairn fairbairn 
types inclusion properties technical report 
university cambridge computer laboratory 
girard 
girard 
une extension de de analyse son application des coupures dans analyse la des types 
proc 
second scandinavian logic symposium 
north holland 
harper pierce harper pierce 
record calculus symmetric concatenation 
technical report cmu cs 
cmu 
jategaonkar mitchell jategaonkar mitchell 
ml extended pattern matching subtypes 
acm conference lisp functional programming 
martini martini personal communication 

typechecking records variants natural extension ml 
proc 
th annual acm symposium principles programming languages 

typing record concatenation free 
proc 
th annual acm symposium principles programming languages 
reynolds reynolds 
theory type structure 
proc 
colloquium sur la programmation 
lecture notes computer science 
springer verlag 
wand wand 
complete type inference simple objects 
proc 
nd annual ieee symposium logic computer science 
wand wand 
type inference record concatenation multiple inheritance 
proc 
th annual ieee symposium logic computer science 
