technical report computer science department oregon tate university february 
unifying framework supporting analysis development safe regression test selection techniques john bible department computer science oregon state university corvallis bible cs orst edu gregg rothermel computer science oregon state university corvallis cs orst edu january safe regression test selection rts techniques software testers reduce number test cases need rerun revalidate new versions software ensuring fault revealing test case existing test suite excluded 
previous safe regression test selection focused specific safe rts algorithms addressing theoretical foundations safe rts techniques general 
unifying framework safe rts supports analysis development safe rts techniques 
show safe rts technique founded regression bias show prove rts technique safe set programs testing processes eliciting bias technique proving bias holds hold set programs processes 
provide general models safe rts techniques templates proofs safety 
model contains formulations defined terms finite automata 
model inefficient provide general powerful safe rts algorithm possible simple assumptions 
define generalized safe rts algorithm marginally powerful finite automata method provides template simplifies development safe rts algorithms 
illustrate application framework analyze existing safe rts algorithms biases develop new safe rts algorithm programs written spreadsheet languages 
cost maintaining quality new versions software dominates cost software maintenance 
maintenance activities contribute software quality current practice emphasizes regression testing 
regression testing requires creation test suites particularly expensive 
maintenance phase development phase test suites previous validation phases may exist reuse suites 
attempt reuse existing test suites problems arise 
reuse part test suites 
second new test cases develop satisfy new specification requirements modified software 
problem known regression test selection problem second problem test suite augmentation problem 
problems important focus regression test selection rts problem 
solve rts problem software testers decide existing test suite 
running test cases existing test suite consume inordinate amount time example industrial collaborators reports products containing lines code running entire test suite requires weeks 
hand omitting test cases test suite potentially result exclusion fault revealing test case 
testing requirements forbid risk regression test selection rts technique employed techniques select subset test suite heuristics analytic approaches :10.1.1.52.6170:10.1.1.30.3199
different rts techniques satisfy different demands 
simplest rts techniques select test cases randomly complex techniques typically base selection code analysis test execution profiles 
different rts techniques produce test suites different fault detection capabilities generate test suites terms meeting customer requirements 
focus rts techniques required safe :10.1.1.52.6170
safe rts techniques select certain conditions test case original test suite reveal fault modified program 
maintainers safety critical applications conservatism essential critical domains incurring extra costs employing safe non safe rts techniques preferable releasing faulty software 
previous research produced algorithms safe rts 
algorithms employ similar methods compare source code program representations program modified version locate lexical differences select test cases associated differences 
example rothermel harrold tool frankl tool pythia family techniques ball direct lexical comparisons source code statements relying control flow information locate test cases reach code changed 
approach laski reduces control flow graphs versions program form modified regions code identified 
testtube approach created chen rosenblum vo uses checksum comparisons text entities global namespace functions variables instance 
previous descriptions indicate safe rts techniques rely implicitly explicitly control flow information identify changed code test cases re executed 
exception testtube simple analytic method operates coarse level control flow information stored required 
partially existing safe rts techniques target imperative languages 
functional languages haskell pure lisp logic languages prolog declarative languages spreadsheets control flow significant component 
fact constructing techniques control flow cases may impossible may mask opportunities efficient 
existing safe rts techniques require code execute deterministically 
distributed parallel imperative programs rely locally control flow easily operated safely existing techniques 
existing safe rts techniques account nondeterministic response times nondeterministic event arrival times real time event driven programs difficult accommodate techniques 
believe limitations partially result lack general framework safe rts framework specifies safe rts means respect different types programs 
far little done establish set requirements govern model evaluate safe rts techniques general 
rothermel harrold provide framework comparing analyzing regression test selection techniques framework specifically address foundations safe rts :10.1.1.30.3199
ball addresses theoretical foundations control flow graph safe rts techniques dejavu shows process employed techniques functionally equivalent process intersection deterministic finite automata 
primary control flow techniques issues precision extent techniques succeed omitting unnecessary test cases 
lack foundation safe rts proofs safety techniques difficult achieve proofs essential techniques deemed acceptable fo validating safety critical software 
lack foundation obscures unique needs different varieties programs testing situations safe rts applied 
unifying framework safe rts algorithms supports analysis comparison creation safe rts algorithms generally 
framework defines properties rts algorithm possess order claim safety 
particular framework establishes concept regression bias set assumptions safety rts technique defines set primitive entities model safe rts technique proof safety technique built bias satisfied program testing process 
framework includes general models safe rts techniques templates proofs safety 
define formulations model finite automata formulations provide theoretical basis safe rts particularly efficient 
generalized safe rts algorithm generates signature graph graph guarantees test case safely excluded trace test case original program remains entirely graph 
algorithm template new techniques implement generic functions algorithm facilitate analysis comparison safe rts techniques 
extension general algorithm equivalent precision second formulation finite automata model efficient analyzing program differences 
illustrate framework 
show framework provide proof safety dejavu sketching providing similar proofs pythia testtube 
show framework develop new safe rts technique testing spreadsheet programs application demonstrates technique applied programs reliant control flow proper evaluation 
remainder organized follows 
section provides background material required subsequent discussion 
section describes semantic framework safe rts presents formulations model safe rts 
section describes generalized safe rts algorithm template functions presents precise extension 
section presents applications framework including analysis proof dejavu techniques creation new instantiation generalized algorithm spreadsheets 
section presents 
safe regression test selection software initial development software maintenance may partially validated validation previous versions 
new functionality course subjected testing requires creation new test cases 
old functionality may exercised existing test suites testers revalidate functionality examine changes introduced new faults old code re executing existing test suites 
retesting modified software involves distinct problems 
problem validating changed functional non functional requirements new version program 

problem verifying changes introduced faults detectable original test suites 
problem requires validation new enhanced system components requires development new test cases call test suite augmentation problem 
changes code require development new test cases functional changes 
particular customer requirements code coverage requirements testing process previously met modifications fail met requiring test case creation 
case task resembles original development phase testing process regression test selection process targets address 
second problem requires revalidation old non obsolete functionality requirements existing test cases regression test selection problem focus 
rest denote program denote modified version denote existing test suite regression test selection problem involves selecting subset test cases necessarily apply changes functionality instance test cases obsolete 
obsolete test case test case behavior specified different correct behavior 
remove test cases execute remaining test cases partially revalidate reusing non obsolete test cases manner known retest approach 
approach offer advantages testers completely re verify testers pay cost test case execution pay cost test case development 
course retest technique employs non obsolete test cases test cases may exercise code unaffected changes generated retest approach involve unnecessary effort requires exercise release entire test suite changes release insignificant 
rts techniques address problem selecting subset test suite rerun eliminating test cases 
primarily interested safe rts techniques informally eliminate test cases provably able reveal faults 
provide precise definition safety rts technique require preliminary definitions 
definition deterministically fault revealing fundamental safe rts define 
definition 
deterministically fault revealing dfr program test suite say deterministically fault revealing dfr test case exhibits identical failures execution note dfr necessary cause exhibit deterministic behavior 
test suite dfr exhibits random behavior faulty behavior occur deterministically deterministically detectable 
testers frequently attempt program behavior deterministic testing scenario 
part justification doing ensure failures occur deterministically ensuring dfr 
important reasons ensuring deterministic testing 
instance failing ensure determinism fault localization impossible difficult correct fault reproduced 
nondeterministic behavior test disturbing effects test quality measures regression test time 
example test case causes nondeterministic program behavior may exercise different branches designed exercise fail cover components required cover fail achieve quality goals required 
suppose ensure test suite deterministically fault revealing case retest technique ensure faults deterministically revealed test suite 
clear draw program quality relative regression test suite form test reuse ensure test suites dfr 
assume safe rts techniques implicitly require test suites dfr programs test 
discuss assumption merely constrains set programs testing methodologies particular rts technique safe 
test suite run exhibits failures testers additional assumption related dfr correct dfr exposed faults unable expose faults correct definition 
correct test suite incapable exposing faults regardless assumptions underlying regression testing process important goal process identify fault revealing subset test suite definition 
fault revealing subset test suite program dfr exists subset tfr tfr contains test cases reveal faults executed algorithm precisely identify general fault revealing subset test suite safe rts algorithms attempt identify superset subset :10.1.1.30.3199
prompts definitions metrics evaluating selected subsets definition 
inclusiveness test suite fault revealing subset tfr contains fault revealing test cases inclusiveness tfr inclusiveness defined 
notable exception explicit nondeterministic testing concurrent programs 
examine possibility possible rts techniques operate safely nondeterministically fault revealing test suites certain circumstances 
example case dfr subset contains potentially fault revealing test cases 
case define subset called non deterministic fault revealing test suite 
similar analysis testing scenario modifications trivial 
particular validating power dfr test suite probabilistic dimension essence sampling behaviors non deterministic case probabilistic dimensions sample test cases probabilistic 
definitions similar definitions :10.1.1.30.3199
definitions viewed precision inclusiveness qualities inherent rts technique precision inclusiveness respect particular test suite 
chosen alternative definitions rts techniques profoundly different results different types subject programs shall discuss section 
definition 
precision test suite fault revealing subset tfr precision jt tfr precision defined case precision 
definition 
safety safe rts technique produces test suite subsets inclusive respect base test suite course safe rts technique worthwhile cost running entire test suite exceeds cost running analysis techniques plus cost running validating results selected test cases 
phrase relation equationally property hold running safe rts algorithm inefficient allocation resources 
precision safe rts algorithm important factor affects size selected test suite cost analysis 
accounts cost critical relation example time spent humans validation may valued time spent machines analysis 
semantic framework safe rts algorithms behavioral equivalence regression biases safe rts techniques non safe rts techniques select subset test cases existing test suite 
non safe techniques safe techniques act proofs excluded test cases reveal faults modified version program 
particular safe rts techniques attempt prove test cases fault behavioral equivalent program subsequent version program 
course providing proofs unrestricted population programs testing methodologies possible 
safe rts techniques specialize particular types programs testing methodologies example deterministic programs written test cases terminated revealed correct outputs previous execution 
situations safe rts techniques apply refined simplifying assumptions environment program execution example particular technique require compiler generate code test suite execute operating system addition requirements specifications give leeway judging software correct instance response times bound technique show test case cause response time exceed bound test case assumed fault behavioral equivalent appropriate assumptions environment testing methodology program behavior rts techniques safe efficient provided assumptions violated 
assumptions constitute regression bias safe rts technique 
formally defined regression bias informal discussion notion far places set assumptions concerning program code environment program regression tested test suites testing methodology test 
aspects constitute gestalt program behavior test safe rts techniques depend detailed consideration issues involved analyzing economic trade offs rts techniques see 
aspects 
constantly referring program environment test suite proves clumsy introducing new definition unnecessary 
term program refer code significant influences external computing environment 
oftentimes safe rts techniques factor external environmental influences case program refers code distinction points factorization safe 
test suites remain separate usage program separating terms adds merging fundamental meaning term program 
clarification precise definitions fault behavioral equivalence regression biases definition 
fault behavioral equivalence test case programs fault behavioral equivalent execution produces failures identical failures 
definition 
regression bias set assumptions safe rts technique constructs implicit deductive proofs subset test suite contains fault revealing test cases 
bias holds subset possible programs test suites 
definition 
biased fault behavioral equivalence test case programs regression bias said fault behaviorally equivalent holding implies fault behavioral equivalent regression testing want prove fault behavioral equivalent existing test suites obsolete test cases removed test suites 
establish safety rts technique show technique proves fault behavioral equivalent regression bias satisfied testing environment 
strict requirement requires bias hold environment course tester distinguish subset tf bias fails tester apply rts technique gamma tf add test cases tf selected set interested techniques regression biases hold time programs intended range application testers choose accept virtually safe rts techniques fail rarely occurring subject programs failure mean inclusiveness 
consider techniques require inclusiveness 
framework applicable virtually safe techniques 
defined regression bias set assumptions yields set characteristics partition space programs 
regression biases viewed sets programs sets assumptions hold 
shall regression biases describe sets assumptions describe sets programs 
context specific usage clear 
regression biases impose general specific ordering space safe rts techniques 
safe rts technique relies bias partitions space programs test suites programs test suites bias applies programs test suites 
define metric regression biases measures extent space covered bias 
general specific metric structure space safe rts techniques ordering techniques 
directed graph ordering safe rts technique directed edge safe rts space programs space safe rts techniques space possible programs domains safety rts techniques imposed 
space possible safe rts techniques general specific ordering imposed 
technique regression bias contains regression bias words programs partition belong partition 
ordering characterize relative strengths different techniques total space programs examining extents techniques underlying biases 
illustrates notion 
safe rts techniques represented techniques space safe rts techniques 
left space possible programs shown rts techniques shown subsets space illustrates sets programs regression biases techniques apply 
right space safe rts techniques shown general specific ordering imposed 
shows general general general subsets safe overlap 
general regression biases general specific ordering hold allow corresponding techniques produce safe subsets 
bias underlying retest approach instance general bias null restriction bias 
null restriction bias definition true programs 
retest approach selects tests time guaranteed inclusive programs 
specific regression biases term null selection biases hold changes code environment held perfectly constant correct algorithms bias select empty set test cases 
cost effective safe rts techniques utilize biases lie null restriction null selection biases 
ordering theoretical usefulness care taken applying 
bias underlying technique rank high general specific ordering application technique impractical 
bias apply wide class programs fail apply exactly programs interested 
general specific ordering supply tool comparing safe rts techniques 
state semantic words agent sets far focused definition safe rts construction proofs safety 
proof proceed model program computing environment test 
model ideal techniques primitive entities model proof specific technique built 
general models primitives finite automata partitioning process intersection program graphs 
models intended general applicable different specific models computation primitives applicable various models 
framework developed section characterizes safe rts techniques general analyses safety involve diverse factors including peripheral devices external agents computing environment definitions quite 
shall show utilize definitions assessing specific safe rts technique necessary precisely tailor definitions terms technique computational model precision critical specification technique regression bias 
defining state definition 
state complete specification internal parameters computational model adopted program computing environment question time normally think state think contents memory registers 
completely characterize state purposes need include interfaces computer external universe 
essence state subsume significant factors internal model computer significance depends assumptions regression bias 
instance testers assume transient voltages gates state transition insignificant stable value matters rts technique requires state model transition 
included state constant inconsequential runs test cases 
nonvolatile storage hard disks instance generally viewed external computing device 
expect external object satisfy quality consistent test case allowing ignore 
hard disk sufficiently consistent subject domain incorporate disk computational model rerun test cases inconsistency issue 
instance test case consisting concurrent distributed transactions able ignore state hard disk particularly transactions required atomic 
course part state pertinent proving particular test cases fault behavioral equivalent 
particular exist dynamically changing portions state effect output behavior test case regression bias program test 
shall divide state domains gamma denotes transient state 
definition 
transient state subset state particular test case run arbitrarily changed causing exhibit different output behaviors 
existing safe rts techniques tend view computing device interpreter particular language 
safe rts techniques requiring stricter control require tester account hardware interactions 
fact techniques view computing device worldwide computer network complexity involved communication fundamental part state 
difficult domain specify 
usually varies time instance stack heap viewed part state program variables regions eventually dead join safe rts technique show execution test case differs execution know fault behavioral equivalent example changes consist changes variables referenced changes form involve specifying difficult section construct new safe rts technique substantial portions easily specified 
model include dynamic primitives operate static primitives constituting state model account fact dynamic primitives think code exemplifies differ dynamic primitives code combined computing environment generate 
example suppose testing system transparently implements remote procedure calls 
testers expect remote procedure call return bounded time particularly testing process designed centralized system distributed computing environments case usually long delays result error condition remote procedure call systems implement protocol 
problem course expectations behavior dynamic primitive subtly incorrect 
description dynamic primitives encompass potential dynamic effects correct dynamic primitive unexpected behaviors occur 
example incorporate processes concurrently executing computer state real time constraints exist round robin scheduled system sufficiently specified 
rts technique insufficient foundation indicate test case need re run fact running test case reveal real time error 
specifications need correct domain question encompass relevant factors 
past roles played different components dynamic primitives explored proofs difficult necessary hindering development common language safe rts techniques 
divide dynamic primitives domains semantic words valid agents rogue agents 
action state requires rogue agent act semantic word bind valid rogue agent 
definition 
semantic word semantic word oe semantic entity representing set expected program behaviors defined terms specific computational model subject inherent part regression bias 
definition 
agent set dynamic effectors enact semantic words enact behaviors potentially specified program 
definition 
valid agent set set agents transform expected behaviors semantic words real behavior physical machine valid agents definition regression bias definition 
rogue agent set set agents generate actions binding semantic word generate inappropriate actions specifications oe 
rogue agents definition create behavior consistent regression bias composition agent set respect specific safe rts technique depends way computing environment abstracted technique 
case safe rts techniques operate high level language constructs agent set account compiler assembler underlying hardware operating system potentially programs executing time 
agents satisfy expectations overarching abstraction assumed safe rts technique pose hazards safety technique 
agents necessarily operate moment program binding 
example compiler transforms high level language statement set assembly instructions translated machine language 
high level language level particular safe rts technique operates compiler component agent set semantic word binds action compiler occurs word executed 
presentations existing safe rts techniques included explicit discussions nature semantic word set associated agent sets assumed technique implicit assumptions sets 
instance shall discuss section dejavu pythia posit single statements blocks code constitute individual dynamic primitives 
currently designed techniques depend deterministic control flow ordered code execution safety 
course safe rts techniques need restricted regression biases underlying existing safe rts techniques 
section shall discuss safe rts technique spreadsheet languages depend deterministic control flow ordered execution code outputs programs languages deterministic 
techniques require deterministic outputs long certain deterministic constraints output behavior met random number generator example produce seemingly non deterministic output behavior correct 
iterative behavioral equivalence general problem proving programs fault behavioral equivalent arbitrary test case undecidable trivially turing reducible halt 
safe rts techniques restrict attention decidable approximation fault behavioral equivalence 
approximation safe need precise 
preceding definitions define decidable problem establishing iterative behavioral equivalence notion crucial semantic framework 
need definition execution trace general standard control flow definition 
definition 
execution trace execution trace records partially totally ordered set semantic words representing execution test case definition mention safety safe rts techniques require execution traces support inferences fault behavioral equivalence 
trace methodology supports inferences possible correctly infer looking orderings semantic words representing execution test case fault behavioral equivalent discuss requires semantic word set satisfy regression bias rts technique dynamic properties programs technique applied conform regression bias 
existing safe rts techniques execution trace represents sequential record code statements basic blocks functions executed test case assumed represent deterministic execution path program 
approximated traces commonly need execution order combined program parameterize set execution paths 
general traces safe rts techniques need restricted paths 
instance safe rts technique converts programs hierarchical plan representations execution trees execution dags children parent node occur order long precede achievement parent goal 
path execution traces identical traces exact copies dag execution traces equivalent dags reordered subject partial order identical dag reordered 
define iterative behavioral equivalence definition 
iterative behavioral equivalence finite length execution traces test case programs said iterative behavioral equivalent contain equivalent totally partially ordered strings semantic words 
iterative behavioral equivalence imposes stricter requirements equivalence fault behavioral equivalence 
fact iterative behavioral equivalence similar essential assumption leung white assumption asserts semantic word execution trace affect path computation 
behaviors semantic word set sigma map correctly corresponding behaviors real hardware iterative behavioral equivalence proves piecewise computations test case remain identical turn guarantees final result computation identical 
note definition specifies execution traces finite length reasonable assumption practice test run eventually terminate normal program termination forced termination tester 
testing processes create excessively large execution traces particularly test cases require long run times traces infinite store 
common solution dilemma discards information trace generated example keeping bit vector records semantic word executed 
culling information may lead false judgements judgements restricted conservative judgements preserve safety 
clearly problem determining fault behavioral equivalence similar post correspondence problem target reduction halting problem 
hand problem determining iterative behavioral equivalence decidable provided execution traces finite totally ordered traces traces converge step partially ordered traces traces reordered show equivalent orderings partial order converges step reordering possible 
fact propose simple solution iterative behavioral equivalence problem deterministic finite automata 
specify solution consider model technique derived directly definition 
iterative behavioral equivalent traces identical semantic word semantic word potentially reordering traces partial orders know process iterating pairs words start finish able recognize iterative behavioral equivalence 
deterministic finite automaton safe rts directly reflects definition inefficient subsumes techniques determining iterative behavioral equivalence 
create traces obviates need safe rts want avoid running test case method redundancy provides bound precision iterative behavioral equivalence techniques 
create automata traces respectively 
stated previously traces composed semantic words 
design automata corresponding trace accept language composed traces equivalent partial order 
totally ordered technique trace accepted partially ordered technique create machine accepts traces equivalent partial order 
stated trace equivalent partial order members permuted create exact duplicate trace permutation violates partial order 
machine exponentially large size trace focusing efficiency wish show machine possible 
designate languages accepted respectively 
know simple technique proving equivalence regular languages simply compute language 
clearly accepts language empty 
obviously approach approach choose implement safe rts techniques iterative behavioral equivalence attempt efficiently approximate solution produced inefficient technique 
significantly technique second formulation provide foundation efficient generalized safe rts technique section 
necessity obtaining traces primary finite automaton formulation 
second formulation finite automaton method efficient operates manner similar practical safe rts techniques 
requires convert graph representations graph trace correspond appropriate sequence nodes partial order 
section discuss constraints graphs satisfy support safe rts 
moment state graphs reflect precedence ordering semantic words contained ordering total semantic word set associated abstractions depended control flow order partial example ordering reflected control data dependencies 
key advantage formulation graphs determine test case definitely create equivalent traces ii iterative behavioral equivalence algorithm determine limitations bias trace graph construction functions lack trace requires transform trace finite automaton just finite automaton 
deterministic path trace results deterministic finite automaton state semantic word trace state outgoing state transition transition state successor receiving successor label 
partially ordered traces require state word trace 
particular automata include state sequences possible sequence node executions subject partial order 
note exactly process construct finite automata method 
create finite automaton corresponding graph representation graph representation automaton contains state semantic word abstracted program state occurence semantic word 
automaton built states contain transitions traces accepted automaton remember traces graph built semantic word set 
edges graph automaton labelled destination state 
automaton accept traces semantically occur example machine accept trace takes branch taken program condition branch true 
perfectly acceptable 
iterative behavioral equivalence process describe reject trace passes code rendered inert result changes create traces result execution accepted graph automaton fail occur traces compare graph automaton trace graph automaton accepts trace trace semantically occur simple example graph representation create finite automaton corresponds control flow graph cfg edges labeled destinations conditions lead edge taken normal convention 
start state automaton corresponds standard null start node added cfgs 
accepting state corresponds null exit node appended cfg 
course control flow graphs example apply subset programs 
core idea holds graph formulation capture ordered behavior program exemplified traces 
consider way trace graph automata combined determine test case responsible trace re executed 
consider simple case semantic words trace necessarily imply successor edge matter edges exit node corresponding word evaluation semantic word leads edge specified value generated semantic word edges condition exist 
constraint need determine language accepted trace dfa accepted graph automaton 
situations requirement semantic words imply successor holds 
semantic words characterize behavior program constructs cases characterize transitions 
hand language designers give semantic words default successors modeled graph representation 
instance graphical model style switch statements single node correspond switch condition edges corresponding particular cases 
particular cases edges edge taken specified switch condition 
particular case evaluated switch exist default edge taken edge corresponds default statement natural exit switch 
default edge taken necessarily depends case statements exist switch 
particular program giving word default successor defined behavior semantic word alteration state result labeled edges take default edge 
comparing programs default behavior undermine iterative behavioral equivalence 
particular suppose graph representations contain difference node exiting edge corresponding node 
nodes default edges 
case trace valid takes default edge node corresponding changed node longer proven equivalent techniques 
time trace take default edge trace equivalent small set possible default situations arise simple algorithm run problematic node consider set possible situations select basis 
foregoing automaton provide mathematical upper bound precision iterative behavioral equivalence techniques bound formulation provide pragmatic upper bound decidable safe rts techniques 
automaton fail precise automaton threat default behavior produces imprecision formulations dependent regression bias 
real safe rts techniques access traces necessarily accept certain level imprecision due default behaviors 
validity preceding formulations relies existence machine tell semantic words equivalent 
course semantic words smaller scale programs problem determining words equivalent undecidable ambiguity exists machine assume words 
fortunately safety requires machine tell words equivalent machine guarantee equivalence 
stable semantics condition equivalence machines finite automata methods just discussed prove test case excluded regression testing basis trace semantic words fully determine program behavior 
semantic words fully determine actual behavior changes state result binding semantic words oe valid agents validity finite automata methods depends existence equivalence machine safety requires machine output equivalent response semantic words equivalent regression bias satisfied 
validity equivalence machine entire finite automata formulation predicated premise semantic word set satisfies stable semantics condition define shortly 
point semantic word oe executed state set properties holds 
properties describe state point 
mean exactly thing state state static quality machine stronger quality entails fqg 
basically notation fqg describes specification property holds transformation oe acts hold completion strengthened definition somewhat suggest true implies terminates 
set properties implies action performed oe terminates leaves machine state satisfies property truth value implies system performs transformation oe proper specification 
fact property satisfied completion oe implies subsequent action pair subject property true satisfy subsequent set properties completion length program 
set behaviors form fp goe fp form alphabet delta 
essentially alphabet contains original alphabet semantic word set sigma conjoined valid regression bias bias holds elements sigma bind correct agents generating delta 
regression bias hold rogue agents compromise safety invalidating finite automata methods built basis bias 
safe rts algorithms programmers general manipulate semantic word set sigma 
words bind rogue agents unsafe situations occur 
example regression bias include assumption program statements eventually terminate 
basis construct safe rts algorithm relies notation derived 
program statements deterministically terminating 
suppose algorithm bias operates initial modified versions program selects test cases 
suppose contains send statement language send statements block 
forced external environment rigidly constant testing receiver send statement return response program perpetually block 
potential nondeterministic behavior undermines regression bias allows fault revealing test cases slip past algorithm 
terms definitions occurs oe bound generating different program behavior expected safety lost 
key hazard test suite fact dfr environment held constant 
designing semantic alphabet sigma models actions program environment completely specify behavior construct language including possible ways command interact environmental factors 
specifications safe rts algorithm view word dangerous 
semantic word complete correct specification programs test suites bias say semantic word satisfies stable semantics condition ssc 
formally action pair oe subject property corresponds function 
causes satisfied completion 
selected function subject constraints 
injective deterministic respectively 

acts transient state shall say satisfaction constraints semantic words oe implies ssc holds symbols alphabet sigma 
alphabet sigma words satisfy ssc necessary sufficient safe rts 
particular ssc considers behavior action word consider possibility rogue agents generating transformations state independently executing semantic words 
safe rts occur alphabet satisfying ssc show rogue agents spontaneously transform state independently semantic word execution ssc satisfied valid agents bind semantic words rogue agent set null provided rogue agents spontaneously occur 
equivalence machine describe dependent ssc machine part depends ssc absence non binding rogue agents 
semantic alphabet sigma words satisfy ssc equivalence machine take word execution traces constructed sigma determine equivalent 
perfect equivalence machine precisely determine equivalence represent equivalence outputting words equivalent 
finite programming languages possible machine exist require enumerate possible syntactic structure know structures provably equivalent 
general infinite languages particular perfect machine exist 
machine safe infinite language weaken claims 
essentially allow output absolutely sure words equivalent output 
safe outputting zero merely force tests selected possibly omitted 
equivalence machine job possible label symbols sigma handles machine recognize 
simply lexical name programming language construct model case semantic words correspond directly constructs programming language provide simple handle 
altogether material gives rise theorem 
theorem 
sigma alphabet regression bias 
stable semantics condition holds sigma oe sigma deterministically recognized equivalence machine constructed judges semantic words equivalent incorrectly long holds 
proof theorem follows immediately preceding discussion machine construction 
generalized safe regression algorithm primary problem create automaton entire trace test case analyze entire trace automaton 
traces arbitrarily large size program technique inefficient 
generate efficient technique approach needed 
key design efficient algorithm realization differences cause test case behaviors diverge 
focused traces deduce test cases diverge analyzing program extracting information allows efficiently select test cases 
analyses worst case costs polynomial size programs 
create safe approximations traces polynomial size program generate technique efficient 
fundamental goal safespace algorithm section 
safespace accepts certain level imprecision unavoidable full traces going examined safespace employs potentially imprecise efficient approach 
discuss extension safespace precise requires polynomial time analyze graphs requires time polynomial length full traces achieve maximally precise test selection 
presents safespace algorithm 
algorithm constructs graph representations semantic word set sigma traverses representations depth manner constructing signature graph sig represents footprint domain code programs proven iterative behavioral equivalent 
shall demonstrate safespace serves basis construction iterative behavioral equivalence algorithms acts template generation new safe rts algorithms providing skeleton fleshed details specific particular safe rts problem 
safespace behavior provide safe rts techniques applicable program domains existing techniques addressed declarative visual programs example 
shall demonstrate safespace basis proofs safety existing methods 
approach similar finite automata approach safe rts algorithms developed ball ball approach developed control flow algorithms approach general encompass wider range iterative behavior equivalence techniques 
proc safespace input programs output intersection graph sig edges structure select node 


construct graphs executing ffi ffl functions 
add start nodes edges start nodes 
roots trees 
add select node empty graph sig 
add sig 
compare null 
return sig 
proc compare input nodes edge 

match edges 
edge lacks corresponding edge 
redirect edge select node sig edge null test cases rerun 

mark visited 
edge matching 
add edge node sig select node 
matching edge 
false 
add edge sig select node 
marked visited 
continue 
marked visited true 
reentrant trace solution 
add node edge sig 
compare 
endif 
endfor 
endif 
generalized safe rts algorithm sections details safespace 
section defines paired traversals underly algorithm function correctness 
section describes graph structure algorithm ffi ffl functions create structure 
section describes details graph walk portion algorithm encoded compare procedure 
section describes extensions algorithm increase precision 
paired traversals indicated safespace idea efficient safe rts technique operate directly traces 
safespace operates graph representations programs producing signature graph size polynomial sizes programs 
correctness process predicated idea paired traversals 
paired traversal pair sequences nodes created simultaneous walk graphs corresponding theorem shows paired traversal proven equivalent constituent sequences proven equivalent inductively nodes shown equivalent continues equivalent note similar definition iterative behavioral equivalence section paired traversals contain sequences equivalent partial order total order case partial orders inductive proof switches equivalence individual nodes equivalence completion sets equivalent partial order 
equivalent node node equivalence reordering 
theorem significant justifies subsequent corollary corollary states paired traversals proven equivalent remain equivalent proven equivalent 
corollary justifies approximation inherent safespace footprint sig safe space shall define acts proxy traces execute semantic words domain 
theorem 
paired traversal induced test case graphs node corresponding node defined machines shown equivalent partial order implicit trace function equivalent stable semantics condition holds converge identical states satisfy identical properties actions proof consider case totally ordered traces 
stable semantics condition holds symbols sigma occurring traces rogue agent set empty initial set properties guaranteed equivalent start traversals know transformations state engendered traces identical step 
paired traversals defined totally ordered traces converge step trace partially ordered traces hand need converge step 
definition partial order imposes strict requirements allow iterative behavioral equivalence 
essence traces equivalent trace reordered violating partial order perform equivalence test identical total order test prove equivalence 
hand traces equivalent permutation exists 
simulated totally ordered traversal identical behaviorally permutations allowed traces family iterative behavioral equivalent 
note partially ordered traces general problem earlier section undecidable 
general problem allows violation partial order proving equivalence general problem requires tractable solution post correspondence problem 
corollary 
proven equivalent paired traversals equivalent equivalent essence corollary allows focus graphs prove equivalence sets traces just single trace 
traces passing proven equivalent remain equivalent equivalent nodes 
process establishing paired traversals simultaneously walking constructs graph isomorphic subgraphs call graph signature graph sig call program space represented graph safe space 
due corollary signature graphs serve proofs test cases traces remain entirely sig need re executed 
need directly map test trace safe space prove trace remains entirely signature graph 
cutset edges separates subgraph corresponding signature graph sig rest record cutset determine test case needs re executed 
trace starts sig contain edge cutset know test case corresponding trace need re executed 
represents substantial savings time constraints problem allow subgraph isomorphism accomplished low order polynomial time allow safe approximation traces edges 
experiments existing techniques suggest practice approximation provides results precise non approximated techniques 
constructing graph representations ffi ffl functions step generalized algorithm safespace transform program elements semantic alphabet sigma order elements graph structure 
tasks performed ffi ffl functions respectively 
ffi function takes raw program including code specifications environmental behavior discussed section explicitly converts data set instances semantic words specified requirements regression bias 
ffl function orders set semantic words graph structure requirements particular safe rts technique 
choice ffi ffl functions critical efficiency algorithm 
ffi ffl functions define size graph representations turn affects execution time memory space utilized determine function implements equivalence machine function operates pairs semantics words just equivalence machine 
designers ffi ffl functions consider functions semantic alphabet sigma regression bias suffice safety 
example suppose semantic alphabet designer decided semantic word designating interprocess communications 
applications suffice applications blocking non blocking send receive protocols 
clearly changing protocol result different behavior considered semantic alphabet 
similarly designer ensure function ffl represents precedence orderings interested 
example discussed earlier partial order sufficiently strong 
ffi ffl functions ensure stable semantics condition ssc holds chosen alphabet programs covered regression bias ensure ssc fail failure detectable 
example consider simple branching construct illustrated 
contains simple style statement graph illustrates possible representation code 
case ffi ffl functions create single decision node branch edges leading successor nodes 
components code absorbed node representation 
large dense statements representation may reflect branch tables generated assembly code statements 
sparse branch statements representation may reflect code 




default default default 
graph constructions statement 
generated presents representation reflecting cascading branch code generated sparse branch statements 
safe rts techniques particular choice representation case irrelevant choice may significant 
suppose example modeling real time system compiler constructs branch table 
maintain response time required speed branch table large dense switch statements 
semantic word set graph structure inherently accounts maximum response times inputs assigns particularly low value decision node assumes efficient branch representation 
compiler produces cascading branch sequence specification statement incorrect safety may violated 
course non real time systems interpretation large may irrelevant 
choice informed subject domain transforms regression bias 
section consider safe rts algorithms various ffi ffl functions specify conditions operate safely 
finding safe space consider graph walk portion algorithm encoded compare procedure 
aspect algorithm derived standard depth search algorithms making structurally similar dejavu ball algorithms 
algorithm acts extending safe space sig safespace prove pair edges lead pair nodes equivalent algorithm changes destination edge select node 
test case trace mapped sig encountering select node re executed 
safespace proven long regression bias holds test case fault revealing 
note algorithm adds edge node select node number edges outgoing changes 
simple example actual code statements semantic word alphabet control flow ffl function adding new edge outgoing node representing switch statement adding new switch case cause test case exercised default edge exercise new edge 
occur execution trace includes changed entities 
note visited condition 
safespace algorithm descend pair nodes examine equivalence 
sits pair nodes proven equivalent looks edges pairs successor nodes checks successor nodes equivalent line marked visited proceed traversal beneath lines 
note marked visited trace looping back trace looping identically back trace 
call reentrant trace problem discuss section 
instantiation safespace algorithm choice reentrant trace solution function acts case choice affect precision efficiency resulting rts technique 
copes reentrant traces depends instantiation safespace algorithm 
safe rts algorithms practice dealt problem different manners 
rothermel harrold algorithm dejavu instance continues safe space traces equivalent nodes technique locates semantic words 
case dejavu effectively directs edge select node test cases traces reentrant associated edge 
ball family safe rts algorithms hand address reentry problem sequence progressively precise ways require progressively greater computational expense 
essentially algorithms attempt store extra information reentrant trace improve selection traces 
basic formulation safespace selects test cases need worry reentrant traces sig sufficient selection 
consider different choice reentrant trace 
note re entry problem basic formulation safespace algorithm powerful 
problem harvest test cases safe space different nodes select re execution unnecessarily happened nodes guaranteed iterative behavioral equivalence 
possible tracked mutual behavior traces eventually pair nodes equivalent node sig way possessed equivalent states satisfied identical properties 
resume execution strand need selected retest 
reentrant trace scenario observed occur practice chosen select reentry basic formulation 
techniques benefit different solutions proof algorithms require different solutions incorporated possibility extension 
recursive calls compare initiated line safespace complete algorithm returns sig previous safe graph walk algorithms explicitly constructed sig returned edges attempt approximate directly selected tests basis edges 
shown ball cfgs form edge selection result imprecision worst case 
constructing sig returning eliminates particular form edge selection imprecision cost storing copy sig mentioned safe space solution add different source imprecision 
provide solution suffer imprecision safespace returns sig solution selecting maximally precise test suite requires examining trace arbitrarily long length program 
brief analysis shows graph walk portion safespace basic reentrant trace solution operates jn jej time identical programs check node edge 
provides basis gauging time spent ffi ffl functions early stages algorithm construction determine number nodes edges determine total running time functions dwarf algorithm run time 
example illustrating occurrence reentrant trace problem proving reentrant convergent traces identical safespace algorithm just described precise 
safespace select test cases execution path nodes corresponding safe space nodes sig sequence semantic words executed remains 
concrete example consider graphs shown 
start exit nodes omitted graphs simplicity 
graphs identical node labels imply semantic words represented nodes identical 
possible traces see programs represented graphs semantically equivalent 
safespace prune test case takes edge edge safe space corresponding edge takes edge continuing node visited node 
semantic word represented node identical word represented node reached safe space node point divergence computation occurred 
fact graphs divergence occur 
define problem determining semantically identical traces executing divergent paths remain equivalent reentrant trace problem 
extending safespace provide greater precision presence reentrant traces arguably impractical 
extension safespace necessarily create longer run time current method stops reentry new methods generate new forms imprecision 
time practical cases observed reentrant trace problem occurs cases examined far contrived 
possible cases exist practice situations cost test cases may sufficiently high justify small possibility eliminating 
abstractions control flow result graphs reentrant traces common case employing different strategy useful 
proofs extensions hold central location 
shall discuss section instantiation safespace proof regression bias subset regression bias technique proven safe 
example technique proven safe select reentry basic formulation safespace selects test cases selected technique reentrant traces factor underlying pathological example program dejavu imprecise trace reentrant result case :10.1.1.30.3199
consideration 
means safespace accidentally possess larger bias technique consideration proven safe set programs subject technique necessarily safe 
essence invisible assumptions slip regression bias safespace entire proof 
possible alternatives reentrant trace function 
alternatives result inefficient safespace algorithms 
practice choice extension economic considerations constructing proofs efficiency irrelevant choice safespace regression bias subset bias technique proven safe close subset possible 
extension safespace algorithm safe space rss solution 
extension safespace algorithm precise method requiring jn time construct sig test selection portion extension requires entire traces examined 
algorithm requires factor jp space safespace worst case examples result behavior contrived 
chosen extension potentially useful new techniques proofs particular rss solution proof dejavu section 
safe space solution safe space rss solution provides alternative original reentrant trace solution previous sections 
original reentrant trace solution selects edge safe space contrast rss solution continues spawning duplicates nodes steps taken rss version reentrant trace called 
node previously marked visited fx fx node compared 
source node compare called 
steps algorithm follows 
duplicate creating dup add pointer dup base node edge connected dup 
mark dup originally visited 

add pointer dup 
mark dup visited fx 
pointers mark nodes previously spawned visited 

call compare node pairs reachable edges exiting dup source edges nodes edges lower stack left 
lets illustrate procedure 
proceeding start nodes omitted simplicity algorithm reaches nodes finds equivalent adds node sig marking originally visited 
suppose algorithm considers self looping edges nodes notes labels destination nodes identical visited walk forward nodes 
algorithm considers edges finds equivalent dup stack graph sig graph graphs sig rss solution 
adds node sig marked originally visited 
edge leaves node edge leads node leads new node basic formulation safespace algorithm note safe space direct edge select 
rss solution algorithm duplicates node creating dup stack 
new node marked originally visited 
edges leaving node corresponding edges lead equivalent nodes causing edges point nodes marked originally visited originally visited respectively 
algorithm terminates having selected edges 
note edges graphs pointers inserted rss solution 
pointers included representation exist support node stack data structure 
notice different roles played extension safespace 
guides creation bottom layer nodes sig corresponding exactly concept safe space basic formulation safespace algorithm 
plays active role determine equivalence guides stacking process nodes 
addition determines node stack new edge added 
interaction changes concept safe space extension safespace algorithm 
essence safe space adds dimension safe space generated basic algorithm 
call sig cross safe space rss extension 
bound run time solution create new copy node reenter safe space node safe space marked visited 
know step safespace marks node visited node 
presume graph contains nodes graph contains nodes node acquire jmj visited flags require contrived program generate 
steps need taken 
step creates new pointer links nodes stack new edge added preceding node new node total run time nm 
rss solution analysis phase complete select traces just regular safespace algorithm run traversal cross safe space sig trace reaches exit node example illustrates case sig size clearly sig size prove invert graphs vice versa 
point imagine sig restricted maximum happens case 
nodes appear different stacks sig ensuring size sig exceed select node 
test cases traces select node rerun rest need rerun 
course want maximal precision need run entire trace sig require time unbounded size program 
suggested basic formulation extract information sig select test cases 
doing certain amount precision necessarily lost 
rss solution primarily intended proofs approximation unnecessary cases care time algorithm takes bias contained bias technique proven safe shall elaborate shortly 
applications framework framework safe rts techniques including semantic model generalized safe rts algorithm show framework applied real world problems 
particular framework facilitates tasks 
proving existing rts technique safe 

defining set programs rts technique safe 

generating new safe rts techniques 
provide example application framework problems 
describe demonstrate step process framework assess safety regression bias rts techniques dejavu subject 
doing define regression bias dejavu describing set programs dejavu safe 
second illustrate generality framework section sketch application additional safe rts techniques pythia testtube 
section framework create new safe rts algorithm targeting languages 
subsequently discuss techniques facilitate development safe rts techniques ways specifying regression biases testers able easily recognize safe rts problems close problems faced past allowing reuse pre existing techniques 
analysis safety regression bias dejavu turn illustration framework analysis existing rts technique dejavu 
proceeding illustration briefly summarize dejavu technique 
readers interested greater detail dejavu consult 
dejavu rts technique dejavu technique family related algorithms performing safe rts 
member family implemented tool subsequently evaluated empirical studies determine precision efficiency variety sample programs test suites 
dejavu requires transform source code control flow graph cfg representations 
cfgs required dejavu node simple statement program transitions model explicit implicit control flow statements 
start exit nodes added cfgs simplify analysis 
depending version technique cfgs span single procedures multiple procedures 
formulations dejavu single procedure cfgs union test cases selected procedure constitutes dejavu requires approximation control flow execution trace test case definition 
control flow execution trace record code statements executed test case program order execution 
dejavu maintain entire execution trace test case tool maintains bit vector denotes edges cfg traversed omitting order traversal traversal frequency 
trace information dejavu executes pairs cfgs identically named procedures generating set dangerous edges test selection 
describing process define concepts underlying dejavu 
definition 
modification traversing test case test case modification traversing execution trace identical execution trace token token comparison semantic words associated nodes traces 
definition 
modification revealing test case test case modification revealing execution produces different output behavior produced definition 
fault revealing test case test case fault revealing execution reveals fault definition 
dangerous edge dangerous edge edge cfg dejavu guarantee test case traversing edge non modification traversing shall discuss detail examining dejavu regression bias selecting tests dangerous edges dejavu selects test cases modification traversing 
shows certain conditions hold test cases include test cases modification revealing contain non obsolete test cases fault revealing presents basic dejavu algorithms :10.1.1.30.3199
numerous optimizations added algorithm dejavu precise discussed 
purposes algorithm suffices 
algorithm operates simultaneously traversing cfgs traversal edge leads pair nodes statements represented nodes differ algorithm adds edge leading pair nodes dangerous edge set 
addition algorithm reaches edge corresponding edge places edge dangerous edge set 
simple version node node pair outgoing edge match outgoing edge version algorithm adds edges leading dangerous edge set 
extra edges result preceding edges selected extra edges represent changes behavior due additions new switch cases 
algorithm input base modified versions procedure output set dangerous edges 

oe 
construct cfgs entry nodes 
compare 
return 
procedure compare input nodes 

mark visited 
successor 
label edge ffl unlabeled 
node label null edge 
null 

marked visited 



compare 
endif 
endif 
endfor 
edge lacking corresponding edge 
locate directed edges vertex 

endfor 
dejavu algorithm 
analysis proof safety point wish provide example proof safety involving safespace 
proofs predicated safety general formulation safespace components safe safe ffi ffl functions instance shown general formulation safespace safe selects test cases traces exit sig 
safespace safety construct proof safety technique generating proxy algorithm technique 
proxy built safespace structural guideline components semantic words state models ffi functions emulate behavior technique proven safe 
rts technique wish prove safe ab target regression bias prove safe construct proxy algorithm instantiation safespace algorithm designed emulate specified behavior emulation need exact approximations cause select larger number test cases long set test cases selected superset set selected proven safe know safe 
ensure particular safespace instantiation appropriate proof complete tasks target bias ab need de facto bias interested proving safety subset programs testing methodologies fact applies 
target regression bias contained actual bias rest presentation assumption case 

prove safe regression bias ib ab 
prove test case selected selected substituting hard problem equally hard problem step 
safespace deliberately designed enhance clarity depending primarily conceptually simple idea safe space clarity fact important reason restricting cross safe space extension 
proven safespace safe long components fulfill restrictions discussed section 
complete proof need construct component functions descriptions primitives technique proving pieces technique fulfill requirements stable semantics condition prevent rogue agents 
course step discover create technique safe ib ab components emulate tells basic primitives logic insufficient safety 
describe step proof process rts techniques logic described description emphasize iterative nature process 
particular logic described demands definition technique regression bias programs test suites safe 
practice proof process fully understanding characteristics reflect bias process proceeds find initial assumptions bias insufficient overly general 
fundamental part safe rts process establishment regression bias fundamental part safe rts proof establishment safety defined bias 
step proof consider bias sufficient task hand 
step proof process 
establish regression bias ab rts technique proven safe 

specify state model semantic word set sigma fulfill regression bias 
explicate nature agent sets relation bias consider ways semantic word set state model fail reflect real program behavior 

construct safety preserving ffi ffl functions sigma 

transform trace information execution traces safespace semantic word set sigma ordering implied ffl function 

show safespace instantiation established steps regression bias containing show selects test case selects note safespace instantiation safe rts algorithm need state model semantic word set general may easier prove technique safe general algorithm views code way need case 
particular structure rts technique differs depth search primitives adapted depth search sense 
alternatively different formulation generalized safe rts algorithm 
step establish dejavu regression bias dejavu imposes requirements subject programs 
dejavu requires test cases fault revealing modification revealing test cases modification traversing noted section shown certain conditions dejavu selects test case modification traversing 
approximation regression bias say dejavu safe situations fault revealing test cases modification traversing 
need specify types programs true types true 
general fault revealing test cases modification traversing 
order fact test case fault revealing imply modification traversing correct exhibit equivalent behavior traces exhibit fault inherited dejavu regression bias includes assumption faults occur deterministically test suite run faults discovered corrected introducing new faults correct problems arise result bias attempt correct fault attempt fail second nondeterministic behavior hide fault remaining system 
problem easily rectified test cases exposed faults rerun regardless results dejavu analysis 
nondeterministic test cases see easily handled dejavu 
nondeterministic test cases explore different input output relations different runs 
particular different runs test cases explore different regions input space result execution different paths code 
nondeterminism exists test case assert correct execution test case proves test case exhibit fault 
dichotomy nondeterminism particular interest explicit nondeterminism versus implicit nondeterminism 
explicit nondeterminism occurs software designers intend code behave nondeterministically control behavior testing process 
implicit nondeterminism occurs software sensitive aspects environment strictly controlled testing environments 
simple example explicit nondeterminism random number generators create nondeterministic sequences numbers 
key feature explicit nondeterminism testers freeze behavior nondeterministic segment code 
general explicit nondeterminism dealt calculating valid deterministic behavior replacing nondeterministic code code reproduces effect 
instance pseudo random number generator seed run program 
implicit nondeterminism hand represents worst rogue agents 
implicit nondeterminism includes type random behavior localized predicted controlled 
instance real time program page faults possibly significant effects response time usually note analysis dejavu great deal knowledge dejavu safety proofs new techniques significantly knowledge 
discussed section obsolete test cases removed obsolete test cases certainly modification traversing need fault revealing 
obsolete test cases disposed incorporated process testing new functionality task subject 
strictly speaking absolutely true 
cases known small set nondeterministic behaviors occur see entire set multiple runs know possibility exercised 
general nondeterministic test cases behaved 
predicted 
similarly multi threaded programs statements may executed nondeterministic order resulting nondeterministic behavior shared variables incorrectly accessed output behaviors properly synchronized 
explicit nondeterminism implicit nondeterminism forces refine regression bias 
initial definition dejavu bias required test case fault revealing imply modification revealing turn imply modification traversing 
satisfaction requirement requires correct know proven correct deterministic nondeterminism consistent requirement 
dejavu regression bias includes programs transformed trivial changes trivial depends constraints testing process programs behave deterministically significant ways 
note bias restricts code constructs type program 
instance applying dejavu arbitrary real time program difficult accomplish preserving safety 
trivially change real time program behave deterministically perform changes changes violate timing dependent nature program 
specifically dejavu obviously safe programs compute values time independent fashion 
words dejavu obviously safe multi threaded programs programs poll outside environment nondeterministically arriving input program exhibit different execution traces different runs due varying inputs varying internal states computer 
programs act linear fashion react consistently input regardless input occurs 
programs dejavu regression bias holds 
addition dejavu targets imperative languages 
dejavu uses control flow graphs select dangerous edges 
languages spreadsheet languages shall see control flow relevant 
dejavu regression bias considered relation programs testing methodologies 
example dejavu approximates traces bit vectors test methodology program uses polling guarantee input consistently arrived polling structure asked consistently arrived loop poll processed dejavu operate safely program 
guarantee section code executed runs test case runs generating faulty traces 
constraint traces identical dejavu records statements executed frequency 
testing methodologies integral part regression bias safe rts technique constitute part space bias valid 
software amenable safe application dejavu testing methodology 
step specify state model semantic word set agent sets point specified expectations regression bias dejavu preliminary considerations nondeterminism 
explicitly consider mapping code primitives assumed dejavu order expose potential threats safety algorithm 
dejavu uses fairly simple abstractions code mapping fairly simple 
analysis techniques operating higher level abstractions specifications interpretations programs plans need explore relation primitives code computing environment greater depth 
dejavu incorporate aspects external environment semantic word statement statement statement jmp statement beq addi statement corresponding mips assembler code 
term represents value register strictly speaking refers particular register 
set dejavu assume external environment constant external environment part state dejavu 
standard definition state program memory 
dejavu bias contain programs dependent high response times need concern caches virtual memory assuming coherent 
assume computing environment identical execution specifically requirement entails compiler operating system machine configuration build test build test general code subset state live data values gamma placing code counterintuitive code directly affects program execution 
program studying viewed external state code case affect program program rewrite code generally case languages modern computer systems 
semantic word set simple 
dejavu examines code statement level semantic word corresponds single simple code statement 
semantic word normalized code statement lexically identical word sigma 
infinite number possible semantic words sigma particular program contains finite number 
agent sets associated properties hold fail hold rogue agents 
words valid agent set consists boolean expressions equivalent compiler equivalent os expressions true 
rogue agents consist expressions expressions true 
essence semantic word bound agent truth boolean expression determines agent valid rogue 
expressions hold executions semantic words recall properties hold semantic word executions 
rogue agent acts non transient state independently execution semantic words violates model program behavior 
consider specification simple set semantic words dejavu set words originating construct 
assume set potential expressions proven safe unsafe 
expression safe automatically reject test cases traversing regardless safety construct 
safety potential expressions proceed prove safe construct respect dejavu 
statement clear interpretation 
assuming format format produced compiler ignoring existence additional clauses brevity readily specify behavior uses mips assembly language 
equivalent code generated modern assembly language 
construct 
expression proven safe unsafe safe need worry construct 
safe correctly produces value specified peculiarities language 
equal beq statement executed beq changes program counter statement executed 
execution statement jump occurs label statement 
behaviors possible assembly code fully characterizes behavior regression bias dejavu holds 
deterministic construct safe dejavu 
course specification terms assembly language approach proving safety 
formal proof methods statement informal natural language descriptions depending demands placed testing situation 
step construct ffi ffl functions instantiation safespace prove safety rts algorithm construct ffi ffl functions functions may duplicate processes may simplify processes key constructing functions cases regression bias holds functions ensure selects set test cases equivalent subset set test cases selected ensuring functions maintain relationship ensure proof safe implies safe 
function 
instantiation safespace constructing function arises naturally description semantic word set 
dejavu semantic words identical normalized lexical values words identical 
dejavu instantiation safespace semantic words statements remove comments spurious white space simply compare statements determine lexicographic equivalence 
choice suffices safety depends rest step process moment partially justify choice 
section stated function output equivalent semantic words produce equivalent behaviors identical states 
nondeterministic constructs program automatically select test case encountering operate deterministic constructs 
outputs equivalent statements lexicographically identical behaviors equivalent words identical 
function meets requirements specified section 
note equivalence context imply transitions taken nodes nodes equivalent 
ffl functions needed 
turning ffi ffl functions functions act code program environment create graphical abstraction program 
arbitrary graph representations sufficient safety regression bias interested 
specify ffi ffl functions consider mesh safespace 
ffi function break program nodes processed function 
similarly ffl function order nodes graph intersection process creates meaningful safe sig note safespace selects basis function considering edges node justifications selection stage arise naturally ffl function preserve safety 
tasks ffi ffl just preserve safety construct safespace instantiation simple regression bias contained true regression bias preferably bias simple transcribe set guidelines evaluating safely particular program 
ffi function safespace instantiation dejavu simple fact specified constructed function 
ffi function maps individual code statements nodes 
note definition statement somewhat idiosyncratic dejavu entire loop single statement instance statement line statement statement contained body loop 
necessary allow fine granularity 
stated earlier ffl function orders statements creating links nodes specified partial total order 
case instantiation safespace constructing dejavu ffl implements total order structures nodes control flow graph 
note cases edges added deleted dealt safely safespace algorithm 
previously shown ffi function suffices safety 
safe ffl function link nodes test trace mapped signature graph select node encountered test case need re executed 
case dejavu control flow ordering sufficient safety 
dejavu course uses approximated traces stated earlier precise interpretation algorithm desirable decided create safespace instantiation full traces 
step proof process show test cases selected basis full traces selected approximated traces approximated traces result extra test cases selected 
section describe different graph formulation testtube process followed dejavu safety dejavu easily demonstrated approach 
note turns ffi function simpler ffl function dejavu need case 
abstractions simple orderings require pervasive global transformations ffi function 
step construct abstracted execution traces safespace perform test selection task subsidiary process uses sig ensure execution traces suffice safe test selection basis signature graph 
traces constructed building blocks graphical representations obey precedence rules traces paths graph graphs 
traces mapped string semantic words 
key safety trace lies correctness semantic word set ordering graph 
semantic word set satisfies ssc rogue agents transform state semantic words traces embedded graph sig means edges select occur trace test case safely excluded 
primitives ffi ffl functions dejavu construction traces real trace data simple 
convert existing statement level trace information semantic word set ffi ordering primitives trace sequence execution 
note transformation necessarily affected ffi ffl 
ffi ffl functions act constructing graphs execution traces hand created information gathered previous executions oftentimes creation execution traces similar creation involves constructing subgraph information corresponds directly subsets traces suffice role safe traces safespace instantiation dejavu trivial sig represents subset control flow graph turn cross safe space sig 
trace select node way sig traversing select edge 
step show ib ab selects selects 
steps proof process guide regression bias technique amenable safespace instantiation 
viable bias ab specified safespace instantiation proven safe bias 
process constructing defines bias ib bias show things bias ib proved safe equivalent superset desired bias ab proper subset real bias selects test cases selects ab concerned may obvious ib actual superset ab take advantage fact ab specified bias de facto bias real technique 
specified bias strictly detail properties set programs test suites contains ib superset bias real technique contain bizarre outlier programs accidentally safe 
sufficient purposes interested proving technique safe particular regression bias actual regression bias purely academic interest 
need ensure bias contained bias done ensuring precise discuss step 
concerned show fault revealing test case selected ab equivalently ib select test case 
criterion precise programs ib precise means safe ab 
ensure containment dejavu rss extension safespace earlier 
basic formulation safespace dejavu selects edges encounters nodes lexically different encounters nodes changed numbers edges different labels edges 
similar rss solution discussed section dejavu construct cross safe space 
dejavu selects test cases traces contain edge lead changed nodes particular test cases reentrant 
prove dejavu safe ab steps completed need show programs test suites space covered dejavu selects test case selects test case 
shows safespace adds edges point select node places lines 
line corresponds case node edges possessed node original graph case possibility default edges safespace select edge leading node pair 
dejavu selects identical edges due lines dejavu algorithm 
second case line occurs edge exiting node counterpart node corresponding modified program dejavu selects edges lines 
third case line safespace edge added node reached equivalent node reached edge 
case instantiation safespace algorithm function lexical equivalence means edge leading lexically different nodes selected 
notice lines dejavu algorithm exactly edges selected 
final case line safespace result selection test cases instantiation safe space solution 
note dejavu selects test cases associated edge selects test cases associated edge 
safespace rss selects test cases edge selects test cases pass node stack connected edge 
dejavu selects test cases safespace selects test cases selected safespace 
analyses safe rts algorithms dejavu example safe rts algorithm 
section briefly consider existing algorithms pythia testtube light framework previous analysis dejavu 
doing gain insights framework 
pythia shall focus safe rts technique bears closest resemblance dejavu pythia 
fundamental goal briefly show pythia regression bias essentially dejavu doing suggest framework utilized constructing proof safety pythia 
pythia performs safe rts programs 
dejavu pythia proves equivalence lexical identity 
generating cfgs performing analysis pythia uses commonly existing unix tools directly perform textual differencing subject programs 
pythia uses unix tool pretty normalize source files pythia divides normalized source code basic blocks basic blocks constitute semantic word set instantiation safespace modeling pythia 
state agent sets instantiation safespace identical dejavu instantiation safespace 
pythia uses basic blocks pythia execution traces identical dejavu elements basic block transitions statement transitions 
dejavu pythia relies transition model control flow basic blocks determine sequencing pythia transition model explicitly constructed determined implicitly syntax code statements required test selection process 
normalized files divided basic blocks pythia executes unix tool diff normalized programs attempting locate blocks changed 
simple case internal structure blocks changed pythia provides solution accurate dejavu 
case block structure changed pythia defaults safe alternative level analysis selects block determined safely precede changed block terms control flow 
approach create greater imprecision exhibited dejavu 
description close relationship pythia dejavu apparent construct proof safety pythia 
essentially safespace instantiation pythia identical instantiation dejavu set primitives composed basic blocks code statements 
basic block just linear set code statements graph simply condensed form graph interested efficiency proof need select preceding basic block block structure changes inefficiency result unix tool diff traversing blocks control flow order illustrates proof safety rts algorithm may utilize safespace instantiation greater precision result pythia selects test cases selected dejavu clearly pythia safespace instantiation safe regression bias ib dejavu safespace instantiation instances pythia dejavu imprecisions respect safespace instantiations result extensions types program covered regression biases dejavu pythia 
testtube testtube performs safe rts lexical analysis level symbols global namespace programs 
testtube functions macros types global variables exist 
current version testtube relies existence subsidiary tools including program instrumenter app program entity database cia set scripts constitutes testtube 
dejavu pythia testtube relies lexical equivalence testtube approach simpler 
cia database associates checksum information entities global namespace program versions 
testtube compares checksums identical global symbols program versions determine ones differ 
testtube determines entities influenced differences changed entities 
instance global variable changed function henceforth considered changed functions called changed function considered changed 
execution traces testtube generated app instrumenter records set functions invoked test 
information conjunction cia database generate list entities potentially affected changed functions 
list entity difference list generated cia program versions indicate test case safely excluded 
testtube resembles dejavu pythia ways structural differences 
significant difference testtube explicitly consider control flow order test traces list functions called global entities potentially referenced particular order imposed 
viewed just approximation dejavu pythia appropriate view testtube right 
safespace instantiation testtube reflect testtube unique qualities 
safespace instantiation testtube set semantic words contain checksum ids functions macros type definitions global variables program global namespace 
testtube models state agent set parallel dejavu pythia 
traces safespace proof resemble regular testtube traces consist set unordered semantic words 
testtube extra symbol added trace entities trace partially ordered occur 
symbol ordered member trace 
testtube explicitly consider control flow order unordered graphs proof 
specifically ffi maps semantic words programs nodes particular order 
ffl function joins nodes complete directed graph shown 
edges graph labeled value destination 
start node added connected nodes graph 
edges leading start node nodes labeled id destination note change denotes cases entity added deleted modified 
void function void function void function start define macro left function declarations macro labeled letters right graph representation program node 
node corresponds extra semantic word placed execution traces added directed edges added node nodes start node 
execution safespace changed node cause edges diverted select node execution traces containing changed entities necessarily select node sig matter order entities traces course 
provide proof regression bias safespace instantiation necessarily contains bias dejavu 
case dejavu testtube shown select modification traversing test cases testtube shown select test cases selected dejavu 
testtube explicitly consider control flow testtube bias non trivially larger biases dejavu pythia noted section means set programs testtube safe potentially larger testtube effective technique 
utilizing safe rts framework create new algorithm far safe rts framework prove rts algorithms safe 
consider framework facilitating creation new safe rts algorithms 
example propose new rts technique designed spreadsheet languages imperative programs addressed dejavu pythia testtube 
best knowledge new rts technique safe rts technique targeting programs outside deterministic imperative regression bias 
demonstrating framework context provide evidence framework generally applicable 
fact previous studies authors shown testtube cost dejavu depending details subject programs test suites 
algorithm particularly interesting framework creates widely applicable declarative languages particular template functions inappropriate different sets requirements govern graphics content languages 
example spreadsheet languages vrml nodes contain geometry links route messages nodes 
structure suggests partial order approach spreadsheet languages useful vrml vrml complications considered spreadsheet algorithm instance node hierarchies infinite message loops script nodes potentially meshing declarative paradigm 
formula blank expr expr constant constant expr gamma line box inlist 
table subset forms grammar 
creating safe rts algorithm spreadsheet languages useful goal 
techniques testing programs spreadsheet languages differ techniques testing programs imperative languages 
differences discussed refer reader detail 
spreadsheet language paradigm forms term spreadsheet languages refers class declarative visual languages sets formulas generate outputs usually final outputs written screen intermediate calculations performed invisibly 
spreadsheet languages potentially express wide range behaviors chosen consider representative languages subset visual research programming language forms 
table presents grammar subset 
subset chosen represents behavior typical spreadsheet applications 
depicts forms program containing cells formulas displayed program calculates root quadratic linear equations 
illustrates traditional spreadsheet languages forms restrict cells grid pattern 
create program users place formulas individual cells system responds edits updating cells visible cells depend cells 
formulas cells access results cells imposing causal ordering set nodes satisfied correct computation 
general possible sequences formula evaluations leading correct results evaluation engine running beneath scenes free choose order provided data dependencies cells maintained 
correct forms programs guaranteed halt due absence cycles causal ordering 
testing process model spreadsheet language model 
execution test case spreadsheet involves placing test values input cells cells formulas constant checking query cells output cells interest program updated determine cells contain proper values 
particular query cell contains mini program computes formula formulas potentially depend values cells 
cell query evaluated cells cell data dependent evaluated 
evaluation engine keeps track cells changed cells need updated 
reverse view process query cell prompting ancestors evaluate ancestors need prompt ancestors 
rothermel specified graph modelling spreadsheet programs called cell relation graph crg 
depicts crg program 
cell relation graph represents individual cell formula cell forms program node 
directed data dependence edges connect node nodes results node immediately requires internal evaluation 
result directed acyclic graph dag 
terms cell relation graph foregoing testing process model viewed creating subset dag original dag cell relation graph 
application set test inputs forms program identification query cell subset dag created test necessarily includes node corresponding cell evaluated immediately 
additional cells nodes continue evaluated specified query node evaluated 
term set nodes involved computation value query node execution dag 
framework create new safe rts algorithm sequence steps follow generate safe rts technique parallel steps involved proving rts technique safe step algorithm generation process 
requirements testing process propose regression bias ab 
propose model state semantic word set sigma satisfying stable semantics condition ssc ab holds 
time describe agent sets indicators detect events occur nonempty 

construct ffi ffl functions state model semantic word set sigma graphs produced capture ab 
transform trace information execution traces safespace 

construct function guarantees safety ab holds 
note process iterative 
may know advance specification regression bias best model semantics graph structure obvious 
repeated iterations suggest initial regression bias fact refined meet testing requirements potentially allowing substantially efficient algorithms loss safety 
step propose regression bias creation regression bias new technique little different creation safespace instantiation existing technique 
cases exists set programs safe rts technique operate 
regression bias merely specifies set attributes possessed set programs positive negative constraints test cases necessary preserve bias 
construction regression bias spreadsheet languages quite simply interested spreadsheet programs follow alan kay value rule states value cell defined solely formula explicitly specified cell 
precise targeting subset forms program obtain root quadratic linear equations 

read 
sqrt solution solution 


solution solution 


ac read read cell relation graph forms program 
forms programs described section clearly satisfies value rule 
program example program 
refine bias need consider expectations needs users safe rts technique 
specifically interested augmenting spreadsheet programming environment everyday users testers professional testers interest understanding testing theory 
users expect hit help retest button result fairly fast safe 
course testers understand distinction safe unsafe rts techniques user expectation system perform best effort attempt error detection essentially implies safety 
employ retest approach potentially violates rapid response goal 
want find efficient safe rts technique 
definition expected tester need clarify bias assumptions relation programmer programming environment 
testers users software product expected fix faults spreadsheet environment 
technique assumes spreadsheet environment evaluation engine performs correctly 
essentially equivalent dejavu pythia testtube assumption compiler operates correctly 
note dejavu algorithms equivalence assumptions factors external environment example operating system identical runs 
spreadsheet evaluation engine provides front factors transparent bias correct execution engine requires aspects hold 
correct execution evaluation engine incorporates assumption programs halt 
simple nature spreadsheet languages verifying program halts requires check cycles cell 
bias assumes correct program executed previously presume faults previously visible detected corrected 
altogether assumptions form regression bias new algorithm regression bias spreadsheet languages underlying environment executes correct forms programs possess constructs outlined specifications language original program correct step propose state model semantic word set agent sets regression bias state consists solely values assigned cells spreadsheet including formulas input values cells changed process evaluation 
transient state consists cells contained execution dag query cell 
case defined set values primarily language purely declarative side effects 
semantic word set consists cell formulas spreadsheet program 
course involve words correspond requests user input 
valid agent set consists set correct behaviors associated evaluation engine 
evaluation engine shields user program outside environment rogue agents result incorrect behavior evaluation engine incorrect behavior engine arise external events 
step construct ffi ffl functions ffi ffl functions algorithm create 
ffi function quite simple algorithm semantic words related formulas individual cells 
ffl function creates directed edges cells contain sources uses variables similar crg algorithm reverse direction edges change graph walk procedure simpler 
individual cells contain small programs chosen consider internals cell formulas algorithm interest maintaining rapid response time 
ffl function forms dag nodes created ffi just cell relation graph dag 
step transform trace information execution traces described earlier execution test case forms program involves applying input values selecting query cell 
obviously application input values change parts graph dependent changed values 
evaluation engine need check parts graph 
execution trace test case subgraph graph formulation coarse version crg 
represent trace simply bit vector nodes contained execution trace 
note traces represent partial orders cells graph 
step construct function proofs safety ffi ffl functions intrinsically tied ffi function may chosen convenient function exists 
algorithm creation process chosen separate ffi ffl function creation step function creation step wish emphasize modeling program concerning proving equivalence 
course difficulties creation valid function lead reevaluation ffi ffl functions created previously 
case ffi ffl functions clear choice function 
just dejavu lexical equivalence choice simple possesses clear semantics 
primarily interested creating fast safe rts algorithm interest maintaining rapid response time demanded users spreadsheets 
having determine lexical equivalence cell formulas keep extra bit information cell indicate cell formula modified 
bits set cells formulas entered set user validated cell exercising incoming dependencies executed safe rts function 
cell formula subsequently altered bit reset 
function needs merely shift bits bit strings detect 
bit vector representing changes contains bit vector representing execution dag test case contains test case needs rerun 
point shown chosen ffi ffl functions suffice structure equivalence functions safespace proof simple delayed defined 
ffi ffl clearly capture semantic behavior spreadsheet programs relation guarantees 
key proof lies entirely function 
stated earlier function guarantee identical start states equivalent nodes produce equivalent non transient states function clearly achieves goal indicates equivalence node altered user represents local function 
global perspective see algorithm safe excludes test cases trace contains nodes changed create new edges arise nodes changed nodes trace changed know test case equivalent execution dag behaviors test case necessarily equivalent 
test selection safe heuristic safespace algorithm focuses constructing data structure selecting dangerous edges 
discussed test case selection performed edges spreadsheet algorithm 
spreadsheet languages interesting traits selection efficient 
stated earlier levels granularity spreadsheet languages inter cell dependencies formulas inside cells 
algorithm focuses inter cell dependencies 
particular trace defined technique apply large number input output relations 
instance distinct traces quadratic equation solver possible test cases required test boundary conditions ensure correct computation roots program 
complex spreadsheet programs interconnected graphs large number distinct traces case far test cases unique test traces 
bin test cases algorithm run create efficient implementation 
keep storage list unique test traces seen previously add test cases check see trace test case unique 
trace unique add list trace unique add test case list associated trace 
run safespace implementation spreadsheet languages run test selection process traces test cases way avoid checking trace test case potentially reduce significantly 
clearly choice safe 
programs substantial numbers test cases executing identical formulas optimization produce substantially greater efficiency 
example application algorithm forms program presents simple forms program 
clearly represent input cells specified visual format forms put read primitives cells require user input 
program compute meaningful functions suffices demonstrate rts algorithm 
alongside forms program graph representation specified ffi ffl functions previously described 
noted section representation depicts inter cell dependencies directions arrows reversed 
edges node point nodes associated cells referenced node local formula 
nodes graph labeled names cells represent defined forms program 
example consider test cases 
query variable second query variable discussed traces include edges traversed course computation value query variable 
trace test case contains edges trace test case contains edges suppose modified version program created 
version graph representation generate program added new cell referenced cell formula nodes change bit set read read read invalid entry invalid solution start left forms program right graph representation program 
start read read read invalid entry invalid solution left version forms program right graph representation version 
select start signature graph sig change bit set 
execute safespace instantiation described previously graphs producing sig shown 
note altered create arrow start directed immediately select 
immediately see test case contained edge selected retest test case need re validated 
main advantages safe rts technique easily incorporated testing environment environment described 
reasonable implementation algorithm environment execute safe rts algorithm run required test cases highlight query variables requiring revalidation 
direct user attention values changed result changes 
safe rts increases responsiveness revalidation command focuses user attention potential trouble spots 
past decades distinct regression test selection algorithms proposed utilizing wide range approaches see list :10.1.1.30.3199
papers said consider regression test selection theoretical standpoint 
attempts extend understanding theoretical foundations regression test selection focusing safe rts techniques 
establishing framework safe rts establish essentially specification safe rts algorithm designed clarify contracts safe rts testing allowing software testers clients readily agree testing standards met 
believe framework task designing new safe regression test selection algorithm easier researcher test engineer need safe rts solution unique testing scenario 
context showed safe rts algorithms designed entirely functions generalized safe rts algorithm 
emphasis process technique intended facilitate practical usefulness framework 
far discussed place safe rts testing global scheme software engineering 
section suggested purpose safe rts testing just save money somewhat equivalently time valid safe rts techniques past primary justification 
safe rts techniques represent branch regression testing philosophies 
safe rts algorithms operate assumption test cases associated faults goal testing find faults 
wrong goal safe rts algorithms help find faults expense clearly foolish 
hand finding faults means improving software quality possibly finding faults best approach 
safe rts algorithms deeper uses maintenance phase software life cycle 
rts algorithms general partition testing resources efficiently little advance 
defining safe space code safe rts techniques exclude portions code testing fault finding techniques usage tells domains behaviorally equivalent 
coupled adequate test suites safe rts techniques provide justification faults located excluded code 
give testers measure utility performing different types additional testing 
having employed safe rts technique tester knows executing tests excluded section program 
tester allocate resources activities reliability assessment increasing test coverage areas known high complexity measures 
consider dejavu example shown reduce cost retesting line program empire 
technique displays tendency produce greater savings programs grow larger 
chunk regression testing time saved reallocated completely different validation processes 
hand unsafe rts techniques perform function similar safe rts techniques general justify confidence levels 
unsafe technique cut size test suite significant amount justified safe techniques processes testing domains adequately tested code greatest concern 
clearly safe rts algorithms belong tester toolbox provide analytic guidance increase quality software limited resources 
course primarily safe rts techniques intended provide safe savings software engineering costs 
evidenced experiments performed rothermel harrold chen vo rosenblum frankl savings realistic programs missing faults 
testing methods mature demand post development testing increases safe rts analysis methods fundamental life software maintenance 
supported part boeing commercial airplane group nsf faculty early career development award ccr oregon state university 
wish acknowledge ravi dan enlightening discussions safe rts 
abadi lamport 
composing specifications 
acm transactions programming languages systems january 
agrawal horgan london 
incremental regression testing 
proceedings conference software maintenance pages september 
aho sethi ullman 
compilers principles techniques tools 
addison wesley publishing reading ma 
ames nadeau 
vrml 
john wiley sons new york ny 
ball 
limit control flow analysis regression test selection 
acm international symposium software testing analysis pages march 
cimitile de 
post maintenance testing path change analysis 
proceedings conference software maintenance pages october 
bible rothermel rosenblum 
comparative study coarse fine grained safe regression test selection 
technical report oregon state university march 
binkley 
semantics guided regression test cost reduction 
ieee transactions software engineering august 
carey bell 
annotated vrml manual 
addison wesley developers press reading ma 
carver 
tai 
sequencing constraints specification testing concurrent programs 
ieee transactions software engineering june 
chen 
rosenblum 
vo 
testtube system selective testing 
proceedings th international conference software engineering pages may 

distributed systems concepts design 
addison wesley publishing reading ma 
gupta harrold soffa 
approach regression testing slicing 
proceedings conference software maintenance pages november 
harrold rosenblum rothermel weyuker 
empirical studies prediction model regression test selection 
ieee transactions software engineering appear 
harrold soffa 
incremental approach unit testing maintenance 
proceedings conference software maintenance pages october 
hopcroft ullman 
automata theory languages computation 
addisonwesley publishing reading ma 
kay 
computer software 
scientific american september 
laski 
identification program modifications applications software maintenance 
proceedings conference software maintenance pages november 
leung white 
insights regression testing 
proceedings conference software maintenance pages october 
patterson hennessy peterson 
computer organization design hardware software interface 
morgan kaufmann publishers san ca 
rosenblum rothermel 
comparative study regression test selection techniques 
proceedings international workshop empirical studies software maintenance pages october 
rothermel 
efficient effective regression testing safe test selection techniques 
phd thesis clemson university may 
rothermel burnett 
methodology testing spreadsheets 
technical report oregon state university january 
rothermel harrold 
empirical studies safe regression test selection technique 
ieee transactions software engineering june 
rothermel harrold :10.1.1.30.3199
analyzing regression test selection techniques 
ieee transactions software engineering august 
rothermel harrold 
safe efficient regression test selection technique 
acm transactions software engineering methodology april 
rothermel burnett 
testing strategies form visual programs 
eighth international symposium software reliability engineering pages november 
rothermel burnett 
see test methodology testing form visual programs 
th international conference software engineering pages april 
frankl 
pythia regression test selection tool textual differencing 
proceedings rd international conference reliability quality safety software intensive systems may 
frankl 
empirical evaluation textual differencing regression testing technique 
proceedings international conference software maintenance pages november 
white leung 
firewall concept control flow data flow regression integration testing 
proceedings conference software maintenance pages november 
white friedman 
test manager regression testing tool 
proceedings conference software maintenance pages september 

