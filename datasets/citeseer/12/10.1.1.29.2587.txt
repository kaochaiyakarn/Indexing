representing non functional requirements process oriented approach john mylopoulos lawrence chung brian nixon department computer science university toronto toronto ontario canada proposes comprehensive framework representing non functional requirements development process 
framework consists basic components provide representation non functional requirements terms interrelated goals 
goals refined refinement methods evaluated order determine degree set non functional requirements supported particular design 
evidence power framework provided study accuracy performance requirements information systems 
complexity information system determined partly functionality system partly global requirements development operational costs performance reliability maintainability portability robustness 
non functional requirements play crucial role system development serving selection criteria choosing decisions 
errors omission commission laying properly account requirements generally acknowledged expensive difficult correct information system completed 
surprisingly non functional requirements received little attention researchers definitely understood critical factors software development 
far software engineering practice concerned generally stated informally requirements analysis contradictory difficult enforce software development validate user final system built 
glimmer technical light landscape originates technical software quality metrics allow quantification degree software system meets non functional requirements 
formal definition complete list non functional requirements 
report published rome air development center radc non functional requirements software quality attributes terminology classified consumer oriented software quality factors technically oriented attributes software quality criteria 
refers non functional requirements observable consumer efficiency correctness interoperability 
addresses system oriented requirements anomaly management completeness functional scope 
table shows radc consumer oriented attributes 
non functional requirements listed table apply software systems 
additional requirements may apply special classes software 
instance precision important non functional requirement numerical analysis software package accuracy maintained information feature prominently development information system 
basic approaches characterize formal treatment non functional requirements shall refer product oriented process oriented 
attempts develop formal definitions non functional requirements software system evaluated degree meets requirements 
example measuring software visibility may include things measuring amount branching software system 
achieved globally criterion shall branches lines code locally criterion shall system modules violate criterion 
referred constraints goals quality attributes literature 
acquisition concern user concern quality attribute utilize resource 
efficiency secure 
integrity performance confidence placed 
reliability function 
perform adverse conditions 
survivability easy 
usability conform requirements 
correctness design valid easy repair 
maintainability design 
easy verify performance 
verifiability easy expand upgrade capability performance 
easy change 
flexibility adaptation adaptable easy interfere system 
interoperability 
easy transport 
portability easy convert application 
reusability table radc software quality consumer oriented attributes 
product oriented approach received exclusive attention literature nicely overviewed 
earlier boehm considered quality characteristics software noting improved quality final product 
supporting quantitative approach software quality basili musa advocate models metrics software engineering process management perspective 
interesting hauser provide methodology reflecting customer attributes different phases automobile design 
alternative approach explored develop techniques justifying design decisions software development process 
evaluating final product emphasis trying rationalize development process terms non functional requirements 
design decisions may affect positively negatively particular non functional requirements 
positive negative dependencies serve basis arguing software system meets certain non functional requirement explaining 
orthogonally treatments non functional requirements classified quantitative qualitative ones 
product oriented approaches alluded earlier quantitative sense study quantitative metrics measuring degree software system satisfies non functional requirement 
process oriented treatment proposed hand definitely qualitative adopting ideas qualitative reasoning 
acknowledged process oriented treatment non functional requirements need qualitative 
imagine quantitative measures say software visibility system developed offer advance warning non functional requirements met 
qualitative techniques chosen primarily felt problem quantitatively measuring incomplete software system harder measuring final product 
course product oriented quantitative metrics process oriented qualitative measures monopoly properly treating non functional requirements 
best seen complementary contributing evolving comprehensive framework dealing non functional requirements 
sources ideas particularly influential 
involves decision support systems described 
lee example adopts earlier model representing design rationale extends making explicit goals presupposed arguments 
reported seen attempt adopt model representation non functional requirements 
second source ideas daida environment information system development provided comprehensive software development framework covering notations requirements modelling design implementation decision support starting point treatment non functional requirements integrated framework 
users daida environment offered languages elaborate requirements design implementation specifications 
developing design specification user consults constrained corresponding requirements specifications 
likewise generation implementation guided employee report hierarchy 
isa rpt employee secretary researcher engineer corresponding design specification 
dependency links represent design decisions relate implementation objects design counterparts design objects requirements counterparts 
framework proposed focuses dependency links justified terms nonfunctional requirements 
early description framework account relates daida 
example expense management system hypothetical research project similar 
example project members organizations different countries register attend various meetings 
submit expense summaries expense management system maintains information generates expense reports member meeting project 
shown kinds employees including secretaries engineers researchers turn classified computer researchers math researchers 
establishment framework achieved steps 
firstly framework section 
presentation includes motivation framework structure short suggestive examples 
framework elaborated illustrated sections examining application respectively accuracy performance requirements information systems 
final section summarizes contributions research presents number open questions directions research 
representing non functional requirements process oriented framework formally proposed framework consists major components set goals representing nonfunctional requirements design decisions arguments support goals set link types relating goals goal relationships links goals set generic methods refining goals goals collection correlation rules inferring potential interactions goals labelling procedure determines degree non functional requirement addressed set design decisions 
examples section concentrate accuracy lesser extent operating cost requirements information systems 
design process goals organized goal graph structure spirit trees problem solving 
traditional problem solving planning frameworks goals representing non functional requirements rarely said accomplished satisfied sense 
different design decisions contribute positively negatively particular goal 
accordingly rest discussion speak goal satisficing suggest generated software expected satisfy acceptable limits absolutely non functional requirements 
earlier version portions section appeared 
uses term refer decision methods look satisfactory solutions optimal ones 
term adopted broadened sense context non functional requirements notions solution optimality solution may unclear 
goals space goals includes mutually exclusive classes non functional requirements goals nfr goals satisficing goals argumentation goals 
general goal associated sort zero parameters nature depends goal sort 
example operating cost requirement parameter desired upper bound annual operating costs system development 
sorts may subdivided subsorts representing special cases goal class 
instance performance sort may subsorts simply time simply space representing respective time space performance requirements particular system 
goals refer respectively set possible goals nfr goals satisficing goals argumentation goals 

non functional requirements goals 
sorts goals range different categories requirements including accuracy security development operating hardware costs performance 
expense management system suppose expected system development maintain accurately employee data 
goal represented accuracy attributes employee accuracy goal sort parameter attributes employee evaluates set attributes associated data class employee 
interpretation goal instances attributes data class employee attributes employees ought maintained accurately system database 
example may expected system development minimal demands manpower 
treated operating cost requirement contributing factors operating costs manpower maintenance requirement represented manpower 

satisficing goals 
sorted parameterized 
case sorts range different categories design decisions adopted order nonfunctional requirements goals 
parameters associated sort depend nature corresponding satisficing goal 
instance way accuracy goal mentioned earlier validate employee data entered system 
represented satisficing goal validation attributes employee validation goal sort attributes employee 
goal turn refined satisficing goal attributes employee representing situation doing validation 

argumentation goals arguments 
sort claim subsorts representing formally informally stated evidence counter evidence goals goal refinements 
consider attributes employee sec argumentation goal supports refinement goal validating employee data assigning task claiming class secretaries perform validation 
contrast rigorous examination recommended publications employees informally stated argumentation goal supporting previous argumentation goal pointing class secretaries validate employee data 
link types indicated earlier design proceeds refining times goal parent set goals offspring 
goal trees relationship collection offspring parent proposed framework different types relationships link types describing satisficing offspring failure thereof relates satisficing parent goal 
need link types evidenced states quality characteristics necessary sufficient achieving 
boehm grade scale correlate quality metric quality attributes final product 
links may relate parent goal offspring 
fact links may relate links argumentation goals indicate argument offers positive negative support particular refinement goal 
links need satisficed formal refinement process arguments provided designer 
links denote set links satisficed predicate true satisficed goals links false 
denied predicate true goals links shown unsolvable problem solving terminology 
propositions goals links satisficed denied predicates proposition argument 
proposition refinement deniable 
instance accuracy goal employee data validation procedure adopted data deniable user interface permits general access information 
deal conflicting cases need distinguish proposition satisficed denied hand proposition potentially deniable refinement 
accordingly predicates deniable introduced deal case 
set logical types links 
type axioms provided formalize semantics terms predicates just introduced propositions theta propositions satisficed satisficed satisficed gn satisficed fg gng gamma 
satisficed fg gng denied denied denied gn gamma 
deniable propositions theta propositions denied denied denied gn satisficed fg gng gamma 
deniable satisficed fg gng satisficed satisficed satisficed gn gamma 
sup propositions theta propositions satisficed satisficed sup gamma 
sub propositions theta propositions denied satisficed sub gamma 
deniable link type sub intended convey sense contributes partially satisficing expressed follows satisficed sub exist propositions gn satisficed satisficed gn gamma 
satisficed satisficed satisficed gn satisficed sub gamma 
words sub proposition exist propositions gn achieve satisficing contribution additional link types introduced represent negative influences goal 
propositions theta propositions satisficed satisficed gamma 
deniable propositions theta propositions denied satisficed gamma 
gamma sub exist gn satisficed satisficed gn satisficed gamma 
deniable satisficed satisficed satisficed gn satisficed gamma 
deniable words negative sub proposition denial leads satisficing satisficing contributes denial useful define eql equivalent link type terms link types introduced eql propositions theta propositions eql sup sup sub sub times may hard determine priori logical relationship set offspring parent goal expansion goal graph 
example designer may see certain hiring policy technical staff relevant sure impact particular goal say justifying assignment class secretary task validating employee data 
situation accommodated variations undetermined link type und propositions theta propositions und indicates possible presence positive negative inf likewise und indicate respectively possible positive negative influence propositions 
methods goals may refined designer responsible satisficing goal offspring refinement represented link 
alternatively framework provides goal refinement methods methods short represent generic procedures refining goal offspring maintain accurately data class need maintain accurately data relevant subclasses 
refinement represented terms link having types previous section considered satisficed 
generally method form xn cn xn xn gamma gamma 
fg xn pred xn represents parent goal predicate red determines set offspring link type relating offspring 
refinement method subject method selection criterion consisting boolean expression free variables xn bound objects type cn respectively method applied 
types goal refinement methods corresponding types goals introduced earlier 
goal decomposition methods 
usually decomposition methods form gamma gamma gamma gamma 
fg gng decompose goal set offspring gn instance method decomposes goal having class argument goals having arguments immediate specializations class gamma gamma gamma gamma 
fg isa isa isa specializations employee example accuracy goal accuracy attributes employee abbreviated attributes employee refined subclass goal decomposition method attributes employee gamma gamma gamma gamma 
fa attributes researcher attributes secretary offspring shown underneath parent goal 
link types omitted figures 
goals needs satisficed turn 
likewise satisficing goal attributes researcher requires attributes researcher maintained accurately 
decomposition accomplished method form class attributes gamma gamma gamma gamma 
fa attr attr attributes method leads decomposition attributes researcher 
assuming research employees attributes degree publ publications addition employee attributes researcher gamma gamma gamma gamma 
fa researcher name researcher degree researcher publ 
goal satisficing methods 
methods refine goal set satisficing goals committing design generated particular design decisions 
returning example may satisficing methods offered goal researcher publ 
publication record researcher obtained existing databases accuracy information ensured periodic auditing databases 
hand data fed directly employee question method may call validation data employee manager gamma gamma gamma gamma gamma 
audit gamma gamma gamma gamma 
validation methods researcher publ refined audit researcher publ validation researcher publ und sup links respectively 
note designer may change type und link design proceeded determined auditing leads accurate publication data 
clearly selection alternatives leads different types user interfaces system development 
particular validation selected publication information confirmed person auditing calls inclusion audit requirement database publication data imported 

argumentation methods 
methods refine goal link argumentation goal indicating evidence counter evidence terms arguments satisficing goal 
instance formal claim consisting conjunction refined claims conjunct related parent link 
illustrates goal structure generated simple example introducing piecemeal 
bigger picture information system development source object say component requirements specification mapped possibly target object say components design specification 
dependencies objects shown dependency links left right hand sides 
goal structure generated designer non functional requirements possibly help methods intended help select alternatives justify design decisions 
selectively focus attention controlling goal structure expansion 
mapping source auditing researcher publ hiring policy technical staff sec researcher publ attributes researcher researcher publ validation attributes engineer attributes employee goal graph structure accurate employee attributes 
node node und sup data imported acc 
script validation activity enter publ data script auditing legend satisficing goal argument non functional requirement goal rigorous exam 
pub 
policy mapping target justification selection dependency link satisficing link attributes programmer researcher name researcher publ researcher degree correlation rules indicated earlier non functional requirements set particular system may contradictory 
instance having built procedures validating auditing data managed information system general requires additional manpower interfering operating cost requirement manpower 
guidance needed designer discovering implicit relationships selecting satisficing goals best meet set nfr goals 
achieved external input designer representation generic interactions goals correlation rules 
consider satisficing goal system design offer interface casual users say employees wish query update system database 
manpower gamma gamma gamma gamma 
employee database unfortunately making database readily available employees lead data inaccuracy interfering accuracy goals 
expressed example rule cardinality ae gamma 
rule infer sub link goals employee database attributes employee assuming attributes employee ae database employees 
likewise consider security goal sort discouraging secretaries accessing research publication data 
validation goal positive researcher publ class secretary validator contribute negatively security goal vice versa isa gamma 
representation security requirements adopted 
consider case satisficing goals interfere dependence critical resource 
competition may synergistic antagonistic leading respectively positive negative argumentation 
instance unrelated goals calling auditing validation information may influence positively sub links staff assigned task jointly suggest hiring personnel data may individually justify hiring additional staff 
argumentative structure indicates share agent new staff member may hired tasks 
validation audit employee gamma 
sub validation audit sub audit validation possible describe expansion procedure starts set nfr goals iteratively expands goal graph structure 
expansion system maintains list propositions refined called open list closed includes propositions completely refined 
proposition selected open refinement designer chooses wants propose refinement apply available methods 
carrying chosen refinement involves creating propositions offspring newly created link adding open 
correlation links introduced new propositions designer judgement correlation rules system 
process repeated chosen proposition refinements system designer offer 
time proposition placed closed list open proposition selected 
second alternative proposition refinement simply label proposition satisficed denied 
labelling may come input designer method proposition refinement 
labelling procedure partially constructed goal graph structure labelling procedure determines status node graph assignment label 
node link graph labelled satisficed deniable denied deniable conflicting deniable undetermined 
labels denoted respectively similar generally ones qualitative reasoning frameworks 
label particular intended represent situations positive negative support albeit inconclusive goal positive negative support 
labelling algorithm consists basic steps 
proposition goal graph algorithm computes individual effect satisficed outgoing link 
secondly individual effects outgoing links combined single label possible values mentioned earlier 
open ended nature argumentation process premise built framework relevant knowledge formally represented rest remaining designers framework calls interactive labelling procedure designer may asked step determine appropriate label particular proposition having supporting inconclusive evidence 
reason labels characterizing influence set offspring parent include mentioned gamma representing respectively inconclusive positive negative support parent 
indicates situation designer determine label characterizes contribution proposition 
note labels gamma introduced step labelling algorithm eliminated second set contributions outgoing links associated proposition combined single label table shows propagation rules different link types offspring parent 
rules sup propagates sub propagates sup inverts label sub inverts label 
link type label source sub sup sub sup und gamma gamma 
table individual effect source label destination label 
propagation rules links ordering labels defined follows assuming fg gng label min label assuming fg gng label max label contributed labels collected proposition second step labelling procedure combines single label 
assuming bag contributed proposition consisting labels set fs gamma gamma labels combined designer labels 
resulting set labels combined single choosing minimal element min assuming label ordering interesting compare labelling procedure truth maintenance systems 
record maintain beliefs justifications assumptions distinguishing facts defeasible beliefs accepted rejected 
graph labelling procedure recursively propagates values offspring parents 
procedure automatic interactively allows designer deal inconclusive evidence 
comparable tms conjunction disjunction link types additional values inputs computing individual effect step 
applying propagation rules table links included tms beliefs satisficed 
combine individual effects label values including qualitative conflicting open ended undetermined ones label ordering second step 
dealing accuracy requirements major consideration building information system degree design encourages accuracy information managed 
example system allows users update information files may user friendly confidence information contains 
ways promote accuracy requirements information system 
restricting access resources technique 
framework treating accuracy requirements goals offers directional guidance design process 
particular accuracy requirements criteria selecting particular design order address elements functional requirement 
goals accuracy requirements goals accuracy requirements accuracy sort abbreviated info parameter 
expressed accuracy abbreviated collection information items 
information items may categorized types propositions entity system property class time interval ii entity system attribute certain value time interval iii object system say record corresponding entity application domain say employee 
accuracy requirements expressed collections information items employee attributes section see 
general satisficing accuracy goals understood terms degree confidence accuracy information items maintained projected system 
bag duplicate labels useful instance positive supporting links indicated may combined label designer 
goal refinement methods goal decomposition methods examples accuracy decomposition methods illustration section 
ffl subclass method order establish accuracy class information items establish accuracy immediate specialization special case goal decomposition method mentioned section 
ffl subset method establish accuracy set information items establish accuracy subset information items 
similarly superset method provided 
ffl method establish accuracy attributes class information items establish accuracy attribute class 
ffl method establish accuracy set information items establish function derives correctly designed function source parameters currently system accurate 
ffl method establish accuracy information item obtained sequence attribute selections joe project budget establish accuracy information item obtained sequence joe project project budget 
ffl conservation method establish accuracy collection information items longer decomposed information items currently system establish accuracy received system external agent ii correct internal manipulation system 
ffl method establish accuracy information items receipt establish accurate transmitted original sender subsequently correctly manipulated receipt system 
sub sort correctness goals accuracy goals related actions induce certain results 
goal satisficing methods premise accuracy information items depends entirely process manipulated system environment accuracy satisficing goals alter process accuracy satisficing goals include preventive curative precautionary techniques 
affect level confidence accuracy information items 
preventive accuracy satisficing goals detect disallow inaccuracies information items received system 
require direct interaction system agents application domain 
specialized varying agent performs needed task volume information items evidences attached time processing output ffl confirmation informant machine person double checks previously submitted information item 
technique specialized confirmation identical channel confirmation transmission channel confirmation distinct channel daisy channel 
ffl verification verifier worker sender information item duplicate entry item medium system duplicate ibm key entry operation 
confirmation verification specialized verification identical channel verification channel 
martin instance offers glossary techniques improving accuracy 
ffl validation validator performs checking application domain certain records procedural guidelines ensure information item meets predetermined standards 
type checking reflected specialized methods creation validation directly contacting information source experimentation re testing information item ffl audit accuracy auditor uses procedures periodically go suspicious sampled information items 
ffl consistency checking prevent frequently occurring errors system enforces certain integrity constraints check sums incorporated 
curative satisficing goals trace inaccuracies source provide recovery inaccuracies 
precautionary satisficing goals information flow reliable terms involved senders receivers communication channels 
goal argumentation methods methods support deny accuracy satisficing goals various refinements terms arguments 
examples include ffl resource assignment performing task satisficing goal assign resources application domain 
example support refinement goal validating expense summaries assigning staff member task claiming class secretaries perform validation 
validation summary gamma gamma gamma gamma 
summary sec ffl policy manual consultation question arises applicability various types methods consult policy manuals application domain 
ffl priority selection select method alternatives relative priority 
satisficing goal high priority accuracy goal bad goal priority positive argument negative correlation rules accuracy satisficing goals verification usually contribute positively accuracy goals attribute researcher provided verification process rapid 
information items timely 
perturbation example satisficing goal negative 
example excessive gamma 
verification verification may negative security goal verifier allowed access information item verified 
security satisficing goal mutual id user friendliness satisficing goal positive negative accuracy goal 
consider mutual id agent info procedure time 
mutually ensure identity agent attempting access certain information items identity system process agent system time interval go test procedure requires alternating queries answers similar challenge response process 
positive accuracy goals malicious user absence mutual identification penetrate system falsify information item 
table summarizes correlations 
entries form condition orientation mean condition holds relationship requirements goal satisficing goal orientation 
time parameter omitted needed 
accuracy security verification sub sub 
sub 
mutual id sub 
true sub 
true sub 
excessive mutual gamma id informant gamma id gamma established isa table correlation nfr goal satisficing goals 
table similar spirit relationship matrix indicates informally correlation rules engineering characteristic affects customer quality requirement terms types values strong positive medium positive medium negative strong negative 
accuracy satisficing goal synergistic antagonistic respect satisficing goal types non functional requirements goals 
suppose single channel shared confirmation verification 
confirmation distinct channel verification distinct channel mutually synergistic new channel installed shared mutually antagonistic channel unshareable 
illustration consider example research expense management system section 
assume attributes rpt root node goal tree representing accuracy requirement attributes expense reports accurate 
root goal refined subclass method offspring corresponding subclasses rpt specified part functional requirements see attributes rpt gamma gamma gamma gamma 
fa attributes attributes attributes offspring needs satisficed 
focusing subgoal attributes goal attributes decomposed method terms accuracy attributes 
attributes gamma gamma gamma gamma 
fa mon legend symbols omitted assume link type satisficing argumentation methods sup remainder 
focusing exp designer indicates exp derived information item derivation function shown 
decomposition method instantiated function needs correctly designed parameters function accurate 
subset method instantiated decomposition exp gamma gamma gamma gamma 
exp gamma gamma gamma gamma 
fa exp date exp proj competing alternatives disjunctive refinements foreseen designer date expense incurred may come expense reimbursement requests requiring members send reimbursement request forms central management office expense summary requiring secretary submit directly exp date gamma gamma gamma 
fa exp date exp summary explore alternative designer applies method exp date gamma gamma gamma gamma 
fa exp date illustrate manipulation information items introduce method applications shown 
designer indicates exp req received external agent 
conservation method exp req accurate received correct processed system exp gamma gamma gamma gamma 
fa rec exp date invoked designer labelling procedure assigns undetermined goals closed leaves 
omitted links labels results generic method applications 
attributes rpt exp summary attributes goal graph structure decompositions accurate expense reports attributes 
rec exp req mon attributes attributes exp proj req date exp exp date exp proj mon proj exp date exp exp req exp exp req date designer uses method refine accuracy received information item rec exp gamma gamma gamma gamma 
rec exp low rec exp unfortunately ensuring correct creation subsequent transmissions item creator system cases costly impractical 
accordingly designer may resign satisficing methods rec exp req 
selecting method designer uses argumentation method policy manual consultation designer consultation guidelines dcg 
designer regards validation method appropriate low rec exp gamma gamma gamma gamma 
validation exp note method call validation supported designer supplied argument gamma gamma gamma gamma 
dcg careful examination preferred materials directly related issuing cheque goal validation designer consults dcg discovers class secretary class candidate carrying validation 
class secretary assigned call assignment assign assignment supported validation exp gamma gamma gamma gamma 
sec gamma gamma gamma gamma 
dcg consider class secretary rec exp req exp req validation exp req directly related issuing cheque consider class secretary attributes req sec 
attributes summary sec 
attributes exp sec sub preferred materials dcg careful examination dcg general tasks require moderate experience sup sup mutual exclusion satisficing accuracy received reimbursement information 
sec 
suppose security requirement considered earlier revealed secretaries job classification ii 
direct conflict mutually exclusive sufficiently negative secretary class validator 
system uses correlation rules propose new links type sup attributes gamma req gamma gamma gamma gamma gamma gamma 
validation exp gamma req validation exp gamma req gamma gamma gamma gamma gamma gamma 
attributes gamma req suppose designer assigns sec label satisficed labels leaves labelling procedure section propagates labels upwards 
results shown 
validation class secretary sufficient counter evidence security goal see left hand side labelled denied 
value value link upper left corner propagated minimum value selected resulting note denial root security goal final 
class secretary designer may see higher ranking staff member validation 
satisficing methods may considered 
designer choose alternative provide argument justifying final design labelling procedure update labels reflect current status process 
success lack thereof goal satisficing methods relies cooperation system agents environment described user procedure manual initially design process 
manual indicates policies agents environment obey interacting system order methods selected 
instance verification method selected manual indicates member transfer expense information system project office enter information system 
design stage choice methods related requirements accuracy security results selection design alternatives 
section consider performance goals dealt implementation stage 
dealing performance requirements resolve conflicts negotiation approach may taken 
argumentation methods record conflicts resolved attachment priorities 
acquiring formal requirements recognizes need generating documents spirit similar manuals 
see description dependency types section 
earlier version portions section appears proceedings third international workshop database programming languages greece august 
previous section illustrates dynamic process aspect design 
section focuses performance requirements second example class non functional requirements treated proposed framework 
accuracy requirements treated context system design performance requirements treated implementation phase designs mapped implementations 
starting point understanding system performance set standard definitions computer systems theory achieving low response time suitable device utilizations 
practice performance goals focus response time throughput developed particular application systems 
stated briefly users expect system meet implicit performance concerns 
see performance goals result complex structures 
implementing information system performance main criterion implementor abandon generic implementation algorithms structures 
implementation techniques selected case case basis number alternatives 
inputs mapping process set implementation alternatives source schema portion design specification workload characterization particular system estimate number researchers handled expense management system performance goals specified particular system 
examples performance goals require researcher registering meeting get system design fast response time storage requirements information researchers minimized 
framework detailed section applied satisficing qualitative goals 
outputs process target implementation goal graphs prediction performance calculated terms performance model 
interesting contrast treatment offered section research transformational approach ti system 
ti transformation peers focuses correctness requirements making sure generated implementation consistent original specification 
performance treated treated selection criterion alternative transformations 
kant early hand address performance goals 
framework focuses conventional programming small information system development relies quantitative performance measures available chosen domain unfortunately available information systems complexity assumes automatic programming setting dialectical software development process adopted 
layered goal structures generating efficient implementations better understood phases information system development impose additional structure representation performance goals 
accomplished series language layers account potentially interacting data model features implementation techniques performance characteristics design languages 
layered approach inspired framework prediction performance relational databases 
design decisions higher layers corresponding higher levels abstraction reflected lower layers describe system detail 
layering shows introduce inputs related design components providing information needed implementation decisions controlling number concepts consider time 
apply layering approach performance selection implementation alternatives conceptual design specification languages 
layering organizes performance implementation areas semantic data models object oriented systems 
layer goal graphs refinements impact graphs lower layers 
shows series linguistic subsets higher level languages include features supported semantic data models target relational data model database system facilities offered dbpl language entities persistent data entities john instance researcher finite entities michael brodie insight performance goals industry 
see performance prediction conceptual design specification languages 
includes results record layout entities attributes enforcement constraints process scheduling 
integers arranged classes attributes defined entity classes roughly corresponding entity relationship model transactions modelled classes attributes instance entities entities transactions attributes classes arranged isa hierarchies roughly corresponding taxis subset described taxis subset extended constraints source conceptual design specification language including constraints long term processes nature aspects entities activities constraints comparable taxis tdl 
specialisation time throughput response time performance sort 
layers arranged grid 
space entity activity constraint performance storage memory main secondary classification aggregation performance goal refinement methods performance goals drive selection implementation alternatives stated terms concepts applicable information systems response time 
methods features specific information systems implementation 
performance goals performance sort 
sub sorts shown 
goal decomposition methods aspect goal decomposition involves selection appropriate sub sort 
example time space goal decomposition method decompose goal performance researcher class layer goals time performance researcher layer space performance researcher layer researcher gamma gamma gamma gamma 
researcher space researcher likewise goal involving time decomposed throughput response time method goal involving space decomposed main memory secondary storage method 
aspect goal decomposition involves decomposition goal parameters 
subclass performance goal decomposition methods similar structural methods names described section 
operational method 
performance goal information item class attribute class decomposed corresponding goal operations item 
layer gamma gamma gamma gamma 
fp layer operation ig method specialized 
individual bulk operations method decomposes goal basis operation manipulates items 
implementation components method goal operation decomposed lower layer components operation 
static dynamic schema method 
conceptual design schema information system may remain constant cases may expected change 
example new specializations researcher added time relative efficiency requiring entire system shut restarted 
method decomposes performance goal information item basis schema expected change 
stands performance sort 
goal satisficing methods performance goal satisficing methods available systems performance engineering semantic data model implementation techniques 
indexing positive time negative space 
early connection action instructions achieve 
specialization determines offsets statically execution time 
attributes tuple frequently accessed time goals positively satisficed 
goal argumentation methods expected actual usage statistics predictions performance implementation alternatives arguments choice satisficing methods 
suppose know information item segment code uniquely determined statically expressions possible values 
write layer 
argument information item subject frequent changes schema written layer illustration returning research expense management system example illustrate designer builds goal graph layers starting layer isa hierarchies showing goal refinement methods impact higher layer goals lower ones 
shows part isa hierarchy example 
attributes shown researcher class including name inherited employee including meeting inherited 
additional input information distribution class populations required characterize workload 
employees instance researchers including computer researchers mathematicians 
non inherited attributes researcher meeting attribute frequently accessed 
information included argumentation structures 
layer selects implementations attributes entity classes presence isa hierarchies possible implementation techniques 
inheritance hierarchies result collections attribute values appearance staircase relational table name meeting researcher employee result simple relational representation may waste space 
options include relation class storing attributes newly defined inherited particular class corresponding relation horizontal splitting newly defined attributes vertical splitting 
turning top goal graph see legend symbols implementor layer goal performance attributes researcher entity class 
implementor decides time space method decompose goal time performance space performance attributes 
implementor individual bulk operations method decompose time goal operations affect entities just individual entity 
goal time performance individual operations attributes researcher class decomposed method resulting goals individual operations name attribute meeting attribute implementor focuses meeting attribute observes attributes researcher inherited meeting 
implementor recalls meeting frequently accessed 
storing non inherited attributes small tuple size attributes stored tuple high proportion frequently accessed 
actual value ratio recorded argument selecting satisficing goal improving time performance accessing attributes tuple 
satisficing goal leads selection implementation vertical splitting attributes illustration attributes shown 
researcher meeting individual attributes individual bulk time space time time sub individual operations researcher meeting individual operations attributes researcher individual operations researcher meeting attributes researcher attributes researcher space time bulk operations attributes researcher attributes researcher individual operations researcher meeting meeting researcher 
attributes meeting researcher meeting researcher layer layer layer layer find offset find offset researcher meeting individual ops 
researcher attributes researcher time retrieve individual operations researcher name storage time retrieve storage attrs 
frequently accessed time time researcher meeting time sub sub performance goal graph 
researcher specializations 
implementation alternative horizontal splitting offer better space performance 
layer designer dealt researcher class isa hierarchy leaving mapping target layer researcher class vertical splitting 
satisficing goal 
refined layer transactions goal time performance individual operations meeting attribute researcher 
implementor continues addressing goal time performance layer deals operations inheritance 
implementor decomposes layer time goal see middle left implementation components operation shown 
result set layer attributes time goals finding offset meeting attribute field relational tuple retrieving value secondary storage implementor focuses finding offset quickly positive 
implementor reviews source schema observes meeting referenced explicitly code 
researcher meeting recorded argument sub link static offset determination meeting attribute chosen implementation technique 
implementor dealt layer issue resulting mapping target layer 
alternative implementation dynamic offset determination 
sub link records negative impact goal minimizing time 
positive impact goal offering uniform time performance 
shown lower right hand side dealing frequent schema changes structure reduces expensive run time reorganization offer variation response time 
main contribution research offers concrete framework integrating non functional requirements software development process information systems 
tackling task research extends earlier lee 
framework refinement prototype implementation way intended provide vehicle thorough testing gaining experience framework strengths weaknesses 
remains done 
firstly framework needs applied types nonfunctional requirements life size examples 
secondly framework needs theoretical foundation representing reasoning non functional requirements 
foundation needs include semantics non functional requirements 
example really mean claim particular design decision enhances system accuracy concerning employee data 
proof theory semantics required including efficient algorithms special classes inferences related non functional requirements 
framework offered justified formal semantic grounds informal intuitive ones 
unfortunately formal semantic treatment non functional requirements need done individually different types requirements long term research project 
experimental approach adopted offer solutions may find immediate area computer practice great need concepts methodologies tools 
acknowledgments referees constructive detailed comments eric yu sheila mcilraith providing helpful suggestions 
artif 
intell 
vol 
nos 
dec 
balzer year perspective automatic programming ieee trans 
software eng vol 
se nov pp 

basili musa engineering software management perspective ieee computer vol sept pp 

benzaken evaluation model clustering strategies object oriented database system proc 
rd int 
conf 
database theory paris dec 
berlin springer verlag pp 

boehm brown macleod merritt characteristics software quality 
amsterdam north holland 
borgida mylopoulos schmidt wetzel support data intensive applications conceptual design software development proc 
nd int 
workshop database programming languages june beach oregon 
san mateo ca morgan kaufmann pp 

bowen tsai specification software quality attributes rep radc tr rome air development center air force base ny feb 
ceri widom deriving production rules constraint management proc 
th int 
conf 
large data bases brisbane australia aug pp 

chan fox 
lin ries storage access structures support semantic data model proc 
th int 
conf 
large data bases mexico city sept pp 


chen entity relationship model unified view data 
acm trans 
database systems vol 
march pp 

chung rios nixon mylopoulos process management assertion enforcement semantic data model proc 
edbt int 
conf 
extending database technology venice italy march 
berlin springer verlag pp 

chung representation utilization non functional requirements information system design proc 
caise rd int 
conf 
advanced information systems eng trondheim norway may 
berlin springer verlag pp 

chung mylopoulos vassiliou information system requirements designs mapping framework information systems vol 
pp 

conklin hypertext tool explanatory policy discussions acm trans 
office information systems vol 
pp 

de kleer problem solving atms artif 
intell 
vol 
pp 

dimarco computational stylistics natural language translation ph thesis dept computer science univ toronto 
doyle truth maintenance system artif 
intell 
vol 
pp 

fickas automating transformational development software ieee trans 
software eng vol 
se nov pp 

hahn jarke rose teamwork support knowledge information systems environment ieee trans 
software eng vol 
may pp 
hartson hsiao full protection specifications semantic model database protection languages proc 
acm annual conf houston tx oct pp 

hauser house quality harvard business review may june pp 

performance prediction relational database management systems ph thesis dept computer science univ toronto 
jarke mylopoulos schmidt vassiliou daida environment evolving information systems acm trans 
information systems vol 
jan forthcoming 
johnson feather harris benner representation presentation requirements knowledge 
manuscript usc information sciences institute oct 
kant efficient synthesis efficient programs artif 
intell 
vol 
may pp 

keller kahn specifying software quality requirements metrics tutorial system software requirements engineering thayer dorfman eds 
ieee computer society press pp 
lazowska zahorjan graham sevcik quantitative system performance 
englewood cliffs nj prentice hall 
lee qualitative decision management system artificial intelligence mit expanding frontiers vol 
winston eds 
cambridge ma mit press pp 

lee extending potts bruns model recording design rationale proc 
th int 
conf 
software eng austin tx may pp 

martin security accuracy privacy computer systems 
englewood cliffs nj prentice hall 
mostow better models design process ai magazine vol 
spring pp 

mylopoulos bernstein wong language facility designing database intensive applications acm trans 
database systems vol 
june pp 

mylopoulos borgida jarke koubarakis telos representing knowledge information systems acm trans 
information systems vol 
oct pp 

nilsson problem solving methods artificial intelligence 
new york mcgraw hill 
nixon chung borgida mylopoulos stanley implementation compiler semantic data model experiences taxis proc 
acm sigmod annual conf san francisco ca may acm sigmod record vol 
dec pp 

nixon implementation information system design specifications performance perspective proc 
rd int 
workshop database programming languages greece aug kanellakis schmidt eds 
san mateo ca morgan kaufmann forthcoming 
pfleeger security computing 
englewood cliffs nj prentice hall 
potts bruns recording reasons design decisions proc 
th int 
conf 
software eng pp 

automated acquisition evolving informal descriptions ph thesis tech 
rep mit artif 
intell 
lab 
robinson negotiation behavior requirement specification proc 
th int 
conf 
software eng nice france march pp 


roman taxonomy current issues requirements engineering ieee computer vol 
apr pp 

simon sciences artificial nd ed 
cambridge ma mit press 
smith performance engineering software systems 
reading ma addison wesley 
stonebraker triggers inference database systems knowledge base management systems brodie mylopoulos eds 
new york springer verlag pp 

thayer thayer glossary tutorial system software requirements engineering richard thayer merlin dorfman eds 
ieee computer society press pp 

selection indexes memory resident entities semantic data models ieee trans 
knowledge data eng vol 
june pp 

contents representing non functional requirements goals link types methods correlation rules labelling procedure dealing accuracy requirements goals accuracy requirements goal refinement methods goal decomposition methods goal satisficing methods goal argumentation methods correlation rules illustration dealing performance requirements layered goal structures performance goal refinement methods goal decomposition methods goal satisficing methods goal argumentation methods illustration bibliography 
