department energy lawrence livermore national laboratory visualization large terrains easy lindstrom appear proceedings ieee visualization san diego california october august approved public release dissemination unlimited preprint jc disclaimer document prepared account sponsored agency united states government 
united states government university california employees warranty express implied assumes legal liability responsibility accuracy completeness usefulness information apparatus product process disclosed represents privately owned rights 
specific commercial product process service trade name trademark manufacturer necessarily constitute imply endorsement recommendation favoring united states government university california 
views opinions authors expressed necessarily state reflect united states government university california shall advertising product endorsement purposes 
report reproduced directly best available copy 
available doe doe contractors office scientific technical information box oak ridge tn prices available apollo gov bridge available public national technical information service department commerce port royal rd springfield va www ntis gov lawrence livermore national laboratory technical information department digital library www llnl gov tid library html visualization large terrains easy elegant simple implement framework performing core visualization view dependent refinement large terrain surfaces 
contrary trend increasingly elaborate algorithms large scale terrain visualization algorithms data structures designed primary goal simplicity efficiency implementation 
approach managing large terrain data departs conventional strategies data tiling 
emphasizing segment efficiently bring data memory focus manner data laid achieve memory coherency data accesses top coarse fine refinement terrain 
compare results different data indexing schemes propose simple compute index yields substantial improvements locality speed commonly data layouts 
second contribution new simple easy generalize method view dependent refinement 
similar published methods area longest edge bisection top traversal mesh hierarchy produce continuous surface subdivision connectivity 
tandem refinement perform view frustum culling triangle stripping 
components done single pass mesh 
show framework supports virtually error metric highly memory compute efficient 
vast number publications decades level detail creation management terrains height fields trend increasing interactivity visual quality performance published methods generally come expense algorithmic implementation simplicity 
implementing fully functional integrated core visualization system support accurate fast view dependent refinement cases considerable time investment 
address problem describe simple implement algorithm improving memory locality minimizing amount data paging necessary general framework fast view dependent refinement 
approach handling large terrains lay data order closely follows order accesses vertices terrain 
essence goal find fixed permutation list height field vertices typical access pattern yields near optimal cache behavior 
indexing scheme groups mesh data refinement level demonstrate considerable improvement paging performance 
issue data paging main memory orthogonal approach 
virtue greatly improved coherency explicit paging scheme necessary 
task address east avenue livermore ca pl llnl gov performed auspices doe llnl contract 
eng 
peter lindstrom center applied scientific computing lawrence livermore national laboratory delegated operating system 
memory mapped files system call associate main memory address space terrain data stored disk 
general framework allows different indexing schemes quickly integrated leaving open possibility sophisticated paging techniques explicit data pre fetching management 
note tied memory mapping propose simple effective method handling large terrains 
accommodate fast display rates essential perform onthe fly simplification high resolution mesh 
similar algorithms view dependent refinement recursive edge bisection means refining coarse base mesh defined regular grid elevation points 
method performs top traversal mesh 
problem common algorithms top refinement ensure consistent mesh cracks built 
guarantee property enforcing nesting terms view dependent error metric implicitly forcing parent vertices introduced descendants 
details algorithm section 
summarize features independence error metric 
framework allows virtually error metric incorporated 
supplemental information stored terrain data essentially orthogonal choice error metric 
consequence implementing different metric requires adding handful lines code 
memory efficiency 
vertex data limited position parametric coordinates optional scalar error term scalar term encoding bounding sphere 
computational efficiency 
refinement algorithm single pass terrain inherently output sensitive 
time needed construct decimated mesh proportional number triangles contains 
algorithm fast practice simple operations involved 
efficient view culling triangle stripping 
fast hierarchical view culling supported additional memory cost 
recursive refinement terrain visits vertices triangle strip order allowing rendering performed tandem refinement 
implicit mesh continuity 
due top approach guarantees parent child relations mesh unconditionally continuous surface outside view volume 
dependencies need maintained costly crack fixing performed 
near optimality 
accuracy top method produces meshes slightly triangles minimal number obtained bottom simplification 
asynchronous updates 
continuous mesh covers entire terrain produced refinement view culling decoupled rendering stage 
approach dedicated rendering thread receives asynchronous mesh updates possibly slower refinement thread 
simplicity 
refinement algorithm simple implement requires dozen lines code 
describing algorithms cover related terrain visualization 
conclude experimental results directions 
previous section discuss related large scale terrain visualization 
focus particularly algorithms refinement terrains schemes core paging memory coherent layout multiresolution data 
view dependent refinement decades extensive done area terrain visualization level detail creation management 
limit discussion fine grained view dependent simplification refinement terrain surfaces 
gross propose method adaptive mesh tessellation near interactive rates 
technique wavelet transform gridded data large detail coefficients chosen selective refinement 
windowing technique described allows regions mesh refined 
lindstrom describe algorithm interactive view dependent refinement terrain 
represent terrain mesh subdivision connectivity locally refined recursive edge bisection 
algorithm conceptually works bottom recursively merging triangles screen space error tolerance exceeded 
actuality coarse grained simplification refinement rectangular blocks followed fine grained vertex decimation block 
due blocking special care taken ensure cracks form blocks 
handling problem context asynchronous paging blocks non trivial enforcing dependencies vertices costly 
lindstrom hoppe extended progressive meshes allow view dependent refinement arbitrary meshes 
technique specialized terrain rendering :10.1.1.10.3677
run time performance reported hoppe places method fastest ones published date 
memory requirements method lower considerable 
addition fully implementing algorithm easy task 
space meshes proposed improvements lindstrom method roam algorithm 
organizing mesh acyclic graph vertices suggest binary tree set triangles 
data structure crack prevention easier 
significant contribution idea maintaining queues split merge operations allows incremental changes mesh order importance allowing refinement pre empted time budget reached 
unfortunately robustly implementing dual queue algorithm mention components method proven difficult 
algorithms edge bisection published different strengths weaknesses terms visual accuracy memory time complexity 
authors recognize inherent complexity doing input sensitive bottom simplification simple heuristics output sensitive top refinement 
improvements methods categories including accuracy mesh complexity memory usage refinement speed generality importantly ease implementation 
core paging data layout external memory algorithms known core algorithms address issues related hierarchical nature memory structure modern computers fast cache main memory hard disk 
managing making best memory structure important dealing large data structures fit main memory single computer 
new algorithmic techniques analysis tools developed address problem geometric algorithms scientific visualization 
terrain visualization systems external memory component essential handling real terrain gis databases 
hoppe addresses problem constructing progressive mesh large terrain bottom scheme decomposing terrain square tiles merged independent decimation simplified :10.1.1.10.3677:10.1.1.10.3677
address issue external memory handling large textures terrain visualization 
reddy implemented custom vrml browser specialized terrain visualization efficiency gained combined multiresolution tiling data caching predictive pre fetching 
component large scale terrain system decomposition domain square tiles stored database supports fast range queries 
efficient rendering achieved organizing set triangles single strip follows sierpinski space filling curve 
similar technique refinement algorithm 
prevailing strategy terrain paging split terrain large rectangular tiles varying resolution paged demand optimize size tiles path disk memory approach optimize data layout improve memory coherency core core access pattern 
approach sense orthogonal manner data paged 
simplicity leave operating system perform task 
view dependent refinement goal view dependent refinement build mesh small number triangles view approximation original dense mesh 
construction done continuously fly viewpoint changes mesh updated reflect change 
measure coarse mesh approximates original typically computes deviation corresponding points meshes objectspace projects errors screen 
depending mesh simplified bottom refined top triangles merged split ensure projected errors meet threshold mesh meets triangle budget 
section framework performing top view dependent refinement terrain surface 
show single procedure efficiently perform refinement cull mesh view volume simultaneously build single triangle strip entire mesh 
describe main approach refinement follow details implement components 
top mesh refinement important classes meshes view dependent refinement general unstructured meshes called triangulated irregular networks tins regular semi regular meshes subdivision connectivity 
tins potential represent surface fewer triangles error tolerance simplicity regular subdivision hierarchies appropriate purpose 
edge bisection hierarchy 
arrows correspond parent child relationships directed acyclic graph mesh vertices 
refinement algorithm particular type subdivision longest edge bisection 
meshes produced subdivision scheme called meshes right triangulated irregular networks restricted quadtree triangulations property refined locally having maintain entire mesh resolution see example 
edge bisection scheme isosceles right triangle refined bisecting creating smaller right triangles 
starting coarse base mesh typically triangles adaptive recursive refinement mesh 
refinement criterion split triangle generally triangle approximates corresponding part original high resolution mesh 
view dependent refinement criterion depends factors relative position orientation viewer triangle 
vertices introduced edge midpoints subdivision map directly points regular rectilinear grid 
natural edge bisection hierarchy multiresolution representation approximating height fields terrain surfaces 
methods edge bisection dimensions underlying grid constrained vertices direction number refinement levels 
possible perform inverse refinement simplification starting highest resolution mesh recursively merging pairs triangles satisfy simplification criterion 
significant disadvantage simplification versus refinement computational complexity depends size highest resolution mesh refinement complexity linear size approximating mesh 
mesh produced edge bisection represented directed acyclic graph dag vertices 
directed edge children dag corresponds triangle bisection inserted connected right angle corner triangle 
non leaf vertices boundary mesh connected children dag parent vertices 
boundary vertices children parent 
refinement mesh say vertex active included furthermore valid forms continuous surface junctions cracks 
produced simplification refinement valid satisfy property ci ci set children dag 
vertex active parents induction ancestors active 
dag traversal top ensuring property easy may possible reach dag visiting parents 
solution enforcing validity mesh maintain explicit dependencies child parents vertex activated chain dependencies followed ancestor vertices activated 
approach inefficient terms computation storage 
approach satisfy property ensuring error terms refinement criterion nested implicitly forcing parent vertices activated descendants 
refinement criterion idea nested errors new 
blow describes method nested spheres 
sphere centered position mesh vertex represents projected screen space error pi object world space error term viewpoint 
constant viewpoints sphere surface 
fixed screen space error tolerance divides space halves active viewpoint inside sphere inactive viewpoints outside 
spherical isosurfaces blow constructs forest nested sphere hierarchies parent sphere contains child spheres 
vertices associated spheres need related refinement long viewpoint outside particular sphere vertices sphere subtree active allows large groups vertices decimated quickly 
theoretically simple method number drawbacks 
ensure nesting fixed front 
second method tied particular error metric metric distance 
orientation sensitive metric necessarily lead isosurfaces nesting properties 
third maintaining explicit dependencies vertices artificially inflating spheres necessary property generally satisfied resulting cracks mesh 
tree sphere forest visited refinement 
forest arbitrarily large clustering trees may necessary 
approach bears resemblance blow avoids undesirable features 
nested dag spheres different purpose structure relationship vertices refinement 
discussion unimportant error terms measured discuss possible error metrics section 
require pi increases monotonically pi fixed reasonable assumption 
definitions sufficient condition satisfying property pi pj ci guarantee property compute adjusted projected error maximum children need relationship transitive meaning hold children descendants 
visiting descendant active vertex run time clearly impractical large terrains set descendants increases exponentially size 
compute lower bound making sphere hierarchy 
note distinct components object space error term view dependent term relates pi approach separate guarantee nesting term 
leaf node max max ci clearly ci 
due monotonic relationship pi pi ensures loss visual accuracy 
don necessarily pi pj ci remainder assume generic screen space error function position viewpoint 
error metrics may measure error points vertex positions entire triangles may depend additional view information gaze direction 
straightforward generalize definitions error metrics 
analogue nested sphere hierarchy refinement view culling 
triangles associated vertices right angle corners 
notice bounding spheres completely contain corresponding triangles bottom levels dag contain level 
error projected pj may arbitrarily larger error projected pi viewpoint may close pj far pi 
essentially add pi projection set pj descendants compute maximum projection set points 
impractical resort superset points easily expressed defined ball bi radius ri centered pi 
define ri leaf node max pi pj rj ci bi bj ci ball hierarchy nested 
example nesting shown 
define adjusted projected error max bi bi bj ci 
consequently active parent set show 
compute run time need perform constrained optimization ball bi typically reduces optimization boundary bi 
may expensive process 
generally easy find closed form expression minimum pre computed see section metric distance expressed concisely 
interesting note approach computing lower error bounds similar strategy lindstrom optimization nested bounding boxes done coarse grained simplification refinement large blocks vertices 
pre processing data set compute vertex 
addition vertex elevation coordinates parameter plane desired parameters needed top refinement algorithm 
general framework refinement briefly discuss compute actual screen space errors different error metrics 
error metrics section consider possible object space screen space error metrics 
common object space error measure height fields vertical distance corresponding points original approximating mesh 
simplicity errors computed height field vertices may computed triangles larger regions influence associated vertex 
framework accommodates approaches position areal extent object space error included vertex bounding sphere inflating necessary 
object space errors measured relative terms consecutive levels refinement absolute terms respect highest resolution mesh 
choice relative absolute errors orthogonal refinement method front errors need computed propagated consistently pre processing 
object space measure error view dependent algorithm projects screen resulting screen space error 
perspective projection commonly terrain visualization involves problems singularities somewhat computationally inefficient 
common view dependent algorithms substitute distance view direction absolute distance attenuate errors 
simple metric form written pi projected error decreases distance viewpoint 
usual perspective projection plane tan number pixels field view 
equation actuality projection sphere plane appropriate choice compare user specified screen space error tolerance 
refinement procedure need find maximum projection set points bi section 
equation maximum projection occurs minimized 
viewpoints inside bi term zero activate bi minimum pi ri maximum screen space error pi ri comparing rearranging squaring terms obtain active ri ri constant refinement 
ex pression involves additions multiplications efficient evaluate 
note equation viewpoint contained bounding sphere 
default error metric terrain visualization system report results section 
object space errors measured vertically errors viewed appear relatively smaller errors viewed side 
lindstrom describe orientation sensitive metric exploits fact 
possible derive simple expression metric refinement algorithm empirical results observed hoppe indicate reduction mesh complexity purely distance metric order percent :10.1.1.10.3677:10.1.1.10.3677
discuss metric detail 
run time refinement necessary pieces hand summarize algorithm top refinement fly triangle strip construction 
pseudo code steps listed table 
refinement procedure builds triangle strip vn represented sequence vertex indices 
triangle strip opengl implementation repeated calls sequence vertices 
append vn vn parity parity vn submesh refine active submesh refine cl append mod submesh refine cr mesh refine parity submesh refine ic append ise submesh refine ic append ine submesh refine ic append submesh refine ic iw table pseudo code recursive mesh refinement triangle stripping 
construction 
vertex appended strip procedure append table 
line turn corners triangulation effectively swapping vertices results degenerate triangle discarded graphics system 
procedure corresponds innermost recursive traversal mesh hierarchy cl cr child vertices dag parent pg domain current triangle 
discuss compute cl cr section 
notice submesh refine called recursively new parent vertex condition line subsequently evaluated twice subtree 
evaluation constitutes significant fraction refinement time efficient move level recursion evaluating conditionally making recursive calls 
outermost procedure mesh refine starts base mesh triangles calls submesh refine triangle 
number refinement levels ic vertex center grid ise ine grid corners iw vertices introduced refinement step 
triangle strip initialized copies vertex allow condition line append evaluated 
vertex discarded triangle strip constructed 
applications demand interactive visualization highest possible frame rates common parallelize sequential interleaved tasks refinement rendering asynchronous processes threads 
model render thread periodically asynchronously supplied list geometry render refinement thread 
display list potentially reused frames newly refined mesh obtained 
terrain visualization system allows multi threaded mode rendering addition traditional sequential mode processing 
view culling rendering performance terrain visualization system substantially improved culling mesh triangles fall outside view volume 
view culling done simultaneously refinement exploits hierarchical nature subdivision mesh large chunks triangles high mesh hierarchy possible 
approach culling algorithm outlined somewhat efficient 
particular exploit nested bounding sphere hierarchy perform view culling similar 
note bounding sphere vertex contains vertices descendants bounding sphere visible descendants appear screen 
possible theory small piece triangle descendants vertex visible vertices visible 
excluding coarser triangle rendered 
note happen periphery screen resulting er ror triangle coarser resolution small relation size practice bounding sphere hierarchy intrinsically loose errors occur second finest refinement level see seen visible artifacts culling mesh 
culling algorithm planes view frustum 
implicit plane equations computed object space coordinates passed refinement 
maintain flag plane indicating bounding sphere completely interior side plane respect view volume 
case descendants bounding spheres interior side culling tests necessary 
sphere entirely outside planes vertex descendants culled refinement recursion terminates 
view culling done spheres straddle planes view volume 
illustrates advantage performing view culling 
evident mesh resolution drops sharply immediately outside view volume 
features left edge mesh remain close top plane view frustum 
note bounding spheres nested culling condition consistent parents children child visible parents 
consequence view culling introduce junctions cracks mesh remains continuous surface 
desirable feature refinement render stages asynchronous regardless refinement thread falls render thread continuous mesh display 
data layout indexing section addresses problem laying terrain data disk achieve efficient core performance 
spirit approach terrain visualization goal simple mechanism perform core paging data maintaining high performance 
particular take advantage paging mechanism operating system mmap function 
mmap associates part logical address space computer specific disk file 
mechanism external memory part implementation consists simply call mmap associate memory address array terrain information elevation values precomputed errors stored disk 
step array terrain vertices allocated main memory operating system takes care paging data disk needed 
main advantage approach simplicity 
paging mechanism specialized particular core algorithm perform fair comparison different data layout schemes 
study performance potential intrinsic different data layouts adding specialized layer pre fetching mechanisms improve core performance terrain traversal 
framework described external memory processing problem reduced data layout problem 
know structure terrain traversal algorithm mechanism hides need data paging application 
framework need determine way storing raw data minimizes paging events ii efficient procedure computing index data element refinement order significant added cost introduced refinement process 
subsections describe data layout scheme satisfies requirements ii particularly straightforward implementation 
equivalent windows function 
top row levels white quadtree 
bottom row complete black quadtree obtained adding crossed ghost vertices 
illustration embedding top levels white quadtree unused parts black quadtree 
interleaved quadtrees basis edge bisection refinement algorithm vertex apart corners grid labeled white introduced odd level refinement black introduced level 
shows classification levels refinement 
top row shows sequence white vertices forms quadtree white quadtree qw 
white node fact center square tile quadtree decomposition rectilinear grid 
interestingly black vertices considered part black quadtree qb 
shows crossed circles vertices need added outside rectilinear grid form complete black quadtree 
refer additional vertices ghost vertices black quadtree rotated degrees respect white quadtree 
note qb start root level refinement 
adding virtual root node qb level taller qw 
traversal dag see section performed top starting form root data locality achieved storing data coarse fine levels 
level data stored preserve neighborhood properties extent possible vertices geometrically close stored close memory 
quadtree achieved order induced formula computes index th child parent node constant dependent index root index distance consecutive levels resolution 
data layout vertices level resolution stored starting coarsest level 
index distance vertices level depends distance common ancestor quadtree siblings stored consecutive positions 
indexing scheme interleave black white quadtree roots rb rw 
rb practice assign indices corners grid 
child rb stored immediately rw rb rw imply 
notice ghost vertices qb 
data eventually stored single linear array results unwanted holes array 
va cl pq cr nw ne vl vm vr pg sw se naming conventions nodes refinement hierarchy 
refinement single triangle linear indexing 
refinement interleaved quadtrees 
sibling vertices black white quadtrees respectively 
possible reduce amount unused space 
observe total number ghost vertices roughly twice large number white vertices 
consequence interleaved quadtrees black quadtree store white nodes place subset ghost nodes 
divide qw subtrees rooted children rw 
shows insertion subtrees unused space qb 
single quadtree affects value constant case rb value white root rb implies 
drawback quadtree indexing schemes non contiguous address space 
case interleaved quadtrees unused ghost vertices result waste storage resources roughly input data 
overhead reduced storage layout white quadtree embedded black quadtree 
overhead completely eliminated data layout hierarchical version lebesgue order space filling curve 
implementation scheme straightforward quadtree schemes described provide details computations involved indexing scheme refer interested reader 
section include empirical results performance achieved quadtree schemes discussed hierarchical order space filling curve 
efficient index computation avoid overhead refinement process need efficient method computing indices vertices visited top traversal terrain 
data stored linear order standard row major matrix layout computing child indices dag easy carrying indices refinement vl va vr 
indices current triangle refinement subscripts correspond left apex right corner triangle 
child triangles recursion written tl vl vm va tr va vm vr 
vm corresponds vertex midpoint edge vl vr computed simply average vm vl vr 
indexing scheme interleaved quadtrees parent child relationship vertices quadtrees 
consider refinement step shown 
new white vertices cl left child cr right child common black graph parent pg refinement dag 
graph parent pg quadtree parent pq cl cr 
observation indices cl cr computed index quadtree parent pq equation 
relative positions pq pg determine branches values index need reach cl cr pq 
numbering children common parent conventions shown 
chosen particular labels branches carefully allow efficient child index computation having lookup tables 
conventions compile transition tables shown table 
note value determined lowest bits vertex index 
considerable redundancy transition tables due choice branch labels transition tables consequently child indices cl cr kl kr pg kl kr sw pg se ne nw sw se ne ne nw nw sw sw se pq se nw sw sw se se ne ne nw ne se ne ne nw nw sw sw se pq nw nw sw sw se se ne ne nw table transition tables determine left kl right kr branch equation quadtree parent pq dag parent pg 
symbols tables values follow conventions 
expressed concisely arithmetic operations cl pq pg pq pq pg mod cr pq pg pq pq pg mod simple equations submesh refine procedure section 
results section results running implementation terrain visualization system computer architectures 
processor mhz pentium iii pc running red hat linux mb ram geforce graphics 
push core aspect system artificially limited memory configuration machine mb results 
processor mhz sgi octane solid impact graphics mb ram measure memory coherency processor mhz sgi onyx gb ram graphics avoid graphics memory limited allow raw refinement speed measured 
results data set puget sound area washington vertices meter horizontal meter vertical resolution 
data set occupies roughly gb disk 
window size cases pixels 
view dependent refinement discuss performance view dependent refinement algorithm 
distance error metric described section results 
evaluate efficiency mesh complexity accuracy recorded views number rendered triangles obtained bottom simplification terrain produces minimal number triangles threshold top scheme 
shows histogram distribution views suboptimal mesh contained certain percentage triangles minimum possible 
mesh generally contains triangles necessary due requirement nested errors occasional inflated error terms 
interesting note top method produces meshes just percent larger minimal pixel error tolerance 
evaluate performance increase due culling multi threading thread rendering refinement 
results summarized table plotted 
graph multi threading culling corresponds sequence shown accompanying video 
able maintain frames second nearly entire fly 
number rendered triangles exceeded frame rate slowed briefly 
numbers expect algorithm surpass performance hoppe method :10.1.1.10.3677
reports rendering speed triangles hz sgi onyx multi threading able sustain rendered triangles obtained subset freely available data duff 
geology washington edu data raster bil 
number views mesh complexity minimum mesh complexity distribution top scheme relation optimal mesh different views 
error tolerance pixel 
platform gb sgi mb pc multi view time rendering refinement threading culling table flight time average performance frame fly see 
rendering performance measured number rendered triangles frame time includes refinement time single threaded mode 
rate 
demonstrates clear advantage culling multi threading 
highlights refinement performance culling measured number rendered triangles divided wall clock refinement time 
low triangle counts refinement runs faster view culling disabled expected 
notice mesh complexity increases middle graph lack view culling leads significant decrease performance 
conversely view culling results relative speedup 
attribute result caching behavior triangle strip grows increasing number cache misses slows method culling 
large fraction triangles culled overhead making recursive function calls dominates evidenced sharp drop performance near frame 
evaluated efficiency single triangle strip 
ratio triangle strip vertices number non degenerate triangles averaged vertices triangle virtually variance 
number compared vertices triangle list independent triangles 
data layout section compare memory performance different indexing schemes single quadtree scheme section white tree embedded black tree order indexing scheme blocking scheme tiles highest resolution data standard matrix layout row major form 
methods stored fields occupy bytes vertex see section 
focus storage efficiency vertex records entirely possible compress eliminate fields record 
assume fixed length records focus efficient different indexing schemes accessing 
shows total number page faults executing flight path video varying values error tolerance 
smaller values result larger meshes rendered data paged 
clearly hierarchical indexing schemes quadtree order greatly outperformed linear block schemes lead drastically improved paging speeds 
surprising scheme terrains performs worst 
refined mesh rarely consists total number page faults block linear single quadtree screen space error tolerance pixels total number page faults vs screen space error tolerance mb sgi 
groups vertices highest resolution 
handful vertices needed block requiring virtually entire terrain paged refinement pass 
reasonable block indexing scheme subsample data create multiresolution pyramid allowing coherent access different resolutions data 
indexing scheme uses multiple indices vertex arguably unfair comparison indexing schemes 
investigated paging behavior time 
results sgi octane shown pc results shown log log scale 
graphs show significant hit startup data memory resident pages stay user memory reclaimed quickly operating system cache 
surprisingly quadtree scheme requires unused space performs slightly better order scheme 
unfortunately plausible explanation behavior 
measured raw core refinement speed indexing schemes 
due better cache locality quadtree scheme involving operations twice fast linear scheme twice fast complex scheme 
suggests linear scheme inferior aspects quadtree indexing exception memory overhead 
plan investigate alternative indexing schemes desirable properties quadtree scheme higher memory efficiency 
summary algorithms important components large scale terrain rendering method efficient view dependent refinement indexing scheme organizing data memory friendly manner 
emphasis simplicity efficiency methods core algorithms implemented little dozen lines code 
spite simplicity rendering paging speed algorithms compete state art terrain visualization 
see avenues 
demonstrated need refinement insert vertices edge midpoints 
current data structures store vertex perform data dependent triangulation subdivision connectivity 
particularly desirable representing features roads rivers 
far employed smooth transitions mesh resolution transitions particularly distracting 
believe framework easily support significant code changes 
compare integrate different error metrics indexing schemes framework 
contrary spirit approach needs done address issue paging efficiency 
prediction prefetching may possible improve rate data paged integrated multiresolution terrain 
cumulative number page faults block linear single quadtree frame number cumulative number page faults time mb sgi 
cumulative number page faults block linear single quadtree frame number log scale cumulative number page faults time mb pc 
arge 
showing lower bounds external memory computational geometry problems 
external memory algorithms visualization 
american mathematical society press 
bajaj thompson zhang 
parallel accelerated core visualization 
proceedings ieee parallel visualization graphics symposium 
oct 
blow 
terrain rendering high levels detail 
proceedings game developers conference 
mar 

chiang silva 
optimal isosurface extraction 
ieee visualization 
nov 
clark bailey 
visualization height field data physical models texture 
ieee visualization 
nov 
davis jiang ribarsky faust 
intent perception outof core visualization applied terrain 
ieee visualization 
oct 
baumann hinrichs 
texturing techniques terrain visualization 
ieee visualization 
oct 
wolinsky miller aldrich weinstein 
roaming terrain real time optimally adapting meshes 
ieee visualization 
nov 
evans skiena varshney 
optimizing triangle strips fast rendering 
ieee visualization 
oct 
evans kirkpatrick townsend 
right triangulated irregular networks 
algorithmica mar 
goodrich 
vitter 
external memory computational geometry 
proceedings th annual ieee symposium foundations computer science 
nov 
gotsman 
visualization large terrains resource limited computing environments 
ieee visualization 
nov 
gross 
fast multiresolution surface meshing 
ieee visualization 
oct 
hoppe 
view dependent refinement progressive meshes 
proceedings siggraph 
aug 
hoppe :10.1.1.10.3677
smooth view dependent level detail control application terrain rendering 
ieee visualization 
oct 
lindstrom koller ribarsky hodges den bosch faust 
integrated global gis visual simulation system 
tech 
rep git gvu georgia institute technology mar 
lindstrom koller ribarsky hodges faust turner 
real time continuous level detail rendering height fields 
proceedings siggraph 
aug 
matias segal vitter 
efficient bundle sorting 
proceedings th annual siam acm symposium discrete algorithms 
jan 

large scale terrain visualization restricted quadtree triangulation 
ieee visualization 
oct 
frank 
global static indexing real time exploration large regular grids 
proceedings supercomputing 
nov 
appear 
available llnl technical report jc 
reddy leclerc iverson 
ii visualizing massive terrain databases vrml 
ieee computer graphics applications mar apr 
helman 
iris performer high performance multiprocessing toolkit real time graphics 
proceedings siggraph 
jul 

seidel 
real time generation continuous levels detail height fields 
proceedings th international conference central europe computer graphics visualization 
feb 
rusinkiewicz levoy 
multiresolution point rendering system large meshes 
proceedings siggraph 
jul 
gomes 
variable resolution meshes concepts applications 
computer graphics forum dec 
vitter 
external memory algorithms data structures dealing massive data 
acm computing surveys 
appear 
pixels triangles 
pixels triangles 
pixels triangles 
view mount washington 
edge bisection subdivision meshes different screen space error thresholds 
view culling triangles 
view culling triangles 
view culling rectangle 
examples view frustum culling 
mesh continuous culled 
view frustum shown semi transparent violet viewer looking terrain right 
view 
mesh resolution drops quickly outside view frustum shown violet rectangle 
frame 
frame 
frame 
frame 
frame 
frames multi threaded fly sequences linear row major indexing top quadtree indexing bottom 
flight paths sequences 
improved cache performance quadtree scheme results detail paged quickly 
frame time ms single threaded culling single threaded culling multi threaded culling rendered frame number rendered triangles thousands frame time thin lines number rendered triangles thick lines 
refinement performance time 
core rendering refinement performance sgi onyx frames terrain fly see accompanying video 
curves correspond single threading culling multi threading culling 
hierarchical indexing scheme runs 
multi threading steady hz maintained nearly entire 
number triangles schemes culling coincide graph shown 
vertical axis corresponds number non degenerate triangles triangle strip divided wall clock refinement view culling time 
refinement speed triangles single threaded culling single threaded culling multi threaded culling rendered frame number 
