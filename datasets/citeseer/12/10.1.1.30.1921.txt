investigating reverse engineering technologies cas program understanding project buss de mori gentleman henshaw johnson kontogiannis merlo muller mylopoulos paul prakash stanley tilley wong corporations face mounting maintenance re engineering costs large legacy systems 
evolving years systems embody substantial corporate knowledge including requirements design decisions business rules 
knowledge difficult recover years operation evolution personnel change 
address problem software engineers spending growing amount effort program understanding reverse engineering technologies 
article describes scope results going research project program understanding undertaken ibm software solutions toronto laboratory centre advanced studies cas 
project involves addition team cas research groups working cooperatively complementary reverse engineering approaches 
groups source code sql ds multi line relational database system legacy system 
article discusses approach adopted integrate various toolsets single reverse engineering environment 
keywords legacy software systems program understanding software reuse reverse engineering software metrics software quality 
copyright fl ibm 
appear ibm systems journal 
software maintenance option 
developers today inherit huge legacy existing software 
systems inherently difficult understand maintain size complexity evolution history 
average fortune maintains lines code adds additional percent year just enhancements updates maintenance 
result maintenance software inventories double size years 
systems easily replaced entire history managing long term software evolution critical 
estimated percent evolution devoted program understanding 
easing understanding process significant economic savings 
promising approaches problem program understanding software evolution reverse engineering 
reverse engineering technologies proposed help maintain software systems 
facilitate understanding process subject software system represented form structural functional characteristics analyzed 
maintenance re engineering costs large legacy software systems increase importance reverse engineering grow accordingly 
describes complementary reverse engineering technologies applied realworld software system sql ds 
goal aid maintainers sql ds improving product quality enhancing understanding lines source code 
section provides background genesis program understanding project focus sql ds product 
subsequent sections detail individual research programs 
section describes defect filtering way improving quality minimizing design errors 
abundance defect filtering information needs summarized effective visualization documentation tools 
section discusses system reconstruct high level structural documentation software understanding 
comprehensive approach reverse engineering requires different techniques 
section outlines techniques analyze source code textual syntactic semantic levels 
convergence separate research prototypes integrated reverse engineering environment reported section 
section summarizes important lessons learned endeavor 
background faced demanding ambitious quality related objectives sql ds product group offered opportunity product candidate system analysis 
faced challenge program understanding project established goals investigate reverse engineering technologies real world sql ds problems utilize program understanding technologies improve quality sql ds product productivity sql ds software organization 
cas philosophy encourages complementary research teams problem common base product analysis 
little program understanding involves large real world systems multiple teams researchers experimenting common target 
networking opportunities ease exchange research ideas 
colleagues explore related solutions different disciplines 
strategy introduces new techniques help tackle problems industry strengthens academic systems deal complex industrial software systems 
addition universities move research academia industry accelerated rate 
different research groups participated contributed cas program understanding project ibm software solutions toronto laboratory centre advanced studies national research council canada nrc mcgill university university michigan university toronto university victoria 
groups focused source code sql ds legacy software system 
system sql ds sql ds structured query language data system large relational database management system evolved 
research prototype undergone numerous revisions release 
originally written pl run vm sql ds lines pl code runs vm vse 
pl proprietary ibm systems programming language pl allows embedded system assembler 
pl proprietary language commercial offthe shelf analysis tools unsuitable 
simultaneous support sql ds multiple releases multiple operating systems requires multi path code maintenance increasing difficulty maintainers 
sql ds consists compilation units roughly split large systems smaller ones 
complex evolution large size individual comprehend entire program 
developers forced specialize particular component various components interact 
existing program documentation problem maintain keep current source code read digest trust 
sql ds typical legacy software system successful mature supporting large customer base adapting new environments growing functionality 
top level goals program understanding project guided maintenance concerns sql ds developers 
important code correctness performance enhancement 
specific concerns included detecting uninitialized data pointer errors memory leaks detecting data type mismatches finding incomplete uses record fields finding similar code fragments localizing algorithmic plans recognizing inefficient high complexity code predicting impact change 
program understanding reverse engineering programmers programming knowledge domain knowledge comprehension strategies trying understand program 
example extract syntactic knowledge source code rely programming knowledge form semantic abstractions 
brooks theory domain bridging describes programming process constructing mappings problem domain implementation domain possibly multiple levels 
program understanding involves reconstructing part mappings 
programming process cognitive involving assembly programming plans implementation techniques realize goals domain 
program understanding tries pattern match set known plans mental models source code subject software 
large legacy systems manual matching plans laborious difficult 
way augmenting program understanding process computer aided reverse engineering 
forms reverse engineering common goal extract information existing software systems 
knowledge improve subsequent development ease maintenance re engineering aid project management 
reverse engineering process identifies system current components discovers dependencies generates abstractions manage complexity 
involves distinct phases identification system current components dependencies discovery system abstractions design information 
process source code altered additional information system generated 
contrast process re engineering typically consists reverse engineering phase followed forward engineering re implementation phase alters subject system source code 
definitions related concepts may 
discovery phase highly interactive cognitive activity 
analyst may build hierarchical subsystem components embody software engineering principles low coupling high cohesion 
discovery may include reconstruction design requirements specifications referred domain model correlation model code 
program understanding research research groups focused efforts development tools techniques program understanding 
major research issues involve need formalisms represent program behavior visualize program execution focus features control flows global variables data structures resource exchanges 
higher semantic level may focus behavioral features memory usage uninitialized variables value ranges algorithmic plans 
points investigation addressed differently 
commercial reverse engineering re engineering tools available catalogs describe packages 
commercial systems focus source code analysis simple code restructuring common form reverse engineering information abstraction program analysis 
research reverse engineering consists diverse approaches including formal transformations meaning preserving restructuring plan recognition function abstraction information abstraction identification graph queries reuse oriented methods 
cas program understanding project guided part need produce results directly applicable sql ds product team 
research groups oriented analysis 
single analysis approach sufficient 
specifically ibm group concerned defect filtering improving quality sql ds base code maintenance process application specific analysis 
university victoria focused structural production large documents describing high level subsystem architecture 
groups nrc university michigan mcgill university working pattern matching approaches various levels textual syntactic semantic 
goal project integrate results complementary overlapping research efforts produce comprehensive reverse engineering toolset integration process described fully section 
sections describe program understanding project main research results defect filtering structural pattern matching 
defect filtering ibm team led buss henshaw perform defect filtering commercial software refinery product refine parse source code sql ds form suitable analysis 
applies experience domain experts create refine rules find certain families defects subject software 
defects include programming language violations overloaded keywords poor data typing implementation domain errors data coupling application domain errors coding standards business rules 
initial resulted prototype toolkits focuses detecting specific errors system 
performed design quality metrics analysis study sql ds 
measurements guided creation flexible defect filtering approach reverse engineering toolkit automatically applies defect filters sql ds source code 
filtering quality fq proved fruitful approach improving quality system 
section describes evolution defect filtering process investigation construction reverse engineering toolkit pl construction prototype analysis systems measurement specific design quality metrics sql ds filtering quality 
building reverse engineering toolkit application problem domains unique specialized characteristics expectations requirements reverse engineering tool vary 
reverse engineering toolkits extensible versatile 
turn key reverse engineering package suffice users 
especially true analyzing systems proprietary nature sql ds 
knows exactly wants accomplish place premium toolkit flexibility 
considerations software refinery chosen basis build pl reverse engineering toolkit defect filtering process 
insert sidebar software refinery 
pl reverse engineering toolkit aid qualitative quantitative improvement sql ds base code maintenance process 
key improvement analysis 
software refinery convert sql ds source code tractable form 
considerable time spent creating parser domain model pl 
difficult process formal grammar available context sensitive nature language parsing challenge embedded system assembler code complicated matters 
lexical analyzer built recognize multiple symbols keyword skip embedded assembler pl listing format directives produce input acceptable parsing engine 
initial experiments produced numerous parsing errors due incorrect inappropriate pl features 
easy change legacy source code easier repair source code augment parser handle offending syntax 
process uncovered errors system source code 
errors usually incorrect uses language constructs identified pl compiler 
early experience pl reverse engineering toolkit confirmed large scale legacy software systems written proprietary context sensitive language put form suitable sophisticated analysis transformation 
toolkit adapted ibm developers similar programming languages evolves implementation rules change 
sql ds source code put tractable form time revisit customer sql ds maintainers determine best utilize technology 
answer came back crystal clear help remove defects code 
challenge effectively 
solution apply power prototype environment analyzing system 
rules written identify places software violations coding standards performance guidelines implementation product requirements exist environment detect defects semi automatically 
experiences pl reverse engineering toolkit prototypes construction prototype reverse engineering toolkit transformation base code tractable form analysis system possible 
analysis strongly biased defect detection due part sql ds product group quality related objectives 
analysis focused implementation language irregularities weaknesses functional defects software metrics unused code 
specific instance prototype toolkit constructed analysis realm 
areas interest classified orthogonal pairs analysis domains analysis small versus analysis large implementation domain versus problem domain 
analysis small concerned analysis code fragments usually procedures closed domain analysis inthe large concerned system wide impact 
analysis large tends difficult perform manual methods benefits may realized selective automation 
implementation domain analysis concerned environmental issues language compiler operating system hardware 
analysis usually readily shared similiar environment 
conversely problem domain analysis concerned artifacts problem business rules algorithms coding standards 
easily shared 
prototypes sql ds specifically built demonstrate capability analysis domains 
prototypes documented 
results prototype toolkits encouraging 
experiments demonstrated feasibility defect detection legacy software systems 
step reverse engineering technologies formalizing generalizing process defect filters system 
design quality metrics analyses maintenance goals continue focus generally improved performance functionality objectives emerging emphasis placed ibm product quality 
developers mounting quality improvement goals paradigm shift simply careful needed 
judicious software quality metrics way obtaining insight development process improve 
confirm applicability metrics ibm products initiated design quality metrics analysis project 
purpose assessing design quality metrics examine design process examining product source code predict product quality improve design process continuous increments quantum leaps 
justify ibm products experiment ffl relate software defects design metrics ffl identify error prone high risk modules ffl predict defect density product various stages ffl improve cost estimation changes existing products ffl provide guidelines insights software designers 
experiment assessed high level module level metrics sql ds related product defect history 
inter module metrics module level design measure inter module coupling cohesion data flow modules 
black box measures require knowledge inner workings module 
intra module design metrics include measures control flow data flow logic module 
clear box measures require knowledge inner working module 
inter module intra module versions structural complexity data complexity system complexity measured 
module level measurements shown 
insert sidebar conformance hierarchy 
experiment applied reverse engineering toolkit developed buss henshaw described section extract metrics system 
defect data gathered defect database running vm cms data correlated sas statistical package running os 
sql ds hours machine time risc system required analyze pl modules 
time include previous person hours required prepare persistent database sql ds source code 
unique characteristics sql ds system lead problems assessing metrics 
important product 
sql ds consists functional components quite different 
preprocessors communications software relational database engine utilities 
component displays different metric characteristics 
analyzing results defects caused design errors accounted percent total product defects 
largest class defects coding errors 
probability injecting defect maintaining module increased percentage changes module decreased 
greatest probability introducing defect occured smallest change 
counterintuitive result sense realized small changes maintainers typically take time fully understand entire module 
result maintainers increased probability injecting defect complexity module increases threshold 
module complexity increases threshold probability injecting error dramatically decreases 
suggests maintainer recognizes module complex tries harder modules complex maintainers avoid changing altogether 
past releases sql ds shown new modules low complexity older ones growing complexity 
complexity increases merely working harder ensure code quality 
increasingly difficult small changes mature modules classic example brittleness suffered aging software systems 
continuing analyzing ibm products written pl pl mi 
applying defect filters improve quality increased focus quality forced organizations re evaluate software development processes 
software process improvement concerns improved methods managing risk increasing productivity lowering cost key factors increased software quality 
meaning term quality subject debate may depend perspective 
definition quality quality absence defects 
somewhat traditional definition relates quality fitness ties software quality conformance respect function implementation environment 
traditional quality measurement measuring defects measures artifacts created software development process 
extending meaning constitutes defect expand definition quality 
example recognition defects caused coding standard violations means quality longer bound purely functional characteristics quality attributes extended include indirect features software development process 
extension quality framework may include assertions adhered assertion non conformance treated defect 
functional defects assertions address issues variety levels abstraction 
definition software quality extended include robustness portability improved maintenance hidden defect removal design objectives fitness superseded fitness maintenance 
illustrates conformance hierarchy 
hierarchy begins base immediate implementation considerations climbs upward deal broader conceptual characteristics 
wrong defects moves right assertions 
tightening definition correctness build higher quality software 
order ensure software product fit developers carefully review software checking possible defects verifying known product related assertions met 
commonly known software inspection process 
approach automating inspection process incorporates reverse engineering technologies discussed section 
filtering process termed filtering quality involves formalization corrective actions language model database rules inspect source code defects 
rules codify defects previous releases product 
context driven approach extends traditional language syntax driven methods tools lint 
benefits automation filtering quality fq process 
greater number defects searched simultaneously 
codified rules generalized restated eliminate entire classes errors 
actions expressed canonical rule form precise subject amenable automation 
knowledge required prevent defects maintained rule base knowledge action remains original development team members left 
recording informal corporate knowledge important long term success 
actions easily exchanged groups similar action rule bases 
sharing defect filters means development groups directly profit experience 
application domain knowledge beneficial development defect filters largely capability enforce application domain specific rules unavailable date 
wants enforce design assertions software product identify exceptions generally held principles software product evolved pay attention filter domain 
problem domain consists business rules aspects problem application independent way implemented 
implementation domain consists implementation programming language support environment 
summary meeting ambitious quality improvement goals times quality improvement requires improved definition defects improved software development process 
defect filtering automating portions inspection process reap great rewards 
tractable software representation key analysis 
easier defect filtering build tool implements 
critical analysis results accessible developers timely fashion identifiable impact 
success moving new technology workplace depends crucially acceptance system users 
minimal negative impact existing software processes accepted developers 
issues platform conflict underestimated 
prototype tools discussed sections partially integrated mainstream sql ds maintenance process 
measurable results come measurable problems 
defect filtering produces directly quantifiable benefits software quality stepping stone program understanding technology 
example presentation documentation tools needed sense amount information generated defect filtering 
critical need focus environment described section 
structural reconstructing design existing software especially important legacy systems sql ds 
program documentation played important role program understanding 
great differences documentation needs software systems lines versus lines 
typical software documentation small describing program terms isolated algorithms data structures 
documentation scattered different media 
maintainers resort browsing source code piecing disparate information form higher level structural models 
process arduous creating necessary documents multiple perspectives impossible 
exactly sort large documentation needed expose architecture large software systems 
software structure collection artifacts software engineers forming mental models software systems 
artifacts include software components procedures modules interfaces dependencies components client supplier inheritance control flow attributes component type interface size interconnection strength 
structure system organization interaction artifacts 
class techniques reconstructing structural models reverse engineering 
reverse engineering approaches reconstruct architecture aspects software termed structural 
university victoria centered rigi environment understanding evolving software systems 
output environment serve input conceptual modelling design recovery project management processes 
rigi consists major components tailorable parsing system supports procedural programming languages cobol pl distributed multi user repository store extracted information interactive window oriented graph editor manipulate structural representations 
scalability effective approaches program understanding applicable huge multi line software systems 
scale complexity necessitates fundamentally different approaches repository technology domains 
example software artifacts need stored repository may perfectly acceptable ignore certain details program understanding tasks 
coarser grained artifacts extracted partial systems incrementally investigated irrelevant parts ig obtain manageable repositories 
program representation search strategies human computer interfaces systems small scale 
large systems information accumulated program understanding staggering 
gain useful knowledge effectively summarize information 
sense key program understanding deciding information material immaterial knowing look ignore 
strategy tradeoffs program understanding environments automated left humans 
structural rigi initially automatic involves parsing source code subject system storing extracted artifacts repository 
produces flat resource flow graph software 
phase followed semi automatic exploits human pattern recognition skills features language independent subsystem composition techniques manage complexity 
approach relies experience software engineer system 
partnership synergistic analyst learns discovers interesting relationships interactively exploring software systems rigi 
subsystem composition recursive process building blocks data types procedures subsystems grouped composite subsystems 
builds multiple layered hierarchies higher level abstractions 
criteria composition depend purpose audience domain 
program understanding purposes process guided dividing resource flow graph established modularity principles low coupling strong cohesion 
exact interfaces modularity encapsulation quality measures evaluate generated software hierarchies 
subsystem composition supported program representation known partite graph 
graphs layered stratified strict levels arcs skip levels 
levels represent composition subsystems 
structuring mechanism originally devised managing complexity hypertext webs multiple hierarchies 
multiple dynamic views visual representations enhance human ability recognize patterns 
graph editor diagrams software structures call graphs module interconnection graphs inclusion dependencies automatically produced 
effective capability analyze structures necessary program understanding 
responsiveness important 
presenting large graphs arise complex system sql ds response time may degrade powerful workstations 
rigi user interface designed allow users necessary batch sequences operations specify windows updated 
small graphs updates immediate visually pleasing feedback large graphs user full control 
rigi presents structural documentation collection views 
view group visual textual frames contain example resource flow graphs overviews projections exact interfaces annotations 
views dynamic ultimately underlying source code remain date 
collected views retrieve previous reverse engineering states 
dramatic improvements program understanding possible semi automatic techniques exploit application specific domain knowledge 
user control subsystem composition process depend diverse criteria tax laws business policies personnel assignments requirements semantic information 
alternate orthogonal decompositions may exist structural representation supported rigi 
decompositions provide possible perspectives review 
effect multiple logical representations software architecture created manipulated saved 
domain retargetability program understanding involves diverse aspects applications domains necessary approach flexible 
reverse engineering tools provide fixed palette extraction selection filtering arrangement documentation techniques 
rigi approach uses scripting language allows analysts customize combine automate activities unforeseen ways 
efforts proceeding user interface fully user customizable 
approach permits analysts tailor environment better suit needs providing smooth transition automatic semi automatic reverse engineering 
goal domain retargetability having single environment sufficiently flexible applicable equally effective multiple domains achieved customization 
rigi system programmable extensible user interface editor engine decoupled room intermediate scripting layer embeddable tcl tk libraries 
layer allows event importance user example key stroke mouse motion button click menu selection tied scripted user defined command 
previously tedious repetitive activities automated 
layer allows analyst complement built operations external possibly application specific algorithms graph layout complexity measures pattern matching slicing clustering 
example rigi system applied various selected domains project management personalized hypertext legacy software systems 
sql ds analysis sql ds rigi shown subsystem composition method graph visualizing editor scale multi lines code range 
results analysis prepared set structural views development teams 
informal information knowledge provided existing documentation expert developers rich sources data leveraged possible 
considering sql ds specific knowledge naming conventions existing physical team members easily recognized constructed views 
domain dependent scripts devised help automate decomposition sql ds constituent components 
example relation data subsystem sql ds analyzed depth 
developer charge path selection optimizer mental model structure development experience 
model recreated rigi structural facilities 
alternate view created actual structure reflected source code 
second view constitutes reverse engineering perspective valuable view compared 
summary rigi environment focuses architectural aspects subject system analysis 
environment supports method identifying building documenting layered subsystem hierarchies 
critical usability ability store retrieve views snapshots reverse engineering states 
views transfer pertinent information abstractions software engineers 
rigi supports human script guided structural pattern recognition provide built operations perform analysis textual syntactic semantic pattern matching 
operations necessary complete program understanding 
scripting layer support access external tools cover areas analysis allowing rigi function cornerstone comprehensive reverse engineering environment 
required areas addressed prototypes described section 
pattern matching important reverse engineering processes analysis subject system identify components relations 
recognizing relations complex problem solving activity begins detection cues source continues building hypotheses cues 
approach detecting cues start looking program segments similar 
program understanding techniques may consider source code increasingly forms including raw text preprocessed text lexical tokens syntax trees annotated syntax trees symbol tables control data flow graphs 
forms entail additional syntactic semantic analysis corresponds meaning behavior code form structure 
different levels analysis necessary different users different program understanding purposes 
example preprocessed text loses considerable amount information manifest constants inline functions file inclusions 
research groups affiliated program understanding project focus textual syntactic semantic pattern matching approaches 
textual analysis big worth understanding internal structure finding understanding internal structure key understanding 
particular large source codes lots internal structure result evolution 
nrc research focuses techniques consider source code raw preprocessed textual forms dealing incidental implementation artifacts methods 
johnson nrc concerns identification exact repetitions text huge source codes 
goal relax constraint exact matches approximate matches preserving ability handle huge source texts 
general approach automatically analyze code produce information queried reported 
understanding purposes analysis better syntactic semantic analysis destroy information content code formatting identifier choices whitespace commentary 
evidence identify instances textual cut paste lost result syntactic analysis 
tools syntactic semantic analysis language environmentally dependent slight changes aspects tools inapplicable 
example versions tools may useless pl code 
specifically techniques discover location structure long matching substrings source text 
redundancies arise typical editing operations maintenance 
measures repetition useful basis building practical program understanding tools 
possibilities redundancy analysis including determining effects cut paste discovering effects preprocessing measuring changes versions understanding factoring abstraction mechanisms lacking 
nrc approach works fingerprinting appropriate subset substrings source text 
fingerprint shorter form original substring leads efficient comparisons faster redundancy searches 
identical substrings identical fingerprints 
converse necessarily true 
differing substrings may fingerprint chance occurring extremely 
file substring fingerprints locations provides information needed extract source code redundancies 
issues addressed discovering efficient algorithms computing fingerprints determining appropriate set substrings devising postprocessing techniques generated fingerprint file useful 
karp rabin proposed algorithm properties residue arithmetic fingerprints incrementally computed single scan 
modified version algorithm 
appropriate substrings called selected exploit line boundary information selection parameters generally desired number lines maximum minimum numbers characters 
adjustable culling strategy reduce sheer number 
overlap contain substring times culling strategy represents substrings certain 
particularly important postprocessing includes merging consecutive match occurrences producing longest matching substrings 
extensions identify long substrings match short insertions deletions 
experimental prototype built applied source code sql ds legacy system 
led number observations 
expansion inclusions preprocessing introduces textual redundancy 
redundancies easily detected prototype 
prototype applied small part source code files lines characters considering matches lines appeared numerous cut paste occurrences copied lines files 
processing entire megabyte source text ran successfully hours ibm risc system 
perform complete useful analysis sql ds research focused approximate matching techniques better postprocessing presentation tools 
textual analysis complements analysis tools providing information tools syntactic analysis effort paul prakash university michigan focuses design development powerful source code search systems software engineers tools designed specify detect interesting code fragments 
searching code extremely common activity reverse engineering maintainers find relevant code correct enhance re engineer 
software engineers usually look code fits certain patterns 
patterns common stereotypical known clich es 
patterns structural behavioral depending searching code specified syntactic structure looking code components share specific data flow control flow dynamic program relationships 
deficiencies current approaches despite critical nature task source code search systems exist 
general tools grep sed awk handle trivial queries context source code 
regular expressions tools exploit rich syntactic structure programming language 
source code contains numerous syntactic structural spatial relationships fully captured entity relation attribute model relational database 
example systems cia handle simple statistical cross queries 
graph models represent source code graph nodes software components procedures data types modules arcs capture dependencies resource flows 
scan system uses graph model attributed syntax representation 
model capture structural information necessary capture strong typing associated programming language objects 
fails support type lattices essential requirement ensure substitutability constructs share supertype subtype relationship 
object models refine adequately capture structural relational information source code 
focus refine design efficient source code search primitives 
university michigan group developed source code search system source code retrieval pattern languages 
pattern query language specify complex structural patterns code expressible existing systems 
pattern language allows users flexibility regarding degree precision code structure specified 
example maintainers trying locate matrix multiplication routine may specify control structure containing nested loops omitting details contents loops trying locate exact copies certain piece code may code piece specification 
pattern language extension source code programming language 
extensions include set symbols substitutes syntactic entities programming language statements declarations expressions functions loops variables 
pattern written symbols plays role template potentially match different code fragments 
pattern matching engine searches source code code fragments match specified patterns 
proceeds converting program source code syntax tree ast converting pattern special finite state machine called code pattern automaton cpa simulating behavior cpa ast cpa interpreter 
matching code fragment detected cpa enters final state 
experience system shows code pattern automaton efficient mechanism structural pattern matching source code 
source code algebra effective pattern query system 
current source code query systems including succeed handling subsets wide range queries possible source code trading generality expressive power ease implementation practicality 
address problem paul prakash designed source code algebra sca formal framework top variety high level query languages implemented 
principle query languages graphical pattern relational flow oriented 
modeling program source code algebra important consequences reverse engineering 
algebraic data model provides unified framework modeling structural flow information 
second query languages built algebra formal semantics 
third algebra serves low level applicative query language 
source code queries expressed algebra expressions optimized algebraic transformation rules heuristics 
source code modeled generalized order sorted algebra sorts program objects operators defined 
choice sorts operators directly affects modeling querying power sca 
essentially sca algebra objects sets sequences 
thought analogue relational algebra serves elegant useful theoretical basis relational query languages 
prototype implementation sca query processor underway 
step test suites representative queries arise reverse engineering 
final goal automatically generate source code query systems specific programming languages high level specifications languages syntax data model 
core query system language independent 
tool generation technique similar yacc parser generator 
semantic analysis mcgill research involves subgoals 
program representations needed capture structural semantic aspects software 
second comparison algorithms needed find similar code fragments 
third pattern matching algorithms needed find instances programming plans intents source code 
fourth software process definition needed direct program understanding design recovery analyses 
program representation suitable program representation critical plan recognition representation encapsulate relevant program features identify plan instances simultaneously discarding implementation variations 
representation methods discussed literature including data control flow graphs prolog rules calculus 
mcgill representation scheme object oriented annotated ast 
grammar domain model language subject system constructed software refinery 
domain model defines object hierarchy ast nodes grammar construct parser builds ast 
tree annotations produced parser produced running analysis routines tree 
annotations produced parser include source code line numbers include file names links identifier corresponding variable datatype definitions 
annotations produced analysis routines include variables updated functions called variable scope information operations complexity quality metrics 
annotations stored ast may analysis routines 
programming plans generally comparison methods needed help recognize instances programming plans abstracted code fragments 
pattern matching techniques similarity measures 
grasp compares attributed data flow subgraphs code fragments algorithmic plans uses control dependencies additional constraints 
compares syntax tree program suites tree templates representing plans 
plan instance match recognized code fragment conforms template certain constraints subgoals satisfied 
cpu comparisons performed applying unification algorithm code fragments programming plans represented lambda calculus expressions 
textual lexical matching techniques encounter problems code fragments contain irrelevant statements plans delocalized 
program behavior considered 
graph formalisms capture data control flow transformations graphs expensive pattern matching algorithms high time complexity 
poses major problem analyzing huge source codes 
addition plan instance recognition contend problems syntactic variations interleaved plans implementation differences 
major problem failure certain methods produce results precise recognition achieved 
mcgill group focusing plan localization algorithms handle partial plans 
human assistance favored completely automatic approach fixed plan library 
plans stand application level concepts simply abstracted code fragments 
concepts high level descriptions occurrences familiar properties assertions data dependencies control dependencies 
mcgill approach plans user defined portions annotated ast 
pattern matching localization algorithm find code fragments similar plan 
plan similar fragments forms similarity class 
object oriented environment gives flexibility matching process implementation variations encoded class hierarchy 
example repeat statements subclasses loop statement class 
object hierarchy classifies program structure data types defined language specific domain model 
similarity analysis focus pattern matching identifying similar code fragments 
existing source code reused system cut paste text operations cf 
section 
practice saves development time leads problems maintenance increased code size need propagate changes modified copy 
detection cloned code fragments done heuristics decision arbitrary programs perform function undecidable 
heuristics observation clones arbitrary carry identifiable characteristics features original fragment 
mcgill approach identifying clones uses various complexity metrics 
code fragment tagged signature tuple complexity values 
transformational technique simplifies software structures converting simpler canonical forms 
framework basic assumption code fragments similar set features measured metric metric values features close 
metrics chosen exhibit relatively low correlation coefficient sensitive number different program features may characterize code fragment 

number functions called software component fan 
ratio variables fan 
mccabe cyclomatic complexity 
albrecht function point quality metric 
henry kafura information flow quality metric 
similarity gauged distance measure tuples 
distances currently measures euclidean distance defined dimensional space measures clustering thresholds defined individual measure axis intersections clusters different measure axes 
analysis determine closely related software components criteria shared data data bindings complexity metrics 
grouping software components varied criteria provides analyst different views program 
data binding criteria tracks uses variables component defined kind interprocedural resource flow 
implementation analyses uses refine product 
goal driven program understanding design recovery strategy explored mcgill group variation gqm model goal question analysis action model 
number available options compared best matches objective selected 
choice experience formal knowledge 
process find instances programming plans 
comparison process iterative goal driven affected purpose analysis results previous 
moving frontier divides recognized plans original program material 
subgoals set fragments recognized high confidence 
analysis continues outward seeking existence parts plan code 
interleaved plans handled allowing gaps partial plan recognition 
summary research prototypes built performing textual syntactic semantic analysis sql ds system 
mcgill michigan tools process pl code applied code 
nrc tool numerous cut paste redundancies sql ds code 
research continuing improving tools 
nrc group focusing better visualization techniques 
michigan investigating better program representations pattern matching engines 
mcgill exploring techniques plan recognition similarity distances source code features 
number common themes arisen research 
domain specific knowledge critical easing interpretation large software systems 
program representations efficient queries essential 
kinds analyses needed comprehensive reverse engineering approach 
extensible environment needed consolidate diverse approaches unified framework 
architecture multi faceted reverse engineering environment addresses requirements section 
steps integration phase program understanding project produced practical results usable prototypes program understanding 
particular defect filtering system developed buss henshaw daily development groups including sql ds db 
second phase program understanding project focusing integration selected prototype tools comprehensive environment program understanding 
prototype tools individually developed research group offer complementary functionalities differ methods represent software descriptions implement descriptions terms physical data structures mechanisms deploy interact tools 
ideally output prototype tool usable input 
example dependencies generated defect filtering system explored summarized rigi graph editor 
defect detection system uses refine object oriented repository rigi system uses graph repository 
integrating representations employed refine rigi non trivial problem 
integration mind new phase project launched early 
key requirements integration ffl smooth data control presentation integration components environment ffl extensible data model interfaces support new tools user defined objects dependencies functions ffl domain specific semantic pattern matching complement facilities developed phase project ffl representation support processes methodologies reverse engineering ffl robust program representations user interfaces algorithms capable handling large collections software artifacts 
rest section describes steps taken provide data integration common repository variety tools program understanding 
addition section describes subsystem environment responsible control integration 
repository schema university toronto contribution focuses development information schema implementation repository support program understanding 
repository needs store extracted information gathered discovery phase abstractions generated identification phase reverse engineering 
information stored readily understandable persistent shareable reusable 
repository common consistent conceptual schema superset sub schemas program understanding tools including refine rigi 
repository provide simple repository operations select update information pertinent specific tool 
schema expected change support dynamic evolution 
schema development implemented phases 
phase implemented captures information currently required refine rigi 
information consists programming language constructs discovered parsing user defined tool generated objects 
example concept rigi subsystem captured class called module 
concept supported refine exist refine sub schema 
similarly programming language construct arithmetic expression captured refine sub schema class expression 
construct rigi sub schema representation rigi currently deal intraprocedural details 
example shared concept notion function common tools captured shared class function 
tool slightly different view class seeing common portions information pertinent 
second phase classifies patterns captures analysis results generated tool 
third phase record information relevant reverse engineering designs system requirements domain modelling process information 
remainder section describes schema developed phase 
information model adopted repository schema telos originally developed university toronto 
features telos include object oriented framework supports generalization classification attribution meta modelling facility novel treatment attributes including multiple inheritance attributes attribute classes 
telos selected data models example refine objectstore expressive respect attributes extensible treatment metaclasses 
support persistent storage repository adopted commercial object oriented database objectstore 
illustrated schema consists tiers 
top level metaclass level exploits meta modelling facilities define types attribute values repository supports useful groupings attributes distinguish information pertinent individual tools 
example capture data pertains rigi level defines kinds attribute classes lower level rigi classes 
level eases schema evolution provides important filtering factoring mechanism 
middle level class level defines repository schema classifying terms metaclasses attributes defined top level 
instance function grouped grey shaded area attribute metaclasses defined capture information particular rigi concepts 
example suggests repository object categorized pertinent tool automatically extracted produced analysis 
bottom level token level stores software artifacts needed individual tools 
shows function objects corresponding actual function definitions 
created rigi parses target source code 
environment architecture generic architecture important step goal creating integrated reverse engineering environment 
main integration requirements environment concern data control presentation 
data integration essential ensure individual tools communicate accomplished common schema 
control integration enhances interoperability data integrity tools 
realized data server built customizable extensible message server called telos message bus shown 
message server allows tools communicate repository common schema interlingua 
messages form basis communication system 
server implemented top existing public domain software bus technology layered approach provides mechanisms policies specifically tailored reverse engineering environment 
example bottom layer provides mechanisms particular tool receive messages interest 
policy layer built top mechanism layer determine particular tool responds messages 
architecture implemented 
motivation layered modular approach schema architecture came earlier experience university toronto group 
project faced similar requirements need common repository help integrate disparate tools 
additional experience architecture reverse engineering purposes currently ongoing 
summary old software needs understood 
critical information technology sector general software industry particular deal effectively problems software evolution understanding legacy software systems 
tools methodologies effectively aid software engineers understanding large complex software systems significant impact 
buss henshaw ibm built prototype toolkits refine focused detecting specific errors sql ds 
ibm developed flexible approach applies defect filters source code improve quality 
defect filtering produces measurable results software quality 
muller research group university victoria developed rigi system focuses highlevel architecture subject system analysis 
views multiple layered hierarchies structural abstractions maintainers 
scripting layer allows rigi access additional external tools 
johnson national research council studies redundancy textual level 
number uses relevant sql ds product looking code reused cut paste building simplified model macro processing actual providing overviews information content absolute relative version variant terms 
paul prakash university michigan match programming language constructs system 
looking low level textual patterns high level semantic constructs looks user defined code clich es 
approach logical progression simple textual scanning techniques 
kontogiannis de mori merlo mcgill university study semantic behavioral pattern matching 
transformational approach complexity metrics simplify syntactic programming structures expressions translating tuples 
distance measure tuples forms basis method find similar code fragments 
defect filtering generates overwhelming amount information needs summarized effectively meaningful 
extensible visualization documentation tools rigi needed manage complex details 
rigi offer textual syntactic semantic analysis operations needed comprehensive reverse engineering approach 
early results indicate extensible integrated toolkit required support multi faceted analysis necessary understand legacy software systems 
unified environment development schema architecture implemented group university toronto 
integration brings strengths diverse research prototypes 
acknowledgments grateful efforts people morris bernstein mcgill university david university toronto margaret anne storey michael whitney brian university victoria 
contributions critical success various research prototypes 
wish sql ds group members ibm participation staff cas support 
deeply indebted jacob slonim continued guidance macdonald associates 
encouragement endeavor 
trademarks aix ibm os risc system sql ds system vm xa vm esa vse xa vse esa trademarks international business machines 
software refinery refine trademarks reasoning systems sas trademark sas institute standish 
essay software reuse 
ieee transactions software engineering se september 
selfridge waters chikofsky 
challenges field reverse engineering position 
wcre proceedings working conference reverse engineering baltimore maryland may pages 
ieee computer society press order number may 
brooks 
theory comprehension computer programs 
international journal man machine studies 
arnold 
software reengineering 
ieee computer society press 
chikofsky cross ii 
reverse engineering design recovery taxonomy 
ieee software january 
arnold 
tutorial software reengineering 
csm proceedings conference software maintenance san diego california november 
ieee computer society press order number november 
hare 
re analyzer source code structured analysis 
ibm systems journal 
myers 
reliable software composite design 
charter 

reengineering technology report volume 
technical report software technology support center august 
editor 
software management technology guide 
software management news edition 
baxter freeman 
tmm software maintenance transformation 
ieee software may 
griswold 
program restructuring aid software maintenance 
phd thesis university washington 
rich wills 
recognizing program design graph parsing approach 
ieee software january 
linger 
function abstraction understand program behavior 
ieee software january 
grass 
object oriented design archaeology cia 
computing systems winter 

discovering visualizing controlling software structure 
acm sigsoft software engineering notes may 
proceedings fifth international workshop software specification design 
consens mendelzon 
visualizing querying software structures 
icse proceedings th international conference software engineering melbourne australia may pages may 
biggerstaff webster 
concept assignment problem program understanding 
wcre proceedings working conference reverse engineering baltimore maryland may pages 
ieee computer society press order number may 
buss henshaw 
software reverse engineering experience 
proceedings cascon toronto ontario october pages 
ibm canada october 
markosian 
program transformation approach automating software re engineering 
compsac proceedings th annual international computer software applications conference chicago illinois october pages 

assessing design quality metrics legacy software 
proceedings cascon toronto ontario november pages november 
henshaw buss 
filtering quality 
proceedings cascon toronto ontario october pages october 
buss henshaw 
experiences program understanding 
cascon proceedings cas conference toronto ontario november pages 
ibm canada november 
card glass 
measuring software design quality 
prentice hall 
card 
designing software 
journal systems software march 
ossher 
mechanism specifying structure large layered systems 
shriver wegner editors research directions object oriented programming pages 
mit press 
muller 
rigi model software system construction integration evolution module interface specifications 
phd thesis rice university august 
shaw 
larger scale systems require higher level abstractions 
acm sigsoft software engineering notes may 
proceedings fifth international workshop software specification design 
muller orgun tilley uhl 
reverse engineering approach subsystem structure identification 
journal software maintenance research practice december 
ousterhout 
tcl tk 
addison wesley 
published 
tilley muller 
virtual subsystems project management 
case sixth international conference computer aided software engineering institute systems science national university singapore singapore july pages july 
ieee computer society press order number 
tilley whitney muller 
storey 
personalized information structures 
th annual international conference systems documentation waterloo ontario october pages october 
acm order number 
johnson 
identifying redundancy source code fingerprints 
proceedings cascon toronto ontario november pages november 
karp rabin 
efficient randomized pattern matching algorithms 
ibm res 
develop march 
chen ramamoorthy 
information abstraction system 
ieee transactions software engineering march 
cleveland 
program understanding support environment 
technical report rc ibm watson research center september 
prakash 
software change analysis attributed dependency graphs 
technical report cse tr department eecs university michigan may 
paul prakash 
source code retrieval program patterns 
case proceedings fifth international workshop computer aided software engineering montr eal qu ebec july pages july 
paul prakash 
framework source code search program patterns 
ieee transactions software engineering june 
bruce wegner 
algebraic model subtype inheritance 
advances database programming languages 
acm press 
kontogiannis 
program representation program understanding process algebras 
cascon proceedings cas conference toronto ontario november pages 
ibm canada november 
wills 
automated program recognition feasibility demonstration 
artificial intelligence september 
johnson soloway 

byte april 
ning 
program concept recognition transformation 
ieee transactions software engineering december 
letovsky 
plan analysis programs 
phd thesis department computer science yale university december 
mccabe 
complexity measure 
ieee transactions software engineering se september 
albrecht 
measuring application development productivity 
proceedings ibm applications development symposium pages october 
henry kafura harris 
relationships software metrics 
proceedings acm workshop symposium measurement evaluation software quality march 
basili rombach 
tailoring software process project goals environments 
icse ninth international conference software engineering pages 
kontogiannis bernstein merlo mori 
development partial design recovery environment legacy systems 
proceedings cascon toronto ontario october pages october 
de mori satta 
computation probabilities island driven parser 
ieee transactions pattern analysis machine intelligence 
schurr westfechtel 
graph oriented database system software engineering applications 
case sixth international conference computer aided software engineering institute systems science national university singapore singapore july pages july 
ieee computer society press order number 
mylopoulos borgida jarke koubarakis 
telos representing knowledge information systems 
acm transactions information systems october 
carroll 
collaborative set 
phd thesis university illinois 
software refinery composed parts dialect parsing system refine objectoriented database programming language user interface 
core software refinery refine specification query language multi paradigm high level programming language 
syntax reminiscent lisp includes prolog rules support set manipulation 
critical feature software refinery extensibility integrated various commercial application domains 
foundation software analysis tractable representation subject system facilitates analysis 
dialect language model consists grammar parsing domain model store parsed programs syntax trees ast 
domain model defines hierarchy objects representing structure program 
parsed programs represented ast stored domain model object hierarchy 
objects annotated rules implementation language linking variable declaration ready analysis 
sidebar software refinery maintenance quality conformance hierarchy begins low level defects climbs upward broader conceptual characteristics 
functional defects errors product function 
usually detected product test code review stages caused mistaken translation functional specification implemented software 
example functional defect program expression attempts divide zero 
errors software cause erroneous function internally incorrect refer non functional defects 
cases working incorrect code functional defects maintainers making changes region non functional defect 
example variable contains undetermined value referenced cause program fail 
non portable defects characteristics limit software developer ability migrate software software environment 
environments may new compilers new hardware operating systems 
familiar example non portable software depends byte ordering hardware compiler 
anti maintenance defects program characteristics unclear undesirable sideeffect features implementation language 
experienced maintainers change software regions features inject defects 
examples type common inconsistent variable naming conventions keywords variable names excessive gotos 
part sidebar conformance hierarchy minimizing non portable anti maintenance defects means risks associated software maintenance lowered software produced fit change 
assertions describe desirable software characteristics introduced enforced software quality improved 
pro maintenance assertions state desirable attributes software help prevent defects 
assertions opposite anti maintenance defects assertion avoid gotos 
example inclusion pseudocode part software internal documentation 
design assertions capture positive aspects software structure maintain design quality code 
example design assertion may access data structure common data controlled access variable common data latch set accessing common data set times 
architectural assertions broad concepts apply higher level abstraction design assertions 
seek maintain architectural integrity software system 
example access shared data structures controlled latch variable data structure 
architectural assertions generalizations design assertions 
part sidebar conformance hierarchy module level measures sql ds performed part process ffl number lines code loc module excluding comments ffl number lines comments module ffl number changed lines code particular release ffl number lines code module including include structures ffl software maturity index smi loc loc loc number lines code module csi number changed lines code module ffl number declared variables module ffl number declared variables structures superfluous ffl number executable statements ffl mccabe cyclomatic complexity gamma cyclomatic number graph number edges number nodes number unconnected parts 
module level measurements sql ds non functional defects functional defects non portable defects anti maintenance defects pro maintenance assertions design assertions architectural assertions maintenance quality conformance hierarchy repository schema environment architecture author bios erich buss ibm sws toronto laboratory tor don mills road north york ontario canada 
electronic mail buss vnet ibm com 
buss advisory software engineering process analyst software engineering process group ibm software solutions toronto laboratory 
graduated sc computer science university western ontario 
joined ibm sql ds data group subsequently moved centre advanced studies cas 
cas ibm principal investigator program understanding project years worked practical application reverse engineering technology real development problems 
current interests program analysis defect filtering object oriented development 
renato de mori mcgill university school computer science university street room montr eal qu ebec canada 
electronic mail cs mcgill ca 
dr de mori received doctorate degree electronic engineering politecnico di torino torino italy 
full professor italy 
professor director school computer science mcgill university 
associate canadian institute advanced research project leader institute robotics intelligent systems canadian center excellence 
author publications areas computer systems pattern recognition artificial intelligence connectionist models 
research interests stochastic parsing techniques automatic speech understanding connectionist models reverse engineering 
fellow ieee computer society member various committees canada europe united states board international journals ieee transactions pattern analysis machine intelligence signal processing speech communication pattern recognition letters computer speech language computational intelligence 
gentleman institute information technology national research council canada montreal road building ottawa ontario canada 
electronic mail gentleman iit nrc ca 
dr gentleman head software engineering laboratory institute information technology national research council canada 
going nrc fifteen years professor computer science university waterloo member technical staff bell telephone laboratories murray hill 
ph mathematics princeton 
research activities include software engineering computer architecture robotics computer algebra numerical analysis 
dr gentleman extensive experience building supporting applying computer systems research industrial environments 
built supported various commercial software products 
john henshaw ibm sws toronto laboratory tor don mills road north york ontario canada 
electronic mail henshaw vnet ibm com 
henshaw manager software engineering process group ibm software solutions toronto laboratory 
prior current position staff researcher program understanding project ibm centre advanced studies years 
john interests fields software engineering database performance modelling programming languages environments 
howard johnson institute information technology national research council canada montreal road building ottawa ontario canada 
electronic mail johnson iit nrc ca 
dr johnson senior research officer software engineering laboratory national research council 
current research interest software re engineering design recovery full text approaches 
received math 
math 
statistics university waterloo respectively 
working survey statistics canada years returned university waterloo completed ph computer science applications finite state transducers 
assistant professor university waterloo manager software development team statistics canada joining nrc 
kostas kontogiannis mcgill university school computer science university street room montr eal qu ebec canada 
electronic mail kostas binkley cs mcgill ca 
kontogiannis received sc degree mathematics university patras greece sc degree artificial intelligence katholieke universiteit leuven belgium 
currently ph candidate mcgill university school computer science 
thesis focuses developing plan localization algorithms devising code similarity metrics 
sponsored ibm centre advanced studies natural sciences engineering research council canada 
interests include plan localization algorithms software metrics artificial intelligence expert systems 
merlo departement de genie ecole polytechnique succ 
centre ville montr eal qu ebec canada 
electronic mail merlo ca 
dr merlo graduated computer science university turin italy obtained ph degree computer science mcgill university 
lead researcher software engineering group computer research institute montreal crim 
currently assistant professor computer engineering ecole polytechnique de montr eal research interests include software reengineering software analysis artificial 
member ieee computer society 
muller department computer science university victoria box victoria bc canada 
electronic mail csr uvic ca 
dr muller associate professor computer science university victoria 
worked software engineer brown cie baden switzerland called brown 
received ph computer science rice university 
sabbatical ibm centre advanced studies toronto laboratory working program understanding group 
research interests include software engineering software analysis reverse engineering re engineering programming large software metrics computational geometry 
currently program chair international conference software maintenance icsm victoria program chair international workshop computer aided software engineering case toronto member editorial board ieee transactions software engineering chair national workshop software engineering education toronto 
john mylopoulos department computer science university toronto king college road toronto ontario canada 
electronic mail jm ai utoronto ca 
dr professor computer science university toronto 
research interests include knowledge representation conceptual modelling covering languages implementations applications 
past research include requirements design languages information systems adoption database implementation techniques large knowledge bases application knowledge bases software repositories 
currently leading number research projects principal investigator national provincial centre excellence information technology 
mylopoulos received ph degree princeton university 
publication list includes refereed journal conference proceedings papers edited books 
recipient outstanding services award canadian ai society recipient best award th international conference software engineering 
paul software systems research laboratory dept eecs university michigan ann arbor mi 
electronic mail eecs umich edu 
paul received tech 
degree computer science indian institute technology madras computer science engineering university michigan 
ph candidate university michigan ann arbor 
thesis focuses design algebraic languages query source code 
research interests include databases reverse engineering multimedia systems 
recipient ibm canada graduate research fellowship 
student member ieee computer society 
atul prakash software systems research laboratory dept eecs university michigan ann arbor mi 
electronic mail eecs umich edu 
dr prakash received tech 
degree electrical engineering indian institute technology new delhi ph degrees computer science university california berkeley respectively 
department electrical engineering computer science university michigan ann arbor currently assistant professor 
research interests include toolkits architectures supporting computer supported cooperative support reengineering software parallel simulation 
primary research focus providing distributed systems multimedia support carrying computer supported cooperative wide area networks 
member acm ieee computer society 
martin stanley department computer science university toronto king college road toronto ontario canada 
electronic mail mts ai utoronto ca 
stanley received degree computer science university toronto 
research interests include knowledge representation conceptual modeling particular application building software repositories 
currently research associate computer science department university toronto primary reverse engineering project toronto 
scott tilley department computer science university victoria box victoria bc canada 
electronic mail csr uvic ca 
tilley currently leave ibm software solutions toronto laboratory ph candidate department computer science university victoria 
book home computing published 
research interests include user programming hypertext program understanding reverse engineering user interfaces 
member acm ieee 
joel ibm sws toronto laboratory tor don mills road north york ontario canada 
electronic mail vnet ibm com 
software engineering process analyst software engineering process group ibm software solutions toronto laboratory 
joel obtained bachelor applied sciences electrical engineering masters applied sciences biomedical engineering university toronto 
joel interests include software complexity metrics technology propagation software development process benchmarking enjoying family life growing 
member ieee computer society 
kenny wong department computer science university victoria box victoria bc canada 
electronic mail csr uvic ca 
wong ph candidate department computer science university victoria 
research interests include program understanding user interfaces software design 
member acm usenix planetary society 

