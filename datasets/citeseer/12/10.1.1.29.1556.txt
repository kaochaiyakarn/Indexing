approximation algorithm minimal paths pseudo euclidean spaces zheng sun john reif department computer science duke university durham nc usa cs duke edu 
define piecewise pseudo euclidean optimal path problems region distinct cost metric class call pseudo euclidean allows path cost possibly vary region predictable efficiently computable way 
class costs allows model wide variety various geographical features 
provide approximation algorithm named efficiently solves piecewise pseudo euclidean optimal path problems 
uses previously known technique dynamically generating discretization progress 
combines technique lazy best path propagation scheme fewer edges need added discretization 
show analytically experimentally efficient approximation algorithms dijkstra algorithm 
applications robotic motion planning geographical information systems arise optimal path problems problem find minimal cost path plane 
common assumption previous studies problems optimal path straight line segment st st lies entirely inside free space 
years increasing attention motivation path planning problems various non euclidean metrics 
free space consists multiple regions metric regions straight line segment st may longer optimal path st lies free space 
techniques developed previous motion planning works longer valid 
weighted region optimal path problem entire free space divided polygonal regions associated unit weight :10.1.1.43.7768
cost path defined weighted sum lengths segments inside region 
example flow problem supported nsf itr eia nsf iri nsf ccr award nsf office naval research contract 
inside region flow defined vector cost path total travel time robot fixed maximum velocity 
solve weighted region optimal path problem number previous works discretization problem edge subdivision dijkstra algorithm find optimal path graph induced discretization :10.1.1.43.7768
proposed logarithmic discretization guarantees ffl short approximation ffl log ffl steiner points placed boundary edge 
algorithm applies pruned version dijkstra algorithm find optimal path discrete graph ffl ffl log log ffl time number boundary edges 
algorithm uses subgraph render optimal path discrete graph dynamically adding edges 
technique number prior precedents algorithm adopting lazy best path propagation scheme able fewer edges compute optimal path discrete graph 
key features algorithm approximation algorithm reif sun introduced approximately solve weighted region optimal path problem algorithm finds optimal path discrete graph time nm log nm 
generalized algorithm compute approximate optimal paths spaces satisfy wide range possible geometric properties 
section define class spaces call piecewise pseudo euclidean space 
show algorithm applied optimal path problem space class 
immediate application path planning area various geographical features plains regions low unit costs regions high unit costs rivers tides regions flows 
focus generality algorithm characterizations spaces applied 
feel important brief digression efficiency 
weighted region optimal path problem applying logarithmic discretization scheme proposed algorithm computes ffl short approximate optimal path nm log nm ffl log ffl log log ffl time 
improves approximation algorithms including mentioned 
preliminaries convex polygonal region said pseudo euclidean region satisfies properties 
property region associated cost function points cost straight line path xy 
cost function property path cost paths lie completely inside straight line segment xy 
property letting point region including boundary letting edge incident small number local extrema function gamma local extrema computed efficiently 
discussion refer region distance region cost space said piecewise pseudo euclidean space consists finite number pseudo euclidean regions 
arbitrary path space divided segments delta delta delta pm lies entirely inside region cost defined sum costs segments determined respective region cost function 
case segment xy lies boundary edge define cost minfd neighboring regions piecewise pseudo euclidean optimal path problem find optimal path path cost source point destination point piecewise pseudo euclidean space 
vertices pseudo euclidean regions 
property optimal path piecewise pseudo euclidean space piecewise linear 
segment path said edge crawling lies edge face crossing cuts region 
call path face crossing edge crawling path segment path face crossing edge crawling respectively 
piecewise space may consist hybrid regions cost functions completely different inside region euclidean space shortest path points inside region straight line segment 
point explain importance property algorithm show efficient computation local extrema needs 
property may restrictive practice optimal path planning problems satisfy property 
examples weighted region problem flow problem mentioned previous section 
introduce notations rest 
polygonal decomposition planar space set vertices denote set boundary edges jej 
loss generality assume region triangle 
path denote cost paths denote concatenation say extension particular say segment extension points denote path opt denote optimal path define distance opt cost opt 
time search optimal path point said discovered opt determined 
natural approach problems discretize space introducing steiner points 
boundary edge add steiner points positive integer set steiner points directed discrete graph constructed points boundary region 
edge assigned weight defined xy edge xy crosses region constructing original path planning problem continuous space transformed problem finding minimum path discrete graph 
problem solved dijkstra algorithm 
path called discrete path 
optimal discrete path approximate optimal path original continuous space 
steiner points place edge accurate approximation 
showed exists discretization ffl log ffl steiner points inserted boundary edge guarantees ffl short approximation optimal path takes je jv log jv nm nm log nm time find optimal discrete path dijkstra algorithm 
observe large dominant part time complexity nm je 
reduce cost processing edges proposed pruned version dijkstra algorithm 
exploiting fact angle angle optimal path bending point obey snell law algorithm uses sparse subgraph yields optimal discrete path number edges included subgraph je ffl log ffl ffl log ffl delta je 
total time complexity algorithm reduced ffl ffl log ffl log log ffl ffl ffl log log ffl 
algorithm follows discretization approach 
maintaining collection data structures called intervals average needs evaluate point costs log adjacent edges show section 
total number edges accessed algorithm nm log ffl delta je 
algorithm find optimal discrete path efficiently nm log nm ffl log ffl log log ffl time 
importantly compared pruned dijkstra algorithms weaker assumptions metric inside region applied piecewise pseudo euclidean optimal path problems 
goal algorithm find exact optimal discrete path discussion refer optimal path mean optimal discrete path specified 
opt denote optimal discrete path opt cost opt 
intervals algorithm works similarly dijkstra algorithm 
keeps sorted list qlist candidate optimal paths 
step candidate optimal path pmin minimum cost extracted qlist 
consequently number candidate optimal paths inserted qlist extensions pmin 
call process propagation iteration continues destination point reached 
dijkstra algorithm compute optimal path arbitrary weighted graph aforementioned discrete graph derived piecewise pseudo euclidean space certain geometric properties 
directly applying dijkstra algorithm fully utilize underlying geometric properties 
particular property implies lemma lemma optimal paths source point intersect interior region 
example paths originated source point intersect point inside region dijkstra algorithm consider paths potential optimal paths respective destination points 
piecewise pseudo euclidean space possible optimal paths intersect inside region stated lemma 
suppose segment contains fact line segments intersect inside region indicates line segments contribute optimal paths originated identify useful line segments may contribute optimal paths useless line segments able avoid explicit construction entire discrete graph keep track useful line segments introduce data structure named interval 
region boundary edges discovered point incident interval defined phi opt opt plist psi plist list includes discovered points point path opt vv costly path paths segment extensions optimal paths discovered points edge share region ilist denote list intervals plist definition intervals conclude discovered point point vv part optimal path originated enters region point maintaining ilist share region algorithm able avoid accessing edges observe interval dynamic set points created discovered 
points discovered plist contain points may changed definition 
lemma implies interval composed consecutive points leads name data structure interval 
interval located left right interval located left right respectively shows points edge partitioned intervals corresponding discovered points claim points interval computed efficiently log time initially created 
face crossing path opt vv needs considered candidate optimal path call path direct interval path associated strategy insert paths qlist simultaneously discovered 
may efficient ilist intervals ilist dynamic data structures 
new point discovered new interval possibly empty created inserted ilist new interval empty ranges neighboring intervals adjusted 
shown point originally new point vnew discovered may fall range new interval vnew case path opt longer needs considered optimal path costly opt new vnew definition interval 
efficient strategy insert direct interval paths lazy manner 
interval paths associated ilist sorted increasing order path cost 
path opt vv inserted qlist previous path extracted list strategy avoid inserting path opt vv qlist switched interval 
achieve need sort efficiently direct interval paths path cost 
paths segment extensions opt need sort property region distance function points constant number local extrema 
divided constant number parts local extrema region distance points part monotonically increasing decreasing 
create monotonic interval monotonic part replace intervals ilist points interval sorted region distance discussion assume interval monotonic 
weighted region optimal path problem region euclidean space interval split monotonic intervals perpendicular point illustrated true region uniform flow computing split point complicated shown 
suppose interval contains points delta delta delta initially created discovered shown delta delta delta consecutive points points interval 
assume 
interval monotonic delta delta delta region incident delta delta delta direct interval paths associated opt vv fp dg 
observe paths extended interval paths segment extensions direct interval paths associated call direct interval paths extended interval paths interval paths 
set interval paths associated connect say interval path locally optimal minfd want insert qlist locally optimal interval path connects initially interval path inserted qlist 
iteratively interval path added qlist intervals new new inserting interval fig 

intervals inserting interval interval path gamma gamma extracted qlist 
defined costly path paths gamma gamma interval path constructed extending opt line segment vv extending gamma line segment gamma whichever costly 
propagation process terminates points reached interval paths 
observe process may terminated generated inserted qlist 
occur interval created re adjust range establish theorem include proof full version theorem locally optimal 
splitting interval propagating interval paths fig 

operations intervals algorithm interval generate locally optimal interval paths number points inside interval 
interval list ilist interval paths inserted qlist number steiner points total number interval paths mn 
need show propagation scheme find optimal discrete path notations previously boundary edges region opt optimal discrete path point enters region point shown opt categorized types opt opt vv face crossing path opt opt vu edge crawling path opt opt vu edge crawling path opt opt vv edge crawling path joint point type type type type fig 

types optimal paths easy see propagation scheme find optimal path opt opt type type optimal path direct interval path type optimal path extended interval path 
capture optimal path type need create paths interval 
point outside interval discovered point interval contains insert path qlist created opt opt 
similarly add path necessary interval paths associated interval inserted 
point outside call paths non interval paths associated interval 
non interval paths propagated removed qlist show 
clear section algorithm finds optimal paths type 
algorithm algorithm maintains types dynamic lists qlist list candidate optimal paths sorted path cost plist list discovered points edge ilist list intervals edge boundary region 
mentioned previously paths divided categories interval paths non interval paths 
face crossing paths edge crawling paths interval paths 
shown non interval paths generated interval 
section explain paths created extending paths 
main body algorithm loop 
iteration candidate optimal path pmin qlist minimum cost extracted list 
point path discovered point distance decided claim path optimal path distance insert path opt qlist reached extract costly path qlist discovered point opt opt propagate function creates new intervals newly discovered point inserts qlist interval path associated intervals 
steiner point edge region incident edge create interval vertex edge incident neighboring steiner point insert path pnew qlist region incident edge create interval newly created interval split monotonic intervals delta delta delta monotonic interval add non interval path necessary add interval path newly discovered point function propagate creates candidate optimal paths propagating constant number ways inserts paths qlist 
propagate interval path associated valid point add second non interval path necessary add interval path edge crawling path segment edge point previous point path neighboring point path extends insert path pnew qlist explained previously paths propagated inside intervals 
observe task handling interval paths accomplished combination procedures propagate 
example intervals created procedure point discovered 
time interval path associated new interval inserted qlist line procedure 
propagation interval paths interval accomplished procedure propagate line 
generating non interval paths interval handled line propagate line 
interval generates non interval paths interval created line procedure interval path interval extracted qlist line procedure propagate 
situation generates non interval paths newly discovered point point edge case non interval path inserted qlist extends opt neighboring steiner point edge indicated line 
non interval paths edge crawling paths 
procedure propagate line line non interval path extracted qlist may insert extension path qlist 
suppose prev segment path edge crawling prev edge adjacent steiner point side prev insert path vv qlist path vv inserted qlist 
propagation non interval paths guarantees optimal path type missed algorithm 
steiner point non interval paths inserted qlist approaching left approaching right 
similarly vertex non interval paths connect edge incident number incident boundary edges original triangular de composition 
total number non interval paths bounded mn total number paths inserted qlist mn 
show algorithm correct sufficient prove theorem include proof full version theorem path extracted qlist discovered optimal path discrete graph complexity algorithm depends factors cost maintaining qlist mn log mn mn candidate optimal paths inserted qlist cost maintaining discovered point lists plist nm log cost maintaining interval lists ilist nm log 
complexity algorithm nm log nm 
section claimed average steiner point needs evaluate costs log adjacent edges inside region edges candidate optimal paths inserted qlist edges steiner point region evaluate costs additional edges order maintain intervals 
decide boundary new interval needs take binary search log steps 
step compare cost vv cost neighboring discovered points result log edges evaluated steiner point 
new interval created need divide monotonic intervals 
need compute local extrema region distance function points property pseudo euclidean region requires local extrema computed efficiently 
specified efficient computation needs 
splitting performed interval long cost computing local extrema cost splitting interval exceed log total cost splitting bounded nm log affect total complexity nm log nm 
noted need find values corresponding steiner points values closest local extrema 
weighted region flow region local extrema computed constant time 
full version show long constant degree polynomial function computing local extrema converted computing roots constant degree polynomial function local extrema computed log time 
preliminary experimental results section report preliminary experimental results produced java implementation algorithm 
compared algorithm dijkstra algorithm running experiments group artificially generated datasets algorithms 
experiments performed windows workstation mb memory mhz pentium iii processor 
simplicity uniform discretization edge equal number steiner points 
results experiments shown consistent complexity analysis 
interval slower small due high cost maintaining various complex data structures efficiency quickly evident increased 
number steiner points weighted problem interval dijkstra weighted problem number steiner points time milliseconds flow problem interval dijkstra flow problem fig 

experimental results 
maheshwari 
sack 
ffl approximation algorithm weighted shortest paths polyhedral surfaces 
lecture notes computer science 

maheshwari 
sack 
approximation algorithms geometric shortest path problems 
acm symposium theory computing 

maheshwari sack 
approximating weighted shortest paths polyhedral surfaces 
proceedings th international annual symposium computational geometry pages 
june 

mata mitchell 
new algorithm computing shortest paths weighted planar subdivisions 
proceedings th international annual symposium computational geometry pages 
june 

mitchell papadimitriou 
weighted region problem 
proceedings rd international annual symposium computational geometry pages 
june 

reif sun 
efficient approximation algorithm weighted region shortest path problem 
proceedings th workshop algorithmic foundations robotics mar 

reif sun 
movement planning presence flows 
lecture notes computer science 
