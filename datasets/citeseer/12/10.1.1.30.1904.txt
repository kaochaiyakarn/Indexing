effective calculus object query languages leonidas fegaras david maier department computer science engineering oregon graduate institute science technology walker road box portland email cse ogi edu define standard effectiveness database calculus relative query language 
effectiveness judges suitability serve processing framework query language comprises aspects coverage efficient evaluation 
monoid calculus argue effectiveness object oriented query languages exemplified oql odmg 
monoid calculus readily captures features multiple collection types aggregations arbitrary composition type constructors nested query expressions 
show extend monoid calculus deal vectors arrays expressive ways current query languages illustrate handle identity updates 
touted advantage relational data model existence formal calculus algebra model database queries 
practice formalisms fail model features commercial query languages sql grouping aggregation duplicate values sort orders name 
features handled ad hoc manner query processors 
gap widens moves objectoriented query languages oql odmg deal multiple bulk collection types arbitrary nesting type constructors methods embedded query expressions permitted collection may appear just clause 
features making way relational query languages 
seek effective formalism model object query languages represents constructs languages provides suitable framework query processing component dbms 
calculus appear acm sigmod international conference management data san jose california may 
monoid comprehensions believe meets needs 
effective calculus 
sizable body proposals database calculi algebras 
add pile 
answering question helps separate proposals purpose 
study issues computational complexity relative expressive power different language features :10.1.1.45.8055
proposed extend relational model handle extension duplicates aggregate computation nested structures temporal expressions path expressions 
interest finding query model provides adequate basis defining translating evaluating actual dbms query languages 
describe mean database calculus effective query language effectiveness aspects ffl coverage calculus sufficient expressive power represent language constructs want calculus serve initial internal representation queries extent cover query processor deal gap ad hoc basis 
addition initial translation target calculus give precise semantics query language 
having precise semantics precondition want demonstrate certain query transformations alter meaning query 
typical relational query formalisms fail cover features current commercial query languages 
ffl manipulable expressions lend easy manipulation programs purposes type checking lining views simplification determining interactions constraints triggers translation query plans 
ffl evaluable mean just means evaluate expression database wide space alternative query plans accessible calculus expression 
typically imagine calculus expression translated companion logical algebra algebra automatically transformed equivalent expressions algebra expressions rendered terms specific physical operators evaluation code 
note query formalism expresses queries low level abstraction barrier efficient evaluation 
example model required nesting combination orders iterators explicitly listed obscure high level intent query 
requirements met basis choose alternative calculi language 
languages interested uniformity prime consideration 
object query languages typically deal different collections types sets bags lists arrays 
query model exploits similarities types permits operated uniform ways aid optimization process cutting number different transformation rules techniques needed deal repertoire operators 
form uniformity query model integrate operations database structures general computation 
object databases provide powerful behavioral encapsulation methods prohibit method invocation queries permit switch optimization queries methods 
claim query model monoid comprehensions meets requirements effective calculus real object query languages exhibits uniformity current proposals 
case study odmg support claims useful focus particular object query language 
chosen concentrate oql language odmg standard proposal closely resembles query language oodbms 
chose oql main reasons 
essentially oodb companies committed supporting oql interface systems near term 
second small language easier comprehend contains language features showing object query languages proposed relational extensions sql 
features include multiple collection types arbitrary nesting type constructors method invocation complex object state path expressions object identity subqueries arbitrary points query expressions subtype hierarchy 
able handle oql believe widely applicable query languages 
contribution calculus monoids general template data type capture collection aggregate operators currently relational object oriented databases 
monoid comprehensions similar set notation applicable types sets give uniform way express queries simultaneously deal collection type naturally compose way mirrors allowable query nesting oql 
comprehension expressions permit easy integration functional subexpressions 
demonstrate coverage showing map major features oql monoid calculus 
order expressions easier operate formalism type constructors independent similarly approach dewitt providing indivisible combinations constructors nested relational models 
give evidence exhibiting simple normalization system putting expressions canonical form maximizes opportunities pipelining 
believe monoid calculus amenable efficient evaluation 
sketch translation logical algebra companion presents framework mapping physical operators 
monoid comprehension calculus proposals object oriented database languages including oql support multiple collection types sets bags lists arrays 
approaches define language syntax frequently fail provide concrete semantics 
example join list set meaningful 
result type join 
generally precise semantics queries multiple collection types 
answer questions need form theory generalizes collection types operations natural way 
theory capture differences collection types way inconsistencies introduced importantly similarities 
abstracting common semantic features derive framework treats collections uniformly simple extensible language 
primary focus framework bulk manipulation collection types 
bulk operations source expressiveness basis efficient execution 
consider lists sets 
semantic properties lists different sets 
intuitively may exchange elements set insert set element twice set changing set 
properties hold lists 
formalize observations need see sets lists constructed impose properties set list constructors 
way constructing sets union number singleton set elements constructs set 
similarly way constructing lists append singleton list elements constructs list list append function :10.1.1.45.8055:10.1.1.45.8055
associative operations commutative idempotent 
commutativity idempotence properties sets different lists 
similarities set list constructors identity 
empty set fg identity empty list identity 
terminology algebra say set fg list monoids particular set fg commutative idempotent monoid 
primitive types integers booleans represented monoids possibly choice monoid 
example int int integer monoids bool false bool true boolean monoids 
call monoids collection types collection monoids monoids primitive types primitive monoids 
collection monoid unit function takes element type input constructs singleton value collection type 
example list unit function takes element constructs singleton list 
list generated list monoid primitives empty list list unit function list append 
types represented monoids query framework map monoids particular monoid 
maps called monoid homomorphisms 
example monoid homomorphism lists sets framework captured operation form hom list set list function takes element returns set 
basically monoid homomorphism performs computation result fg foreach result result return result words hom list set replaces fg singleton list 
list generated delta delta delta result set delta delta delta 
monoid homomorphism captures conquer computation list divided lists case operation hom list set equal hom list set hom list set 
unfortunately monoid homomorphisms formed 
example sets converted lists introduce nondeterminism 
sets converted sorted lists 
semantic restriction purely syntactic framework depends static properties monoids involved homomorphism commutativity idempotence properties 
monoid homomorphism form bulk manipulation collection types supported algebra 
demonstrate monoid homomorphisms expressive 
fact small subset functions monoid homomorphisms sets sets captures precisely nested relational algebra equivalent set extension operator ext shown capture nested relational algebra 
monoid homomorphisms go capture operations multiple collection types join list bag returns set plus predicates aggregates 
example existential predicate set monoid homomorphism set monoid monoid bool false aggregation summing elements list monoid homomorphism list monoid monoid int 
define new calculus algebra called monoid comprehension calculus captures operations involving multiple collection types declarative form 
monoid comprehensions defined terms monoid homomorphisms monoid homomorphism expressed terms monoid comprehension 
programs expressed calculus far easier understand manipulate equivalent algebraic forms 
way monoid comprehensions resemble tuple relational calculus query variables may range multiple collection types output comprehension may different collection type 
example monoid comprehension setf ff gg joins list bag ff gg returns set set comprehension tagged word set example monoid type zero unit merge list list ff set set ff fg fag ci bag bag ff list ff delta string list char concat sorted list ff merge ci table examples collection monoids monoid type zero unit merge sum int prod int max int max ci bool false ci bool true ci table examples primitive monoids sum monoid int :10.1.1.45.8055
expression returns sum list elements greater equal 
rest section gives formal definition monoids monoid operations 
formal framework definition monoid triple zero merge monoid type merge type theta associative identity zero merge zero merge zero 
addition monoid zero merge may commutative monoid merge commutative idempotent monoid merge 
example sum int commutative monoid set set ff fg commutative idempotent monoid 
definition collection monoid ff type determined type parameter ff type constructor ff zero merge monoid 
quadruple ff zero unit merge unit function type ff ff collection monoid 
defining operations involve multiple monoids 
necessary distinguish components particular monoid qualify zero unit merge table presents examples collection monoids 
column indicates monoid commutative idempotent monoid 
monoids list bag set capture known collection types linear lists bags sets additive union bags 
monoid captures lists duplicates 
operator delta defined follows delta gamma gamma list elements delta :10.1.1.45.8055
monoid string captures character strings 
monoid sorted parameterized function range associated partial order merge function monoid merges sorted lists sorted list 
appears sorted list 
monoid chosen idempotent duplicates removed isomorphic set monoid 
shorthand mf represent construction monoid merge unit merge unit gamma unit particular shorthands ffe ng fe ng setf definition primitive monoid quadruple zero unit merge zero merge monoid unit identity function unit primitive monoid 
table presents examples primitive monoids 
note instances primitive monoid generated monoid operations need values type generate new values 
define mapping monoids set fc ig iff commutative iff idempotent 
partial order monoid names defined example list bag set set bag commutative idempotent list commutative idempotent 
see representation partial order monoids 
define algebraic operator parameterized input output monoids 
definition monoid homomorphism homomorphism hom collection monoid ff zero unit merge monoid zero merge defined inductive equations hom zero zero hom unit hom merge merge hom hom ae ae ae ae 
ae ae ae ae 
ci set list 
bag sum restriction lattice homomorphisms basically expression hom replaces zero zero merge merge unit function type unit example list hom list set computes set delta delta delta 
condition definition important 
collection monoid commutative idempotent monoid 
example bag cardinality hom bag sum formed homomorphism set cardinality hom set sum commutative idempotent 
restriction see hom set sum fag hom set sum fag fag restriction prohibits conversion sets lists set list allows conversion sets sorted lists 
examples formed monoid homomorphisms image hom set set ff theta hom set set hom set set hom set filter hom set set fag fg length hom list sum image maps function elements set theta computes cartesian product sets filter selects elements set satisfy predicate 
queries calculus expressed terms monoid comprehensions 
informally monoid comprehension monoid takes form mf expression called head comprehension 
term term sequence called qualifier ffl generator form variable expression expression function ffl filter pred pred predicate 
formally monoid comprehensions defined terms monoid homomorphisms 
particular qualifiers comprehensions eliminated left right qualifier left definition monoid comprehension monoid comprehension primitive collection monoid defined inductive equations mf unit mf hom mf mf pred pred mf zero expression computes instance collection monoid monoid output specified explicitly collection monoid associated expression inferred 
details type inference process 
convention represent variable bindings comprehension mf mf expression substituted free occurrences substitute qualifiers assuming generator term terms form called bindings bind variable expression example setf equal setf note formed comprehension translated homomorphism set list ff gg generators monoid comprehension commutative idempotent monoid comprehension commutative idempotent monoid 
condition checked statically commutativity idempotence properties monoid specified explicitly monoid defined 
relational joins represented directly comprehensions 
join sets setf join predicate function constructs output set element elements example record construction comprehension setf rules definition comprehension translated algebraic form hom set set hom set set fh ig fg comprehensions join different collection types 
example setf ff gg equal example nest equal setf key setf nesting operator nested relations 
similarly unnest setf comprehension example dependent join value second collection depends value element relation dependent joins convenient way traversing nested collections 
examples filter setf flatten setf setf length sum count expression sum adds elements monoid sum :10.1.1.45.8055
expression count counts number occurrences bag count ff gg 
definition equations hom nf collection monoid hom nf primitive monoid conclude monoid homomorphisms expressed monoid comprehensions vice versa 
monoid comprehension calculus treatment queries consider types valid definition monoid type monoid type forms class name class primitive type type collection type record type type monoid types 
collection types freely nested 
oodb schema set potentially mutually recursive class definitions 
class definition takes form class class name type extent extent name type monoid type 
extent name optional collection set instances class 
ways accessing instances class class extent persistent variables part oodb schema 
example oodb schema language class person name string address string spouse person extent persons class hotel name string address string facilities set string employees set person rooms set bed int price int extent hotels class city name string hotels bag hotel places visit list name string address string extent cities var city city name portland city persistent variable 
definition monoid comprehension calculus monoid calculus consists syntactic forms variable constant projection record construction omega omega zero unit merge mf comprehension terms monoid calculus variable qualifiers form example valid expression calculus name hl hotels cities name portland hl bed rooms translating odmg oql monoid calculus main claims effectiveness monoid calculus gives better coverage language features real query languages 
nearly oql expressions direct translation monoid calculus exception indexed oql collections 
section monoid indexed collections comprehension syntax capture complex vector array operations 
illustrate translate main constructs oql monoid calculus 
select oql statement form select xn pred translated xn en pred note pred contain nested comprehension expressions supports capability oql nested queries select clauses 
example nested oql query select address hl select hotels cities name portland hl name hilton expressed comprehension syntax follows address hl hotels cities name portland hl name hilton select distinct oql statement translated set comprehension similar way 
example consider query previous oodb schema finds hotels portland interesting places visit select distinct name cities hotels places visit name portland name name query translated comprehension setf name db cities hotels places visit name portland name name oql group operator takes forms 
simplest form group operation partitions collection partition functions clause 
different combination values creates partition contains elements mapped values 
form translated setf en partition setf en en general form group partition bm um partition translated setf en partition bm um partition partition setf en en table gives translation oql expressions monoid calculus intersect gamma 
setf pred gamma 
pred exists pred gamma 
pred gamma 
count gamma 
sum gamma 
flatten gamma 
setf sort gamma 
sorted example example oql query finds hotels portland room beds select name hl select hotels cities name portland hl exists rooms bed query expressed comprehension syntax follows name hl hotels cities name portland hl bed rooms restriction monoid comprehensions relating idempotence commutativity monoids involved turns limitation translation 
oql select statements return sets bags explicit conversion function collections calculus allows 
mf zero gamma 
zero mf unit gamma 
mf mf merge gamma 
merge mf mf commutative gamma 
mf nf gamma 
mf mf pred gamma 
mf pred table normalization algorithm program normalization claim monoid calculus supports easy manipulation query expressions 
amenable pattern rewriting 
illustrate transformation monoid calculus implemented earlier version calculus 
monoid calculus put canonical form efficient rewrite algorithm called normalization algorithm 
evaluation canonical forms generally produces fewer intermediate data structures initial unnormalized programs 
normalization algorithm improves program performance cases 
generalizes optimization techniques relational algebra pushing selection join 
table gives normalization rules 
rule important flattens nested comprehension comprehension contains generator domain comprehension 
rule existential quantification 
cases query unnesting covered currently extending normalization algorithm 
advantage normalization algorithm algorithm calculus expressions expressed pattern rewrite shown correctly preserve meaning proving rewrite transformation correct 
proofs correctness rules table 
rules may require variable renaming avoid name conflicts 
generator generator variable renamed 
example filter filter setf setf setf setf renaming inner variable normalized setf setf rule definition filter predicate conjunction example normalization consider nested oql query select distinct select distinct expressed monoid calculus follows setf setf normalized setf setf setf setf rules definition 
consider query section finds hotels portland room beds name hl hotels cities name portland hl bed rooms query normalized name cities name portland hl hotels hl rooms bed name cities name portland hotels rooms bed rules definition 
normalization algorithm handling inefficiencies introduced new programming language constructs incorporated relational languages sql 
sql contains new proposed relational extensions user defined types multiple collections types routines triggers 
particular statement sql may introduce inefficiencies contains bindings large intermediate results 
example declare hs sql set hotel addr string select hotels hs cities name select address addr hs name return addr notice hs set hotels generated select statement second select statement 
query translated comprehension form follows setf addr hs setf hotels cities name addr setf address hs name normalize expression derive program materialize intermediate result 
path path name identifier bound variable identifier persistent variable name class extent expression path name name attribute name record path path 
generator domains comprehension contain non commutative merges list append domains normalized paths 
monoid comprehensions put canonical form 
assume predicates pushed comprehension forming conjunction pred predicates mf path pred path path 
proof statement easy domain generator monoid comprehension form path domain reduced simpler form normalization algorithm 
addition normalization rules important program transformations explore commutativity properties monoids 
particular commutative monoid join commutativity rule mf gamma 
mf holds term depend transformation valid monoid pushes selection join predicate depend mf gamma 
mf language extensions monoid calculus capable directly representing main features language oql fact capable expressing queries expressible oql 
example comprehensions yield values monoid type oql select statement yields sets bags 
see oql extended select statements return collections sets bags select list sort sorts projects preserving order 
examine monoid vectors basis extending expressiveness oql 
show handle identity updates calculus 
vectors arrays vectors arrays important collection types scientific applications 
contrast collection types obvious monoid captures vectors effectively 
vector operations provide random access indexing bulk manipulation 
propose effective form vector comprehensions describe monoid captures comprehensions 
example vector manipulation vector reverse computes gamma gamma gamma vector size function computed vec gamma gamma vec anticipated monoid vectors size 
note want access value associated index vector want impose order way accessed 
generator accesses pairs unspecified order elements set list retrieved comprehension generator constructed element vector comprehension gamma gamma means able store element position resulting vector 
vector elements accessed bulk fashion pairs value index values vectors constructed random fashion specifying value stored place 
problem different values stored place vector 
need perform merge operation vectors 
solution merge vector elements individually 
elements stored place vector resulting vector value computed merging elements 
solution considered choose values value zero choose 
way non zero value overwrites previous values 
formalize observations 
introduce new collection monoid monoid constant integer denote vectors size elements type monoid primitives unit function binary functional languages ary function considered unary applied tuple 
zero zero unit je gamma ae unit modn zero merge ja gamma jb gamma merge gamma gamma je gamma constructs vector elements 
zero element vector zeros unit takes values int constructs vector zeros th element set merge function uses merge merge input vectors element wise 
example zero sum unit sum merge sum note monoid freely generated case collection monoids 
operations depend operations 
ambiguity merge merging vectors merge example matrix sum matrices type mat sum merge mat merge sum merge sum 
examples vector manipulations 
comprehensions readable represent pair form 
sum subseq sum gamma permute sum concat sum fa sum subseq returns vector gamma permute returns vector mat sum mat type theta integer matrices examples matrix operations map transpose inner multiply transpose inner understand map notice resulting matrix formed merging values form unit mat unit sum zeros ij th element 
oql syntax map expressed select sum object identity database updates monoid calculus extended capture object identity 
introduce new type constructor obj ff represents objects states represented values type ff 
addition extend monoid calculus operations ffl new creates new object state ffl dereferences object returns state ffl changes state object returns true 
example valid object oriented comprehension new new creates list type list obj int containing new objects new new 
variable ranges list type obj int state incremented 
result computation list 
examples new new false new new true new true new setf new new example indicates different objects distinct second indicates objects equal states :10.1.1.50.9046
defined monoid higher order primitives captures object oriented computations state transformers 
state transformers propagate object heap contains bindings oids object states operations expression change response operation creates new object modifies existing object 
translation state transformers captures precisely semantics object identity need extending base model 
provides equational theory allows valid optimizations object oriented queries 
database updates captured extending definition comprehension qualifiers qualifier path destructively replaces value stored path qualifier path merges singleton path qualifier path deletes elements path equal example sql program inserts new hotel select cities name city name insert hotels values hotel name hotel address set set set set hotel hotel program comprehension form setf setf db cities name city name hotels name hotel name address hotel address facilities fg employees fg rooms fg hotel related proposals object query algebras see example 
contrast algebra algebras support multiple bulk operators 
demonstrated get expressive power just operator monoid homomorphism 
supporting small number operators highly desirable bulk operations algebra supports transformation rules needs harder optimization task 
framework monoid homomorphisms introduced effective way capture database queries tannen 
form monoid homomorphism called structural recursion union presentation expressive 
operations form require validation associativity commutativity idempotence properties monoid associated output operation 
properties hard check compiler operation impractical 
recognized special cases conditions automatically satisfied ext operation equivalent hom monoid 
view expressive inconsistent programs detected form 
operator capture non polynomial operations powerset complicate query optimization 
fact knowledge normalization algorithm forms general forms put canonical form 
hand ext expressive capture operations involve different collection types express predicates aggregates 
believe monoid homomorphism algebra expressive subset inconsistencies detected compile time importantly programs put canonical form 
monad comprehensions introduced wadler generalization list comprehensions exist functional languages 
monoid comprehensions related monad comprehensions considerably expressive 
particular monoid comprehensions mix inputs different collection types may return output different type 
possible monad comprehensions restrict inputs output comprehension type 
monad comprehensions proposed convenient practical database language trinder algebraic transformations forms methods converting comprehensions joins 
monad comprehension syntax adopted buneman alternative syntax monoid homomorphisms 
comprehension syntax capturing operations involve collections type structural recursion expressing rest operations converting collection type predicates aggregates 
normalization algorithm highly influenced wong normalization monad comprehensions 
powerful rules flattening nested comprehensions canonical comprehensions generators simple paths 
canonical forms equivalent canonical forms monoid homomorphisms 
believe monoid calculus provides effective framework processing object oriented query languages oql 
significant area coverage left deal method invocation initial studies indicate insurmountable problems 
turn monoid calculus improve query languages 
area ensuring languages oql wellfounded semantics 
put features languages match expressive capabilities monoid calculus selects return lists comprehensive manipulations arrays 
authors grateful len shapiro bennet vance helpful comments 
supported advanced research projects agency arpa order number monitored army research laboratory contract nsf iri 
abiteboul beeri :10.1.1.45.8055
power languages manipulation complex objects 
international workshop theory applications nested relations complex objects darmstadt 
beech 
collections objects sql 
vldb pp 
beeri 
algebraic optimization object oriented query languages 
international conference database theory paris france pp 
springer verlag december 
lncs 
breazu tannen buneman naqvi 
structural recursion query language 
proceedings third international workshop database programming languages pp 
august 
breazu tannen buneman wong 
naturally embedded query languages 
th international conference database theory berlin germany pp 
springer verlag october 
lncs 
breazu tannen subrahmanyam 
logical computational aspects programming sets bags lists 
th international colloquium automata languages programming madrid spain pp july 
lncs 
buneman 
fast fourier transform database query 
technical report university pennsylvania march 
ms cis 
buneman libkin suciu tannen wong 
comprehension syntax 
sigmod record march 
cattell 
object database standard odmg 
morgan kaufmann 
chan trinder 
object comprehensions query notation object oriented databases 
twelfth british conference databases pp july 
lncs 
cluet delobel 
general framework optimization object oriented queries 
sigmod pp 
dadam dbms prototype support extended nf relations integrated view flat tables hierarchies 
sigmod pp 
valduriez 
fad data intensive applications 
transactions knowledge data engineering february 
dayal goodman katz 
extended relational algebra control duplicate elimination 
pods pp 
deux story 
transactions knowledge data engineering march 
fegaras 
uniform calculus collection types 
oregon graduate institute technical report 
available anonymous ftp cse ogi edu pub ps fegaras maier 
algebraic framework physical oodb design 
available anonymous ftp cse ogi edu pub oodb design ps gadia 
homogeneous relational model query languages temporal databases 
transactions database systems december 
immerman stemple 
expressiveness family finite set languages 
pods pp 
kemper moerkotte 
advanced query processing object bases access support relations 
vldb pp 
leung mitchell subramanian vance zdonik 
aqua data model algebra 
fourth international workshop database programming languages manhattan new york city pp august 
maier vance 
call order 
pods pp 
ohori 
representing object identity pure functional language 
international conference database theory paris france pp 
springerverlag december 
lncs 
ozsoyoglu ozsoyoglu matos 
extending relational algebra relational calculus set valued attributes aggregate functions 
acm transactions database systems december 

database language sets lists tables 
information systems 
trinder 
comprehensions query notation 
proceedings third international workshop database programming languages pp august 
trinder wadler 
improving list comprehension database queries 
proceedings bombay india pp november 
dewitt 
algebraic support complex objects arrays identity inheritance 
sigmod pp 
wadler 
comprehending monads 
proceedings acm symposium lisp functional programming nice france pp june 
wong 
normal forms conservative properties query languages collection types 
pods pp 

