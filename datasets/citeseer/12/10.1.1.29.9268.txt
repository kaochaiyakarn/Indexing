system description abstraction verification uniform treatment quality quantity michael huth department computing information sciences kansas state university manhattan ks usa huth cis ksu edu ph fax www cis ksu edu huth april build established modal transition systems probabilistic specifications sketch framework system descriptions abstraction finite state model checking uniform presentation various levels qualitative quantitative views mediating abstraction concretization maps 
choose labeled kripke structures modal transition systems interval transition systems possible views interpret models modal probabilistic way 
prove safety results abstractions views forall fragment modal mu calculus show allow compositional reasoning respect process algebra la ccs 
modal refinement shown sound model checks variety probabilistic semantics 
view interval transition systems seen provide foundation model checking systems descriptions evidence endowing intervals predicates guarantees respectively possibilities 
motivation process algebras milner ccs mil guarded command languages mcmillan smv mcm description languages computer systems 
operational meaning descriptions typically captured triple set states state transition relation contains information atomic system descriptions usually trivial event setting 
syntactic constraints regularity mil abstraction techniques cgl may ensure set states finite :10.1.1.116.9247
analysis descriptions done variety ways 
model checking particular analysis advantages automatic computationally inexpensive invented clarke emerson ce sifakis qs 
idea finite state system specification oe temporal logic efficient algorithm deciding oe holds initial states due exponential blow state set number parallel components requires abstraction techniques data control flow paths order bring smaller size cgl cgl 
needs certain positive model check oe abstracted system means original system satisfies specification oe 
methodology documented host established literature simulations refinements corresponding safety results model checks abstracted systems see cgl :10.1.1.116.9247
triad system description abstraction verification formalism established successful qualitative system design analysis transfer quantitative system descriptions large problematic 
implementation side symbolic techniques binary decision diagrams bry don perform nearly real number versions purely binary case 
challenge finding similar symbolic techniques real number manipulation 
conceptual side moving qualitative quantitative view system ordinarily change description language notion abstraction verification engine completely notable exception see hil 
changes necessitates knowledge sophisticated computationally expensive concepts measure theory hal probabilistic bisimulation bai hard embed qualitative description quantitative view interpret quantitative results qualitative judgments 
ideally uniform family triads mediating maps dimensions description abstraction verification 
author aware previous closely fit envisioned framework 
modal transition systems larsen thomsen lt lar provides nice point departure 
systems ordinary labeled kripke structures finite state model checking expect transitions guaranteed refinements possible refinement may remove 
modal process logic modal hennessy milner logic semantics lt lar basis triad sense 
modal transition systems enriches binary qualitative view modal valued view transitions flexible notion refinement 
small step replace full quantitative view transitions refinement 
jl jonsson larsen consider models transitions annotated sets probabilities 
important case study models sets closed intervals 
description formalism studies various notions refinement quite hard establish 
conceptually models interesting commit reactive generative probabilistic right away 
interpretations enter chosen notion refinement total refinements implementations exhibit desired properties 
aim uniform way describing abstracting analyzing systems different points view ordinary labeled kripke structures modal transition systems lt lar lsw interval transition systems special case probabilistic specifications jl 
models transitions form chief interpretation transitions greatest lower bound guar transition occur dually expresses upper bound possibility system move 
constitutes significant shift usual way describing probabilistic information systems 
modeling probabilistic systems debatable really justifies exact probabilities assigned actions states 
specifying lower upper bounds numbers realistic motivates consideration closed intervals 
safety results refinements secure validity specification concrete system actual probabilities provided refines interval transition system consideration 
approach fits nicely techniques philosophy domain theory aj sco approximates total information exact evidence partial information closed intervals evidence 
example esc esc methodology domain closed intervals semantics functional programming language extended data type real numbers 
exploit fact interval transition systems multiple interpretations presenting triads connections class models modal probabilistic mixed 
section formally define classes models 
uniform specification logic modal mu calculus semantics classes section 
mediating abstraction concretization maps classes models topic section allow compare semantics views 
abstractions classes models safety results model checking covered section 
probabilistic view interval transition systems topic section prove modal refinement interval transition systems sound respect variety probabilistic semantics 
significant refinement notion inductive definition easier establish probabilistic counterparts jl 
family process algebras uniformly defined classes section 
discuss extend abstractions compositional respect process algebra operators section 
section concludes pointing 
models kripke modal interval transition systems advantageous associate class models base domain truth values 
definition domain kripke element lattice fff ttg 
domain modal element lattice ff ttg dk dk don know element elements maximal 
interval domain interval moo sco collection closed intervals ordered reverse containment iff write pr function 
pr 
sequel write denote domains define predicates set iff equals tt iff equal ff 
set iff iff domain continuous filtered infima directed suprema 
map box box def upper adjoint pr 
dually map diamond op diamond lower adjoint pr op labeled kripke structures see bra models set states act set actions events theta act theta state transition theta ap labeling function 
set ap contains atomic assertions system states 
note conventionally write tt ff usually type ap isomorphic theta ap modal transition systems lt lar models types theta act theta theta ap lt lar writes tt ff dk tt 
notion interval transition system special case probabilistic specifications jl fact allow act non trivial 
definition interval transition system triple theta act theta theta ap convention write 
write indicate model type labeled kripke structure modal transition system interval transition system 
modal intuition system state perform action reach resulting state greatest lower bound guarantee upper bound possibility jl shows model unreliable medium 
observe notion interval transition system commit particular kind interpretation 
numbers stand bounds proper probabilities 
fix notion processes reactive generative stratified ones 
light interval transition systems may basis implementing fuzzy modal probabilistic processes 
particular industrial control architectures increasingly employ fuzzy inference systems applied theories evidence requiring fuzzy semantics verification specifications 
observe models allow labels states transitions 
way framework may customize state event formalisms letting act respectively trivial 
definition call finitely branching act set fs finite 
call finite finite 
working assumption models finitely branching results require restriction 
logic modal mu calculus standard version modal mu calculus koz general temporal logic specification language 
grammar may note part definition modal transition systems lt 
loc 
cit 
range restricted context sensitive means dk tt means dk syntax process logic 
manageable ambiguity removed representing models order encodes inclusion note definition matches usual definition concepts labeled kripke structures see bra modal transition systems lar 
full error deliver empty gamma ffl ffl interval transition system modeling unreliable medium jl 
oe false true oe oe oe oe oe hai oe oe oe oe ranges family propositional atoms ap set variables act bodies oe oe oe formally monotone 
logic known semantics labeled kripke structures see bra fixed points variables semantics modal transition systems implicitly lar modal interpretation milner logic obtain characterization notion refinement 
natural semantics models type hk base domain unit interval hut base domain models labeled markov chains section 
novel continuous version semantics modal transition systems quantitative setting 
define semantics uniformly point salient differences 
meaning oe generally function type space functions ae map variables elements definition define false constant type value ff ff respectively 
similarly true type value tt tt respectively 
set false ae def false true ae def true ae def ae def ae ae def ae 
define negation operator swaps truth values extend dk def dk 
set def gamma gamma 
meaning oe computed pointwise oe ae def oe ae 
define type theta pointwise infimum extend unique commutative function satisfying dk ff def ff dk def dk tt dk modal semantics conjunction def min min meaning oe oe computed pointwise oe oe ae def oe ae oe ae 
meaning obvious dual def 
write applications associative commutative operations elements 
definition def true def false primary guideline defining modal semantics oe ae specify greatest lower bound guarantee oe oe tt hold upper bound possibility 
view system labeled kripke structure oe oe serves conservative measure guaranteed evidence oe 
maximality minimality valid respect system refinements 
sense measure guarantee respectively possibility oe conservatively 
modal quantitative semantics justified follows 
suppose meaning oe meaning state min certainly lower bound guarantee oe 
greater bound greater loss generality lower bound guarantee oe hold contradicting assumption greatest lower bound guarantee 
conclude min greatest lower bound guarantee oe 
justification upper bound possibility min completely dual 
course view striking contrast probabilistic stance discussed section 
fixed notion negation infer modal quantitative semantics derived notion 
implication max max max gamma max gamma modal quantitative semantics similar justifications primary semantic guideline 
worth noting fuzzy logic considers norms monotone associative commutative symmetric maps theta 
elementary show min maximal norm respect pointwise natural ordering 
employ greatest norm component modal quantitative semantics norms norms replaced condition 
dually max minimal norm serves modal quantitative semantics proposition operations preserve directed suprema 
particular monotone 
proof illustrate case directed family supremum equals easily verified 
fixed min min min min min preserves directed suprema filtered infima 
proof 
definition define hai type 
follows assuming argument hai def ff def ff define motivate hai 
meaning hai oe hai oe ae meaning oe oe ae meaning hai usual labeled kripke structures 
meaning hai lt conservative extension meaning mimics semantics considering guaranteed transitions hai possible ones particular meaning hai different define modal quantitative semantics hai primary semantic guideline semantic value oe expresses greatest lower bound guarantee oe holds upper bound possibility 
maximality minimality express valid assessments refinements implementations view total refinements 
recalling intended meaning semantic value refines meaning order greatest lower bound guarantee upper bound possibility greater 
defined refinement notion modal view interval transition systems see section derive semantics branching modalities idea adversaries 
concepts typically concurrent markov chains similar models resolve reactive choices concurrent system resulting structure labeled markov chain analyzed classical probabilistic methods see han 
adversaries refinements implementations 
depending polarity interval boundaries modality reason behavior refinements respectively refinement 
write hai def fx delta pr system may choose transitions maximizes delta pr 
range transitions pr assumed greatest lower bound guarantee hold greatest lower bound guarantees guarantee hai increase implementation 
greatest lower bound guarantee hai dually set def fy delta pr upper bound possibilities pr assumed upper bound possibility hold upper bound possibility hai maximal delta pr transition possible 
changing transitions transitions ensure bound improved turning possible transitions guaranteed ones refinement 
note implies 
reason bounds possible states 
necessitates swap modalities transitions 
write def fx delta pr system move possible lower bound guarantee minimal delta pr 
change required ensure estimate conservative refinements refinements may turn transitions transitions 
dually set def fy delta pr upper bound possibilities upper bound possibility minimal delta pr transition guaranteed 
changing transitions transitions ensure bound conservative possible refinements 
note implies 
observed meaning hai generally different meaning models type equals hai gamma delta gamma pr gamma delta gamma pr observe pr pr hai 
justification fixed point semantics oe ae unfold recursive meaning initial values state guarantees possibilities 
process unfolding accumulate evidence guarantee oe decreases possibility 
process stabilizes established best evidence find knowing particular implementation 
interpretations monotone bi complete base domain assuming formal monotonicity fixed points define semantics delta unique compositional fixed point semantics induced interpretations hut complete lattice 
case define oe oe oe result replacing free occurrences oe sensible thing negation swaps guarantee possibility assertions specified property 
important keep mind semantics models type intuitionistic branching modalities 
optimizations performed formulas preserve intended meaning 
translation greatest fixed points fixed points negation renders standard semantics 
fixed point oe ae iterating monotone meaning transformation 
oe ae 
type 
constant function 
false proposition semantics oe operations preserve directed suprema 
particular approximation fixed points reaches meaning level 
proof known see bra 
remains show branching modalities 
provide proof illustration essentially follows fact lattice ghk scalar multiplication preserves filtered infima directed suprema 
hai set def hai def hai fx delta pr fx delta pr pr monotone 
similarly fy delta pr fy delta pr follows pr op monotone 
hai hai shows hai monotone 
directed family suffices show def hai hai def 
scalar multiplication pr preserve directed suprema general associativity suprema get fx delta pr delta pr equal pr op preserves directed suprema continuity op ensures op theta op op preserves directed suprema pr hai pr hai fy delta pr delta pr fy delta pr note fact model finitely branching 
monotonicity argued similarly previous case 
continuity set def hai def hai proof dual previous case requires continuity secure theta preserves directed suprema equality established general associativity fact scalar multiplication preserves filtered infima pr preserves directed suprema 
proof 
semantics continuous meaning functions continuous models type small numerical changes actual values changes model checking results depend continuously changes stable deadlock ffl gamma ffl state system possible deadlock ffl 
model 
contrast approaches specification logic quantitative thresholds syntax semantics returns truth values see han 
illustrate modal semantics interval transition systems indirect way computing greatest fixed points state model act fg 
compute meaning stable hi corresponds ctl formula stable 
stable models type iff exists computation path stable holds states path ce 
convert formula negation fixed point stable hi yielding stable hi 
defined semantics satisfy laws may change formula stable hi note change stable branching modalities intuitionistic semantics 
compute meaning iterating constant function maps states recursive body 
way obtain stable hi stable equals stable gamma ffl delta delta 
clearly deadlock 
stable computes gamma ffl delta gamma delta gamma 
deadlock reached fixed point 
meaning stable state stable guarantee possible 
meaning stable state deadlock possibility guarantee abstraction results theorem page shows stable false states system viewed labeled kripke structure 
instructive consider happens attempted compute greatest fixed point iterating recursive body constant function tt reader may check pr stable gamma ffl pr stable sequence stable descending second example computes meaning ctl formula af deadlock computation paths eventually reach deadlock state written deadlock modal 
computing approximating functions get stable min gamma ffl delta delta min delta 
clearly deadlock 
stable stable min gamma ffl delta delta min delta 
meaning af deadlock state stable guarantee possibility 
state deadlock meaning 
mapping results correspond results respective concrete version system 
topic section 
abstractions views mean study meaning oe ae invariant various notions refinement class models time example model checks indicated interested seeing semantic insights transfer abstraction concretization maps classes models 
require basic understanding natural embeddings corresponding 
relating embed ff defined ff tt def tt ff ff def dk 
note sensible monotone map type 
interpretation cc sense absent transitions may possible 
dually map type system descriptions concrete 
desired map ff type clearly satisfy ff ff ff ff tt tt 
note possibilities ff dk define tt abandon monotonicity ff need map ff tt 
acceptable set ff dk def ff 
ff lower adjoint ff realizing closure observe ff upper adjoint preserve infima 
non monotone embedding ff def ff tt def tt 
straightforward extend maps models appropriate type 
specifically define ffm ff ffi ff ffi 
concretization map interesting contains dual view propositional information encoded transition capabilities expressed 
concrete view conservative dk interpreted ff 
dually consider dk real state transition concrete system 
corresponding concretization map ff tr defined preserve tt ff maps dk tt 
definition set ff def ff tr ffi ff ffi 
map ff tr preserves preserves reflects ff preserves ff preserves reflects preserves 
clearly ff ffi ff just fl ffi ff id fl ff ff tr conversely ff ffi ff refines original system see proposition page 
map ff tr bearing mediating semantics branching modalities hai map ff convert model checking results model checking results need record interacts interpretations propositional logic operators lemma interpretations negation conjunction disjunction observe 
ff ffi ffi ff theta ff 
ff ffi ffi ff theta ff 
ff ffi ffi ff theta ff 
proof ff ffi ff id interpretations propositional logic operations extensions need check cases argument dk 
illustration ff dk ff dk ff tt ff ff dk ff dk ff ff dk ff ff ff ff dk ff ff 
proof 
theorem oe negation free formula modal mu calculus 
models environments ff oe mm ae oe ff mk ff ae ff oe ae oe ffm proof prove nested induction structure oe fixed point depth 
show implies 
ff oe ffm oe ff ffm ff oe ae ff ffi ff identity models environments type oe ffm ff ffi ff oe ffm ff oe ae id ff ffi ff proof item 
oe true get actual equality ff true ae tt ff tt true ff ff ae 
oe false ff ff ff similar way 

oe follows labeling function ff defined ff ffi 
oe note ff ae just composition ff ffi ae 

oe oe oe follows induction oe oe appealing lemma fact ff monotone 

disjunction third part lemma 

oe hai lemma compute ff hai ae equals fff ae ff tr preserves induction conclude equal ff ff ae ff tr ffi just hai ff ff ae 
dually oe lemma compute ff ae equals fff ae ff tr preserves may induction conclude equal ff ff ae ff tr ffi just ff ff ae 
fixed points recursion body smaller fixed point nesting may induction hypothesis transfinite approximations fact ff preserves suprema lower adjoint 
proof 
note models type formulas false equivalent models type dk ff 
mapping ff gives result 
may tempted item lemma strengthen proposition formulas modal mu calculus monotone map 
theorem says affirmative model checks remain affirmative model ff oe ae tt ff oe ae oe ff ff ae implies oe ff ff ae equals tt 
result lifted coincides result lifted system 
difference models negation free formulas liberal notion refinement lt relationship model checks type corresponding notions refinement studied section 
relating meaning transition guaranteed 
interval transition system may code similarly means transition possible guaranteed may code meaning impossible represent suggests define fi fi dk def fi ff def fi tt def 
choosing map type principal choices 
map fi upper adjoint fi realizing projection kernel fi def ff fi def tt fi def dk 
note function invariant negation ffi fi fi ffi remaining canonical choices pessimist fi pes optimist fi opt agree fi arguments 
pessimist fi pes def dk fi pes def ff perceives intervals image fi false soon upper bound possibility outside image fi gets status dk possibility constraints guarantees 
optimist fi opt def dk fi opt def ff dual view 
duality formalized lemma ffi fi pes fi opt ffi ffi fi opt fi pes ffi lt identifies tt context require uncountable domain additional technically unpleasant consequences 
proof second equation follows inverses respective domain 
equation shown analysis patterns definition noting swaps ff tt leaves dk invariant 
proof 
fi mapping model checks type formulas range full modal mu calculus 
concretization transitions fi tr defined fi tr def tt dk ff 
transitions positive guarantees turn modal guarantees transitions positive possibilities guarantees turn possible transitions transitions turn absent transitions 
map needs translate qualifiers semantics modal operators adequately 
map fi hand needs interface propositional logic operators 
map fi tr preserves reflects 
map fi preserves 
definition define fi fi tr ffi fi ffi 
lemma models 
fi ffi ffi fi 
fi fi fi 
fi fi fi 
proof 
fi tt iff iff gamma iff iff fi ff iff fi tt 
fi ff iff iff gamma iff iff fi tt iff fi ff 
fi dk iff gamma gamma satisfies gamma gamma iff iff iff fi dk iff fi dk 

need argue cases fi dk iff fi min min dk iff min min iff min fi fi dk dk dk 
ii 
fi fi dk tt dk 
iii 
symmetric previous case 
fi tt iff fi min min tt iff min iff iff fi fi tt iff fi fi tt 
fi ff iff fi min min ff iff min iff iff fi fi contains ff iff fi fi ff 

item follows previous meaning dual meaning proof 
show modal semantics sound respect semantics modal transition systems compute conflicting truth values proper truth value concrete modal transition system computes dk 
proposition 
fi oe mi ae oe fi mm fi ae formulas oe modal mu calculus 

oe ae fi oe mm formulas oe modal mu calculus 
proof show item 
follows item 
fi oe oe fi fi oe mm ae item may apply monotone map fi sides noting id fi ffi fi proof item 
true follows fi true true 
false follows fi false false 
follows fi defined fi ffi 
clear fi ae just fi ffi ae 

oe holds fi ffi equals ffi fi lemma maps monotone 

oe oe follows fact fi ffi ffi fi theta fi lemma maps monotone 

oe oe holds lemma 

hai oe write hai oe ae fx delta pr oe ae fy delta pr oe ae 
fi equals dk show dk element fi equals ff 
fi tr ffi implies definition fi tr delta pr oe ae entails pr oe ae 
oe ae 
induction ff fi fi oe ae oe fi fi ae oe fi fi ae ff follows considered transition fi conclude hai oe fi fi ae ff 
fi equals tt 
exists delta pr oe ae 
fi oe ae tt pr oe ae follows delta pr oe ae 
fi tr preserves obtain fi tr ffi 
induction tt fi fi oe ae oe fi fi ae oe fi fi ae tt follows fi transition satisfies oe conclude hai oe fi fi ae tt 

oe write oe ae fx delta pr oe ae fy delta pr oe ae 
fi equals dk show dk element 
fi equals ff 
exists oe ae 
pr oe ae implies fi oe ae ff 
fi tr preserves obtain fi tr ffi 
induction ff fi fi oe ae oe fi fi ae oe fi fi ae ff follows 
fi transition satisfy oe oe fi fi ae ff follows 
fi equals tt 
fi tr ffi proof contradiction assume oe fi fi ae ff 
induction fi oe ae oe fi fi ae oe ae fi oe ae tt 
pr oe ae 
fi tr ffi implies delta pr oe ae contradiction 

oe write ff approximative meaning oe mi ae level ff similarly write ff approximative meaning oe fi mm fi ae level ff 
show fi ffi ff ff ordinals ff 
ff clear constant bottom function fi preserves bottom 
ff induction ff induction oe infer fi ffi ff fi ffi oe mi ae 
ff fi ffi oe mi ae 
fi ffi ff oe fi mm fi ae 
fi ffi ff oe fi mm fi ae 
fi ffi fi ffi ff oe fi mm fi ae 
ff ff limit ordinal fi ffi ff ff ff 
adjointness renders ff fi ffi ff ff 
ff ff 
fi ffi ff fi preserves suprema lower adjoint fi equals fi ffi ff 
ff fi ffi adjointness obtain desired inequality ff ordinal models reached fixed point infer fi ffi oe ae oe fi fi ae 
proof 
related modal model checks models checks done transitivity relate model checks 
abstractions views possible refinements models uniformly 
key domains defined predicates 
definition model define functional fd theta theta theta set fd iff conditions met ref 
act 
ref 
act 
ref 
ap subsets satisfying fd called refinements 
proposition 
functional fd theta theta monotone 
may define vd greatest fixed point fd 
set delta def sg refinement 

refinements relational composition ffi 
relation vd preorder greatest refinement 

fq ig set refinements union refinement 

event model type greatest refinement milner strong bisimulation 
proof 
monotonicity immediate conditions ref ref monotone 

diagonal delta obviously satisfies delta fd delta 

fd 
ffi exists witness composition need show fd ffi 
ref 
fd infer existence 
similarly fd obtain 
transitive get 
ffi follows serves witness composition 
ref 
works symmetrically previous case 
ref 
fd get ap 
fd follows transitivity 
knaster tarski theorem vd equals union refinements 
items ensures vd reflexive transitive 

immediate implies 
event model type predicates coincide model truth presence transitions models equality transitions 
proof 
notion refinement modal transition systems lt states theta refinement implies ref 
transition possible possible act qt 
ref 
transition guaranteed guaranteed act qt 
write refinement 
instructive compare refinement notion refinement holds analyze transitions 
ref implies refines maximal matches exactly second condition ref refinement modal transition systems 
constraints enforced 
second analyze transitions 
ref implies refined 
half condition ref 

constraints enforced 
ref implies refined 
inequality ensures sharper constraint modal transition systems possible guaranteed transition refining state matched possible guaranteed transition refined state 
noted ordering ensured existing transition matching modality 
refinement notion simplified modal transition systems 
interval transition systems see systems jl fact refinements interval system simulation identifies state refined system state original system 
proposition refinement ff ffi ff proof ff ffi ff equals ff ffi ff tr ffi ff ffi ff ffi write state ff ffi ff immediate sg refinement sum systems 
condition ref follows fact ff reflects ff tr reflects ref follows ff ff tr preserve ref clearly met 
proof 
proposition 
entails 
iff particular entails 
iff particular entails 
fi predicate just equals 
proof immediate 
illustration holds iff gamma gamma holds iff gamma greater iff 
proof 
safety abstractions theorem ae oe formula modal mu calculus vd implies oe ae oe ae proof cases false true clear 
propositional atoms ref obtain ae ae cases follow immediately fact interpretations monotone 
key cases modalities exploit properties ref ref page fact respectively monotone 
fixed points follows semantics monotone recursion body 
illustrate reasoning modalities hai hai ae hai ae show 
ref obtain 
induction gives delta pr ae delta pr ae supremum terms equal supremum superset terms 

ref obtain 
induction gives delta pr ae delta pr ae supremum terms equal supremum superset terms 
ae ae show 
ref obtain 
induction gives delta pr ae delta pr ae infimum terms greater equal infimum superset terms 

ref obtain 
induction gives delta pr ae delta pr ae infimum terms greater equal infimum superset terms 
proof 
illustrate theorem compute hi deliver full deliver full unreliable medium hi deliver full gammaffl delta min delta ffl delta gamma ffl deliver full min gamma ffl delta delta delta 
empty deliver full ffl ffl empty deliver error full gamma ffl gamma ffl implementations unreliable medium ffl 
system left corresponding results hi deliver full deliver full 
note results computed unreliable medium 
system right get hi full max gamma ffl delta ffl delta max gamma ffl delta ffl delta gamma ffl gamma ffl hi full min gamma ffl delta ffl delta min gamma ffl delta ffl delta 
results computed unreliable medium 
probabilistic interpretation state transitions interval transition systems may read providing guarantees possibilities hold 
may think infimum respectively supremum actual probability shift meaning system quantitative aspects warrants probabilistic semantics reflects change view 
emphasize term probabilistic semantics informally exist probability spaces semantics entire modal mu calculus 
semantics probabilistic spirit model branching modalities expected values 
probabilistic semantics design decisions probabilistic reasoning interface interfere reactive capacity systems 
typically description languages contain operators probabilistic view 
section prefer retain modal process algebra ipa specifying interval transition systems express probabilistic view descriptions separate semantic interpretation 
probabilistic interpretation need greatest lower bound probability reactive capacity action triggered state dually require upper bound probability 
definition 
act define def fx def fy note sums finite finitely branching systems 
lemma 



proof item follows implies 
second argument argued properties ref ref similar show pr true ae pr true ae pr hai true ae pr hai true ae 
proof 
note numbers may greater 
example unreliable medium modeled number full gamma ffl gamma ffl full ffl greater 
probabilistic semantics ip change meanings modalities hai operators fixed points treated modal interpretation 
definition define probabilistic semantics branching modalities 
desired value hai ip define reactive capacity action state 
follows set def delta fx delta def min delta fy delta lemma 
implies see case defined 

follows evidence action possible state def 
equal guarantees action state view ill defined term delta fy delta maximal element 
define def probabilistic setting replace branching modes versus state expected value 
define meaning hai general probabilistic meaning different probabilistic meaning hai 
reconsider unreliable medium actions state full guarantee possibility interval gamma ffl ffl 
model contains implicit constraints probabilistic implementations 
example probability gamma ffl probability ffl 
interval transition systems resolved implemented probabilistic process replace likelihoods state full rules choice action state modeled probability distribution 
essentially probabilistic process satisfy model sense jl 
suggests call models probabilistically consistent probabilistic implementation sense jl 
modal interpretation systems sense system consideration contains probabilistic inconsistencies 
wit transitions state full hi true ip full delta delta delta min delta delta delta min 
example shows upper bound probability needs explicitly enforce result greater 
meaning dealt variety ways may computed conditional probabilities provided specification logic restricted fragment relevant sets computation paths measurable var 
second may conservative estimate probabilities 
approach investigated discussed section 
soundness modal refinement stress probabilistic refinement notions established jl quite sophisticated hard verify practice prove existence certain distribution function require automata theoretic subset constructions linear programming techniques explicit state space 
modal view advantage refinement notion formulated zigzag fashion known bisimulations mil 
corroborate showing probabilistic interpretations monotone refinements sound probabilistic semantics interprets hai expected value 
proposition suppose holds 
oe ip ae oe ip ae modal mu calculus formulas oe monotone semantics proof 
cases true false obvious 
case follows ref 

oe follows induction monotone 
maps ip ip assumed monotone remains consider modalities fixed points 

hai oe set hai oe ip ae hai oe ip ae lemma obtain 
definition get delta fx delta pr oe ip ae delta fy delta pr oe ip ae delta fu delta pr oe ip ae delta fv delta pr oe ip ae need show 
ref infer 
induction yield delta oe ae delta oe ae lemma follows induction summation monotone 
prove similarly 
ref exists 
induction renders delta oe ae delta oe ae lemma induction secure desired inequality 
lemma implies 

definition get 

fixed points works monotone recursive bodies 
proof 
mixed interpretations far explicitly defined meaning ip give possible definition mms hk 
general interval transition systems specialized total models reactive probabilistic processes meanings oe ip fixed states usually viewed actual probabilities possible restricted logics ltl var 
crucial measure theoretic identity guideline conservative estimates meaning conjunction 
example coded interval minimal maximal probability oe hold state corresponding interval oe state identity probability measures suggests conjunction events ought interval max gamma min 
knowledge possible probability space pointed may exist bounds assumed define ip def max gamma min ip defined ffi ip ffi get ip def max min note functions preserve filtered infima directed suprema 
lower bound part known lukasiewicz norm upper bound part lukasiewicz norm 
friction modal probabilistic interpretation models easy see ip ip modal interpretation informative propositional logic connectives 
hand summation done modalities hai ip clearly informative semantics hai respect information ordering hope directly compare semantics propositional modal connectives combined 
expected different interpretations quantitative system descriptions 
illustrate semantics transferring example checks page probabilistic semantics 
iterate constant function stable hi compute stable gamma ffl stable ffl 
stable ip hi ip stable hi ip stable ffl delta gamma ffl delta min gammaffl delta delta ffl delta min ffl gammaffl 
deadlock ip independent value easily seen equals meaning stable state stable meaning stable state deadlock results modal interpretation 
second example deadlock computes deadlock ip stable deadlock ip deadlock noting semantics identifies hi may define mixed semantics oe choose hai ip similar reasons semantics incomparable modal probabilistic interpretations 
description languages process algebras uniformly define process algebras dpa type focus fragment calculus la ccs mil nil jjp pdb fix act ranges set process variables act 
assume usual involution 
act act communication special symbol internal non observable actions 
give process terms uniform semantics structural operational way plo 
semantics interpretation addition relabeling operators leaves results intact 
act sum jjp jjp com jjp jjp com jjp jjp fd com pdb db res fix fix rec interpretation structural operational semantics process algebras process operators domain function dpa 
dpa maps unique judgment 
dpa def false function associates triple evidence transition 
prefix semantics false 
sums compute meanings 
meaning defined operational semantics sums typically non determinism sum system perform action components matter 
model setting def 
asynchronous parallel product compute meaning triple jjp jjp defined meaning system engage asynchronous action component extent component perform action isolation 
meaning triple jjp jjp symmetrically defined meaning 
meaning jjp jjp computed stages action due communication action motivating disjunction ranging act 
fixed act meaning successful communication conjunction meaning component able offer required action 
note sum ranges considers fix fix structural operational semantics lt modal process logic mpl lt stands 
meaning pdb computed computing meaning filtering 
recursion compute meaning fix meaning fix fixed point 
comments order defined function corresponds operational semantics corresponding ccs fragment mil note ff bisimilar nil derived notion 
proposition structural operational semantics process algebra terms matches semantics corresponding ccs fragment mil 
proof prove induction rank essentially merely sure interpretation gives expected logic usual operational semantics ccs 
illustrate rules communication 
rules immediately dealt induction 
third jjp jjp iff act 
induction case iff tt tt act 
equivalent fr tt defined jjp jjp 
proof 
defined function mpa matches semantics modal process logic lt corresponding fragment identify ff nil 
modal process logic mpl lt defined nil fix operational semantics 
definition define map 
mpl mpa homomorphic prefix set def dk def tt 
lemma map 
mpl mpa injective equality syntactic 
proof straightforward argument structural induction equals fact dk tt proof 
proposition mpl 

holds mpl iff mpa tt 

hold mpl iff mpa dk 

hold mpl iff mpa ff 
proof illustrate cases 

iff equals iff equals injective iff mpa dk dk rule sum iff mpa dk definition 


iff induction equivalent mpa tt mpa tt 
rule sum definition equivalent mpa tt 
definition means mpa tt 
iff induction equivalent mpa dk mpa dk mpa tt mpa tt 
rule sum definition respectively equivalent mpa dk 
defined 
remaining cases demonstrate interpretation reflects remaining operational rules modal process logic mpl 
proof 
example operational semantics ipa nil nil nil net result depends view modal probabilistic 
straightforward extend embeddings ff fi connecting process algebra terms 
example 
ff mpa congruence process operators prefix define ff def ff dually ff ff tr course may want show abstraction concretization maps relate domain values dpa expected way 
fact ff fi preserve semantics crucial 
uniform refinements compositional abstraction uniform presentation system descriptions insight concepts involved allows uniform ways specifying analyzing systems 
illustrate proving vd process algebra operators dpa monotone maps 
note dpa determines event model type set states process algebra terms state transition relation dpa record basic facts modalities interface semantics lemma 
iff 
iff 
iff 
iff 




proof clear model truth 
immediate definitions follows max max min min 
items modeling lower modeling upper set obvious 
proof 
fixed point operators dpa binding constructs standard notions free bound variables substitution 
term free variables called closed 
theorem act closed terms vd vd 
vd 
jjp vd jjq 
pdb vd proof operator dpa suffices show def vd subset fd 
event setting consider conditions ref ref 

fixed act def 
ref 
act dpa dpa dpa follows 
similarly derive dpa dpa dpa dpa follow vd 
ref 
act dpa dpa dpa follows 
similarly derive dpa dpa dpa dpa follow vd 

def jjp 
ref 
act jjp jjp jjp jjp implies 
vd exists vd 
jjq jjq jjp jjp jjq jjq 
case act jjp jjp handled symmetrically vd 
suppose jjp jjp 
jjp jjp equals fr means act holds lemma 
item lemma infer 
vd obtain vd 
lemma 
item lemma entails jjq jjq 
suffices show def jjq jjq jjp jjp def sequel write 
equals 
ff bottom case ref show ii 
satisfy may ignore terms equal ff 
equally dk bottom element show 
remaining possibility may ref construct iii 
deal cases 
equals reasoning item gives holds coordinate 
suffices show holds second coordinate 
order second dual ref construct element 
ref 
reasoning similar previous case chose omit 

def pdb 

ref 
act dpa pdb equals db pdb db 
follows 
vd vd 
db pdb db db 
ref 
reasoning act dpa similar omit 
proof 
order show abstractions monotone recursive process terms sums need adapt milner standard device bisimulation greatest bisimulation refinement vd 
definition call refinement vd iff fd vd ffi vd 
proposition 
refinement vd vd vd refinement 

refinement vd contained vd 
show vd suffices refinement vd proof 
need show vd vd fd vd vd 
vd vd exist vd vd show validity condition ref cases reasoned similar way 
vd implies vd fd vd vd imply existence vd vd 
similarly vd imply vd vd transitive infer vd vd 


previous item vd vd refinement contained greatest refinement vd delta contained vd vd transitive infer contained vd 
immediate technique 
proof 
definition process terms dpa sole free variable define vd iff closed process terms vd 
theorem process terms sums free variable vd fix vd fix proof proof follows structure milner proof event case def fix fix free refinement vd may choose proposition concludes proof 
conditions ref ref shown transfinite induction depth inference fix respectively fix case analysis proof 
sketched framework describing abstracting verifying systems uniformly varying qualitative quantitative views 
address logical characterizations various refinement relations 
mean investigate sense modal quantitative semantics models approximates truly probabilistic semantics fragment logic expressed probability measures computation paths 
order framework practically compelling tool need find ways representing decision instances oe symbolic terms explicit representation great interest see state framework smv mcm extended modal specification semantics interval transition systems presence simple fairness constraints 
fairly routine prove inequalities correspond equational theory ccs showing completeness may harder carry 
question smoothly framework extends weak simulation addition time 
aj abramsky jung 
domain theory 
abramsky gabbay maibaum editors handbook logic computer science volume pages 
clarendon press 
bai baier 
polynomial time algorithms testing probabilistic bisimulation simulation 
proceedings cav number lecture notes computer science pages 
springer verlag 
baier kwiatkowska norman 
computing probability lower upper bounds ltl formulae sequential concurrent markov chains 
technical report csr school computer science university birmingham uk may 
preliminary proceedings 
bra 
verifying temporal properties systems 
boston mass 
bry bryant 
graph algorithms boolean function manipulation 
ieee transactions computers 
cc cousot cousot 
interpretation unified lattice model static analysis programs 
proc 
th acm symp 
principles programming languages pages 
acm press 
ce clarke emerson 
synthesis synchronization skeletons branching time temporal logic 
kozen editor proc 
logic programs volume lncs 
springer verlag 
cgl clarke grumberg long :10.1.1.116.9247
model checking abstraction 
th annual acm sigplan sigact symposium principles programming languages pages 
acm press 
cgl clarke grumberg long :10.1.1.116.9247
model checking abstraction 
acm transactions programming languages systems september 
cleaveland iyer 
optimality abstractions model checking 
mycroft editor statis analysis volume lecture notes computer science pages 
springer verlag september 
glasgow united kingdom 
clarke wing formal methods state art directions 
acm computing surveys december 
esc 
pcf extended real numbers 
theoretical computer science july 
esc 
pcf extended real numbers 
phd thesis imperial science technology medicine november 
ghk gierz hofmann keimel lawson mislove scott 
compendium continuous lattices 
springer verlag 
hal 
measure theory 
van 
han hansson 
time probability formal design distributed systems 
elsevier 
hil 
compositional approach performance modelling 
cambridge university press 
distinguished dissertation series 
hk huth kwiatkowska 
quantitative analysis model checking 
annual ieee symposium logic computer science pages 
ieee computer society press june 
hut huth 
approximation denotational mu semantics 
applied categorical structures pages 
appear 
hut huth 
interval domain matchmaker actl 
mislove editor nd brazil joint workshop formal foundations software systems held tulane university new orleans louisiana november volume electronic notes theoretical computer science 
elsevier 
jl jonsson larsen 
specification refinement probabilistic processes 
proceedings international symposium logic computer science pages 
ieee computer society ieee computer society press july 
koz kozen 
results propositional mu calculus 
theoretical computer science 
lar larsen 
modal specifications 
sifakis editor automatic verification methods finite state systems number lecture notes computer science pages 
springer verlag june 
international workshop grenoble france 
lsw larsen steffen weise 
constraint oriented proof methodology modal transition systems 
proceedings st workshop tools algorithms construction analysis systems volume lecture notes computer science pages 
lt larsen thomsen 
modal process logic 
third annual symposium logic computer science pages 
ieee computer society press 
mcm mcmillan 
symbolic model checking 
kluwer academic publishers 
mil milner 
finite delay operator synchronous ccs 
technical report csr university edinburgh 
mil milner 
communication concurrency 
series computer science 
prentice hall international 
mms morgan mciver seidel 
probabilistic predicate transformers 
acm transactions programming languages systems may 
moo moore 
interval analysis 
prentice hall englewood cliffs 
plo plotkin 
structural approach operational semantics 
technical report daimi fn computer science department aarhus university september 
qs sifakis 
specification verification concurrent systems cesar 
proceedings fifth international symposium programming 
sco scott 
lattice theory data types semantics 
formal semantics programming languages pages 
prentice hall 
sco scott 
lectures mathematical theory computation 
monograph prg oxford university computing laboratory oxford 
var vardi 
automatic verification probabilistic concurrent finite state programs 
proc 
focs pages 
ieee 

