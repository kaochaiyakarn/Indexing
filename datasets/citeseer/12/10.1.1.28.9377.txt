consideration publication functional programming inductive graphs functional graph algorithms martin erwig oregon state university department computer science corvallis oregon usa mail erwig cs orst edu propose new style writing graph algorithms functional languages alternative view graphs inductively defined data types 
show graph model implemented efficiently demonstrate graph algorithms succinctly recursive function definitions inductive graph view 
regard contribution teaching algorithms data structures functional languages functional style graph algorithms imperative algorithms dominant today 
keywords graphs functional languages recursive graph algorithms teaching graph algorithms functional languages implement graph algorithm functional programming language 
seemingly simple question attracted attention quite long time different proposals 
course really difficult realize graph algorithms functional languages 
real challenge obtain clear efficient programs functional programs lose elegance simplicity asymptotic complexity imperative ones 
main difficulties arise dealing example depth search functional languages caused fact node reachable different edges algorithm requires visited 
traditional descriptions graph algorithms imperative languages behavior achieved simply marking node visited encountered time 
node reached checking mark prevents algorithm re processing possibly running infinite loop 
node marking strategy easily mimicked functional languages remember visited nodes data structure pass data structure function calls occur context algorithm 
martin erwig way local state node marks maintained algorithm 
approach bears problems regard efficiency clarity 
imperative setting marking node testing node mark performed constant time array functional set data structures generally meet time bound example balanced binary search trees set insertion membership test take log time denotes number elements set 
second threading data structures requires participating functions additional parameter passing state affects readability algorithms worse ease manipulating programs proving program properties key attribute functional programming 
solution problem monads thread arrays access function calls king launchbury king 
complicates function definitions making readable difficult understand forcing algorithms written imperative style 
answer problem uniqueness types offered example clean language barendsen smetsers rely automatic discovery single threadedness generate cases safe imperative code hudak bloss sastry 
despite facts uniqueness types widespread example standard ml haskell single threaded analysis discover cases approaches adhere imperative node marking view graph algorithms provide answer question functional style 
aspect teaching graph algorithms functional languages 
reader ask issue 
seen newsgroup discussions re appear regular intervals functional languages need defending demonstrating mainstream imperative object oriented languages 
proof usability programming language manifests applications written language certain degree available teaching materials language 
example textbooks convince programmers students language really usable 
explanations language needed programmers students able learn language programming style 
quite textbooks available introducing functional programming general particular functional languages general course algorithms data structures example lapalme 
really cogent saying functional languages true alternative imperative object oriented languages indispensable teaching material functional languages demonstrate functional languages just toys address standard topics algorithms data structures 
teaching material implement typical undergraduate curriculum completely functional language 
hand functional algorithm data structure textbooks available fatal impression conveyed implement real data structures resort 
inductive graphs functional graph algorithms believe leaves negative impression usability functional languages general 
functional data structure textbooks exist 
believe reason treatment graphs functional languages weak far 
goal twofold 
want demonstrate possible define graph algorithms distinctive functional style algorithms time competitive terms efficiency typical imperative implementations 
second giving collection algorithms typically courses algorithms data structures try close gap functional algorithms data structure textbooks 
section review related 
foundations functional graph algorithms laid section inductive graph view explained 
discuss implementation functional graphs 
section define graph algorithms recursive function definitions follow inductive graph structure 
section complete 
source code examples available part functional graph library obtained world wide web www cs orst edu erwig 
haskell notation 
extension employ active patterns provide special kind pattern matching explained section allows succinct description algorithms 
active patterns helpful essential versions algorithms defined 
related straightforward approach implementing graph algorithms functional languages proposed burton yang pass state graph algorithms function calls state represented functional array 
certainly standard way implementing imperative algorithm functional language 
burton yang show classical algorithms translated lazy functional language particular functional languages design algorithms 
contrast wise describe algorithms fixed points recursive equations essentially relies lazy evaluation 
algorithms quite complex difficult comprehend 
burton yang approach achieve asymptotic running time imperative algorithms 
kind combinator approach erwig identified classes graph algorithms introduced corresponding predefined operators 
graph algorithm realized selecting operator providing appropriate parameter functions data structures 
believe approach reflects structure graph algorithms 
previous martin erwig approaches potential formal program manipulation 
drawback combinator approach limited expressiveness 
proposal king launchbury concerned depth search focus generated data structure depth spanning forest underlying graph algorithm 
facilitates formal reasoning particular formal development algorithms depth search possible 
depth search function realized nicely generate prune manner 
monads implement state maintained search vertices visited achieve linear running time 
point approach stuck imperative programming style 
encapsulated restricted single point comes process program fusion transformations quite complex functions moved state transformers 
example see launchbury demonstrated phase fusion applied eliminate intermediate results algorithms 
king defines thesis algorithms depth search defined functions mainly implementations imperative algorithms 
fegaras sheard investigate generalization fold operations data types embedded functions 
motivating example show model graphs 
approach somewhat limited clear define example function reversing edges graph highly inefficient direct access node requires general traversal graph 
related gibbons considers definition graph fold operations algebraic framework 
deals acyclic graphs implementation discussed 
categorical definition fold operators data types proposed erwig 
approach decomposition adts controlled external values 
main application definition graph operations depth search contrast gibbon approach arbitrary graphs 
contrast monolithic view graphs dominating adopted functional approaches suggest view graphs inductively data type defined constructors lists trees 
view erwig focus define kinds graph fold operations identify laws program transformation 
implementation functional graphs provided 
erwig extended implementation ways compared different representation schemes performing benchmarks 
inductive graph view applications go realization functional graph algorithms 
example inductive graphs facilitated denotational semantics definition visual languages erwig 
application strong educational component purely functional description graph reduction erwig 
application currently investigating treatment graph grammars functional setting 
existing textbooks functional programming concentrate explaining fundamental programming language concepts 
certain extent inductive graphs functional graph algorithms data structures covered 
fact books contain examples list tree algorithms example bird ullman treat graphs 
books mention graphs superficially paulson 
dedicated data structure textbook lapalme 
degree book harrison 
books contain material graphs graph algorithms representations chosen known imperative world 
causes breach presentation distinctive clear succinct functional programming style lost degree 
graph algorithms contained king phd thesis king 
heavy monads rely state computations 
algorithms mainly known imperative world 
comprehensive advanced book data structures functional languages chris okasaki 
contain material graphs graph algorithms 
inductive graphs prevailing view graphs programming large monolithic block disregarding node edge labels graph viewed pair set nodes theta set edges 
descriptions algorithms incrementally graphs algorithms visit nodes need additional data structure remembering parts graph dealt 
alternatively graph representation defined additional fields allows marking nodes edges directly graph structure 
node marking strategy reflects inherently imperative style algorithms shows bit painfully tries implement algorithms functional language thread data structure node marks functions involved implementation algorithm 
done passing additional parameter monads 
case state threaded algorithm complicates aspects algorithm 
complicates correctness proofs program transformations considerably 
seen contrast list tree algorithms beautiful simple definitions needing additional bookkeeping 
reason lists trees inductively defined data types function definitions follow quite naturally definition argument data type inductive style 
pattern matching contributes significantly succinctness elegance function definitions 
proposing essentially regard graph inductive data type 
graph algorithms amenable inductive function definitions advantages 
graphs conceptually represented constructors introduce constructors section 
simple algorithms implemented imme martin erwig pattern matching basic constructors 
advanced algorithms require ability visit nodes specific order supported particular kind pattern matching described section 
section describe discuss ways implement inductive graphs 
denote number nodes edges graph 
graph constructors graph consists set nodes connected edges 
simplicity assume nodes represented integers generality define single graph type directed node edge labeled multi graphs 
graph types obtained special cases example undirected graphs simulated directed graphs having symmetric edge structure say directed graph properly represents undirected graph edge edge label 
unlabeled graphs simply node edge label type unit 
inductive view graphs captured description graph empty graph graph extended new node label edges successors predecessors graph 
representation edge contains successor predecessor node label edge 
information step inductive graph extension contained type called context 
type node int type node type context node graph type implemented efficiency reasons type see section 
convenient think graph type defined algebraic type constructors empty infix notation data graph empty context graph definition suggests graphs isomorphic lists case graphs freely generated empty 
constructors denote graphs data type terms 
consider instance graph shown left 
build graph example expression solid dashed dotted part see graph middle left right empty chosen order inserting node contexts possible 
example reverse order 
contexts changed inductive graphs functional graph algorithms right left right left right left 
directed graph inductive constructions 
accordingly refer predecessor successor lists nodes graph extended see graph right 
right left empty defined function consistency checks graph construction integrated 
fact error reported context added node graph node mentioned successor predecessor list missing graph 
choose arbitrary order node insertion building graph 
important property sets theoretical foundation possibility powerful kind pattern matching graphs described subsection 
express result facts fact completeness labeled multi graph represented graph term 
fact choice representation graph node contained exist denotes observations established formally define semantics graph constructors express relationships semantics see erwig 
inductive graph view mean forced invent proper sequence contexts define graphs 
fact quite tedious defined number operations insert lists nodes edges graph 
connection mention function yields list nodes contained graph 
int graph node foldr max nodes function particularly useful extending graph construction history known 
function nodes extracts node values graph defined subsection 
martin erwig pattern matching graphs having introduced described inductive graphs terms pattern matching representation 
define elementary functions isempty graph bool isempty empty true isempty false realize interesting operations 
example define map function graphs simple term pattern matching gmap context context graph graph gmap empty empty gmap gmap note gmap preserves structure nodes necessarily edges 
graph reversal function easily defined gmap grev graph graph grev gmap swap swap advantages programming style particular simple proofs program properties transformation rules 
example needs just couple lines prove induction say fusion law gmap inversion rule grev gmap gmap gmap gmap fusion grev grev id grev inversion prove gmap fusion induction graph structure 
empty definition gmap gmap empty gmap empty empty gmap empty conclude induction gmap gmap gmap gmap def gmap gmap def gmap gmap gmap def gmap gmap ind hyp gmap def gmap gmap def proof second equation need obvious facts swap gmap swap swap id swap idempotency gmap id id gmap unit prove grev inversion help gmap fusion law 
grev grev gmap swap gmap swap def grev gmap swap swap gmap fusion gmap id swap idempotency id gmap unit inductive graphs functional graph algorithms really appreciate elegance proof reader try prove property imperative graph reversal algorithm works iterating adjacency lists 
useful basic function graphs context graph empty implement gmap couple graph functions gmap nc 
empty nodes graph node nodes 
eq graph graph gmap ps nub ps ps graphs implemented type reader aware fact function constructor patterns 
defines predicate isempty function extracting arbitrary context graph 
context graph note reports error applied empty graphs 
function gmap implemented typically follows 
gmap isempty gmap general contexts encountered reverse order inserted graph 
affect reasoning demonstrated preconditions refer arbitrary representations 
far practical concerned keeping term representation problem equality graphs defined basis set nodes edges contained graphs 
model gmap id find gmap id evaluates true 
question arises different term representations graph graph algorithms defined gmap correct encounter arbitrary representation 
correctness algorithm requires certain sense robust respect term representation graph works arbitrary valid term representation 
question considered definition individually 
example definition grev works correctly stands unordered emphasizes order encountering nodes important 
fold operations particular ordered graph decomposition defined erwig 
martin erwig change order contexts dependency successor predecessor nodes inserted previous contexts affected exchanging successor predecessor lists 
contrast functions change contexts arbitrary ways gmap may succeed orders fail requirement successor predecessor nodes exist graph 
algorithms require contexts matched specific order 
point multiple representations graphs offer great opportunity define special kind pattern matching just allows selection contexts specific nodes 
erwig introduced active patterns essentially extend patterns function component applied argument value matched pattern 
function transform argument desired form matching extract just parts desired form 
respect active patterns similar views wadler burton cameron 
active pattern function access external values argument facilitates external control argument reorganization 
possible views possible approach erwig peyton jones limited degree proposal 

detailed comparison pattern matching extensions see erwig peyton jones 
going explain active patterns full detail purpose sufficient just define active graph pattern fact tells node contained graph term representation suitable active pattern matched graph searching node transforming conceptually term representation context inserted argument outermost application 
course done contained case pattern said match context bound graph context incident edges bound hand contained pattern fails bindings produced pattern matching continues normal pattern match failure 
note expression pattern 
variable bound value active graph pattern evaluated 
typically happens parameter preceding graph pattern 
examples active graph patterns determining node successors computing degree node deleting node graph node graph node map snd deg node graph int deg length length del node graph graph del inductive graphs functional graph algorithms table 
basic graph operations construction decomposition empty graph empty test empty graph empty match add context extract arbitrary context match extract specific context note active patterns essential rewrite functions explicitly calling function match searches context node graph returns context remaining graph match node graph 
context graph function uses active pattern way rewritten case expression case match just note equations precede active pattern kept unchanged 
see instance dfs section function implemented case match just map snd fact way functions implemented active patterns available haskell 
addition frequently need function selects successors known context 
define suc context node suc map snd implementation complexity implementation inductive graphs support operations constructing decomposing graphs shown table 
particular graphs fully persistent updates graph leave previous versions intact 
martin erwig graph representations persistence idea plain term representation offers persistence free 
closer look rules option implementation pattern hopelessly inefficient implementation function inefficient ensure existence predecessors successors non existence newly inserted node testing takes linear time respect size graph 
considering imperative world main representations adjacency lists incidence matrices 
strengths weaknesses 
special applications adjacency lists generally favored incidence matrices 
adjacency lists require space dense graphs 
adjacency lists offer access time successors arbitrary node contrast omega gamma time needed scan complete row incidence matrix 
concentrated alternatives making adjacency lists persistent representation uses variant version tree implementation functional arrays second representation stores successor predecessor lists balanced binary search tree 
version tree implementation aasa 
records changes original array inward directed tree index value pairs original array root 
different array version represented pointer node version tree nodes path root mask older definitions original array tree 
adding new node version tree done constant time index access take steps denotes number updates array 
basic structure extended additional cache array add array carrying time stamps nodes 
support specialized operations efficiently structure supplemented array implementation node partitions keep track inserted deleted nodes 
optimizing version tree array representation version tree representation implementation quite inefficient deletion context requires removal predecessor successor list successor predecessor list 
denotes size context length means running time uc recall gives total number previous updates graph 
keeping predecessors successor balanced binary search trees effort reduced uc log 
fact sophisticated functional array implementations available example dietz neill burton 
implementation data structures requires considerable effort benchmarks shown simpler version tree implementation deliver practice asymptotic complexity promises erwig 
inductive graphs functional graph algorithms avoiding node deletion 
avoid costly deletion activities equip node graph positive integer integer negated node deleted 
positive node stamps put successor predecessor lists 
node context deleted need remove referencing successor predecessor lists successor list node accessed contains elements non matching stamps ignored returned successor negative node stamp contains positive stamp 
re inserted graph stamp positive increase take new stamp newly added predecessors successors 
new predecessors old entry correctly ignored accessed value smaller current stamp 
practice garbage nodes successor predecessor lists invalid unused deleted nodes significant source inefficiency applications 
example case graph reduction graphs heavily updated nodes successor predecessor lists filtered due invalid stamps 
avoiding version tree lookups 
define leftmost node version tree leaf reached repeatedly added version node starting root 
add imperative cache array leftmost node version tree 
means array represented node fact duplicated 
index access array possible constant time algorithms functional array single threaded way complexity imperative case version tree degenerates left spine path leaf node offering constant time access algorithm 
subtlety implementation involving having just cache array functional array second time cache consumed previous computation 
gives surprising time behavior user executes program functional array runs quite fast 
running program results general larger execution times access goes version tree 
create implementation new cache new version derived root version tree 
support special operations 
version tree implementation described far surprisingly inefficient operations empty match match 
testing empty graph easily supported extending graph representation include number nodes graph 
operation match difficult realize general scan stamp array find valid non deleted node 
note simple imperative array implementation requires general linear time operation scans array 
surprising question graph updates completely ignored anyway descriptions imperative graph representations 
martin erwig account match keep graph partition inserted nodes nodes existent graph deleted nodes node deleted decomposed moved inserted set deleted set node inserted graph moved way 
node partition realized arrays index elem integer giving number existent nodes equivalently pointing existing node 
array elem stores existent nodes left part deleted nodes right part index gives node position elem array 
node existent index deleted index inserting new node means move deleted set inserted set 
done exchanging position elem node stored elem deleted node followed increasing 
entries index updated accordingly 
delete node swap elem decrease 
possible constant time 
mentioned graph operations implemented constant time match realized calling elem empty match true 
useful graph operations efficiently supported node partition list fresh nodes required implementation simply elem elem gives number nodes graph nodes reported time size array 
described implementation node partitions extension sparse set technique proposed briggs torczon 
drawback extension keeping partition information requires additional space causes overhead 
graphs truly dynamic arrays grow shrink 
binary search tree representation binary search tree functional array implementation offers immediate realization functional graphs graph represented pair tree pairs node predecessors label successors largest node occurring note support creation new nodes possible time 
inserting deleting node context requires considerable effort 
insertion insert context takes log steps insert successor predecessor node requires log steps 
insertion runs log time large log dense graphs 
context deletion takes time remove successor predecessor list element requires searching lists altogether deletion runs log time log log predecessors successors stored search trees 
dense graphs gives complexity log log 
asymptotic behavior search tree representation clearly worse single threaded graph uses array implementation performs practice see erwig simpler inductive graphs functional graph algorithms require tuning 
great advantage truly dynamic structure supports unbounded growth graphs 
problem array implementation difficult realize haskell 
unsafe features exploited operations constant time array updates encapsulated monad 
monad extend far access array monad eventually show algorithms hidden graph implementation 
bad completely destroy functional flavor algorithms inductive graphs 
version tree implementation contained ml version haskell version currently provides search tree representation 
functional graph algorithms ready collection graph algorithms inductive view graphs 
describe selection algorithms courses algorithms data structures 
serve evidence possible teach graph algorithms functional languages 
provide additional explanations required potential graph chapter textbook 
shall discuss different flavor functional algorithms compared imperative versions 
comment complexity assume may true implementations 
example programs erwig concentrated definition kinds graph fold operations optimization rules erwig example programs benchmark different inductive graph implementations 
examples completely functional graph reducer described detail erwig 
depth search depth search basic important graph algorithms 
reveal lot internal structure graph information implement algorithms topological sorting computing strongly connected components 
depth walk graph essentially means visit node graph visiting successors siblings 
parameters depth search course graph searched list nodes saying nodes left visit 
list needed unconnected graphs having completely explored component node component needed continue search 
result depth search example list nodes order visited list said depth order depthfirst spanning forest keeps edges traversed reach nodes 
giving algorithm yields list nodes depth order martin erwig dfs node graph node dfs dfs vs dfs suc vs dfs vs dfs vs algorithm works follows 
nodes left visited case dfs stops returning nodes 
contrast nodes visited dfs tries locate context nodes argument graph 
possible second equation case contained argument graph node resulting node list search continues remaining graph successors visited remaining list nodes vs fact successors put front nodes causes dfs favor searching depth breadth 
matched line dfs continues search remaining list nodes vs note case occur contained graph pattern second equation matched 
reader noticed source optimization definition fact immediately terminate dfs return empty node list nodes visited left graph empty 
achieved adding second equation dfs vs empty changing equation dfs vs null vs jj isempty affect computed results improve efficiency particular dense graphs expanded edges cause omega gamma nodes checked graph completely traversed 
interesting note single visit constraint depth search realized active patterns node visited successfully matched second equation algorithm continues graph contain anymore 
remembering visited nodes imperatively node marks functionally threading set structure approach visited nodes simply forgotten 
consider easy realize breadth search simply replace suc vs vs suc second equation new nodes deeper level visited nodes current level visited 
course treatment lists queues inefficient section discusses replace lists efficient implementation queues 
mentioned general form dfs needs parameter list possibly unvisited nodes 
run dfs graph mentioning start node sufficient call dfs nodes 
note works bfs list queues parameter 
visiting nodes order list provided 
bfs defined just queue needs single start node parameter 
inductive graphs functional graph algorithms note active patterns just notational convenience implement dfs match function dfs dfs vs case match just dfs suc vs dfs vs computing depth spanning forest slightly complex distinguish relationship node successors siblings obtain spanning tree structure 
needed dfs nodes just put list successors siblings concatenated 
contrast compute tree structure spanning trees siblings concatenated node new branch tree spanning trees successors subtrees 
need definition multi way trees postorder traversal function visits nodes subtrees root 
data tree br tree postorder tree postorder br ts concatmap postorder ts note concatmap function defined haskell prelude concatmap concatmap concat map course simple implementation postorder quadratic running time accumulating parameter queue data structure obtain linear complexity 
define function compute spanning forests 
function similar dfs mainly differs second equation applies node visited graph 
case create independently spanning forests forest successors trees subtrees newly created tree root tree added second forest computed remaining nodes visited 
ensure node remember unused graph parts second result thread graph successive function calls 
df node graph 
tree node graph df df vs br df suc df vs df vs df vs graph result df internally define additional function dff returns just computed forest 
dff node graph tree node dff vs fst df vs martin erwig able compute depth spanning forests implement quite easily functions topologically sorting graph computing strongly connected components erwig king launchbury king topological sorted list nodes obtained reversed postorder list nodes depth spanning tree sharir algorithm computing strongly connected components works computing depth spanning forest reversed graph starting topologically sorted list nodes 
graph node reverse concatmap postorder dff scc graph tree node scc dff grev examples demonstrate nicely compositional style functional languages give succinct descriptions graph algorithms 
launchbury erwig shown definitions optimized 
breadth search breadth search essentially means visiting siblings successors 
effect visiting nodes certain distance measured number edges start node visiting nodes away 
property exploited shortest path algorithm esp breadthfirst search 
bfs node graph node bfs bfs vs bfs vs suc bfs vs bfs vs algorithm works depth search treatment newly successors reflects exactly way nodes visited implicitly ordered dfs kept stack newly discovered nodes put front previously discovered visited ones bfs nodes kept queue new nodes appended old ones 
lists realize queue efficient due append operation linear time size argument 
queue implementations available guarantee constant time operations amortized operations gries burton single operation hood melville chuang goldberg okasaki 
purpose amortized constant time queue implementation sufficient keeps bfs linear algorithm 
enhance definition way dfs df aborting search encountering empty graph 
build breadth spanning tree keep information just order nodes 
algorithm observations 
quite difficult efficiently build breadth spanning tree inductive graphs functional graph algorithms represented example tree node value done df see okasaki 
problem expressions denoting trees built bottom recursion bfs delivers nodes way se suited top construction 
second representation important important uses breadth spanning tree find shortest paths root node supported inward directed trees trees edges point successors predecessors finding shortest path node node achieved computing breadth spanning tree rooted ii locating node iii edges root 
reverse list traversed nodes edges gives shortest path 
inward directed tree represented simply mapping domain range type node mapping nodes predecessors 
mapping built incrementally breadth search list traversed edges monolithic array implementing 
fact array construct proposed johnsson build tree requires reformulation algorithm follows array construction destroys simplicity elegance functional bfs algorithm 
binary search tree adds logarithmic factor operation building spanning tree ii reconstructing shortest path 
problem addressed just mapping nodes predecessor path root call root path path short 
really implementation complex insert predecessor just inserting key tree locate root path stored say insert key tree 
way need locate inward directed tree just reverse list stored nodes obtain shortest path note representation causes minimal space overhead common prefixes paths common suffixes paths shared representation linear number stored nodes 
complexity computing breadth spanning tree computing shortest paths log 
improvement represent breadth spanning tree list tree paths node root 
call kind tree root path tree 
linear space requirement paths share common suffixes 
achieved quite easily keeping paths queue bfs define function bft takes single node computes breadth spanning tree rooted list paths calling function bf works bfs uses queue paths argument 
expression map suc extends root path distance measured number edges 
shortest path algorithm uses edge weights section 
martin erwig successors yields new root path successors 
new root paths appended rest queue ps type path node type rtree path bft node graph rtree bft bf bf path graph rtree bf bf ps bf ps map suc bf ps bf ps optimizations termination empty graphs efficient queue implementation apply 
algorithm finding shortest path nodes computes breadth spanning tree rooted spanning tree represented list root paths element extracted 
root path reversed obtain shortest path 
bool head filter esp node node graph path esp reverse bft breadth search algorithm simpler king king uses subtle functional programming tricks 
computation shortest paths efficient esp linear running time assuming usual optimization graph operations 
case king algorithm perform uninformed search target node reason king chosen kind top tree depth search 
shortest paths closely related shortest path algorithm preceding section dijkstra algorithm computing shortest paths graphs positive edge labels 
main difference length path defined sum edge labels shortest path nodes accordingly minimum path length 
dijkstra algorithm described similar bfs difference root paths kept queue heap ordered regard lengths paths 
define type labeled nodes labeled paths 
labeled root path list labeled nodes representing path node root node paired length path root 
label node inductive graphs functional graph algorithms path gives length complete path length path node root 
represented breadthfirst spanning trees lists plain paths represent shortest path trees lists labeled paths 
define labeled paths instances ord eq classes store heaps 
function extracts path specific node labeled root tree drops labels 
type lnode node type lnode type instance eq eq instance ord ord 
node path reverse map fst labeled root paths stored heap represent currently expanded shortestpath tree 
particular nodes represent fringe search labels give tentative costs nodes 
nodes paths nodes known belong shortest path tree 
dijkstra algorithm works repeatedly selecting path labeled node say 
corresponds making permanent 
new paths created putting successors front labels label plus cost associated edge leading successor 
done function expand storing different root paths node heap presents problem regard correctness cost selected 
node selected second time simply ignored matching graph fail 
heap contains entries deleting minimum heap performed times causing running time log log 
altogether version dijkstra algorithm runs worst case time log asymptotically worse non sparse graphs imperative algorithm runs log 
pairing heap implementation described okasaki 
operation wraps single value heap operation combines list heaps single heap 
operation applied non empty heap returns pair containing minimum remaining heap minimum 
strictly speaking need mergeable heap chosen pairing heaps reported efficient practice operation convenient describing node expansion 
concise notation active pattern oeh matches non empty heap binds minimum heap martin erwig expand real context heap expand map dijkstra real heap graph dijkstra jj isempty dijkstra oeh dijkstra expand dijkstra oeh dijkstra note real subclass num containing standard numeric types subclass ord real contains standard numeric types complex define additional function spt encapsulates construction initial heap function sp computing shortest paths 
spt real node graph spt spt sp real node node graph path sp spt minimum spanning tree minimum spanning tree labeled undirected graph spanning tree minimal total edge length 
context directed graphs algorithms described general directed graphs properly represent undirected graphs 
easily convert directed graph representing undirected function described section 
popular minimum spanning tree algorithms kruskal prim 
kruskal algorithm works repeatedly edges order increasing edge length long form cycle 
graph get list edges crucial part algorithm efficient implementation union find data structure enable fast cycle detection 
contrast prim algorithm performs usual walk graph 
greedy algorithm dijkstra algorithm means step new part result computed 
prim algorithm keeps heap edges start currently computed part minimum spanning tree selects step smallest edges extends fringe tree edges start selected edge target node 
define prim algorithm decide representation spanning tree decision depends context spanning tree 
application telecommunication telephone companies calculate costs phone calls length path nodes precomputed minimum spanning tree 
supported labeled root path trees 
need function creating new root paths successors node expanded 
function quite similar expand consider edge costs costs complete root paths 
inductive graphs functional graph algorithms real context heap map define prim minimum spanning tree algorithm 
parameterize function mst node value provide flexibility specifying root spanning tree 
easily define function need root operation mst real node graph mst prim prim real heap graph prim jj isempty prim oeh prim prim oeh prim striking similarity dijkstra algorithm known long time clear programming approach 
fact algorithms considered far follow basic traversal scheme differ essentially data structure control traversal 
fact exploited teaching graph algorithms presenting different algorithms instances scheme emphasized erwig erwig 
going back prim algorithm remains shown paths minimum spanning tree represented root path tree 
idea quite simple select root paths nodes join non common parts common ancestor 
path reconstruction realized functions real node node path path path path head tail tail node path path path vs ws vs ws reverse algorithms described far graph single threaded way 
data type graphs persistent shall consider application uses graphs persistently different versions graph employed time 
described 
maximum independent node sets independent node set subset nodes graph nodes set connected edge 
maximum independent node set martin erwig independent node set maximum cardinality 
problem finding maximum independent node set sense dual maximum clique problem asks maximal set nodes pair nodes connected edge 
problems np hard 
little chance exist efficient algorithms solving 
algorithms better blindly trying possible node subsets 
algorithm defined works recursively comparing alternatives 
maximum independent node set graph node maximum degree removed 
maximum independent node set neighbors removed extended node 
larger sets maximum independent node set indep graph node indep empty indep length length vs nodes maximum map flip deg vs nv deg vs indep indep foldr del pre suc note pre defined analogously suc 
proposed inductive definition graphs encourages definition graph algorithm recursive functions 
hope functional style writing graph algorithms eventually finds way teaching graph algorithms 
active patterns function definitions succinct functions easily rewritten 
described efficient implementation inductive graphs shows alternative algorithmic style gives efficiency clarity 
acknowledgments author chris okasaki anonymous reviewers helpful comments 
aasa nilsson 
efficiency comparison representations purely functional arrays 
bit 
barendsen smetsers 
uniqueness typing functional languages graph rewriting semantics 
mathematical structures computer science 
inductive graphs functional graph algorithms bird 
functional programming haskell 
prentice hall international 
briggs torczon 
efficient representation sparse sets 
acm letters programming languages 
burton 
efficient functional implementation fifo queues 
information processing letters 
burton cameron 
pattern matching data types 
journal functional programming 
burton yang 
manipulating data structures pure functional language 
software practice experience 
chuang 
goldberg 
real time deques turing machines purely functional programming 
conf 
functional programming computer architecture pp 

dietz 
fully persistent arrays 
workshop algorithms data structures 
lncs pp 

erwig 
graph algorithms iteration data structures 
structure graph algorithms corresponding style programming 
th int 
workshop graph theoretic concepts computer science 
lncs pp 

erwig 
active patterns 
th int 
workshop implementation functional languages 
lncs pp 

erwig 
fully persistent graphs choose 
th int 
workshop implementation functional languages 
lncs pp 

erwig 
functional programming graphs 
nd acm int 
conf 
functional programming pp 

erwig 
functional graph reduction 
technical report 
hagen 
erwig 
syntax semantics visual languages 
journal visual languages computing 
erwig 
random access data types 
th int 
conf 
algebraic methodology software technology 
lncs pp 

erwig peyton jones 
pattern guards transformational patterns 
haskell workshop 
fegaras sheard 
revisiting catamorphisms datatypes embedded functions 
rd acm symp 
principles programming languages pp 

gibbons 
initial algebra approach directed acyclic graphs 
mathematics program construction 
lncs pp 

gries 
science programming 
springer verlag 
harrison 
data types standard ml 
john wiley sons 
hood melville 
real time queue operations pure list 
information processing letters 
hudak bloss 
aggregate update problem functional programming systems 
th acm symp 
principles programming languages pp 

johnsson 
efficient graph algorithms lazy monolithic arrays 
journal functional programming 
wise 
graph algorithms lazy functional programming language 
th int 
symp 
lucid intensional programing pp 

king 
functional programming graph algorithms 
phd thesis university glasgow 
martin erwig king launchbury 
structuring depth search algorithms haskell 
nd acm symp 
principles programming languages pp 

launchbury 
graph algorithms functional flavour 
advanced functional programing 
lncs pp 

okasaki 
simple efficient purely functional queues deques 
journal functional programming 
okasaki 
purely functional data structures 
cambridge university press 
okasaki 
breadth numbering lessons small algorithm design 
th acm int 
conf 
functional programming pp 

neill burton 
new method functional arrays 
journal functional programming 
pe na nez 
new look pattern matching data types 
st acm int 
conf 
functional programming pp 

paulson 
ml working programmer nd ed 
cambridge university press 
lapalme 
algorithms functional programming approach 
addison wesley 

elements functional programming 
addison wesley 
sastry 
order evaluation analysis destructive updates strict functional languages flat aggregates 
conf 
functional programming computer architecture 
ullman 
elements ml programming nd ed 
prentice hall international 
wadler 
views way pattern matching cohabit data abstraction 
th acm symp 
principles programming languages pp 

