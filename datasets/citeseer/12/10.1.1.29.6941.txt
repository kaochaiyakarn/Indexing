cecil language specification rationale version craig chambers department computer science engineering university washington box seattle washington usa ii cecil purely object oriented language intended support rapid construction high quality extensible software 
cecil combines multi methods simple classless object model kind dynamic inheritance modules optional static type checking 
instance variables cecil accessed solely messages allowing instance variables replaced overridden methods vice versa 
cecil predicate objects mechanism allows object classified automatically run time mutable state 
cecil static type system distinguishes subtyping code inheritance cecil enables graphs described single set declarations streamlining common case graphs parallel 
cecil includes fairly flexible form parameterization including explicitly parameterized objects types methods implicitly parameterized methods related polymorphic functions commonly functional languages 
making type declarations optional cecil aims allow mixing migration exploratory production programming styles 
cecil supports module mechanism enables independently developed subsystems encapsulated allowing type checked reasoned isolation despite presence multi methods subclassing 
objects extended externally additional methods instance variables encapsulated separate modules supporting kind subject oriented programming style 
document describes design cecil language december 
mixes specification language discussions design issues explanations reasoning led various design decisions 
iii table contents 
design goals major features overview dynamically typed core 
objects inheritance inheritance object instantiation extension declarations predefined objects closures methods argument specializers multi methods method bodies primitive methods fields read vs mutable fields fields methods copy vs shared fields field initialization predicate objects predicate objects inheritance predicate objects fields statements expressions declaration blocks variable declarations variable assignment statements literals message sends object constructors vector constructors closures parenthetical subexpressions precedence declarations previous approaches precedence associativity declarations cecil iv method lookup philosophy semantics examples strengths limitations multiple inheritance fields method lookup lexical scoping method invocation resends files include declarations pragmas static types 
goals types signatures type signature declarations type declarations representation object declarations type object extension declarations signature declarations implementation method declarations field implementation declarations type declarations discussion special types type constructors named types closure types upper bound types greatest lower bound types object role annotations type checking messages checking messages signatures checking signatures method implementations comparison type systems type checking inherited methods type checking expressions statements declarations type checking subtyping declarations type checking predicate objects mixed statically dynamically typed code parameterization parametric polymorphism 
explicit parameterization parameterized declarations formal type parameters instantiating parameterized declarations parameterized objects types method lookup type checking instantiations implicit parameterization matching type patterns method formal type patterns upper bound type patterns matching algorithm static vs dynamic matching constraints supertype graphs matching matching bounded formal type parameters implicit type parameters extension declarations parameterized objects method lookup parameterization syntactic bounded polymorphism motivation bounded polymorphism singly dispatched languages bounded polymorphism cecil bounded polymorphism multiple types modules 
related 


appendix annotated cecil syntax 
grammar tokens white space document describes current design cecil object oriented language intended support rapid construction high quality reusable extensible software systems chambers chambers chambers leavens 
cecil unusual combining pure classless object model multiple dispatching multi methods modules mixed static dynamic type checking 
cecil inspired initially self ungar smith hlzle clos bobrow gabriel trellis schaffert schaffert 
current version cecil extends earlier version chambers predicate objects modules efficient typechecking algorithms 
design goals major features cecil design results goals maximize programmer ability develop software quickly reuse modify existing software easily 
response goal cecil pure object model data objects objects manipulated solely passing messages 
pure object model ensures power object oriented programming uniformly available data parts programs 
run time performance disadvantage traditionally associated pure object oriented languages diminishing advent advanced implementations 
experience leads develop classless prototype object model cecil 
feel classless object model simpler powerful traditional class object models 
cecil object model somewhat restricted languages borning lieberman lalonde ungar smith lieberman response design goals 
message passing cornerstone power object oriented systems cecil includes fairly general form dynamic binding multiple dispatching 
multimethods affect aspects rest language design research cecil aims combine multi methods traditional object oriented language concepts encapsulation static type checking multiple dispatching languages 
inheritance plays key role organizing software factoring commonalities 
cecil extends traditional inheritance mechanisms predicate objects support automatic form classification objects specialized subclasses run time state 
state mutable object classification change time 
mechanism enables inheritance classification applied modelling time varying properties object 
example rectangle automatically classified predicate subobject square satisfies predicate length equals width rectangle length width mutable 
instance variables called fields cecil accessed solely sending messages enabling fields replaced overridden methods vice versa affecting clients 
fields default initial values part declaration 
initialization expression evaluated lazily field referenced acting kind memoized constant function 
allowing initialization expression object part circular data structures constructed generally value field computed values fields object 
support production high quality reliable software 
help construction high quality programs programmers add declarations assertions cecil programs 
important kind static declaration specifies types interfaces objects methods 
cecil allows programmers specify types method arguments results local variables cecil performs type checking statically statically typed expression assigned variable formal argument 
types specified programmers describe minimal interfaces required legal objects representations implementations support maximum reuse typed code 
cecil subtype graph distinguished code inheritance graph type checking different goals requirements code reuse module extension snyder brien cook 
support independent construction subsystems cecil includes module system 
module encapsulates internal implementation details presents interface external clients 
encapsulation mechanism specially designed presence multimethods inheritance subtyping module boundaries 
modules encapsulate roles andersen subjects harrison ossher programming idioms pieces total interface object split apart application specific facets 
module include method field declarations extend previously defined objects additional specialized state behavior 
cecil includes kinds static declarations 
object annotated object providing shared behavior manipulable programs template object providing behavior suitable direct instantiation manipulable program concrete object fully manipulable instantiated 
object annotations inform type checker programmer intends objects enabling type checker flexible objects limited fashion 
cecil encourages functional programming style default easier understand robust face programming changes 
default local variables fields initialize explicit var keyword required assert variable field mutated 
object created fields initialized desired values single atomic operation partially initialized states execution constructor 
cecil omits certain complex language features effect masking programming errors 
example cecil multiple dispatching multiple inheritance unbiased respect argument order parent order resulting ambiguities reported back programmer potential errors 
design decision squarely odds decision clos related languages 
additionally subtyping cecil explicit implicit behavioral specification information implied types incorporated decision type behavioral subtype 
support exploratory programming production programming enable smooth migration parts programs style 
central achieving goal cecil ability omit type declarations annotations initial exploratory versions subsystem incrementally add annotations subsystem matures production quality 
cecil type system intended flexible expressive type declarations added existing dynamically typed program achieve static type correctness major reorganization program 
particular objects types methods may explicitly parameterized types method argument result types may declared parameterized implicitly bound type variables achieve polymorphic function definitions mentioned subtype graph differ inheritance graph 
presence multiple dispatching relieves type system burden multiple dispatching supports type safe manner considered unsafe covariant method redefinition single dispatching language 
additionally environment cecil infer demand parts programs explicitly declared list supertypes object set legal methods object language support exploratory programmers inferencer production programmers explicitly specify want 
approach resolves tension language features support exploratory programming features support production programming 
cases language supports explicit production oriented feature directly environment expected provide additional support exploratory oriented feature 
avoid unnecessary redundancy programs 
avoid requiring programmer repeat specifying interface object method cecil allows single object declaration define implementation type interface 
similarly subtype hierarchy coincides code inheritance hierarchy single declaration establish relations 
approach greatly reduces amount code required system distinguished subtyping code inheritance 
degree conciseness believe separating subtyping code inheritance verbose 
similarly cecil classless object model designed single object declaration define entire data type 
contrasts situation self objects needed define data types ungar 
similarly cecil object model supports concise inheritance representation concise overriding representation class object oriented languages support classless object oriented languages conveniently support 
cecil avoids requiring annotations exploratory programming 
annotations type declarations privacy declarations simply omitted programming exploratory mode 
case language verbose rapid exploratory programming 
simple possible simpler 
cecil attempts provide smallest set features meet design goals 
example object model pure classless simplifying language sacrificing expressive power 
features included cecil complex supporting multiple dispatching distinguishing subtyping implementation inheritance 
alternative preference powerful language complex simpler powerful language 
simplicity important override language goals 
cecil design includes number features proven worth systems 
include multiple inheritance implementation interface closures implement user defined control structures exceptions course automatic storage reclamation 
overview document attempts provide fairly detailed specification cecil language discussion various design decisions 
section document describes basic object message passing model cecil 
section extends dynamically typed core language static type system describes type checking algorithm section discusses parameterization 
section describes cecil module system 
section discusses related 
appendix summarizes complete syntax cecil 
dynamically typed core cecil pure object oriented language 
data objects message passing way manipulate objects 
instance variables accessed solely message passing 
purity offers maximum benefit object oriented programming allowing code manipulate object knowledge dependence underlying representation implementation 
cecil implementation defines programs put 
uw cecil implementation defines program sequence declaration blocks statements optionally interspersed pragmas program top level file top level file top decl block stmt pragma declaration blocks comprised set declarations introduced simultaneously names introduced part declarations declaration block visible declaration block remainder scope containing declaration block names go scope scope exits 
name object visible declaration block objects inherit objects defined declaration block methods specialized objects defined declaration block 
environments top level declaration comprising program spread multiple files ability attach methods objects defined file important 
syntax declarations follows top decl block decl pragma decl object decl obj ext decl predicate decl method decl field decl decl precedence decl include decl subsections describe objects methods fields predicate objects 
subsection describes variables statements expressions subsection explains precedence declarations 
subsections detail semantics message passing cecil 
subsection describes include declarations file structure uw cecil implementation subsection discusses pragmas 
objects inheritance basic features objects cecil illustrated declarations define simple shape hierarchy 
comments cecil extend line bracketed nested 
ignoring type signature declarations section module declarations section 
object shape generic shape operations object circle isa shape circle operations object rectangle isa shape rectangle operations object rhombus isa shape rhombus operations object square isa rectangle rhombus square operations syntax object declaration excluding features relating static type checking modules follows object decl object name relation field inits relation isa parents parents named object named object named object name name token regular identifiers letter see appendix details lexical rules cecil 
cecil classless prototype object model self sufficient objects implement data abstractions objects inherit directly objects share code 
cecil uses classless model primarily simplicity avoids problems relating firstclass classes metaclasses defining unique named objects specialized behavior easy 
section shows treating instance objects class objects uniformly enables clos style eql specializers supported extra mechanism 
section describes field initializers 
inheritance objects inherit objects 
informally means operations defined parent objects apply child objects 
inheritance cecil may multiple simply listing parent object ambiguities methods fields defined parents reported programmer 
inheriting ancestor directly indirectly effect place ancestor relation ancestors cecil repeated inheritance eiffel meyer meyer 
object need explicit parents objects considered inherit predefined object see section 
inheritance graph acyclic 
inheritance cecil requires child accept fields methods defined parents 
fields methods may overridden child facilities excluding fields methods parents renaming part inheritance eiffel cecil 
deliberately chosen experiment simpler inheritance semantics 
important note inheritance code distinct subtyping inheritance interface specification 
section explains cecil support subtyping static type checking 
object instantiation introduce distinct instantiation concept language new instances object created solely inheriting object 
object declarations allow statically known named instances defined object constructor expressions allow new anonymous instances created run time 
object constructor expression syntactically semantically similar object declaration name object created 
example object isa square create fresh instance square executed section describes object constructor expressions detail 
note parent object statically known cecil allow objects created parents runtime computed expressions 
restriction prototype languages 
extension declarations inheritance structure named object may augmented separately object declaration object extension declaration obj ext decl extend named object relation field inits cecil object extension declarations conjunction field method declarations enable programmers extend previously existing objects 
ability important reusing integrating groups objects implemented programmers 
example predefined objects int vector vector additional behavior ancestry separate user code 
similarly particular applications may need add application specific behavior objects defined part applications 
example text processing application may add specialized tab space conversion behavior strings collections characters defined standard library 
object oriented languages stroustrup ellis stroustrup eiffel allow programmers add behavior existing classes modifying source code existing classes completely disallow adding behavior built classes strings 
sather notable exception allowing new class defined superclass existing classes omohundro 
section explains object extensions particularly useful declare objects provided independent vendors subtypes third type 
section describes modules localize extensions particular regions code 
predefined objects objects predefined play special roles 
void object represent lack value 
result methods expressions useful result 
system guarantee statically presence type checking void passed argument method 
object implicitly ancestor non void objects 
supports behavior shared objects 
object represents undefined value 
system guarantee dynamically passed argument method ensured statically 
respect akin nil languages void eiffel 
sparingly 
cecil implementation provides predefined objects integers floats characters booleans mutable immutable vectors strings part standard library 
closures cecil includes closure objects represent class anonymous functions 
closures lexically nested enclosing scope 
functions closure formal arguments 
closure object invoked sending eval message additional actual arguments formal arguments 
closures considered inherit closure predefined object 
details closures remainder section 
particular section describes syntax semantics closure constructor expressions section describes evaluation rules closure eval methods 
methods definitions expand earlier shape hierarchy methods object shape method draw draws display method move new center move new center object circle isa shape method area circle radius radius pi method circle radius pi object rectangle isa shape method area rectangle length width method rectangle length width method draw rectangle override draw case drawing rectangles windows object rhombus isa shape object square isa rectangle rhombus inherits area method overrides method square length syntax method declarations excluding aspects relating static typing encapsulation follows method decl method method name formals pragma body prim body method name msg name op name msg name name formals formal formal formal name specializer formal names optional referenced cease user manipulable object version language 
specializer named object specialized formal empty unspecialized formal op name token infix prefix operators punctuation symbol see appendix details 
convention indent method declarations associated object declaration 
semantic implication helps visually organize collection object method declarations absence powerful graphical programming environment chambers 
argument specializers multi methods cecil method specifies kinds arguments code designed 
formal argument method programmer may specify method applicable actual arguments implemented represented particular way equal inherit particular object 
specifications called argument specializers arguments restrictions called specialized arguments 
rectangle notation specializes formal argument rectangle object implying method intended correctly actual argument object equal descendant rectangle object formal 
unspecialized formal argument lacking suffix new center move method treated specialized predefined object implicitly ancestor objects consequently unspecialized formal accept argument object 
methods may overloaded may methods name long methods name number arguments differ argument specializers 
methods different numbers arguments independent system considers number arguments part method name 
sending message particular name certain number arguments method lookup system described section resolve overloaded methods single specific applicable method dynamic values actual argument objects corresponding formal argument specializers methods 
zero method arguments may specialized enabling cecil methods emulate normal functions leaving formals unspecialized move singly dispatched methods specializing argument area methods true multi methods specialized version draw rectangles windows 
statically overloaded functions functions declared certain kinds patternmatching subsumed multi methods 
callers send particular message group arguments aware collection methods handle message arguments methods specialized internal implementation decisions affect callers 
particular message initially implemented single unspecialized procedure extended replaced specialized implementations affecting clients original method occurs draw methods previous example 
contrast clos congruent lambda list rule requires methods particular generic function specialize argument positions 
argument specializers distinct type declarations 
argument specializers restrict allowed implementations actual arguments part method lookup locate suitable method handle message send 
type declarations require certain operations supported argument objects place constraints operations implemented 
type declarations effect method lookup 
name formal may omitted needed method body 
languages implicit self formal cecil formals listed explicitly 
cecil classless object model combines definition argument specializers support similar clos eql specializers 
clos argument multi method generic function may restricted apply particular object annotating argument specializer eql keyword 
cecil needs extra language mechanism achieve similar effect methods specialized particular objects 
cecil mechanism differs clos cecil method apply children specializing object clos method apply object 
dylan descendant clos singleton specializer analogous clos eql specializer apple 
mentioned subsection methods added existing objects needing modify existing objects 
facility lacking object oriented languages reusing existing components easier adapted new uses adding methods fields parents 
names methods fields name space separate name space objects variables 
method field name variable object confusion 
method bodies syntax body method closure parenthetical subexpression follows body stmt result return result statement empty return void result normal return return expression non local rtn return lexically enclosing method normal return decl block return void assignment return void expr return result expression non local rtn non local return returning void expr non local return returning result syntax semantics statements expressions described section invoked method evaluates statements new environment containing bindings method formal parameters nested method lexically enclosing environment 
interactions nested scopes method lookup language features described detail section result message invoking method result statement method body 
method body empty method returns special void value 
alternatively method returns void statement declaration block assignment statement expression returns void 
void value indicate method returns useful result 
system ensures void accidentally computation reporting error statically presence type checking void passed argument message 
closure eval method invoked evaluation proceeds evaluation method 
difference closure eval method may force non local return prefixing result expression symbol result expression omitted void returned non locally 
non local return returns caller closest lexically enclosing method caller eval method just non local return smalltalk goldberg robson self similar return statement language currently prohibits invoking non local return lexically enclosing scope closure returned class continuations supported 
primitive methods prim body prim language code language name code string low level operations integer arithmetic vector indexing looping file implemented primitive methods 
primitive method body list language name implementation source code pairs 
details protocol writing code language inside cecil primitive method implementation specific 
uw cecil implementation recognizes rtl language names primitives written compiler internal intermediate language respectively 
fairly straightforward calls routines written cecil defining primitive method body written 
looping primitive behavior provided loop primitive method specialized closure predefined object 
method repeatedly invokes argument closure closure performs non local return break loop 
languages scheme rees clinger avoid need primitive relying user level tail recursion implementation provided tail recursion elimination 
tail recursion elimination precludes complete source level debugging chambers hlzle consequently undesirable general 
primitive loop method may viewed simple tail recursive method implementation instructed perform tail recursion elimination 
primitive body may included top level primitive body declaration prim decl prim body construct allows code languages included outside compiled routines 
primitive declarations include global declarations primitive methods 
detailed semantics construct implementation specific 
smalltalk trademark parcplace systems 
fields object state instance variables class variables supported cecil fields associated accessor methods 
define mutable instance variable particular object obj programmer declare field form var field obj declaration allocates space object obj object constructs real methods attached obj object provide access variable method obj get accessor method method set obj value value set accessor method get accessor method returns contents hidden variable 
set accessor method mutates contents hidden variable refer new object returns void 
accessor methods specialized object containing variable establishing link accessor methods object 
example sending message obj object find invoke get accessor method return contents hidden variable acting obj instance variable 
section describes accessor methods encapsulated data abstraction implementation protected external manipulation 
illustrate declarations define standard list inheritance hierarchy object list isa ordered collection method empty list length method prepend list dispatch second argument object isa cons head tail object nil isa list empty list method length nil method nil iterating elements empty list method pair nil method pair nil method pair nil nil object cons isa list non empty lists var field head cons defines head cons set head cons accessor methods var field tail cons defines tail cons set tail cons accessor methods method length cons tail length method cons block eval block head call block head list tail block recur tail list method pair cons cons block eval block head head pair tail tail block cons object fields accessible automatically generated accessor methods 
syntax field declarations excluding static typing aspects encapsulation follows field decl shared var field method name formal expr read vs mutable fields default field immutable get accessor method generated 
support updating value field var prefix field declaration 
presence var annotation triggers generation set accessor method 
immutable fields receive values part object creation initializing expression associated field declaration see section 
note contents immutable field mutable binding field contents change 
global local variables cecil similarly default initialize semantics explicit var annotation required allow updating variable value described section general believe beneficial explicitly indicate field immutable encourage indication immutable fields default 
programmers looking code easily reason behavior programs know certain parts state object side effected 
similarly immutable fields support construction immutable value objects complex numbers points easier reason 
languages including self eiffel support distinguishing assignable constant variables imperative languages support initialize instance variables 
clos define initialize variables sense slot initialized object creation time set accessor method defined clos slot value primitive function modify slot set accessor generated 
fields methods accessing variables solely automatically generated wrapper methods number advantages traditional mechanism direct variable access common objectoriented languages 
instance variables accessed messages code representation independent certain degree 
instance variables overridden methods vice versa allowing code reused representation assumed parent implementation different child implementation 
example code rectangle abstraction inherit polygon abstraction alter representation appropriate rectangles object polygon var field vertices polygon method draw polygon output device draw polygon output device accessing vertices object rectangle isa polygon var field top rectangle var field bottom rectangle var field left rectangle var field right rectangle method rectangle binary operator creating new point object top left top right bottom right bottom left method set vertices rectangle vs set corners rectangle vs list possible single abstraction programmers change minds stored computed rewriting lots code 
syntactically simple message send accesses accessor method just concise variable access syntactic sugar described section imposing burden programmer extra expressiveness 
object oriented languages self trellis shown advantages accessing instance variables solely special get set accessor methods 
clos enables get set accessor methods defined automatically part defclass form clos provides lower level slot value primitive read write slot directly 
dylan joins self trellis accessing instance variables solely accessor methods 
object may define inherit fields name 
just overloaded methods legal long methods accessor name number arguments argument specializers 
method may override field accessor method removing field memory location object resend overriding method may invoke field accessor method 
implementations may optimize away storage field object accessed vertices field rectangle object 
copy vs shared fields default object inheriting field declaration receives space hold version field contents field accessor methods access memory space associated argument 
copy field acts instance variable declaration classbased language object gets local copy field 
alternatively field declaration may prefixed shared keyword implying inheriting objects share single memory location 
shared field acts class variable 
supporting copy shared fields addresses weaknesses prototype object oriented languages relative class languages 
class languages instance variables declared superclass automatically copied subclasses declaration inherited variable contents 
class variables hand shared class instances subclasses 
prototype languages including self instance variables object copied inheriting objects variables shared class variables class language 
self get effect object specific state data types defined objects object prototype includes instance specific variables objects data type need object traits object inherited prototype holds methods shared state data type ungar 
new self objects created cloning shallow copying prototype giving new objects instance variables sharing parent traits object methods state 
defining data type pieces awkward especially separates declarations instance variables definitions methods access 
furthermore inheriting instance variable part implementation data type difficult self class languages relying complex inheritance rules dynamic inheritance chambers programming environment support ungar 
copy fields cecil solve problems self sacrificing simple classless object model 
cecil object needs defined data type field declarations place method declarations access 
design increases conciseness readability cost additional language mechanism 
cecil objects created object declarations object constructor expressions expressions similar run time effects additionally binding names created objects enabling methods fields associated enabling objects inherit 
cecil needs primitive mechanism create copy objects languages 
self provides shallow copy clone primitive addition object literal syntax analogous cecil object constructor expressions part copy data slots self 
class languages typically include mechanisms creating instances classes relations 
hand creating object inheriting existing object may natural creating object copying existing object 
field initialization cecil allows field initial value declared field declaration symbol initializing expression 
additionally object created object specific initial value may specified non shared field 
syntax field initializers object declarations object constructor expressions follows field inits field init field init field init name location expr location named object example method produces new list object particular values inherited fields method prepend list object isa cons head tail field initialization form name expr field initialized performing lookup akin message lookup find field declaration named name starting object created 
method lookup directly field initialized may overridden method name 
form lookup ignores methods 
lookup succeeds finding single specific matching field declaration field initial value matching field shared field 
matching field matching field field initializer understood ambiguous field initializer error respectively reported 
resolve ambiguities initialize fields overridden fields extended name field form name obj expr may 
kind initializers lookup matching field begins object named obj object created 
obj object ancestor object created 
extended field names analogous similar mechanism related directed resends described section 
immutable shared fields initialized part field declaration way give value 
immutable copy fields may initialized part field declaration initialized part object constructor expressions objects inherit field leading functional programming style data structures largely immutable 
avoid problems uninitialized variables fields initialized accessed providing initial value part field declaration providing value part object declaration object constructor expression assigning field reading 
static type checker warns prove options taken field inherited object described section 
cecil initializing expression field declaration evaluated field accessed 
field shared field initializer evaluated contents field updated refer initial value subsequent accesses shared field simply return initial value 
supports functionality similar functions eiffel languages 
field copy field initializing expression evaluated separately object accessed 
initializing expression may name formal parameter field declaration allowing initial value field object field part 
evaluating field initializers demand declaration time avoid need specify arbitrary ordering field declarations resort unhelpful unspecified implementation dependent rule 
illegal try read value field execution field initializer cyclic dependencies field initializers allowed 
evaluating copy field initializer expression repeatedly inheriting object support common cecil programming style 
corresponds clos initform specifier 
earlier version cecil specified caching results field initializer evaluation objects evaluating initializer expression sharing initial value 
initializing expression viewed shared part field declaration separate part copied inheriting object 
earlier semantics corresponded clos default specifier 
difference semantics exposed initializing expression evaluates new mutable object 
practice object wants mutable object sharing mutable object inheriting objects 
old semantics simulated combination copy field accesses shared field get field initial value 
predicate objects enable inheritance classes capture run time varying object behavior cecil support predicate objects chambers 
predicate objects normal objects associated predicate expression 
semantics predicate object object inherits parents predicate object predicate expression true evaluated child object child considered inherit predicate object addition explicitly declared parents 
methods associated predicate objects predicate expressions test value state candidate object predicate objects allow form state dynamic classification objects enabling better factoring code 
predicate objects multi methods allow pattern matching style implement cooperating methods 
example predicate objects implement bounded buffer abstraction object buffer isa collection field elements buffer queue elements field max size buffer integer method length buffer elements length method empty buffer length method full buffer length max size predicate empty buffer isa buffer buffer empty method get empty buffer 
raise error block caller predicate non empty buffer isa buffer buffer empty method get non empty buffer remove front elements predicate full buffer isa buffer buffer full method put full buffer 
raise error block caller predicate non full buffer isa buffer buffer full method put non full buffer add back elements predicate partially full buffer isa non empty buffer non full buffer diagram illustrates inheritance hierarchy created example explicit inheritance link buffer object buffer omitted predicate objects increase expressiveness example ways 
important states bounded buffers empty full states explicitly identified program named 
documenting important conditions bounded buffer predicate objects remind buffer buffer object non empty buffer non full buffer full buffer empty buffer partially full buffer programmer special situations code handle 
particularly useful maintenance phases code extended new functionality 
second attaching methods directly states supports better factoring code eliminates case statements distributing methods classes traditional object oriented language 
absence predicate objects method behavior depended state argument object include case statement identify branch appropriate case predicate objects eliminate clutter tests clearly separate code case 
complete example methods associated special state buffer 
factoring code separating code associated particular state behavior mode hope improve readability maintainability code 
syntax predicate object declaration follows predicate decl predicate name relation expr field inits predicate objects inheritance normal objects object child object exactly relationship declared explicitly isa declarations programmer 
predicate objects hand support form automatic property classification object automatically considered child predicate object exactly conditions satisfied object descendant parents predicate object predicate expression predicate object evaluates true evaluated scope predicate object parent names bound object evaluating predicate expression context parent names refer object tested predicate expression query value state object 
state object change time fields mutable results predicate expressions evaluated object change 
happens system automatically object recomputing implicit inheritance links 
example buffer object full predicates associated non full buffer full buffer predicate objects change inheritance graph buffer object updated 
result different methods may respond messages put message filled buffer example 
predicate expressions evaluated lazily part method lookup eagerly state object changes 
value predicate expression needed determine outcome method lookup predicate evaluated 
separate describes efficient implementation schemes predicate objects chambers 
predicate object inherits predicate object special case parent predicate object 
child predicate object force parent predicate object predicate evaluates true 
essence parent predicate expression implicitly conjoined child predicate expression 
non predicate object may inherit explicitly predicate object implication predicate expression evaluate true child object system verifies assertion dynamically 
example unbounded buffer object inherit explicitly non full buffer predicate object 
predicate object need clause illustrated partially full buffer predicate object defined 
predicate object may depend condition ancestors predicate object 
example partially full buffer predicate object explicit predicate expression object inherits partially full buffer inherits non empty buffer non full buffer partially full buffer predicate object effectively repeats conjunction predicate expressions parents case buffer empty full 
predicate objects intended interact normal inheritance data abstractions 
abstraction implemented inheriting implementation predicate objects specialize parent implementation automatically specialize child implementation appropriate state 
example new implementation bounded buffers built fixed length array insert remove positions cycle array object circular buffer isa buffer field array circular buffer fixed length array elements var field insert pos circular buffer index array var field remove pos circular buffer integer index method max size circular buffer array length method length circular buffer modulus operator insert pos remove pos array length predicate non empty circular buffer isa circular buffer non empty buffer method get non empty circular buffer var fetch array remove pos remove pos remove pos array length predicate non full circular buffer isa circular buffer non full buffer method put non full circular buffer store array insert pos insert pos insert pos array length diagram illustrates extended inheritance graph bounded circular buffers partially full buffer predicate object omitted circular buffer implementation inherits original buffer object circular buffer object automatically inherit empty buffer full buffer predicate object circular buffer happens states 
empty circular buffer full circular buffer objects need implemented specialized behavior needed 
non empty circular buffer non full circular buffer predicate objects needed override default get put methods non blocking states 
object inherits circular buffer satisfies predicate associated non empty buffer automatically classified non empty circular buffer 
specification object inherits predicate object implicitly places predicate object just immediate parents normal children parents 
example consider empty circular buffer object 
buffer object parent circular buffer object considered inherit empty buffer predicate object 
circular buffer considered inherit empty buffer methods attached circular buffer override methods attached empty buffer 
desired behavior times preferable methods attached predicate objects override methods attached cousin normal objects 
case buffer code simplified somewhat follows object buffer isa collection 
elements length method get buffer remove front elements method put buffer add back elements predicate empty buffer isa buffer buffer empty method get empty buffer 
raise error block caller object cousin share common ancestor unrelated 
circular buffer buffer non empty buffer non full buffer full buffer empty buffer non full circular buffer non empty circular buffer circular buffer object predicate full buffer isa buffer buffer full method put full buffer 
raise error block caller object circular buffer isa buffer 
array insert pos length method get circular buffer var fetch array remove pos remove pos remove pos array length method put circular buffer store array insert pos insert pos insert pos array length non blocking versions get put associated buffer object directly non empty buffer non full buffer partially full buffer predicate objects removed desired 
non blocking get put routines circular buffers similarly moved circular buffer object non empty circular buffer non full circular buffer predicate objects removed 
methods attached empty buffer object considered override circular buffer object sending get circular buffer empty correctly invoke empty buffer implementation 
current semantics predicate objects cecil circular buffer implementation get invoked leading error 
third potential semantics consider predicate object unordered respect cousin objects methods defined cousins mutually ambiguous 
experience predicate objects needed adequately resolve question 
predicate objects fields fields may associated predicate object 
effect reserving persistent space field object classified descendant predicate object 
value stored field persists field inaccessible 
object creation time initial value may provided fields potentially inherited predicate objects fields may visible newly created object 
semantics accessing field attached predicate object governed semantics accessing corresponding accessor methods 
example exploits semantics implement graphical window object expanded 
important states window remembers screen location field named position cases plus mode specific information text window bitmap icon data persists openings window object window isa interactive graphical object var field window false method display window draw window position 
method erase window clear space window 
method move window new position works expanded windows 
erase position new position display predicate expanded window isa window window var field position expanded window upper left field text expanded window method expanded window erase true display predicate window isa window window var field position window lower right field icon window method open window erase false display method create window open position position text icon object isa window false position open window open position position window position text text icon icon window object position fields visible time 
allows display erase move routines send message position part implementation needing know window open closed 
create window method initializes position fields window created position icon visible initially 
position object notation field initialization resolves ambiguity position fields 
statements expressions statement declaration block assignment expression stmt decl block assignment expr expression literal variable named object object constructor expression vector constructor expression closure constructor expression message resend parenthetical subexpression expr binop expr binop expr binop msg unop expr unop expr unop msg dot expr dot expr dot msg simple expr simple expr literal ref expr vector expr closure expr object expr message resend paren expr constructs described resends described section declarations variable declarations described sections 
declaration blocks declaration block unbroken sequence declarations 
names introduced part declarations declaration block visible declaration block remainder scope containing declaration block names go scope scope exits 
name object visible declaration block objects inherit objects defined declaration block methods specialized objects defined declaration block 
similarly methods declared single declaration block mutually recursive need forward declarations 
environments top level declaration block comprising program spread multiple files uw cecil implementation ability attach methods objects defined file important 
variable declarations variable declarations syntax decl var name expr var annotation variable may assigned new value assignment statement 
variable binding constant 
contents variable may mutable 
formal parameters treated constant variable bindings assignable 
initializing expression evaluated context name variable declared variables declared declaration block considered undefined 
avoids potential misunderstandings meaning apparently self referential mutually recursive initializers supporting kind steele variable binding sequence 
variable declarations may appear top level inside method 
ordering variable declarations top level consequently order evaluation initializing expressions defined 
current uw cecil implementation textual ordering variable declarations define ordering evaluating variable initializers 
prefer semantics independent order variable declarations top level top level declarations considered unordered 
possible alternative semantics property include restricting variable initialization expressions simple expressions side effects making issue evaluation order unimportant eliminating variable declarations top level entirely supporting form demand evaluation top level variable initializers akin lazy evaluation semantics field initializers see section 
variable variable named object referenced simply naming variable object ref expr name names objects variables name space 
lexical scoping locate closest lexically enclosing variable object binding name 
assignment statements assignment statements syntax assignment name expr assignment variable assign msg assignment syntax messages left hand side simple name closest lexically enclosing binding name located changed refer result evaluating right hand side expression 
error try assign object formal parameter variable declared var keyword 
left hand side syntax message assignment statement really syntactic sugar message send described section 
literals cecil literal constants integers floating point numbers characters strings literal integer float character string literals immutable objects 
message sends syntax message send follows message msg name exprs exprs expr expr unop msg op name unop expr binop msg binop expr op name binop expr message written forms named prefix form name message followed parenthesized list expressions unary operator prefix form message name listed argument expression infix form message name pair argument subexpressions 
normally message name begins letter written named prefix form message name begins punctuation symbol written unary prefix form infix form 
invoke named message operator invoke operator named message arguments message listed explicitly implicit self argument 
named prefix form method declarations 
name message prefixed underscore leading underscore considered part message name 
example expressions send message expressions send bit message bit bit precedence associativity infix messages specified precedence declarations described section 
semantics method lookup described section 
resends special kind message send described section 
syntactic sugar exists common forms messages 
dot notation allows argument message written dot msg dot expr msg name exprs message takes argument trailing parentheses omitted 
consequently expressions send message expressions send bit message bit bit syntax may suggest argument important fact semantics arguments treated uniformly subset arguments dispatched method lookup time 
syntactic support message sends written assignments 
message appear left hand side assignment statement assign msg lvalue msg expr sugar set msg exprs expr lvalue msg message dot msg unop msg binop msg cases name message sent carry assignment set followed name message lvalue msg expression arguments real message arguments lvalue msg expression followed expression right hand side assignment 
expressions equivalent set foo foo foo expressions set top rectangle rectangle top frequently set accessor methods expressions set note syntactic assignments syntax 
semantically messages 
object constructors new objects created object declarations described section evaluating object constructor expressions 
syntax object constructor expression follows object expr object relation field inits syntax object declaration object name specified 
object constructor expressions analogous object instantiation operations class languages 
difference named objects introduced object declarations anonymous objects created object constructor expressions named objects statically known names 
consequence named objects methods fields attached descendants 
vector constructors vector constructor expression written follows vector expr exprs result evaluating vector constructor expression new immutable object inherits predefined vector object initialized corresponding elements 
closures syntax closure constructor expression follows closure expr closure formals body closure formals closure formal closure formal closure formal name formal names optional referenced syntax identical method declaration method keyword message name replaced symbol intended suggestive symbol 
closure takes arguments prefix may omitted 
evaluated closure constructor produces things new closure object inherits predefined closure object returned result closure constructor expression method named eval anonymous argument specialized newly created closure object remaining arguments listed formal parameters closure constructor expression 
nested method declarations body closure eval method lexically scoped scope active closure created 
nested method declarations eval method globally visible long connected closure object reachable 
closures may invoked lexically enclosing scopes returned 
control structures cecil implemented user level messages closures sole exception loop primitive method described section 
additionally closures achieve effect exceptions multiple results constructs currently omitted cecil language 
closures syntactically verbose built language construct considering various alternatives allowing programmers define syntactic extensions language provide cleaner syntax user defined control structures 
parenthetical subexpressions parenthesized subexpression syntax body method paren expr body body method closure parenthetical subexpression introduces new nested scope may contain statements local declarations 
precedence declarations cecil programmers define infix binary operators 
parsing expressions infix operators problematic precedence associativity infix operators needs known parse unambiguously 
example cecil expression foo bar 
baz 
max relative precedences max infix operators needed associativity 
infix operator 
familiar example cecil expression represents exponentiation parse standard mathematical rules parenthesized follows previous approaches languages restrict infix operators fixed set fixed set precedences 
appropriate cecil set infix messages 
smalltalk defines infix operators equal precedence left associative 
simple rule differs standard mathematical rules leading hard find bugs 
example smalltalk expression returns 
self attempts rectify problem smalltalk specifying relative precedence infix operators undefined requiring programmers explicitly code 
avoids current uw cecil implementation caveats non lifo closures 
see system documentation additional details 
problems smalltalk approach leads parentheses 
example parentheses self code required self exception case binary operator series treating case left associative 
example expression parses expected self 
expression parse backwards self defined 
self uses power exponentiation avoid problems 
expressions illegal self requiring explicit 
standard ml milner allows operator declared prefix called sml infix infix operators declared left right associative 
infix declarations specify precedence level integer binding tightest binding default 
example sml declarations standard infix div mod infix infix infix sml provides special syntax infix operator prefix operator vice versa 
fixity declaration appear declaration appear affect parsing expressions fixity declaration scope 
fixity declarations spread program multiple declarations add independent operators precedence level 
fixity declarations scope override fixity declarations operator enclosing scopes 
disadvantage sml approach supports levels precedence 
possible add new operator higher precedence operator defined level possible squeeze new operator operators adjacent levels 
operators level bind tighter operators lower levels programmer preferred expressions mixing operators completely different applications explicitly parenthesized readability 
precedence associativity declarations cecil cecil allows precedence associativity infix operators specified programmers precedence declarations 
syntax declarations follows prec decl precedence op list associativity precedence associativity left associative right associative non associative precedence op list op list op list op list op name op name example declarations appear part standard prelude cecil precedence right associative exponentiation precedence left associative precedence left associative precedence non associative precedence left associative precedence left associative precedence precedence left associative array indexing default infix operator unique precedence unrelated precedence infix operator non associative 
expressions mixing operators unrelated precedences multiple sequential occurrences operator non associative explicitly parenthesized 
effect precedence declaration declare relationship precedences binary operators specify associativity binary operator 
sml information provided precedence declaration scope declaration declarations operator scope override enclosing scope 
precedence declarations define precedence operator scope 
precedence declaration form precedence bin op bin op associativity bin op bin op bn bin op bin op bin op bin op wn declares bin op belong precedence group group tightly binding precedence groups bin op bi tightly binding bin op ai bin op wi provided bin op belong precedence group bin op wi bin op wi belong precedence group 
bin op form new precedence group 
associativity bin op specified associativity 
absent associativity bin op bin op wi provided non associative 
illustrated example ordering precedence groups may redundantly specified 
cycles tighter binding relation precedence groups allowed 
operators precedence group associativity 
taken precedence declarations form partial order groups infix operators 
parentheses may omitted adjacent infix operators ordered precedence declarations adjacent infix operators precedence group precedence group left right associativity 
parentheses included 
example expression 
parentheses required ordered precedence declarations 
tightly binding parentheses required 
cecil declaration declaration block visible block including textually earlier declarations block 
applies precedence declarations somewhat complicating parsing 
implementation strategy uw cecil system parses expressions involving binary operators list operators operands lists converted traditional parse tree form visible declarations processed 
precedence declarations apply infix message names individual methods 
multiple methods may implement infix message different kinds arguments methods particular name share precedence scope 
method lookup section details semantics multi method lookup discussion motivations assumptions led semantics 
philosophy computation cecil accomplished sending messages objects 
lion share semantics message passing specifies method lookup method lookup rules typically reduce defining search inheritance graph 
single inheritance languages method lookup straightforward 
object oriented languages today including cecil support multiple inheritance allow flexible forms code inheritance subtyping 
multiple inheritance introduces possibility ambiguity method lookup methods name may inherited different paths forcing system programmer determine method run run methods combination 
multiple dispatching introduces similar potential ambiguity absence multiple inheritance methods differing argument specializers applicable uniformly specific 
consequently key distinguishing characteristic method lookup language multiple inheritance multiple dispatching exactly ambiguity problem resolved 
languages resolve ambiguities automatically 
example flavors moon linearizes class hierarchy producing total ordering classes derived class local left ordering superclasses searched ambiguity just single inheritance case 
linearization produce unexpected method lookup results especially program contains errors snyder 
bobrow clos extend linearization approach multi methods totally ordering multi methods prioritizing argument position earlier argument positions completely dominating argument positions 
removes possibility run time ambiguities cost automatically resolving ambiguities may result programming errors 
cecil takes different view ambiguity motivated assumptions expect programmers mistakes program development 
language help identify mistakes mask misinterpret 
experience self leads believe programming errors hidden automatic language mechanisms difficult time consuming find 
experience self encourages strive simplest possible inheritance rules adequate 
apparently straightforward extensions subtle interactions extensions difficult understand chambers 
complex inheritance patterns hinder program evolution method lookup depend program details parent ordering argument ordering usually unclear program text details important particular application 
accordingly simple system multiple inheritance multiple dispatching cecil 
semantics method lookup cecil uses form touretzky inferential distance heuristic touretzky children override parents 
method lookup rules interpret program inheritance graph partial ordering objects partial order corresponds specific object specific object partial order proper descendant ordering objects turn induces analogous ordering set methods specialized objects reflecting methods override methods 
partial ordering methods particular name number arguments method specific method argument specializers equal specific corresponding argument specializer methods argument specializers argument specializer strictly specific corresponding specializer unspecialized argument considered specialized object ancestor objects specialized argument strictly specific unspecialized argument 
ordering methods partial ambiguities possible 
partial ordering methods method lookup straightforward 
particular message send system constructs partial ordering methods name number arguments message 
system throws ordering method argument specializer equal ancestor corresponding actual argument passed message method applicable actual call 
system attempts locate single specific method remaining method partial order applicable methods 
methods left partial order system reports message understood error 
method remains partial order single method overrides system reports message ambiguous error 
exactly method partial order strictly specific methods method returned result message lookup 
examples example consider inheritance graph containing singly dispatched methods moment partial ordering objects graph defines abc specific ab ac ab ac specific methods defined abc specific override methods defined ab ac methods defined ab ac specific override methods defined ab ac objects mutually unordered methods defined ab ac unordered 
message sent abc object implementation formal argument specialized abc object implementation specialized apply method specialized abc specific specialized abc specific abc chosen 
message sent ab object version specialized object chosen version specialized abc specific apply 
message sent abc version formal argument specialized formal specialized ac apply 
partial ordering places ac object ahead object ac version selected 
message sent abc ab ac versions apply 
ab ac single specific object objects mutually incomparable 
system select implementation automatically having chance wrong introducing subtle bug system reports ambiguous message error 
programmer responsible resolving ambiguity explicitly typically writing method child object resends message particular ancestor resends described section 
sends ab ac unambiguous method apply 
ac ab ac abc ab abc ac illustrate rules presence multi methods consider inheritance graph methods dispatched arguments shown twice picture methods ab illustrate multiple methods name number arguments may associated specialized object long arguments specialized differently 
table reports results message sends inheritance graph 
strengths limitations partial ordering view multiple inheritance desirable properties simple 
implements intuitive rule children override parents lesser partial ordering order parents count inheritance links invoke sorts complicated rules 
message invoked method error explanation abc xyz xz xz overrides abc xyz ab ab overrides abc xyz ab xy xy overrides unspecialized ab xy message understood abc specific ab applicable method abc xyz message ambiguous ab overrides xz overrides single specific applicable method abc xyz message ambiguous ac overrides unspecialized xyz overrides unspecialized single specific method xz ab ac abc ab abc ac abc xz ab xy xz xyz xy xyz xz xz ab ab xy ab ab ambiguities masked 
ambiguities reported back programmer message lookup time error get hidden 
programmer included static type declarations system report ambiguity type check time 
form multiple inheritance robust programming changes 
programmers change programs fairly easily system report ambiguities may arise programming errors 
complex inheritance rules tend brittle possibly hindering changes programs exploit intricacies inheritance rules hiding ambiguities reflect programming errors 
cecil partial ordering view multiple inheritance transform inheritance graph prior determining method lookup linearization 
allows programmers reason method lookup inheritance graph write programs 
course may times having priority ordering parents argument positions resolve ambiguity automatically fuss 
situations nice able inform system preferences 
self prioritized multiple inheritance strategy blend ordered unordered inheritance undesirable properties preferring method ancestor child interacts poorly resends dynamic inheritance 
may cecil support akin prioritized multiple inheritance prioritized argument list preferences resort resolving ambiguities ambiguities remain favoring children parents preferences parents argument position considered 
design appears fewer drawbacks self approach clos approach gaining benefits 
alternative approach support explicit declarations method intended override method 
declarations add relations partial order methods potentially resolving ambiguities 
approach advantage operates directly method overriding relationship parent order indirectly affects method overriding relationships 
approach resolve existing ambiguities change existing overriding relationships making easier reason results method lookup 
multiple inheritance fields languages multiple inheritance addition possibility name clashes methods possibility exists name clashes instance variables 
languages maintain separate copies instance variables inherited different classes languages merge named instance variables subclass 
situation simpler cecil access instance variables field accessor methods 
object conceptually maintains space inherited copy field independently names distinct fields name merged automatically 
accesses fields mediated accessor methods normal multiple inheritance rules resolve ambiguities named field accessor methods 
particular method child name self multiple inheritance semantics greatly simplified eliminating prioritized inheritance 
self rules similar cecil self omits children override parents global rule 
effect declaring ambiguous messages abc example section 
field accessor method send directed resend messages described section access contents ambiguous fields 
method lookup lexical scoping methods may declared top level nested inside methods method lookup take account methods specialized methods defined deeply nested scopes 
interaction lexical scoping inheritance significant presence modules described section 
view lexically nested methods cecil nested methods extend inheritance graph defined enclosing scope override 
call porous lexical scoping methods enclosing scope filters nested scope 
performing method lookup message nested scope set methods consideration declared current scope plus methods defined lexically enclosing scopes 
local method name number arguments argument specializers method defined enclosing scope local method shadows replaces method enclosing scope 
additionally object declarations object extension declarations local scope added declarations extensions defined enclosing scopes 
augmented inheritance graph constructed method lookup proceeds scope object method defined 
languages beta kristensen take opposite approach searching matching method scope proceeding enclosing scope 
matching method scope selected specialized method defined enclosing scope 
experience needed judge alternatives preferable 
cecil approach gets advantage distinguishing variable respect lexical scope field treated message sends primarily respect inheritance links 
beta uses syntax access global variables inherited instance variables making semantics construct somewhat complicated 
nested methods achieve effect typecase statement languages including trellis modula nelson harbison 
example test implementation object executing different code case programmer write method test method typecase obj code case inherits obj method typecase obj code case inherits obj method typecase obj code case inherits obj method typecase code default case typecase example obj obj obj may related inheritance hierarchy case specific case chosen 
case applies case specific message understood ambiguous message error result 
results fall semantics method lookup 
nesting typecase methods inside calling method method bodies access variables calling method lexical scoping plus scope temporary typecase methods limited particular method invocation 
eiffel reverse assignment attempt modula narrow operation handled similarly 
method invocation method lookup successful locating single target method error method invoked 
new activation record created formals new scope initialized actuals statements body method executed context new activation record primitive method executed field accessor method executed result method possibly void returned caller 
resends existing object oriented languages allow method override method preserving ability overriding method invoke overridden version smalltalk super clos call method qualified messages operator trellis qualified messages operator self undirected directed resend integrating unqualified super messages qualified messages 
facility allows method defined incremental extension existing method overriding new definition invoking overridden method part implementation overriding method 
facility allows ambiguities message lookup resolved explicitly forwarding message particular ancestor 
cecil includes construct resending messages adapts self undirected directed resend model multiply dispatched case 
syntax resend follows resend resend resend args resend args resend arg resend arg resend arg expr corresponding formal sender unspecialized name undirected resend name specialized formal name named object directed resend name specialized formal purpose resend construct allow method invoke methods resending method overrides 
consequently methods name number arguments resending method argument specializers ancestors resending method argument specializers considered possible targets resend 
invoke overridden method normal prefix message sending syntax changes restrictions syntactically name message keyword resend semantically name message implicitly name sending method 
number arguments message sending method 
specialized formal arguments resending method passed unchanged corresponding arguments resend 
syntactic convenience formals sender passed arguments resend unchanged simple resend keyword argument list sufficient 
semantics resent message similar normal message methods specific resending method partial order methods considered possible matches effect searching upwards inheritance graph find single specific method resending method overrides 
restrictions name number arguments passing specialized objects unchanged ensures methods considered candidates applicable name arguments send 
languages similar restrictions smalltalk requires implicit self argument passed unchanged super send clos call uses name arguments calling method 
example illustrates resends may provide incremental extensions existing methods object colored rectangle isa rectangle field color colored rectangle method display colored rectangle output device color color set right color rectangle resend normal rectangle drawing sugar resend resends may explicitly resolve ambiguities method lookup filtering undesired methods 
required arguments resend specialized formals resending method may symbol name ancestor corresponding argument specializer 
restricts methods considered resulting partial order corresponding argument specializers equal ancestors object named part resend 
illustrate method resolves ambiguity height vlsi cell favor rectangle version height object rectangle field height rectangle object tree node method height tree node height parent object vlsi cell isa rectangle tree node method height vlsi cell resend rectangle model undirected directed resends simplification self rules extended multiple dispatching case 
self rules additionally support prioritized multiple inheritance dynamic inheritance cecil 
self allows name number arguments changed part resend 
cases appears useful able change name message part resend 
example useful able example adapted ungar smith original self ungar smith 
provide access tree node version height method name currently possible cecil 
investigating possible semantics resends name message changed ambiguously inherited methods invoked 
demonstrated self supporting undirected directed resends preferable just supporting directed resends trellis resending code need changed local inheritance graph adjusted 
clos admit possibility ambiguity need support undirected resends call method need directed resends 
files include declarations current uw cecil implementation file 
compiler single file name naming file containing program compile 
include files program file include include declaration global scope include decl include file name file name string included file top decl block effect include declaration include declarations named file current scope 
named file syntax single declaration block 
file inclusion idempotent redundant inclusions file particular scope effect 
pragmas pragmas cecil programmer provide additional information implementation directives cecil implementation 
set recognized pragmas interpretation implementation dependent 
description pragmas supported uw cecil implementation provided documentation 
pragmas written follows pragma expr body pragma uses syntax cecil expression interpretation different implementation dependent 
currently pragmas may appear part cecil declarations 
pragmas able provided declaration expression 
static types cecil supports static type system layered top dynamically typed core language 
type system chief characteristics type declarations specify interface required object stored variable returned method placing constraints representation implementation 
argument specializers method dispatching separate type declarations enabling type system contain special cases type systems traditional single dispatching oriented languages 
code inheritance distinct subtyping common case parallel requires set declarations 
type checker detect statically message ambiguously defined result multiple inheritance multiple dispatching 
rely absence ambiguities correct 
type system check programs statically despite cecil classless object model 
type declarations optional providing partial language support mixed exploratory production programming 
parameterized objects types methods support flexible forms parametric polymorphism complementing inclusion polymorphism supported subtyping 
section describes cecil static type system absence parameterization section extends section cope parameterized objects methods 
section presents major goals type system 
section presents structure type system 
sections describe important kinds declarations provided programmers extend base dynamically typed core language described section 
sections detail type checking rules language 
section describes language supports mixed statically dynamically typed code 
goals static type systems historically addressed concerns ranging program verification improved run time efficiency 
goals conflict goals type system language conflict type systems designed improve efficiency type systems designed allow full reusability statically typed code 
cecil type system designed provide programmer extra support areas machine checkable documentation early detection kinds programming errors 
goal addressed allowing programmer annotate variable declarations method arguments method results explicit type declarations 
declarations help document interfaces abstractions system ensure documentation date respect code documenting 
type inference may useful programming environment tool introducing explicit type declarations untyped programs 
cecil type system intended help detect programming errors program definition time run time 
statically detected errors include message understood message ambiguous uninitialized field accessed 
type system designed verify possibility errors programs guaranteeing type safety possibly reporting errors problem particular execution program 
incomplete inconsistent programs easier type errors considered warnings programmer able run program contains type errors 
dynamic type checking run time final arbiter type safety 
cecil type system designed improve run time efficiency 
object oriented languages goal reusable code odds goal efficiency static type declarations efficiency usually gained expressing additional representational constraints part type declaration artificially limit generality code 
cecil type system strives specification properties objects affect program correctness interfaces objects properties implemented 
achieve run time efficiency cecil relies advanced implementation techniques dean chambers dean dean grove grove 
cecil type system descriptive prescriptive 
semantics cecil program determined completely dynamically typed core program 
type declarations serve documentation partial redundancy checks influence execution behavior programs 
contrast type systems dylan argument type declaration mean run time type check contexts act method lookup specializer contexts 
design cecil type system affected strongly certain language features 
foremost multi methods 
type systems single dispatching languages argument message having control consulting static type determine operations legal 
cecil subset arguments method may specialized leaving unspecialized 
enables cecil easily model procedure non object oriented languages singly dispatched object oriented languages important special cases requires type system treat specialized arguments differently unspecialized arguments 
types signatures type cecil abstraction object 
type represents machine checkable interface implied unchecked behavioral specification objects conform type support type interface promise satisfy behavioral specification 
type may claim subtype case objects conform subtype guaranteed conform supertype 
type checker verifies interface subtype conforms interface supertype system accept programmer promise subtype satisfies implied behavioral specification supertype 
subtyping explicit cecil just implied behavior specifications indicated 
type may multiple direct supertypes general explicit subtyping relationships form partial order 
described subsection additional type constructors plus special types expand type partial order full lattice 
signature cecil abstraction collection overloaded methods specifying interface name sequence argument types result type implied behavioral specification 
interface type defined set signatures mention type argument result types 
example types signatures describe interface lists integers type int list subtypes int collection signature empty int list bool signature length int list int signature int list int void void signature pair int list int list int int void void signature prepend int int list int list types signatures represent contract clients implementors enable message sends type checked 
presence signature allows clients send messages argument types subtypes corresponding argument types signature guarantees type result message subtype result type appearing signature 
message covered signature produce message understood error 
signatures impose constraints implementations methods order guarantees clients 
collection methods implementing signature conforming complete consistent conformance implies method implementing signature unspecialized argument types supertypes corresponding argument types signature result type subtype signature result type conformance cecil version standard contravariance rule singly dispatched statically typed languages 
completeness implies methods handle possible argument types appear run time argument message declared legal signature 
consistency implies methods ambiguous combination run time arguments 
checking completeness consistency subject section 
singly dispatched language type associated set signatures defines interface type 
association relies asymmetry message passing languages receiver argument impacts method lookup 
type checking singly dispatched message type receiver determines set legal operations set associated signatures 
matching signature message understood run time static types remaining message arguments checked static argument types listed signature 
cecil wish avoid asymmetry sort type system 
consequently view signature associated argument types just multi method cecil associated argument specializer objects 
example prepend signature considered part int type int list type 
object oriented languages code inheritance graph subtyping graph joined class subtype class inherits class 
constraint awkward snyder example class supports interface class type wish inherit code 
times class reusing class code considered subtype covariant redefinition commonly occurs eiffel programs example case cook 
increase flexibility expressiveness cecil separates subtyping code inheritance 
types signatures declared independently object representations method implementations 
cases subtyping graphs inheritance graphs parallel requiring programmers define maintain separate hierarchies onerous practical 
simplify specification maintenance graphs cecil programmer specify type representation associated subtyping conformance inheritance relations single declaration 
similarly single declaration specify signature method implementation 
way hope provide benefits separating subtyping code inheritance useful imposing additional costs separation needed 
type signature declarations variable declarations formal arguments results methods closures fields may annotated type declarations 
syntax declarations extended include new declarations decl decl tp decl type ext decl object decl obj ext decl predicate decl disjoint decl cover decl divide decl signature decl method decl field decl precedence decl include decl prim decl subsequent syntax specifications changes specifications described section boldface 
example illustrates extensions object list method empty list bool length signature length list int signature list closure int void void signature pair list list closure int int void void method prepend int list list object inherits cons head tail method copy reverse list list var list nil int prepend representation cons isa list field head cons int field tail cons list type declarations new user defined types introduced type declarations form ignoring parameterization encapsulation aspects tp decl type name type relation type relation subtypes types types type type new type considered subtype types listed subtypes clause 
induced subtype relation defined types partial order contain cycles 
type names interpreted name space distinct objects variables message names 
type object method may named list unambiguously 
representation object declarations new user defined objects introduced representation declarations form ignoring parameterization encapsulation object decl rep role rep kind name relation field inits rep kind representation declares object implementation object declares object type implementation relation subtypes types impl conforms type type subtypes type inherits parents impl inherits impl isa parents impl inherits impl type subtypes type representation roles described section 
representation keyword declaration introduces new object representation 
object inherits objects named inherits clause conforms types named subtypes clause 
mentioned section inheritance graph cycles 
isa clause syntactic sugar subtypes clause inherits clause sugar case inheritance subtyping parallel 
declaration representation cons isa list syntactic sugar declaration representation cons inherits list subtypes typeof list typeof list represents specific type list object conforms typeof legal cecil syntax 
object keyword declaration syntactic sugar pair object representation declaration type declaration 
declaration form object name inherits name name name subtypes name name name sm isa name name name bk syntactic sugar declarations type name subtypes name name name sm typeof name typeof name typeof name bk representation name inherits name name name name name name bk subtypes name object type name potential ambiguity object type names resolved separate name spaces 
new type subtypes types listed subtypes clause types objects isa clause original declaration conform 
new object representation conforms new type inherits object representations listed inherits isa clauses original declaration 
object isa syntactic designed easy specify inheritance subtyping properties object type pair common case code inheritance subtyping parallel 
expect programs object isa declarations type representation inherits subtypes declarations intended relatively rare cases finer control inheritance subtyping required 
object constructor expressions similarly extended representation roles representation kinds subtyping relationships object expr rep role rep kind relation field inits object constructor expression representation keyword object keyword effect presence absence anonymous type immaterial 
representations add new implementation specific operations 
example cons representation defined earlier introduced head tail fields 
able send messages access new features type exist includes appropriate signatures 
cons representation separate type need defined included signatures head tail 
avoid extra step representation declaration object declaration introduces corresponding type 
object declaration type derived representation declaration anonymous 
referenced indirectly typeof internal function specifies semantics isa syntactic section describes sugar 
consequently variables unspecialized formals may declared anonymous type types may declared subtypes anonymous type 
enables object representations defined treated class types programmer control types intended type declarations 
type object extension declarations described section objects extended new inheritance relations defined 
similar fashion types extended new subtyping relations type extension declarations form type ext decl extend type named type type relation syntax object extension declarations extended support augmenting just object representation representation type obj ext decl extend extend kind named object relation field inits extend kind representation extend representation object extend type representation extension uses representation keyword named representation extended appropriate inheritance conformance relations 
representation type named extension updated 
declaration form extend object name inherits name name name subtypes name name name sm isa name name name bk syntactic sugar declarations extend type name subtypes name name name sm typeof name typeof name typeof name bk extend representation name inherits name name name name name name bk subtypes name error exist representation type corresponding name 
allowing types extended externally additional supertypes allows third parties integrate separately developed libraries modifying separate libraries directly hlzle 
signature declarations signatures declared syntax sig decl signature method name arg types type decl arg types arg type arg type arg type name type type decl type names formals signature documentation purposes impact meaning signature effect type checking 
signatures declared field notation follows field sig decl var field signature method name arg type type decl field signature declaration form var field signature name type type syntactic sugar declarations signature name type type signature set name type type void field signature declaration require implementations resulting signatures fields interface looks implemented fields 
var keyword omitted second set accessor signature generated 
implementation method declarations syntax method implementations extended way accommodate static types method decl impl kind method name formals type decl body prim body impl kind method implementation declares method implementation method declares method signature implementation specializer location type decl specialized formal object sugar object object formal parameters method implementation result method implementation explicit type declarations 
implementation keyword declaration introduces new method implementation 
method keyword declaration syntactic sugar method implementation declaration signature declaration 
declaration form method name obj type obj type type body syntactic sugar declarations signature name type type type implementation name obj type obj type type body explained section obj omitted default 
formal method field declaration specified object syntax 
syntax shorthand object typeof object 
field implementation declarations field implementation declarations similarly extended accommodate static types field decl shared var field field kind method name formal type decl expr field kind empty declare accessor method impl sig implementation declare just accessor method implementation implementation keyword declaration introduces field get accessor method implementation set accessor method implementation field declared var keyword 
result type field type second argument set accessor method result type set accessor method void 
plain field keyword field declaration syntactic sugar field implementation declaration field signature declaration 
field declaration form shared 
var 
field name obj type type expr shared 
shared keyword empty var 
var keyword empty syntactic sugar declarations shared 
var 
field implementation name obj type type expr var 
field signature name type type field signature declaration syntactic sugar signature declarations depending var keyword 
type declarations addition allowing formals results methods fields annotated explicit type declarations variable declarations closure arguments results annotated explicit type declarations decl var name type decl expr closure expr closure formals type decl body closure formal name type decl formal names optional referenced result type closure omitted defaulting dynamic described section result type inferred type result expression closure body 
similarly type constant local variable omitted inferred type initializing expression mutable variables global variables explicit types avoid dynamic type checking 
discussion subtyping conformance cecil explicit programmer explicitly declare object conforms type type subtype type 
explicit declarations verified part type checking ensure preserve required properties conformance subtyping 
explicit declarations cecil implicit inference subtyping relations structural subtyping reasons 
provide programmers error checking assumptions objects conform types types subtypes types 
allow programmers encode additional semantic information particular type additional information implied type purely syntactic interface 
benefits desirable part cecil goal supporting production high quality software 
exploratory programming easier programming environment tool infer greatest possible subtype relationships implicit structural subtyping relationships particular object add appropriate explicit subtype declarations automatically 
separating subtyping implementation inheritance increases complexity cecil 
simpler language provide subtyping restrict objects inherit code supertypes trellis takes approach example 
merit clearly separating concepts allowing inheritance code objects legal supertypes 
studies fairly common dynamically typed languages cook 
current cecil design way object legal structural subtype object inherits child overrides method parent restricts argument type declaration relatively rare occurrence 
cecil may eventually support filtering transforming operations part inheritance ability exclude operations rename operations systematically adjust argument types operations create situations object inherit subtype 
types default implementations object representations methods attached 
languages axiom scratchpad ii watt default implementations stored type called category axiom 
axiom method lookup rules complicated possibility methods inherited superclasses categories inheritance subtyping links 
cecil inheritance rules simplified searching inheritance graph 
expect entities declared object form corresponding representation hold default method implementations 
special types type constructors syntax types excluding parameterization follows type named type closure type lub type glb type type just grouping named types types names directly named named type name described section type names resolved name space distinct names variables objects methods 
addition user defined types introduced type object declarations cecil type system includes special predefined types type void result type methods closures return result 
types subtypes void enabling method returns result context required 
type void may declaring result type method closure 
predefined object void type void 
type implicitly supertype types void may method require special operations object 
type implicitly subtype types defining bottom type lattice 
result type closure terminates non local return closure returns caller 
result type primitive loop method returns normally 
appropriate argument type closures called 
special predefined object type 
type dynamic indicate run time type checking 
type declarations omitted dynamic implied exception closure results constant local variable declarations described section 
dynamic type selectively disables static type checking support exploratory programming described section 
closure types type closure described syntax closure type arg types type decl syntax arg types specified signatures section closure type form describes closure eval method signature signature eval closure types related implicit subtyping rules reflect standard contravariant subtyping closure type form subtype closure type form iff supertype corresponding subtype upper bound types upper bound types type lattice notated syntax lub type type type type type type supertype type type subtype types supertypes type type upper bound types useful conjunction parameterized types described section 
greatest lower bound types greatest lower bound types notated syntax glb type type type type type type subtype type type supertype types subtypes type type syntactically greatest lower bound type constructor higher precedence upper bound type constructor 
note greatest lower bound types different named type subtype types 
example type type different type type introduced declaration type type subtypes type type type type subtype type type types subtype type type automatically subtypes type type identical 
reason programmer define type type type type subtypes type type type type subtype type type type type different fact mutually incomparable subtype relation 
types different named types include implicit behavioral specifications implication separate type declarations implied behavioral specifications type type different 
special types greatest lower bound upper bound type constructors serve extend explicitly declared type partial order generated type object declarations full lattice 
object role annotations cecil classless objects run time entities static program structure entities 
objects nil objects created run time object constructor expressions manipulated run time appear arguments messages run time 
concrete objects required signatures types supported corresponding method implementations fields initialized 
contrast objects cons list directly manipulated run time 
help organize programs providing repositories shared methods defining locations type lattice 
return restricted usage objects required fields fully initialized signatures fully implemented 
inform type checker part played object declaration prefixed object representation role annotation rep role inherited named objects allowed incomplete template inherited instantiated uninitialized fields allowed concrete directly usable complete initialized dynamic directly usable static checks role annotations appears list hierarchy object list isa collection template representation cons isa list concrete representation nil isa list objects potentially incomplete objects designed inherited fleshed objects 
objects need signatures fully implemented fields initialized 
example list object required implement signature defined type list implementation operation deferred children 
object may incomplete directly run time appear parent object constructor declaration 
objects similar classes classbased languages 
template objects complete objects suitable direct instantiation object constructor expressions allowed directly value run time 
new method implementations specified anonymous objects signatures specified part type template object required fully implemented 
example cons object required fully implement list operations including 
template objects sent messages run time required fields initialized 
cons object required head tail fields initialized 
template objects analogous concrete classes class languages 
concrete objects complete initialized objects manipulated run time 
template objects signatures implemented addition fields initialized part field declaration part object declaration object constructor expression 
named objects named concrete objects inherited 
child object role revert template 
anonymous concrete objects correspond instances class languages named concrete objects direct analogue feature cecil object model 
object role annotation dynamic omitted object considered fully manipulable programs static checks incomplete implementation signatures uninitialized fields performed 
appropriate checks dynamically messages sent fields accessed 
dynamic objects designed support exploratory programming discussed section 
object constructor expressions create objects run time template annotations allowed object constructor expressions 
object role annotations help document explicitly programmer intended uses objects 
languages provide similar support 
indirectly supports differentiating concrete classes pure virtual functions private constructors 
eiffel supports similar mechanism deferred features classes mechanism 
cecil annotation somewhat flexible approaches object labeled explicitly methods 
declaration useful prevent direct instantiation object method implementations mutually recursive way subclasses expected override methods break recursion 
earlier version cecil fifth annotation unique document fact object unique 
example nil true false annotated unique objects 
exact semantics unique unclear plausible interpretation unique object concrete object parent object constructor expression instantiated copied 
unique objects inherited object declarations useful code inherited 
unique objects removed felt extra language mechanism worthwhile 
template annotation may removed similar reason strictly necessary type checker distinction template objects appears useful documenting programmer intentions 
distinction objects concrete objects crucial able write type check realistic cecil code 
type checking messages section describes cecil type checking rules message sends method declarations 
section describes type checking simpler kinds expressions 
parameterized types described section 
cecil control structures instance variable accesses basic operators implemented message passing messages primary kind expression type check 
message type correct single specific applicable method implementation defined possible argument objects argument message 
directly checking message occurring program methods program cecil check messages set signatures defined argument types message check signature program implemented completely consistently group methods 
signatures intermediary type checking important advantages 
type checking problem simplified dividing separable pieces 
second checking signatures enables interfaces checked conformance completeness consistency independent messages exist program exercise possible argument types 
signatures enable type checker assign blame mismatch implementor client 
message implemented completely error message understood message implemented correctly 
signature absent 
signatures inform type checker programmer intended interfaces abstractions system may report informative error messages 
course missing signature error appropriate message report type checker accurately distinguish message understood alternative 
subsection describes checking messages signatures subsection describes checking signatures method implementations 
checking messages signatures message form name expr expr expr type checks static type type checker uses locate signatures form name type supertype corresponding set applicable signatures empty checker reports message understood error 
message send considered 
determine type result message send type system calculates result type applicable signature 
specific result type computed greatest lower bound result types applicable signatures 
absence type errors greatest lower bound normally correspond result type specific signature 
illustrate consider message copy list static type list list 
types signatures assumed exist type collection type list subtypes collection type array subtypes collection signature copy collection collection signature copy list list signature copy array array signature copy array array applicable list static type list subtype array 
dynamic type list turn conform array run time data structure list array static checker assume ignore signature 
signatures apply copy message considered legal 
type result known list collection 
greatest lower bound list result copy message type list 
method dispatching acceptable signature applicable message 
signatures contracts clients assume signature applicable client assume guarantees type result 
greatest lower bound calculate message result type upper bound signature assumed force 
run time method selected method required honor result type guarantees applicable signatures target method implementation return object conforms result types applicable signatures greatest lower bound signatures 
common practice specific signature result type greatest lower bound list type selected 
checking signatures method implementations type checker ensures signature program possible messages declared type safe signature fact locate single specific method appropriate argument result type declarations current set representation type declarations program 
involves locating methods signature applicable invoked message covered signature ensuring completely consistently implement signature 
precisely signature considered applicable method iff name number arguments exists sequence argument objects inherits specializers method conforms argument types signature 
objects included considering possible argument objects required complete implementations restricted manipulated runtime 
key distinction non objects 
template objects included required fully implement applicable signatures 
method conforms signature iff formal objects inherit formal specializer conform signature corresponding argument type conform formal declared type unspecialized formals constraint amounts requiring formal type supertype signature argument type method result type subtype signature result type 
set methods completely implement signature iff possible sequence argument objects conforms argument types signature exists method set applicable argument objects argument objects inherit method specializers 
set methods consistently implement signature iff possible sequence argument objects conforms argument types signature exists single specific applicable method set 
conformance method signature checked isolation methods signatures program 
presence multi methods possible check individual methods isolation completeness consistency interactions multimethods introduce ambiguities exist multi methods jointly defined program 
type check presence cecil prototype object model object representatives extracted program 
named template concrete dynamic object considered distinct object representative static occurrence object constructor expression considered object representative 
finite number representatives extracted program 
representatives potential run time argument objects testing signature applicable method set methods completely consistently implement signature 
object representative object constructor expression acts proxy objects created run time executing object constructor expression 
object created particular object constructor expression inherits set methods type representative need checked ensure type safety objects created object constructor expression run time 
object representatives analogous concrete classes class language maps self implementation chambers 
conceptually signature type checker enumerates possible message representatives covered signature arguments message representative object representatives conform signature argument types 
efficient algorithm perform checking described chambers leavens 
message representative type checker simulates method lookup checks simulated message locate exactly specific method 
method type checker reports signature implemented incompletely error 
multiple mutually ambiguous methods type checker reports signature implemented inconsistently error 
single specific method message representative 
case type checker verifies argument object representatives conform declared argument types target method declared result type method subtype signature result type 
tests succeed run time messages matching message representative guaranteed execute successfully 
example consider type checking implementation signature signature pair collection collection int int void void type checker collect object representatives conform collection conform int int void 
small system collection conforming object representatives representation nil inherits list representation cons inherits list representation inherits cons representation array inherits collection list collection objects enumerated 
third representative extracted object constructor expression prepend method 
single object representative stands closure object 
applicable object representatives collected type checker enumerates possible combinations object representatives conforming argument types signature construct message representatives 
message representatives pair nil nil closure pair nil cons closure pair nil representation inherits cons closure pair nil array closure pair cons nil closure pair cons cons closure pair array representation inherits cons closure pair array array closure message representative method lookup simulated verify message understood declared argument types respected target method returns subtype signature type 
comparison type systems singly dispatched languages type systems apply contravariant rules argument result types checking overriding method safely invoked place overridden method argument types overriding method supertypes corresponding argument types overridden method result type subtype 
cecil type system directly compare method enforce contravariant redefinition rules compares method applicable signature enforce contravariant rules non specialized arguments 
cecil terms singly dispatched language signature inferred superclass method subclass methods methods applicable signature checked conformance signature 
specialized arguments need obey contravariant restrictions 
type specialized argument method subtype type corresponding argument general method 
violate type safety run time dispatching guarantee method invoked arguments inherit argument specializer static type checker verified objects inherit specializer conform specialized argument type 
unspecialized arguments safely covariantly redefined run time dispatching arguments ensuring method invoked type declaration correct 
singly dispatched languages distinction specialized unspecialized arguments implicitly way treat type receiver 
singly dispatched languages receiver argument omitted signatures compared leaving unspecialized arguments contravariant redefinition rule 
receiver type included explicit argument special treatment allowed differ covariantly 
fact receiver type determines method overrides 
cecil arguments specialized unspecialized requiring distinction explicit 
methods cecil program specialized argument cecil type checking rules reduce traditional singly dispatched language 
multiply dispatched languages support static type systems 
relevant polyglot agrawal kea mugridge 
systems type checking method consistency completeness requires related methods methods generic function polyglot variants function kea available type checker just cecil 
polyglot kea distinguishes subtyping inheritance interfaces implementations 
additionally polyglot kea supports notion classes required completely implemented include notion operation expected implemented subclasses signatures play role cecil 
type checking inherited methods cecil require method re type checked inherited descendant descendant subtype 
feat accomplished verifying descendant objects conform declared type corresponding formal inherited method 
declared type type specializer arise type declaration syntax descendant objects required subtypes specializer 
may constraining 
example consider set bag implementation fragments template object bag isa unordered collection field elems bag list method add bag int void elems cons elems method includes bag int bool elems includes template object set isa unordered collection inherits bag method add set int void includes resend type checker report error set inherits bag subtype violating conformance requirements bag elems add includes methods 
case new type bag object created understood elems set elems messages formal bag add includes methods changed type object bag object field elems bag object list template object bag isa unordered collection bag object method add bag bag object int void elems cons elems method includes bag bag object int bool elems includes template object set isa unordered collection bag object inherits bag method add set bag object int void includes resend programmer go move bag operations bag object 
eventually set simply inherit bag object bag 
situation inheritance links parallel subtyping links need distinguished 
satisfactorily resulting inheritance subtyping graphs parallel may necessary separate inheritance subtyping language 
approach may feasible 
creating intermediate bag object somewhat tedious original code easy read dynamically type safe 
implementation bag written independently control programmer building set 
cases simply reusing implementation bag set convenient 
unfortunately cecil type rules currently prevent simple solution 
alternative simply re type check method inherited object subtype 
notation interpreted indicating sort re type checking done 
re type checking require access part inherited method source code 
alternative relax conformance constraint object inherited overriding method 
example bag add method need rewritten set add method shadows descendant object subtype includes method need rewritten 
resend set add method type incorrect passing argument type set method expecting argument type bag 
alternative close idea encapsulating inheritance clients private inheritance 
consider separation subtyping inheritance coupled desire avoid methods inherited important area 
type checking expressions statements declarations type checking expression statement determines type correct type correct determines type result 
type checking declaration simply checks type sets subtypes bags sets support behavioral specification bags 
client detect difference set bag adding element twice unordered collection testing size collection changed 
correctness 
constructs type checked typing context containing information binding variable object name scope variable declared type indication variable binding assignable constant object role annotation set conformed types 
set inheritance relations currently scope binding type name scope corresponding type set subtyping relations currently scope set signatures currently scope type checking messages set method declarations currently scope type checking resends 
type checking rules expressions follows literal constant type correct 
type result literal constant corresponding predefined type 
name type correct iff name defined typing context exists declaration name earlier scope lexically enclosing scope variable object 
variable type correct type result associated type variable typing context 
object type correct iff object concrete dynamic object type result type named object 
object constructor expression general form role annotation object inherits parent parent subtypes supertype supertype isa parent supertype parent supertype field obj expr field obj expr type correct iff parent name bound non non void non object typing context supertype type current typing context parent supertype name bound non non void non object typing context obj obj names ancestor newly created object absent considered newly created object field names field specialized inherited unambiguously obj ignoring overriding methods shared expr type correct returning object static type subtype type contents field field initialized role annotation template role annotation concrete exist fields specialized inherited newly created object default initial value initialized part object creation expression 
representation keyword may place object keyword effect 
type result object constructor expression new anonymous type subtype supertype types types parent supertype objects 
closure constructor expression general form type type type body type correct iff provided distinct type provided non void type current typing context type provided type current typing context body type correct checked typing context constructed extending current typing context constant variable bindings corresponding type type type result body subtype type provided type omitted type inferred type result body 
type result closure constructor expression form type type type vector constructor expression general form expr expr type correct iff expr type correct static type void 
type result vector constructor expression predefined parameterized type vector instantiated upper bound 
see section information parameterized types 
message expression general form name expr expr type correct iff expr type correct static type void set applicable signatures non empty set signatures current typing context form signature name ir subtype type result message greatest lower bound result types ir applicable signatures 
verifying correctness implementation signatures described subsection 
resend expression general form resend parent expr 
type correct iff arguments expr type correct static type void resend nested textually body method takes number arguments resend check argument type void strictly necessary signature argument type supertype void 
specialized formal parameter formal specialized object th argument resend formal possibly parent formal shadowed local variable name unspecialized formal parameter formal th argument resend parent resend argument form formal parent parent proper ancestor object specializer formal void method lookup simulated message name arguments argument formal unspecialized parent argument resend directed parent suffix notation object specializer formal resending method removed set applicable methods current typing context exactly specific target method located argument type declarations target method supertypes corresponding type result resend expression declared result type target method parenthetical expression form body type correct iff body type correct 
type result parenthetical expression type result body 
rules define type correctness statements assignment statement form name expr type correct iff expr type correct static type expr name bound assignable variable type name current typing context expr subtype name type result assignment statement void 
declaration block type correct iff declarations type correct checked typing context names declaration block available declaration block 
type result declaration block void 
expression statement type correct iff expression type correct static type type result expression statement non local return statement form expr type correct iff expr type correct static type non local return statement nested textually inside body method subtype declared result type type local result non local return 
body method closure parenthetical expression type correct iff statements type correct 
type result body type statement void 
rules define type correctness declarations variable declaration form var name type expr var var empty type correct iff name defined scope type type current typing context expr type correct typing context name variables defined declaration block unbound resulting static type subtype type 
typing context extended include variable binding name type type assignable var var constant 
type declaration form type name subtypes supertype supertype type correct iff supertype type current typing context cycles introduced subtyping graph result declaration 
result declaration typing context extended include type binding name new type subtype supertype types 
representation declaration form role annotation kind name inherits parent parent subtypes supertype supertype isa parent supertype parent supertype field obj expr field obj expr type correct conditions analogous object constructor expression changes objects may named inherits isa clauses template role annotations allowed cycles allowed introduced inheritance subtyping graphs 
typing context extended include object binding name new object role role annotation inherits parent objects parent supertype objects 
kind representation keyword new object conforms supertype types 
kind keyword object typing context extended type binding name new type subtype supertype types new object conforms new type 
type extension declaration form extend type name subtypes supertype supertype type correct iff name bound typing context type void dynamic constraints subtypes clause type declaration satisfied 
result declaration typing context extended reflect type name subtype supertype types 
representation extension declaration form extend kind name inherits parent parent subtypes supertype supertype isa parent supertype parent supertype field obj expr field obj expr type correct iff name bound typing context object void kind object omitted name bound typing context type void dynamic constraints inherits subtypes isa field initialization clauses object representation declaration satisfied field obj initialize fields specialized inherited object extension 
result declaration typing context extended reflect object name inherits parent objects parent supertype objects 
kind representation keyword typing context extended reflect object conforms supertype types 
kind keyword object typing context extended reflect name type subtype supertype types name object conforms name type 
signature declaration form signature name type type type type correct iff provided distinct type type void typing context type type typing context 
typing context extended include corresponding signature 
field signature declaration form var field signature name type type type correct iff type type void typing context type type void typing context 
typing context extended include signature signature name type type var var signature signature set name type type void method implementation declaration general form method kind name obj type obj type type body type correct iff provided distinct type type void typing context obj obj conforms type type type typing context body type correct checked typing context constructed extending current typing context constant variable bindings corresponding type type type result body subtype type typing context extended include declared method implementation 
kind representation typing context extended include signature signature name type type type field implementation declaration general form shared var field kind name obj type type expr type correct iff type type void typing context obj obj conforms type type type void typing context expr provided expr type correct static type subtype type shared shared expr provided 
typing context extended include declared field get accessor method implementation plus set accessor method implementation var var plus get possibly set signature kind representation 
type checking subtyping declarations programmer declares object conforms type subtypes isa clause type system trusts declaration uses checking conformance subtyping 
possible programmer claim wrong object fact faithfully implement interface types supposedly conforms 
case signature implementation checking described section sufficient detect report error additional checking required 
enumerating checking message representatives matching signature defined supertype object question enumerated error detected signature implemented properly object 
object type error reported 
affect running programs object message 
objects allowed incomplete unclear type error really exists 
type checking predicate objects predicate objects intended represent alternative ways implementing object interface 
accordingly possible type check programs predicate objects assumption particular state object affect external interface 
particular guarantee type safety presence predicate objects type checker verify message declared interface object times implementation message inherited object time mutually ambiguous implementations message inherited object tests correspond extending tests completeness consistency method implementations cope presence predicate objects 
set methods inherited object normal objects fixed program definition time type checked standard way 
methods inherited predicate objects pose problem 
predicate objects inherited simultaneously object predicate object known override disjoint method names 
example bounded buffer implementation described section object inherit non empty buffer non full buffer predicate objects predicate objects implement methods name 
similarly implementations message set predicate objects predicate objects inherited message guaranteed understood 
words checker needs know predicate object implies predicate objects mutually exclusive group predicate objects exhaustive 
relationships predicate objects determined rest type checking straightforward 
ideally system able determine relationships automatically examining predicate expressions attached various predicate objects 
predicate expressions cecil run arbitrary user defined code consequently system hard time automatically inferring implication mutual exclusion exhaustiveness 
consequently rely explicit user declarations determine relationships predicate objects system verify dynamically declarations correct 
declaration exists describe predicate object implies isa declaration 
predicate object explicitly inherits object predicate assumed imply second object predicate 
methods child predicate object override ancestor resolving ambiguities 
mutual exclusion exhaustiveness specified declarations form disjoint decl disjoint named objects cover decl cover named object named objects divide decl divide named object named objects named objects named object named object disjoint declaration disjoint object object implies static type checker predicate objects named object inherited simultaneously predicate expressions evaluate true time 
mutual exclusion predicate objects implies type checker concerned predicate objects define methods name inherited object 
illustrate declarations extend earlier bounded buffer example mutual exclusion information disjoint empty buffer non empty buffer disjoint full buffer non full buffer system infer empty buffer full buffer mutually exclusive partially full buffer 
note empty buffer full buffer necessarily mutually exclusive 
cover declaration cover object object object implies object descends object object descend object predicate objects object expected descend object 
exhaustiveness implies object implement message object inheriting object understand message 
example coverage declaration extends bounded buffer predicate objects cover buffer empty buffer partially full buffer full buffer group predicate objects divide abstraction set exhaustive mutually exclusive subcases 
divide syntactic sugar specifying situations easier 
declaration form divide object object object syntactic sugar declarations disjoint object object cover object object object fields accessed solely accessor methods checking accesses fields predicate objects reduces checking legality messages presence predicate objects described 
ensure fields initialized accessed type checker simply checks values fields potentially inherited object initialized declaration field creation object 
mixed statically dynamically typed code cecil major design goals support exploratory programming production programming particular support gradual evolution programs written exploratory style programs written production programming style 
styles benefit object oriented programming pure object model user defined control structures closures flexible interactive development environment 
primary distinction programming styles relates effort programmers want put polishing systems 
programmers exploratory style want system allow experiment partially implemented partially conceived systems minimum construct subsequently systems rapid feedback incomplete potentially inconsistent designs crucial 
production programmer hand concerned building reliable high quality systems wants help system possible checking polishing systems 
partially support programming styles language type declarations type checking optional 
type declarations may omitted argument result local variable 
programs explicit type declarations smaller redundant maximizing exploratory programmer ability rapidly construct modify programs 
program part program matures programmer may add type declarations incrementally evolve system polished reliable production form 
omitted type declarations treated dynamic dynamic may specified explicitly type argument result variable 
expression type dynamic may legally passed argument returned result assigned variable type 
similarly expression type may assigned passed returned variable argument result respectively type dynamic 
approach integrating dynamically typed code statically typed code effect checking type safety statically statically typed expressions interact assuming run time objects resulting evaluating expressions conform types deferring run time checking message sends dynamically typed expression 
consequence semantics dynamic type static type safety expressions broken passing incorrect dynamically typed value piece program 
dynamic type checking catch errors eventually run time type errors occur inside statically typed code code passes type checker 
alternative approach check types dynamically interface dynamically statically typed code dynamically typed value assigned passed returned statically typed variable result system perform run time type check dynamically typed value part assignment 
approach ensure integrity statically typed code run time type errors occur statically typed code labeled type correct typechecker mixed buggy dynamically typed code 
unfortunately approach difficulties 
problem objects defined exploratory mode required include explicit subtyping declarations declarations hinder free flowing nature exploratory programming 
object passed statically typed code run time type check interface fail object declared subtype expected static type 
chosen moment skip run time check interface statically typed code order support statically typed code exploratory code relying dynamic checking message send ensure dynamically typed object supports required operations 
alternative perform form inference subtyping relationships dynamically typed objects incorporated object oriented systems implicit structural subtyping inferred subtyping relationships run time type check 
cecil supports view static type checking useful tool programmers willing add extra annotations programs static efficiently decidable checking techniques ultimately limited power programmers constrained inherent limitations static type checking 
cecil type system designed flexible expressive particular supporting multi methods separating subtype code inheritance graphs supporting explicit implicit parameterization reasonable programs successfully type check statically recognize may reasonable programs awkward write statically checkable way difficult impossible statically type check form 
accordingly error reports prevent user executing suspect code users free ignore type checking errors reported system relying dynamic type checks 
static type checking useful tool complete solution 
parameterization parametric polymorphism practical statically typed languages need mechanism parameterizing objects methods 
mechanism parameterization parametric polymorphism programmers resort multiple similar implementations abstractions list array differ declared type collection elements 
similarly control structures map reused variety argument types 
accordingly cecil supports definition parameterized object representations method field implementations types signatures 
section describes cecil mechanism explicit parameterization 
section introduces cecil mechanism implicit parameterization sections describe aspects feature depth 
section explains interaction parameterized objects method lookup section explains interaction parameterized constructs object method syntactic 
section discusses cecil version bounded polymorphism 
caveat parameterization mechanisms cecil static type system somewhat informally defined details need finishing 
includes refining formalizing parameterization mechanisms 
explicit parameterization cecil allows object type method field signature declarations parameterized sequence types examples illustrate object collection object list isa collection signature list void void concrete representation nil isa list template representation cons isa list field head cons field tail cons list nil method prepend list list concrete object isa cons head tail object table key value isa collection value template object array isa table int method new array size int initial value array concrete object isa array size size initial value initial value type printable array subtypes array printable parameterized declarations formal type parameters syntax type object predicate object method field signature declarations extended allow explicit parameterization follows tp decl type name formal params type relation object decl rep role rep kind name formal params relation field inits predicate decl predicate name formal params relation expr field inits method name msg name formal params op name formal params formal param formal param formal param name number formal type parameters considered part name declared entity 
example multiple objects declared name long declared different numbers formal type parameters 
formal type parameter form name type quantified types subtypes type leading back quote symbol optional 
type upper bound omitted assumed 
similar facilities appear name bounded quantification cardelli wegner constrained genericity meyer 
type parameters scoped declaration type parameters distinct names 
scope type parameter may type declaration instantiating type parameterized type method type parameter subtypes clause context requires statically known type 
cycles allowed dependency graph formal type parameters upper bound types illegal orderings required 
example legal occurrence referring instantiating type second type parameter 
parameterized declaration typechecked isolation independently instantiating clients 
contrast languages modula typechecking parameterized class module general deferred repeated instantiation 
typechecking body parameterized method initialization expression parameterized field assumed variable type declared formal type parameter variable subtype upper bound type parameter 
purposes equivalent assuming variable conforms upper bound type 
instantiating parameterized declarations parameterized entity class entity manipulated directly entity generator function tuple types instantiated entity 
feature interact mixed dynamic static typing number parameters affects execution behavior program violating principle static types affect execution semantics 
number parameters may removed name object method parameters confined optional static type system 
omitted type parameters default dynamic keeping default omitted type declarations 
lower bounds type parameters useful example model case specific closure type required general argument types 
parameterized entity client instantiate actual types parameters point instantiated entity regular entity formal type parameters replaced actual type parameters 
syntax object type messages extended follows allow instantiating parameters provided named object name params named type name params message msg name params exprs dot msg dot expr msg name params exprs params types instantiations parameterized entity actual parameter types name instantiated entity distinct static occurrences array int name instantiated object 
semantics form structural type equivalence patterned clu trellis contrasts languages parameterized entities instantiated explicitly names client code 
parameterized objects types possible inherit directly parameterized object representation subtype directly parameterized type 
possible common inherit instantiation parameterized object subtype instantiation parameterized type 
particularly common idiom parameterized object type inherit subtype parameterized object type instantiated function parameterized object type type parameters 
example object collection object table key value isa collection value template object array isa table int type printable array subtypes array printable method lookup method lookup extended include number explicit parameters candidate methods part method selection process 
message form name type type expr expr zero greater match methods named name explicit formal type parameters formal arguments 
method lookup depend constraints placed legal instantiating types explicit formal type parameters 
example method foo override method foo fact methods legally defined system name number explicit type parameters number arguments argument specializers 
type checking instantiations type check message explicit type parameters signatures matching names number parameters number arguments located 
signature actual type parameters bound formal type parameters signature formal argument types signature compared actual argument types call site 
signature applicable call site actual types subtypes corresponding formal argument types described section 
signature deemed applicable actual type parameters compared upper bounds formal type parameters actual parameters subtypes corresponding upper bounds illegal instantiation error reported 
type check implementation parameterized signature methods name number type parameters number arguments signature collected 
rules conformance completeness consistency section verified modification checking formal argument types method signature occurrences method formal type parameters substituted signature corresponding formal type parameters 
addition upper bound formal type parameter signature subtype corresponding upper bound method kind contravariance requirement type parameter constraints 
instantiations parameterized objects types checked instantiating types subtypes upper bounds corresponding formal type parameters 
tricky verify instantiating type parameter subtype upper bound corresponding formal type parameter formal type parameter upper bound formal type parameter 
case able show statically bounded actual type parameter subtype bounding actual type parameter 
actual types formal type parameters caller relationship may difficult show 
example consider methods method base method client base num int method middle method client middle int num base method requires second type parameter subtype type parameter 
client method satisfies requirement assuming int subtype num 
middle method meet requirement upper bound num known subtype upper bound particular instantiation middle may preserve relationship 
method client illustrates instantiation 
consequently static type checker flag invocation base middle type unsafe 
implicit parameterization explicit parameterization instantiation sufficient programming parameterized objects types frequently inconvenient 
example consider implementation explicitly parameterized pair method method pair cons cons closure void void eval closure head head pair tail tail closure singly dispatched languages face verbosity methods defined class scope parameterized class type parameters 
additionally invocations methods parameterized object head message need specify instantiating parameter derived instantiating parameter distinguished receiver object 
pseudo code representative kind support singly dispatched languages class cons field head field tail list method length int tail length 
code formal type parameter introduced cons class declaration scoped fields methods defined class 
consequently fields methods need explicitly parameterized recursive length call need pass explicit type parameters implied type receiver expression 
regain conciseness parameterization singly dispatched languages supporting multi methods object extensions cecil flexible constructs cecil allows implicit type parameter bindings type declarations formal arguments method field 
implicit type parameters instantiated automatically corresponding type actual argument call site 
binding occurrence implicit type variable indicated prefixing type name back quote character occurrences type variable simply name bound type 
operations parameterized cons objects rewritten implicit type parameters follows template representation cons isa list field head cons field tail cons list nil method pair cons cons closure void void eval closure head head pair tail tail closure method prepend list list concrete object isa cons head tail explicit formal type parameters implicit formal type parameter may bounded type type notation implicit formal parameter quantified types subtypes upper bound default upper bound 
explicit type parameters implicit type parameters scoped entire declaration 
implicit type parameter name distinct implicit explicit type parameters 
explicit type parameters implicit type parameters may type declarations earlier formal arguments prepend method long cyclic dependencies result 
implicit type parameters akin polymorphic type variables languages ml milner 
note type variables ml back quote cecil part type name identifies type binding occurrence opposed simple previously defined type 
implicit type parameters useful parameterized types performing simple calculations argument types compute appropriate result types 
example method describes result type terms argument types method min user defined control structures compute types results types arguments signature condition bool true case false case method condition true true case false case void eval true case method condition false true case void false case eval false case illustrated examples upper bound types implicit type parameters relatively common expressing type method result terms arguments types 
implicit type parameter bindings appear declared type formal parameter variable upper bound type type parameter instantiating parameter parameterized object type augmented extension declaration 
type contain implicit type parameter binding called type pattern 
syntax constructs updated reflect implicit type parameter bindings legal type pattern binding type named type closure type lub type glb type paren type binding type name named type name param patterns closure type arg type ps type decl sig decl signature method name arg type ps type decl field sig decl var field signature msg name formal params arg type type decl arg type ps arg type arg type arg type name type pattern section revise version min sophisticated comparable type 
specializer location type decl specialized formal type decl unspecialized formal named object sugar named obj named obj closure formal name type decl formal names optional referenced type ext decl extend type named type type relation obj ext decl extend extend kind named object relation field inits named object name param patterns type decl type pattern formal param name type pattern param patterns type patterns type patterns type pattern type pattern matching type patterns type method formal contains binding occurrence implicit type parameter type form system responsible automatically inferring right instantiating actual type call method 
bound implicit type parameters just explicit type parameters 
matching parts message sends compared signatures may contain implicit type parameters method implementations compared signatures may implicit type parameters 
case easier requires matching regular type type pattern second case requires ability compare patterns 
describe somewhat informally process matching type type pattern precise descriptions processes remain 
method formal type patterns general formal argument type patterns form type param param may zero 
prefix omitted fresh type variable supplied represent type argument 
formal parameter considered associated implicit type variable bound dynamic type corresponding actual 
type 
upper bound omitted defaults 
type variable formal bound dynamic type actual static type actual 
typechecking caller static type actual known situation modeled treating type actual fresh type variable known subtype static type computed argument 
normally distinction static dynamic type important situations 
particular corresponding type variable upper bound type variable section great difference static dynamic type 
point discussed section 
upper bound type patterns upper bound type formal explicit implicit type parameter parameterized parameter type may contain implicit type binding upper bound types type patterns 
general param form formal type type param param formal type type 
upper bound omitted defaults 
formal type leading prefix omitted 
important semantic distinction parameter form type 
parameter form type 
prefix omitted argument types matching type pattern parameters match type 
exactly parameters form type matching types need subtype type 
illustrate distinction consider methods method array string void 
method array method takes argument subtype array string object satisfies interface array string 
particular array supports store operation value type string able stored array second method places different constraints argument 
takes array things type subtype string 
value type array string string subtype string legal argument second method 
argument legal method mutable arrays mutable strings subtype mutable arrays generic strings generic string safely stored array mutable strings 
second method value type stored safely argument array 
deciding exact form parameterized type declaration subtle need gather experience language assess programmers able pick appropriate type declaration 
type inference help suggest type method implementation 
matching algorithm method implicit type parameters invoked system binds explicit type parameters corresponding actual type parameters formal declared type prefix binds type parameter dynamic type corresponding actual argument 
system attempts match actual explicit type parameter actual argument dynamic type corresponding upper bound type type param param may zero 
upper bound type variable bound method header checking upper bound constraint deferred type variable bound 
system searches supertypes locate form type ptype ptype head type number parameters additional constraint param simple type prefix ptype param finding matching types upper bound system binds type variables parameter param prefix binding bound ptype system recursively matches ptype upper bound may bind additional type parameters 
formal parameter upper bound type variable checked 
matches fail type error results 
matching process subsumes subtyping checks upper bounds types embedded type variable bindings matching process reduces simple subtyping check 
example consider code object printable signature print printable void object number isa printable object collection signature collection closure void void method print collection print print print print method expand tabs return copy tab characters replaced spaces object list isa collection concrete representation nil isa list template representation cons isa list object table key value isa collection value object indexed isa table int template object array isa indexed template object string isa indexed char message print sent object dynamic type cons number print method defined collection 
dynamic type cons number matched pattern collection bind implicit type parameter supertype graph cons number searched type form collection 
search locate type collection number binding type number 
system verifies binding subtype upper bound printable 
hand message expand tabs sent object dynamic type string method defined collection char 
dynamic type string matched static formal argument type collection char 
match succeed string declared subtype collection char implicit type parameter bound string 
illegal type variable bound particular scope method list explicit type parameters types formals 
illegal bound type variable parameter upper bound type type variable bound matching process 
implies uses type variable parameters occur greater depth binding occurrence type variable 
matching process forms heart semantics implicit type parameters needs formalized clearer algorithmic way 
static vs dynamic matching run time dynamic type actual argument compute instantiation implicitly bound type parameters 
static type checking type checker know dynamic type arguments 
fortunately static type checker perform similar matching process static types arguments call verify type correctness call compute static type result 
static checker uses type variables stand dynamic types arguments call type variables statically known subtypes static type arguments 
matching process succeeds static type variables match guaranteed succeed run time 
usually distinction dynamic static type unimportant 
example simple min method defined caller know type result subtype upper bound dynamic types arguments 
static knowledge arguments dynamic type subtype particular static type caller infer static knowledge result subtype static type 
static type information implies dynamic type expression subtype static type calculating static approximations implicitly bound type variables type checker doing 
circumstances distinction instantiating type parameter dynamic type versus static type important 
implicitly bound type parameter normal type declaration upper bound type legal actual parameters known equal subtypes implicitly bound type variable 
example min rewritten follows method min second argument required subtype dynamic type argument 
requirement quite difficult guarantee statically probably programmer meant 
type parameters usually directly type declarations bound instantiating parameter parameterized type method method store array index int value void store value index th element array bound type elements array specified array created usually value argument known subtype type call site just extracted array similar type 
distinction dynamic types static types instantiation appears instantiating parameterized object 
example way write new array method method new array size int initial value array concrete object isa array size size initial value initial value initial value dynamic type array returned type instantiating value 
fetch store operations defined arrays array able contain elements subtypes dynamic type initial value 
usually restrictive 
correct problem real method create new array explicitly parameterized desired type elements method new array size int initial value array concrete object isa array size size initial value initial value instantiations parameterized objects record instantiating types part dynamic runtime state 
instantiating types determine subtyping relation object matching parameterized object type type pattern form type type 
constraints supertype graphs matching process matching dynamic type static type declaration containing implicit type parameter bindings depends locating single specific binding type 
may possible additional constraints 
example declaration concrete object strange isa collection int collection string strange object sent message type matched type pattern collection 
collection int collection string match system needs locate single type bind variable binding int string reasonable type error result strange subtype collection int string relationship explicitly declared 
avoid sort problem method invocation time objects strange disallowed 
object declaration legal specific instantiation parameterized supertypes 
check type checking object declaration constructor expression 
matching bounded formal type parameters instantiating parameterized type binding occurrence implicit type parameter upper bounds specified declaration parameterized type inherited automatically bound type variable 
example hash tables require keys template object hash table key isa collection value methods defined hash tables bind type parameters types keys values table method fetch hash table key value key key value 
hash tables take keys type checking body fetch method type checker assume key type variable subtype 
implicit type parameters extension declarations extension declaration augment instance parameterized type collection instances implicit type parameter 
example declaration extends single instance parameterized type extend array char subtypes string declaration extends collection related types extend collection isa printable extend parameterized type just instances extension declaration updates instances extend list subtypes variable length collection parameterized objects method lookup method attached parameterized object group instances parameterized object single instance 
form instantiating type pattern determines scope method implementation 
example method attached parameterized object instances parameterized object parameter parameterized object universally quantified method length cons int 
attach method subset instances bounded implicit type variable instantiating parameter method hash cons instantiating type contains implicit type parameter bindings method attached particular instance parameterized object method cons char cons char 
multiple method implementations name defined parameterized object different degrees quantification method print collection void 
method print collection method print collection method print collection char void 
issue method invoke arises 
reasonable choice declare redundant method implementations ambiguous print method argument defined collections characters 
alternative semantics choose specific matching method implementation method specific associated subset instances 
little experience attaching multiple versions method different subsets parameterized types initially selected conservative position allowing single version method provided instance parameterized type declarations illegal 
parameterization syntactic desugaring parameterized object declaration implied representation type declarations parameterized formal type parameters 
similarly method declaration desugared implied implementation signature declarations explicit type parameters formal argument types including implicit type parameter bindings 
example declarations object collection method print collection method expand tabs object table key value isa collection value object indexed isa table int template object array isa indexed method new array size int initial value array 
syntactic sugar declarations type collection representation collection subtypes collection signature print collection implementation print collection signature expand tabs implementation expand tabs type table key value subtypes collection value representation table key value inherits collection value subtypes table key value type indexed subtypes table int representation indexed inherits table int subtypes indexed type array subtypes indexed template representation array inherits indexed subtypes array signature new array int array implementation new array size int initial value array 
bounded polymorphism motivation section min method defined follows method min type comparable defined follows object comparable signature comparable comparable bool method comparable comparable bool signature method method comparable comparable bool method comparable comparable bool numbers declared comparable follows extend number isa comparable declaration pair numbers arguments min method 
state collections comparable things comparable extend collection isa comparable unfortunately declarations appear cecil program require numbers compared collections numbers 
subtyping declaration min method constrains single object 
need case able describe objects come related types arguments min subtypes number subtypes collection type instantiated related types 
bounded polymorphism singly dispatched languages bounded polymorphism canning cook supports parameterization upper bound constraint type parameter function type parameter 
enables parameterized types describe patterns types necessarily subtypes 
versions bounded polymorphism appeared languages emerald black hutchinson axiom scratchpad ii watt strongtalk bracha griswold bench 
singly dispatched language bounded polymorphism comparable type defined follows class comparable signature method bool signature method method bool method bool comparable types declared subtypes instances parameterized type extend num isa comparable num extend collection isa comparable collection functions polymorphic comparable types written explicit parameterization follows method min seemingly recursive nature explicit type parameter collection min problem 
type form type actual instantiating type parameter bound type variable type checked type instantiated type bound example call min num bound num system checks num subtype comparable num holds 
bounded polymorphism cecil cecil bounded polymorphism needs extended support multi methods implicit type parameters 
straightforward translation parameterized comparable class cecil introducing explicit formal parameter implied self argument lead declarations object comparable signature comparable bool method comparable bool signature method method comparable bool method comparable bool unfortunately definitions operations comparable objects asymmetric argument determines instantiating type comparable constrains type second argument 
contrary cecil philosophy treating arguments symmetrically 
additionally body method typecheck signature defined 
revised implementation comparable treats arguments uniformly object comparable signature comparable comparable bool method comparable comparable bool signature method method comparable comparable bool method comparable comparable bool unfortunately legal cecil binds type variable twice scope 
facility legal semantics system find single specific type bind enables formal type patterns match mixed type comparisons correctly 
system locate single type argument comparable types instantiated 
case comparing integers reals common type num 
similar fashion multiple bindings type variable allowed min written implicit type parameters method min definition min convenient earlier definition require caller provide explicit type parameter 
kinds non linear type patterns appear resolve problems types comparable investigating feasibility extending cecil support 
bounded polymorphism multiple types type comparable self recursive sense parameter type link types arguments operations 
general case involves mutually recursive types 
example consider simplified model view framework model view able refer invoke operations 
instances model view framework drawing model drawing view able invoke specific operations loss type safety 
define framework exploit bounded style parameterized implementation strategies 
code shows generic model view framework defined object model field views model set new set method register view model view void views add view method update model void views update object view field model view signature update view void model view parameterized type model view 
formal parameters bounded seemingly recursively defined instances model view types 
discussed problem results recursive nature type variables bound actual parameters upper bounds checked 
parameterizing model view type corresponding upper bound code parameterized model view parameterized actual type instantiation framework 
example code instantiates generic framework construct bitmap drawing model view template object drawing isa model drawing drawing view field bitmap drawing bitmap method set pixel drawing pos position value color void bitmap pixel pos value views drawing view update pixel pos value template object drawing view isa view drawing drawing view method update drawing view void screen plot model bitmap method update pixel drawing view pos position value color void screen plot pixel pos value method new drawing view drawing drawing view concrete object isa drawing view model gail murphy suggesting problem 
drawing drawing view add new operations need called type 
parameterizing model done type views field drawing known statically set subtypes drawing view 
knowledge allows set pixel operation drawing invoke update pixel operation generating static type error requiring dynamic typecase narrow operation 
similarly way view parameterized model field child drawing view known statically refer subtype drawing allowing update operation drawing view access bitmap field model statically type safe manner 
modules object oriented methods encourage programmers develop reusable libraries code 
multi methods pose obstacles smoothly integrating code developed independently 
singly dispatched systems classes subclass common class included program possible incompleteness inconsistency result 
additional expressiveness flexibility multi methods creates new pitfalls integration 
encapsulation modularity multi methods related problem 
enable easier program reuse maintenance desirable encapsulate data structure implementation 
multiply dispatched language achieving encapsulation straightforward data type language clu singly dispatched object oriented language smalltalk 
adt singly dispatched languages direct access object representation limited statically determined region program 
earlier approach encapsulation cecil suffered problem privileged access gained writing methods specialized desired data structures chambers 
cecil module system designed support integration separately developed code encapsulation modular design 
system restrict access parts implementation bounded region program text preserving flexibility multi methods 
individual modules reasoned typechecked isolation modules explicitly imported 
modules extend existing modules subclasses subtypes augmenting multi methods 
conflicts arise independent extensions resolved resolving modules extend conflicting modules 
simple check presence necessary resolving modules needed link time guarantee type safety 
chambers leavens describe cecil module system detail chambers leavens 
syntax declarations extended support modules follows decl module decl import decl decl tp decl type ext decl object decl obj ext decl predicate decl disjoint decl cover decl divide decl signature decl method decl field decl precedence decl include decl prim decl privacy public protected private module decl privacy module module name extension friendship decl extension extends module names friendship friend module names module names module name module name module name name import decl privacy import friend module names declarations optional privacy annotation allowed 
precise semantics modules development 
related cecil builds done self programming language ungar smith hlzle 
self offers simple pure classless object model state accessed message passing just methods 
cecil extends self multi methods copy initialize data slots lexically scoped local methods fields object extensions static typing module system 
cecil simpler method lookup encapsulation rules considering single dispatching case 
cecil model object creation different self 
cecil incorporate dynamic inheritance interesting features self predicate objects cecil structured restricted alternative dynamic inheritance 
freeman benson independently developed proposal adding multi methods self 
common loops bobrow clos bobrow gabriel incorporate multi methods dynamically typed class object oriented extensions lisp 
method specializations clos class argument object value 
significant difference cecil design philosophy clos predecessors cecil multiple inheritance multiple dispatching rules unordered report ambiguities source program message errors clos left right linearization inheritance graph left right ordering argument dispatching serves resolve message ambiguities automatically potentially masking real programming errors 
feel strongly programmer aware potential ambiguities automatic resolution ambiguities easily lead obscure errors programs 
cecil offers simpler purer object model optional static type checking encapsulation 
clos predecessors include extensive support method combination rules reflective operations kiczales cecil 
dylan apple new language viewed clos scheme language common lisp 
dylan similar clos respects described dylan accesses state messages 
dylan supports form type declarations checked statically parameterized treated argument specializers type declarations cecil argument specializers argument type declarations distinct 
polyglot clos language static type system agrawal 
type system polyglot distinguish subtyping code inheritance classes types polyglot support parameterized parametrically polymorphic classes methods support methods signatures 
check consistency multimethods generic function interfaces multi methods generic function available type check time 
requirement similar cecil program available type check time guarantee multi methods mutually ambiguous set argument objects 
kea higher order polymorphic functional language supporting multi methods mugridge 
polyglot object oriented languages inheritance subtyping kea unified 
kea type checking multi methods similar cecil multi methods complete consistent 
appears kea notion methods 
leavens describes statically typed applicative language supports multi methods run time overloading declared argument types methods leavens leavens weihl 
designed primarily vehicle research formal verification programs subtyping behavioral specifications consequently omits theoretically unnecessary features important practical programming inheritance implementation mixed static dynamic type checking mutable state 
theoretical treatments multi methods pursued ghelli ghelli castagna castagna castagna pierce turner pierce turner pierce turner 
environment supports subdivided methods value parameter method global variable helps select alternative method implementations harrison ossher 
method subdivided particular values parameter global variable class supporting clos eql specializers 
number languages including stroustrup ellis stroustrup haskell hudak support static overloading function arguments overloading resolved compile time static types arguments dynamic types required true multiple dispatching 
trellis supports expressive safe static type system schaffert schaffert 
cecil parameterized type system includes features trellis implicitly bound type variables uniform treatment constrained type variables 
trellis restricts inheritance hierarchy conform subtype hierarchy supports isa style superclasses 
pool statically typed object oriented language distinguishes inheritance implementation inheritance interface america van der linden 
pool generates types automatically class declarations cecil allows programmer restrict objects may types allows programmer define explicit types separate class declarations feature cecil provide 
subtyping implicit structural pool possible legal subtype relationships assumed force 
programmers may add explicit subtype declarations documentation aid verify expectations 
unusual aspect pool types classes may annotated properties simple identifiers may capture distinctions behavior expressed purely syntactic interface 
drawbacks implicit subtyping 
emerald classless object oriented language static type system black hutchinson hutchinson black hutchinson 
emerald multiple dispatching fact include support inheritance implementation 
types emerald arranged subtype lattice 
known owl trellis owl 
rapide mitchell extension standard ml modules milner subtyping inheritance 
rapide support multi methods relies implicit subtyping design goals rapide similar cecil 
languages support means distinguishing subtyping inheritance 
languages include theta day java sun sather omohundro 
theta additionally supports enhanced clu clause mechanism provides alternative bounded polymorphism 
private inheritance supports kind inheritance subtyping 
languages support form mixed static dynamic type checking 
example clu liskov liskov allows variables declared type 
expression may assigned variable type assignments expression type expression type explicitly coerced parameterized force procedure 
cedar supports similar mechanism ref type teitelman 
modula retains type includes operations including narrow typecase produce precisely typed value type nelson harbison 
cecil provides better support exploratory programming languages source code overhead dynamic typing variable type declarations simply omitted coercions dynamically typed expressions statically typed variables implicit 
hand cecil subtle expression statically typed dynamically typed 
cecil pure object oriented language intended support rapid construction reliable extensible systems 
incorporates relatively simple object model multiple dispatching supports form encapsulation data type programming style 
cecil object model static type system describes interfaces objects representation 
cecil type system distinguishes subtyping code inheritance uses notation strives minimize burden programmer maintaining separate object type relationships 
type system supports explicitly implicitly parameterized types methods precisely capture relationships argument types result types convenient concise way 
cecil supports exploratory programming style production programming style part allowing program mature incrementally dynamically typed system statically typed system 
areas cecil design subject current including details parameterization mechanism static type system precise semantics module system formal specification static dynamic semantics language 
acknowledgments cecil language design presentation document benefitted greatly discussions members self group including david ungar urs hlzle bay wei chang ole agesen randy smith john maloney lars bak members kaleidoscope group including alan borning bjorn freeman benson michael sannella gus lopez denise draper cecil group including claudia chiang jeff dean charles garrett dave grove litvinov shmatikov stuart williams including peter deutsch eliot moss john mitchell jens palsberg doug lea rick mugridge john chapin barbara lerner christine 
gary leavens collaborated author refine static type system devise module system develop efficient typechecking algorithm 
claudia chiang implemented version cecil interpreter self 
stuart williams augmented interpreter type checker monomorphic subset cecil type system 
jeff dean greg defouw charles garrett dave grove joy litvinov huynh shmatikov ben teitelbaum tina wong worked various aspects vortex optimizing compiler object oriented languages uw cecil implementation 
conversation danny bobrow david ungar oopsla provided original inspiration cecil language design effort 
research supported national science foundation research initiation award contract number ccr nsf young investigator award contract number ccr university washington graduate school research fund office naval research contract number gifts sun microsystems ibm canada xerox parc edison design group pure software 
information cecil language vortex optimizing compiler projects available www cs washington edu research projects cecil anonymous ftp cs washington edu pub chambers 
agrawal rakesh agrawal linda demichiel bruce lindsay 
static type checking multi methods 
oopsla conference proceedings pp 
phoenix az october 
published sigplan notices november 
america van der linden pierre america frank van der linden 
parallel object oriented language inheritance subtyping 
oopsla ecoop conference proceedings pp 
ottawa canada october 
published sigplan notices october 
andersen andersen 
system design composing structures interacting objects 
ecoop conference proceedings pp 
utrecht netherlands june july 
published lecture notes computer science springer verlag berlin 
apple dylan object oriented dynamic language 
apple computer april 
black andrew black norman hutchinson eric jul henry levy 
object structure emerald system 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
black hutchinson andrew black norman hutchinson 
typechecking polymorphism emerald 
technical report tr department computer science university arizona december 
bobrow daniel bobrow kenneth kahn gregor kiczales larry masinter mark stefik frank 
merging lisp object oriented programming 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
bobrow bobrow demichiel gabriel keene kiczales moon 
common lisp object system specification 
sigplan notices special issue september 
borning borning 
classes versus prototypes object oriented languages 
proceedings fall joint computer conference pp 
dallas tx november 
bracha griswold gilad bracha david griswold 
strongtalk typechecking smalltalk production environment 
oopsla conference proceedings pp 
washington september 
published sigplan notices october 
canning peter canning william cook walter hill john mitchell william 
bounded quantification object oriented programming 
proceedings conference functional programming languages computer architecture 
cardelli wegner luca cardelli peter wegner 
understanding types data abstraction polymorphism 
computing surveys pp 
december 
castagna giuseppe castagna giorgio ghelli giuseppe longo 
calculus overloaded functions subtyping 
proceedings acm conference lisp functional programming pp 
san francisco june 
published lisp pointers 
castagna giuseppe castagna 
covariance contravariance conflict cause 
acm transactions programming languages systems pp 
may 
chambers craig chambers david ungar lee 
efficient implementation self dynamically typed object oriented language prototypes 
oopsla conference proceedings pp 
new orleans la october 
published sigplan notices october 
published lisp symbolic computation kluwer academic publishers june 
chambers craig chambers david ungar bay wei chang urs hlzle 
parents shared parts inheritance encapsulation self 
lisp symbolic computation kluwer academic publishers june 
chambers ungar craig chambers david ungar 
making pure object oriented languages practical 
oopsla conference proceedings pp 
phoenix az october 
published sigplan notices october 
chambers craig chambers 
design implementation self compiler optimizing compiler object oriented programming languages 
ph thesis department computer science stanford university march 
chambers craig chambers 
object oriented multi methods cecil 
ecoop conference proceedings pp 
utrecht netherlands june july 
published lecture notes computer science springer verlag berlin 
chambers craig chambers 
cecil language specification rationale 
technical report department computer science engineering university washington march 
chambers craig chambers 
predicate classes 
ecoop conference proceedings pp 
kaiserslautern germany july 
published lecture notes computer science springerverlag berlin 
chambers leavens craig chambers gary leavens 
typechecking modules multimethods 
oopsla conference proceedings pp 
portland october 
published sigplan notices october 
expanded revised version appear acm transactions programming languages systems 
chang ungar bay wei chang david ungar 
experiencing self objects object artificial reality 
unpublished manuscript 
cook cook 
proposal making eiffel type safe 
ecoop conference proceedings pp 
cambridge university press july 
cook william cook walter hill peter canning 
inheritance subtyping 
conference record th annual acm symposium principles programming languages san francisco ca january 
cook william cook 
interfaces specifications smalltalk collection classes 
oopsla conference proceedings pp 
vancouver canada october 
published sigplan notices october 
day mark day robert gruber barbara liskov andrew meyers 
subtypes vs clauses constraining parametric polymorphism 
proceedings acm conference object oriented programming systems languages applications oopsla pp 
austin tx october 
dean chambers jeffrey dean craig chambers 
better inlining decisions inlining trials 
proceedings acm symposium lisp functional programming pp 
orlando fl june 
published lisp pointers july september 
dean jeffrey dean craig chambers david grove 
selective specialization objectoriented languages 
proceedings sigplan conference programming language design implementation pldi la jolla ca june 
dean jeffrey dean david grove craig chambers 
optimization object oriented programs static class hierarchy analysis 
proceedings european conference object oriented programming ecoop denmark august 
ellis stroustrup margaret ellis bjarne stroustrup 
annotated manual 
addison wesley reading ma 
freeman benson bjorn freeman benson 
proposal multi methods self 
unpublished manuscript december 
gabriel richard gabriel jon white daniel bobrow 
clos integrating objectoriented functional programming 
communications acm pp 
september 
ghelli giorgio ghelli 
static type system message passing 
oopsla conference proceedings pp 
phoenix az october 
published sigplan notices november 
goldberg robson adele goldberg david robson 
smalltalk language implementation 
addison wesley reading ma 
goldberg adele goldberg 
smalltalk interactive programming environment 
addisonwesley reading ma 
grove david grove jeffrey dean charles garrett craig chambers 
profile guided receiver class prediction 
proceedings acm conference object oriented programming systems languages applications oopsla austin tx october 
grove david grove 
impact interprocedural class analysis optimization 
proceedings cascon pp 
toronto canada november 
brien daniel patrick brien 
types inheritance objectoriented languages 
technical report dec tr digital equipment april 
harbison samuel harbison 
modula 
prentice hall englewood cliffs nj 
harrison ossher william harrison harold ossher 
subdivided procedures language extension supporting extensible programming 
proceedings international conference computer languages pp 
new orleans la march 
harrison ossher william harrison harold ossher 
subject oriented programming critique pure objects 
oopsla conference proceedings pp 
washington september 
published sigplan notices october 
hlzle urs hlzle bay wei chang craig chambers ole agesen david ungar 
self manual version 
unpublished manual february 
hlzle urs hlzle craig chambers david ungar 
optimizing dynamically typed objectoriented programming languages polymorphic inline caches 
ecoop conference proceedings pp 
geneva switzerland july 
hlzle urs hlzle craig chambers david ungar 
debugging optimized code dynamic deoptimization 
appear proceedings sigplan conference programming language design implementation san francisco ca june 
hlzle urs hlzle 
integrating independently developed components object oriented languages 
ecoop conference proceedings pp 
kaiserslautern germany july 
published lecture notes computer science springer verlag berlin 
hudak paul hudak philip wadler arvind brian boutel jon fairbairn joseph fasel kevin hammond john hughes thomas johnsson dick kieburtz nikhil simon peyton jones mike reeve david wise jonathan young 
report programming language haskell version 
unpublished manual april 
hutchinson norman hutchinson 
emerald object language distributed programming 
ph thesis university washington january 
hutchinson norman hutchinson raj andrew black henry levy eric jul emerald programming language report 
technical report department computer science university washington october 
ingalls daniel ingalls 
simple technique handling multiple polymorphism 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
richard robert 
axiom scientific computing system 
springerverlag 

kiczales gregor kiczales james des daniel bobrow 
art meta object protocol 
mit press cambridge ma 
kristensen kristensen ole lehrmann madsen mller pedersen nygaard 
beta programming language 
research directions object oriented programming mit press cambridge ma 
lalonde wilf lalonde dave thomas john pugh 
exemplar smalltalk 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
leavens gary todd leavens 
verifying object oriented programs subtypes 
ph thesis mit 
leavens weihl gary leavens william weihl 
reasoning object oriented programs subtypes 
oopsla ecoop conference proceedings pp 
ottawa canada october 
published sigplan notices october 
lieberman henry lieberman 
prototypical objects implement shared behavior objectoriented systems 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
lieberman henry lieberman lynn andrea stein david ungar 
treaty orlando 
addendum oopsla conference proceedings pp 
orlando fl october 
published sigplan notices may 
liskov barbara liskov alan snyder russell atkinson craig schaffert 
abstraction mechanisms clu 
communications acm pp 
august 
liskov barbara liskov russell atkinson toby bloom eliot moss craig schaffert robert scheifler alan snyder 
clu manual 
springer verlag berlin 
meyer bertrand meyer 
genericity versus inheritance 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
meyer bertrand meyer 
object oriented software construction 
prentice hall new york 
meyer bertrand meyer 
eiffel language 
prentice hall new york 
milner robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge ma 
mitchell john mitchell 
extension standard ml modules subtyping inheritance 
conference record acm symposium principles programming languages williamsburg va january 
moon david moon 
object oriented programming flavors 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
mugridge mugridge hosking 
multi methods statically typed programming language 
technical report department computer science university auckland 
ecoop conference proceedings geneva switzerland july 
nelson greg nelson editor 
systems programming modula 
prentice hall englewood cliffs nj 
omohundro stephen omohundro 
sather specification 
unpublished manual june 
pierce turner benjamin pierce david turner 
statically typed multi methods partially types 
unpublished manuscript october 
pierce turner benjamin pierce david turner 
object oriented programming recursive types 
conference record th annual acm symposium principles programming languages january 
rees clinger jonathan rees william clinger editors 
revised report algorithmic language scheme 
sigplan notices december 
francois 
safe run time overloading 
conference record th annual acm symposium principles programming languages pp 
san francisco ca january 
philip 
type system computer algebra 
international symposium symbolic algebraic computation 

schaffert craig schaffert cooper carrie 
trellis object environment language manual 
technical report dec tr november 
schaffert craig schaffert cooper bruce mike kilian carrie 
trellis owl 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
snyder alan snyder 
encapsulation inheritance object oriented programming languages 
oopsla conference proceedings pp 
portland september 
published sigplan notices november 
steele guy steele jr common lisp 
digital press 
stroustrup bjarne stroustrup 
programming language 
addison wesley reading ma 
sun sun microsystems 
java language specification 
unpublished manual may 
teitelman warren teitelman 
cedar programming environment midterm report examination 
xerox parc technical report csl june 
touretzky touretzky 
mathematics inheritance systems 
morgan kaufmann 
ungar smith david ungar randall smith 
self power simplicity 
oopsla conference proceedings pp 
orlando fl october 
published sigplan notices december 
published lisp symbolic computation kluwer academic publishers june 
ungar david ungar craig chambers bay wei chang urs hlzle 
organizing programs classes 
lisp symbolic computation kluwer academic publishers june 
ungar david ungar 
annotating objects transport worlds 
proceedings acm conference object oriented programming systems languages applications oopsla pp 
austin tx october 
watt steven watt richard robert barry 
scratchpad ii type system domains subdomains 
proceedings international workshop scientific computation capri italy 
published computing tools scientific problem solving ed academic press 
appendix annotated cecil syntax ebnf notation vertical bars separate alternatives 
braces surround strings repeated zero times 
brackets surround optional string 
parentheses grouping 
literal tokens included quotation marks 
grammar program sequence declaration blocks statements file included include decl contain declarations program top level file top level file top decl block stmt pragma included file top decl block declaration block unbroken sequence declarations names available declaration blocks top level interspersed pragmas top decl block decl pragma decl block decl decl declaration variable field method declaration decl module decl import decl decl tp decl type ext decl object decl obj ext decl predicate decl disjoint decl cover decl divide decl signature decl method decl field decl precedence decl include decl prim decl privacy declaration defaults public privacy public protected private modules package independent subsystems module decl privacy module module name extension friendship decl extension extends module names friendship friend module names module names module name module name module name name import declarations specify modules import decl privacy import friend module names variable declarations bind names objects var variable assignable decl privacy var name type decl expr type representation object declarations create new implementations types tp decl privacy type name formal params type relation declares object type object decl privacy rep role rep kind name formal params relation field inits rep role inherited named objects allowed incomplete template inherited instantiated uninitialized fields allowed concrete completely usable complete initialized dynamic completely usable accesses checked dynamically rep kind representation declares object implementation object declares object type implementation type relation subtypes types relation type relation type subtypes type impl conforms type inherits parents impl inherits impl isa parents impl inherits impl type subtypes type types type type parents named object named object field inits field init field init field init msg name location expr location named object predicate object declaration predicate decl privacy predicate name formal params relation expr field inits declarations relationships predicate objects disjoint decl privacy disjoint named objects cover decl privacy cover named object named objects divide decl privacy divide named object named objects named objects named object named object extensions adjust declaration existing object type type ext decl privacy extend type named type type relation obj ext decl privacy extend extend kind named object relation field inits extend kind representation extend representation object extend type representation signature declarations declare method signatures sig decl privacy signature method name arg type ps type decl arg type ps arg type arg type arg type name type pattern method name msg name formal params op name msg name name implementation declarations define new method implementations method decls define signatures method decl privacy impl kind method name formal params formals type decl pragma body prim body impl kind method implementation declares method implementation method declares method signature implementation formals formal formal formal name specializer formal names optional referenced specializer location type decl specialized formal type decl unspecialized formal named object sugar named obj named obj field declarations declare accessor method signatures implementations field sig decl field privacy var field signature msg name formal params arg type type decl field decl field privacy shared var field field kind msg name formal params formal type decl expr field kind empty declare accessor method impl sig field implementation declare just accessor method implementation field privacy privacy get privacy set set precedence declarations control precedence associativity binary operators prec decl privacy precedence op list associativity precedence associativity left associative right associative non associative precedence op list op list op list op list op name op name include declarations control textual file inclusions implementation specific include decl include file name file name string primitive body declarations include arbitrary piece code compiled file implementation specific prim decl prim body primitive method bodies support access code written languages implementation specific prim body prim language code language name currently recognize rtl self code string body method closure body stmt result return result statement empty return void stmt decl block assignment expr result normal return return expression non local rtn return lexically enclosing method normal return decl block return void assignment return void expr return result expression non local rtn non local return returning void expr non local return returning result assignment allowed name assignable returns void assignment qualified name expr assign msg assignment syntax messages assign msg lvalue msg expr sugar set msg exprs expr lvalue msg message dot msg unop msg binop msg expressions expr binop expr binary msgs lowest precedence binop expr binop msg unop expr binop msg binop expr op name binop expr associativity declared unary msgs second lowest precedence unop expr unop msg dot expr unop msg op name unop expr allowed unary operators dotted messages second highest precedence dot expr dot msg simple expr dot msg dot expr msg name params exprs sugar msg name params dot expr exprs 
simple messages highest precedence simple expr literal ref expr vector expr closure expr object expr message resend paren expr literal constants literal integer float character string variable named object implementation ref expr qualified name local global variable named object named object build vector vector expr exprs exprs expr expr build closure closure expr closure formals type decl body closure formals closure formal closure formal closure formal name type decl formal names optional referenced build new object object expr rep role rep kind relation field inits send message message msg name params exprs resend message resend resend resend args resend args resend arg resend arg resend arg expr corresponding formal sender unspecialized name undirected resend name specialized formal name location directed resend name specialized formal introduce new nested scope paren expr body name module qualified name module name name name object named object qualified name params named object qualified name param patterns syntax types type named type closure type lub type glb type paren type named type qualified name params closure type arg types type decl arg types arg type arg type arg type name type lub type type type glb type type type paren type type formal types types contain binding occurrences implicit type parameters type pattern binding type named type closure type lub type glb type paren type binding type name named type qualified name param patterns closure type arg type ps type decl type decl type type decl type pattern formal parameters objects methods formal params formal param formal param formal param name actual parameters objects methods params types actual parameters types may contain binding occurrences implicit type variables param patterns type patterns type patterns type pattern type pattern pragmas added various points program provide implementation specific hints commands pragma exprs tokens bold faced non terminals grammar tokens full grammar 
usual tokens defined longest possible sequence characters language defined grammar 
meta notations concisely list range alternative characters 
space tab newline stand corresponding characters 
name letter letter digit id cont op name underscore part msg name op name id cont name underscore part msg name id cont name op name integer radix hex digits leading considered unary operator radix digits hex digits hex digit hex digit hex digit digit fa float integer hex digits exponent integer exponent exponent digits digits digit digit character char string char line break char escape char escape char digit digit digit hex digit hex digit line break whitespace new line whitespace characters part string letter za digit white space whitespace allowed pair tokens grammar 
whitespace space tab newline comment comment newline newline comment line bracketed comment nested 
