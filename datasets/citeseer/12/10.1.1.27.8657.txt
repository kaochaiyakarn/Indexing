realtime signal processing dataflow visual functional programming hideki john reekie submitted degree doctor philosophy university technology sydney school electrical engineering september thesis presents justifies framework programming real time signal processing systems 
framework extends existing block diagram programming model components high level textual language visual language dataflow process network model computation 
dataflow process network model widely lacks formal description provide semantics 
formal leads new form actor 
having established semantics dataflow processes functional language haskell layered model providing powerful features notably polymorphism higher order functions algebraic program transformation absent block diagram systems 
visual equivalent notation haskell visual haskell ensures power exclude intuitive appeal visual interfaces intelligent layout suggestive icons visual haskell program look block diagram program 
functional language extend dataflow process networks simulating timed dynamically varying networks 
thesis draws number previously separate ideas reasonable expectation efficient execution established dataflow compilation technology powerful high level programming notation block diagram style interface 
contents motivation benefits overview thesis previously published background material models parallelism meta model parallelism implicit parallelism data parallelism control parallelism linda model pipeline parallelism functional programming minutes objects functions bindings patterns currying higher order functions lambda case polymorphism type classes evaluation mechanisms graph reduction strictness parallel graph reduction parallel data structures functional operating systems functional process networks skeletons real time signal processing discrete time signals streams channels functions systems digital signal processors summary dataflow process networks related computation graphs synchronous dataflow sdf kahn process networks dataflow processes firing rules standard form dataflow actors syntax desugaring semantics consumption production vectors canonical sdf actors phased form dataflow actors syntax phase graphs semantics cyclo static multi phase integer dataflow execution mechanisms hierarchy strictness summary visual haskell related visual haskell visual syntax preliminaries visual elements specifying visual syntax simple visual language de sugaring core syntax simple expressions structured expressions patterns bindings match phrases improving visual syntax visual syntactic sugar iteration boxes unfolded higher order functions wiring summary static process networks related vectors vector datatype ii iterators combiners selectors example fast fourier transform streams stream datatype process primitives example process constructors process network construction simple combinators simple linear networks pipelines meshes systolic arrays network construction dataflow systems process network transformation type annotations fusion parallelisation pipelining promotion summary dynamic process networks related timed signals streams functions timed streams basic functions timed vectors synchronous timed streams dynamic process networks finite synchronous streams dynamic process functions digital music synthesiser notes envelopes note generation formant wave function note generator summary summary contributions concluding remarks haskell code iii list figures conceptual framework dsp programming arguments summarised overview thesis topics hierarchy parallelism carriero gelernter models parallelism models parallelism simple block diagram simplified dsp chip architecture simple dataflow network computation graph synchronous dataflow graph kahn process network sugared syntax standard form actor desugaring standard form actor instantiating actor canonical sdf actors sugared syntax phased form actor non deterministic actor phased form delay actor desugaring phased form actor phase graphs phase graph iota deadlock hierarchical actor phased network example example phased network phased form actor factorial function cardelli language factorial function factorial function visual haskell patterns map function icons standard prelude data constructors icons standard prelude functions function composition simple visual elements iv haskell syntax visual syntax simple language sugaring simple language de sugaring rules visual syntax simple expressions example translation visual syntax structured expressions examples structured expressions visual syntax patterns visual syntax bindings visual syntax match clauses sugaring rules illustrating type annotations illustrating iteration unfolded higher order functions wiring mixing text pictures unfolded vector iterators iterator type signatures combiner type signatures selector type signatures additional selector functions selectors wiring point fft butterfly diagram fft function parts point fft visual haskell types stream functions order recursive filter process constructor definitions process constructors fir filter function th order recursive filter simple network forming functions linear process networks pipeline process network mesh process networks illustrating network types process fusion transformed fir filter horizontal parallelisation pipelining promotion simple digital gain control types timed stream functions types finite stream functions functions making finite streams types dynamic process functions note events associated code ramp envelope generators note generators top level synthesiser sine wave synthesiser output formant wave function tone generation formant wave function output vi academic supervisors professor warren yates school electrical engineering university technology sydney dr john potter microsoft institute school computing sciences university technology sydney advice support patience 
am indebted thesis assessors dr chris university technology sydney dr greg michaelson heriot watt university dr andrew university adelaide time effort reading commenting submitted version thesis hope final version adequately addresses issues raised 
supported australian post graduate research award 
colin reekie thing possible 
jon hill read offered useful comments early draft thesis 
matthias meyer wrote tms prototype 
ken dawson wrote prototype visual haskell editor 
mike wrote polyphonic version formant wave function music synthesiser 
john offered enthusiasm encouragement 
rick told funny story 
morris psycho cat took interest 
vii virtues architecture weigh said strength construction beauty decoration 
consider mean say building constructed built merely mean answers purpose modern buildings fail built answer purpose simplest way expenditure means 
john stones venice 
writers books articles circumstances collective anonymity editorial newspaper place 
author may reader say seen ought meaning say believe sound reason anonymous say writer reviewer expressions individuality singular pronoun 
modern writers showing disposition fashionable uses practice deserves encouragement 
imitated scientific writers misplaced describing experiments perpetually passive voice thing done trick repetition reader long author break monotony saying boldly thing fowler dictionary modern english usage chapter real time signal processing computation unique field 
special class applications applications demand extremely high computational performance fast real time response 
uses specialised micro processors unique set hardware design programming tricks 
pursues performance expense generality maintainability portability generally accepted measures software practice 
running real time signal processing program exciting kind computer program hear see interact ways possible kinds computer program 
fortunately eagerness sacrifice practice pursuit maximum performance tempered programming approach promises 
approach going guise block diagram development systems simple metaphor software modules interconnected software channels manner hardware units connected cables carrying analog digital signals 
concept dates back kelly 
modern systems visual interfaces add appeal metaphor complete systems constructed making connections computer screen 
computational model systems called pipeline dataflow combination visual interface pipeline dataflow established fields including signal processing image processing visualisation instrumentation general purpose visual programming languages 
signal processing systems special class pipeline dataflow dataflow process net chapter 
dataflow process network scans high level language visual language programming technology computational model 
conceptual framework dsp programming works see chapter 
block diagram systems established practical compromise usability implementation technology lack features modern programming languages 
aim thesis extend visual interface dataflow network style computation 
adding third dimension illustrated 
underlying model computation dataflow process networks programmer creates programs visual language high level language 
appears diagram high level language offers new flexibility power visual interface dataflow process network model 
thesis haskell high level language haskell modern functional language provides common ground research functional languages functional programming 
visual language visual haskell visual equivalent haskell design 
sections summarise arguments favour adding third dimension 
sections provide outline chapters review previously published papers reports relation thesis 
chapter 
motivation main motivations thesis 
firstly wanted way expressing dataflow network programs powerful expressive current block diagram systems 
secondly wanted show powerful notation need sacrifice intuitive appeal visual interface 
block diagram system programmer engineer places icons representing processing modules blocks computer screen 
connections input output ports represent flow data block 
data flowing channels called stream 
input output handled uniform way special blocks input ports represent input channels blocks output ports represent output channels 
systems support hierarchical construction networks network unconnected input output ports named placed network 
dataflow network equivalent procedural abstraction 
block diagrams conceptually familiar engineers visual interface semantically simple provides little barrier take learning new textual language 
computational model limited pipeline dataflow 
result block diagram languages express kinds computation 
example easy express point wise summation streams numbers possible express addition numbers 
reason block diagram systems supply library primitive blocks waveform generators filters modulators detectors transforms complex blocks systems constructed 
algorithm supplied library coded primitive block user conventional language fortran 
approach drawbacks 
firstly algorithms coded fortran divided smaller parts simultaneous execution multiple processors 
large primitive blocks fast fourier transform may limit throughput reduce effectiveness load balancing 
second objection essentially elegance programmer forced program completely different languages completely different semantics 
functional programming languages natural choice coding dataflow network programs 
pure functional languages assignment think func chapter 
tional programs dataflow programs dataflow result block flows input functional programs result function application argument function application 
data atomic numbers tokens dataflow terminology atomic dataflow addition pure functional languages lazy evaluation performed needed produce result program 
laziness nice property number reasons 
firstly necessary guarantee referential transparency expression substituted equivalent expression changing program meaning 
secondly allows programming techniques languages see examples programs constructed lazy language 
purposes laziness easy build infinite data structures simulate pipeline dataflow systems 
language codes internal computation blocks networks blocks barrier primitive constructed blocks conventional block diagram systems 
functional languages visual 
visual functional languages widely adopted implemented 
functional language approach dataflow programming fits dataflow model developed visual notation haskell called visual haskell 
aim visual haskell provide unambiguous visual equivalent textual haskell programs translated back forth notations represented double ended arrow top 
blocks constructed primitive created manipulated visual textual languages 
typically visual language higher levels system textual language lower level algorithms transition styles programming seamless programmer free choose whichever appropriate 
view idea new multiple view program development environment proposed procedural languages view document formatting systems natural synthesis compiled wysiwyg styles document production 
choice lazy language drawbacks inevitable overhead associated building run time representation unevaluated expressions 
chapter 
presents serious difficulties computation blocks real time signal processing simply afford support overheads essential producing result computation 
benefits having decided framework interesting benefits apparent 
visual language general visual notation haskell particularly oriented signal processing promises powerful tool functional programming general 
presentation chapter earlier written assuming visual haskell visual functional language visual dataflow language 
connection functional languages pipeline dataflow specifically dataflow process networks see chapter provides new implementation model particular class functional programs 
similar approaches evaluating functional programs section promises efficient execution established dataflow scheduling compilation techniques 
high level language provides visual language pipeline dataflow models powerful features 
existing block diagram languages general purpose visual programming languages support features promised visual haskell 
reasons developed visual haskell existing visual language combining dataflow networks 
polymorphism example allows functions networks written accept different datatypes 
ptolemy spw example programmer choose appropriate addition block integer floating complex 
visual haskell operator overloaded types 
typing static feature require overheads run time typechecking case lisp language adopted 
higher order functions provide powerful mechanism constructing parameterising process networks 
higher order function takes function argument delivers function result 
allows expression visual programs large thoughts 
explore idea section 
simple form higher order function mechanism added ptolemy inspired earlier papers :10.1.1.21.2539
chapter 
functional language visual language dataflow networks expressiveness intuition ef expressiveness intuition ef 
arguments summarised interesting possibility opened incorporating functional language programming framework program transformation 
program transformation advocated functional programming texts means obtaining efficient realisation programs inefficient executable specifications :10.1.1.100.9674
context dataflow networks offers means performing provably correct alterations structure network section 
individual modules network interpreted units parallelism section effect alter control degree type parallelism exhibited network 
summarises preceding arguments terms dimensions new programming framework dataflow network model provides visual functional programming efficient execution mechanism visual language adds intuition functional dataflow programming functional language adds expressiveness visual dataflow programming 
result powerful framework program reason dataflow network programs 
overview thesis thesis covers broad range topics 
help explain material covered inter relationships shows dependencies main topics 
outline proceeds chapter chapter 
chapter background material provides background material surveys relevant chapters 
topics covered models parallel computation functional program chapter 
functional programming visual haskell static networks dynamic networks process networks strict dataflow non strict dataflow evaluation mechanisms 
overview thesis topics ming evaluation mechanisms functional languages real time programs 
sections include basic background material needed remaining chapters reviews chapter 
chapter dataflow process networks presents formalisation dataflow actors processes 
builds seminal kahn process networks lee term dataflow process network due :10.1.1.21.2539
emphasis modelling describing dataflow actors practical issues associated implementation dataflow programming environments 
formalisation leads new insights nature dataflow actors 
dataflow actors strict consume needed input tokens producing output tokens 
final section chapter introduces non strict actors call phased actors 
idea quite novel development 
chapter visual haskell formally describes visual haskell 
syntax translation haskell syntax directly concrete visual syntax 
visual grammar uses novel techniques handle differences style textual visual syntaxes 
visual syntax haskell expression definition syntax notable omission syntax type type class declarations 
final section chapter shows way specified visual syntax far perfect greater flexibility needed support complex varied forms visual representation 
chapter static process networks builds previous dataflow processes programmed haskell programs illustrated visual haskell 
firstly relationship haskell functions dataflow actors explicit 
remainder chapter demonstrates haskell features increase expressiveness dataflow chapter 
network programs higher order functions concise powerful means constructing combining dataflow networks program transformation techniques adapted improve efficiency tailor program particular physical network 
chapter dynamic process networks takes different approach writing functional programs fit dataflow mold chapter write haskell programs ways may give insight extending improving dataflow actor process model 
key issue tackled representing time dataflow networks 
secondary issue dynamic networks networks change time 
haskell represent evolving networks substantially needed find way translating type program dataflow networks little done formal characterisations evolving dataflow networks 
dependencies chapter shown dotted lines areas 
chapter summary summarises thesis lists key contributions 
indicated enormous scope outline areas consider promising research 
previously published material thesis previously published technical reports conference papers 
included material thesis reader interested particular portions elided directed electronic copies referenced bibliography list papers address www ee uts edu au papers effective programming parallel digital signal processing contains key ingredients thesis 
report proposed functional programming language choice programming block diagram systems illustrated programs written vectors streams early version visual language thesis 
identified usefulness program transformation parallel programming pipelined fft fast fourier transform illustrate 
chapter 
integrating block diagram textual programming parallel dsp essentially brief summary report focuses notion view development system 
transforming process networks continues program transformation theme pipelining fir finite impulse response filter 
transformation proceeds fusing vector iterators section form single process pipelining promotion sections produce pipeline controllable grain size 
suggested difficult means finding program transformations required program transformation useful programmers 
means decided reproducing key example 
process network transformation condensed version visual notation closer current visual haskell 
identifies classes process network transformation section 
real time dsp assembler set course notes tms dsp may interest reader seeking accessible features modern dsp devices 
generating efficient loop code programmable dsps somewhat leap earlier papers describes aimed compiling vector functions efficient code dsps 
proposes dsp machine vehicle dsp compilation describes essential part code generation algorithm designed exploit high degree instruction level parallelism dsps 
included thesis 
host engine software architecture parallel digital signal processing totally unrelated earlier papers describes software architecture called signal processing object oriented kernel best described api level application programmer interface implementation dataflow engine parallel dsp machines 
combination architecture description experience implementations architecture written tms processor second largely matthias meyer tms 
tms implementation progress written detailed description final implementation see meyer report 
decided chapter 
including material thesis feel tangential main theme 
modelling asynchronous streams haskell develops haskell code modelling timed streams 
approaches mark empty slots timestamps mark times occurrence tokens 
chapter thesis complete revision particular new form timed stream developed music synthesiser example extended 
visual haskell attempt written devoted explaining visual haskell final form visual language developed refined years 
chapter revised version core 
visual language slightly improved way visual syntax specified different think simpler elegant 
original contains motivating examples possible uses visual haskell screen dump prototype visual haskell editor written ken dawson 
chapter background material thesis covers quite broad range topics collected chapter useful background material 
firstly give broad overview models parallel computation terms simple meta model computation 
parallel programming plays minor role thesis motivations pipeline dataflow model harness parallelism think important place model context approaches parallelism 
section functional programming haskell 
section evaluation mechanisms functional languages 
serves place chapters context particular translating functional program dataflow process network similar existing approaches parallel evaluation functional programs 
context thesis real time signal processing section explains key concepts real time programming programmable dsp devices 
section largely experience real time programs 
models parallelism pipeline dataflow model inherently suited parallel execution 
key models parallelism important place context 
section reviews key models parallelism shown hierarchy 
chapter 
background material language level parallelism implicit parallelism explicit parallelism data parallelism functional parallelism control parallelism linda pipeline parallelism 
hierarchy parallelism meta model parallelism carriero gelernter suggest paradigms parallelism result parallelism result parallelism focuses structure solution 
parallelism arises simultaneous production components result 
specialist parallelism specialist parallelism focuses kind knowledge needed produce solution 
parallelism arises specialists encapsulating particular kind knowledge simultaneously 
agenda parallelism agenda parallelism focuses steps taken arrive solution 
parallelism arises non sequential steps simultaneously 
translate problems exhibiting types parallelism operating computer programs linda see section carriero gelernter offer corresponding program structures live data structures message passing distributed data structures respectively 
structures distinguished relationship processes data 
live data structure program parallelism structured data implicitly defined process datum computes value 
messagepassing program contrast consists collection separate processes containing private data communicating messages 
distributed data structure program tight binding process corresponding data processes share data 
suppose separate knowledge perform computation thing performs computation 
entities call script agent chapter 
background material 
carriero gelernter models parallelism result parallelism specialist parallelism agenda parallelism respectively note process script agent agent script data model serves meta model describing different models parallelism 
shows carriero gelernter program structures modified show agents scripts data agents grey ellipses rounded rectangles scripts curly glyphs resemble sheets data white squares 
live data structure program agent script uses produce data enclosing 
message passing program agent script agents contain private data send data processes messages shown white ellipses 
distributed data structure program program single script agenda agents read script performing available task operating shared data 
implicit parallelism implicit parallelism associated program expressions data time dependence 
example expression chapter 
background material multiplications performed parallel 
greater parallelism available loops different iterations loop performed parallel 
example iterations performed parallel 
parallelising compilers conventional sequential languages analyse programs find kind opportunity parallel execution 
advantage implicit parallelism theory programmer need concerned programming parallel machine compiler find exploit available parallelism 
implicit parallelism characteristic programming language compiler run time architecture 
side effect free languages contain implicit parallelism imperative languages lack artificial 
examples languages architectures support implicit parallelism dataflow languages architectures multi processor graph reduction pure functional programs 
cases languages side effect free 
gajski point parallelising compilers fact perform better single assignment languages 
implicit parallelism key ingredient modern single processor compilers 
modern processors including dsp micro processors exhibit significant instruction level parallelism compilers attempt exploit 
data parallelism data parallelism parallelism level elements data set 
parallel computing scientific applications uses data parallelism 
blelloch call data parallel languages collection oriented 
survey class languages ways support data parallel computation 
data parallel language operation elements data set invoked single function call language construct 
dataparallel language example calculate inner product vectors domain float float float chapter 
background material float ip 
domain ip contains triples located different processor 
instances processor 
ip refers single variable located system host processor 
execution code body causes instance updated product corresponding instances instances summed result placed ip 
illustrates data parallelism agent script data meta model 
agents read script read data need 
greatest advantage data parallelism descriptive simplicity programmer easily control thousands processes thread control manipulate 
data parallelism associated simd machines functional parallelism associated mimd machines 
case important associate language model physical hardware program run connection language level model parallelism supposed obvious implementation platform 
example hatcher quinn describe data parallel language compiler mimd machines describes simd computer simulate mimd computer 
control parallelism control parallelism form functional parallelism characterised mainly explicit communication message passing synchronisation processes 
effect programmer writes separate programs embedded program commands communication synchronisation programs 
example control parallel language implementation distributed memory dsp machines parallel loosely hoare csp communicating sequential chapter 
background material 
models parallelism data parallelism shared memory control parallelism linda pipeline parallelism processes formalism 
programmer writes number tasks independent programs 
configuration file specifies processor topology communications links assigns tasks processors 
messages exchanged calling message passing library 
example sending task contain code message sizeof message outs receiving task contain code sizeof message ins control parallelism low level programmer interface essentially operations performed directly target machine transmission messages processors distributed memory machines synchronisation memory accesses shared memory machines 
criticised low level error prone programmer explicitly manage communication synchronisation keep track internal states processors 
control parallel programs machine specific projects pvm virtual machine abstraction achieve architecture independence 
chapter 
background material single agent script data model control parallel programs 
machines support message passing message passing model appropriate 
machines shared memory model suitable model agent script processes access shared data 
important distinguish control parallelism characterised higher level forms functional parallelism 
proponents implicit dataparallel language styles forget approaches functional parallelism provide better support managing parallelism 
linda model linda simple elegant architecture independent model mimd computation 
basis linda model global associative memory tuple space 
task adds tuple tuple space executing instruction task remove tuple tuple space executing instruction arguments called anti tuple template matching tuples tuple space 
case value tuple removed tuple space variable reading task value assigned 
anti tuple matches existing tuple reading task suspended matching tuple available 
task create new tasks exec instruction 
example statement exec task ping creates live tuple actively evaluates fields 
case third field requires evaluation new task created evaluate ping 
task terminates tuple turns back data tuple replacing third element tuple value returned ping 
linda rd instruction matches reads tuple remove tuple space predicate versions rd called inp rdp 
inp rdp chapter 
background material behave rd find matching tuple return value 
fail find match immediately suspend reading task return value 
approximate agent script data model linda 
agent slot script agent takes script tuple space performs corresponds eval operation 
agent script read remove add tuples 
note shared memory model agent modify tuple tuple space removing putting new tuple tuple space 
shown diagram 
linda avoids synchronisation problems associated conventional shared memory models 
pipeline parallelism functional programs thesis pipeline parallel model processes communicate fifo buffered channels 
programs written model contain explicit communication instructions implicitly specify communication construction 
example haskell expression maps abs scans constructs pipeline processes 
computes running sum input stream second calculates absolute value element input stream 
communication processes implicit fact result argument second 
pipeline parallelism arguably just special kind message passing control parallelism 
think differences general control parallel programs sufficient model processes send messages channels de coupling senders receivers processes separate programs just expressions program text communication processes buffered providing decoupling sender receiver processes 
kind parallelism functionally parallel counterpart data parallelism focuses essential aspects parallelism excessive concern low level detail 
shows pipeline parallel model messagepassing program explicitly shows fifo buffered channels 
chapter 
background material pipeline parallelism includes certain dataflow programming languages 
lucid order pipeline parallel language 
lucid process pipeline written runner runner runner runner fby runner abs lucid primitive operations extended point wise streams operator sums corresponding elements streams 
fby operator produces stream containing element left argument followed right argument 
runner produces zero followed summed 
dataflow process network model lower level communication explicit :10.1.1.21.2539
process formed repeatedly firing actor complete program consists network actors 
dataflow process networks examined chapter 
functional programming minutes functional programming languages higher level conventional imperative languages 
persuasive arguments advanced functional programming languages general lazy functional languages particular :10.1.1.100.8004
study indicates claimed advantages functional languages brevity development ease understanding confirmed 
study compares languages including ada substantial rapid prototyping exercise 
metrics compare solutions haskell solution highest rated 
section introduces functional programming haskell 
haskell quite large language omitted complex features separate modules chapter 
background material data hiding array syntax list comprehensions user defined operators 
haskell library types functions contained standard prelude 
standard prelude library code modules haskell implementations expected support importance compiler allowed understand contents modules order generate efficient code 
give cursory overview standard prelude functions types 
chapters typeset version haskell improved readability 
differences standard haskell greek characters type variables 


type declarations slanted roman typeface constant width typeface 
objects functions haskell standard prelude defines number types operators functions 
simple constants types notation means type int float true bool char complex types defined prelude include rational complex numbers arbitrary precision integers lists tuples 
complex rational numbers built data constructors respectively 
example complex float rational int operators defined standard prelude include arithmetic operators negate unary negation relational operators logical connectives 
operators overloaded appropriate types 
division defined rational floating point numbers integer types integer division div modulus mod functions 
functions numeric types include transcendental operations sin exp operations specific complex numbers magnitude phase 
chapter 
background material tuples contain fixed number fields possibly different types fields separated commas 
example int char float useful functions tuples fst selects element pair snd selects second 
lists contain zero elements type 
empty list denoted list constructor joins element front list syntax short hand 
examples lists xs int char char standard prelude contains functions lists 
simple ones head returns element list tail returns elements list 
include reverse reverses list length returns number elements list take returns number elements front list returns element list concat joins list lists single list appends lists repeat repeats argument forever repeat 
operators usually written infix position operator written prefix position enclosing parentheses binary function written infix position enclosing back quotes div function application denoted juxtaposition sin usual sin 
parentheses disambiguate necessary example take second element list xs expression head tail function application binds tighter operator sin sin 
chapter 
background material bindings binding association identifier value 
consider simple pattern bindings variable name bound expression 
examples pi double pi double pi function binding associates identifier function 
example definition factorial function fact int 
int fact fact line says fact function integer argument produces integer result 
construct expression control flow construct imperative languages returns value 
function pattern bindings guards select number alternative expressions 
example fact defined fact int 
int fact fact indicates start alternative followed predicate selected expression 
guard true 
guards tested top bottom 
bindings contain local bindings introduced keyword 
example butterfly function section local binding butterfly num 
complex 
complex complex 
complex complex butterfly chapter 
background material patterns pattern formed data constructor appears left hand side binding 
result evaluating right hand side bound corresponding identifiers pattern 
example binding xs cause integer bound list bound xs 
patterns nested arbitrarily zs 
arguments function bindings patterns case serve select possibly multiple clauses function definition 
patterns position constants 
illustrate consider haskell definition map applies function element list map 


map map xs map xs clause match list argument null list second clause match head list bound tail possibly null bound xs 
patterns wild card written matches 
map example usually defined wild cards map 


map xs map xs map currying higher order functions map example higher order function hof 
higher order function takes function argument produces function result 
case map argument chapter 
background material function indicated type 
higher order functions powerful features functional programming languages capture patterns computation 
map example captures style iteration list 
functions capture various styles iteration 
foldl example applies function argument list element result previous application foldl produces 
scanl similar produces list containing partial results 
example scanl produces 
functions defined follows foldl 




foldl foldl xs foldl xs scanl 




scanl scanl xs scanl xs useful higher order functions function composition written infix operator defined 
particularly common construct pipeline functions haskell lambda calculus higher order functions arise naturally define functions argument 
example consider function adds numbers add int 
int 
int add associates right left type add really int 
int 
int add takes single integer argument produces function integers integers 
example expression add function adds argument 
functions type called curried mathematician haskell curry 
practice refer function add function arguments application full number arguments partial application 
comparison uncurried version add written chapter 
background material add int int 
int add lambda case expression delimits new scope local bindings declared 
illustrate butterfly defined expression butterfly expressions expressions appear expression appear appear binding 
lambda abstraction abstraction anonymous function 
example define butterfly butterfly 
backslash haskell syntax lambda abstraction mimics greek patterns backslash arguments expression value returned abstraction applied arguments 
note abstraction guards 
functions defined guards multiple clause definitions translated abstraction aid haskell case construct selects expressions pattern matching 
example map defined abstraction map xs 
case xs ys 
map ys polymorphism type classes key innovations haskell type classes add ad hoc polymorphism hindley milner type system :10.1.1.47.1059
type class way grouping types functions operate types 
class declaration types chapter 
background material functions class optionally default definitions functions 
example standard eq class groups types support equality test defined class eq 

bool type support equality test instantiates eq class 
example integer type int instantiates eq instance eq int primitive function generates call underlying run time system 
example eq instance pairs instance eq eq 
eq type constraint eq eq states elements pair comparable equality 
type constraints appear function definitions 
example type absolute function indicates type argument result numeric ordered abs num ord 

abs classes inherit form hierarchy 
example class ordered types ord inherits class types eq class eq 
ord 

bool 
standard prelude implements full hierarchy primitive numeric types see details 
chapter 
background material evaluation mechanisms implementations lazy functional languages graph reduction 
section briefly reviews graph reduction topics related evaluation functional programs 
aim place context suggested implementation chapter stream functions dataflow actors 
survey issues parallel functional programming hammond 
graph reduction evaluation functional program proceeds successively reducing expressions 
evaluator chooses redex reducible expression reduces repeats 
expression contains redexes normal form 
fi reduction written fi performed abstraction applied argument application reduced substituting body abstraction replacing formal actual 
ffi reduction written ffi performed primitive function applied arguments arguments reduced appropriate operation performed 
key reduction policies 
normal order reduction evaluator chooses outer redex 
example fst fst fi fst fst fi fst fi ffi ffi ffi fst applicative order reduction evaluator chooses inner redex 
example fst fst ffi fst fst ffi fst fst chapter 
background material fi fst fst fi fst fi ffi operationally normal order reduction applies body function arguments argument evaluated applicative order reduction evaluates arguments 
normal order reduction evaluate expression value needed seen example expression evaluated 
applicative order reduction contrast evaluates argument expressions regardless values needed 
church rosser theorems fundamental considerations reduction order see pp 

informally says reduction sequences normal form provided terminate 
great interest allows freedom change reduction order perform reductions parallel 
second theorem says normal order reduction terminate normal form exists 
powerful motivation choosing normal order reduction evaluation mechanism programming language 
lazy functional languages normal order reduction reducer reduces top level redexes 
called weak head normal form whnf term normal form whnf 
data structures evaluated top level may contain unevaluated expressions 
example whnf regardless form normal form normal form 
whnf insufficient arguments redex 
example normal order reduction expression evaluated twice 
avoid functional languages graphs share expressions 
reduction step reducer locates left top level redex reduces overwrites redex result 
redex application abstraction reducer instantiates copy body abstraction pointers argument expressions substituted formals 
redex application primitive chapter 
background material function reducer reduces strict arguments calls run time system perform appropriate operation 
strictness function said strict iff result applying undefined argument undefined 
denotes undefined value say represents term whnf 
operationally take mean needs argument result evaluating argument strict function whnf applying function affect result 
generalised functions arguments example strict second argument 
strictness imply argument evaluated whnf termination 
omega denote term normal form just denotes term whnf 
function hyper strict iff omega result applying necessarily undefined argument normal form 
called exhaustive demand opposed simple demand evaluation whnf 
simple example difference strictness hyper strictness consider strict hyper strict hyper strict 
argument normal form say necessarily cause result applying undefined necessarily cause result applying undefined 
chapter 
background material parallel graph reduction program graph typically contains moment redexes 
parallel evaluation graph achieved having processors evaluate redexes simultaneously 
peyton jones describes issues parallel graph reduction shared memory machine 
choices performing parallel graph reduction evaluate redexes parallel alter termination properties ii evaluate redexes parallel may alter termination properties iii allow programmer choose perform parallel reduction 
choice conservative parallelism requires strictness analysis function strict arguments arguments evaluated parallel function body 
example application evaluated parallel addition performed 
case course point evaluating function body parallel 
second choice speculative evaluation 
speculative evaluation expression evaluated parallel 
discarded soon value known 
third choice programmer controlled parallelism 
form annotations form primitive combinators 
roe example points difficulties conservative parallel graph reduction suggests new combinators par seq par ff fi fi par seq ff fi fi chapter 
background material seq 
par creates new task evaluate returns evaluation fails terminate may may terminate 
seq evaluates whnf returns roe gives wide range examples algorithms illustrating combinators control parallel reduction program graph 
parallel data structures problems associated pure functional language parallel programming sequential nature lists 
algorithm high degree intrinsic parallelism algorithm expressed functional language may fact obscure parallelism simply list data structure accessed sequentially 
data structures functions allow parallel evaluation multiple elements structure identified compiler easily identify parallelism 
addition programmer better able understand behaviour parallel implementation achieve better performance 
joy example propose set list primitives allow parallel evaluation list functions including list containing element 
concatenation lists split pair lists split point chosen non deterministically 
split non deterministic implementation free implement lists suitable tree structure 
joy implement standard haskell list functions primitives divide conquer recursive implementation 
result lg best case worst case parallel complexity 
map example implemented map chapter 
background material map map map map joy replace standard foldl foldr functions new function reduce requires associative function argument obligation programmer ensure case 
haskell standard prelude functions foldl foldr meet criterion 
maassen proposes set finite data structures sequences tables sets range higher order functions defined 
gives complexities implementation lists avl trees logarithmic complexity functions 
range examples illustrate utility chosen functions programming 
roe contrast describes bags multi sets expressing parallel computation shows bird meertens formalism applied parallel computation bags 
functional operating systems expression operating system functionality functional language revolves deferred evaluation streams messages 
context operating systems process function list input messages type ff list output messages type fi turner example gives example process process ff fi process trans initial state process trans ff oe oe state transition function produces state input message current state ff oe fi produces list output messages input message 
networks processes formed applying processes output messages lists 
corollary church rosser theorem network processes produce result depends values input messages particular time arrival input messages affect result 
chapter 
background material apparently operating system needs deal asynchronous events written language 
approach resolving dilemma add non deterministic merge operator language merges lists order arrival time elements 
merge referentially opaque reasoning programs difficult 
jones sinclair reduce difficulties associated merge restricting systems programmers 
describe operating system design give examples access operating system services file editing disk control 
ensure computation proceeds operationally useful way streams constructed head strict cons elements fully evaluated transmission 
second approach non determinism stoye sorting office 
scheme output message contains address destination process sorting office receives messages routes addressed process 
non determinism contained place sorting office simplifying reasoning system eliminating need awkward extensions language 
new processes created sending message distinguished process creation process 
turner develops stoye model adding wrappers messages allow type checking synchronous unbuffered communication asynchronous communication 
similarly jones sinclair wrapper functions hyper strict 
apart eliminating need global garbage collection allows operating system executed loosely coupled network processors 
wallace runciman constructor classes express type safe communication processes 
scheme message type serves message address 
wallace implemented operating system embedded systems gofer systems reviewed stream constructor hyper strict head 
wallace suggests head hyper strictness important ingredient making evaluation functional programs predictable meet real time scheduling constraints 
chapter 
background material functional process networks kelly proposed list manipulating functions treated processes mapped processors distributed memory mimd machine 
language programs written pure functional language standard list functions map filter 
additional language construct contains declarations specify lists represent communications channels processes 
example expression xs map abs scanl arc processor pipeline 
operator converts function process indicates argument result lists function indicated communications channels conventional lazy lists 
arc function specifies connection processes 
power host language define network forming operations 
example pipeline combinator builds pipeline processes 
chain defined insert arc processes list fs pipeline ff ff ff ff pipeline fs xs ys ys foldl delta id fs xs chain arc map fs arc fs xs arc hd fs ys chapter 
background material pipeline network written pipeline map abs scanl xs current implementation requires process network static 
compile time annotations expanded extract single top level annotation describes static network 
kelly suggests strictness analysis programmer annotations minimise eliminate overheads associated sending non normal form expressions channels 
current implementation supports head hyper strict streams words normal form elements sent channels 
skeletons section showed parallelism captured terms data structures 
contrast cole algorithmic skeletons capture parallel computation terms relatively algorithmic description skeleton particular pattern parallel computation 
cole imperative framework points higherorder functions ideal mechanism expressing skeletons 
idea selecting parallel program structure catalogue structures appealing 
darlington adapt cole idea functional language framework 
point skeleton implementation independent meaning functional definitions behaviour tailored target parallel machine parallelism arises behavioural aspect 
propose skeletons higher order functions pipe list functions produce pipeline function allocated different processor 
farm function datum environment produce farm processes applies function element data set environment 
dc divide conquer functions split data set test solve trivial solution combine solutions produce tree structured parallel program implements divide conquer algorithm 
chapter 
background material ramp reduce map pairs functions represent interaction data items combine results interactions data items produce parallel program calculates interactions items data set combines interactions produce single solution 
dynamic message passing architecture set processes accepts set messages produces set messages processes generate parallel program implements set processes 
darlington give examples skeletons transformed skeletons 
programmer choose skeleton easily represents problem solved ii transform program performance measures skeleton efficient machine architecture 
proposes different set skeletons map filter fold composition 
functionally functions haskell map filter foldl 
implemented processor farms composition pipeline connection farms 
additional skeletons compositions 
contrast darlington argues skeletons identified compiler directive programmer parallel execution take place 
compiler uses profiling performance prediction decide execute skeleton parallel addition approach allows compiler detect parallelism recursive functions 
measurements compiled programs show execution estimates 
real time signal processing term real time refers systems correctness system depends logical result computation time results produced 
examples real time systems include command control systems process control systems flight control systems 
thesis focuses particular class real time system digital signal processing systems analyse produce transform discrete time signals 
conven chapter 
background material tional real time systems respond process individual events may occur arbitrary times signal processing systems process streams data representing discrete time signals elements usually occur known rates 
signal processing systems tend stringent timing requirements timing parameters expressed tens micro seconds milliseconds 
section provides background needed appreciate decisions chapters 
section largely experience observations real time programs 
discrete time signals discrete time signal function defined particular set values time 
common case called uniform sampling discrete time signal related continuous analog signal nt gamma sampling period sampling frequency signals internal external case constitute interface signal processing system external environment 
signal processing systems line external signals processed produced simultaneously occurrence external environment 
real time signal processing 
discrete time signals defined time computer implementations find convenient consider non negative time indices time zero nominal time real time program begins operating 
nt quantification time indexes positive implicit 
denote clock signal sequence times defined 
element clock called tick 
clock uniformly sampled signal chapter 
background material period fnt non uniformly sampled signal characterised quite easily 
nonuniformly sampled signal clock general discrete time signal represent samples analog signal 
sequence values representing changes state refrigerator door open closed closed example 
sequence messages processes multitasking operating system 
term uniformly clocked mean signal clock fnt constant non uniformly clocked signal 
non uniformly clocked signals treated chapter 
notational short hand logical arithmetic operators extend point wise clocks operator phi phi phi clocks equal earlier streams channels signal represented computer register data structure updates time contain zero values signal 
register data structure call channel implemented software hardware case program hardware write read channel 
define stream sequence values passes channel 
signal implemented synchronous stream streams equivalent signals chapter 
background material signal stream clocks 
write clock sequence times stream values defined words times written stream channel 
read clock sequence times stream values consumed read channel 
read write clocks general non uniformly spaced represent actual times certain events reading writing stream occur idealised times signal values occur 
signal clocks understood program read write clocks solely analysing describing programs 
assume action writing value reading value channel consumes infinitesimally small amount time 
read clock stream write clock relation signal clock stream clocks depend signal internal external 
consider input signal stream produced external environment signal clock equal stream write clock output signal stream read clock equal signal clock correct real time operation hinges program responding appropriately external signals 
equations input stream output stream words program attempt read input stream early write output stream sufficiently early 
non zero time difference chapter 
background material 
simple block diagram read write clock signal clock attributed time taken program transfer value signal stream example interrupt response time time copy value real time input output port channel 
functions systems signal processing system input signal output signal function system composed functions input output signals 
example system consisting series connected functions giving name internal stream written system equations implemented block diagram system blocks streams 
simple system shown 
important function signal processing systems delay operator gammak gamma delay operator usually implemented process inserting initial zero values fifo buffer contained relevant channel 
chapter 
background material digital signal processors digital signal processors microprocessors tailored specifically performing signal processing computations real time 
differences microprocessors cisc controllers powerful risc cpus centre key points need support certain types arithmetic efficiently ii need deterministic execution times 
section give overview characteristics devices 
focus modern floating point devices detailed information specific devices see 
illustrates simplified architecture typical floating point dsp core 
device contains functional units alu multiplier address units load store units shown operate simultaneously bank floating point data registers bank address registers 
typical instruction allows arithmetic operations indirect loads stores address register updates 
combination operations ideally suited vector operations elements stored memory fixed address increments major factor high performance dsps signal processing algorithms compared cisc risc processors fabricated comparable technology 
operations functional unit encoded single instruction word bits 
dsps resemble horizontally micro coded devices super scalar multiple instruction issue 
instructions execute cycle maintain rate instruction stream pipelined usually levels 
limited instruction width restrictions placed possible combinations operations example devices allow multiplier alu parallel alu performing addition subtraction 
complex instructions place limitations source destination registers 
tms tms essentially register memory machines operands located memory registers 
typical instruction devices parallel multiply add instruction ar ar ir addition multiply add operations operands loaded memory chapter 
background material floating point registers address registers index registers alu address units address data 
simplified dsp chip architecture address registers incremented 
provided memory operands located zero wait state memory devices sustain instructions rate cycle 
explicitly shown data path data registers alu multiplier address registers address generators 
paths parallel data address busses provide data transfer bandwidth necessary sustain instruction rates 
multiply add instruction core fir finite impulse response filter key dsp benchmark 
devices parallel multiply add subtract instruction substantially speeds execution fft fast fourier transform key benchmark 
contrast tms tms adsp dsp load store machines operands explicitly loaded data registers prior operating 
programmer writes separate fields instruction control alu multiplier load store address units 
example typical parallel multiply add instruction code fadd fields multiplier alu operations second data move placement memory operands little complicated device internal memory accessed twice instruction cycle external memory accessed 
tms external busses active simultaneously 
chapter 
background material address update operations 
apart architectural layout instruction set dsp devices feature hardware perform zero overhead looping 
mechanism varies device essentially allows device loop block instructions flushing pipeline block 
zero overhead looping essential example execute multiply add instruction cycle needed fir filter 
address generators quite sophisticated minimise need separate address manipulation instructions 
firstly increment contents index register allowing device step memory arbitrarily sized increments 
secondly perform modulo addressing address register automatically wrapped back base address incremented decremented past limit address 
descriptive real dsps implement modulo addressing little differently 
modulo addressing essential efficient implementation circular buffers fir filters 
thirdly support reverse carry addressing provides bit reversed addressing needed fft see section execution cost 
early dsps fully deterministic instruction execution time instruction took exactly cycle 
cpus modern dsps deterministic calculating execution time requires knowledge location memory operands devices interaction successive instructions instruction pipeline 
presence prioritised dma controllers instruction caches exact prediction execution times impossible 
simpler architectures non hierarchical memory architectures predictable instruction execution times dsp execution behaviour predictable modern risc devices essential ingredient design time critical systems 
summary material chapter provides background detailed chapters 
pipeline parallelism model underlies model computation described chapters 
chapters rely functional programming concepts notation notation different evaluation mechanisms functional programs place context dataflow style evaluation chapter 
background material programs 
chapters influenced goal realtime execution embedded dsp device provided overview real time programming concepts dsp devices 
chapter dataflow process networks dataflow model computation data items called tokens flow computing agents actors program represented dataflow graph dfg vertices correspond actors edges flow data actor 
term dataflow number different contexts interested pipeline dataflow actors long lived producing consuming items lifetimes 
model identical kahn process networks kahn gave denotational semantics 
pipeline dataflow network corresponds directly signal flow block diagram example box labelled block diagram sums signals point wise manner 
dataflow terms actor fired repeatedly time reads token input channels writes sum output channel 
illustrates simple dataflow network 
summer actor just described 
delay actor unit delay element appears time slot 
scale actor multiplies element input stream constant case value gammaa 
summer delay scale 
simple dataflow network chapter 
dataflow process networks lee coined term dataflow process describe kahn processes implemented sequence firings dataflow actor 
firing governed rule states conditions input values needed fire actor 
provided sequence actor firings deterministic actor forms deterministic kahn process 
assured kahn network processes deterministic able produce output data input data received 
view dataflow actor kahn process relatively new chapter develop formalism describing dataflow actors give semantics actors corresponding dataflow processes 
actors strict read required input tokens producing output common practice 
notation extends lee firing rules include state update token output token matching reading 
considering relationship dataflow actors non strict functional programming languages non strict actors needed accurately model way tokens produced consumed 
introduce new form actor called phased form 
execution actors proceed series phases may required place single firing strict actor 
phased form permits limited amounts non determinism gives new insights behaviour dataflow actors 
related term dataflow number different contexts 
associated dataflow machines dataflow model basis execution mechanism highly parallel machine 
actors fine grained machine operations addition edges graph represent transfer tokens machine 
machine executes actor required tokens inputs 
languages program machines called dataflow languages 
dataflow analyses dfas code optimisation compilers 
dfas provide compiler information variable lifetimes usage enables eliminate code executed re registers contents longer needed re order instructions order generate improved machine code chapter 
dataflow process networks sequences 
nodes dataflow graph fine grained operations corresponding single machine instructions edges dfg represent dependencies instructions 
pipeline dataflow actors perform relatively complex tasks operations may take dozens hundreds thousands machine instructions complete 
edges dfg correspond communications channels actors 
model am interested thesis 
computation graphs karp miller described graph theoretic model parallel computation essentially pipeline dataflow 
computation represented finite directed graph node represents computational operation arc represents queue data node 
associated non negative integers number tokens initially queue number tokens written executes number tokens read executes number tokens needed execute 
arc connected producer consumer node 
illustrates simple computation graph compute 
arc annotated 
takes token input increments outputs internal value zero initial value 
self loop contains initial tokens tokens drive computation 
multiplies inputs outputs result arcs 
self loop initial token value assumed zero 
writes final value received location holds result entire computation 
note maintains value counter internally explicitly passes previous output value back arc model care nodes maintain internal state perform explicit feedback 
execution computation graph containing nodes represented sequence sets sn set sn lg 
denote number sets sm sm 
proper execution iff chapter 
dataflow process networks 
computation graph 
sn arc gamma 
nodes arcs gamma sr condition states execute operation initial number tokens added total number tokens produced input channel exceed total number consumed plus threshold 
condition ii states operation executed finite number steps 
sequence partially ordered schedule sn contains nodes eligible execution time 
note graph proper execution 
karp miller prove number properties model 
firstly number performances operation proper executions initial tokens arc value token proper executions 
determinate 
karp miller develop number theories concerning termination graph nodes terminate times appear possible executions 
synchronous dataflow sdf synchronous dataflow sdf slightly general model computation graphs input threshold equal number consumed tokens 
designed chapter 
dataflow process networks 
synchronous dataflow graph specifically processing infinite streams 
sdf scheduling developed lee messerschmitt formed backbone efforts implement dataflow networks efficiently real time non real time execution 
shows simple sdf graph numbers node inputs outputs equivalent annotation indicates arc contains zero initial value small circle fork node 
graph computes running product input stream 
compared computation graph sdf graph driven infinite input stream produced node input arcs finite number initial tokens placed arc schedule calculated sdf graph ordered sequence node names repeated forever computes output streams input streams 
incidence matrix gamma contains token consumption production figures graph gamma number tokens produced node arc time fired consumes data gamma negative 
shows example graph decorated node arc numbers gamma gamma gamma gamma gamma vector number tokens arc time vector denotes node scheduled time chapter 
dataflow process networks node scheduled executing node changes number tokens arcs gammav assuming sample rates consistent network deadlock vector number times node executed schedule node executed times find assign node repetition count 
follow arc node assign connected node repetition count storing quantity exact rational number 
nodes reached find common multiple denominators repetition counts multiply find example network special case called homogeneous dataflow token counts unity 
calculating trivial schedule simulating execution graph compile time equation 
step numbers tokens arc equal number tokens consumed append consumer node schedule 
scheduling node appeared schedule times 
simple example possible schedule 
sizes internal fifo buffers determined way 
code generation system take advantage fact produce extremely efficient code 
efficiency improvement dynamic scheduling great considerable effort expended dataflow models restricted sdf sufficiently constrained sdf code applied parts graph 
sdf code generators operate firing code generation actors compile time time actor fired emits assembler code 
assembler code generation macros symbolic names programmer task easier allow optimisations 
powell example describe assembler code generation spw give examples assembler source code 
typical instruction looks chapter 
dataflow process networks addl ta ta tx table reg ty ta tx ty stand registers table region memory 
powell register allocation heuristics assign registers spill instructions inserted necessary 
example instruction may addl just described sdf code generation tend generate large amounts code general multi rate graphs code actor duplicated time actor appears schedule 
embedded dsp processors severely limited memory space sophisticated scheduling techniques developed produce loops generated output code minimising code memory required 
kahn process networks kahn described semantics language parallel programming process networks 
kahn language program consists network computing stations processes connected fifo buffered channels 
process repeatedly reads data input channels writes data output channels 
shows simple pipeline page written kahn language 
kahn processes communicate channels channels obliged transmit data finite time 
process read input channels blocking reads data available process suspend 
words process test presence data input channel wait data input channels concurrent systems csp 
semantics kahn process network expressed terms histories data transmitted channel kahn process function set functions histories histories 
domain set finite sequences containing elements set infinite sequences containing elements sequences related partial ordering prefix equal minimal element empty sequence 
chain sequences upper bound lub chapter 
dataflow process networks integer channel process integer integer integer repeat wait send abs process running integer integer integer repeat wait send comment main program running par 
kahn process network complete partial order cpo 
kahn process built continuous functions function continuous iff lub lub continuity ensures process able produce output received infinite amount output 
continuous process monotonic sequences monotonicity ensures output depend input allowing processes produce output receiving input 
chapter 
dataflow process networks process arity input channels output channels process specified continuous functions theta theta 
process network sigma set fix point equations cpos system unique minimal solution 
importantly minimal solution continuous function input histories processes monotonic 
means network kahn processes exhibits desirable property producing output receiving input ii networks connected manner single processes allowing hierarchical construction networks 
kahn macqueen suggest kahn process network implemented demand driven style routines 
process attempts read token empty input channel suspends process writes channel activated 
producer process writes data channel suspended consumer process resumed 
producer process may suspended course producing output data 
ultimately demands data propagate back processes generate input data say file read input channel say console 
single driver process usually process responsible printing program results 
dual demand driven execution data driven execution executing successor process requires data process executes input data 
process suspends attempts read channel data resumed operating system time data written channel 
implementation stream processing functions sisal uses technique 
dataflow processes lee defines dataflow process sequence firings dataflow actor 
dataflow process special kind kahn process execution broken series firings 
process sequence actor firings complete network executed firing actors appropriate order 
actors manage internal state need provide process illusion exclusive access cpu context switching eliminated 
important chapter 
dataflow process networks point real time signal processing context switching presents high overhead real time digital signal processor time needed save restore registers modern dsp quite high see discussion issue 
demand driven execution single processor implemented simply elegantly 
actor executes attempt read empty channel causes source actor fire immediately 
firing actor involves executing procedure propagation demands data proceeds recursively dataflow graph 
recursion unwinds data propagated back graph 
real time execution multiple processors presents awkward problems 
firstly data demanded ahead time guarantee data available ahead output signal clocks 
secondly demand data processor boundary causes demanding processor idle data produced 
effect overcome processing different part graph waiting re introduce overhead multi tasking 
difficulties demand driven execution dataflow networks led matthias meyer abandon attempts incorporate initial design signal processing object oriented kernel parallel dsp kernel 
believe important efficient hybrid scheduling mechanism possible 
data driven scheduling actor fired sufficient tokens input channels 
external scheduler tests tokens available fires actor 
naive implementation data driven scheduling simply cycles actors firing sufficient input tokens 
sophisticated schedulers attempt minimise unnecessary testing tracing graph topological order pushing tokens graph 
eager nature data driven execution processes may produce data needed 
form throttling needed bounding channel buffers solution pre emptive scheduling 
solution elegant suggesting hybrid demand data driven solution really needed 
ashcroft proposes machine architecture lucid mixing methods network 
edges network graph coloured data chapter 
dataflow process networks driven demand driven 
request tokens propagated backwards arcs tokens called normal data tokens called datons pingali arvind take approach give transformation dataflow graph demand driven semantics transformed equivalent graph data driven semantics 
essence demands explicit adding arcs actors carry 
propagation resulting propagation datons back graph performed data driven execution 
skillicorn proposes strictness analysis applied lucid programs allow sent graph fewer hops 
known actor demand data certain inputs actor bypassed demand output simply produce demands input anyway 
stream actors sent produce datons datons propagated data driven fashion bypassed actor 
jagannathan surveys current state dataflow computing models including comparison demand data driven execution 
dataflow architectures proposed implementation functional programming languages 
field harrison point demand driven evaluation functional programs gives normal order semantics data driven evaluation gives applicative order semantics chapter 
firing rules lee formalised notion firing actor 
actor arity set firing rules ff fn tuple patterns input pattern sequence tokens manifest constant wildcard symbol 
lee defines modified version prefixing predicate chapter 
dataflow process networks express qg sequence sequence available tokens input channel 
available tokens represents undefined part sequence words tokens computed 
firing rule actor input channels enabled mg sequence available tokens th input channel 
lee firing rules capture essential aspect scheduling dataflow actor strict data driven semantics 
strict mean input tokens actor begins execute 
consider examples 
summer actor sums corresponding elements input channels requires token fire select actor consumes token boolean control input true consumes token data input passes output consumes token data input passes output 
firing rules true false non deterministic actor form kahn process 
archetypical nondeterministic actor merge passes available token input output 
firing rules chapter 
dataflow process networks recall kahn requirements process perform blocking reads 
non deterministic merge satisfy criterion test inputs see data pass output 
non deterministic merge deterministic making time part data stream see chapter 
lee gives algorithm determine finite set firing rules tested process performs non blocking reads 
set firing rules satisfies condition lee calls sequential briefly algorithm works follows choose input contain element 
head elements patterns unambiguously divide firing rules subsets fail 
remove head elements repeat procedure subset modified patterns 
fail time rule subset empty element long 
algorithm terminates failing rules sequential 
effect algorithm mimics run time behaviour actor 
standard form dataflow actors lee firing rules capture input conditions necessary fire actor saying precisely firing mechanism pattern matched available input tokens 
apart matching reading input tokens actor firing updates actor internal state ii calculates produces output tokens 
section give syntax describing actors followed precise semantics dataflow actors processes 
syntax term dataflow actor mean things description actor actual instance actor network 
call actor schema actor instance necessary distinguish 
sugared syntax actor schemata shown 
general form stateful actors 
actor called name zero parameters 
parameters arguments actor streams reducible constant compile time 
init clause specifies initial value chapter 
dataflow process networks actor name init rule update output 
rule update output actor name rule 
rule 
sugared syntax standard form actor stateful actor stateless actor actor internal state assumed known compile time 
followed rules containing input pattern update action update output action output input pattern corresponds lee firing rules 
pattern sequence token patterns token pattern identifier simple constant structured type containing element patterns 
difference lee firing rules identifiers symbol 
patterns irrefutable fail match pp 

loose interpretation definition allowing identifiers tuples identifiers structured patterns known matched value pattern match 
example irrefutable pattern see group actor uses vector irrefutable pattern 
update action function current value actor internal state value state completion firing 
rule selection irrefutable pattern 
update expression contain free variables variable output action function actor internal state sequences sequences output tokens produced firing 
output expression manifest sequence expression manifest sequence result 
manifest sequence expression length sequence determined purely syntactically example valid output chapter 
dataflow process networks expression copy 
ensures number tokens produced determined examining output action knowledge data values 
patterns output expressions sequences actor input output channel respectively 
input output channel pattern output expression tuple sequences 
examples clarify description 
consider delay operator expressed standard form actor schema rule actor delay init rule update output actor parameter value initial value actor state 
firing actor produces current state sets state equal value new input token 
output values delayed time slot 
signal processing delays usually initial state zero delay actor instantiated delay 
slightly complex actor implements running process actor parameters actor running init rule update output stateless actors simplified syntax omits keywords expressions related internal state 
written full stateless actor init value update action update output action output operationally actor useful delays strict 
accurate version delay section 
chapter 
dataflow process networks examples stateless actors 
summer actor rule actor summer rule scale actor rule actor scale rule theta select actor section rules actor select rule true rule false non deterministic merge actor rules actor merge rule rule desugaring actor schemata previous section desugared translated simpler easily manipulated form translation 
introduces notation syntactic translation functions double square brackets enclose syntactic element 
desugared form actor schema triple possibly empty tuple actor parameter names actor initial state set rules 
rule translated triple upd pattern upd update action output action 
chapter 
dataflow process networks actor name init rule rule rule rule rule update output 
desugaring standard form actor example delay actor applying transformation triple stateless actor uses translation result translated actor upd equal identity function example select actor true false semantics lee defines dataflow process sequence firings dataflow actor 
provided actor firing rules sequential process kahn process mapping input histories initial state output histories 
section give semantics actors state precisely meaning dataflow process 
need primitive types help describe actors precisely type actor internal state oe type input pattern patt type tuple patterns pattern type possibly empty tuple schema parameters parameters 
saw section kahn process function sequences sequences 
chapter consider infinite sequences 
operator define type synonym 
inputs outputs actor infinite sequences tuples infinite chapter 
dataflow process networks sequences input theta theta output theta theta actor fires consumes produces finite segments input output sequences theta theta theta theta update output actions accept state value produce new state output segment respectively oe oe oe rule triple pattern actions rules set rules schema triple parameters initial state rule set rule pattern theta theta rules schema parameters theta oe theta rules execution actor proceeds distinct phases instantiation actor parameters ii execution actor stream arguments 
lee stresses difference parameter arguments stream arguments ptolemy parameters evaluated initialisation phase streams evaluated main execution phase 
result code generation take place parameters known stream data unknown 
separation parameters streams compile time run time values clear compulsory 
actor instantiated supplying schema parameter values 
represent chapter 
dataflow process networks instantiate schema parameters actor instantiate fr inst inst upd upd 
instantiating actor instantiation schema name parameter values write name schema parameters name unique identifier actor instance 
instantiating schema creates new actor instance actor oe theta rules instantiate actor parameter formal occurring free initial state firing rules substituted corresponding actual 
gives instantiation function 
notation means occurrence identifier occurring free replaced expression notation extends point wise tuples substitution variables actor instance connected actors network proceed second part execution dataflow process 
process infinite series firings proceeds stages input state update output 
turn divided parts matching rule patterns input sequences select rule reading input segments input sequences 
pattern matching rule selection performed semantic function match chapter 
dataflow process networks accepts rule input sequences produces rule matches sequences 
match rule input rule match pm xm match match patt bool match xs true notation pm haskell name rule triple containing patterns pm elements insignificant value 
function performs pattern matching tokens functional languages 
implicit definition match concept failure input patterns match input sequences match returns 
pronounced bottom denoting undefined value 
note compares token pattern required tokens available rule selected execution proceed 
semantics captures strictness actors 
selected rule read function splits input sequences segments read firing remainder sequences read rule input theta input read pm xm read read xm read patt theta read xs xs input function combines matching reading matches rule set input sequences returns selected rule input segments remaining chapter 
dataflow process networks input sequences input rules input rule theta theta input input fr match 
match read input uses operator select valid rule possible matches bottom avoiding 
line means pattern matching fail match succeeds 
behaviour chosen emphasise semantics works deterministic actors 
update output semantic functions update actor state produce output rule 
inputs segment input sequences current state 
functions somewhat simpler derive input required bind free variables named input patterns supplying arguments update rule oe oe update output rule oe output fire function combines input state update output single actor firing 
firing accepts unread input history current state produces chapter 
dataflow process networks remaining unread input history state segment output sequences fire rules input theta oe input theta oe theta fire rs input rs update output function process set rules starting state tuple input sequences endlessly chooses fires rule process rules input oe output process rs process fire rs output segments prepended remainder output sequences operator ys ys assume extends tuples sequences 
give precise meaning dataflow process dataflow process corresponding dataflow actor function io io supplies actor initial state complete input sequences process io actor input output io rs process rs consumption production vectors fired actor consumes number tokens input streams produces number output streams 
numbers manifest actor firing rules input patterns output actions 
chapter 
dataflow process networks operator return length sequence operator return lengths sequences tuple vector 
defined informally si consumption vector production vector contain number tokens consumed produced rule recall sdf actor consumes produces known constant numbers tokens firing section 
property formally stated terms consumption production vectors 
define fi operator return value arguments equal fi fi fi fi 
fi fi extend point wise vectors hx fi hy hx fi fi consumption production vectors actor rules fr defined fi fi fi fi input input patterns clauses length chapter 
dataflow process networks consumption vector contains integer appropriate position contains 
pronounced bottom indicating number determined additional information 
lengths output sequences output length production vector similarly contains integer 
example summer vectors summer summer select actor vectors select select definition sdf actors sub class homogeneous dataflow actors stated terms consumption production vectors definition synchronous dataflow sdf actor arity theta synchronous dataflow sdf iff definition homogeneous dataflow hdf actor arity theta homogeneous dataflow hdf iff sdf actors usually expressed single rule call actor single rule irrefutable token patterns simple sdf actor 
actor need perform pattern matching rule selection rule input chapter 
dataflow process networks actor delay init rule update output actor group rule hx actor concat rule hx actor zip rule actor unzip rule actor map rule 
canonical sdf actors tokens fail match 
needs count input tokens read values 
canonical sdf actors sdf actor implemented network containing delays instances just actor schemata 
chapter give functions equivalent schemata give examples give schemata texts argue sdf actor translated network actors 
discuss role actor parameters 
lists actors delay 
parameter 
completeness delay shown actor implemented initial values fifo buffer 
note delay actor maintains state group breaks stream stream vectors 
delay parameter known order produce formal executable actor text 
notation formal 
really limitation fact actor text chapter 
dataflow process networks contain manifest sequence output action 
see chapter group powerful notation defined requiring known compiletime 
concat inverse group concatenates stream vectors stream 
parameter known order produce formal actor text 
zip unzip combine multiple streams stream tuples vice versa 
require parameter known compile time case possible remove restriction powerful notation parameter determines number input output channels actor 
chapter limitation force restricted versions functions 
map actor takes function parameter applies element input channel 
known efficient implementation map generated system support dynamic creation functions knowledge run time 
actor kind mimics higher order functions functional languages called higher order actor argue informally sdf actor implemented delays schemata 
pointed lee stateful actor represented stateless actor unit delay feedback loop carrying state value 
remaining schemata implement stateless sdf actor follows 
consumption production vectors actor hc hp input insert group actor connected arc change pattern input hx 
output insert concat actor connected arc change expression sequence output hy 
actor hdf 
actor input zip actor gather input streams stream tuples change input pattern xm 
actor output change output expression unzip actor change stream tuples back tuple streams 
actor input channel output channel form actor implemented map 
chapter 
dataflow process networks phased form dataflow actors section introduce phased form dataflow actor 
execution actor proceeds series phases phased form expresses finer grain computation standard form 
motivating factors development desire better express non strict demand driven execution 
breaking actor firings phases actors need perform minimum amount input computation necessary produce token output 
phased form permits non deterministic behaviour semantics outlined section provides means characterising non deterministic behaviour 
particular actor non deterministically choose consume tokens different inputs form deterministic process 
clarify point consider sum squares actor similar summer squares input tokens summing actor rule definition says order inputs read outputs produced choice particular case 
saw section standard form actor reads input tokens performing computation output 
need read token input square attempting read token second input 
wait token input square wait token input 
actor satisfy kahn blocking read criterion implements kahn process 
phased form actor way precisely expressing ordering input computation output non determinism allowed limited manageable way 
see useful considering demand driven execution potential deadlock situations 
number motivations actors chapter 
dataflow process networks phased form express actors expressed standard form iota actor described section 
taken operational definition computation proceed input received 
single actor important network may computation proceed part network parts blocked waiting data 
phased form potential provide consistent semantics hierarchical actors able develop algorithm computes phased form actor network 
see section phased form actors generalisation buck multi phase integer dataflow actors cyclo static dataflow engels comparison section 
syntax phased form actors extension standard form actors 
key differences firing subset rule set considered firing 
subset called eligible rule set rule eligible set satisfied actor non deterministically chooses fires 
full phased form syntax shown 
actor rules 
order identify eligible rules rule explicitly numbered 
initial eligible rule set oe oe kg start clause 
rule fired actor uses select action update eligible rule set firing 
restrictions explicit syntax 
firstly token patterns irrefutable fail match 
standard form state pattern actions irrefutable 
secondly right hand side select action set integers expression form fintg fintg chapter 
dataflow process networks actor name init start oe rule update output select 
rule update output select actor name start rule 
rule 
sugared syntax phased form actor stateful actor stateless actor boolean expression int stands literal integer constant 
syntactic form ensures eligible rule sets manifest actor text 
oe set literal integer constants 
rules perform possible actions 
convenience omit update clause update action update output clause output action output tuple containing appropriate number empty sequences 
examples clarify phased form works 
version nondeterministically reads token input written rules shown 
underscore represents don care pattern 
delay operator strict standard form actor page 
strict actor way represent delay delay usually able produce output token reading input token 
phased form write version delay produce consume tokens arbitrary interleaving shown 
example internal state list tokens phase token removed list written output phase token read input appended list 
chapter 
dataflow process networks actor init start rule update select rule output select rule update select rule output select 
non deterministic actor stateless actors simpler syntax 
example select stateless rules actor select start rule rule rule non deterministic merge actor rules actor merge start rule rule eligible rule set course kind state am treating eligible rules explicitly term state refer information maintained firings 
chapter 
dataflow process networks actor delay init start rule update xs xs output xs select xs null xs rule update xs xs select xs 
phased form delay actor actor name init phase oe rule rule oe rule rule rule update output select 
desugaring phased form actor phased form actors desugared similar manner standard form actors 
gives translation desugared actor tuple containing parameters initial state initial rule set set rules rule tuple input patterns update output select actions 
instantiation proceeds similar fashion standard form actors case instantiated phased form actor triple initial state initial rule set set rules 
example instantiated merge actor chapter 
dataflow process networks phase graphs possible orders rules selected captured phase graph 
phase execution rule phase graph useful tool characterising analysing behaviour phased form actors 
notational convenience rule identifiers interchangeably rules 
shows phase graphs example actors previously annotated consumption production vectors 
note vertex phase graph cycle ensures actor continue execute input data 
phase graph kinds vertex 
rule vertices correspond rule labelled rule identifier rule occurs exactly 
choice vertices correspond non deterministic choice named choice phi phi set successor vertices 
choice vertex occurs non singleton set select actions 
choice vertices coloured black labelled names clear context 
vertex corresponding initial eligible rules set marked asterisk 
edges graph correspond allowable transitions rules 
singleton set produced rule select action edge rule vertex vertex corresponding single rule non singleton set edge rule vertex choice vertex 
precisely succ succ succ choice phi phi succ foeg foeg succ phi phi succ phi succ phi succ sequence rule firings corresponds path phase graph 
write may useful special phase called say initialisation phase predecessors cycle 
yield practical advantages corresponds computation proceed zero time 
chapter 
dataflow process networks 
phase graphs delay select merge length path ae vector hoe oe paths function return set paths vertex 
vertex oe path intersects cycle say hoe oe set returned paths infinite including paths oe oe oe oe oe oe oe oe oe 
paths specify cycles relation returns set cycles starting node cycles oe oe oe succ semantics phased form allows precise description order tokens consumed produced 
standard form phase fulfils conditions input tokens consumed output tokens produced 
phase complete phase 
phase strict actor firing proceeds series phases actor non strict 
define meaning firing forms chapter 
dataflow process networks execution terms paths phase graph falls short full semantics phased form actors sufficient describe important characteristics 
path represented vector rules path length path graph ae hoe oe need know consumption production vectors path meaning executing ae 
consumption production vectors rule way standard form actors 
consumption production vectors path ae ae oe oe ae oe oe addition operator assumed extend point wise vectors 
firing single rule essentially identical firing single simple rule actor 
read update output section slightly modified rule tuple triple 
step semantic function execute single rule step rule input oe input theta oe theta step read update output note am trying give full semantics particular am examining computation performed path phase graph state update output production calculation eligible rule set 
full semantics need calculate sets input output sequence mappings 
sets chapter 
dataflow process networks required account non deterministic choice 
execution path execute function 
execute takes path vector rules returns input output mapping produced executing rules order 

operator vectors way cons operator sequences 
execute path input oe theta oe execute execute 
rs step execute rs complete firing phased form actor execution cycle start vertex definition complete firing complete firing phased form actor execution cycle phase graph start vertex oe execute ae ae cycles oe cycles graph pass oe infinite number complete firing paths 
section gives example actor 
actor infinite number complete firing paths phased form equivalent sdf satisfies condition consumption production vectors definition phased synchronous dataflow actor initial vertex oe phased synchronous dataflow iff fae ae cycles oe finite ii consumption production vectors cycles equal ae ae ae ae summing vectors cycles applying criterion seen phased sdf 
note chapter 
dataflow process networks phased sdf actor necessarily deterministic 
example actor exhibits kind internal non determinism actor silly start rule rule note definition phased sdf include actors considered sdf actors see section example 
section showed illustration non deterministic actor produce deterministic process 
process deterministic nondeterministic choice affect computation performed actor 
necessary condition deterministic process choice vertex oe paths ae cycles oe equal ae ae 
stronger necessary sufficient condition examine output state sequences definition kahn actor phased dataflow actor forms kahn process iff non deterministic choice oe phase graph cycles oe finite 
paths ae cycles oe equal values execute ae 
paths ae cycles oe equal values fst delta execute ae paths ae cycles oe write see 
condition paths behave exactly condition inputoutput mappings state ignored subsequent decisions anyway 
condition requires explanation execute ae need return state ae cycles oe provided differing states ignored 
define const path ae hoe oe writes state iff exists oe update action form const oe output select actions form const const proposition main insight section 
practical means determining conditions satisfied perform reduction execute symbolic se chapter 
dataflow process networks quences 
consider 
choice vertex choice cycles choice fh ig 
path execute step execute execute execute step similar process cycle yields expression 
satisfies condition 
state written rules read rules condition satisfied forms kahn process 
graphs select kahn process choice vertices delay merge fail equal consumption production vector condition 
cyclo static multi phase integer dataflow buck proposed multi phase integer dataflow actors 
integer dataflow actor number tokens consumed produced arc function control token 
repeat type actor consumes integer control token phase executes phase number times token 
example buck iota actor reads control token value outputs sequence integers inclusive 
phased actor write iota chapter 
dataflow process networks 
phase graph iota actor iota init start rule update select rule update output select shows phase graph iota 
surprisingly actor phased sdf infinitely cycles start vertex deterministic 
consumption production vectors graph exactly special class actor cyclo static synchronous dataflow actors proposed engels 
general form actor actor init start rule update output select rule update output select compared iota actor value supplied parameter read input 
actor sdf definition phased sdf chapter 
dataflow process networks recognise 
instantiated known actor expanded phases case phase graph contains single cycle recognisable sdf 
show network actors scheduled statically schedule certain assumptions execution timing lower execution time sdf static schedule 
cyclo static dataflow multi phase integer dataflow actors reduce memory requirements required statically generated schedule 
buck extends scheduling techniques developed boolean dataflow switch select canonical boolean dataflow actors determine graph containing integer dataflow actors bounded schedules cluster graph order extract control structures loops loops 
execution mechanisms phased form actors non strict 
section examine implications dynamic scheduling phased form actors look implications networks 
far specified restrictions granularity phases 
example written actor start rule standard form version strict 
phased form useful actor fulfils informal criteria 
consumes minimum number input tokens needed produce single output token 
outputs token soon possible performs computation 
outputs tokens output performing computation 
criteria met ensure actor performs minimum amount input output computation necessary keep data flowing graph 
consider chapter 
dataflow process networks effect data driven scheduler input patterns contain irrefutable token patterns scheduler need count available tokens read values 
scheduler fire actor sufficient input tokens output space buffers bounded eligible rules 
demand driven execution possible 
phased form actor perform strict actor time fired 
output channel token demanded 
target phase set phi phase actor phi foe oe qg oe meet demand actor execute path ae element current eligible phase set phi element phi ae phi phi note value affect path taken actor mechanism actor know output data demanded 
possible source non determinism believe best avoided 
hierarchy strictness issues raised lee examination dataflow actors dataflow equivalent procedural abstraction 
natural choice role dataflow network block diagram systems ptolemy hierarchically compose actors networks actors 
lee points semantics hierarchical sdf actor fact network actors represents 
consider hierarchical actor component actors homogeneous strict actors 
considered fine example homogeneous strict actor 
connected network network deadlocks fire top input data top output produce data fires 
course different strict theta actor behave 
different internal network behave substituted place case fire producing token top output chapter 
dataflow process networks 
deadlock hierarchical actor actor network deadlocked network fire producing token bottom output cycle repeat 
ptolemy side steps problem expanding hierarchical actors scheduling 
somewhat unsatisfactory 
phased version actor say allows computation proceed receiving input 
supposing simplicity stateless writing example mean token produced firing input tokens write actor init start rule update output select rule output select placed network deadlock behaves way internal network connected way 
fire rule data bottom input phase fire rule consuming new input token token received previous phase repeats cycle 
phased form offers promise consistent semantics hierarchical actors corresponding networks 
algorithm find phased form hierarchical actor open research prob chapter 
dataflow process networks select 
phased network example network graph phase graph actor net init start rule update select rule output select rule output select rule output select rule output select rule output select rule output select 
example phased network phased form actor chapter 
dataflow process networks lem 
goal find algorithm approximates compile time set possible run time behaviours network 
illustrate example hierarchical actor called say net phase graph actor homogeneous stateless 
phase net represents phases phased form description network obtained tracing execution network hand shown 
summary chapter contributions dataflow theory 
semantics dataflow process networks 
description actor firing function semantics gives precise meaning dataflow process formed actor 
semantic description concise elegant re formulate semantics 
second contribution description phased actors 
semantic description incomplete offers new characterisation dataflow actors interesting indications 
particular task determining phased form complete network prove challenging 
remains seen phased form actors lead efficient scheduling certain kinds dataflow actors networks descriptive tool 
formal description actors paved way chapters section argued dataflow actor implemented schema 
implement functions correspond schema function expressed terms functions translated dataflow network 
chapter visual haskell visual haskell visual dataflow style language haskell 
intent ultimately provide complete visual syntax haskell program visualisation tool programming language right 
roles complementary haskell standard textual form replacement improved notation 
presently part haskell supported notable omissions class type declarations 
sufficiently developed useful 
visual haskell evolved need explain thesis non functional programmers 
began ad hoc notation drawing functional programs see ken dawson uts implemented prototype editor language stimulating development precise usable language 
style visual haskell dataflow programs described data function boxes connected arcs representing flow data 
ways superset dataflow supporting structured dataflow constructs conditionals case statements pattern matching higher order functions scoping 
haskell polymorphic type system visual notation 
lexical scoping unrestricted visual haskell programs lose key advantages dataflow explicit data dependencies program 
particular interest visual haskell way handles higher order functions visual haskell curried higher order functions easy construct firstorder functions 
need special function slots enforced chapter 
visual haskell tion order higher order functions 
construct case expression say function applied way named function 
sections briefly survey visual languages introduce visual haskell example 
sections formally give syntax visual haskell translation haskell syntax concrete visual syntax 
related visual programming languages vpls relatively new 
subject disagreement worth real world projects visual programming 
success systems indicates strongly visual programming applied appropriate problem domains supported appropriate tools offers kind understanding absent purely textual languages 
successful interface paradigms visual programming languages dataflow forms 
signal processing dataflow visual languages years common block diagrams describing signal processing systems 
successfully fields image processing instrumentation surveys number dataflow visual languages 
form layout cells containing formula computes value usually terms values cells 
dataflow languages forms dataflow ptolemy example uses form enter actor parameters dataflow connect streams labview uses forms front panels virtual instruments 
informal diagrammatic notations describe explain functional programs time 
example explains function application box arrow diagrams kelly illustrates networks streams processes written annotated pure functional language waugh illustrate effect program transformation parallelism 
proposals formal visual functional languages 
cardelli proposed visual functional language function application denoted juxtaposition function name arguments bracketing denoted containing boxes pattern matching select expressions bindings denoted placing chapter 
visual haskell 
factorial function cardelli language left pointing arrow name expression 
shows definition factorial function cardelli language fact fact fact frames clause 
top frame vertical bar represents zero box 
bottom frame heavy rectangle attached ellipse represents 
boxes enclosing arguments point function applied 
expression bound icon 
cardelli suggests visual language useful applied manipulation dimensional data structures 
gives examples manipulations boxes containing characters symbols functions place frame box decompose compound box list components 
functional language najork golin visual dataflow language enhanced show tell similar features including higher order functions polymorphic type system 
key concept inconsistency arc passes inconsistent box carry data 
example illustrates factorial function 
left type declaration factorial function integers integers 
main box split sub boxes 
left input data flows box labelled input data zero box value passed output 
box inconsistent produces data 
right data flows predicate box 
provided input datum satisfies predicate containing box inconsistent data flows produce output value 
datum zero box inconsistent produces data 
inconsistency perform role conditional execution chapter 
visual haskell 
factorial function structured type notation performs pattern matching 
iteration governed inconsistency iteration construct repeatedly applies internal dataflow graph previously produced data long graph consistent 
higher order functions supported function slots function icon placed inside icon higher order function 
visual haskell argument slots section generalisation function slots 
includes visual notation polymorphic type system may starting point visual haskell missing type notation 
describe visual functional language backus functional programming language fp 
language essentially visual dataflow language explicit support higher order functions function arguments placed icons higher order functions 
editor implemented smalltalk supports interesting concepts act programming easier 
example order function icon dragged higher order function icon firstorder function argument 
dragging box connected output function box connected input second function cause functions connected arc consider issues chapter 
enforce artificial view distinction order higher order functions mainly fp 
kelso proposes visual functional language programmer interaction chapter 
visual haskell influences design language 
expression graphs similar dataflow languages inputs expression connected terminator nodes containing argument type outputs connected terminator nodes labelled type entire expression function type 
application function argument achieved dragging output node input node 
sub expressions collapsed single node 
mechanisms important reduce clutter complex visual expressions 
visual languages represented conventional grammars means describing programs described example 
increasing amount grammars visual syntax particularly relevant automatic generation visual language parsers 
golin reiss example picture layout grammar 
underlying grammar model multisets eliminate ordering implicit textual grammars 
number primitive operators specify relationships pictures example production contains matches picture production inside production complex productions defined terms operators additional constraints picture attributes 
general formalism conditional set rewrite systems proposed najork kaplan 
consists set rewrite rules sets terms governed predicate terms 
example rewrite rule box num inside states finished box number located inside 
rewrite rule picture rewritten single finished box valid visual language defined rewrite rules 
najork kaplan show specify visual syntax different set rewrite rules translate picture textual language 
show specify dimensional visual language presumably motivated cube dimensional logic programming language 
sections chapter touch differences visual haskell visual dataflow languages 
motivations functional language chapter 
visual haskell thesis apparent correspondence functional languages dataflow 
highlighted fact languages programming dataflow machines functional 
closer examination important differences 
ambler survey comparison programming paradigms highlight differences functional dataflow paradigms 
pipeline dataflow operates streams data evaluation mechanism strict nonstrict see section 
functions class objects dataflow visual haskell example shows function value partially applied abstraction flowing arc ambler comment structuring mechanisms dataflow described 
point section visual haskell includes mechanisms similar structured dataflow languages general 
side constructs may interfere dataflow schedulers flow data constructs explicit 
powerful feature functional languages rare dataflow languages pattern matching cube support form pattern matching 
key difference functional dataflow languages treatment functional language performed key ways calling system primitives lazy lists representing history input output ii calling system primitives continuation function 
idea monadic adopted technique superficially similar continuations external world single threaded code allowing performed immediately side effecting operation 
contrast dataflow languages perform special nodes produce consume streams 
visual haskell visual haskell essentially visual dataflow language functions represented named boxes function application arcs boxes 
shows visual haskell form version factorial function section fact chapter 
visual haskell fact 
factorial function visual haskell fact function definition displayed window indicated shadowed rounded rectangle 
name function fact icon stylised character displayed window title bar 
inside right window frame input patterns case inside left result ports expressions connected port result values function 
guarded alternatives separated dashed line 
top right example guard 
iconic textual representations binary operators 
example theta 
boxes adjacent box alternative notation connecting boxes arcs 
result expression case just constant connected result port 
dashed line condition drawn blank space 
note recursive call fact denoted icon 
pattern bindings shown connecting arc expression pattern graphic 
binding pi shown 
variable simplest pattern 
note port pattern semi circular triangular arc pattern port arrow 
patterns nested look expression drawn backwards 
example shows pattern zs 
box divided jagged line pair constructor tall narrow box list constructor 
note patterns connected arc juxtaposed chapter 
visual haskell zs pi 
patterns map xs 
map function appropriate location 
shows definition haskell map function map map xs map xs function name icon appear window title bar 
time function definition clauses separated visual syntax solid horizontal line 
note list constructor icon pattern right hand side lower clause data constructor left clause 
recursive call map denoted double box icon 
argument shown inside icon 
example argument slot see section 
icons thesis plain ease drawing interesting icons real graphical development system 
shows icons haskell standard prelude data constructors shows icons standard prelude functions lists 
data constructors tuple produced chapter 
visual haskell tuple tuple cons cons list list 
icons standard prelude data constructors map zipwith foldl foldr scanl 
icons standard prelude functions desugaring translation section 
choice iconic notation think personal readily 
choice icons visual theme represent class icons various arbitrary decorations indicate specific icons 
example doubled box indicates higher order function lists higher order functions vectors chapter obscured box filled black 
note visual haskell depend icons syntactic sugar visual haskell program drawn labelled boxes plain syntax described section icons 
excessive icons certainly obscure program meaning unfamiliar believe familiarity consistently designed icon set yields great improvement ease program understanding 
icon annotation arcs indicate type 
example list carrying arcs decorated asterisk annotation 
annotations useful visual aid program understanding formalised representation 
chapter 
visual haskell 
function composition incidentally am habit drawing visual haskell expressions data flow right left 
reason simple direction data flows textual programs 
example delta delta data flows see 
visual haskell care direction diagrams thesis left right data flow 
prototype visual editor constructed ken dawson undergraduate project editor indicates view development system visual haskell feasible 
interesting point noted construction prototype visual parser needed interpret visual programs 
prototype editor builds graph representing visual haskell program user draws program 
editor syntax driven context editor allows user draw pictures sense visual haskell 
generate haskell code completed visual haskell function system traverses graph generating linear haskell code way need parse dimensional picture 
cardelli observation system translated syntax trees visual representations 
despite fact visual haskell include haskell dawson system able generate executable haskell functions 
type declaration function inserted textually form associated function information form included numbers inputs outputs 
generation textual haskell function type simply written verbatim output file 
dawson printer print acyclic graphs oversight simple correct 
visual syntax preliminaries visual haskell designed alternative notation haskell chapter specifies visual haskell terms haskell 
approach may limit scope concepts introduced visual language example chapter 
visual haskell concept inconsistency advantages haskell powerful features visual dataflow systems polymorphism higher order functions examples 
easier precisely define semantics visual haskell terms haskell semantics attempting define new semantics scratch 
notion view development system feasible 
visual haskell programs executed standard haskell compilers interpreters required translator visual textual syntax 
remainder section describes means visual syntax specified 
visual elements visual haskell program composed visual elements arranged computer screen 
surface elements arranged called canvas 
valid program fragment pict short picture 
recursively composed simpler ultimately primitive boxes icons lines strings 
special kinds primitive pict ports arcs ports serve connection points 
output ports triangular carry non function value rectangular carry function 
input ports triangular expressions semi circular patterns 
arcs join ports 
kinds arcs data arcs expressions binding arcs patterns 
key ways composing complex 
attached located immediately adjacent 
port example attached pict kind 
connected arc port port connected ports arc form new pict 
pict contains second wholly enclosed 
claims constructions calls linkage containment account majority diagrams computer science 
chapter 
visual haskell 
simple visual elements output ports input ports containment data connection pattern connection specifying visual syntax syntax visual haskell specified translation haskell syntax concrete visual syntax 
syntax chapter 
far syntax haskell goes means complete purposes chapter 
points note sub scripts distinguish unique occurrences production 
functions tuple cons produced de sugaring translation section 
haskell equivalent respectively 
binary operator op enclosed parentheses treated function identifier 
de sugaring translation translates operators form 
constant production includes floating point literals character literals string literals 
string literals treated constants lists characters 
productions represent haskell match phrases see section 
semi colon indicates concatenation 
example binding contains bindings may series bindings 
square brackets indicate optional part 
visual syntax optional non terminals shown understood visual non terminals textual ones 
chapter 
visual haskell 
non function identifier values 
op function identifier function names literal constants tuple cons data constructors op binary operators patterns expressions case match match delta delta delta boolean guards bindings delta delta delta match match match match phrases 
haskell syntax backslash abstraction constant width typeface 
am unable get produce 
translation syntax picture broken passes 
textual de sugaring pass section 
removes haskell syntactic sugar reduce number special cases 
example infix operators changed prefix functions special syntax lists tuples changed data constructors 

translation haskell syntax core visual syntax section 
production rewritten concrete visual syntax 

selective visual sugaring translation section picture core syntax modified improve appearance layout 
visual syntax quite specify details exact position canvas topological relationships 
example states connected state relative absolute chapter 
visual haskell positions canvas 
exact layout positioning shall assume decided mechanism called layout manager 
layout manager form automatic graph drawing screen layout algorithm assisted interactively user 
simple visual language assist notation motivation visual syntax sugaring sections sections give example simple language 
consider expression language variables functions arity 
non function identifier 
function identifier positional grammar approach visual syntax language specified primitive visual operations 
suppose primitives describe particular kinds boxes variables functions 
operation name produces string representing argument contains connect represent containment linkage relations 
write contains name contains name connect translate haskell syntax grammar chosen direct approach result translation visual representation just textual description 
gives rewrite rules simple language 
rules straight forward variables represented grey box single output port functions larger white box input port output port 
name identifier enclosed quotes meta syntax equivalent string 
chapter 
visual haskell 
visual syntax simple language translation rules simple sentence translation rules port matching third rule rewrites function application 
diamond shaped graphic represents visual non terminal visual equivalent production labelled 
visual element non terminals concrete visual syntax elements part picture 
case element arc connects output port input port 
recursively applying rewrite rules complete picture produced example picture represents sentence 
currying functions argument simple approach doesn 
new concepts needed live dead ports matching ports 
illustrate concepts complex visual syntax language functions multiple arguments left section 
gives translation rules port matching 
variable function encountered created live ports coloured grey 
objects connected connected ports killed black 
difficulty ports exist draw black ports new additions picture picture grey ports black ports 
matching existing ports avoid difficulty 
consider input port third rule black partially obscures grey port 
order chapter 
visual haskell ff ff 
sugaring simple language sugaring rules sugaring sugaring apply rewrite rule obscured grey port match grey port result picture contains obscuring port black 
contrast output port matches live port remains live 
note reason port matching easier support curried functions merely change colour connected ports 
complex removed need translate haskell intermediate language earlier 
having translated program picture picture appealing 
icons example popular ingredient visual interfaces 
seek remove redundancies left textual notation multiple boxes variable example 
changes picture affect meaning kind visual syntactic sugar 
kind modification expressed set bi directional rewrite rules 
shows suitable set simple language 
rules allow variable function box replaced icon graphic meta syntax icon representing object labelled 
third rule allows variable box shared applications 
rules left production produced translation core syntax right alternative form 
rules reversible double ended arrows 
sugaring rewrite allowed result acceptable layout manager 
language simple allow multiple variable occurrences 
assume productions omitted 
chapter 
visual haskell delta delta delta cons delta delta delta tuple delta delta delta list delta delta delta op op op op op op flip negate 
de sugaring rules example icon defined particular function layout manager simply avoid particular transformation merging variable boxes causes arc cross merge disallowed 
words sugaring rules selectively intelligently 
illustrate shows fragment visual program core syntax shows look visual sugaring 
de sugaring phase translation removes haskell syntax lists tuples 
rewrite rules accomplish 
amount desugaring minimal 
rules equations recognise series comma cons operators combine single constructor allows meaningful icons 
equation removes infix operators formed back quoting function 
equations translate binary operators sections 
equations produce permuted function see page 
equation translates unary operator negation 
core syntax core syntax visual haskell specified set rewrite rules haskell syntax directly concrete visual syntax style section 
ports complex explained section 
rules groups simple expressions structured expressions patterns bindings match chapter 
visual haskell phrases order 
note recursive re application rules implicitly selects correct rule context rule applied occurrence say selected occurs expression pattern 
simple expressions section gives syntax simple expressions expressions containment 
small subset haskell approximately equivalent language features pure dataflow languages 
gives rewrite rules expressions variables constants data constructors function application function composition 
variables constants 
function variables data constructors similar input ports live 
arity constructor function mean arity production consideration 
earlier examples output port rectangular indicating function valued 
visual sugaring replace boxes icons see section 
recall enclosing object identifier double quotes meta syntax name string 
name variable function identifier 
special names name operator operator parentheses example name names constants name wildcard blank string 
application function valued expression argument connects corresponding 
function valued expression live input port port matching select set live ports 
indicated dashed line input ports top live port connected argument pict killed changing colour black 
currying handled visual syntax time additional argument supplied function live port connected killed eventually arguments supplied function box remaining live ports 
port matching output ports output port matches live port triangular rectangular indicated superposition shapes 
port killed 
output port matches chapter 
visual haskell 
visual syntax simple expressions rectangular port function 
result port annotated small means triangle zero rectangle greater zero 
newly connected port function applied arguments port changes rectangle triangle 
expression argument live input ports 
black diamond lower corner non terminal means remaining live ports killed 
function composition similar function application 
functions match shapes output ports rectangular 
main point note live port result pict port attached function application 
indicated annotation input port 
live port remain live connected port attached 
usually remaining live ports 
chapter 
visual haskell visual language easy apply arguments arbitrary order 
express special syntax denote function variable arguments supplied different order 
th argument th argument call permuted application permuted functions produced de sugaring rules section 
visual syntax permuted function variable similar normal function port annotated numbers concrete syntax appear canvas 
graphical development environment permuted application expect standard haskell visual representation impose order arguments textual representation 
example clarify function application composition works 
consider expression negate shows visual terminals show steps translation top bottom 
applied connected ports killed 
second step pict composed negate second port matched connected output port negate 
note input port negate remains live 
pict just produced applied connected ports killed expected 
note output port changes triangle input port pict just connected 
alert reader may noticed source ambiguity picture bottom represent negate 
ambiguity arises composition retain visual grouping construct 
visual editor best resolve ambiguity retaining composition internal data structure user request display grouping containing box allow removed altered 
useful distinction visual haskell intended provide complete syntactic equivalent haskell 
original development visual haskell idea view development system featured heavily system difference negate negate significant 
development visual haskell expect exact correspondence necessary 
chapter 
visual haskell negate negate negate 
example translation negate visual terminals steps translation structured expressions aid simple conditional actors select page possible encode loops constructs conditional execution pure dataflow framework 
possible analyse graph extract constructs encoded 
argue dataflow paradigm extended incorporate structured constructs 
add loops case construct sequencing construct labview language calling result structured dataflow 
general purpose visual dataflow languages generally provide constructs see survey 
special purpose languages ptolemy relying lower level host language 
haskell explicit loops uses recursion iteration 
visual haskell structures resemble structured dataflow expressions conditionals abstractions case expressions 
delimited containing box enclosure connected outside expression 
novel feature arises haskell higher order structured expression function valued live input ports connected way function variable 
improvement language earlier required explicit apply nodes structures chapter 
visual haskell case match match case match match 
visual syntax structured expressions abstractions 
visual syntax expression essentially containing box labelled containing expression result local bindings connected dummy port inside enclosure 
expression non zero arity box live input ports attached 
output port rectangular non zero triangular 
visual sugaring phase sharing connect variables bound uses variable area canvas sharing occur called region case entire inside box 
illustrate shows expression chapter 
visual haskell case true false 
examples structured expressions see text series conditional expressions grouped single visual construct 
translation case expressions haskell report cumbersome visually 
guard consequent placed horizontal section containing box separated heavy arrow glyph 
sections separated heavy dashed line 
region sharing 
guard region left entirely blank 
expressions series conditional expressions input ports function valued 
illustrates function valued conditional expression applied variable abstractions containing box time syntax box contents delegated production called see section 
similar enclosing box expressions contains patterns abstraction arguments 
includes abstraction map 
case expression uses pattern matching select expression alternatives 
alternatives match clause see section stacked order tested 
case value chapter 
visual haskell connected special input port stacked match expressions grey rectangle argument slot section placed case layout manager allow 
shape output port depends number input ports 
function valued case expression applied argument case true 
false 
argued constructs precedent structured dataflow general structured dataflow 
structured dataflow construct behaves outside just dataflow actor data operates comes input ports 
visual haskell scope named variables necessarily true constructs just described 
abstraction example fulfils condition free variables 
abstraction comparison abstraction 
occurs free 
similar idea applies constructs conform dataflow model data supplied explicitly 
conditional example uses supplied construct dataflow arc compare labview case selects functions applies argument 
haskell case way need 
sense visual haskell case flexible 
abstractions transformation known lambda lifting eliminate free variables may possible find similar transformation case expressions 
patterns patterns de construct arguments bind names expressions parts expressions haskell pattern syntax essentially subset expression syntax visually patterns look expressions connected backwards 
pattern input port zero output ports patterns kind object output port 
patterns common visual languages enhanced show tell supports similar facility inconsistency chapter 
visual haskell 
visual syntax patterns gives rewrite rules patterns 
variables constants drawn grey boxes single live semi circular input port 
variables single output port 
port live patterns attached port sharing sharing require live ports section 
data constructors drawn white box input port live output ports 
expressions box replaced icon visual sugaring section 
nested patterns translated 
live output ports constructor connected killed order way function application connects kills live input ports 
example pattern firstly connects output port input port second output port note common nested patterns removed desugaring translation section 
example ys translated cons ys 
patterns drawn pattern variable box attached 
variable box single output port sharing 
chapter 
visual haskell bindings binding binds name value 
visual dataflow languages allow binding names functions function bindings avoid problem free variables 
visual haskell allows names bound values pattern bindings 
series bindings displayed region 
noted earlier visual syntax specify relative positions bindings 
core syntax bindings connected sharing pattern bindings connected inter region 
module level layout manager place bindings 
levels place function bindings pattern bindings clustered sharing effectively 
simplest kind pattern binding value connected pattern 
live input ports killed 
simple pattern binding local definitions right hand side put containing box 
appearance expression label input ports regardless arity 
guarded pattern binding form delta delta delta 
visual syntax right hand side similar conditionals addition bindings placed region 
final rewrite rule function bindings 
region defined function binding shown small rounded rectangle containing function name appropriate number dead input ports dead output port 
editing function definition displayed window title bar contains function name icon 
body window stack match phrases 
match phrases match phrase haskell series patterns guards result expressions case expressions function bindings 
types guards 
represented visual haskell productions respectively production match 
shows textual visual syntax unguarded match phrases 
chapter 
visual haskell 
match match match match 
visual syntax bindings chapter 
visual haskell delta delta delta 
delta delta delta 
delta delta delta delta delta delta delta delta delta 
delta delta delta 
delta delta delta delta delta delta 
visual syntax match clauses ally unguarded match set patterns delimiter 
expression optional clause containing local definitions difference clauses delimiter 
context occur case expressions function bindings 
haskell distinguishes cases syntactically visual haskell 
visually unguarded match similar expression addition set patterns 
expression bindings exist patterns region 
second type unguarded match contain expression top level auxiliary definitions 
simplifies common case expression occurs top level 
visually effect remove redundant containing box 
shows syntax guarded match phrases 
textually guarded match set patterns delimiter 
series guards consequents optional set bindings visually guarded match similar series fact redefine variables pm haskell problem way crossing variables pm chapter 
visual haskell conditionals addition bindings patterns 
bindings patterns region conditionals isolated region 
shown visual syntax guard just blank space 
improving visual syntax core syntax enhanced ways 
section firstly give sugaring rules style section 
rules improve appearance visual haskell programs considerably 
help key reasons visual notation handle give structural properties program 
example examples chapter illustrate arrays functions connected various ways 
assist kind program visualisation complex visual representations needed give thesis 
visual syntactic sugar lists sugaring rules 
explained section layout manager permits sugaring rewrite result pict sensibly laid canvas 
sets rules icons variable sharing attachment argument slots 
icons critical ingredient visual language meaningful symbols 
visual haskell common visual languages optionally uses icons represent application certain functions allows icons variables constants data constructors 
gives sugaring rules icons 
recall quoted production visual meta syntax string box visual meta syntax icon 
icons standard prelude data constructors functions shown figures icons special cases introduced chapters necessary 
sharing core visual syntax occurrence variable textual haskell program produces unique pict canvas 
layout permits shared arc connected 
cases captured rewrite rules arcs variable box chapter 
visual haskell 
sugaring rules icons sharing attachment argument slots re connected pattern variable box name zero output arcs variable box deleted canvas 
second arcs variable box re connected variable box name output arcs box deleted canvas 
attachment attached connected 
rules 
connected data arc attached arc ports disappear canvas 
uses blank diamond denote visual syntax numeral bottom right corner distinguishes unique chapter 
visual haskell 
illustrating type annotations stream vector ff occurrences 
second rule pict pattern connected binding arc attached 
argument slots enhanced show tell function slots function slot position icon higher order function function argument placed 
visual haskell generalised form idea call argument slots icon slots arguments functions 
layout permits argument connected corresponding input port drawn argument slot icon 
rules argument slots 
function argument higherorder function name placed slot 
frequently higher order functions application map 
second rule similar applies variables 
third allows arbitrary expression placed argument slot 
allows function icons placed slot complex expressions placed slot layout permits 
rules port corresponding argument disappears 
type annotations informal system annotations arcs indicate types 
illustrates annotated arcs type variables ff represented black circles tupling placing tuple element annotations side side arc lists asterisk annotation streams section open circle vectors section slash 
necessary type annotation enclosed box turn annotated 
iteration boxes general purpose visual programming languages support iteration form 
visual dataflow languages survey example support chapter 
visual haskell 
illustrating iteration map scanl iteration 
technique special iteration constructs labview example incorporates loops loops structured dataflow model way 
containing box internal dataflow graph executes time loop 
languages cycles special purpose dataflow nodes example programmer places loop glyph start section flow graph iterated feedback connection glyph flow graph section 
pure functional languages rely recursion iteration 
higher order language haskell patterns iteration captured higher order functions applying higher order function equivalent coding iterative loop languages see sections 
visual haskell visual functional language uses function icon represent iteration 
limit information icon convey previous representation similar structured dataflow iteration constructs 
examples 
representation computation performed iteration shown dataflow graph inside generic icon representing type iteration 
input graph element input aggregate list stream vector output element output aggregate 
lists generic icon white shadowed box icon map 
map example internal graph function application applied input element produce output element 
function maintains state value iteration shown crossed box 
scanl example state input iteration updated output element 
shows complex example representation 
chapter 
visual haskell 
unfolded higher order functions map scanl unfolded higher order functions higher order functions combine functions usefully thought visual language means constructing program graphs 
example gave special syntax function composition combines function boxes meaningful way 
syntax represented box labelled connected function variable boxes labelled higher order functions map scanl thought representing array function applications element list 
illustrates map shown manner conveys idea 
narrow horizontal boxes represent deconstruction list individual elements construction list elements 
dashed line elided function application boxes 
second style representation unfolds higher order function assuming certain properties argument 
example shows scanl appear argument list contained elements 
styles show programs higher order functions structural way sections unfolded representations extensively 
am unaware proposal incorporate kind representation visual language 
unfolded diagrams appear part visual interface 
visual haskell representations informal 
incorporate visual interface mark list aggregate data type expansion 
unfolded representations valid sugaring rewrite rule 
chapter 
visual haskell 
wiring map delta reverse wiring number functions lists re arrange elements argument list 
conjunction unfolded higher order functions helpful draw functions wiring 
illustrates expression map delta reverse 
long rectangles right left represent list construction de construction respectively 
reverse shown mass wires map shown unfolded 
need wiring apparent vector operations section 
gives example additional wiring functions uses definition fast fourier transform 
summary believe significant value precise visual syntax haskell replace ad hoc notations 
chapter syntax substantial portion haskell 
missing syntax need provided visual haskell complete apart type declarations syntax needed user defined operators modules list comprehensions array comprehensions 
addition way specifying sophisticated syntax sections needed 
approach explored translate syntax low level picture language picture layout grammars 
approach turned cumbersome core syntax may acceptable limited special purposes 
visual haskell mainly program visualisation far idea view development system intriguing 
view system programmer chapter 
visual haskell map 
mixing text pictures text picture picture text switch text pictures arbitrary levels program 
example picture contain expression text box text window contain picture 
illustrates idea alternative views expression map 
illustrated complete picture 
chapter static process networks real time signal processing programs oriented key aggregate data types arrays call vectors streams 
base elements invariably numbers 
streams fundamental real time signal processing program exist data structure interface external signals 
vectors inherent signal processing algorithms operate segments signal transforms 
digital signal processors designed operate efficiently loops important high level programming language able express iteration vectors streams clearly 
section chapter develops vector data type associated functions capture key operations vectors 
example fast fourier transform illustrates 
haskell lazy easy write infinite data structures 
functional operating systems process networks sections lazy lists model communications channels processes 
explicitly defined stream data type model communication give haskell functions implemented canonical sdf actors section 
functions features haskell increase expressiveness write dataflow networks higher order functions encapsulate common types processes higher order functions capture common interconnection patterns serial parallel connection represent various linear mesh tree structured interconnection patterns 
language facilities constructing process networks explored kelly extend chapter 
static process networks real time streams signal processing 
style programming called data parallel process programming provides counter position functional parallelism provide adequate abstraction individual threads computation 
functions streams defined terms primitive functions programmer define recursive functions streams 
style programming advocated backus bird non recursive programs tend concise recursive ones ii chance making errors forgetting termination condition :10.1.1.100.9674
final task chapter adapt algebraic style program transformation streams processes 
result set provably correct program transformations alter structure degree parallelism process network program 
techniques eliminate apparent efficiency defects caused high level programming language tailor program hardware configuration better execution efficiency 
related real world dsp programming assembler block diagram systems popular alternative programming technology 
drawbacks block diagram systems generally oriented particular hardware systems fall short generally applicable production tool 
argue block diagrams inadequate specifying dsp systems permit expression control flow detailed computation best specified textual language leaving block diagram higher levels description 
approach uses light weight operating system kernels support libraries 
particular evident parallel systems added complexities multi processor communication synchronisation encourage adoption multi tasking kernels 
approach am interested programming language higher level best example language designed specifically dsp programming explores higher level signal pro chapter 
static process networks cessing programming concepts 
evolved commercial product dfl 
noticeable feature support streams data delays 
expression signal delayed sample 
arithmetic operations extend pointwise streams 
supports fixed point data types arithmetic important aspect programming real dsp devices 
recursive functions define signal processing functions 
higher order functions capture particular patterns recursion 
unusual aspect language explicit suspension construct supports data driven programming code interfaces real time channels 
propose partial evaluation compiler eliminate potential run time overhead recursion 
recurring theme dsp programming streams represent discretetime signals 
streams proposed landin means separating control structure algol loops loop body 
landin represents stream pair head element nullary function representing rest stream 
stream elements evaluated come calculation successive loop control value execution loop body proceed interleaved manner 
burge developed idea streams way structuring programs set independent sub programs 
uses representation landin lists number functions standard functional programming languages maps applies function element stream generate produces sequence zips produces stream pairs streams filter removes elements fail satisfy predicate 
compare number stream implementations point difference channels streams noting terms overlap somewhat usage 
channel destructive elements appended channel 
kahn process networks dataflow process model channels new tokens appended 
streams functional stream producer part stream 
landin burge example function represent remainder stream lazy functional languages implement streams recursively defined lazily evaluated lists 
chapter 
static process networks ease lazily evaluated streams lend signal processing noted 
uses lazy lists simulate signals gives number simple filters haskell suggesting conciseness programs haskell excellent tool prototyping 
prototyping image processing programs functional language advocated michaelson higher order functions code range image processing algorithms 
related compiles higher order functions parallel code meiko transputer system 
vectors vectors play important role signal processing 
recall section instruction sets modern dsps support efficient vector operations 
section describes vector datatype implemented haskell set functions haskell implemented efficiently dsps 
functions typical blelloch call collection oriented languages 
appendix lists code vector module 
standard prelude treat code semantic definition words compiler understands vector functions generates efficient code 
key issue avoiding laziness vector functions compiled hyper strict context avoid access vector elements pointers 
vector datatype vector datatype defined haskell data vector ff nullv ff 
vector ff vector type vector ff ff type elements 
defined vectors lists different data constructors 
vector function takes list produces vector vector 



nullv chapter 
static process networks clumsy assume haskell special syntax vectors lists enclose vectors angle brackets hx zi 
nullv write find convenient annotate vector type signature vector lengths 
example function perform inner product summation vectors type ip num ff vector ff vector ff ff input arguments interpret length annotations pre conditions specify conditions arguments satisfied function produce defined result 
key part programming contract approach software development 
case input vectors length 
compiler required generate correct code pre conditions violated implementation focus generating fastest code possible equal length vectors example omitting test equal length 
type annotations attached nested vector types inner annotation specifies sub vector length 
example xs vector vector ff vector vectors sub vectors length sub vectors ys vector vector ff may different lengths 
annotating vector functions way choose efficient implementation xs generality ys appropriate 
interesting research topic extend haskell type system infer compile time constraints met 
iterators vector iterators higher order functions apply function elements vector 
effect captures particular pattern iteration allowing programmer re patterns risk error 
persuasive arguments favour inclusion higher order functions programming language 
chapter 
static process networks shows iterators unfolded style section 
diagrams illustrate pattern computation represented iterator structural way viewpoint higher order functions particularly important build networks processes section 
iterators complexity length vector 
types listed 
simplest iterator mapv analogous map lists 
example mapv produces vector specified length initial value function produces successive value 
element vector produced initial value example generate vector complex numbers equally spaced unit circle write mapv cis theta pi cis cos sin 
function creates vector containing copies element easily defined int ff vector ff id id fold vector single value 
example sum elements vector particular expression common worth giving name num ff vector ff ff vector iterators haskell higher order functions lists chapter 
static process networks 
unfolded vector iterators mapv chapter 
static process networks mapv ff fi vector ff vector fi int 
ff ff ff vector ff ff fi ff ff vector fi ff ff fi ff ff vector fi vector ff ff fi 
ff fl ff vector fi 
ff vector fl fi ff ff ff vector fi ff fi ff ff ff vector fi vector ff fi ff 
fl ff ff vector fi 
ff vector fl 
iterator type signatures folding functions come left handed right handed flavours 
left handed flavour iterates element right handed flavour iterates element 
note right handed functions quite mirror images left handed ones typing function argument changes seen examining 
scan function vector result produced application function argument written output vector input application 
example produce running sum elements vector capture mesh pattern iteration combination mapv 
argument function produces pair values input application function second output value 
example consider expression 
readers familiar functional programming notice definition differs standard haskell scanning functions lists 
comparison scanl vector versions defined output vector length input vector affords efficiency improvement input vector written result 
chapter 
static process networks vector ff vector ff vector ff vector vector ff vector jk ff 
ff vector ff vector ff vector ff ff vector ff 
ff vector ff vector ff 
vector ff ff vector ff 
combiner type signatures note second element result pair input vector shifted right 
wish define 
operator see section 
ff vector ff vector ff 
xs snd na 
xs combiners combiners perform computation combine vectors elements new vectors 
type signatures listed 
joins vectors single vector 
joins vector vectors single vector 
note type signature requires sub vectors length 
example hh ii remaining combiners implement shift register operations 
attach element left right vector respectively 

shift element left right vector respectively 


smart compiler able produce implementations combiners 
consider expression destination address registers chapter 
static process networks lengthv vector ff int vector ff int ff int int int vector ff vector ff int vector jk ff vector vector ff transpose vector vector ff vector vector ff vector ff vector fi vector ff fi vector ff fi 
vector ff vector fi 
selector type signatures set point memory area allocated result expression vectors produced produced directly result 
copying required 
require sophisticated analysis 
shift operators implemented complexity modulo addressing hardware modern dsp devices page 

operator write right argument current position vector increment address register moves outside vector memory reset addressing hardware back position memory 
function reads vector operates similar way reading current position position past element written element written 

operator similar decrements address register performing write 
selectors selectors perform computation just re arrange vector elements 
lists types 
visual haskell selectors drawn wiring section 
shows selectors way unfolded vector iterators visual representation provides structural intuitive grasp operation 
function lengthv returns length vector lengthv chapter 
static process networks lengthv div lengthv div lengthv lengthv lengthv lengthv lengthv 
additional selector functions selects individual element vector selects linearly spaced elements vector 
argument position start element second stride elements third number elements 
result undefined elements outside vector 
example useful functions easily defined select odd elements vector take remove elements vector split vector equal halves produce head tail vector produce element vector elements reverse vector 
splits vector vector vectors elements discarded length new sub vectors exactly divide length input vector 
example hh ii transpose swaps outer dimensions vector 
example transpose hh ii hh ii chapter 
static process networks combine vectors vector pairs vice versa 
example 
implement butterfly access patterns fast fourier transform algorithm 
functions duals drawn wiring 
defined duals vector ff vector ff ff duals lengthv div vector ff ff vector ff duals requires length argument 
example duals useful defining iterators accept produce vector argument 
example define function applies function point wise input vectors ff fi fl vector ff vector fi vector fl xs ys mapv 
xs ys binary operator function extended operate vectors way example useful example kind operation vector inner product ip num ff vector ff vector ff ff ip chapter 
static process networks 
selectors wiring duals implemented naively copying elements selectors complexity 
smart compiler reduce selectors complexity 
see recall dsp increment address registers contents index registers instruction 
suppose elements vector located contiguous addresses memory 
expression mapv generate single instruction loop iteration loads adds vector element stores result previous iteration increments source destination address registers 
consider expression mapv delta odds 
loop source address register incremented point element offset vector loop count halved 
loop source address register incremented 
easily generalised arbitrary strides index registers 
example fast fourier transform fast fourier transform fft algorithm important algorithms signal processing 
formulated recursive divide conquer algorithm chapter 
static process networks 
point fft butterfly diagram implementations algorithm usually coded iterative manner efficiency 
aid understanding iterative algorithm called butterfly diagram drawn shows diagram fft coded point input vector 
particular form fft complex radix decimation time algorithm bit reversed output 
fft algorithm haskell coded directly butterfly diagram 
top level function guard checks supplied log vector length correct 
explain rest code works start inner functions outwards 
bit reversed re ordering performed function assumes length argument vector power 
defined recursively vector ff vector ff hxi hxi xs evens xs odds xs usually expect implementation provide primitive chapter 
static process networks fft int 
vector complex float 
vector complex float fft xs stage xs stage int 
vector complex float 
vector complex float stage segment div segment complex float 
vector complex float 
vector complex float segment mapv butterfly duals vector complex float mapv cis negate lengthv xs 
fft function function reverse carry addressing modern dsps 
twiddle factors vector complex numbers situated unit circle 
value hw gamma obtained applying negate cis functions negative phase angles unit circle applying bit reversal re ordering result 
level processes single segment segment groups segment pairs dual nodes performs butterfly operation pair nodes original ordering 
note partial application distribute twiddle factor segment applications butterfly 
butterfly defined page 
illustrates unfolded segment second stage point fft 
level fft single stage algorithm point fft 
stage consists number segments 
stage divides data vector segments applies segment segment chapter 
static process networks butterfly butterfly butterfly butterfly segment segment div stage stage stage stage 
parts point fft visual haskell segment stage fft single twiddle factor combines result single vector 
illustrates unfolded second stage point fft 
level call pipeline level applies series stages pattern captured 
argument stage length segments stage point fft example vector required 
function generates vector reverse order 
illustrates level fft 
streams haskell stream datatype defined section allows simulate dataflow process network programs haskell 
vectors assumptions compiler treat datatype 
haskell code stream module listed appendix chapter 
static process networks stream datatype stream datatype declaration vector data stream ff nulls ff stream ff saw sections pragmatic implementations process networks functional programming languages evaluate element stream hyper strict context elements fully evaluated transmitting process 
assume stream 
stream function produces stream list stream 
nulls assume haskell special syntax streams enclose streams curly brackets fx zg 
nulls write chapter consider infinite streams 
annotations streams indicate sample rate 
see consider process sums corresponding elements input streams summer num ff stream ff stream ff stream ff inputs different sample rates buffer memory quickly exhausted 
annotations treated pre conditions ensure sample rates correct 
stream contains vectors annotation vector type constraint lengths vectors 
stream vector ff stream rate containing vectors length annotations useful transforming process networks 
vector lengths extending haskell type system infer correct sample rates interesting 
process primitives section argued sdf actor sdf network built delays instances actor schemata 
section give haskell chapter 
static process networks function actors 
types functions 
recursive definitions section cons operator attaches element front stream 
equivalent placing initial value stream unit delay 
example fa cg fx cg common signal processing delays initial value zero define new function named confusingly delay delay num ff stream ff stream ff delay xs zero xs groups breaks stream stream vectors length argument 
groups directly equivalent group actor 
basic mechanism sample rate streams decreased 
length input stream multiple final incomplete vector discarded 
example groups fa fha bi hc dig reverse concatenating stream vectors stream elements 
concat need argument giving length vectors stream calculates run time 
vector length assertion type states vectors length 
example fha bi hc dig fa dg zips combines streams point wise pair streams 
example zips fa cg reverse zips produces pair streams stream chapter 
static process networks ff stream ff stream ff groups int stream nk ff stream vector ff stream vector ff stream nk ff zips stream ff stream fi stream ff fi stream ff fi 
stream ff stream fi maps ff fi stream ff stream fi 
types stream functions pairs 
example 
fa cg zips equivalent actors zip unzip respectively 
haskell type system allow function accept variable number arguments 
restriction overcome assuming exists family zipping functions zips zips 
theory affect claim functions section minimum set functions needed write sdf actor triples tuples represented nested pairs zipping functions defined terms zips 
maps equivalent map actor 
applies function element stream maps section discussed difference parameter stream arguments 
functional programming language deals quite different types argument long stream arguments follow parameter arguments easy create parameterised stream functions equivalent instantiated actors groups example function divides stream argument vectors 
slightly sophisticated examples maps multiplies element stream argument 
need constant stream required languages lucid 
point note difference way processes instantiated 
section actor instantiated binding unique vertex name stream chapter 
static process networks arguments supplied graph topology 
haskell functions section process exist unique entity arguments supplied 
call function contains streams input output types process function arguments supplied process function applied parameter arguments process example maps maps applied arguments process functions maps xs stream produced process maps process function process arguments supplied process functions supplied arguments higher order functions 
example write mapv maps xs produce vector processes section explores idea 
example order recursive digital filter defined gamma gamma gamma filter coefficients 
reformulated gamma gamma gamma block diagram simple filter shown 
define scale summer page haskell functions scale num ff ff stream ff stream ff scale xs maps xs summer num ff stream ff stream ff stream ff summer xs ys maps 
zips xs ys define order iir filter haskell iir num ff ff ff ff stream ff stream ff iir chapter 
static process networks 
order recursive filter block diagram notation visual haskell summer scale delay summer scale scale shows definition visual haskell laid mimic block diagram icons scale summer delay 
diagram omit containing window function definitions 
example demonstrates visual haskell look block diagrams able tap appeal intuition block diagram systems 
note importance defining suitable functions aid visual representation programs 
textual program easy write example summer maps maps chapter 
static process networks delay summer scale scale able icons effectively 
process constructors primitive functions maps higher order function 
additional higherorder functions readily defined terms primitives 
call higher order functions streams process constructors key role constructing process networks 
types definitions listed definitions shown diagrammatically 
point wise process constructors maps build processes input output 
example point wise addition process written process outputs sum difference inputs written gamma process constructors maintain state 
definitions feedback loop carry state purely functional actor recursive definitions 
example scans defined scans nulls nulls scans xs scans xs definitions equivalent chosen state feedback form new functions treated hierarchical dataflow actors 
iterates generates produce stream single input value key difference iterates outputs state application argument functions generates produces output value state chapter 
static process networks ff fi fl stream ff stream fi stream fl xs ys maps 
zips xs ys ff 
fi fl stream ff 
stream fi stream fl xs maps xs ff fi 
fl ffi stream ff stream fi 
stream fl stream ffi xs ys maps 
zips xs ys iterates ff ff ff stream ff iterates ys maps ys xs generates ff 
ff fi ff stream fi generates zs ys zs ys scans ff fi ff ff stream fi stream ff scans xs ys ys xs ys states ff fi 
ff fl ff stream fi stream fl states xs zs ys zs xs ys 
process constructor definitions application 
example process produces stream written iterates useful function defined terms iterates generates stream containing infinite number copies argument repeats ff stream ff repeats iterates id scans states propagate state value iterations 
example process scans produces running sum input stream 
interesting process chapter 
static process networks xs ys xs ys ys zs xs ys ys zs xs ys 
process constructors iterates generates scans states integer outputs input value vector containing value past gamma values slide num ff int stream ff stream vector ff slide scans 
example slide fh ig common operation signal processing 
illustrate equation defining chapter 
static process networks ip 
fir filter function th order finite impulse response fir filter impulse response gamma words input value output inner product impulse response input values 
haskell fir num ff vector ff stream ff stream ff fir maps ip slide lengthv fir illustrated 
icon slide supposed evoke stack items falling bottom 
large amount redundant communication processes input value sent slide process scans process times 
apparent overhead removed program transformation see section 
consider recursive filter arbitrary order shown block diagram form 
equation gamma gamma gamma filter order 
diagram difficult draw formal notation arbitrary order 
fir filter group gamma delays single state slide 
definition illustrated visual haskell applications slide clarity num ff vector ff vector ff stream ff stream ff chapter 
static process networks ip ip negate 
th order recursive filter block diagram form generalised form mapv negate summer maps ip slide lengthv delay maps ip slide lengthv process network construction previous section gave examples order process networks 
order network process function appears argument higher order function process appears explicitly program text 
take advantage powerful features host functional language increase expressive power available writing dataflow process network programs 
chapter 
static process networks 
simple network forming functions composition fan par higher order functions useful capture patterns instantiation interconnection processes 
section mainly concerned illustrating kinds networks produced way resulting style programming called data parallel process parallelism 
simple combinators function composition connects processes series series composed functions forms pipeline 
illustrates pipeline delta delta processes 
new higher order functions express topologies easily defined 
example fan applies processes stream par applies processes stream pair 
defined follows fan ff fi 
ff fl ff 
fi fl fan xs xs xs par ff fi 
fl ffi 
ff fi 
fl ffi par xs ys xs xs illustrate functions 
note visual syntax defined chapter 
important feature visual language implementation visualising kinds networks user defined visual syntax higher order functions 
chapter 
static process networks simple linear networks supplying process function argument vector list iterator gives rise array processes process functions 
expression mapv maps xs xs vector stream ff vector streams linear network identical processes 
network shown 
similar network results point wise constructors xs ys examples maps process constructor 
ease explanation process constructors maintain state 
example expression builds linear array processes built scans mapv scans xs initial state processes 
build array processes differing initial state taken vector write scans xs previous examples built arrays identical processes 
wish apply vector functions fs process network behaves differently maps fs xs illustrates network results 
construction corresponds par vectors functions data pairs 
network corresponding fan linear array different processes applied single stream xs mapv maps xs fs chapter 
static process networks xs fs xs 
linear process networks pipelines composition builds pipelines process explicitly represented text 
easy define higher order function connects vector functions series series vector ff ff ff ff series fs 
id fs fs process function series produces pipeline 
example create pipeline identical processes copies process pipeline series xs stream ff stream ff 
useful way creating pipeline different processes parameterise process supplying instance process chapter 
static process networks different argument series mapv xs process vector arguments 
see works suppose maps 
expression mapv evaluates maps maps unfolding series gives maps delta maps delta maps shown 
direct way achieve result 
relate series identity series mapv pipeline parameterised processes equation xs data flow pipeline left right 
care needed order arguments swapped flip xs idea parameterising process network mapping process vector parameters occurs pipelines easily network structures 
example equation example instantiations process applied single stream parameterise process produce vector parameterised processes map stream xs mapv xs mapv chapter 
static process networks 
pipeline process network particular case easy write expression desired network directly mapv xs way parameter affects depends constructed 
example maps parameter argument mapped function scans initial state meshes systolic arrays remaining vector iterators process function argument give rise various mesh structured networks 
example expression illustrated folds vector streams single stream ts binary function 
vector generation functions way produce vector streams single stream illustrated maps scanning vector functions produce vector streams vector streams result express dimensional arrays processes 
example ts chapter 
static process networks ts ss ts 
mesh process networks chapter 
static process networks produces array processes mesh inter connection pattern 
applying function second vector streams get dimensional array processes shown 
expression network ss ts dimensional mesh systolic array wave computation proceeds array 
patterns algorithms developed hardware implementation interesting functional languages hardware design 
sheeran fp language example functional language backus fp includes structuring operations similar 
language evolved hardware design verification language ruby circuits represented relations signals functions signals signals 
haskell specify simulate systolic arrays mckeown give higher order functions expressing systolic arrays illustrate number algorithms 
network construction dataflow systems block diagram systems included network construction 
grape ii geometric parallelism specifies multiple invocations block 
visual language invocations appear block 
number invocations specified textual language values known compile time 
connection topology specified textual language 
output invocation feeds input additional feedback arc shown 
technique allows complex structures expressed needing provide higher order functions 
ptolemy adopted form higher order function notation 
special blocks represent multiple invocations replacement actor 
map actor example generalised form mapv 
compile time map replaced specified number invocations replacement actor grape ii number known compile time 
mapv map accept replacement actor arity referenced gives values textual form 
clear expressed visual language 
chapter 
static process networks case vector input streams divided groups appropriate arity number invocations replacement actor reduced accordingly 
requirement number invocations actor known compiletime ensures static scheduling code generation techniques effective 
required explore forms higher order function mid way fully dynamic 
example code generator produces loop actor body number loop iterations unknown execute efficiently 
process network transformation lack side effects functional languages lend program transformation 
section demonstrate algebraic style program transformation exemplified bird meertens formalism bmf :10.1.1.100.9674
key characteristic style extensive catalogue known algebraic laws functions relying discovery lower level methods 
bmf known developed programming calculation method developing programs specifications 
haskell notation writing transformations similar manner concise notation :10.1.1.100.9674:10.1.1.100.9674
key contribution section adapt bird meertens theory lists streams result powerful tool restructuring process networks 
particularly powerful transformations available networks constructed higher order functions 
identify distinct classes transformation suitable process networks 
transformations common cases means exhaustive catalogue 
transforming programs improve performance advocated carriero gelernter transform programs expressed natural categories parallelism efficiently implementable category 
transformations ad hoc lacking equational basis bird meertens style 
chapter 
static process networks 
illustrating network types type annotations transformations bird meertens formalism bmf general independent structural information arguments transformed functions types 
unfortunately transformations section correct arguments satisfy certain structural constraints 
particular concerned lengths vectors data rates streams 
example consider simple network par maps maps merge processes transform equation delta maps par delta uncurry zips sample rates streams different equation operate real time program 
equation consumes data streams equal rates data accumulate input higher rate resulting buffer overflow heap exhaustion 
problem isolated zips sample rates streams meet sample rate pre conditions zips 
specify transformations valid certain length sample rate conditions satisfied append annotated type expressions side transformation 
example transformation written par maps maps delta maps par delta uncurry zips stream ff stream fi 
stream fl stream ffi chapter 
static process networks 
process fusion fusion common example algebraic law functions map distributivity called expresses fact map distributes backwards function composition map delta map map delta law states applying element list element list equivalent applying element list 
correctness law depends properties map properties essence algebraic style program transformation computational behaviours captured functions particular emphasis higher order functions structural properties expressions easily recognised expressions transformed appropriate function identities 
similar identities combinations functions foldl map example collectively known loop fusion identities 
class process network transformations simple adaptation identities process network 
simplest maps delta maps maps delta stream ff stream fi left hand side equation represents processes righthand side represents single process 
transformation identity effect increasing decreasing parallelism depending direction transformation applied 
types fusion identities equation omitted 
chapter 
static process networks ip 
transformed fir filter easily find fusion identities 
fusion processes constructed maps scans captured maps delta scans states general identity captures fusion processes built states states delta states states illustrate process fusion consider inefficient version fir filter page 
transformation efficient version straight forward fir definition fir maps ip delta slide lengthv unfold slide maps ip delta scans 
lengthv fusion equation states 
ip lengthv simplify states 
ip lengthv version fir filter harder read original version 
shows version visual haskell iterator view section 
written readable efficient version scratch readily derived easier read maintainable version 
easier read original version uses known utility function slide 
difficulty process fusion identities chapter 
static process networks number identities may require 
problem noted time ago wadler context lazy lists 
led development successively techniques deforestation aimed automatic fusion list functions program efficiency :10.1.1.30.9032
gill discovered improved method part haskell compilers 
easy see techniques applied purposes reasons 
firstly rely expanding functions question recursive firstorder form seek retain higher order functions key efficient imperative implementation dataflow actors 
secondly transformations fusion direction interested making processes smaller fission larger 
parallelisation second class identity transforms process containing application vector iterator vector processes vice versa 
class identity appear bmf needed operational characteristics vectors streams differ 
call class identity horizontal parallelisation 
new zipping functions needed zip vector streams stream vectors vice versa vector stream ff stream vector ff stream vector ff vector stream ff simplest parallelisation identity maps mapv delta mapv maps delta stream vector ff stream vector ff left hand side equation single process right hand side vector processes 
delta id delta id chapter 
static process networks straight forward modify identity follows delta maps mapv delta mapv maps vector stream ff vector stream ff equation probably useful starting vector processes equation useful starting single process 
consider process repeatedly applies obtained calculating sum vector stream maps process similar manner maps repeats delta stream vector ff stream ff shows left hand side identity right hand side 
process fusion horizontal parallelisation quickly leads problem large number combinations higher order functions 
technique automatically deriving identities class helpful 
pipelining third kind identity constructs combines pipelines processes process parameterised different value 
pipelining explored extensively kelly 
identity relates single process pipeline parameterised processes constructed maps maps series fs series mapv maps fs stream ff stream ff suppose fs produced mapping function vector parameters chapter 
static process networks 
horizontal parallelisation right hand side series mapv maps mapv map fusion series mapv maps delta saw equations explicitly parameterising functions processes 
rewrite equation equivalent form maps xs maps xs stream ff form identity similar horizontal parallelisation fold operators stream feeds pipeline vector streams feeding pipeline 
structure left hand side equation fft example similar fir filter example second devoted process network transformation 
right hand side chapter 
static process networks xs xs 
pipelining pipeline processes parameterised vector promotion fourth class identity derived bird promotion identities 
map promotion identity expresses idea map promoted concatenation map delta concat concat delta map map words concatenating list lists applying element applying element sub list concatenating result 
adapting identity lists vectors get mapv delta delta mapv mapv vector vector ff vector thetak fi function vector thetak ff vector vector ff chapter 
static process networks satisfies delta id vector ff vector ff rewrite equation mapv delta mapv mapv delta vector ff vector fi equation gives slightly useful perspective apply element vector divide sub vectors apply element sub vector join result back vector 
change grain size vectors processes 
example mapv maps promotion equation delta mapv mapv maps delta horizontal parallelisation equation delta mapv delta maps mapv delta delta result equation shown vector processes size process determined 
adjusting way breaks vector control degree parallelism obtained transformation 
similar law holds fold functions foldl law foldl delta concat foldl foldl laws kind useful controlling grain size processes pipeline see derivation pipeline fir filter example 
bird page gives law variant fold promotion law non associative operators 
chapter 
static process networks 
promotion summary chapter approach programming dataflow networks functional programming language 
argued vector functions functional language section provide potential efficient execution dsp devices showed small set stream functions section write concise definitions typical signal processing functions 
functions demonstrated higher order functions provide powerful notation building networks dataflow processes ii program transformation techniques developed functional programming languages adapted process networks 
particular key classes transformation distinct effects process networks gave examples illustrating classes 
note addressed thesis similar transformations applied vector functions concrete examples see 
functional languages program transformation techniques applied ways hand derivation optimisation programs ii automatic optimisation tool functional language compilers 
hand derivation quite difficult seen example derivation parallel fir jones derivation fft algorithm 
believe appropriate path development transformations context transformational dataflow programming tool programmer choose catalog transformations applied tool 
chapter dynamic process networks previous chapter considered static sdf networks expressed haskell 
sdf networks block diagram systems ptolemy established sdf networks adequate describe bulk signal processing systems ptolemy predecessor gabriel supported sdf 
soon consider systems interact asynchronous events synchronous dataflow inadequate 
example consider digital gain control shown 
gain control signal value person changes position gain control knob 
order produce appropriate output signal able represent times occurrence gain control values relative input signal 
key approaches modelling time insert stream 
hiaton special token representing passage time 
input signal output signal gain control 
simple digital gain control chapter 
dynamic process networks attach time stamp token denoting real time token occurs 
chapter develop hybrid approach suitable real time implementation hiaton represent number ticks base clock timing stream quantised 
approach avoids having processes spend time testing prevents unbounded latencies potential problem realtime implementation time stamps 
approach described contrasts approaches modelling time maintains dataflow implementation focus time passing tokens 
explicitly models time general dynamic dataflow systems employing switch select actors 
contrasts approach taken family synchronous different sense sdf languages compile dataflow programs finite state machines 
timed streams imply dynamic scheduling give rise dynamic process networks 
dynamic networks created synchronous stream functions able think realistic example 
complete music synthesiser example provides ample opportunity explore dynamic process networks synthesiser exhibits high level asynchronous behaviour 
related prior development sdf scheduling block diagram oriented simulation systems dynamic actor scheduling 
messerschmitt simulator example fired actors round robin fashion actor insufficient input data required return simulator immediately 
general approach supporting multiple models computation taken ptolemy domain graph supports model computation graph interface allows embedded graphs different domain 
dynamic dataflow ddf domain implements dynamic scheduling dataflow graphs 
ddf domain input channels graph initialised fixed number tokens actors fired firings 
allows chapter 
dynamic process networks ddf domain embedded sdf domain 
entirely different approach time taken discrete event de domain 
actors operate timed events global clock order actor firings correctly time times occurrence actor input events 
approaches really suitable 
pino developed notion peek poke actors 
actors act interface independently scheduled graphs running different processors 
example multiplier execute real time dsp device control signal written shared memory location control cpu 
reads writes amplitude output signal change expected provided latency control cpu processing undetectable human listener 
approach develop chapter explicitly represents time 
advantage precision pino method complex implement 
languages explicitly model time include real time extensions lucid synchronous languages 
lucid dataflow language data constants occurs streams 
lewis propose stream associated stream time windows time window pair denotes earliest time corresponding daton produced latest time needs available 
skillicorn glasgow similar approach associate earliest latest time streams data stream construct isomorphic nets operating streams 
earliest input streams earliest time token produced calculated latest output streams latest time token produced calculated 
synchronous languages explicitly model time 
synchrony hypothesis reaction event supposed instantaneous 
inter process communication esterel example done broadcasting events processes broadcast responses instantaneous 
simplifying assumption allows precise specification time semantics compilation programs finite state automata 
family synchronous languages includes esterel lustre signal version lucid extended time stamps 
chapter 
dynamic process networks timed signals streams section non uniformly clocked signal defined times clock drop notation clear context signal uniformly non uniformly clocked 
clock quantised base clock fnt constant values signal sampled version analog signal am working framework existing language add time semantics language starting afresh 
time information explicit time just data 
tokens carry time information called hiaton denotes ticks base clock unit hiaton denotes single tick 
tokens carry signal data called datons stream carrying datons timed stream example subscript indicates timed stream opposed synchronous stream 
haskell type definition tokens data token ff hiaton int hiaton daton ff single value daton datons token ff 
timed vector block ff 
synchronous vector unit datons denoted daton tag occupy single tick base clock datons example stream unit datons 
stream containing unit datons called simple stream 
kinds daton timed vector vector unit datons written synchronous vector vector data element equivalent unit daton 
duration chapter 
dynamic process networks token number base clock ticks occupies duration function duration token ff int duration hiaton duration daton duration datons mapv duration duration block lengthv timed stream stream tokens 
nullt stream terminator equivalent synchronous streams timed stream constructor data timed ff nullt token ff timed ff earlier representations passing time time stamps unit 
problem unit imply processes great deal just marking time processing 
time stamps hand indeterminate latency functions may produce output indeterminate time read required input 
unacceptable real time operation reason adopted hybrid approach 
consider timed merge function function produces token receives token input takes account token durations output token appears correct tick 
datons passed output result new hiaton possibly different duration output 
arrival time tokens synchronised token durations timed merge produce output hiaton input token received duration output hiaton known 
duration input unbounded time stamped data time receiving input daton producing output hiaton unbounded 
real time operation duration tokens bounded limit say suppose 
stream bounded latency stream process produces real time stream ensure meets requirement process consumes real time stream ensure output streams latency greater input stream 
chapter 
dynamic process networks token ff timed ff timed ff ff token fi 
int token fi timed ff timed fi zipt timed ff timed fi timed token ff token fi ff fi 
ff token fl 
ff int 
ff token fl ff timed fi timed fl int timed ff timed ff timed ff timed ff timed ff stream ff timet stream ff timed ff 
types timed stream functions functions timed streams section presents set primitive functions timed streams synchronous streams section 
aim provide set functions known dataflow actor equivalents process network translated dataflow network 
variety operations timed streams greater synchronous streams claim functions complete way 
provided dataflow actor equivalents functions required find useful set functions 
types functions section listed 
recursive definitions appendix basic functions functions similar maps zips states synchronous streams 
presence necessarily complex 
accept simple timed streams streams containing unit datons 
function arguments applied value unit daton second duration hiaton 
produce token hiaton kind daton acceptable 
define version map operates unit datons ignores chapter 
dynamic process networks mapt ff fi timed ff timed fi mapt daton hiaton example mapt define replaces unit datons satisfy predicate unit ff bool timed ff timed ff nx 
daton hiaton hiaton second function zipt zips timed streams timed stream pairs stream contains pair input streams contains unit daton 
streams contain daton element pair daton unit hiaton 
example zipt zipt easy define functions operate timed streams 
unfair timed merge discussed section 
unfair merge outputs value input datons occur input streams time timed ff timed ff timed ff xs ys merge hiaton zipt xs ys merge daton daton daton merge daton hiaton daton merge hiaton daton daton operation synchronous languages time semantics produces elements signal data signal times elements signal clock signal occur 
haskell version unit hiaton output data chapter 
dynamic process networks signal value clock contains data 
example definition similar unfair merge timed ff timed fi timed ff xs ys hiaton zipt xs ys daton daton daton daton hiaton hiaton hiaton daton hiaton final primitive group propagates state value stream 
takes function arguments applied daton value duration hiaton 
functions accept state argument produce pair containing output token state 
example replace daton number ticks previous daton occurred propagate counter state output daton occurs deltat timed ff timed int deltat daton hiaton example deltat timed vectors timed vector vector tokens marked timed stream tag datons 
primitives working streams containing timed vectors 
functions analogous groups synchronous streams 
produces timed vector stream simple timed stream 
groups chapter 
dynamic process networks vector may different duration rest 
example fh joins stream unit datons timed vectors back timed stream 
illustrate sample simple timed stream 
definition replace daton timed vector containing daton hiaton multiply duration hiaton sampling factor 
joins timed vector stream back timed stream 
int timed ff timed ff datons hiaton hiaton example complex function simple timed stream 
useful reducing number streams produced 
argument latency output stream function assumes latency input stream greater value 
works propagating count number ticks daton output emitting hiaton daton encountered count reaches latency int timed ff timed ff daton datons daton xi datons hiaton chapter 
dynamic process networks example requirement input latency greater output latency sense real time effects considered 
input stream latency timing output tokens effect exhibit delay just output lower maximum duration advance time 
sake examples assume global variable named latency value 
synchronous timed streams functions operate timed synchronous streams 
concatenates vector containing unit datons synchronous vectors synchronous stream 
useful functions defined inserts specified value empty slots stream inserts daton value empty slots ff timed ff stream ff daton block ff timed ff stream ff daton block example chapter gave simple example timed user control real time signal processing function 
digital gain control easily defined chapter 
dynamic process networks num ff stream ff timed ff stream ff signal control signal zero control simple idea convert kind real time process dynamic user control 
timet converts synchronous stream timed stream adding daton tags 
example convert synchronous boolean signal clock stream defined original stream contains value true stream bool timed bool latency true timet note clock signal latency 
timed streams may reduce data rate signal 
define function outputs daton input value changes 
function edges defined terms argument starting value compares value stream edges eq ff ff stream ff timed ff edges xs latency timet xs xs xs example edges edges deltat find distance zero crossings signal deltat delta edges true delta maps gamma gamma gamma gamma suppose wish encode transmit signal straight line segments 
encoding produces value value signal second slope segment slope signal changes chapter 
dynamic process networks encode num ff stream ff timed ff encode xs edges huge xs zero xs huge frominteger huge value appear input stream 
example encode gamma gamma gamma gamma gamma gamma gamma reconstruct signal zero order interpolation integrate decode num ff timed ff stream ff decode scans zero zero example decode gamma gamma gamma gamma gamma gamma gamma dynamic process networks dynamic process networks arise streams nested 
typically synchronous streams nested timed streams daton timed stream creates processes produce new synchronous stream 
new stream produced concurrently streams initiated timed stream 
time synchronous streams process processes producing disappear 
section describes primitive functions finite synchronous streams spawn new processes combine streams 
types functions listed 
finite synchronous streams functions create finite synchronous streams 
example section show synchronous streams created initial prefix stream stream 
consider haskell standard prelude functions lists described section 
chapter 
dynamic process networks generator ff truncates stream ff stream fi generator fi stream fi fi ff fi 
fi ff bool fi ff stream ff generator ff stream ff ff bool timed ff stream fi generator fi stream fi 
types finite stream functions define function produces stream containing elements list followed infinite number copies fifth element write xs ys take xs ys repeat ys example interpret functions processes take repeat 
outputs elements stream terminates outputs elements second stream just waits stream terminate outputs element 
finite stream second stream appended defined functions streams take additional function argument type ff stream ff 
function type called generator haskell type synonym easier recognise type generator ff ff stream ff example stream version take takes outputs number elements input stream applies generator elements 
way generator called stream continuation 
generator new process produces elements output stream 
takes unable produce output elements example input stream empty element chapter 
dynamic process networks apply continuation 
takes accepts value passed continuation 
example example translated synchronous streams xs takes xs repeats requires processes 
terminate output stream generator 
takes single element ignores produces empty stream 
example take elements synchronous stream xs terminate takes takes defined terms complex primitive function definition takes additional finite stream functions listed 
accepts arguments function state current input value state 
predicate state current input value stream continuation applied output element predicate returns true 
initial state 
argument stream continuation output elements produced 
input stream 
stream continuation 
defined terms stops reading input stream predicate fails 
example 
truncates primitive stops reading second argument stream argument stream terminates 
example truncates fa fg fa dg chapter 
dynamic process networks takes int 

stream 
generator 
stream takes 


bool 

stream 
generator 
stream 


bool 



stream 
generator 
stream xs truncates xs maps xs num 

bool 

stream 
generator 
stream xs truncates xs xs xs 
functions making finite streams truncates define finite stream functions synthesiser example 
applies function elements input stream stops reading input stream calls continuation supplied predicate fails 
example 
repeats stops reading input stream calls continuation difference successive elements fails satisfy supplied predicate 
example 
final primitive group 
function stops reading synchronous stream daton timed stream fails supplied predicate 
example 
chapter 
dynamic process networks ff bool timed ff timed timed ff vector ff fi timed stream ff stream fi 
types dynamic process functions dynamic process functions primitive functions section spawn new streams combine synchronous streams 
types 
key building dynamic process networks 
daton satisfies predicate creates new daton argument stream daton 
datons satisfy predicate result unit hiaton 
example odd ff stream top level stream produce new processes 
define function produces odd daton timed stream synchronous stream containing copies daton num ff timed ff timed stream ff xs mapt proc odd xs proc daton xs takes repeats example ff gg line streams show times elements produced get time values chapter 
dynamic process networks nested stream synchronous streams combined single synchronous stream 
accepts function applied vector values produced tick existing synchronous sub streams streams producing data time function applied empty vector 
example ff gg digital music synthesiser section illustrates dynamic process creation generate musical tones 
synthesiser receives timed stream tokens represent note note events note event creates new processes generate note specified frequency 
eventually note decays processes producing note disappear 
great deal dynamism example readers familiar strict real time constraints dsp may doubt possible implement program real time 
possible shown implementation polyphonic synthesiser single tms michael 
program implements synthesiser similar simpler structure haskell program 
generate notes generating sine waves formant wave function fwf synthesis section 
re coding selected parts fwf algorithm assembler considerably notes achievable 
notes input synthesiser timed stream notes 
type associated types functions listed 
stream typically produced interface music keyboard key pressed daton generated containing note id frequency amplitude value reflecting hard key struck note released daton generated containing note id time note event note decays note exists time note event occurs time corresponding note event chapter 
dynamic process networks type frequency float type amplitude float type int type envelope float float data frequency amplitude true false nid nid true false false float 
note events associated code occurs 
polyphonic synthesiser arbitrary number notes active simultaneously 
note event stream example notes sample rate synthesiser hz 
envelopes note event received synthesiser starts generating note appropriate frequency 
amplitude note controlled envelope series straight line segments sampled envelope specified list slope target pairs segment started proceeds target value value indicated slope 
slope zero indicates current value held chapter 
dynamic process networks ramp float 
generator float ramp slope tails iterates slope float 
float 
float 
generator float 
stream float start slope target cont slope target start ramp slope start cont slope target start ramp slope start cont repeats start ramps envelope 
generator float ramps slope target rest start start slope target ramps rest ramps nulls envelope timed 
envelope 
envelope 
stream float envelope notes daton attack decay attack notes ramps decay ramps 
ramp envelope generators indefinitely 
function generates synchronous stream single segment envelope function ramps recursively processes list slope target pairs join series segment streams 
typical note envelope attack decay sustain envelope attack gamma note event received note envelope decays current value zero decay gamma complete note envelope attack envelope followed decay envelope 
function envelope generates complete note envelope starts envelope note event uses switch decay envelope corresponding note event occurs note event stream 
amplitude chapter 
dynamic process networks generator float freq maps sin phaser freq phaser float 
float 
stream float phaser init freq iterates init phase fmod phase pi fmod pi freq generator float freq repeats envelope 
envelope 
generator float 
timed 
stream float gen notes daton freq ampl ns maps ampl envelope notes gen freq 
note generators note envelope scaled amplitude parameter note event 
dashed line shows superimposed envelopes note event stream 
note generation lists code associated generation single note 
sine wave generator frequency parameter generates infinite sine wave frequency 
testing envelope generators generates infinite stream ones 
function accepts attack decay envelope waveform generator note event stream starts current note 
uses envelope generate note envelope waveform generator generate note waveform multiplies 
scales waveform note amplitude 
note terminates envelope terminates 
complete synthesiser pipeline stages code 
structure identical dynamic process example page 
note event chapter 
dynamic process networks synthesiser envelope 
envelope 
generator float 
timed 
stream float synthesiser generate mapt generate 
top level synthesiser produces new timed stream note generator process created produce synchronous stream corresponding note synchronous streams summed single synchronous stream 
waveform generator synthesiser passed argument generate 
shows result evaluating expression synthesiser attack decay notes dashed line sum note envelopes produced synthesiser attack decay notes formant wave function note generator useful testing sine waves musically uninteresting 
formant wave function fwf synthesis time domain method simulating excitation pulse resonant filter model sound synthesis 
music synthesis fwf algorithm relatively simple implement demonstrated implementation monophonic synthesiser assembler tms fixed point dsp chip 
parameters algorithm direct relation shape frequency spectrum helpful programming musical sounds produce rich interesting sounds 
formant peak spectrum musical note typical instruments excitation pulse resonant cavity including brass organ human voice 
impulse passed resonant cavity single spectral peak produces sine wave exponentially decaying envelope fwf algorithm chapter 
dynamic process networks 
sine wave synthesiser output waveform produced directly time domain 
typical instruments resonant peaks shape time variation shape give instrument characteristic timbre 
example produce single non time varying formant 
formant wave function fwf product sine wave resonant frequency envelope determines shape spectral peak 
envelope gamma cos fit fi fi parameters ff fi control shape spectral peak 
exponential terminates minimise computational burden envelope changed linear decay rate decay drops slope ffi 
modified envelope gamma cos fit fi fi gammaff gamma gamma ffi 
chapter 
dynamic process networks float 
float 
float 
stream float alpha beta delta attack decay attack pi 
cos phaser beta pi repeats decay 
delta maps exp ramp alpha 
delta fwf float 
generator float fwf alpha beta delta fc freq alpha beta delta fc periods float 
timed float periods freq timed cycle daton hiaton truncate period period freq float 
generator float mapt fwf periods 
formant wave function tone generation ffi ffe ff ln ffi ff time exponential decay changes linear decay 
lists code fwf tone generation 
generates envelope single formant wave function 
attack stream rising half cosine wave time fi followed values repeated forever 
decay stream exponential decay time followed linear decay 
total envelope point wise product 
single format wave function generated fwf accepts list fwf parameters produces point wise product envelope sine wave resonant frequency generator series possibly overlapping formant wave functions 
timed stream containing datons times new fwf start chapter 
dynamic process networks 
formant wave function output generated periods generator 
periods quite coarse just truncates period nearest integer number ticks 
result incorrect tuning higher frequencies adequate example 
function mimics structure top level synthesiser produces single fwf daton periods sums single waveform 
shows portion output fwf waveform generator 
dotted line envelope single fwf 
note waveform multiplied note envelope 
fwf synthesiser exhibits asynchronicity times notes produced note note pitch period 
produce single fwf processes created note hundreds thousands created 
dynamism inherent algorithm remains seen degree dynamism implemented real time algorithms implemented removing dynamism 
summary chapter demonstrated stream processing functions writing dynamic process networks 
approach hinges particular choice time representation suitable real time implementation represent integral number ticks base clock 
complexity representation unable chapter 
dynamic process networks produce complete set primitive functions section synchronous streams 
useful examples shown 
functions generate dynamic process networks section harder limit key functions 
defined demonstrated section suited kinds network structure example application section applications require additional functions 
clear possible provide sufficient set primitive functions necessary allow programmers define recursive functions 
applications dynamic process networks necessary assessment validity approach 
chapter summary thesis covered lot ground depth individual topics deserve 
final chapter summarise particular contributions thesis indicate specific directions proceed 
conclude thoughts value framework introduced chapter expounded remaining chapters 
contributions chapter introduced new framework signal processing development high level textual language visual language efficient low level execution model dataflow process networks combine form extremely powerful tool 
implementation complete framework believe laid groundwork implementation 
apart working haskell prototype code appendix text portions framework implemented dawson prototype visual haskell editor implementations signal processing objectoriented kernel described see page portions compiler modern digital signal processors 
key framework efficient implementation model 
model dataflow process networks widely signal processing development environments lacks formal description semantics 
chapter formal syntax semantics dataflow actors processes 
far know attempt chapter 
summary formal semantics dataflow actors processes way 
final portion chapter new form actor phased form actors 
early development kind actor offers new insights behaviour dataflow actors shows promise path improved semantic descriptions dataflow networks 
chapter visual haskell language 
visual haskell substantial design visual language builds functional programming community lead establishment haskell de facto functional programming language 
conforms successful model visual languages pipeline dataflow 
formal syntax chapter covers substantial portion standard haskell 
visual haskell extensively chapter illustrate functional programs believe examples demonstrate language usable stated limitations complete 
draw functions streams closely resembles block diagrams see example 
dawson prototype implementation language demonstrates feasibility constructing editor 
thesis maintained functional programming language excellent vehicle expressing dataflow block diagram style systems 
realisation new believe chapters explored relation context signal processing depth considered previously 
key realisation fact sdf network built delays actors section 
just functions required represent order sdf network functional programming language section 
enables employ sdf scheduling techniques implementation technology restricted class functional programs 
having identified utility functional programming dataflow explored implications key facets functional programming higher order functions program transformation sections 
developed functional programming community concepts foreign signal processing community 
higher order functions signal processing implemented ptolemy system topic 
proposed explored novel representation timed streams chapter 
realistic complete example illustrates representation chapter 
summary express dynamically changing process networks 
evolving illustrates complex dynamic network 
key directions proceed 
semantic description dataflow actors chapter benefit concise notation 
additional sugaring syntax standard form actors easier write actors 
example refutable state patterns possible write actors iota standard form actor words state part rule selection process 
needed relationship phased form actors dynamic process networks 
difficulty finding complete set primitive functions timed streams best approach think translate recursively defined functions timed streams phased form actors 
need phased form actors particular algorithm derives phased form network phased form actors 
visual haskell chapter proved invaluable visualisation tool prototype implementation complete implementation 
interesting effort construct complete editor interesting approach may build complete visual haskell domain ptolemy system signal processing exploration simulation say tcl tk graphical environment 
needed iconic representations type annotations find useful representations dynamic process networks chapter 
features described chapter incrementally added existing signal processing development systems higher order functions simple catalogue program transformations example 
effective means implementing dataflow network haskell approach add new domain ptolemy system 
doing need adapt functional mechanisms page real time streams haskell expressions represent dataflow networks embedded existing dataflow environment 
chapter attempt identifying minimal set functions needed support timed dataflow 
needed set functions chapter 
summary complete relate functions phased form dataflow actors 
relation synchronous languages needs clarified 
exploration dynamic process networks sections intriguing examples need developed 
important ingredient line development formal model dynamically evolving dataflow networks 
concluding remarks complete framework thesis somewhat idealistic 
users framework engineers requiring learn functional programming language welcome learning overhead 
lazy evaluation probably place production signal processing environment despite utility exploration prototyping 
complexities modern dsp devices generating assembler code efficient meet performance expectations highlevel code standard form actors requires analysis optimisation technology exist 
real value framework lies ideal model framework specific areas proceed done body thesis 
see key directions practical development framework proceed identify limitations existing systems new features added ii design haskell visual dataflow language appropriate mix strict non strict evaluation 
hope able pursue directions ptolemy system extending support aspects ideal model implementing new dataflow language ptolemy domain 
bibliography william ackerman 
data flow languages 
ieee computer pages february 
aho sethi ullman 
compilers principles techniques tools 
addison wesley reading ma 
ahuja nicholas carriero david gelernter 
linda friends 
ieee computer pages august 
alan ambler margaret burnett betsy zimmerman 
operational versus definitional perspective programming paradigms 
ieee computer september 
analog devices 
adsp user manual 
analog devices 
adsp super harvard architecture computer october 
preliminary datasheet 
arvind david culler 
dataflow architectures 
annual reviews computer science 
arvind 
scientific programming parallel machines 
journal parallel distributed computing 
ashcroft 
architecture 
sri technical report csl sri international ravenswood ave menlo park ca april 
tom mike joy 
list processing primitives parallel computation 
computer language 
john backus 
programming liberated von neumann style 
communications acm 
brian barrera edward lee 
multirate signal processing spw 
icassp pages may 
albert benveniste paul caspi paul le guernic nicolas halbwachs 
data flow synchronous languages 
decade concurrency reflections perspective pages 
springer verlag june 
bibliography albert benveniste paul le guernic christian 
synchronous programming events relations signal language semantics 
science computer programming september 
gerard berry georges gonthier 
esterel synchronous programming language 
science computer programming 
bhattacharyya edward lee 
scheduling synchronous dataflow graphs efficient looping 
journal vlsi signal processing 
bier ho lapsley reilly lee 
gabriel design environment dsp 
ieee micro pages october 
richard bird philip wadler 
functional programming 
prentice hall 
bird 
circular programs eliminate multiple traversals data 
acta informatica 
bird :10.1.1.100.9674
lectures constructive functional programming 
technical report technical monograph prg oxford university computing laboratory programming research group oxford 
bird 
algebraic identities program calculation 
computer journal 
tore 
skeleton parallelisation programs 
phd thesis dept computing electrical engineering heriot watt university edinburgh uk november 
brooks 
view document editor 
ieee computer pages june 
manfred broy 
applicative real time programming 
mason editor information processing 
joseph buck ha edward lee david messerschmitt 
ptolemy framework simulating prototyping heterogenous systems 
international journal computer simulation 
special issue simulation software development 
joseph buck 
scheduling dynamic dataflow graphs bounded memory token flow model 
phd thesis electrical engineering computer sciences university california berkeley 
joseph buck 
static scheduling code generation dynamic dataflow graphs integer valued control streams 
th asilomar conference circuits signals systems november 
burge 
stream processing functions 
ibm journal research development january 
bibliography margaret burnett benjamin summers 
real world uses visual programming systems 
technical report tr oregon state university 
david 
implementing recursive functions farms 
parallel computing 
luca cardelli 
dimensional syntax functional languages 
proc 
integrated interactive computing systems pages 
nicholas carriero david gelernter 
write parallel programs course 
mit press 
caspi pilaud halbwachs plaice 
lustre declaration language programming synchronous systems 
th acm symp 
principles programming languages munich west germany pages january 

digital signal processing tms 
topics digital signal processing 
john wiley sons 
murray cole 
algorithmic skeletons structured management parallel computation 
pitman publishing 
michael 
realtime polyphonic music synthesiser 
technical report school electrical engineering university technology sydney november 
undergraduate thesis report 
gennaro sergio andrea de lucia 
automatic generation visual programming environments 
ieee computer march 
stuart cox shell ying huang paul kelly liu frank taylor 
implementation static functional process networks 
parle parallel architectures languages europe pages 
springer verlag 
lncs 
alan 
porting parallel environment texas instruments tms 
editors transputer research applications 
ios press 
darlington field harrison kelly sharp wu 
parallel programming skeleton functions 
parle parallel architectures languages europe pages 
springer verlag june 
ken dawson 
visual haskell editor parser 
technical report school electrical engineering university technology sydney november 
undergraduate thesis report 
electronics research laboratory university california berkeley 
ptolemy user manual version 
bibliography marc engels greet rudy jean 
cyclo static dataflow model implementation 
th asilomar conference circuits signals systems november 
paul hudak report functional programming language haskell nonstrict purely functional language version 
sigplan notices may 
antony edgar lewis 
real time dataflow language 
ieee software pages january 
john feo david rodney 
report sisal language project 
journal parallel distributed computing 
antony field peter harrison 
functional programming 
addison wesley 
markus 
formally correct translation dsp algorithms specified asynchronous applicative language 
icassp minneapolis usa pages april 
daniel gajski david padua david kuck robert kuhn 
second opinion data flow machines languages 
ieee computer pages february 

experiments pipelining parallelism sisal 
th intl 
hawaii conf 
system sciences january 
andrew gill john launchbury simon peyton jones 
short cut deforestation 
functional languages computer architecture fpca 
david 
haskell applications digital signal processing 
technical report mitre drive mclean virginia september 
eric golin steven reiss 
specification visual language syntax 
proc 
ieee workshop visual languages pages rome italy 
kevin hammond 
parallel functional programming 
proc 
st intl 
symp 
parallel symbolic computation pages austria 
world scientific 
philip hatcher michael quinn 
data parallel programming mimd computers 
mit press 
henderson 
purely functional operating systems 
functional programming applications 
cambridge university press 
hilfinger rabaey de man dsp specification language 
icassp new mexico april 
daniel 
visual programming language scientific visualisation 
proc 
acm computer science conference pages san antonio texas march 
bibliography daniel 
visual languages computing survey data flow visual programming languages 
journal visual languages computing 
charles antony richard hoare 
communicating sequential processes 
prentice hall 
paul hudak 
para functional programming 
ieee computer pages august 
paul hudak 
conception evolution application functional programming languages 
acm computing surveys september 
paul hudak mark jones 
haskell vs ada vs vs awk vs experiment software prototyping productivity 
research report dept computer science yale university july 
john hughes 
functional programming matters 
computer journal 
jagannathan 
dataflow models 
editor parallel distributed computing handbook 
mcgraw hill 
thomas johnsson 
attribute grammars functional programming paradigm 
functional programming languages computer architecture pages portland oregon 
springer verlag 
lncs 
jones 
deriving fast fourier algorithm calculation 
davis hughes editors functional programming proceedings glasgow workshop august pages 
springer verlag 
geraint jones mary sheeran 
circuit design ruby 
editor formal methods vlsi design pages 
north holland 
mark jones 
system constructor classes overloading implicit higher order polymorphism 
proc 
acm conf 
functional programming languages computer architecture pages copenhagen denmark june 
jones sinclair 
functional programming operating systems 
computer journal february 
simon jones 
range operating systems written purely functional style 
technical monograph prg oxford university computing laboratory september 
simon peyton jones 
implementation functional programming languages 
prentice hall 
simon peyton jones philip wadler 
imperative functional programming 
acm principles programming languages pages january 
john kelly jr carol lochbaum 
block diagram compiler 
bell system technical journal pages may 
bibliography gilles kahn 
semantics simple language parallel processing 
information processing pages 
north holland 
gilles kahn david macqueen 
coroutines networks parallel processes 
editor information processing 
north holland 
richard karp raymond miller 
properties model parallel computations determinacy termination queueing 
siam journal applied mathematics november 
paul kelly 
functional programming loosely coupled multiprocessors 
research monographs parallel distributed computing 
pitman 
joel kelso 
visual representation functional programs 
technical report cs murdoch university australia december 
dan kimura apte sengupta julie chan 
form formula visual programming paradigm user definable user interfaces 
ieee computer march 
alois markus 
applicative real time language dsp programming supporting asynchronous data flow concepts 
microprogramming august 
jeffrey jack gary 
visual programming structured data flow 
proc 
ieee workshop visual languages pages kobe japan october 
john 
software development environment image signal processing 
ieee transactions image processing may 
landin 
correspondence algol church lambda notation part communications acm 
rudy ade 
geometric parallelism cyclo static data flow grape ii 
th intl workshop rapid system prototyping grenoble france june 
edward lee 
private communication 
edward lee 
dataflow process networks 
memorandum ucb erl electronics laboratory july 
edward lee david messerschmitt overview ptolemy project 
anonymous ftp ptolemy eecs berkeley edu march 
edward lee david messerschmitt 
static scheduling synchronous data flow programs digital signal processing 
ieee trans 
computers january 
edward lee david messerschmitt 
synchronous data flow 
proceedings ieee september 
bibliography allen leung mishra 
reasoning simple exhaustive demand higher order lazy languages 
th acm conf 
functional programming languages computer architecture pages cambridge ma august 
andreas 
parallel programming data structures higher order functions 
science computer programming 
mckeown 
specification simulation systolic systems functional programming 
proc 
th intl 
workshop implementation functional languages university east uk september 
david messerschmitt 
tool structured functional simulation 
ieee trans 
special topics communications january 
bertrand meyer 
applying design contract 
ieee computer october 
matthias meyer 
pilot implementation host engine software architecture parallel digital signal processing 
technical report school electrical engineering university technology sydney technical university hamburg november 
ftp ftp ee uts edu au pub dsp papers ps gz 
michaelson scaife wallace 
prototyping parallel algorithms standard ml 
proc 
british machine vision conference 
motorola dsp ieee floating point dual port processor user manual 
marc najork eric golin 
enhancing show tell polymorphic type system higher order functions 
proc 
ieee workshop visual languages illinois pages october 
marc najork simon kaplan 
cube language 
proc 
ieee workshop visual languages pages kobe japan october 
marc najork simon kaplan 
specifying visual languages conditional set rewrite systems 
proc 
ieee symposium visual languages pages august 
jeffrey 
visual programming limits graphical representation 
proc 
ieee symposium visual languages pages october 
john ousterhout 
tcl tk toolkit 
addison wesley 
software parallel operating system 
prentice hall 
simon peyton jones 
parallel implementations functional programming languages 
computer journal february 
simon peyton jones david lester 
modular fully lazy lambda haskell 
software practice experience may 
bibliography keshav pingali arvind 
efficient demand driven evaluation part 
acm trans 
programming languages systems april 
jose luis pino thomas parks edward lee 
mapping multiple independent synchronous dataflow graphs heterogeneous multiprocessors 
th asilomar conference circuits signals systems november 
john plaice 
general real time dataflow language 
proc 
formal techniques real time fault tolerant systems netherlands january 
springer verlag 
lncs 
jorg guido claudio 
higher order functional visual programming language 
journal visual languages computing 
douglas powell edward lee william newman 
direct synthesis optimized dsp assembly code signal flow block diagrams 
icassp pages 
john mark young 
dataflow visual languages 
ieee potentials april 
chris 
elements functional programming 
addison wesley 
john reekie 
effective programming parallel digital signal processing 
technical report key centre advanced computing sciences university technology sydney may 
john reekie 
real time dsp assembler 
ftp ftp ee uts edu au pub prose course ps gz 
john reekie 
modelling asynchronous streams haskell 
technical report key centre advanced computing sciences university technology sydney june 
ftp ftp ee uts edu au pub prose async streams ps gz 
john reekie 
visual haskell attempt 
technical report key centre advanced computing sciences university technology sydney august 
ftp ftp ee uts edu au pub prose visual haskell ps gz 
john reekie matthias meyer 
host engine software architecture parallel digital signal processing 
proc 
part workshop parallel realtime systems melbourne australia july 
ftp ftp ee uts edu au pub prose host engine ps gz 
john reekie john potter 
generating efficient loop code programmable dsps 
icassp pages ii ii 
ieee 
hideki john reekie 
real time performance oriented music synthesiser 
technical report school electrical engineering university technology sydney november 
undergraduate thesis report 
bibliography john reekie 
integrating block diagram textual programming parallel dsp 
proc 
rd intl 
symp 
signal processing applications pages august 
john reekie john potter 
transforming process networks 
proc 
massey functional programming workshop north new zealand august 
massey university 
john reekie john potter 
process network transformation 
david arnold editor parallel computing transputers pages 
ios press november 
steven reiss 
program development systems support multiple views 
ieee trans 
software engineering march 
xavier rodet 
time domain formant wave function synthesis 
computer music journal 
paul roe 
parallel programming functional languages 
phd thesis dept computing science university glasgow 
gary 
model architecture independent parallel programming 
mit press 
mary sheeran 
designing regular array architectures higher order functions 

jouannaud editor functional programming languages computer architecture pages nancy france september 
springer verlag 
lncs 
jay guy blelloch 
collection oriented languages 
proceedings ieee april 
david skillicorn 
stream languages dataflow 
bic editors advanced topics dataflow computing pages 
prentice hall 
david skillicorn janice glasgow 
real time specification lucid 
ieee trans 
software engineering february 
skillicorn 
parallelism bird meertens formalism 
ftp ca pub skill april 
john stankovic ramamritham 

john stankovic ramamritham editors hard real time systems chapter 
ieee computer society press 
stanley dougherty dougherty 
digital signal processing 
reston publishing 
william stoye 
message functional operating systems 
science computer programming may 
bibliography geist dongarra manchek 
pvm concurrent computing system evolution experience trends 
parallel computing 
appear 
texas instruments tms user guide 
literature number 
texas instruments tms user guide 
literature number 
turner 
semantic elegance applicative languages 
proc 
acm conf 
functional programming computer architecture pages 
david turner 
approach functional operating systems 
turner editor research topics functional programming pages 
addison reading ma 
steven vegdahl 
survey proposed architectures execution functional languages 
ieee transactions computers december 
ingrid chris jan rabaey 
specification support multi dimensional dsp language 
icassp pages ii ii adelaide australia april 
eric 
meeting parallel dsp challenge real time programming system 
dsp applications pages january 
wadge ashcroft 
lucid dataflow programming language 
academic press 
wadler 
applicative style programming program transformation list operators 
functional programming languages computer architecture pages 
acm 
philip wadler 
better laziness lazy evaluation garbage collection compile time 
proc 
acm symp 
lisp functional programming 
philip wadler 
replace failure list successes method backtracking pattern matching lazy functional languages 

jouannaud editor functional programming languages computer architecture pages 
springer verlag 
lncs 
philip wadler :10.1.1.30.9032
deforestation transforming programs eliminate trees 
theoretical computer science 
philip wadler stephen blott :10.1.1.47.1059
ad hoc polymorphism ad hoc 
acm symposium principles programming languages pages austin texas january 
malcolm wallace 
functional programming embedded systems 
phd thesis dept computer science university york uk january 
bibliography malcolm wallace colin runciman 
type checked message passing functional processes 
proc 
glasgow functional programming workshop 
springerverlag september 
workshops computer science series 
kevin waugh patrick greg michaelson 
parallel implementations functional prototypes case study 
technical report heriot watt university edinburgh uk 

exploring stream data type sisal languages 
cosnard ebcioglu 
editors architectures fine medium grain parallelism pages 
ifip elsevier science publishers 
patrick dirk marc van paul dominique 
algorithm specification dsp station data flow language 
dsp applications pages january 
carla williams john 
visual language image processing 
proc 
ieee workshop visual languages pages 
appendix haskell code vector module types infixr 
data vector nullv 
vector vector 
vector vector nullv vector xs strict 
vector xs evaluate spine nullv vector 
bool nullv nullv true nullv 
false 
vector 
nullv iterators mapv 

vector 
vector mapv nullv nullv mapv xs 
mapv xs int 



vector nullv 
int 



vector nullv 




vector 
nullv xs xs 



vector 
vector nullv nullv xs 
xs 



vector 
vector nullv nullv xs ys ys xs 



vector 
nullv xs xs 



vector 
vector nullv nullv nullv 
nullv xs 
ys ys 
xs 



vector 
vector nullv nullv xs ys ys xs vector 
vector 
vector nullv ys ys xs ys 
xs ys lengthv vector 
int lengthv nullv lengthv xs lengthv xs vector 
int 
xs xs xs int 
int 
int 
vector 
vector xs nullv xs xs 
xs int 
vector 
vector vector lengthv nullv 
lengthv vector vector 
vector nullv vector 
vector 
vector xs ys 
xs ys nullv vector 
vector vector nullv nullv nullv xys xs ys xs ys xys additional functions infixr 
infixl 
vector 

vector xs xs 
vector 

vector xs 
xs 

vector 
vector 
xs xs stream module types infixr data stream nulls stream stream 
stream stream nulls stream xs stream xs units 
stream units nulls nulls stream 
bool nulls nulls true nulls false heads stream 
heads tails stream 
stream tails xs xs primitives maps 

stream 
stream maps nulls nulls maps xs maps xs groups int 
stream 
stream vector groups nulls nulls groups nulls groups xs nullv nulls groups drops xs xs stream vector 
stream nulls nulls vs vs zips stream 
stream 
stream zips xs ys zips xs ys zips nulls stream 
stream stream nulls nulls nulls xys xs ys xs ys xys useful functions vector 
stream 
stream nullv xs xs int 
stream 
vector tk nullv tk tk nulls nullv tk xs tk xs drops int 
stream 
stream drops nulls nulls drops drops xs drops xs timed module types infixr data timed nullt token timed data token hiaton int daton datons vector token block vector timed stream list timed token 
timed timed nullt timed xs timed xs timet stream 
timed timet nulls nullt timet xs daton timet xs token 
timed nullt utilities need primitives nullt timed 
bool nullt nullt true nullt false map timed stream 
token 
int 
token 
timed 
timed daton xs xs hiaton xs xs nullt zip timed streams zipt timed 
timed 
timed token token zipt xs ys zipt xs ys zipt daton xs daton ys daton daton daton zipt xs ys zipt daton xs hiaton ys daton daton hiaton zipt xs ys zipt hiaton xs daton ys daton hiaton daton zipt xs ys zipt hiaton xs hiaton ys hiaton zipt xs ys hiaton zipt xs ys hiaton zipt xs ys zipt daton xs ys daton daton hiaton zipt xs ys zipt hiaton xs ys hiaton zipt xs ys hiaton zipt xs ys hiaton zipt xs ys zipt xs daton ys daton hiaton daton zipt xs ys zipt xs hiaton ys hiaton zipt xs ys hiaton zipt xs ys hiaton zipt xs ys zipt nullt unzip stream pairs 
timed token token 
timed timed daton daton daton xys daton xs daton ys xs ys xys daton daton hiaton xys daton xs hiaton ys xs ys xys daton hiaton daton xys hiaton xs daton ys xs ys xys hiaton xys hiaton xs hiaton ys xs ys xys nullt nullt state process timed stream 
defined directly terms get break 


token 

int 
token 

timed 
timed daton xs xs hiaton xs xs nullt concatenate stream tokens token vectors timed 
timed hiaton xs hiaton xs daton xs daton xs datons xs append xs nullv append ys ys xs append ys xs append ys nullt group stream vectors greater xs xs nullt nullt nullt hiaton hiaton nullt hiaton xs rest rest xs xs hiaton xs hiaton xs hiaton const rest rest xs nullt take vector front stream 
returns rest stream initial hiaton value 
int 
timed 
token int timed daton xs datons daton xs daton xs daton const rest rest xs hiaton xs hiaton xs hiaton xs nullt xs hiaton nullt hiaton const rest rest xs hiaton nullt join token token vector const token 
token 
token const hiaton datons 
hiaton const datons datons 
join vector blocks back sync stream 
allowed 
timed 
stream daton xs xs block xs xs nulls spawn new streams timed stream 
bool 
timed 
timed timed nullt nullt daton xs daton xs hiaton xs hiaton xs hiaton xs combine timed sync streams single top level sync stream vector 

timed stream 
stream ss ss daton vector map heads ss ss ss block mmap ss int 
stream 
stream filter nulls map drops mmap vector 

stream 
stream mmap ss vector map heads ss mmap ss new functions truncating streams type generator 
stream terminate stream generator const nulls truncate stream predicate state 





bool 


stream 
generator 
stream xs nulls xs nulls xs xs take items predicate control stream satisfied 
daton satisfy 

bool 
timed 
stream 
generator 
stream daton ys xs ys xs error hiaton ys xs hiaton ys xs daton ys xs ys xs hiaton ys xs ys xs hiaton ys xs hiaton ys xs truncate stream length truncates stream 
stream 
generator 
stream truncates nulls ys truncates xs nulls truncates xs ys truncates xs ys 
