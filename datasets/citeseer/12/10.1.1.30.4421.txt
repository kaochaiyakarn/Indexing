higher type recursion ramification polynomial time 
schwichtenberg february shown restrict recursion notation finite types characterize polynomial time computable functions 
restrictions obtained enriching type structure formation types oe adding linear concepts lambda calculus 
recursion finite types introduced hilbert known essential part godel system 
system long viewed powerful scheme unsuitable describing small complexity classes polynomial time 
simmons showed ramification characterize primitive recursive functions higher type recursion leivant marion showed form ramification restrict higher type recursion pspace 
characterize smaller class polynomial time computable functions higher type recursion additional principle required 
introducing linearity constraints conjunction ramified recursion characterize polynomial time computability admitting recursion notation higher types 
simple types built ground type binary numerals recursion notation type oe mapping oe type oe 
oe oe oe defined oe oe oe single recursion type define function exponential growth satisfies je jmj jnj 
note function assigned ramified type scheme leivant tier tier 
shows requirement addition ramification recursion variable required restrict higher type recursion polytime computability 
culprit lie nested nonlinear research supported logik der informatik der dfg munchen 
assistance fields research mathematical sciences toronto gratefully acknowledged 
research reported supported dfg gratefully acknowledged 
previous value approach introduce time ramification recursion variable linearity conditions 
enrich type structure formation types oe called complete types types called incomplete 
intuitively objects complete types completely known pattern recursion higher type non linear way 
objects incomplete types accessed low order bits higher type certain linear way 
define class ra ramified terms 
recursor oe receives ramified type oe 
oe oe 
oe admitted free oe require terms complete types free variables incomplete types 
input positions types correspond normal tier safe tier input positions common earlier ramified recursion cf 

central system expresses linearity constraints bound variables incomplete types 
designed system ra closed reduction 
ordinary lambda terms defined recursion constants embeddable ra 
closed term normal form nf may length length constant respect length integers may wish evaluate denoted function 
show closed ra term type level find polynomial numerals compute normal form nf time nj 
denotes polynomial time computable function 
converse holds polynomial time computable function computed ra term 
hofmann modalities ramification linearity lambda calculus defined higher types 
interesting characterizes polynomial time computability 
modalities independent concepts coincide 
proof methods papers different hofmann uses category theoretic approach 
connections linear logic see girard scedrov scott abramsky background linear logic refers knowledge input allows nonlinearly 
logic differs significantly polytime linear logic explicit polynomials attribution occurrences 
connections light linear logic girard due differing frameworks exact comparison 
modality different linear modality includes concepts ramification study ordinary ramified recursion 
approach higher type functions taken contrasts cook wellknown basic feasible functions defined pv terms 
explicit size bounds critical value computed recursion ground type 
difference seen fact system ra admits iteration functional jxj form bff 
hand intuitively expects suitable sense bff functions definable ra 
types terms types type oe types oe oe 
assume binds tighter associates right 
types form oe complete incomplete 
ground types types level defining level oe oe oe oe higher type type level 
example ground type higher type 
free types called safe 
ground type safe complete 
constant symbols listed types 
predecessor oe 
oe 
oe 
oe oe oe safe cases oe oe 
oe oe 
oe oe safe recursion terms built constants typed variables oe elimination rules type forms oe oe 
oe oe 
oe 
oe oe oe oe oe binary numeral 
conversion rules assume binary numeral distinct 





rt 
rt 


application term associates tighter applications right applications associate left 
rg 
conditional hofmann conditional 
length jtj term defined jxj jcj jx rj rj jrj jrj jrj jsj 
redexes subterms shown left side conversion rules 
term normal form contain redex 
term unique normal form term nf see proofs normalisation godel system 
terms equivalent normal form 
linear logicians may read 
writes fv set free variables fo multiset free occurrences say term complete incomplete safe ground type similar godel types terms interpreted set theoretical function spaces 
semantics identify objects type oe type oe interested computational behaviour terms 
interpret non negative integers 
value term environment defined usual value closed term independent environment just write 
ra terms subterms occurring term scope equivalent binds variable free lie scope definition 
incomplete variable term 

subterm free occurrence occurrence occurrences scope equivalent 
call 
type variable trivially term 
definition 
ra term ramified complete subterm contains complete free variables subterm incomplete variable reduct pointed intuition terms complete type non linear way objects higher incomplete type certain linear way expressed 
accordingly requires complete terms incomplete free variables 
simmons requirement step terms oe complete types rule non primitive recursive growth rate 
previous value outer recursion applied previous value inner recursion 
example godel function 
defined 
sy obtain polynomial growth rate additionally require recursion type oe admitted safe free types oe recall type oe 
oe oe 
oe oe ra 
oe mimics central idea ramification safe normal input positions cf 
previous values recursions passed safe input positions input positions induce unfolding recursions 
example polynomially growing functions phi satisfying jm phi nj jmj jnj omega satisfying jm omega nj jmj delta jnj easily definable ra phi omega phi xv higher types oe previous values recursions passed input positions applied objects complete types recursion oe admitted safe oe 
designed rule nested occurrences previous values recursions cf 
definition 
requires lambda higher type incomplete variable free occurrences separated occurrences ground type context admitting recursion oe incomplete oe allow define proper elementary functions 
example function satisfying jmj ra definition 
sq sq defines function sq jnj note gamma 
need obtain system closed reduction condition requires reduct note terms property closed application may form rs incomplete satisfy rs 
immediate terms property closed reductions 
true ra terms prove 
theorem closure reduction 
ra term 
gamma 
ra term 
nf 
proof 
induction height reduction tree side induction proof ra term assume gamma 
terms property closed reductions suffices consider subterm incomplete prove reduct case subterm assumption reduct reduct fv 
case gamma 
subterm distinguish subcases 
subcase gamma 
gamma 
nf side ih nf nf 
reduct nf 
subcase reduct find situation side ih ra term 
successively applying ih gamma obtains ra term 
ih nf nf 
proof ra term assume normal done 
assume gamma 
proceed distinguishing cases 
case may assume redex claim follows giving ra term ih giving nf 
reduct obtained replacing occurrences nf 
ra term 
claim follows ih free occurrence nf nf nf 
case 
ih may assume subterm containing duplicated reduction 
considering reductions ones duplicate subterm reductions fi reductions 
case duplicated subterm complete type property contain case redex fv formed replacing 
satisfies contains incomplete variable incomplete 
satisfies reduct obtained replacing 
ra term gamma 
furthermore applying induction hypothesis obtain nf nf 
rs terms final result interested ground type terms free variables ground type 
observe due typing constants normal form term variables safe ground 
lemma 
ground type term free variables ground type 
nf variables safe ground 
proof 
suppose variable oe oe safe ground occurs nf 
bound subterm oe oe 
nf 
structure normal derivations system propositional logic consisting elimination rules follows cf 
oe occurs positively type nf negatively type constants free variables nf 
impossible ground type inspection types constants 
normal ground type term ground free variables satisfies subterm higher type safe variable reduct 
kind sharing construct obtain equivalent term containing higher type variable replace lemma sharing 
term subterm higher type incomplete variable repeated expansions 
construct term gamma 
subterm higher type incomplete 
proof 
induction number occurrences bound higher type incomplete variables 
consider outermost subterm higher type incomplete 
assumption minimal subterm contains occurrences result replacing new variable write occurrences simultaneously replaced apply induction hypothesis show inside results see subterm occurrence scope equivalence occurrences fv occurrence free occurrence case occurs case separated case case minimality implies construction results replacing subterm new free occurrence cases 
subterm occurrence contains exactly occurrence construction follows subterm construction motivate useful consider subset set ra terms called rs terms stands sharing 
definition 
ra term rs term safe ground variables higher type variable occurs 
term written uniquely head form form variable constant ground 
call components number components considered part head form 
components specified numbering order left right 
general term formation operation terms resulting formation term components terms specified constant numbers remaining components terms specified number algorithms nf rf described register machine model computation register may contain term 
unlimited supply registers primitive computation step operations test head form copying component register test formation test formation test oe formation variable test formation operations simulated turing machine time polynomial length terms registers program computable polynomial time register machine polynomially large terms registers polynomial time computable turing machine 
refers encoding terms turing machine tape 
associates unique environment register variable numeral binary numeral number 
environment list rs term type numeral environment environment numeral 
theorem 
free rs term ground type numeral environment fv compute nf jtj steps ii number registers jtj iii term occurring computation satisfies jsj jtj max jn proof 
describe algorithm nf input outputs nf nf input register induction jtj 
type reasons form variable constant ground type 
output 
performed steps ii iii obvious 
delta delta delta occurrences delete leading content output resulting numeral 
performed jtj steps jtj registers iii obvious 
ur symbol compute nf form un 
performed jrj jtj steps jrj jtj registers iii follows 
compute nf output form performed jrj jtj steps jrj jtj registers 
iii observe js nj jrj max jn jtj max jn similarly pr compute nf form output 
compute nf js rj jtj steps js rj registers 
iii follows directly induction hypothesis oe compute nf find new variable copy compute nf performed jt jt rj jtj steps max jrj jt rj jtj registers 
iii observe jt rj max jn jnj jt rj jt max jn jtj max jn ground type 
compute nf copy compute nf 
observe ground type numeral environment fv performed jrj js rj jtj steps ii iii follow previous case 
compute nf 
js rj jtj performed js rj jtj steps js rj registers iii obvious 
corollary base normalisation 
closed free rs term ground type 
numeral nf computed jtj steps jtj registers term occurring computation satisfies jsj jtj 
order compute free rs terms slightly generalise technique 
theorem elimination 
rs term safe ground type 
polynomial closed ground type free rs terms fv safe compute free rs term rf equivalent number steps number registers length term occurring computation jn 
proof 
induction jtj 
jn write steps registers quantities call maximum bound 
course computed term rf new free variables produced fv rf fv 
compute rf form observe safe safe type safe free variables 
induction hypothesis free rs term obtained bound 
free rs term obtained bound jtj 
ur variable constants oe safe ground type term apply induction hypothesis rs terms obtain suitable free rs terms rf 
form ur rename obtain rs term 
need closed free variable duplicated violating property 
induction hypothesis obtained bound jtj 
ground type satisfies 
distinguish cases safe rename form step compute rf rf 
form rename obtain rs term 
induction hypothesis result term obtained bound jtj 
complete form step compute rf copy compute rf 
induction hypothesis result term obtained bound jtj 
form step compute rf 
induction hypothesis result term obtained bound jtj 
case treated similarly previous case case obvious 
safe remaining case form output renamed version term gamma rf nf rf rf hz new variable obtained deleting leading constants rf 
complete subterm term satisfying free variables complete 
closed free variables safe 
nf numeral 
obtains rf bound induction hypothesis 
base normalization obtains numeral nf rf nf steps registers compute term gamma obvious loop jn rounds 
obtain estimate bound need look details 
pick new variable write hz fixed register compute rf bound result register consider register holding counter 
holds output content register holds holds gammai gamma 
compute gammai gamma environment register clearly possible bound jn polynomial compute gammai gamma rf hz gammai gamma bound hz jn gammai gamma hz 
update applying content original content 
gives gammai gamma gammai gamma step additional register increased jt gammai gamma hz 
update hold go initial test loop 
estimate bound 
go jn times loop 
number steps round jn hz jn gammai gamma hz number register plus compute gammai gamma plus hz compute gammai gamma maximum length term hz total bound part computation gamma hz delta delta loop rounds compute rf bound assuming holds gamma gamma update applying term total number steps registers lengths terms polynomial explicitely definable hz polynomial time computable functions section complete proof number theoretical functions definable exactly polynomial time computable functions 
theorem bounding 
closed ra term type oe oe ground type 
denotes function computable polynomial time turing machine 
proof 
find polynomial numerals types oe compute nf time jn new variables types oe 
ra term note type oe 
normal form computed number steps large constant respect closure reduction ra term ground free variables 
note variables nf safe ground 
nf normal term satisfying subterm higher type variable sharing obtains rs term nf number steps needed compute elimination obtains free rs term rf equivalent requires time steps uses registers size 
output register bounds length base normalization obtains nf nf rf total time steps registers size 
computation simulated turing machine polynomial factor 
remains embed polynomial time computable functions system ra terms 
resource free function algebra characterizations polynomial time computable functions pick 
theorem 
function computable polynomial time turing machine denoted ra term proof 
polynomial time computable functions characterized function algebra schemata safe recursion safe composition 
function written form denotes kind bookkeeping variables involved safe recursion definition denotes variables recursion performed 
proceed induction definition associating closed ra term type denoting initial function projection satisfying xm xm xm define xm 
conditional satisfying mod type 
defined safe composition define gm hn defined safe recursion 
induction hypothesis obtain define dn pn pn 
case finished defining 
case easily verifies abramsky 
computational interpretations linear logic 
theoretical computer science 
cook 
new recursion theoretic characterization polytime functions 
computational complexity 

characterizing parallel polylog time type recursions polynomial output length 
logic computational complexity leivant ed springer lecture notes computer science 


ranking primitive recursions low grzegorczyk classes revisited 
siam journal computing 
appear 
cook 
characterizations basic feasible functionals finite type 
feasible mathematics buss scott eds birkhauser boston 
girard scedrov scott 
bounded linear logic modular approach polynomial time computability 
theoretical computer science 
girard 
light linear logic 
information computation 
godel 
uber eine noch nicht erweiterung des 
dialectica 
hilbert 
uber das 
mathematische annalen 
hofmann 
mixed modal linear lambda calculus applications cook safe recursion 
csl springer lecture notes computer science appear 
hofmann 
new results linear modal lambda calculus higher result types recursion trees 
draft 
matthes 
short proofs normalisation simply typed calculus conversions godel submitted leivant 
lambda representation free algebras 
feasible mathematics buss scott eds birkhauser 
leivant marion 
ramified recurrence computational complexity iv predicative functionals poly space 
information computation appear 


measure tool classifying computational complexity 
submitted september 
simmons 
realm primitive recursion 
archive mathematical logic 
troelstra schwichtenberg 
basic proof theory cambridge university press 

