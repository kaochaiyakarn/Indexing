self papers compiled bay wei chang self group cis stanford university stanford ca table contents self power simplicity parents shared parts objects inheritance encapsulation self organizing programs classes efficient implementation self dynamically typed object oriented language prototypes iterative type analysis extended message splitting optimizing dynamically typed object oriented programs experiencing self objects object artificial reality published lisp symbolic computation international journal kluwer academic publishers manufactured netherlands self power simplicity david ungar ungar self stanford edu computer systems laboratory stanford university stanford california randall smith parc xerox com xerox palo alto research center palo alto california 
self object oriented language exploratory programming small number simple concrete ideas prototypes slots behavior 
prototypes combine inheritance instantiation provide framework simpler flexible object oriented languages 
slots unite variables procedures single construct 
permits inheritance hierarchy take function lexical scoping conventional languages 
self distinguish state behavior narrows gaps ordinary objects procedures closures 
self simplicity expressiveness offer new insights objectoriented computation 
self true 
william shakespeare object oriented programming languages gaining acceptance partly offer useful perspective designing computer programs 
offer exactly perspective different ideas nature object oriented computation 
self programming language new perspective objects message passing 
smalltalk language self designed support exploratory programming partially supported xerox partially national science foundation presidential young investigator ccr sun microsystems powell foundation ibm apple computer dec ncr texas instruments cray laboratories 
authors address sun microsystems garcia avenue mountain view ca 
substantial revision originally published oopsla conference proceedings sigplan notices 
ungar smith includes runtime typing type declarations automatic storage reclamation 
smalltalk self includes classes variables 
self adopted prototype metaphor object creation 
furthermore smalltalk object oriented languages support variable access message passing self objects access state information sending messages self receiver current message 
naturally results messages sent self language named honor messages 
strengths object oriented programming lies uniform access different kinds stored computed data ideas self result uniformity results greater expressive power 
believe ideas offer new useful view object oriented computation 
principles guided design self messages bottom 
self features message passing fundamental operation providing access stored state solely messages 
variables merely slots containing objects return 
self objects access state solely sending messages message passing fundamental self languages variables 
occam razor 
design aimed conceptual economy described self design omits classes variables 
object perform role instance serve repository shared information 
distinction accessing variable sending message 
smalltalk language kernel control structures 
closures polymorphism support arbitrary control structures language 
smalltalk self objects procedures woven representing procedures prototypes activation records 
technique allows activation records created way objects cloning prototypes 
addition sharing model creation procedures store variables maintain environment information way ordinary objects described section 
concreteness 
tastes led metaphor elements concrete possible 
matter classes versus prototypes chosen try prototypes 
basic difference way new objects created 
class language object created instantiating plan class 
prototype language self object created cloning copying prototype 
self object cloned 
smalltalk trademark parcplace systems 
term smalltalk refer smalltalk programming language 
self power simplicity remainder describes self detail concludes examples 
smalltalk yardstick widely known language object 
familiarity smalltalk helpful reader 
prototypes blending classes instances smalltalk simula loops ada object object contains pointer class object describes format holds behavior see 
self object 
class pointer self object contains named slots may store state behavior 
object receives message matching slot search continues parent pointer 
self implements inheritance 
inheritance self allows objects share behavior turn allows programmer alter behavior objects single change 
instance point object slots non shared characteristics see 
parent object held behavior shared points comparing prototypes classes self interesting aspects way combines inheritance prototypes object creation eliminating need classes see table 
simpler relationships 
prototypes simplify relationships objects 
visualize way objects behave class language grasp relationships relationship indicates object instance class kind relationship indicates object class subclass object class 
system self prototypes classes relationship inherits appeal point objects examples 
smalltalk point represents point dimensional cartesian coordinates 
contains instance variables coordinates 
creation metaphor initialization kind infinite regress class systems instance subclass build plan executing plan need extra object class class class class 
self classes inherits clone object cloning example extra object needed required inheritance relationships ungar smith class superclass inst vars methods name point class class superclass inst vars methods name object nil class add points print print objects parent parent parent print add points print objects self objects smalltalk 
instances classes 
comparison smalltalk instances classes self objects 
bottom point objects created user program 
self point intrinsically describes format appeals object behavior shared points 
example points appeal object containing shared behavior points 
object turn appeals top behavior shared objects 
root object fully describes format behavior parent 
smalltalk point contains class pointer coordinates 
class point supplies format list instance variables behavior information collection methods points 
additional format behavior information inherited object point superclass link 
classes turn appeal classes shown format behavior 
self power simplicity describes objects share behavior state 
structural simplification easier understand language easier formulate inheritance hierarchy 
working system provide chance discover class objects useful programmers create encouragement language 
absence class instance distinction may hard understand objects exist solely provide shared information objects 
self programmers create entirely new organizational structures 
case self flexibility poses challenge programming environment include navigational descriptive aids 
creation copying 
creating new objects prototypes accomplished simple operation copying simple biological metaphor cloning 
creating new objects classes accomplished instantiation includes interpretation format information class see 
instantiation similar building house plan 
copying appeals simpler metaphor instantiation 
examples preexisting modules 
prototypes concrete classes examples objects descriptions format initialization 
examples may help users reuse modules making easier understand 
prototype system allows user examine typical representative requiring sense description 
support kind objects 
self provides framework easily include kind objects behavior 
object named slots slots hold state behavior object unique slots behavior see 
class systems designed situations objects behavior 
linguistic support object possess unique behavior awkward create class guaranteed instance 
self suffers disadvantages 
object customized behavior 
unique object hold unique behavior separate instance needed 
elimination meta regress 
object class system object class needed express structure behavior 
leads conceptually infinite meta regress point instance class point instance metaclass point instance point ad infinitum 
hand prototype systems object include behavior object needed life 
prototypes eliminate meta regress 
discussion prototypes naturally applies realized self 
prototype systems inheritance problem object include behavior just real world see description structures evolved written 
ungar smith point clone class superclass inst vars methods name point class class inst vars methods superclass name new objects parent parent clone objects creating self object 
creating smalltalk object 
superclass inst vars methods class inst vars methods superclass name 
superclass inst vars methods create new point self clone message sent prototypical point 
clone method copies receiver 
point slot resides root object create point 

object creation smalltalk self 
create new point smalltalk new message sent class point 
new method point class superclass uses information receiver point define size format new object 
self power simplicity class superclass inst vars methods name object nil 
class superclass inst vars methods name false 
true 
class smalltalk self false true iftrue iffalse value iftrue iffalse value iftrue false parent 
parent 
iftrue false parent 
value 
value true false 
self easier define unique objects class system smalltalk 
consider objects represent true false boolean values 
system needs instance object smalltalk class 
self object contain behavior straightforward create specialized objects true false 
ungar smith systems pleasant differences computers real world ability sweeping changes changing shared behavior 
inheritance introduced language natural tendency prototype object contains behavior kind object 
instance behavior points changed changing behavior prototypical point 
unfortunately system supply ways create objects object offspring prototype copy object prototype 
ultimate result prototypes special prototypical 
solution put shared behavior family objects separate object parent prototype 
way prototype absolutely identical member family 
object containing shared behavior plays role akin class contains information representation merely holds shared behavior 
add behavior points self add behavior parent points 
blending state behavior self direct way access variable objects send messages access data residing named slots 
access value point sends message 
message finds slot evaluates object 
slot contains number result evaluation just number 
order change contents slot say performing assignment point send message argument 
point object contain slot named containing assignment primitive 
course messages sent self verbose programs syntax allows self elided 
result accessing state messages self easy write accessing variables directly smalltalk accesses slot name stores seventeen slot 
accessing state messages inheritance powerful 
suppose wish create new kind point coordinate random number stored value 
copy standard point remove slot changed replace contents slot code generate random number see 
modifying slot replaced slot halt method obtain breakpoint write 
self express idioms associated active variables 
accessing state messages easier share state 
create points share coordinate slots put separate object parent points see 
self power simplicity 
examples flexibility self 
left point coordinate computed random number generator 
code point sends messages get value random point reuse existing point code 
right points share variable 
parent print parent print objects 
parent add points parent random number generator print parent print objects 
parent add points parent parent parent computing value storing shared state object oriented languages accessing variable different operation sending message 
message passing model computation assignment access 
result message passing powerful 
instance inclusion variables harder specialization subclass replace variable computed result may code superclass directly accesses variable 
class languages typically store names order instance variables object class shown 
limits power inheritance specification class unnecessarily restricts instance format 
variable access requires scoping rules complication 
instance smalltalk kinds variables local variables temporaries instance variables class variables pool variables global variables scopes roughly correspond ladder instantiation 
ungar smith closures methods lisp community obtained excellent results closures basis control structures 
experience smalltalk blocks supports closures provide powerful easy metaphor users exploit define control structures 
furthermore ability crucial language supports user defined data types 
self closure represented object containing environment link method named value value value forth depending number arguments 
local variables 
methods require storage local variables self slots fulfill function 
smalltalk method creates activation record initial contents described method 
example number temporary variables listed method describes number fields set aside activation record hold variables 
similar way class contains structural description instantiate instances 
self objects play role methods prototypes activation records copied invoked run subroutine 
local variables allocated reserving slots prototype activation record 
advantage prototype slots may initialized value may contain private methods closures blocks 
environment link 
general method contain link enclosing closure scope 
link resolve variables method 
self having separate scope information method parent link performs function 
slot current scope lookup proceeds outer scope parent link 
interesting mechanisms needed parent links handle lexical scoping 
parent link set appropriate object 
simple ordinary object parent link automatically set prototype parent result cloning 
methods object created compiler serves prototype activation invoked cloned 
clone parent set message receiver 
fashion method scope embedded receiver 
self blocks environment link set block enclosing activation record block created 
block activated method parent link set block environment link 
second order allow slots containing local variables accessed way implicit self operand take unusual meaning start message lookup current activation record set receiver message current receiver 
way opposite super construct smalltalk starts lookup receiver superclass see 
self power simplicity parent print objects activation self clone print parent clone objects arg self parent arg self nil clone arg arg shared behavior objects shared behavior points point point cloned activation record prototype activation record 
shows happens point sent message argument 
lookup plus starts finds matching slot object holding shared behavior points 
contents slot method object cloned clone argument slot set argument message parent set receiver 
code executes lookup find receiver slot inheritance chain current activation record 
find contents arg slot way 
technique having lookup implicit self receiver start current activation allows local variables instance variables method lookup unified self 
ungar smith speculation self headed 
designing self led strange recurring themes 
reader ponder 

object languages objects passive object self object 
variable access message passing ordinary passive objects regarded merely methods return 
example consider number 
smalltalk number represents particular immutable state 
self number just object returns behaves certain way respect arithmetic 
way know object actions 
computation viewed refinement 
smalltalk number number particular state state information arithmetic primitives addition example 
self viewed refinement shared behavior numbers responds addition returning argument 
self activation record parent set receiver message method activation viewed creation short lived refinement receiver 
likewise block closure activation viewed creation refinement activation record enclosing context scope 
examples render shared behavior object points ordinary passive object 
twist build class objects methods 
self shared behavior object points method code simply returned clone prototypical point 
method installed point slot root object 
object serving roles code create new points slots locals hold shared behavior points 
writing believe best way construct system methods hold shared behavior group objects example flexibility afforded self 
parents viewed shared parts 
view parents object shared parts object 
perspective self point contains private part slots part shared points containing slots part shared objects containing behavior common objects 
viewing parents shared parts broadens applicability inheritance 
syntax section outline syntax textual representation self objects 
possible followed smalltalk syntax avoid confusion 
added slot list syntax creating objects inline 
general self objects written enclosed parentheses include list slots case self power simplicity methods include code 
blocks written methods enclosed square brackets parentheses 
code follows smalltalk syntax notable exceptions receiver omitted self 
return value method result expression 
keyword messages associate right left 
case keyword message sends easier read keyword lowercase subsequent keywords selector uppercase 
changes reduce number parentheses lexical noise self code 
slot list syntax little precedent smalltalk 
slot list pair vertical bars 
item slot list separated period 
trailing period optional 
forms slots selector denotes slots slot initialized nil slot named trailing colon initialized assignment primitive denoted 
example object contains slots called containing nil called containing effect declaring smalltalk variable 
selector followed left arrow slots slot initialized value expression corresponding assignment slot 
effect similar initialized variable 
example method object tally tally tally random 
tally random slot root returns random numbers returns sum random numbers 
contains slot named tally initialized zero slot named tally containing assignment primitive 
selector followed equals sign expression denotes slot initialized value expression 
effect identical left arrow form variable read assignment slot created 
unary selector identifier preceded colon defines slot bound corresponding argument message 
example ungar smith arguments method may moved selector smalltalk display aform 
copy destination self source aform display aform copy destination self source aform equivalent 
examples example shows simple point 
assumes system organized kinds objects objects hold shared traits prototypes 
examples primitive adds slots receiver slots exist primitive define redefines receiver place 
traits 
create object holding traits objects 
prototypes 
create object holding prototypical objects 
parent easier refer contents 
traits traits define define object holding traits objects 
copy clone 
define copy method invokes clone primitive 
traits point traits point define define object holding traits points 
parent traits 
inherit copying methods 
printstring define method construct printable string 
printstring concatenate strings printstring 
separated 
define method addition 
uses local slot 
copy 
copy receiver serve result 
self power simplicity set coordinate 
set coordinate 

return new point 
define subtraction exploiting fact copy assignment returns self 

convention methods return self possible 
prototypes point point define define prototypical point 
parent traits point 
inherit shared traits read parent slot 
define read write slots initialized 
define assignment primitive 
traits integer add behavior creating points existing point copy self 
integer traits object 
example interesting shows exploit self unique features build data structure holds binary tree objects 
traits traits define define object holding traits 
parent traits 
inherit copying methods 
includes false 
empty trees include insert create new set contents parent copy switch parents 
uses dynamic contents 
inheritance 
size 
self 
prototypes tree tree define define prototypical tree empty 
parent assignable parent slot set traits 
traits traits define define object holding tree node traits 
parent traits 
inherit copying methods 
ungar smith includes method uses local variable 
contents iftrue true 
send contents self compare 
uses self ability inherit state contents slot 
return true 
select subtree 
iftrue left false right 
includes 
recurse return result recursive call 
insert insert receiver recursion contents iftrue self 
includes 
iftrue left false right 
insert self 
size left size right size 
left 
value contents 
right 
self 
copy copy subtrees copying tree node 
resend copy left left copy provides new empty trees tree node right right copy 
copied insertion tree 
prototypes define define prototypical tree node 
parent traits 
constant parent slot 
left assignable subtree slots initialized right prototypical empty tree 
contents 
assignable slot contents 
related express deep appreciation past members system concepts laboratory xerox parc trail smalltalk 
way self accesses state message passing owes conversations peter deutsch reminiscent earlier unpublished language called smalltalk programmers adopted style variable accessing 
trellis owl independently designed object oriented language includes syntactic sugar message invocation look self power simplicity element access assignment 
reverse approach 
stuck message passing syntax self emphasize behavioral connotations 
strobe frame language ai mixes data behavior slots 
loops extension interlisp objects includes active variables 
henry lieberman calling attention prototypes 
self lieberman prototypes include shared information 
clones inherit prototype adding private slots demand 
approach obviates need traits objects prototypes heavier weight objects self 
exemplars name prototypes project added prototype object hierarchy smalltalk 
design self objects created cloning exemplars multiple representations data type permitted 
self system includes classes type hierarchy forms multiple inheritance 
interesting contribution exemplar system support inheritance 
self unorthodox exemplars respects eliminates variable accessing language unifies objects classes methods 
alternate reality kit direct manipulation simulation environment prototypes active objects insight world prototypes 
alan borning experience prototype environments especially wonderful sounding board struggling grasp implications prototypes 
proposal included ideas merging smalltalk methods blocks helped understand problems area 
actors system active objects processes self procedural model 
actors rejects classes replacing inheritance delegation 
version scheme message passing bottom 
class maintains inheritance hierarchy separately lexical nesting integrate lambdas objects 
self offers new paradigm object oriented languages combines simplicity expressiveness 
simplicity arises realizing classes variables needed 
elimination metaclass regress illusory distinction instantiation subclassing allows blurring differences objects procedures closures 
reducing number basic concepts language language easier explain understand 
tension making language simpler making organization system manifest 
variety constructs decreases variety linguistic clues system structure 
ungar smith making self simpler powerful 
self express idioms traditional object oriented languages classes instances go express kind objects active values inline objects classes overriding instance variables 
believe self provides insights nature object oriented computation 
acknowledgments daniel weise mark miller listening patiently tutoring scheme 
craig chambers martin rinard lee helped distill refine language 
readers reviewers helpful comments criticisms especially dave robson helped separate wheat chaff 

abelson sussman sussman structure interpretation computer programs mit press 

borning constraint oriented simulation laboratory 
ph dissertation stanford university 

borning programming language aspects constraint oriented simulation laboratory 
acm transactions programming languages systems 

borning classes versus prototypes object oriented languages 
proceedings acm ieee fall joint computer conference 

borning shea empirically aesthetically motivated simplification smalltalk tm language 
unpublished manuscript 

goldberg robson smalltalk language implementation 
addison wesley reading ma 

hewitt agha actors conceptual foundation concurrent object oriented programming 
unpublished draft mit artificial intelligence laboratory 

lalonde thomas pugh exemplar smalltalk 
oopsla conference proceedings 
published sigplan notices 
self power simplicity 
lang pearlmutter object oriented scheme class types 
oopsla conference proceedings 
published sigplan notices 

lieberman prototypical objects implement shared behavior object oriented systems 
oopsla conference proceedings 
published sigplan notices 

search smalltalk programming style 
technical report 
cr computer research laboratory tektronix laboratories beaverton 

schaffert cooper kilian trellis owl 
oopsla conference proceedings 
published sigplan notices 

power tools programmers 
datamation 

smith alternate reality kit animated environment creating interactive simulations 
proceedings ieee computer society workshop visual languages 

smith experiences alternate reality kit example tension magic 
proceedings chi gi conference 

smith strobe support structured object knowledge representation 
proceedings international joint conference artificial intelligence 

steele jr lambda ultimate imperative 
ai memo mit artificial intelligence laboratory 

stefik bobrow kahn integrating access oriented programming multiprogramming environment 
ieee software magazine 

ungar chambers chang hlzle organizing programs classes 
published lisp symbolic computation 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation international journal kluwer academic publishers manufactured netherlands parents shared parts objects inheritance encapsulation self craig chambers david ungar bay wei chang urs hlzle self self stanford edu computer systems laboratory stanford university stanford california 
design inheritance encapsulation self object oriented language prototypes results understanding inheritance allows parents shared parts children 
programmer resolves ambiguities arising multiple inheritance prioritizing object parents 
unifying unordered ordered multiple inheritance supports differential programming abstractions methods combination unrelated abstractions unequal combination abstractions mixins 
self private slot may accessed sending method shared part receiver allowing privileged communication related objects 
classless self enjoys benefits class encapsulation 
inheritance basic feature object oriented languages 
languages classes inheritance allow class obtain methods instance variables 
classes inheritance specify type compatibility 
years proposals languages prototypes 
languages include classes allow individual objects inherit delegate objects 
issues surrounding inheritance encapsulation need revisited designing language 
describes inheritance encapsulation mechanisms designed implemented prototype language self 
design generously supported national science foundation presidential young investigator ccr sun microsystems ibm apple computer cray laboratories tandem computers ncr texas instruments dec author address sun microsystems garcia avenue mountain view ca 
chambers ungar chang hlzle philosophy object parents treated shared parts object inheritance simple declarative way maximize possibilities sharing 
describes heretofore unpublished innovations prioritized multiple inheritance scheme unifies unordered ordered multiple inheritance object encapsulation model provides benefits class encapsulation language classes 
addition inheritance system supports directed undirected resends forward messages object ancestors unique sender path rule resolves ambiguities unrelated unordered parents dynamic inheritance allows object change parents run time effect significant behavioral changes due changes state 
benefits inheritance feel reasons include inheritance dynamically typed language self malleability reusability 
inheritance allows behavior common set objects factored single shared object superclass 
result behavior object set may changed single change shared object 
malleability facilitates program construction maintenance extension 
inheritance encourages reuse code data allowing programmer write new abstractions terms existing abstractions 
separating potentially reusable pieces code protocol implementing abstraction abstractions may able share code avoid duplicating programming effort 
style programming called differential programming powerful features object oriented systems 
programmers need write differences existing code defining new abstractions rest code may shared old abstractions new abstraction 
improvements abstraction automatically propagate abstraction shares behavior amplifying programmer power 
guiding principles design inheritance self common theme malleability reusability sharing object shared objects promoting malleability providing reusability 
inheritance just declarative way specifying objects shared objects 
guiding principle design inheritance self object parents treated shared subparts object 
languages static type systems may reasons include inheritance declare type hierarchies type checking 
concern inheritance code sharing mechanism 
alternate approach provide mechanism visit object set automatically perform change object set 
approach explored researchers 
inheritance encapsulation self view inheritance provides natural explanation aspects object oriented language 
rules message lookup easily derived simpler rules message lookup absence inheritance treating message receiver parents part receiver 
view explains basic ideas object oriented programming meaning self method 
inheritance self refer receiver object holding method 
inheritance inherited methods considered shared parts receiver method invoked part receiver object 
self refers receiver message inherited methods 
guiding principle inheritance system support sharing objects possible order maximize malleability reusability self programs 
unfortunately powerful inheritance schemes notoriously difficult effectively 
especially true automatically resolve ambiguities multiply inherited conflicting behavior confusing users unexpected correct behavior 
power inheritance balanced complexity potential confound intuition 
basic self object model object self contains set named slots slot containing self object 
method self object additionally contains code execute invoked method object viewed prototypical activation record slots arguments local variables 
object may allow assignments data slot associating assignment slot data slot 
new objects created cloning shallow copying pre existing objects 
complete description self syntax object model see 
absence inheritance message lookup self handled searching receiver slot matches message name evaluating contents matching slot generating error matching slot 
evaluating method executes associated code 
evaluating shared parents shared parts children chambers ungar chang hlzle simple data object just returns data object 
way self access state sending messages state access unified method invocation guarantees self code representation independent 
prioritized multiple inheritance self inheritance system supports multiple inheritance allowing object parent 
modern object oriented systems support form multiple inheritance offers significantly possibilities sharing simple single inheritance 
multiple inheritance introduces new complexity parents may define slots name 
ordered vs unordered multiple inheritance previous languages belong camps handling name clash problem 
languages new flavors clos rank object parents automatically resolve ambiguity favor slot inherited highest ranked parent :10.1.1.56.2990
call approach ordered inheritance 
ordering object parents works best object parent programming shared mixins designed override behavior side 
addition ordering languages linearize inheritance graph constructing total ordering classes consistent class local total ordering defined class followed direct superclasses order 
error results global total ordering consistent class local total ordering 
linearization drawbacks masks ambiguities unordered ancestors fails inheritance graphs deems inconsistent 
opposite approach resolving ambiguities object parents leave programmer 
languages trellis owl eiffel version treat object parents equals relative ordering treat ambiguities programming errors need explicitly resolved programmer 
call approach unordered inheritance 
works best combining relatively equal parents unrelated parents ambiguities need explicit resolution programmer 
artificially ordering equal parents mask ambiguities introducing subtle obscure errors programs 
orders superclasses invoke constructors destructors resolve virtual function calls 
inheritance encapsulation self prioritized parents approaches advantages disadvantages 
developed simple new approach combines ordered unordered multiple inheritance object 
object parents associated priority 
parents different priority levels ordered higher priority parents slots precedence lower priority parents slots names clash 
parents priority level unordered respect accesses slot definitions generate ambiguous message error 
priorities allow programmer best choice situation 
support prioritized multiple inheritance receiver parents treated shared subparts parent objects extended parents slots 
object ancestors define slots name object slot takes precedence ancestor slot implements standard rule object may override ancestors slots 
object parents define inherit slots name slot higher priority parent takes precedence parents priority unordered system generates error access slot 
ancestor slots included matter paths lead receiver ancestor object won generate ambiguities slots inherited paths 
rule handles cycles inheritance graph inheriting ancestor repeatedly cycle effect including just 
object parents parent slots normal data slots marked parent priority 
parent slot assignable object may change parent assigning slot 
feature called dynamic inheritance 
sender path rule self incorporates unique feature frequently resolves ambiguities inheriting equally unrelated abstractions 
method object sends message self expects find matching slot object descendants ancestors 
corresponds method invoking methods defined general abstraction ancestor refining abstraction descendant 
descendant object containing method uses unordered multiple inheritance combine object unrelated object happened define matching slot message ambiguous 
resolve ambiguities self inheritance rules additionally specify slots name defined equal priority priorities syntactically indicated adding asterisks slot name asterisks indicating lower priority asterisks footnote style asterisks movie ratings 
chambers ungar chang hlzle parents receiver parents ancestor descendant object containing method sending message sending method holder parent slot takes precedence parent slot 
sender path rule automatically resolves ambiguities unrelated abstractions sender message part abstraction 
ambiguity may resolved favor parent message send favor parent different message send depending location sending method holder 
dynamic behavior difficult program explicitly changing slot names inherited abstractions 
sender path rule unique self 
trellis owl obtain similar results cases statically binding calls private members 
approach inferior general sender path rule fails disambiguate public subclass visible protected members 
receiver sending method holder object path sender path rule sender path matching slot object path matching slot inheritance encapsulation self resends directed resends support differential programming method level object oriented languages include resend mechanism allows method written variation method overrides invoking overridden method part overriding method 
self method may continue lookup find matching slot resending method overriding prefixing name message reserved word resend followed period instance resend clone resends clone message finding clone slot method overrides 
resends may chained method doing resend call overridden method turn resend 
single method may number resends receiver resend self resend may different message name different arguments resending method 
self includes variant resend mechanism directs message lookup object parents 
directed resend normally explicitly resolve ambiguities object parents 
syntactically directed resends specified prefixing name message name sending method holder parent slots followed period analogous normal resends specified resend reserved word resend reserved mistaken name parent slot 
example clone resends clone message parent object referenced parent slot sending method holder 
directed resends general delegation mechanism directed parents sending method holder 
general delegation starting message lookup arbitrary object provided self special primitives 
flavors clos method combination rules handle case multiple classes define methods name 
standard method combination rules clos support call method similar self undirected resend call method allow programmer change name message 
standard method combination rules include combinations provided self example methods 
users may write method combination rules 
approach powerful flexible inheritance rules 
want self inheritance rules simple feel added expressiveness user definable method combination outweighed extra complexity language 
languages unordered inheritance ambiguities resolved statically 
eiffel forces programmers rename inherited features disambiguate resend 
trellis owl allows programmers select inherited definitions inherit clause 
trellis owl chambers ungar chang hlzle jects support mechanisms similar self directed resends 
languages support undirected resends cope problems directed resends may mask ambiguities caught undirected resends 
directed resends may need changed names object parents changed inheritance hierarchy changed 
directed resends may mixins method invoked resend differs depending objects mixed lower priority 
beta virtual functions invoked specific specific keyword inner invoke specific method 
mechanism product philosophy beta subclasses behavioral extensions superclasses specialize behavior superclasses defined points calls inner 
restrictive self resend mechanism 
complexities ordered multiple inheritance ordered multiple inheritance quite powerful supporting unequal multiple inheritance mixins 
programming techniques useful significant self code 
power ordered multiple inheritance hidden drawbacks effects ordering parents occasionally surprise novice expert self programmers alike 
ordered multiple inheritance mixins resends consequence higher priority parents implement mixins self mixin objects defined parents 
slots mixin ancestors matter general override slots lower priority parents matter specific 
example mixin inherited print default behavior traits object default behavior override specific behavior lower priority parent print programmer intends 
programmer learns leave mixins prevent mixing behavior expected 
potentially surprising effect ordering object parents chain resends may eventually backtrack call method defined parent descendant sending method holder ancestors descendant higher priority parent contain matching slots 
continuing example resend print invoke print desirable feature ordered multiple inheritance resends allows mixins invoke methods override defined lower priority cousins 
backtracking lower priority branches may surprise novice programmer situations especially lower priority branch child resending method 
inheritance encapsulation self considering altering self lookup rules search children ancestors children lower priority paths ancestors flavors clos similar rule linearizing classes 
effect declared priorities break ties parents left unordered inheritance graph 
problems described remedied change 
example print print resends print invoke print ordered multiple inheritance resends dynamic inheritance ordered multiple inheritance resends dynamic inheritance complex interactions 
dynamic inheritance normally affect message lookup assignable parents change message send handled 
may change resends chain resends 
problem system single inheritance unordered multiple inheritance message lookup resending method holder parents proceed upwards 
ordered multiple inheritance resend backtrack lower priority parent descendant resending method holder find matching slot 
parent receiver resending method holder changed resends difficult determine matching slot especially resending method holder longer ancestor receiver 
self current rules resends face dynamic inheritance complex explain implement 
tar baby self inheritance system illustrating potential dangers combining seemingly understood innocuous language features 
actively debating possible solutions 
receiver problems self priorities mixins low priority parent print print default traits object high priority parent chambers ungar chang hlzle inheritance rules partial order ancestors lookup rules inheritance define partial order receiver ancestors derived inheritance graph receiver sending method holder 
order defined rules object higher priority parents ancestors ordered object lower priority parents priorities 
object ordered left unordered previous rule paths inheritance graph receiver second object pass object children ancestors 
object ordered left unordered previous rules object lies sender path second sender path 
object lies sender path sending method holder ancestor receiver object lies path inheritance graph receiver sending method holder ancestor sending method holder 
partial order determine results message lookups 
normal lookups search nodes partial order ancestors contain slots match name message 
matching slot message understood 
single greatest ancestor containing matching slot ancestors earlier partial order considered greater partial order message ambiguous 
greatest ancestor containing matching slot result lookup contents matching slot evaluated result message 
resends similar normal lookups search ancestors partial order resending method holder resending method holder partial order spliced dynamic inheritance message understood 
directed resends resends parent slots resending method holder directed ignored constructing partial order 
rules described fail cope cycles inheritance graph 
appears possible accurately model self treatment cycles doing complicate rules longer useful understanding normal acyclic situation 
difficulty indicates need revisit treatment cycles making ancestors cycle mutually incomparable equivalently treating inheritance graph preorder ancestors cycle equal 
partial ordering different linearization flavors clos 
linearizations total orders performed entire system 
ordering partial real ambiguities resolved arbitrarily system conceptually constructed dynamically message send different receivers may different views ordering objects inheritance encapsulation self inheritance hierarchy different message send sites may different constructed partial orders sender path rule 
encapsulation inheritance self defined far support data abstraction information hiding 
object may send message object long matching slot referent evaluated 
unrestricted message passing prevents object maintaining local invariants data object invoke assignment slots freely 
addition unrestricted access slots object external interface 
lacking means distinguish object internal implementation external interface object clients may invoke operation intended internal creating unwanted coupling clients object implementation 
problems may serious individual exploratory programming fact unrestricted access may desirable hinder construction permanent reusable abstractions 
visibility declarations self allows individual slots declared public private slot declaration said unspecified 
public slots prefixed part external interface abstraction may invoked messages object 
private slots prefixed underscore invisible objects 
assignment slots declared simultaneously corresponding data slots declaration applies data slot assignment slot 
frequently programmer may want data slot publicly accessible protecting assignment slot 
specify mixed mode declarations self programmer may prefix data slot assignment slot declaration pair meaning public data slot private assignment slot meaning private data slot public assignment slot 
trellis owl support different visibility declarations data access assignment 
construct easy programmer limit access modification data appropriate 
unspecified slots prefix act public slots connotations self programmers different 
rapid development code may convenient ignore encapsulation issues abstractions mature visibility declarations just left making slots accessible 
code slots may annotated public private declarations better define external interfaces 
chambers ungar chang hlzle deliberately chosen terse slot syntax easy possible programmer add modify visibility declarations 
slots may remain unspecified implementor decided slot public access required cooperating abstraction slot generally considered part external interface abstraction 
distinction unspecified scope public scope unique feature self designed support exploratory production programming 
meaning privacy existing encapsulation systems object module classbased example smalltalk language provides object encapsulation instance variables meaning method may access instance variables self 
trellis owl eiffel object encapsulation instance variables methods 
unfortunately object encapsulation restrictive 
consider method add points create new point set slots 
new point self public method set module encapsulation hand allows code defined module class access private methods data object module enabling internal operations declared private 
example language uses module encapsulation 
module encapsulation minimum level encapsulation needed realistic programs protect private data operations outsiders unduly restricting internal access 
self language explicit modules classes support encapsulation 
guiding principle parents shared parts leads surprising logical solution method shared objects inherit method method access private slots object shares inherits 
shared ancestor object defining method forms module sorts methods may access private slots descendants 
consequently scope private slot large allow slots shouldn part public interface declared private 
complete rule private slot accesses private slot accessible sending method private slot objects ancestors receiver objects holding sending method private slot shared subparts receiver 
case adding points addition method parent words part new point private slots new point access permitted 
encapsulation self provides benefits class module encapsulation requiring existence explicit classes modules 
smalltalk trademark parcplace systems inheritance encapsulation self advantages direct consequence consistent treatment parents shared parts objects 
property rules object may gain access private slot child object private slot 
presence dynamic inheritance difficult statically determine objects may children object private slot preventing air tight proofs invariants implementation maintained 
practice problem continue investigate ways support static reasoning encapsulation presence dynamic inheritance 
self private slots visible children parents shared parts 
languages provide programmer choices 
trellis owl enable programmer hide members subclasses 
supports friend classes methods access class private members useful cooperating abstractions 
similarly eiffel allows members selectively exported list cooperating abstractions feature may overcome eiffel object encapsulation model cost verbosity 
inheritance confers benefits malleability reusability supporting sharing minimizing unexpected surprises 
accordingly self design interpreting object parents shared parts object 
self inheritance system introduces prioritized multiple inheritance simple way describe unordered multiple inheritance ordered multiple inheritance provides ways resolve ambiguities 
sender path rule automatically resolves ambiguities certainly caused accidental naming conflicts unrelated ancestors object 
directed resends resolve ambiguities object parents particular message resending access allowed access denied receiver sending method holder receiver object private slot sending method holder object private slot chambers ungar chang hlzle message object parents 
parent priorities resolve ambiguities object parents messages ranking object parents 
part mechanisms simple intuitive unfortunately combination ordered inheritance resends leads surprising behavior 
previous multiple inheritance schemes prioritized multiple inheritance supports wide range uses differential programming abstractions methods combination unrelated abstractions unequal combination abstractions mixins 
language supports programming techniques 
self incorporates encapsulation assist programmers identifying object public interface reasoning behavior module examining clients 
syntax carefully chosen encourage programmers concise treats slot independently separates access assignment allows slot visibility remain unspecified 
unspecified slots free programmer making public declarations engaged exploratory programming 
object interface defined annotated gradually visibility declarations 
smooth transition unique self 
considering parents shared parts led powerful encapsulation semantics 
method may access private slot method private slot considered part receiver 
definition allows slots private declared private 
self prototype language provide benefits module encapsulation 
lessons inheritance allows object places time ordered unordered multiple inheritance sufficient language need include classes gain benefits class encapsulation 
acknowledgments randy smith designed original self language second author prioritized multiple inheritance encapsulation continues useful sounding board new ideas 
peter deutsch provided inspiration pursuit self 
lee helped early design implementation prioritized multiple inheritance 
martin rinard provided valuable suggestions section inheritance partial order ancestors 

bobrow demichiel gabriel keene kiczales moon common lisp object system specification 
published sigplan notices 
inheritance encapsulation self 
bobrow kahn kiczales masinter stefik merging lisp object oriented programming 
oopsla conference proceedings 
published sigplan notices 

borning classes versus prototypes object oriented languages 
proceedings acm ieee fall joint computer conference 

chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation 
published sigplan notices 

chambers ungar lee efficient implementation self dynamically typed object oriented language prototypes 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

cunningham objects inheritance 
personal communication 

goldberg robson smalltalk language implementation 
addison wesley reading ma 

kristensen madsen mller pedersen nygaard beta programming language 
shriver wegner editors research directions object oriented programming mit press cambridge ma 

lalonde designing families data types exemplars 
acm transactions programming languages systems 

lalonde thomas pugh exemplar smalltalk 
oopsla conference proceedings 
published sigplan notices 

lee object storage inheritance self prototype objectoriented programming language 
engineer thesis stanford university 

lieberman prototypical objects implement shared behavior object oriented systems 
oopsla conference proceedings 
published sigplan notices 
chambers ungar chang hlzle 
madsen mller pedersen virtual classes powerful mechanism object oriented programming 
oopsla conference proceedings 
published sigplan notices 

meyer genericity versus inheritance 
oopsla conference proceedings 
published sigplan notices 

meyer eiffel version 
tr ei gi interactive software engineering ca 

moon object oriented programming flavors 
oopsla conference proceedings 
published sigplan notices 

schaffert cooper trellis object environment language manual version 
dec tr digital equipment hudson ma 

schaffert cooper kilian trellis owl 
oopsla conference proceedings 
published sigplan notices 

smith objects inheritance 
personal communication 

snyder overview 
stl hewlett packard laboratories palo alto ca 

snyder encapsulation inheritance object oriented programming languages 
oopsla conference proceedings 
published sigplan notices 

stein delegation inheritance 
oopsla conference proceedings 
published sigplan notices 

stroustrup programming language 
addison wesley reading ma 

stroustrup evolution 
usenix workshop proceedings 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

wegner dimensions object language design 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation international journal kluwer academic publishers manufactured netherlands organizing programs classes david ungar craig chambers bay wei chang urs hlzle self self stanford edu computer systems laboratory stanford university stanford california 
organizational functions carried classes accomplished simple natural way object inheritance classless languages need special mechanisms 
single model dividing types prototypes traits supports sharing behavior extending replacing representations 
natural extension dynamic object inheritance model behavioral modes 
object inheritance provide structured name spaces known objects 
classless languages express class encapsulation 
stylized uses object inheritance instantly recognizable idioms extend organizing principles cover wider range programs 
researchers proposed object models prototypes delegation classes static inheritance 
proposals concentrated explaining prototype languages allow flexible arrangements objects 
flexibility certainly desirable felt large prototype systems difficult manage lack organizational structure normally provided classes 
organizing large object oriented system requires capabilities 
foremost ability share implementation state instances data type related data types 
ability define strict interfaces data types hide protect implementation useful organizing generously supported national science foundation presidential young investigator ccr sun microsystems ibm apple computer cray laboratories tandem computers ncr texas instruments dec author address sun microsystems garcia avenue mountain view ca 
ungar chambers chang hlzle large systems 
ability global names refer data types categorize large name spaces structured parts easier browsing important managing huge number objects exist large object oriented system 
argue programs languages classes able accomplish tasks just programs class languages 
particular show organizational functions carried classes accomplished natural simple way classless languages organizational functions expressed objects inheritance need special mechanisms layer data structures additional flexibility prototype languages natural extension possibilities provided class systems exploiting additional flexibility need lead unstructured programs 
ideas lessons learned ways organize code self dynamically typed prototype language 
accordingly illustrate ideas examples self ideas applied classless languages providing similar inheritance models 
sharing programming object oriented language largely revolves specifying sharing relationships code shared instances data type code shared similar data types 
intra type sharing classes traits objects principal activity object programming defining new data types 
define simple data type programmer needs specify state behavior specific instance data type state behavior common shared instances type 
example way define simple polygon data type specify polygon instance contains list vertices polygons share operation draw 
typical class language class object defines set methods class variables shared instances class set instance variables specific instance 
example polygon data type implemented class polygon defines draw method specifies instances single instance variable named vertices polygon metaclass contain new method create new polygon instances organizing programs classes see 
initialize new instance list vertices polygon class define wrapper method named vertices just assigned argument vertices instance variable 
wrapper method required languages smalltalk limit access object instance variables object 
classless language polygon data type defined similarly 
prototypical polygon object created instance polygon type see 
object contains slots assignable data slot named vertices corresponding vertices assignment slot constant parent slot pointing object contains draw method copy method 
smalltalk trademark parcplace systems data slots self may assignable constant 
data slots assignable virtue associated assignment slot changes data slot contents invoked 
assignment slot name constructed appending colon data slot name 
parent slots indicated self syntax asterisks slot name 
parent slots figures indicated asterisks 
polygon class polygon class vertices list points vertices instance variables draw display methods draw draw copy draw display return copy receiver polygon traits parent vertices list points prototypical polygon vertices 
data types class language 
instance 
data types classless language 
data type prototype traits ungar chambers chang hlzle vertices slot prototype initialized convenient default list vertices list points defining triangle making usable serving programming example 
new polygons created sending copy message existing polygon prototypical polygon clones shallow copies receiver polygon copies internal vertex list 
prototype slots contain default values clones prototype automatically initialized values 
particular parent object shared new polygon providing common behavior polygons system 
call shared parent objects traits objects 
traits objects classless language provide sharing capability classes just class language making changes behavior instances type simple common behavior factored single shared object 
general data types may defined classless language dividing definition type objects prototypical instance type shared traits object 
prototype defines instance specific aspects type representation type traits object defines common aspects instances type 
special language features need added support traits objects traits object regular object shared instances type normal object inheritance 
traits objects regular objects may contain assignable data slots shared instances data type providing equivalent class variables 
classless languages gain descriptive power class languages dividing implementation data type separate objects 
data type concrete type instances data type created traits object initial prototype object defined 
type existing simply define reusable behavior shared types prototypical instance need defined 
alternately instance particular data type unique objects nil true false traits object need separated object 
traditional class languages implicitly specify shared behavior format class instances extra language mechanisms distinguish concrete singleton data types corresponding loss descriptive organizational power 
inter type sharing subclasses refinements object oriented languages inheritance support differential programming allowing new data types defined differences existing data types 
implementor new data type may specify type equivalent combination existing types possibly additions changes 
example filled polygon type identical polygon type organizing programs classes drawing filled polygons different drawing unfilled polygons filled polygon instance needs extra state hold fill pattern 
typical class languages class may defined subclass classes 
methods new class union methods superclasses possibly methods added changed instance variables new class union instance variables superclasses possibly instance variables added 
example filled polygons implemented class subclass polygon class see 
class overrides draw method specifies additional instance variable named instances vertices instance variable automatically provided subclass polygon 
initialize new instance fill pattern class define wrapper method named assigned argument instance variable 
filled polygons defined similarly language classes 
new filled polygon traits object created refinement child existing polygon traits object see 
traits object defines method 
complete definition new data type prototypical object created inherits filled polygon traits object 
object contain vertices data slot data slot plus corresponding assignment slots 
revise representation avoid unnecessary repetition vertices data slot subsection 
general new data type classless language may defined terms existing data types simply refining traits objects implementing existing data types new traits object child existing traits objects 
object inheritance specify refinement relationships needing extra language features 
representation sharing instance variable extension data parents defining data type extension pre existing data types frequently instance specific information existing data type combined extra information particular new data type construct instance specific information new data type 
example filled polygon instance needs polygon information list vertices plus new filled polygon specific information fill pattern 
ideally new data type wouldn need repeat instance specific information inherits existing data types share information enhance malleability resulting system changing data type representation causes data types inherit changed data type updated automatically 
ungar chambers chang hlzle polygon class class polygon instance filled polygon instance class vertices list points fill pattern class vertices list points vertices instance variables draw display methods draw fill display methods superclass instance variables assign variable draw parent vertices list points vertices fill pattern parent vertices list points draw copy draw display return copy receiver polygon traits prototypical polygon parent draw draw fill display filled polygon traits prototypical 
differential programming class language subclassing implicit representation extension 
draw filled polygon differential programming refining traits objects 
differential programming classless language 
vertices organizing programs classes class languages 
subclass defined automatically inherits instance variable lists superclasses instance variables specified subclass interpreted extensions superclasses instance variables 
feature illustrated example class extends instance variables polygon superclass instance variable see 
classless language multiple inheritance provide similar functionality data parents 
manually repeating data slot declarations prototypes parent data types done implementation filled polygons new prototype may share representation parent data types inheriting 
better way implement filled polygons define prototype child traits object polygon prototype object see 
new copy method defined traits object copy receiver filled polygon data parent polygon object instance parent vertices list points draw copy draw display return copy receiver polygon traits prototypical polygon vertices parent draw draw fill display filled polygon traits prototypical filled polygon copy copy data parent fill pattern representation extension data parents 
representation extension classless language 
ungar chambers chang hlzle filled polygon data type implemented objects containing instance fill pattern containing list vertices 
data parents explicitly implement representation extension mechanism implicit traditional class languages 
data parent objects parents data slots defined data parent transparently accessed defined receiver object defining explicit forwarding methods 
relying ability inherit state initialize new object parents computed values special language mechanisms needed concatenate representations 
problem class representation extension surfaces languages multiple inheritance 
superclasses define instance variables name subclass contain different instance variables superclasses instance variables merged shared instance variable subclass 
programming situations may correct keep different instance variables situations may necessary share single instance variable 
different class languages support multiple inheritance answer difficult question differently languages provide programmer option doing cost extra language complexity 
classless languages don face dilemma 
prototypical instance data type defined explicitly programmer complete control type representation 
new type contain version data slot prototype just contains data slot 
versions need maintained parent data type data parents may keep versions data slots name 
representation sharing class languages automatically extend representation subclass include superclasses instance variables 
automatic extension may desired 
example application want define rectangle data type subtype polygon data type 
representation rectangle numbers list vertices draw routine optimized special case 
class languages define rectangle class subclass polygon class rectangle class extended automatically polygon class vertices instance variable 
fix problem additional class instance variables defined common superclass polygon rectangle behavior common polygons moved concrete self includes message lookup rule sender path rule automatically disambiguates internal accesses data slots 
organizing programs classes polygon class class see 
creates problem code polygons longer access vertices instance variable polygon instances 
instances polygon subclasses know vertices instance variable 
possible solution define wrapper methods access polygon class vertices instance variable class rectangle class define method construct list vertices numeric instance variables 
avoid problems altering representation class subclass leaf classes concrete define instance variables 
nonleaf classes defining instance variables code written invoke wrapper methods explicit variable accesses 
programming style support reuse code allowing representation subclass different representation superclass 
sacrifice ability share representation information concatenating instance variables class ancestors require definition wrapper methods access instance variables 
programs awkward write modify 
prototype languages change representation refinements easily 
rectangle example prototypical rectangle object contains data slots parent slot pointing rectangle traits object doesn include data parent slots see 
including data parent prototypical polygon object implementation explicitly deciding base representation rectangles representation polygons 
rectangle traits object overrides polygon traits object draw method tuned drawing rectangles representation specific rectangles 
preserve compatibility polygons rectangle traits object defines vertices method construct list vertices numbers define rectangle 
particularly convenient self vertices message sent method polygon traits object access vertices data slot polygon receiver invoke vertices method rectangle receiver extra wrapper methods needed vertices data slot modifications invoking methods 
convenience afforded self uniform messages access state behavior adopted classless class languages achieve similar flexibility 
trellis owl class language accesses instance variables messages able change representation subclass overriding instance variables inherited superclasses methods defined subclass 
implementation data type classless language specify extend parent types representations forming new type representation including data parents refer parent types repre ungar chambers chang hlzle polygon class rectangle class polygon rectangle class access vertices variable methods superclass vertices inst vars assign vertices variable vertices vertices class vertices list points optimized draw methods superclass top left right bottom instance variables construct list inst vars draw vertices class top top coord left left coord right right coord bottom bottom coord methods access vertices variable vertices instance instance 
representation modification class language 
sentations filled polygon example rectangle example 
natural structured programming styles fostered classless languages 
class languages typically difficult time handling cases differ strict representation extension 
mentioned trellis owl notable exception 
languages powerful metaclass facilities clos able define metaclasses subclasses inherit instance variables superclasses solution complex probably verbose simple solution classless languages 
organizing programs classes dynamic behavior changes changing instance class dynamic inheritance behavior instance data type divided different modes behavior implementation state instance determining mode behavior 
example boxed polygon straight lines different drawing methods smoothed polygon splines 
situations distinction behavior may completely internal implementation data type reflecting different ways representing instance depending current past states object 
self reorganizing collection radically different representations depending access patterns insertion frequent indexing external interface collection remains unchanged 
common way capturing different behavioral modes include flag instance variable defining behavior mode testing flag vertices construct list coords parent vertices list points draw copy draw display return copy receiver polygon traits prototypical polygon representation modification data parents vertices parent draw draw rectangle efficiently rectangle traits prototypical rectangle parent right right left left bottom bottom top top 
representation modification classless language 
ungar chambers chang hlzle method depends behavior mode 
obscures code behavior mode merging behavior modes shared methods sprinkled tests case statements 
code analogous programs simulating object oriented method dispatching tests case statements determine type receiver message 
surprisingly flag tests behavior modes suffer problems flag tests receiver types hard add new behavior modes modifying lots code error prone write difficult understand particular mode code intermixed code behavior modes 
better way implementing behavior modes define mode special subtype general data type method dispatching inheritance eliminate flag tests 
example collection data type refined empty collection data type non empty collection data type inheritance relate types 
behavior mode instance may change state changes empty collection non empty element added 
correspond class language changing object class dynamically prototype language changing object parent dynamically 
class languages allow object change class face hard problems 
class object implicitly specifies representation happens object changes class specifies different representation 
object restricted change class identical representations wouldn allow different behavior modes different representations 
classless languages hand naturally extended handle dynamically changing behavior modes allowing object parents change run time object inherit different behavior mode traits objects depending state 
representations behavior modes differ data parents behavior mode specific data slots changing behavior mode require changing traits parent data parent simply having behavior mode data parent inherit directly behavior mode traits object changing just data parent 
self dynamic inheritance comes free basic object model 
data slot may parent slot data slot may corresponding assignment slot parent slot may assignable object parents changed simply assigning 
polygon example boxed draw method draw method defined polygon traits object smooth draw method treat vertices polygon spline control points 
polygon prototype parent slot assignable alternate boxed polygon traits object smooth polygon traits object see 
organizing programs classes behavior modes naturally implemented classless languages dynamic inheritance choose small set parents 
style programming compromise structure system contrary structure organization system clearer separating various modes behavior 
contrast close coupling class representation prevent class languages extended naturally handle behavior modes 
encapsulation languages user defined data types usually provide means data type hide attributes types 
encapsulation may specify external interface abstraction unaffected internal implementation changes improvements isolating dependencies data type clients 
encapsulation may protect local state implementation data type external alterations violate implementation invariant 
encapsulation improve structure organization system identifying public interfaces parent vertices list points copy return copy receiver polygon traits prototypical polygon vertices parent parent draw draw boxed polygon parent smooth draw draw smooth polygon polygon traits boxed polygon traits multiple behavior modes dynamic inheritance 
multiple behavior modes classless language 
ungar chambers chang hlzle remain unaffected implementation changes allowing implementation preserve internal invariants 
existing encapsulation models objects types 
languages object encapsulation smalltalk trellis owl eiffel accessible private members receiver 
languages type encapsulation private members instance type accessible methods defined type 
type encapsulation significantly flexible supporting binary methods need access private data arguments initialization methods need access initialize private state newly created objects 
receiver encapsulation situations require initialization methods wrapper methods external public interface type largely defeating purpose encapsulation place 
classless languages explicit classes types appear type encapsulation impossible support severely weakening encapsulation provided language 
surprisingly self visibility rules support form type encapsulation 
method may access private slots descendants ancestors method defined traits object may access private slots instances trait clones prototypes inheriting traits object just methods defined class may access private members instances class subclasses 
effect traits object defines type descendant objects considered members type 
example polygon example polygon prototype object vertices slot declared private slot 
prevent outside objects modifying polygon list vertices allow copy method defined polygon traits object send vertices method new copied polygon object new object descendant polygon traits object 
similarly assignment slots rectangle objects marked private prevent unwanted external modification 
class prototype languages may provide features encapsulation type encapsulation 
features dependent individual languages language includes classes 
naming categorizing system structured programs name known objects data types programmers find objects types 
objects eiffel includes selective export clauses allow object encapsulation extended type encapsulation particular members 
organizing programs classes object inheritance support tasks explicit support classes environment structures 
naming objects global variables name spaces programs need refer known objects different places system 
example data type may need referenced places order create new instances type define subtypes 
class languages associate unique name class may uttered program refer class normal instance objects explicit names 
classless language prototypes traits objects need globally accessible clone new objects define new refining traits objects objects implemented regular objects internal names 
classless languages normal object inheritance may define name space objects sole function provide names known objects 
name object name space simply name slot refers object 
object inherits name space object may refer known objects defined name space sending message accesses appropriate slot name space object 
scope name space set objects inherit 
designers eiffel encourage similar strategy handle shared possibly global constants different language mechanisms handle global names class names 
self approach just concise global variables state known objects may accessed messages defining wrapper functions messages sent self written self keyword omitted 
polygon really message sent self accesses data just concise global variable access 
lobby globals prototypes traits globals nil true false prototypes polygon rectangle list traits polygon rectangle list integer boolean lobby normal parent 
name spaces global 
ungar chambers chang hlzle illustrates name spaces part inheritance graph self system 
lobby object root inheritance graph objects inherit expressions typed self prompt evaluated lobby self 
prototypes parent object inherited objects provides succinct names prototypes standard data types 
traits object contains slots naming traits objects system typically name name data type prototypical instance 
example expression polygon names polygon prototype expression traits polygon names polygon traits object 
case prototypes name space object inherited lobby polygon yields contents polygon slot name space object second case sending traits lobby gives traits name space object sending polygon object gives polygon traits object 
organizing names categories large flat name spaces globals convenient programs awkward programmers 
systems provide features help organize name spaces smaller categories names break name spaces chunks 
example smalltalk environment supports level structure browsing classes dividing classes class categories 
classless systems name space objects similarly broken categories subdividing name spaces multiple parents 
example lobby globals prototypes traits prototypes shapes collections collections prototypes list array shapes prototypes polygon rectangle traits shapes collections system normal parent 
categorizing name spaces 
organizing programs classes prototypes name space object broken name space subobjects kind prototype 
original prototypes name space object contains parent slots referring name space subobjects name slot name category 
composite name spaces behave just flat name space point view program referring global objects categories parents original name space object 
example message polygon yield prototypical polygon name space broken categories 
name spaces structured multiple objects programmer may browse facilities available browsing objects slot names object structure locate objects interest understand organization system 
composite name spaces may number levels structure need balanced categories may 
single object may categorized different ways simultaneously simply defining slots multiple categories refer object 
flexibility natural consequence normal objects categorization 
global variables name spaces need broken programmers 
individual data types sort name space methods name spaces may large require categorization 
smalltalk environment provides level structure organizing methods class method categories 
classless languages techniques organizing large name space objects may applied organize large traits objects 
traits object may refer parent subobjects define category slots traits object 
categorizing traits objects 
fibonacci function fibonacci factorial function factorial addition subtraction division equals greater arithmetic functions comparing integer traits parent ungar chambers chang hlzle name parent slot name subobject category see 
composite traits objects extend number levels structure 
extensional vs intensional names categorization name space objects message passing access global objects object name sequence message sends needed reach 
call extensional name derived structure system 
languages internal class names hand intensional names classes explicit names programmer may related structure system 
similarly categorizing name spaces traits objects object structure extensional categorization browser data structures describe categorization classes methods intensional categorization 
extensional names number advantages intensional names extra language environment features needed support extensional names categories 
extensional names additional interpretations expressions evaluate named object may program access object paths reach named object may browser navigate object 
data structures defining intensional names programmers inconsistent global variable names programs 
example internal names classes data structures environment find class subclasses incorrect global variable referring class renamed inheritance hierarchy changed updating browser data structures 
inconsistency exist extensional names derived actual structure system 
restriction associated extensional names legal expressions language object name described object structure 
restriction problem system feel advantages extensional naming intensional naming important 
classes necessary structure objects provide traits objects provide behavior sharing facilities instances refinements encapsulation mechanisms provide type encapsulation needing explicit types classes structured name space objects provide names programs people browse 
traits objects name space objects organizing programs classes different objects stylized idiom instantly recognizable programmer 
languages classes structure programs languages classes 
additionally certain properties traditional class systems conspire hinder kinds useful structures handled naturally classless systems 
class implicitly extends superclasses representations hard define subclass alters representation defined superclasses 
classless languages define type representation explicitly prototype objects able implement representation extension representation alteration naturally 
representation object class system tied object class difficult implement dynamic behavior modes 
classless languages may dynamic inheritance structured way implement behavior modes natural extension static inheritance 
languages classes structure programs better languages classes 

bobrow demichiel gabriel keene kiczales moon common lisp object system specification 
published sigplan notices 

borning classes versus prototypes object oriented languages 
proceedings acm ieee fall joint computer conference 

chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation 
published sigplan notices 

chambers ungar lee efficient implementation self dynamically typed object oriented language prototypes 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

chambers ungar chang hlzle parents shared parts objects inheritance encapsulation self 
published lisp symbolic computation 

goldberg smalltalk interactive programming environment 
addison wesley reading ma 
ungar chambers chang hlzle 
goldberg robson smalltalk language implementation 
addison wesley reading ma 

lalonde designing families data types exemplars 
acm transactions programming languages systems 

lalonde thomas pugh exemplar smalltalk 
oopsla conference proceedings 
published sigplan notices 

lee object storage inheritance self prototype objectoriented programming language 
engineer thesis stanford university 

lieberman prototypical objects implement shared behavior object oriented systems 
oopsla conference proceedings 
published sigplan notices 

schaffert cooper trellis object environment language manual version 
dec tr digital equipment hudson ma 

schaffert cooper kilian trellis owl 
oopsla conference proceedings 
published sigplan notices 

stein delegation inheritance 
oopsla conference proceedings 
published sigplan notices 

stein lieberman ungar shared view sharing treaty orlando 
kim editors object oriented concepts applications databases addison wesley reading ma 

stroustrup programming language 
addison wesley reading ma 

stroustrup evolution 
usenix workshop proceedings 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 
published lisp symbolic computation international journal kluwer academic publishers manufactured netherlands efficient implementation self dynamically typed object oriented language prototypes craig chambers craig self stanford edu david ungar ungar self stanford edu lee parcplace com computer systems laboratory stanford university stanford california 
developed implemented techniques double performance dynamically typed object oriented languages 
self implementation runs twice fast fastest smalltalk implementation despite self lack classes explicit variables 
compensate absence classes system uses implementation level maps transparently group objects cloned prototype providing data type information eliminating apparent space overhead prototype systems 
compensate dynamic typing user defined control structures lack explicit variables system dynamically compiles multiple versions source method customized receiver map 
version type receiver fixed compiler statically bind inline messages sent self 
message splitting type prediction extract preserve static type information allowing compiler inline messages 
inlining dramatically improves performance eliminates need hard wire low level methods iftrue 
despite inlining optimizations system supports interactive programming environments 
system traverses internal dependency lists invalidate compiled methods affected programming change 
debugger reconstructs inlined stack frames debugging information making inlining invisible self programmer 
generously supported national science foundation presidential young investigator ccr ibm texas instruments ncr tandem computers apple computer sun microsystems 
author address sun microsystems garcia avenue mountain view ca 
author address parcplace systems plymouth street mountain view ca 
originally published oopsla conference proceedings sigplan notices 
chambers ungar lee self dynamically typed object oriented language inspired smalltalk language 
smalltalk self type declarations allowing programmers rapidly build modify systems interference date type declarations 
self provides blocks lexically scoped function objects akin closures self programmers may define control structures standard control structures iteration boolean selection constructed blocks 
smalltalk object oriented languages self classes 
prototype object model object defines object specific behavior inherits shared behavior parent objects 
smalltalk self accesses state solely sending messages special syntax accessing variable changing value 
features combined self multiple inheritance rules help keep programs concise malleable reusable 
straightforward implementation self prototype model consume storage space dynamically typed object oriented programming languages reliance message passing access state exact higher penalty execution time 
developed implemented techniques eliminate space time costs features 
addition implemented optimizations enable self run twice fast fastest smalltalk system 
techniques improve implementations class object oriented languages smalltalk flavors clos trellis owl eiffel 
describes implementation self running year 
review self object execution model section 
describe self object storage system section introducing maps segregation presenting object formats 
section explains byte coded representation source code 
section reviews compiler techniques originally published 
section explains optimizations coexist exploratory programming environment supports incremental recompilation source level debugging 
section compares performance self fastest available smalltalk system optimizing compiler 
proposes new performance metric object oriented language implementations 
conclude discussion open issues 
smalltalk trademark parcplace systems write smalltalk referring smalltalk system language 
illustrate unusual note respected authorities gone far require object oriented languages provide classes 
prototype models discussed 
efficient implementation self overview self self initially designed second author randall smith xerox parc 
subsequent design evolution implementation undertaken mid authors stanford university 
self objects consist named slots contains object 
slots may designated parent slots appending asterisks names 
objects may self source code associated case object called method similar procedure 
new object self existing object called prototype simply cloned message sent object called receiver message object searched slot name message 
matching slot contents object parent slots searched recursively self multiple inheritance rules disambiguate duplicate matching slots 
matching slot contents evaluated result returned result message send 
object code evaluates slot holding acts variable 
object code method prototype activation record 
evaluated method object clones fills self slot receiver message fills argument slots arguments message executes code 
self slot parent slot cloned activation record inherits receiver message send 
instance point example shown page sending message cartesian point object finds slot immediately 
contents slot integer evaluates associated code producing result message 
sent polar point object wouldn immediately 
object parents searched finding slot defined polar point traits object 
slot contains method computes coordinate rho theta coordinates 
method get cloned executed producing floating point result 
print message sent point object print slot defined point traits object 
method contained slot prints point object cartesian coordinates 
point represented cartesian coordinates messages access corresponding data slots point object 
print method works fine points represented polar coordinates messages find conversion methods defined polar point traits object compute correct values 
self supports assignments data slots associating assignment slot assignable data slot 
assignment slot contains assignment primitive object 
assignment primitive evaluated result message send stores argument associated data slot 
data slot chambers ungar lee corresponding assignment slot called constant read slot running program change value 
example parent slots constant slots 
object model allows parent slot assignable just slot simply defining corresponding assignment slot 
assignable parent slot permits object inheritance change fly result change object state 
example collection object may wish provide different behavior depending collection empty 
dynamic inheritance self linguistic innovations proven useful addition set object oriented programming techniques 
self objects 
bottom objects dimensional point objects left cartesian coordinates right polar coordinates 
represents assignment primitive operation invoked modify contents corresponding data slots 
cartesian point traits object immediate parent object shared cartesian point objects defines methods interpreting cartesian points terms polar coordinates polar point traits object polar point objects 
point traits object shared ancestor point objects defines general methods printing adding points regardless coordinate system 
object inherits top object defines general behavior copy objects 
parent rho theta rho theta parent rho theta rho theta print parent parent 
parent 
clone 
cartesian point polar point cartesian point traits polar point traits point traits general traits rho theta cos rho theta sin sqrt arctan print 
print 
print clone arg arg efficient implementation self self allows programmers define control structures blocks 
block contains method slot named value method special invoked sending value block method runs child lexically enclosing activation record normal method activation block method activation 
self slot rebound invoking block method inherited lexically enclosing method 
block methods may terminated non local return expression returns value caller block method caller non block method return statement kinds objects appear self object arrays byte arrays 
arrays contain single parent slot pointing parent object kind array contain variable number element objects 
names suggest object arrays contain elements arbitrary objects byte arrays contain integer objects range compact form 
primitive operations support fetching storing elements arrays determining size array cloning new array particular size 
self language described simple powerful resists efficient implementation 
self prototype object model object unique format behavior poses serious challenges economical storage objects 
self exclusion type declarations commitment message passing computation control structures variable accesses defeats existing compiler technology 
remainder describes responses challenges 
object storage system object storage system referred memory system represent objects self user world including objects 
creates new objects reclaims resources consumed inaccessible objects 
ideal memory system squeeze objects little memory possible high performance low cost 
earlier version self memory system documented 
memory system design exploits technology proven existing highperformance smalltalk systems 
minimal overhead common case self system represents object direct tagged pointers indirectly object table 
allocation garbage collection self system uses generation scavenging demographic feedback mediated augmented traditional mark sweep collector reclaim garbage 
subsections describe new techniques efficient object storage systems third subsection describes object formats detail 
chambers ungar lee maps naive implementation self prototype object model waste space 
self classes class objects contain format names locations instance variables methods superclass information instances instances contain values instance variables pointer shared class object 
self uses prototype model object define format behavior inheritance presumably implementation represent class format method inheritance information instance state information self object 
luckily regain storage efficiency classes self prototype object model 
self objects totally unique format behavior 
objects created cloning object modifying values assignable slots 
wholesale changes format inheritance object induced programmer accomplished invoking special primitives 
say prototype objects cloned identical way values assignable slots form clone family 
invented maps implementation technique efficiently represent members clone family 
self object storage system objects represented values assignable slots pointer object map map shared members clone family 
slot object map contains name slot slot parent slot offset object slot contents assignable slot slot contents constant slot non assignable parent slot 
object code method map stores pointer self byte code object representing source code method byte code objects described section 
maps immutable may freely shared objects clone family 
user changes format object value object constant slots map longer applies object 
case new map created changed object starting new clone family 
old map applies members original clone family 
implementation point view maps look classes achieve sorts space savings shared data 
maps totally transparent self language level simplifying language increasing expressive power allowing objects change formats 
addition map object conveys static properties self compiler 
section explains compiler exploit information optimize self code 
efficient implementation self example representations cartesian points parent 
maps slot require words name contents 
means point occupy words 
maps point object needs store contents assignable slots plus word point map 
constant slots format information factored map 
maps reduce words point words 
cartesian point traits object assignable slots data kept map 
parent rho theta rho theta 
parent parent parent rho theta rho theta 
parent offset offset 
cartesian point traits cartesian point traits map cartesian point traits cartesian points cartesian points cartesian point map maps maps chambers ungar lee segregation common operation memory system scan object meet criterion scavenger scans objects objects space 
reflective object modification programming primitives redirect object size changes moved 
browser may want scan objects contain particular object interests self user 
support functions self implementation designed rapid scanning object 
elements byte arrays represented packed bytes tagged words byte array elements may masquerade object 
smalltalk systems typically handle problem scanning heap object object word word 
object system checks see object contains object bytes 
object contains object system scan object matching iterating length object 
scanner proceeds object 
procedure avoids problems caused scanning byte arrays slows scan overhead parse object headers compute object lengths 
self system avoid problems associated scanning byte arrays degrading object scanning speed segregating byte arrays self objects 
generation scavenging memory space divided areas byte arrays objects 
scan object object area space needs scanned 
optimization speeds scans ways byte array objects scanned object headers parsed 
bytes area grows downward contains byte arrays object self memory space object area grows upward contains object confusing byte arrays efficient implementation self avoid slowing tight scanning loop explicit space check word space temporarily replaced sentinel matches scanning criterion 
scanner checks space matching word 
early measurements sun showed self system scanned memory rate approximately megabytes second 
measurements fastest smalltalk implementation machine indicated scanning speed non segregated memory spaces megabytes second 
kinds scans finding objects refer particular object scanner needs find objects contain matching 
system perform types searches nearly fast normal scan 
special tag header word object called mark word identify object 
scanner proceeds normally searching matching 
object containing simply scanning backwards object mark word converting mark address object 
object formats self memory space organized linear array aligned bit words 
word contains low order bit tag field interpret remaining bits information 
integer floating point number encodes number directly 
converting tagged integer immediate corresponding hardware representation requires shift instruction 
adding subtracting comparing tagged integers require conversion 
self objects map objects embed address object remember object table 
remaining tag format mark header word object required scanning scheme discussed previous subsection 
pointers virtual machine functions objects self heap represented raw machine addresses addresses bit half word aligned scavenger interpret immediates won try relocate 
object begins header words 
word mark word marking object 
mark contains scavenger immutable self hash primitive 
second word tagged object map 
self object assignable slots contains additional words represent contents 
array object contains length tagged self integer prevent interactions scavenging scanning elements bit tagged object bit untagged bytes padded nearest bit boundary 
chambers ungar lee representation map similar 
map objects mark map words 
map objects share map called map map 
map map map 
maps new space linked third words scavenge system traverses list finalize inaccessible maps 
fourth word map contains virtual machine address array function pointers functions perform format dependent operations objects maps 
maps objects slots fifth word specifies size object words 
sixth word indicates number slots object 
words contain change dependency link map described section 
words tagged integers 
map method ninth word byte code object representing method source code 
function pointer array exactly virtual function array generated compiler 
bit signed integer integer immediate virtual machine address top bits word aligned address self heap object bits ieee floating point number floating point immediate address scavenging fields hash field mark header word begins self heap object bytes bytes bytes object slots object array byte array map mark map mark map mark array length array length slot contents slot contents slot contents element element element efficient implementation self map includes word description object slots 
word points self string object representing name slot word describes type slot constant data slot assignable data slot assignment slot slot parent slot 
third word slot description contains contents slot constant slot offset object contents slot assignable data slot index corresponding data slot assignment slot 
words slot contain change dependency link slot described section 
self parents prioritized priority parent slot stored second word slot description 
map map map slot description array method data object map map mark function array link slot count object length link dependency map map mark function array link slot count object length link dependency map map mark function array link byte code slot description parent slot description slot description slot description constant slot data slot assignment slot description description description slot type slot name link dependency slot offset slot type slot name link dependency slot contents slot type slot name link dependency data slot index chambers ungar lee parent 
assignment slot assignment slot representation cartesian point objects 
objects left point instances containing values assignable data slots 
right object shared map cartesian points containing value constant parent slot offsets assignable slots 
slot name slot type mark map scavenging link function array link map dependency link slot dependency const 
parent slot slot contents object length slot count slot name slot type link slot dependency slot offset slot name slot type link slot dependency slot offset slot name slot type link slot dependency data slot index slot name slot type link slot dependency data slot index data slot data slot 
map map cart 
point traits mark map slot contents slot contents 
mark map slot contents slot contents 
efficient implementation self object formats determine total space cost represent clone family objects slots assignable words 
simple cartesian point example parent leading total space cost represent point objects words 
published accounts smalltalk systems indicate systems extra words object class pointer address hash code flags 
maps allow objects prototype system self represented just space efficiently objects class system smalltalk 
parser minimize parsing overhead textual self programs parsed entered system generating self level byte code objects smalltalk instances 
method object represents source code storing pre parsed byte code object method map cloned invocations method share byte code object 
byte code object contains byte array holding byte codes source object array holding message names object literals source 
byte code byte array represents single byte sized virtual machine instruction divided parts bit opcode bit object array index 
opcodes specified execution stack oriented interpreter actuality self compiler dynamically translates byte code objects native machine instructions just prior execution 
opcodes represent self programs self push self execution stack literal push literal value execution stack send send message popping receiver arguments execution stack pushing result self send send message self popping arguments execution stack pushing result super send send message self delegated parents popping arguments execution stack pushing result delegatee delegate message send named parent non local return execute non local return lexically enclosing method activation index extension extend index prepending index extension chambers ungar lee index opcodes index accompanying object array 
bit offset allows message names literals referred directly indices larger constructed extra index extension instructions 
self source code primitive operations invoked syntax send message message name begins underscore 
call primitive operation may optionally pass block invoked primitive fails appending message name 
invoked block passed error code identifying nature failure overflow divide zero incorrect argument type 
normal send byte codes represent primitive operation invocations simplifying byte codes facilitating extensions set available primitive operations 
contrast smalltalk primitives invoked number name may called method 
rest method executed primitive fails indication primitive failed 
code literals codes 
representation point print method 
top object prototype activation record containing placeholders local slots method case just self slot plus byte code object representing source code stored method map 
byte code object contains byte array byte codes separate object array constants message names source code 
method object byte code object prototype activation record self send send print literal send print self send send print byte code array literal array self print source code representation efficient implementation self byte codes needed express self programs fall classes base values literal self message sends non local return 
small number results simplicity elegance self language lack elaborate space saving encodings 
smalltalk defines larger set byte codes tuned minimize space maximize interpretation speed includes byte codes fetch store local instance class pool global variables shortcut byte codes common case operations loading constants nil true 
smalltalk systems special control flow byte codes implement common boolean messages iftrue iffalse smalltalk parser translates message sends conditional unconditional branch byte codes open coding argument blocks 
similarly message automatically translated identity comparison primitive operation byte code 
similar optimization included messages special byte codes 
executed byte codes directly invoke corresponding integer primitive operation receiver integer perform message send receiver isn integer 
special processing common messages may significantly improve performance existing smalltalk systems especially interpreted ones violate extensible flexible spirit smalltalk source code hard wired methods relegated documentation changes hard wired source code ignored system 
definitions iftrue iffalse types objects ignored 
receiver iftrue iffalse message evaluate true false object run time arguments block literals parse time receiver argument block literals parse time receiver block evaluate true false object run time 
worst aspect parser optimizations programmers select inappropriate control structures obtain performance hard wired message 
effect hard wired messages non object oriented built operators smalltalk 
self system incorporates tricks 
compilation techniques achieve better performance compromising language conceptual simplicity elegance preserving message passing model messages 
chambers ungar lee compiler self compiler significant part efficient implementation 
similar deutsch schiffman translator described implemented parcplace smalltalk system supports dynamic translation methods machine code transparently demand run time uses inline caching technique reduce cost non polymorphic message sends 
deutsch schiffman system fastest smalltalk system july runs times slower optimized combining traditional optimizing compiler technology techniques highperformance smalltalk systems critical new techniques developed self compiler achieved level performance twice fast deutsch schiffman system times slower optimized hope second generation system construction described section achieve better levels performance 
main obstacle generating efficient code smalltalk programs people noted little static type information available smalltalk source 
literal constants known class compile time detailed analysis types known 
type inferencing difficult smalltalk programs especially compiler inferred types improve performance 
smalltalk programmer willing sacrifice benefits exploratory programming environment annotate programs static type declarations designing adequate type system smalltalk hard flexible type system smaller performance improvement possible smaller reward including type declarations place 
self programs harder compile efficiently smalltalk programs 
problems missing static type information smalltalk compilers face faced self compiler 
addition variables self accessed sending messages explicitly identified variables source code byte codes 
classes self class techniques optimize smalltalk programs inline caching type inferencing static type checking directly self system 
compromising flexibility self programs static type system compromising execution speed programs interpreting dynamic type information developed compilation techniques automatically derive type information statically specified type systems 
combining extra information general purpose techniques optimizing compilers traditional languages fortran compiler achieves performance sacrificing interactive exploratory programming environment fast turnaround programming efficient implementation self changes complete source level debugging simple elegant programming language static type declarations 
subsections summarize new compilation techniques detailed discussion may 
customized compilation deutsch schiffman smalltalk system compiles single machine code method source code method 
classes may inherit method smalltalk compiler know exact class receiver 
self compiler hand compiles different machine code method type receiver runs source method 
advantage approach self compiler know type receiver message compile time generate better code specific versions method single general purpose compiled method 
call technique dynamic translation multiple methods single source code method customized compilation 
consider min method defined objects min arg method invoked integers floating point numbers strings objects compared systems self system waits min method invoked compiling code method 
systems compile method receiver argument types require generating code full message dispatch select right comparison routine 
self compiler generates separate compiled version receiver type customize version specific receiver type new type information optimize message 
trace operations self compiler evaluate expression min contains integer run time 
assuming time min sent integer compiler generate code version min customized integer receivers 
compiler builds internal flow graph pictured top page expensive operations bold face 
expensive operations eliminated inlining messages sent receivers known type described 
simplify discussion message sends access local slots executing activation record arguments assumed replaced local register accesses immediately 
chambers ungar lee message inlining compiler uses sources type information types source code literals type self gleaned customized compilation perform compile time message lookup message inlining 
type receiver message known compile time compiler perform message lookup compile time wait run time 
lookup successful absence dynamic inheritance programming errors compiler slot contains method compiler inline body method call site method short nonrecursive 
slot contains block value method compiler inline body block value method call site short 
inlining remaining uses block object compiler eliminate code create block run time 
slot constant data slot compiler replace message send value slot constant known compile time 
slot assignable data slot compiler replace message send code fetch contents slot load instruction 
slot assignment slot compiler replace message send code update contents slot store instruction 
inlining messages sent receivers known type compiler inlined messages equivalent smalltalk program variable assignments eliminating overhead self message passing access variables 
addition messages inlined smalltalk system remained full message sends 
send push self push arg send iftrue false push self push arg create closure create closure efficient implementation self example version min customized integers compiler statically look definition defined integers method simply calls integer primitive failure block omitted brevity 
compiler inlines method get flow graph overhead sending message eliminated calling procedure compare integers expensive 
section explains compiler open codes common primitive built operations increase performance 
primitive inlining primitive inlining viewed simpler form message inlining 
calls primitive operations normally implemented simple procedure call external function virtual machine 
high performance systems including smalltalk systems self compiler replaces calls certain common primitives integer arithmetic comparisons array accesses hard wired definitions 
significantly improves performance primitives implemented machine instructions overhead procedure call removed 
arguments side effect free primitive arithmetic comparison call push self push arg send iftrue false push self push arg create closure create closure push 
create closure chambers ungar lee primitive known compile time compiler calls primitive compile time replacing call primitive result primitive self form constant folding 
ongoing min example compiler inlines call definition integer primitive integer method hard wired compiler get flow graph compare branch sequence verifies argument call integer receiver known integer courtesy customization failure block created invoked 
argument integer integers compared true object false object returned result message 
message considered compiler iftrue false message 
arg integer common case receiver iftrue false true false result value message unknown compile time 
normally prevent inlining iftrue false message type receiver uniquely determined 
compiling multiple versions iftrue false message version statically known receiver type self compiler handle optimize case separately 
technique explained 
send iftrue false push self push arg create closure create closure push false arg push true cmp self arg branch push 
create closure send value efficient implementation self message splitting type information lost flow control merges happens just prior iftrue false message min example self compiler may elect split message merge separate messages preceding branches merge postponed split message 
compiler knows type receiver copies message perform compile time message lookup message inlining radically improve performance versions 
proper semantics original unsplit message preserved compiling real message send branches unknown receiver types 
message splitting thought extension customized compilation customizing individual messages particular control flow paths similar improvements run time performance 
min example self compiler split iftrue false message separate versions push self push arg create closure create closure push self push arg create closure create closure push self push arg create closure create closure push false arg push true cmp self arg blt push 
create closure send value send iftrue false send iftrue false send iftrue false chambers ungar lee compiler inline definition iftrue false true object iftrue false value 
false object iftrue false value 
get flow graph value messages inlined replaced bodies blocks 
receiver arguments inlined iftrue false messages need created run time compiler eliminates control flow graph producing flow graph top page 
assume failure block integer comparisons complex inline away 
compiler won inline value message value message result type unknown compile time 
receiver type iftrue false message unknown simple self compiler wouldn able inline message away 
subsection describes compiler uses known patterns usage predict receiver iftrue false message boolean optimizes message accordingly 
arg value push self push arg create closure create closure push self push arg create closure create closure push self push arg create closure create closure push false arg push true cmp self arg blt push 
create closure send value self value send iftrue false efficient implementation self type prediction type receiver message unknown compile time self compiler uses static type prediction generate better code common situations 
certain messages known compiler sent receivers certain types sent integers iftrue false sent true false 
compiler generates run time test expected type value receiver followed conditional branch sections code success branch type value receiver known compile time failure branch type unknown 
compiler uses message splitting techniques split predicted message compiling copy message branch 
compiler knows type receiver split message success branch inline version message away significantly improving performance common operations integer arithmetic boolean testing 
real message send executed case prediction fails preserving original message semantics possible receivers 
push self push arg create closure create closure push arg arg push self cmp self arg blt push 
create closure send value send iftrue false chambers ungar lee type prediction scheme requires little additional implementation message splitting inlining implemented 
better hard wiring iftrue iffalse messages parser compiler smalltalk systems achieves sorts performance improvements preserves message passing semantics language allows programmer modify definitions self methods including optimized type prediction 
apply type prediction remaining iftrue false message min example 
compiler inserts run time tests true object false object followed copies iftrue false message ll just look remaining unoptimized branch push 
create closure send value cmp true beq cmp false beq push self push arg create closure create closure push self push arg create closure create closure push self push arg create closure create closure send iftrue false send iftrue false send iftrue false efficient implementation self left branch receiver iftrue false known value true middle branch receiver known value false 
compiler inlines iftrue false messages plus corresponding value messages eliminates closure creations get final flow graph entire method push arg arg push self cmp self arg blt push 
create closure send value cmp true beq cmp false beq push self push arg create closure create closure send iftrue false chambers ungar lee common case minimum integers compiler executes simple compare branch sequences fast execution 
similar savings seen user calls min floating point numbers strings compiler customizes optimizes special versions receiver types 
case minimum values different types integer floating point number compilation techniques preserve message passing semantics original source code execute source code faithfully 
supporting programming environment self system supports high productivity programming environment 
environment requires rapid turn time programming changes complete source level debugging byte code level 
features coexist optimizing compiler techniques including message inlining 
subsections describe compiler maintained change dependency links support incremental recompilation compiled code affected programming changes compiler generated debugging information allows debugger reconstruct inlined stack frames debug time 
information appended compiled method object compiled code cache 
support incremental recompilation high productivity programming environment requires programming changes take effect fraction second 
accomplished self system selectively invalidating compiled methods affected programming change recompiling new definitions needed 
compiler maintains way change dependency links cached compiled method slots compiled method depends 
information compile code object formats contents non assignable slots precisely information stored maps 
confine dependency links maps 
links formed ways method compiled system creates dependency link map slot description containing method compiled code case definition method changes slot removed 
compiler inlines message system creates dependency link matching slot description method slot data slot assignment slot compiled code case definition inlined method changes slot removed 
efficient implementation self compiler searches parent object course compiletime lookup system creates dependency link slot description containing parent compiled code case parent pointer changes alters result lookup 
compiler searches object unsuccessfully matching slot compile time lookup system creates dependency link map object searched compiled code case matching slot added object 
rules ensure date compiled methods survive programming changes limiting invalidations methods affected change 
dependency link represented circular list connects slot description map dependent compiled methods 
system changes contents constant slot removes slot traverses corresponding dependency list header native machine code scavenging info 
dependency links scope descriptions byte code mappings caller scope slot locations compiled method address scope desc 
ptr 
byte code index scope description byte code mapping compiled method contains just instructions 
includes list offsets instructions embedded object scavenger modify compiled code referenced object moved 
compiled method includes dependency links support selective invalidation 
includes descriptions inlined method scopes find values local slots method display source level call stacks bidirectional mapping source level byte codes actual program counter values 
desc 
ptr 
chambers ungar lee root integer root map integer traits map true true map integer map min parent parent map dependency map dependency parent map dependency iftrue false map dependency false false map parent iftrue false map dependency traits compiled code integer min dependency lists case changed case parent change affects min lookups case min added case iftrue false changed dependency lists compiled min method customized integers 
gray line represents separate circularly linked dependency lists 
list connects slot description dependent compiled code objects 
map information linked compiled code changes compiled code min compiled methods depend changed information thrown away recompiled needed 
case min added case parent change affects min lookup case iftrue false changed case min added efficient implementation self invalidates compiled code objects list 
system adds slot similarly traverses map dependency list invalidates linked compiled code objects 
links removed lists method invalidated map garbage collected lists doubly linked speed removals 
selective invalidation complicated methods executing programming change requires invalidated 
methods really flushed executing code exist 
remain untouched optimized information longer correct 
solution implemented recompile executing methods immediately rebuild execution stack new compiled methods 
know procedure fast keep programming turn time short 
support source level debugging programming environment include source level debugger 
self debugger presents program execution state terms programmer execution model state byte code interpreter optimizations 
requires debugger able examine state compiled optimized self program construct view state virtual state terms byte coded execution model 
examining execution state complicated having methods virtual call stack inlined methods compiled method call stack allocating slots virtual methods registers stack locations compiled methods 
allow debugger reconstruct virtual call stack physical optimized call stack self compiler appends debugging information compiled method 
scope compiled initial method methods block methods inlined compiler outputs information describing scope place virtual call chain compiled method physical stack frame 
argument local slot scope compiler outputs value slot constant known compile time slots register stack location allocated hold value slot run time 
self compiler outputs debugging information support computing setting breakpoints 
information takes form bidirectional mapping program counter addresses byte code instructions particular scope 
complexity mapping byte codes may map program counter address messages get inlined optimized away program counter addresses may map byte code messages get split compiled place 
determine current state program byte code terms program counter address debugger finds latest program counter address mapping equal current program counter selects latest byte code mapped address algorithm returns byte code chambers ungar lee started completed program counter address 
execution stack uses mapping information find bottommost virtual stack frame physical stack frame display call stack program halted 
implemented facilities debugger current debugger displays virtual execution stack immediately continues execution primitive called 
mapping system designed support computing setting breakpoints anticipation process control primitives 
set breakpoint particular source level byte code debugger find program counter addresses associated byte code set breakpoints 
cases byte codes map program counter address single stepping byte code wouldn cause instructions executed debugger pretend execute instructions preserve illusion byte coded execution 
debugging information min method 
scope description points calling scope description black arrows block scope points lexically enclosing scope description gray arrows 
slot scope debugging information identifies slot compile time value run time location 
min example initial arguments run time locations registers case slot contents known statically compile time 
self arg value block 
min self arg value block arg iftrue self true self arg false iftrue self false self arg false value block self efficient implementation self performance comparison self implemented lines code lines assembler runs sun machine sun machine 
written lines self code including hierarchy collection objects recursive descent parser self prototype graphical user interface 
compare performance generation self implementation fast smalltalk implementation standard sun optimizing compiler sun workstation 
fastest smalltalk system currently available excluding graphics performance parcplace smalltalk virtual machine rated system includes techniques described earlier 
compare smalltalk self stanford integer benchmarks richards operating system simulation benchmark small benchmarks adapted smalltalk systems sumto 
sumto arg total arg index total total index 
total 
recurse 
recurse iffalse recurse 
recurse 
rewrote stanford integer benchmarks selfish programming style argument function receiver corresponding self method 
measurements rewritten benchmarks columns labeled self oo times parentheses mark benchmarks rewritten 
table presents actual running times benchmarks specified platform 
times milliseconds cpu time smalltalk times milliseconds real time real time measurements self system compiled program practically identical cpu time numbers comparisons measured performance parcplace smalltalk system systems valid 
originally published performance numbers improved significantly factor 
see 
dorado measure performance smalltalk implementations 
dorado defined performance early smalltalk implementation microcode ns xerox dorado fastest available smalltalk implementation 
chambers ungar lee raw running times smalltalk self self oo real ms cpu ms cpu ms cpu ms perm towers queens puzzle quick bubble tree richards entries table ratios running times benchmarks pair systems 
point view bigger numbers better columns smaller numbers better columns 
meaningful rows table probably rows median stanford integer benchmarks row richards benchmark 
relative performance self smalltalk smalltalk smalltalk self self oo self self oo perm towers queens puzzle quick bubble tree min median max richards self implementation outperforms smalltalk implementation benchmark cases self runs twice fast smalltalk 
surprisingly optimizing compiler better self compiler 
efficient implementation self difference performance results significantly poorer implementation self compiler standard compiler techniques register allocation peephole optimization 
difference may attributed robust semantics primitive operations self arithmetic operations check overflow array accesses check indices bounds method calls check stack overflow 
rest difference probably caused lack type information especially arguments assignable data slots 
deficiencies large extent second generation self system described section 
previous tables show performance object oriented systems improving dramatically 
new metric comparing performance systems propose millions messages second measure analogous millions instructions second mips measure processors 
number measures performance object oriented system executing messages 
compute rating system specific benchmark particular hardware platform divide number messages benchmark sends total running time 
define message sends invocations semantics include dispatch self includes slots receiver instance variable accesses invoke method excludes slots local method invocation local variable accesses access data 
computed rating generation self system richards benchmark sparc sun message executed ns 
efficiency object oriented system inversely proportional number instructions executed message sent 
cycle time sun ns giving self system cost message cycles 
sparc clocked cycles instruction accounting cache misses multicycle instructions give self system efficiency rating instructions message sent 
aware implementations dynamically typed object oriented languages approach level efficiency 
researchers attempted speed smalltalk systems adding type declarations smalltalk programs 
atkinson hurricane compiler compiles subset smalltalk annotated type declarations 
reports performance improvement factor hurricane compiler system sun initial self system achieves performance improvement deutsch schiffman system type declarations 
johnson ts typed smalltalk system type checks compiles smalltalk programs fully annotated type declarations 
reports performance improvement factor tektronix smalltalk interpreter tektronix 
bench chambers ungar lee mark identical benchmark reports execution time ms executed ms machine times faster machine 
system performance roughly comparable system performance system relies type declarations 
results suggest compilation techniques job extracting type information available systems programmer supplied type declarations 
self reached final state 
established feasibility rewards implementation techniques described remains 
second generation self system process reimplementing entire self system clean code simplify design include better compilation algorithms 
writing july completely rewritten object storage system unified run time compile time message lookup system 
implemented core second generation compiler compiles executes half self code 
new compiler performs type flow analysis determine types local slots compile time 
includes significantly powerful message splitting system 
initial message splitter described splits message type result previous message second generation message splitting system type information constructed type flow analysis especially types local slots 
message splitter may elect split messages message immediately merge point splitting messages intervene merge lost type information message needs type information 
goal combined type analyzer extended message splitter allow compiler split entire sections control flow graph especially loop bodies manipulate common data types 
sections types variables known compile time leading maximally inlined code run time type checks sections type information available compiler full message sends generated 
normal conditions optimized code executed method run fast possibly just fast program 
exceptional situations overflow occurs flow control transfer optimized section method preserves message passing semantics 
efficient implementation self second generation compiler performs data flow analysis common subexpression elimination code motion global register allocation instruction scheduling 
hope addition optimizations allow new self compiler compete high quality production optimizing compilers 
open issues method arguments largest sources unknown type information current compiler 
want extend second generation system customize methods types arguments addition receiver type 
extension provide compiler static type information arguments generate faster code 
benefits balanced costs verifying types arguments prologue method runtime 
compile time lookup strategy works nicely long parents get searched constant parents assignable compile time lookup fails message inlined 
second generation system provides limited support dynamically inherited methods adding types assignable parents traversed run time lookup customization information method method prologue tests values assignable parents addition type receiver 
plan investigate techniques optimize dynamically inherited methods 
message inliner needs better decisions inline method 
inliner information call site loop failure block help decide inline send wasting extra compile time compiled code space 
better job deciding method short inline reasonably counting byte codes fixed cut value algorithm 
implementation type prediction hard wires message names predicted type dynamic implementation dynamic profile information analysis self inheritance hierarchy produce better adapting results 
current implementation compiler speedy traditional batch optimizing compiler standards fast interactive programming environment 
compiler takes seconds compile optimize stanford integer benchmarks lines self code seconds compile optimize richards benchmark lines self code 
plan experiment strategies compiler executes quickly little optimization user waiting compiler queuing background jobs recompile unoptimized methods full optimization 
remains making sure techniques practical larger systems tested 
fully understand contributions need chambers ungar lee analyze relative performance gains associated space time costs techniques 
analysis performed part author forthcoming dissertation 
researchers attempted boost performance dynamically typed object oriented languages 
designers smalltalk hard wired definitions user level arithmetic control methods compiler preventing users changing overriding 
researchers added type declarations smalltalk hindering reuse modification code 
devised dynamic customized compilation static type prediction type flow analysis message splitting message inlining automatically extract preserve static type information 
measurements suggest system runs just fast smalltalk systems type declarations twice fast hard wired methods 
researchers seeking improve performance improve compilers compromising languages 
self novel features cost user execution time storage space 
virtual machine supports prototype object model just space similar class systems maps act implementation level classes reclaim efficiency classes implementation class semantics self user 
self messages access variables absolutely effect final performance self programs message sends get inlined away 
implementation reaches level sophistication performance information provided classes explicit variables redundant unnecessary 
languages run just fast class languages 
implementation introduces new techniques support programming environment 
segregation object byte arrays speeds scavenging scanning operations 
dependency lists reduce response time programming changes 
detailed debugging information maps execution state user source level execution model transparently undoing effects method inlining optimizations 
techniques restricted self apply dynamically typed object oriented languages smalltalk flavors clos 
techniques applied statically typed object oriented languages trellis owl 
example customization automatic inlining eliminate virtual function calls encouraging broader object oriented features programming styles reducing cost 
debugging information debugger hide inlining user just compiler generates debugging information reconstruct self virtual call stack 
efficient implementation self self practical implementation self twice fast dynamically typed purely object oriented language documented literature 
self compiler achieves level efficiency combining traditional optimizing compiler technology procedure inlining global register allocation specialized techniques developed high speed smalltalk systems dynamic translation inline caching new techniques customization message splitting type prediction bridge gap 
synergy old new results performance 
acknowledgments owe randy smith original designers self 
peter deutsch instructive discussions seminal ideas design implementation self 
bay wei chang implemented graphical self object browser contributed discussions self language implementation 

atkinson hurricane optimizing compiler smalltalk 
oopsla conference proceedings 
published sigplan notices 

ballard maier wirfs brock smalltalk dialect defining primitive methods 
oopsla conference proceedings 
published sigplan notices 

bobrow demichiel gabriel keene kiczales moon common lisp object system specification 
published sigplan notices 

borning classes versus prototypes object oriented languages 
proceedings acm ieee fall joint computer conference 

borning ingalls type declaration inference system smalltalk 
conference record ninth annual symposium foundations computer science 

chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation 
published sigplan notices 
chambers ungar lee 
chambers ungar iterative type analysis extended message splitting optimizing dynamically typed object oriented programs 
ceedings acm sigplan conference programming language design implementation 
published sigplan notices 
published lisp symbolic computation 

curtis type inferencing smalltalk 
personal communication 

deutsch dorado smalltalk implementation hardware architecture impact software architecture 
krasner editor smalltalk bits history words advice addison wesley reading ma 

deutsch richards benchmark 
personal communication 

deutsch schiffman efficient implementation smalltalk system 
proceedings th annual acm symposium principles programming languages 

goldberg robson smalltalk language implementation 
addison wesley reading ma 

hennessy stanford integer benchmarks 
personal communication 

johnson graver ts optimizing compiler smalltalk 
oopsla conference proceedings 
published sigplan notices 

lalonde thomas pugh exemplar smalltalk 
oopsla conference proceedings 
published sigplan notices 

lee object storage inheritance self prototype objectoriented programming language 
engineer thesis stanford university 

lieberman prototypical objects implement shared behavior object oriented systems 
oopsla conference proceedings 
published sigplan notices 

mccall smalltalk benchmarks 
krasner editor smalltalk bits history words advice addison wesley reading ma 

meyer genericity versus inheritance 
oopsla conference proceedings 
published sigplan notices 

moon object oriented programming flavors 
oopsla conference proceedings 
published sigplan notices 
efficient implementation self 
agrawal jackson cmos gate array implementation sparc architecture 
compcon conference proceedings 

parcplace systems 
parcplace newsletter winter 

schaffert cooper kilian trellis owl 
oopsla conference proceedings 
published sigplan notices 

steele jr lambda ultimate declarative 
ai memo mit artificial intelligence laboratory 

steele jr sussman lambda ultimate imperative 
ai memo mit artificial intelligence laboratory 

stein delegation inheritance 
oopsla conference proceedings 
published sigplan notices 

stroustrup programming language 
addison wesley reading ma 

suzuki inferring types smalltalk 
th annual acm symposium principles programming languages 

ungar design evaluation high performance smalltalk system 
ph thesis university california berkeley 
published mit press cambridge ma 

ungar jackson policies generation storage reclamation 
oopsla conference proceedings 
published sigplan notices 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

wegner dimensions object language design 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation international journal kluwer academic publishers manufactured netherlands iterative type analysis extended message splitting optimizing dynamically typed object oriented programs craig chambers craig self stanford edu david ungar ungar self stanford edu computer systems laboratory stanford university stanford california 
object oriented languages suffered poor performance caused frequent slow dynamically bound procedure calls 
best way speed procedure call compile dynamic binding object oriented procedure calls static receiver type information precludes inlining 
iterative type analysis extended message splitting new compilation techniques extract necessary type information possible hoist run time type tests loops 
system compiles code fly customized actual data types running program 
compiler constructs control flow graph annotated type information simultaneously performing type analysis inlining 
extended message splitting preserves type information lost control flow merge duplicating code merge place uses information 
iterative type analysis computes types variables loop repeatedly recompiling loop computed types reach fix point 
techniques enable self compiler split copy entire loop optimized common case types 
time self compiler generates code graph eliminated procedure calls type tests 
resulting machine code twice fast generated previous self compiler times faster parcplace systems smalltalk fastest commercially available dynamically typed object oriented language implementation nearly half speed optimized iterative type analysis extended message splitting cut performance penalty dynamically typed object oriented languages half 
generously supported national science foundation presidential young investigator ccr sun microsystems ibm apple computer tandem computers ncr texas instruments powell foundation dec author address sun microsystems garcia avenue mountain view ca 
originally published proceedings acm sigplan conference programming language design implementation sigplan notices 
chambers ungar dynamically typed object oriented languages historically slower run time performance traditional languages fortran 
measurements smalltalk systems personal computers workstations indicate performance performance optimized programs 
disparity performance caused largely relatively slow speed high frequency message passing lack static type information reduce costs 
describes new techniques extracting preserving static type information object oriented programs 
continues earlier self programming language 
self new dynamically typed object oriented language spirit smalltalk novel prototypes classes messages variables access state 
features self programs harder run efficiently dynamically typed objectoriented languages self programs send messages equivalent smalltalk programs 
part earlier built optimizing compiler self pioneered customization type prediction message splitting :10.1.1.56.2990
techniques provided compiler static type information previously available enabling aggressively inline away costly message sends sacrificing source code compatibility 
self compiler achieved performance optimized stanford integer benchmarks twice fastest smalltalk implementation machine 
performance clear improvement comparable systems competitive traditional languages 
narrow gap developed implemented iterative type analysis extended message splitting new self compiler 
techniques provide compiler accurate static type information enable preserve type information effectively 
techniques especially important optimizing loops lead version loop compiled version optimized different run time types 
techniques new self compiler produces code runs half fast optimized programs sacrificing dynamic typing overflow array bounds checking user defined control structures automatic garbage collection complete source level debugging optimized code 
traditional compilers divided front parser back optimizer code generator 
generate code dynamically typed object oriented language inserted new phase front smalltalk trademark parcplace systems iterative type analysis extended message splitting back 
phase performs type analysis method inlining message splitting construct control flow graph syntax trees source code 
traditional back performs data flow analysis global register allocation code generation control flow graph 
describes new intermediate phase compiler 
section briefly describes previously published techniques self compiler 
section presents type system describes type analysis works straight line code 
section extends type analysis handle merges control flow graph describes extended message splitting 
section completes type analysis message splitting describing iterative type analysis loops presents simple example compiling multiple versions loop 
section compares performance new self system optimized original self compiler versions new self compiler selected optimizations disabled 
section discusses related 
background new techniques build introduced previous self compiler including customization type prediction message splitting called local message splitting message inlining primitive inlining :10.1.1.56.2990
customized compilation 
existing compilers smalltalk object oriented languages compile single machine code method source code method 
classes may inherit method smalltalk compiler know exact class receiver 
self compiler hand compiles different machine code method type receiver runs source method 
advantage approach self compiler know type receiver message compile time 
type prediction 
name message sufficient predict type receiver 
example studies shown receiver message times small integer type 
compiler inserts type tests cases subsequent code may exploit type information common case 
message inlining 
type receiver known compiler optimize away message lookup performing compile time inline code invoked message 
primitive inlining 
self includes primitive operations integer addition 
compiling call external routine compiler directly compile primitives line 
primitives include type tests compiler type information may eliminate 
chambers ungar simple type analysis compute static type information necessary message inlining compiler builds mapping variable names types point program node control flow graph 
mapping computed nodes control flow graph assignment nodes runtime type test nodes message send nodes 
type variable describes information compiler knows current value variable differs standard notion data type traditional statically typed language 
type system type specifies non empty set values 
variable particular type guaranteed contain values type set values run time 
type specifies single value called value type acts compile time constant 
type specifies possible values provides information compiler called unknown type 
type specifies values instances class called class type provides compiler format inheritance information variables type traditional data type 
messages sent variable class type looked compile time inlined 
type specifies subrange values integer class type called integer subrange type 
compiler treats integer value types integer class type extreme forms integer subrange types 
type may specify set union types set difference types 
chart summarizes kinds types type system information provide compiler created 
self classes implementation introduces user transparent maps provide information space efficiency similar classes 
system class type set values share map 
types self compiler type name set description static information source value singleton set compile time constant literals constant slots true false type tests integer set sequential integer ranges arithmetic comparison subrange integer values primitives class set values format inheritance self results primitives class integer type tests unknown set values data slots message results level assignments union set union types union results primitive operations difference set difference types difference failed type tests iterative type analysis extended message splitting type analysis rules start method type mapping contains bindings receiver argument 
compiler generates customized versions source method see section class receiver known compile time version compiled 
receiver initially bound corresponding class type 
system doesn currently customize types arguments arguments initially bound unknown type 
simple node analysis declaration local variable adds new binding type mapping 
local variables self initialized compile time constants binding value type 
example variables implicitly initialized nil types start scopes nil value type 
node control flow graph may alter type bindings type information propagates node 
local assignment node simply changes binding assigned local variable type value assigned 
memory load node implementing instance variable access binds result temporary name unknown type compiler doesn know types instance variables 
compiler computes type result integer arithmetic nodes integer subrange analysis 
example rule determine result type integer addition node integer compare branch nodes integer subrange analysis 
adding binding result compare branch nodes alter type bindings arguments outgoing branch 
example rule alter argument type bindings compare node node integer addition primitive just add instruction 
type checking overflow checking performed nodes surrounding simple add instruction node 
lo hi lo hi lo lo hi hi maxint lo hi lo hi max lo lo hi lo min hi hi lo min hi hi max lo lo hi chambers ungar run time type test nodes similar compare branch nodes 
success branch test tested variable rebound type test failure branch variable rebound set difference incoming type tested type 
example rule alter argument type binding integer type test message send node type analysis type prediction inlining propagate types message send node compiler attempts inline message 
compiler looks type bound receiver message 
type class type subset class type value type integer subrange type compiler performs message lookup compiletime replaces message send node memory load node data slot access memory store node data slot assignment compile time constant node constant slot access body method method slot invocation 
method inlined new variables formals locals created added type mapping 
type result message send node inlined unknown type 
type receiver message unknown general single class type compiler tries predict type receiver name message predicting receiver message integer 
successfully predict type receiver compiler inserts run time type test message verify guess uses local message splitting compile versions predicted message 
primitive operation node type analysis range analysis inlining addition sending messages self programs may invoke primitive operations 
primitives include integer arithmetic array accesses object cloning basic graphics primitives 
primitive operations self robust types arguments checked primitive exceptional conditions overflow divide zero array access bounds checked 
call primitive optionally pass user defined failure block invoke case exceptional conditions occurs result failure block result primitive operation 
self programmer doesn provide explicit failure block default failure block passed simply calls standard error routine invoked 
control flow graph diagrams conditional branch nodes true outgoing branch left false outgoing branch right 
int 
type type int int iterative type analysis extended message splitting propagate types primitive operation node compiler attempts constant fold primitive 
primitive side effects arguments value types compile time constants compiler executes primitive compile time replaces primitive node compile time constant result 
compiler constant fold primitive arguments aren compile time constants 
example arguments integer comparison primitive integer subranges don overlap compiler execute comparison primitive compile time solely subrange information 
compiler constant fold primitive primitive small commonly integer arithmetic array accesses compiler inlines primitive replacing call primitive lower level nodes implement primitive 
example set nodes implement integer addition primitive analyzing nodes primitive compiler frequently able optimize away initial type tests overflow check 
example arguments integer arithmetic primitive integer subranges cause overflow compiler constant fold away initial type tests overflow check failure block leaving single add instruction node 
eliminates type overflow tests compiler comes closer closer goal eliminating performance disadvantage robust primitives 
tests eliminated failure block eliminated saves space importantly eliminates subsequent type tests result primitive 
type result inlined primitive computed propagating types nodes implementing primitive 
primitive isn arg int 
arg int 
sum arg arg overflow 
sum fail chambers ungar inlined compiler binds result primitive result type stored table primitive result types 
original self compiler constant fold inline primitive calls range analysis couldn comparison primitive solely integer subrange information eliminate overflow checks array bounds checks 
extended message splitting original new self compilers message splitting take advantage type information lost merges control flow graph see :10.1.1.56.2990
original self compiler able split messages immediately followed merge point call local message splitting 
new self compiler performs type analysis detect splitting opportunities matter code separates message send merge point call extended message splitting 
propagate type information merge node compiler constructs type mapping outgoing branch merge node type mappings incoming branches 
variable bound type incoming branches compiler merges incoming types 
incoming types outgoing type incoming type 
types different compiler constructs new merge type containing incoming types 
merge type similar union type compiler knows dilution type information caused merge control flow graph 
addition merge type records identities constituent types recording result set union merged types 
example integer class type merged unknown type forms merge type contains types distinct elements reducing just unknown type set union produce recall unknown type specifies possible values contains integer class type 
compiler takes advantage merge types propagating type information message send nodes 
type receiver message merge type containing types different classes compiler may elect split message intervening nodes back control flow graph merge point diluted type information 
splitting creates copies nodes graph send node back merge point receiver copy split message send node specific type allowing merge iterative type analysis extended message splitting nodes send msg send msg send msg merge merge extended splitting inline msg merge inline msg nodes nodes nodes nodes extended splitting inlining chambers ungar compiler normal message inlining copy message separately splitting original message send couldn inlined 
course uncontrolled extended message splitting lead large increase size graph compiled code size compile time 
limit increase code size compiler performs extended message splitting number copied nodes fixed threshold copies nodes common case branches control flow graph branches aren downstream failed primitives type tests 
type analysis loops performing type analysis loops presents problem 
loop head node kind merge node connecting loop back 
type bindings loop body depend type bindings loop bindings loop depend bindings 
creates circular dependency 
solution circularity construct type binding table loop head guaranteed compatible bindings computed loop 
done rebinding locals assigned loop general possible type unknown type 
call strategy pessimistic type analysis 
effectively disables new self compiler type analysis system including range analysis precisely points important performance inner loops program 
accurate type information compiler forced type prediction insert run time type tests check expected types local variables 
original self compiler performed type analysis local variables considered unknown type original self compiler thought pessimistic type analysis loops 
solution circularity traditional iterative data flow techniques determine type bindings loop doing inlining loop 
locals changed loop assigned results messages message aren inlined result types unknown locals bound unknown loop body nodes 
loop head iterative type analysis extended message splitting type loop body 
net effect standard iterative data flow analysis type information pessimistic type analysis assigned locals bound unknown type 
iterative type analysis solution adopted new self compiler called iterative type analysis 
compiler uses type bindings head loop compile body loop inlining constant folding possible types 
compares type bindings loop head loop 
compiler successfully compiled loop go compile parts program 
types different compiler forms appropriate merge types locals types different body loop general type bindings 
process iterates fixed point reached type bindings head loop compatible type bindings loop 
iterative type analysis computes type bindings changing control flow graph building control flow graph part computation type binding information 
standard data flow techniques hand operate fixed control flow graph 
iterative type analysis important dynamically typed object oriented languages transformations control flow graph inlining crucial compute accurate type information 
reach fixed point analysis quickly loop head merge nodes compute type binding table slightly different way normal merge nodes 
loop head loop tail produce different value subrange types class type particular local loop head merge node generalizes individual values enclosing class type forming normal merge type 
example initial type local value type type value type simple loop counter initialized zero loop head node local integer class type merge value types 
type automatically handles integer values counter iteration 
sacrifices precision type analysis saves great deal compile time hurt quality generated code 
iterative type analysis extended message splitting combination extended message splitting iterative type analysis possible compile multiple versions loops 
example consider loop head merges different types creates merge type 
compiler free split merged types apart inline message send inside body loop may split loop head node copies different type information 
loop head starts version loop compiled different type bindings 
chambers ungar compiler reaches loop tail node compiling body loop may multiple loop heads choose 
compiler tries find loop head compatible loop tail finds connects loop tail compatible loop head 
doesn find compatible loop head tries split loop tail node create copy loop tail compatible loop heads 
type local loop tail merge type loop heads contains binding subset merge type loop tail split generate loop tail contains matching subset copy connected matching loop head 
compiler attempts match split loop tail 
loop body loop head loop body loop head loop body loop head iteration compatible second iteration compatible iteration compatible iterative type analysis extended message splitting loop body inline msg inline msg send msg merge loop head loop head loop head loop head loop head loop body loop body loop body loop body inline msg inline msg extended splitting splitting loop tail extended splitting inlining chambers ungar loop tail doesn match available loop heads compiler give throw away existing versions loop recompile general type bindings 
compute type bindings head new loop compiler forms merge types bindings old loop heads remaining loop tail 
compatibility needs defined carefully avoid losing type information 
loop tail compatible matches loop head type binding type loop head contains type loop tail type loop head sacrifice class type information loop tail 
means unknown type loop head compatible class type loop tail 
type analysis iterate forming merge type unknown type class type loop head 
advantage body loop may split class type branch unknown type branch generate better code class type branch 
example consider simple self function sums integers argument sum declare init sum upto loop index sum sum increment sum 
sum 
return sum function uses user defined control structure upto iterate numbers 
inlining control structure primitive operations compiler produces sum loop sum sum 
goto loop sum 
compiler uses iterative type analysis compile body loop 
time sum initially bound value type initially bound value type 
messages get inlined integer addition primitives constant folded 
loop sum bound value type bound value type 
types incompatible constants assumed head loop type analysis iterates 
iterative type analysis extended message splitting second iteration starts generalizing types sum integer class type remember loop head merge nodes intentionally generalize merge types speed analysis 
completing iteration assuming result type failed primitive unknown type compiler generates control flow graph pictured 
type tests sum optimized away type information computed loop overflow check increment optimized away integer subrange analysis 
portion version loop gray box best expect compiler achieve 
unfortunately loop tail doesn match loop head sum int int type analysis iterate 
extended splitting denotes unknown type 
compiler eliminate remaining overflow check possible pass argument cause sum overflow largest possible integer 
int 
sum int int int sum sum overflow 
sum fail block return sum int sum merge sum int nodes int merge maxint int int sum int int maxint int sum loop head second iteration example chambers ungar compiler compile single version loop worked cases 
general version need run time type tests operations test integer arguments 
extended splitting compiler able eliminate run time type tests common case version loop generating exactly gray box version generated handle overflows non integer restart type analysis compiler builds new loop initialized types resulting previous iteration 
analysis proceeds similarly analyzing messages compiler splits integer receiver argument cases non integer cases splitting loop head process 
loop tail reached compiler splits tails connects corresponding loop head 
final control flow graph pictured combination extended splitting iterative type analysis allowed compiler optimize type tests common case 
compiler statically typed non object oriented language better 
actual workings compiler final control flow graph bit complex 
chosen simplify exposition ideas glossing messy details 
loop general sum int int int int 
int sum sum overflow 
sum fail block sum int sum maxint maxint loop head return loop head loop head int sum int int body sum int int sum int int final results example iterative type analysis extended message splitting discussion combining extended message splitting iterative type analysis beneficial effects 
compiler generate multiple versions loops version assuming different type bindings optimized different cases run time 
especially important isolate negative effects primitive failure normal case primitive success 
example loop performs arithmetic locals body get versions compiled knows locals integers second handles locals type 
version branch second version primitive fails primitives fail common case control remain fast integer version loop 
robustness integer arithmetic primitives implemented cost overflow check extra type tests needed failure happens 
extended message splitting may hoist type tests loop integer type test example 
initial types variables unknown method arguments body loop arithmetic variables compiler compile version loop unknown types embed type tests check integer values run time 
values turn integers second iteration loop branch version compiled assuming integer types locals 
control remain second version loop long locals remain integers overflow occurs 
version loop contains type tests second version contains 
normal case integer values type tests effectively hoisted integer version unknown version executed loop iteration 
extended message splitting iterative type analysis carefully designed automatically compile multiple versions loops 
additional implementation techniques special algorithms needed 
special treatment integers loop control variables needed special performed hoist type tests loops 
compiler just uses type prediction message splitting create preserve type information needed inline messages avoid type tests ends creating multiple versions loop 
course extended message splitting price compile time compiled code space 
compiling additional specialized version loops probably costly 
specialized version tends smaller general version loop type tests message sends failure blocks 
unfortunately current implementation compiles just versions loop plan minimizing number extra versions loops get compiled 
chambers ungar performance measurements measured performance compiled code compiled code size compile time 
measurements taken sun sparc workstation 
measurements summarized sets benchmarks stanford set integer benchmarks stanford benchmark suite 
benchmarks typically measure speed accessing iterating fixed length arrays integers 
stanford oo consists benchmarks rewritten objectoriented style 
changes chiefly redirect target messages benchmark object data structures manipulated benchmark array sorted underlying algorithms changed source level optimizations performed part rewrite 
puzzle benchmark rewritten included group anyway interest fairness 
small group micro benchmarks initial test suite implementing new techniques 
richards larger operating system simulation benchmark written lines self source code 
benchmarks run compilers optimized compiler supplied sunos invoked flag 
richards written version includes effect cfront preprocessor 
st refers parcplace systems version smalltalk implementation 
system uses dynamic compilation tied version distinction fastest commercially available smalltalk system 
old self refers measurements taken old self compiler early published :10.1.1.56.2990
tuned self system simpler compiler expression trees customization local splitting 
old self current production self system uses old self compiler 
system includes elaborate semantics message lookup blocks highly tuned year ago 
reasons performance worsened year numbers 
comparing performance new self compiler allows isolate effects improvements new compiler 
new self new self compiler described compiling multiple versions loops 
time writing part new compiler recomputes type information loop splitting loop head broken 
results observed past compiling multiple versions loops leads expect better performance part compiler repaired 
iterative type analysis extended message splitting rest section summarizes results 
raw data individual benchmarks appendices 
speed compiled code results table show new self compiler speed optimized stanford oo benchmarks 
performance times faster smalltalk twice fast current self version original compiler 
improvement original self compiler results better register allocation delay slot filling 
rest credited better type analysis especially inclusion range analysis 
originally published compiler implementation refined reliable 
execution performance faster reported speed optimized stanford stanford oo benchmarks compilation speed orders magnitude faster speed optimized compiler 
speed compiled code percentage optimized median min max small stanford stanford oo richards st old self old self new self compile time code size median ile max small stanford stanford oo puzzle richards compile time seconds cpu time optimized old self new self compiled code size kilobytes optimized old self new self chambers ungar richards benchmark worthy mention 
performance benchmarks traced problem single bottleneck call site runs task task queue 
call polymorphic different tasks handle run message differently invoking different procedure call defeats traditional optimization intended speed monomorphic call sites 
result overhead handle single call site total optimized time benchmark 
think nearly eliminate overhead generating call site specific inline cache handlers 
implemented probably increase performance richards benchmark 
compile time optimized compile time new compiler measurements suggest need 
benchmarks take seconds compile new compiler 
expect numbers reduced quite substantially old self compiler compiles programs second 
contrast compile takes seconds programs 
suspect new self compiler contains exponential algorithms data flow analysis register allocation hope improve 
code space new compiler generated code size times larger optimized programs 
difference blamed solely new techniques 
fact original self compiler uses space new self compiler 
substantial part space overhead attributed large inline caches dynamically bound procedure calls code handling primitive failures overflow checking array bounds checking 
done rudimentary conserving compiled code space expect able reduce space overhead 
current compiled code sizes large self applications executed amount code space 
example prototype graphical user interface supporting data structures written lines self source code compile megabyte machine code space currently store debugging relocation information compiled code 
addition self compiles code dynamically need maintain working set code memory unused compiled code flushed code cache recompiled needed 
final proof await larger self programs believe extra code space problem 
iterative type analysis extended message splitting related systems perform type analysis programs external type declarations 
ml statically typed function oriented language compiler able infer types procedures expressions static type checking virtually type declarations 
researchers attempted extend ml style type inference object oriented languages success 
approaches type systems describe object interface protocol object representation method dictionary 
higher level view object type best flexible polymorphic type checking provides little information optimizing compiler speed programs 
different approach taken typed smalltalk project 
type system sets classes variable type specifies possible object classes superclasses objects stored variable may 
number possible classes associated variable small messages sent variable inlined appropriate series run time type tests 
typed smalltalk system includes type inferencer infers types methods local variables user declared types instance variables class variables global variables primitives 
type inferencer interpretation program type domain expression type correct interpretation expression context current class hierarchy successful 
type method determined partially evaluating interpretation body method frequently completely determined simple type may contain unresolved constraints types method arguments 
constraints checked call site 
type checking type inference system powerful able type check existing smalltalk code 
suitable optimizing compilation types variables expressions describe possible representations method dictionaries 
unfortunately system take long time infer type expression arbitrarily large portion entire system evaluated compute type expression 
statically typed systems handles dynamically typed languages self typed smalltalk systems disallows smalltalk programs statically type checked 
type analysis system designed compute exact type information receivers messages possible handling uncertain unknown types gracefully 
operates limited amount initial type information just type receiver types constant slots attempts extract preserve new type information 
chambers ungar range analysis performed traditional optimizing compilers 
fortran compilers typically determine subrange information looking bounds specified loops 
approach doesn languages userdefined control structures self smalltalk scheme compiler fixed construct look loop index ranges 
approach computing range information primitive arithmetic comparison operators high level statements lets compiler perform range optimizations eliminating overflow checks array bounds checks context user defined control structures 
useful extension scheme record results comparisons non constant integer values case comparison performed 
help eliminate array bounds checks exact size array unknown index array length array bounds check eliminated 
current range analysis eliminate bounds checks integer subrange array index overlaps integer subrange array length 
hand ts compiler typed smalltalk able optimize bounds checks away uses simple theorem proving propagate results conditional expressions avoid repeated tests index array length 
implementation uses single premise time evaluate conditional expressions integer subrange types represent combined effects comparisons 
needed explore approaches 
ts compiler typed smalltalk performs optimization similar message splitting 
basic block multiple predecessors may copied predecessors rerouted copy conditional expression basic block may eliminated subset original block predecessors similar local message splitting 
extension proposed copy blocks block containing conditional predecessor enable eliminating conditional similarly extended message splitting 
techniques apply eliminating conditional expressions performed type analysis message inlining completed 
extended message splitting performed type analysis time part message inlining additionally split branches control flow graph information available type analysis time splitting available values order perform common subexpression elimination 
extended message splitting iterative type analysis may lead version loop compiled different initial type bindings 
similar optimization parallelizing fortran compilers called loops 
loop parallelized certain run time conditions held variable positive compiler insert run time iterative type analysis extended message splitting test desired conditions loop branch parallelized version sequential version 
type analysis similar partial evaluation 
type analysis form interpretation nodes control flow graph compile time types run time values 
system partially evaluates methods respect customized receiver type produce optimized version method specific receiver type 
method type analysis propagates type information similar manner partial evaluators propagate constant information 
compiler terminates input programs partial evaluators traditionally allowed go infinite loops input program contains infinite loop 
partial evaluators support complex descriptions input data generate specialized versions residual function calls propagate type information procedure calls self compiler performs interprocedural analysis type propagation non inlined message sends 
static type analysis feasible dynamically typed object oriented language self 
type analysis system computes static information eliminate costly message sends run time type tests 
value types serve propagate constants control flow graph integer subrange types computed arithmetic comparison primitives avoid overflow checks array bounds checks language built control structures 
iterative type analysis recompilation serves compute accurate type information variables loops 
type information lost control flow merges regained extended message splitting 
extended message splitting especially important loops may lead version loop generated 
accomplished simply allowing loop heads tails split nodes extra implementation effort needed implement multi version loops 
typically version loop common case types integers arrays contain type tests overflow checks 
version loop general contain type tests error checks executed unusual run time type conditions 
iterative type analysis integer subrange analysis extended message splitting powerful new techniques nearly doubled performance self compiler 
self runs nearly half speed optimized sacrificing dynamic typing user defined control structures automatic garbage collection source level debugging 
feel new level performance making dynamically typed object oriented languages practical hope widely accepted 
chambers ungar acknowledgments urs hlzle provided invaluable assistance collecting performance data 
bay wei chang helped improve visual appearance significantly 

aho sethi ullman compilers principles techniques tools 
addison wesley reading ma 

chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation 
published sigplan notices 

chambers ungar lee efficient implementation self dynamically typed object oriented language prototypes 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

deutsch schiffman efficient implementation smalltalk system 
proceedings th annual acm symposium principles programming languages 

goldberg robson smalltalk language implementation 
addison wesley reading ma 

graver type checking type inference object oriented programming languages 
ph thesis university illinois urbana champaign 

graver johnson type system smalltalk 
conference record th annual acm symposium principles programming languages 

heintz jr low level optimizations object oriented programming language 
master thesis university illinois urbana champaign 

hennessy stanford integer benchmarks 
personal communication 

johnson type checking smalltalk 
oopsla conference proceedings 
published sigplan notices 
iterative type analysis extended message splitting 
johnson graver ts optimizing compiler smalltalk 
oopsla conference proceedings 
published sigplan notices 

lee object storage inheritance self prototype objectoriented programming language 
engineer thesis stanford university 

mcconnell design rtl system 
master thesis university illinois urbana champaign 

milner tofte harper definition standard ml 
mit press cambridge ma 

mitchell personal communication 

ohori buneman static type inference parametric classes 
oopsla conference proceedings 
published sigplan notices 

padua wolfe advanced compiler optimizations supercomputers 
communications acm 

rees clinger editors 
revised report algorithmic language scheme 

sestoft sndergaard bibliography partial evaluation 
sigplan notices 

ungar design evaluation high performance smalltalk system 
ph thesis university california berkeley 
published mit press cambridge ma 

ungar performance comparison self smalltalk implementations 
unpublished manuscript 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

wand complete type inference simple objects 
proceedings nd ieee symposium logic computer science 

wand type inference record concatenation multiple inheritance 
proceedings th ieee symposium logic computer science 
chambers ungar appendix performance data compiled code speed percentage optimized benchmark st old self old self new self stanford perm perm oo towers towers oo queens queens oo oo puzzle quick quick oo bubble bubble oo tree tree oo small sieve sumto richards originally published compiler implementation refined 
execution performance faster reported speed optimized stanford stanford oo benchmarks 
empty entries performance tables indicate unavailable information 
see section discussion performance results richards 
iterative type analysis extended message splitting appendix code space compiled code size kilobytes benchmark optimized old self new self stanford perm perm oo towers towers oo queens queens oo oo puzzle quick quick oo bubble bubble oo tree tree small sieve sumto richards chambers ungar appendix compile time compile time seconds cpu time benchmark optimized old self new self stanford perm perm oo towers towers oo queens queens oo oo puzzle quick quick oo bubble bubble oo tree tree oo small sieve sumto richards originally published compiler implementation refined 
compilation speed orders magnitude faster speed optimized compiler 
experiencing self objects object artificial reality bay wei chang bay self stanford edu david ungar ungar self stanford edu computer systems laboratory stanford university stanford california programming hard 
programming forces programmer deal things grasp complex relationships elements program manage dependencies elements 
programming taxes programmer short term memory 
self project strives programmer job easier combining language design efficient implementation user interface tightly coupled language 
self dynamically typed prototype objectoriented language 
describes approach taken design user interface self 
detailed description language implementation 
prototype user interface self provides browsing inspecting self objects combining object model artificial reality 
emphasizing problem domain objects views objects discards layer indirection conventional window user interfaces 
placing objects artificial reality reduces cognitive load programmer exploiting programmer internalized knowledge objects physical world behave 
goal user interface invisible self objects self world real 
generously supported national science foundation graduate fellowship national science foundation presidential young investigator ccr sun microsystems ibm apple computer cray laboratories tandem computers ncr texas instruments dec author address sun microsystems garcia avenue mountain view ca 
chang ungar section provides prototype self user interface brief tour aspects 
section discusses power artificial reality programming setting adoption artificial reality self interface works programmer 
section examines benefits object model section follows look personality self objects 
conclude observations lessons learned 
self artificial reality self artificial reality consists self objects populating empty space 
shows typical self object 
object box boxes glued face grabbed mouse thought virtual hand moved world screen 
object keeps programmer dragged floating front objects world 
object represents prototypical circle self center origin unit radius 
self objects circle object consists set slots wide boxes face object 
slot name words face contents 
contents slot just self object represented box face slot indicating containment 
circle object slots slots hold center point radius circle slots assignment slots permit contents center radius slots changed final slot parent slot indicated asterisk name slot holds object circle inherits 

self object 
experiencing self objects self objects names 
known objects circle prototype object name path slots root object known lobby 
sending message circle lobby returns prototypical circle object 
objects integers points know print named accordingly 
current self user interface browser inspector objects encountered known named 
bulk objects executing program name created dynamically typically reached path starting lobby 
name object appears top object 
name object contained slot contents box slot face 
examine contents circle center slot programmer grabs contents box clicking mouse 
contents slot point object appears screen connected arrow contents box 
cause contents box detach smoothly grow full object contents box just condensed form object 
simply special case grabbing object programmer move wishes releasing mouse button 
moves connecting arrows stretch rubber bands 
movement names self part object insofar programmer name object 
language semantics separate provision objects name self artificial reality infers names uses 

objects connected arrows 
chang ungar objects arrows occurs high frame rate provide illusion reality 
studying workings objects program programmer typically sprout objects screen 
objects longer examined removed screen currently clicking different mouse button 
resulting world number objects screen intrinsic relations shown arrows connecting objects extrinsic information shown objects placement screen relative 
shows part simple shape hierarchy 
prototypical circle inherits circle traits object holds shared behavior circles similar way circle class class language hold behavior instances circles 
circle traits object turn inherits shape traits object parent triangle traits object 
circle traits triangle traits slot containing shape traits object shape traits object screen 
shape traits object system object exists self artificial reality 
programmer parent slot triangle traits shape traits object screen arrow connects slot existing shape traits object virtual hand mouse cursor moves object integer object zero provides example 
referenced slots point object places system 
way self artificial reality maintains identity objects 
self artificial reality objects world certain personality traits contribute programmer interaction system 
closer examination traits follows sections 
artificial reality self interface user interface means programmer accesses manipulates objects program 
traditional interfaces tool framework programmer interactions objects system 
interface clearly visible doubt programmer interacting interface translates actions access objects behalf 
interface barrier programmer objects system 
applying artificial reality paradigm user interface helps minimize barrier 
objects artificial reality behave laws artificial world 
laws similar physical world user able intuition understand object behavior 
ark example objects mass velocity obey physical laws gravity inertia 
frames second medium sized objects gx equipped sun sparcstation 
experiencing self objects tossing ark object causes continue moving original direction indefinitely 
friction ark world object slow come 
behavior easy user understand sort behavior objects everyday world user interacting birth 
user accepts artificial world screen behaves large part real world come forget dealing user interface 
new tasks environment learned quickly naturally 
artificial reality powerful provides environment behavior easy learn understand removes layer indirection user objects system eliminating conceptual overhead needed operate interface 
important programming environment concern learnability 
multiple slots may point object 
chang ungar novice user usability experienced programmer 
programmer need spend attention operating user interface artificial reality physical world metaphor skills internalized part lifelong interaction physical world 
ideal notion interface vanish completely replaced portal user enters artificial world populated objects hand 
personality artificial reality determined laws world objects world obey 
self artificial reality relies physical world metaphor 
aspects personality self artificial reality space 
initially world screen contains single object typically lobby object 
lobby programmer navigate wellknown object system simply objects slots paths 
objects placed programmer space world 
solidity 
dimensional look boxes illuminated screen source light objects solid 
moving object moves actual object screen outline contributes maintaining solidity objects 
achieving high frame rate reinforces solidity avoiding discontinuous jumps 
physical interaction 
programmer manipulates objects grabbing pick 
slot performed grabbing contents box slot 
objects artificial world cursor thought artificial hand space extension programmer real world hand 
limited depth 
self artificial reality true third dimension objects may overlap 
objects dimensional effect world limited depth objects float front near surface 
picking object brings closest programmer result collisions objects objects moved front objects 
investigating ways true depth shadows collisions self artificial reality 
physical metaphor self artificial reality permits programmer think self objects additional weight dealing obtrusive interface 
concentrating maintaining illusion artificial reality attempts interface invisible 
experiencing self objects object interfaces conventional interfaces treat problem domain objects objects hidden system accessible tools user interface 
tools provide views problem domain objects tool showing aspect objects system 
examples smalltalk trellis environments 
smalltalk uses different tools different activities browsers show classes methods defined classes inspectors show instance variables objects 
style user interface called tool activity 
activity model emphasizes manipulation user interface tools provide views problem domain objects 
contrast object model treats problem domain objects objects manipulated user interface 
problem domain objects concrete interface programmer identifies objects user interface representation 
identification occurs activity oriented interfaces tool view different objects lifetime 
tools concrete little programmer tools problem domain objects programmer concerned 
identifying problem domain objects representation interface affects programmer mental model objects system 
identification complete programmer come think objects depicted screen actual objects represent behavior interface contribute programmer mental model objects language 
critical behavior objects interface closely follow semantics language 
behavior inconsistent language semantics inevitably confuse programmer conversely careful design supporting language model interface powerful tool aiding programmer understanding working language 
examples object interfaces include star interface macintosh finder 
macintosh finder represents directories folders 
opening folder yields window may contain folders icons representing files 
folders file icons directly interface may moved window moved folder 
user identifies files icons moving icon folder means user moving file directory place notion directory concrete image folders containing files 
object model breaks places finder 
window representing open folder share full identification folder really view folder 
folder window folder icon exist screen different places time window open folder moved folder folder icon 
object model finder applies icons 
chang ungar environment adopts object model elements programs represented hierarchical windows 
hierarchical windows matched block structure languages designed support clearly expressing containment relations 
addition explicit goal environment create identification elements program individual windows example referencing element screen result new window object programmer attention directed element screen 
environment big step directing programmer attention away interface objects program 
want go farther 
object model self interface self interface completely notion windows imply view favor artificial concrete reality 
object model context artificial reality allows self interface forge stronger identification interface objects problem domain objects 
attempts programmer thinking object interface problem domain object simply representing 
result programmer mental model language heavily influenced model interface 
interface mental model explicit concrete programmer able think interact objects naturally 
consequence integrating artificial reality object model elimination separate notion tools user interface 
tools indirect mechanisms manipulating examining objects object approach coupled artificial reality provide natural intuitive interaction objects transfers powers objects 
objects interface nature supply functionality programmer need simply consistent concept manipulating real objects real artificial world 
design interface shifts focus functionality tools personality objects 
objects artificial world reflect personality objects self language identity 
self object definite identity independent state changes 
artificial world solid object single existence 
multiple object direct programmer object screen creating multiple interface objects corresponding problem domain object 
known self objects globally accessible path lobby 
object screen reflects characteristic displaying path name tag 
experiencing self objects composition 
self object composed set named slots referring objects 
artificial world object large box smaller boxes glued face 
smaller box name slot name smaller box slot contents glued 
uniformity 
self language object smallest integer 
things self artificial world share basic likeness look feel 
connectivity 
self programs networks interconnected objects 
artificial world relationships objects indicated stretching arrows links objects 
objects connected object slots 
connections objects complex web relationships demands arrows pointing object different slot arrows pointing object originating slots object 
arrows stretch remain connected objects move connections maintained programmer explicitly decides remove view 
referral 
understand object role program may necessary find object children objects refer 
understand slot role program may necessary find slots name 
object artificial world show programmer list objects slots list objects inherit 
slot world likewise show programmer objects containing 
current implementation functions uses buttons object slots 
shows buttons 
hope devise natural interaction object referrals 

object buttons 
chang ungar interior vs exterior 
information objects considered part exterior object information part interior 
self provides notion visibility slots encapsulation scheme public slots accessible private slots accessed object descendants 
current self user interface provides access interior objects displaying slots public private object 
define means examine exterior object public slots 
structure vs behavior 
structure hierarchies objects self provided inheritance objects parent slots 
self artificial world reflects structural outlook box arrows approach inheritance 
behaviorally parents object part object 
self valid model language structural model 
studying ways provide behavioral model objects alternative means presenting inherited slots artificial world 
intensional vs extensional structure 
extensional structure objects considered system determined relationships virtue slots 
relationships explicit arrows link objects object slot 
positions problem domain objects screen semantic meaning programmer moves objects places 
positions devoid information program usually full information programmer example positional information indicate inheritance relationships group objects 
layout objects screen intensional 
investigating technique call poses acts snapshot capturing layout objects screen pose object 
activating pose object time instructs objects part pose move locations objects get way effectively reconstructing layout captured earlier 
rooms user move recapture certain layout objects world 
rooms objects maintain identity places 
pose object include actual objects specification activated director 
poses promise provide convenience functionality maintaining layouts objects adhering artificial reality object model user interface 
self user interface encourages programmer think objects artificial world real 
attempts strip away conceptual overhead user interface replacing tools objects interface arti experiencing self objects reality 
result programmer brought closer self objects working restricted viewing objects manipulating indirectly programmer enters self artificial world experience self objects directly 
self interface described supports browsing system inspecting objects 
continue follow principles laid prototype expand interface complete programming environment 
principles observations particularly important object artificial reality 
illusion artificial reality carefully maintained times 
lapse illusion sunspot disrupts communication size indicate 
small lapse destroy illusion user consciously aware interface divert attention problem hand 
second emphasis placed personality objects system reap full benefits object interface 
discarding tools views giving responsibility objects user interface places emphasis problem domain objects interface level objects programmer think objects tools 
acknowledgments craig chambers urs hlzle contributed ideas discussions regarding nature functionality appearance self user interface 
randall smith reality deserve credit setting feet path objectbased physical metaphor 

chambers ungar customization optimizing compiler technology self dynamically typed object oriented programming language 
proceedings sigplan conference programming language design implementation 
published sigplan notices 

chambers ungar lee efficient implementation self dynamically typed object oriented language prototypes 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

goldberg smalltalk interactive programming environment 
addison wesley reading ma 
chang ungar 
magnusson environment direct interaction abstractions 
ecoop proceedings 
published lecture notes computer science springer verlag new york ny 

henderson card rooms multiple virtual workspaces reduce space contention window graphical user interface 
acm transactions graphics 

lee object storage inheritance self prototype objectoriented programming language 
engineer thesis stanford university 

brien kilian trellis programming environment 
oopsla conference proceedings 
published sigplan notices 

smith kimball designing star user interface 
byte 

smith alternate reality kit animated environment creating interactive simulations 
proceedings ieee computer society workshop visual languages 

smith experiences alternate reality kit example tension magic 
proceedings chi gi conference 

ungar smith self power simplicity 
oopsla conference proceedings 
published sigplan notices 
published lisp symbolic computation 

williams apple macintosh computer 
byte 
