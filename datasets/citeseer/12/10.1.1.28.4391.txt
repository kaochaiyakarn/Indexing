helsinki university technology department computer science digital systems laboratory fin espoo finland helsinki university technology digital systems laboratory series research reports issn may isbn model checking branching time temporal logic ctl digital systems laboratory department computer science helsinki university technology finland helsinki university technology digital systems laboratory series research reports issn may isbn model checking branching time temporal logic ctl reachability analysis method analyzing dynamic behavior concurrent system 
way specifying properties behaviors system branching time temporal logic ctl computation tree logic 
process checking behavior system specied property called model checking 
analyze algorithms ctl model checking 
main contribution report new model checking algorithm time complexity matching best existing algorithms memory requirements equal smaller existing algorithms depending structure system consideration 
algorithm counterexamples witnesses facility valuable trying nd cause incorrect behavior system 
algorithm straightforward implement eoeciently implemented algorithm prod tool set 
keywords model checking temporal logic ctl verication reachability analysis state space exploration prod printing helsinki university technology phone department computer science digital systems laboratory telefax fin espoo finland mail lab saturn hut 
contents branching time temporal logic branching time 
branching time temporal logic ctl 
counterexamples witnesses 
small verication example 
ctl model checking subformula evaluation order 
global model checking 
general structure 
naive implementation 
emc model checking algorithm 
local model checking 
new global model checking algorithm model checking universal formulas 
searching counterexample 
model checking existential formulas 
searching witness 
time space requirements 
prod implementation appendix mutex example prod description appendix initialization routines ii reachability analysis method analyzing dynamic behavior concurrent system 
system described numerous available methodologies example concurrent programming languages sdl promela petri nets 
reachability analysis provides way creating possible behaviors system starting initial state 
possible behaviors system induce reachability graph directed graph nodes global states system edges atomic state transitions states 
reachability graph generation completely mechanical easily automated computer tool support available 
thesis concentrates automated method analyze created reachability graphs tool 
user tool course interactively navigate reachability graph sheer size reachability graphs nding errors way dioecult 
easier specify properties want reachability graph formalism computer mechanical checking 
ad hoc ways dening properties past dioeerent temporal logics getting wide acceptance 
temporal logic logical formulas specify properties behaviors system 
process checking formula true specied state reachability graph called model checking automated tool 
cases possible tool give information help user nd cause errors system 
example tool give sequence states leading state specied invariant assertion doesn hold 
thesis branching time temporal logic ctl computation tree logic specifying properties systems 
interested algorithms model checking ctl formulas 
branching time temporal logic ctl eoecient model checking algorithms 
best algorithms worst case running time linear size formula size reachability graph length theta jsj jrj size reachability graph sum number states transitions reachability graph 
compares favorably linear time temporal logic ltl model checking algorithms take exponential time space size formula worst case 
initial goal select ctl model checking algorithm implemented prod reachability analyzer tool set developed digital systems laboratory 
analysis advanced algorithms seen clear winner existing algorithms algorithms dioeerent strengths 
hand seen new algorithm having combination features algorithms designed 
main contribution thesis new ctl model checking algorithm time complexity matching best existing algorithms memory requirements equal smaller existing algorithms depending structure system model checked 
algorithm counterexamples witnesses facility valuable trying nd cause incorrect behaviors system model checking 
algorithm straightforward implement eoeciently implemented algorithm prod tool set 
main ideas new algorithm rst 
section introduce branching time temporal logic framework 
section contains description analysis existing model checking algorithms 
section introduces new model checking algorithm developed thesis compares algorithms 
discuss implementation model checker section 
thesis suggestions research section 
branching time temporal logic section discuss branching time view behavior system try give intuitive idea specify properties concurrent system branching time temporal logic 
treatment somewhat informal reader directed section formal treatment subject 
branching time looking system reachable states system seen reachability tree 
nodes reachability tree global states system edges reachability tree atomic state transitions 
root node tree initial state system 
edges node represent possible state transitions state 
way tree represents possible behaviors concurrent system starting initial state 
innite reachability tree represented 
constitutes branching time view system 
reachability tree 
state system required successor state tree tree innite extends downwards bounds 
indicated dashed arrows states 
finite computations turned innite ones adding dummy transitions states enabled transitions 
dummy transitions change state system way purpose computations system innite 
computation innite sequence states called fullpath 
need consider nite sequences states 
mark dioeerence call nite sequences states paths 
need way specifying properties innite trees able reason 
reachability tree fact induced state space system time specifying properties innite computations system interested 
way specifying properties innite trees branching time temporal logic 
logic called ctl computation tree logic 
branching time temporal logic ctl conveniently express important properties system interested 
formally dene logic section ll try give intuitive idea subset logic help examples branching time properties 
ctl formulas refer states formulas specify behaviors system starting assigned state formula evaluated 
state omitted convention formulas evaluated initial state system 
syntax ctl atomic propositions ctl formulas ctl formulas constructed combining universal existential path path formula 
path formulas form globally eventually state ctl formulas 
examples legal ctl formulas ag ef ef atomic propositions 
path formula true ioe path formula true starting state formula evaluated 
path formula true ioe formula true states fullpath 
path formula true ioe formula true state fullpath 
exists expressive variant ctl called ctl pairing path formula path restricted 
logic ctl higher algorithmic complexities expressive logic ctl 
example verify property system true invariantly 
means state reachability tree property isn true 
express invariant properties system branching time temporal logic ctl formula ag 
reachability tree system satises formula 
gure states colored black correspond states property true 
states tree isn true true invariantly 
path fullpath forces existential formula true called witness path fullpath forces universal formula false called counterexample 
formally dene notions counterexamples witnesses section 
requirement specied branching time temporal logic ctl formula ag typical safety property 
species things reachability tree ag 
counterexample ag 
happen correctly functioning specication 
safety properties violated requirement isn satised 
state violates property specied formula 
state invariant property true 
path counterexample formula ag surrounded dashed line 
counterexample path fullpath causes universally path formula true 
clearly counterexamples formula isn true 
model checker output counterexample user inspect execution leading error 
kinds properties specied ctl 
property ctl eventuality property af 
species starting initial state eventually reach state property true 
see example 
frontier tree states marked dashed line gives set states system eventually reach 
states true required property eventually true 
example property mean message delivered 
ctl formula af requires message eventually delivered 
case reachability tree af 
path message delivered 
move formal denition ctl 
branching time temporal logic ctl section give formal denition branching time temporal logic ctl 
section largely 
formal syntax ctl denition non empty underlying set atomic propositions ap formal syntax ctl rules 
atomic proposition ap ctl formula 
ctl formulas ax 
call set formulas formed rules set ctl 
dene semantics ctl formulas respect labeled state transition graph meaning word labeled states labeled atomic propositions confused transition labels formalisms 
denition structure labeled state transition graph triple 
nite set states 
binary relation theta gives possible transitions states 
total 

ap assigns state atomic proposition true state 
structure generated form description analyzed system program case high level petri net 
description language essentially syntax atomic propositions ap terms reachability graph state space synonyms structure note transition relation total state successor state 
dene notions path fullpath 
nite innite sequences states called computations 
denition fullpath innite sequence states 
denition path nite sequence states 
structure state innite computation tree root labeled arc tree ioe call computation tree reachability tree system 
relation means formula true state structure known context omitted 
denition relation dened inductively 
ioe 
ioe 
ioe 
ax ioe states 
ioe 
ioe fullpath abbreviation help writing ctl formulas easily ffl ex ax means true immediate successor state ffl af true means true state fullpath ffl ef true means fullpath contains state true ffl ag ef means true state fullpath ffl af means fullpath true state equally valid formulations ctl depending operators taken fundamental 
example equality 
equality replace denition denition number 
denition formula 
formula dened abbreviation equality 
completeness required denition formula structure 
structure 

ioe fullpath example represents structure formula true state 
gures section states true black states true grey states true white 
formula true starting state state true true states 
frontier states prevents construction counterexample formula 
example represents structure formula true state fullpath true state true states 
path marked dashed outline prex fullpath 
witnesses formula 
witness path 
witnesses counterexamples innite length 
witness witness formula 
structure 
fullpath witness ioe true state fullpath note system investigating nitely states fullpath system path ends loop 
case represented fullpath nite path contains states fullpath loop reached 
note witness path counterexample formula true 
witnesses counterexamples complementary cases 
need standard denitions talk ctl formulas 
dene notions set set subformulas set proper subformulas 
denition ctl formula 
set subformulas sub dened recursively follows 
atomic proposition ap sub ffg 

form ax sub ffg sub 

form sub ffg sub sub 
denition ctl formula 
set proper subformulas dened sub ffg want dene length formula precise discussing complexity model checking 
denition ctl formula 
length formula length dened length means cardinality set sub 
counterexamples witnesses previous sections talked informally counterexamples witnesses ctl formula 
equality ctl formulas dene counterexample paths means formula false true true 
combine equality nite state space system get denition denition path counterexample formula state structure ioe denition witness path simpler comes directly ctl formula denition existential formula 
denition path pw witness formula state structure ioe small verication example show ctl specify interesting properties analyzed system 
small verication example section describe small verication example demonstrate usage limitations branching time temporal logic ctl 
system verify small mutual exclusion system 
despite small size demonstrates dioeerent aspect modeling verifying concurrent system ctl 
modeling system class high level petri nets called predicate transition pr nets 
presentation formalism thesis minimal interested reachability graph net model generates 
refer interested reader complete description pr nets 
pr net system consists places graphically noted circles transitions rectangles graphical notation 
places represent local states system markings 
marking place consists multisets tuples integers called tokens 
markings places net constitute global state system 
pr net system initial marking initial state system 
transitions places net connected directed edges called arcs form connected bipartite graph 
place input place transition arc place transition output place transition arc transition place 
transitions represent atomic events 
transition enabled ioe input places transition required tokens specied arc annotations available 
annotations may contain free variables bound tokens input places 
may instances transition enabled dioeerent ways bind free variables binding oe instance transition say transition enabled mode oe 
enabled transition res atomic state transition occurs bound tuples removed input places annotations outgoing arcs transition determine tokens added markings output places transition 
reachability graph generated recursively ring enabled transition instances initial marking 
pr net mutex system prod net description appendix basic idea system model process mutual exclusion algorithm 
processes represented tuples nci nci place initial states processes non critical section indicated constant nc tuples 
tuple place models shared variable mutex algorithm variable initial value indicated constant 
turn turn try go critical idle leave critical pr net model mutex system 
processes want access mutual exclusion region stay respective non critical sections 
modeled executing idle transition 
transition enabled dioeerent modes initial marking 
rst mode transition instance binds tuple nci place tuple place instance red transition atomically rst removes bound tuples input places uses arc annotations output arcs generate tuples output places 
arc annotations output arcs transition result adding tuple nci place tuple place marking transition red identical initial marking expected transition description 
seconds instance transition symmetric process bound tuples tuple nci place tuple place transitions behave similar way 
point time process non critical section try enter critical section executing try transition 
process rst tries enter critical section get turn 
processes trying enter critical section process longer delay idle transition longer enabled 
transition models process entering critical section 
possible process trying enter turn enter critical section 
process leaves critical section transition gives turn process tried enter critical section 
sets turn value 
idle idle try try try try non critical non critical go critical go critical go critical go critical try try non critical non critical reachability graph mutex system 
graphical representation reachability graph mutex system seen 
note transition labels arcs easier readability model checking 
reachability graph seen compact presentation innite reachability tree 
tree generated starting node graph reachability relation recursively generate successor states state 
specied root node reachability tree example verify properties mutex system 
notation csi express atomic propositions 
atomic proposition true marking place contains token csi false 
interesting properties system 
processes time critical section ag csi csi 
process tries get critical section eventually get ag try af csi 
process eventually get critical section 
isn true process remain non critical section forever af csi 
exists path starting form initial state ends process getting critical section ef csi 
globally true system eventually reach initial state 
isn true system loop forever returning initial state ag af nci nci 
globally true system eventually visit initial state ag ef nci nci 
path starting initial state system leaves initial state nci nci 
starting initial state process enter critical section going trying state csi try examples show quite interesting properties systems expressed ctl 
ctl limitations example suppose model modied enable idle transition process process trying get critical section include scheduling processes 
case ask question processes scheduled process eventually reach critical section trying get critical section 
requires expression typical fairness constraint required property required hold 
ctl express property holds fairness constraints 
properties fairness needed linear time temporal logic ltl full branching time temporal logic ctl 
complexity model checking logics exponential size formula price pay expressiveness 
way introducing fairness ctl model checking process raises model checking complexity 
ctl model checking section discuss model checking problem structure ctl formula determine states ctl formula true 
model checking problem formulated dioeerent ways 
traditionally process state structure truth formula evaluated 
called global model checking gives state independently true false result 
cases interested truth value formula state model cases initial state system 
called local model checking 
local model checker perform global model checker intuitively local model checker needs give subset results required global model checker 
worst case time worst case space complexity model checking problem ctl shown linear length formula size structure 
length denote number subformulas ctl formula jsj denote number states structure jrj denote number transitions structure worst case running times ctl model checking algorithms discussed require length theta jsj jrj running time exception naive algorithm require jsj times time 
subformula evaluation order need dene order proper subformulas evaluated evaluating ctl formula dependencies formulas set subformulas 
model dening partial order subformulas sub 
atomic propositions proper subformulas ctl formulas bottom elements partial order 
denition ctl formula 
dene partial order follows 
ctl formulas sub 
marked ioe belongs set proper subformulas 
demonstrate notions proceed example 
suppose need model check ctl formula set subformulas sub fp partial order partial order 
arrow formula formula arrows subformulas form connected directed acyclic graph construct total order topological sorting 
done searching graph depth rst order starting node representing ordering encountered states post order increasing order 
acceptable total order order represented numbers subformula 
algorithm construct sequence sub sequence subformulas sub increasing order 
notation sub denote th item sequence 
process constructing sequence sub seen creating legal evaluation order subformulas note usually legal total orders just straightforward way generating 
algorithm implementations alternative denition technical reasons 
call partial order denition ctl formula 
ctl formulas sub 
ioe 
atomic proposition atomic proposition topological sorting algorithm create sequence sub denition non atomic formulas evaluated atomic propositions evaluated 
advantages partial order explained combination model checking algorithm implementations 
rule thumb global model checking algorithms evaluate formulas sub increasing order local model checking algorithms start formula sub length proceed decreasing order 
help dene model checking algorithms need way accessing immediate subformulas formula example subformulas formula 
dene functions dened total functions notational convenience 
denition ctl formula 
dene functions ctl ctl 
atomic proposition ap null null 

form ax null 

form null special place holder value 
algorithms index sequence sub refer corresponding subformula sub 
specify left right subformulas formula 
concrete new subroutines left right 
subroutines just return value indexed arrays lef right 
arrays initialized subroutine 
subroutines represented completeness appendix figures 
global model checking global model checker evaluates truth value ctl formula bottom manner 
subformulas sub states structure truth value subformula evaluated state previous section dened dependencies subformulas way subformula sub proper subformulas sub fact implement global model checker 
basic idea evaluate subformulas sub length increasing order evaluating subformula consists checking state way evaluation sequence sub constructed evaluating subformula sub know truth values proper subformulas states subformula truth values needed evaluate truth value top level formula unnecessary performed 
model checking question user asked local model checking question unnecessary results obtained process 
example want know property true initial state system global model checker check property states system 
way seeing global model checking creates new atomic propositions subformula sub 
atomic propositions model check subformulas sub section rst general structure global model checking algorithms 
presentation includes subroutines common global model checking algorithms 
global model checking algorithms way existential universal formulas model checked 
section ways implementing 
rst naive version second classical global model checking algorithm emc 
general structure general structure global ctl model checking algorithm 
basic algorithm global model checking algorithms 
data structures subroutines algorithms 
algorithm section isn complete just contains routines common global model checking algorithms 
main loop global model checking algorithms 
rst initializes subformulas subroutine previous section 
starts evaluating proc length foreach initialize subformula false od evaluate access results labeled od main loop global model checker 
subformulas sub increasing order formula truth value states rst set false formula sub evaluated states system subroutine 
dimensional bit array store subformula truth values states 
call bit array indexed jsj length 
procedure set bit false procedure set bit true 
procedure labeled returns true false depending current value bit 
globally model check subformula dependent type formula 
subroutine chooses dioeerent subroutines depending type formula 
global model checking atomic propositions negations conjunctions universal state formulas quite straightforward 
subroutines loop states system check local conditions conditions depending immediate successor states decide truth value formula state 
universal state formula slightly check immediate successor states formula indexed satisfy formula indexed lef 
universal state formula worst time complexity routines easily seen jsj jrj 
subroutine implementations routines figures 
proc ftype sub ftype atomic proposition atomic process atomic subformula elsif ftype negation process negation elsif ftype conjunction process conjunction elsif ftype ax ax process formula ax elsif ftype au au process formula elsif ftype eu eu process formula choosing processing subroutine dioeerent formula types 
proc atomic foreach proposition true state 
change formula labeling true od process atomic proposition 
proc negation foreach labeled left left formula false 
change formula labeling true od process negation 
proc conjunction foreach labeled left labeled right true 

formula true 
od process conjunction 
proc ax foreach suppose formula true foreach successors labeled left contradiction 
isn true 
break od od process universal state formula 
naive implementation global model checking algorithm complete process existential universal formulas 
naive implementation doing 
version looks bit dioeerent basic algorithm 
naive implementation running time linear length formula 
subroutine au model checks universal formulas states system 
see equivalence ctl formulas ax universal formula true states right true lef true true successor states rst set true states right true 
loop states nd state lef true true successor states state state labeled true 
state xpoint reached 
round second part algorithm change labeling formula true false state jsj states algorithm perform changes jsj rounds 
explicit counter loop line subroutine 
body loop takes jsj jrj time subroutine needs worst case jsj theta jsj jrj time 
handling existential formulas similar universal formulas 
subroutine eu model checks universal formulas states system 
ctl formula equivalence need ex 
see equivalence existential formula true states right true lef true true successor state rst set true states right true 
loop states nd state lef true true successor state state state labeled true 
state xpoint reached 
global model checking algorithm uses naive subroutines check existential universal formulas worst case time complexity length theta jsj theta jsj jrj 
memory requirements algorithm quite small 
needed bit array size length theta jsj bits hold subformula truth values states 
simple adjacency list representation successor relation needs jrj theta dlog jsj jsj theta dlog jrj bits 
run time book keeping structures couple counters local variables need memory 
fair compare algorithms remember naive algorithm quite minimal memory requirements 
proc au foreach labeled right label states right true od jsj iterate jsj rounds worst case changed alse foreach labeled labeled left continue labeled going labeled rue foreach successors labeled labeled alse break od labeled local labeling conditions label state changed rue xpoint od changed break fixpoint reached od process universal formula 
proc eu foreach labeled right label states right true od jsj iterate jsj rounds worst case changed alse foreach labeled labeled left continue labeled going labeled alse foreach successors labeled labeled rue break od labeled local labeling conditions label state changed rue xpoint od changed break fixpoint reached od process existential formula 
emc model checking algorithm emc algorithm global model checking algorithm general structure previous sections 
compared naive algorithm previous section emc algorithm better worst case time requirements 
time requirements model checking reduced length theta jsj jrj theoretical minimum 
negative side increased memory requirements 
section subroutines model checking existential universal formulas algorithm global model checking algorithms 
original emc model checking universal formula pseudo code 
constructed model checking routine existential formula trying follow outline original 
emc algorithm uses eoecient algorithm permit globally model check universal existential formulas jsj jrj time 
subroutines au eu accomplish 
subroutines check state formula evaluated case subroutine called evaluate formula state calling evaluation subroutine side eoeect evaluate formula states graph 
avoid redoing unnecessary need notice emc algorithm uses additional bit array marked mark states formula evaluated 
bit array size jsj subroutines change array values false true correspondingly 
bit array accessed subroutine marked returns current value marked array indexed subroutine evaluates universal formula states successor relation accesses 
uses marked bitmap rst mark states accesses 
state marked subroutine called labeled bitmap contain truth value formula state directly see equivalence ax formula right true formula true formula right isn true formula lef isn true won true 
local conditions checked subroutine 
cases apply case true ioe true successor states check case recursively calling subroutine successor state successors checked successor isn true 
subtle point haven considered 
case arises loop reachability graph lef true states right isn true state 
case result subroutine dependent output call subroutine state happens case second call return false 
correct behavior algorithm see denition counterexample 
nd loop reachability graph right isn true state counterexample 
counterexample path witness formula state isn true state checked successor states haven isn true labeled true state talk time complexity algorithm see subroutine takes time state marked 
state isn marked rst marked 
case time needed subroutine constant loop subroutine called recursively successor states 
number calls time needed result processing bounded jrj looking calls processing formula total time complexity algorithm au jsj jrj 
subroutine model checking existential formulas quite dioeerent model checking routine universal formulas 
basic dioeerence algorithms existential model checker uses predecessor relation model checking 
algorithms fact calling subroutine known formula true state known model checker called subroutine states basic idea algorithm explained help equivalence ex 
see true states right true lef true true successor state equivalent true predecessor state lef true true subroutine looks state right 
state true state labeled 
starts subroutine recursive depth rst search predecessor relation 
encounters predecessor lef true true predecessors investigated states true 
marked bitmap search predecessor relation state 
talk time complexity algorithm see proc au foreach od foreach marked formula evaluated 
check formula od process universal formula 
subroutine takes time processing 
subroutine takes time loop predecessor states loop executed state 
number calls recursive search bounded jrj 
total time complexity algorithm eu jsj jrj 
global model checking algorithm uses emc subroutines check existential universal formulas worst case time complexity length theta jsj jrj 
memory requirements algorithm follows 
needed bitarray size length theta jsj bits hold subformula truth values marked bitmap states 
simple adjacency list representation successor predecessor relation needs theta jrj theta dlog jsj jsj theta dlog jrj bits 
need double reachability relations substantial usually need memory mixture existential universal subformulas formula 
predecessor relation theory computed successor relation linear time computing awkward relation sizes large 
run time structures stack size jsj dioeerent recursive calls quite reasonable 
emc algorithm quite straightforward implement time complexity 
need predecessor relation lack counterexamples witnesses facility drawbacks almc algorithm section new algorithm section don 
proc marked formula evaluated loop 
labeled labeled gets right value cases 
return rue return alse mark state reached formula evaluated labeled right right true true return rue elsif labeled left return alse left right false false foreach successors left true check successor return alse od successors ok true return rue process universal formula state proc eu foreach od foreach marked formula evaluated 
check formula od process existential formula 
proc labeled right formula true directly label states reach process existential formula state proc visit state twice foreach predecessors marked labeled left true predecessor 
label predecessor recursively depth rst search od propagate label change predecessor states 
local model checking section discuss alternative approach model checking 
model checking question study local model checking question structure state ctl formula true state answer question take topdown approach evaluate subformulas needed 
subformula truth values dioeerent states usually needed times recursive evaluations 
keep time requirements minimal keep track subformulas evaluated state results evaluations 
global model checker evaluate subformula truth values states system may perform unnecessary values needed 
algorithm section almc algorithm published 
algorithm derivative algorithm contributions 
original almc algorithm uses high level data types operations data types dioecult implement conventional data types maintaining theoretical complexity almc algorithm 
algorithm complexity original almc algorithm recast concrete terms arguments algorithm complexity clearer 
opinion easier understand implement original almc algorithm 
time memory requirements algorithms identical worst case 
general structure algorithm similar ones global model checking 
part algorithm way existential formulas model checked 
main loop algorithm resembles global model checking algorithm main loop 
main dioeerence almc algorithm gets state input parameter state formula evaluated initialization changed somewhat 
value subformula state almc unknown true false 
initialization subformula values labeled unknown states subformula state pairs set unmarked 
new depth rst search number array initialized zeroes 
real local model checking algorithm called state top level subformula 
array info tell value subformula sub unknown true false state subroutine info returns current value array item info value sets value 
need bit array marked keep track visited states depth rst searches 
subroutines manipulate bit array subroutine marked tell state currently marked 
way save memory code values info marked bits state subformula possible algorithms needs mark state subformula truth value known 
structure need jsj theta length theta bits memory 
almc algorithm doesn need predecessor relation emc algorithm 
simple adjacency list presentation predecessor relation needs jrj theta dlog jsj jsj theta dlog jrj bits memory 
almc algorithm hand needs array depth rst search numbers 
almc algorithm smaller memory requirements needs jsj theta dlog jsj bits memory store depth rst search number state 
memory needed successor relation 
note structures ctl interpreted total state successor state 
subroutines num set access depth rst search numbers 
subroutine check locally model checks formula sub state subroutine 
looks similar structure global model checking routine 
main dioeerence check subroutine evaluate formula state evaluation states graph 
notice rst thing check check formula truth value known 
algorithm returns immediately uses time case 
return check procedure guarantee truth value formula evaluated state accessed subroutine info 
figures local model checking subroutines atomic proposition negation conjunction universal state formulas 
similar global model checking counterparts figures 
subformulas local immediate successor states determine truth value evaluated formula 
note calling subroutine check start recursive local model checking evaluations 
obviously length evaluation searches active moment single evaluation search corresponds active calls check subformula subroutine au locally model checks universal formula state figures 
compare algorithm emc algorithm figures see logic routines identical 
obvious looking algorithm pseudo code reformulate almc algorithm model checking universal formula look corresponding recursive emc algorithm 
section try faithful original representation almc algorithm 
major change comparing global model checking algorithm sure truth values needed subformula evaluated need 
subroutine check guarantee needed subformula evaluated 
note subroutine cst dioeerent ways terminating 
return normally raise signal exit signal caught routine au initialized current evaluation search 
signal raised counterexample path formula causes recursive calls cst terminate search return routine au current value stack cst passed variable contains current search path 
counterexample path stack cst contains counterexample path states path labeled false 
proc length foreach unknown initialize formulas unknown od od foreach initialize dfs numbers od check length evaluate top level subformula state return info length main loop almc model checker 
proc check info rue info alse return truth value known state ftype sub ftype atomic proposition atomic process atomic subformula state elsif ftype negation process negation state elsif ftype conjunction process conjunction state elsif ftype ax ax process formula ax state elsif ftype au au process formula state elsif ftype eu eu process formula state choosing processing subroutine dioeerent formula types 
proc atomic proposition true state 
rue change info unknown true alse change info unknown false process atomic proposition state proc negation check left check left state info left rue info unknown check alse rue process negation state proc conjunction check left check left state info left rue check right check right state info right rue rue true true return alse process conjunction state proc ax foreach successors check left check right state info left alse alse return od rue left true successors true process universal state formula state proc au cst empty stack store search path stack cst try cst search counterexample catch exit uses signal exit abort search aborted signal ioe search aborted cst empty empty cst stack cst counterexample pop cst state belongs counterexample alse set info false state od subroutine au 
proc cst search counterexample containing tmp info tmp alse throw exit false counterexample elsif tmp rue return true counterexample elsif tmp unknown check right info right rue true rue counterexample return contain state check left info left alse false cst counterexample throw exit abort search marking loop detection cst foreach successors marked loop 
continue searching cst search children counterexample throw exit abort search od cst counterexample rue true subroutine cst 
algorithm model checking existential formulas lot emc algorithm interesting part almc algorithm 
dioecult part algorithm 
algorithm doing consecutive depth rst searches reachability graph subformula evaluation search 
rst explain simple approach elaborate match time complexity emc algorithm 
basic idea simple algorithm search witness path existentially formula depth rst search starting state quite obvious denition witness path witness path formula ends state formula right true 
reach witness path state states lef true witness formula state search witness path state prematurely nd state formula evaluated true previous run 
case know witness path starting state state witness path constructed concatenation paths call state search witness stopped successfully goal state 
search nd state false right false lef false conclude belong witness path successors need investigated formula labeled false goal state formula true state goal state formula false state problem procedure described evaluates truth value formula state potentially states reachability graph may visited recursive calls subroutine 
obviously simple algorithm time requirements quadratic number states system quite unacceptable 
get back linearity algorithm evaluate truth value formula states current evaluation search visited 
order need complicated algorithm 
easily see denition witness path states evaluation search goal state reached states lef true witness formula labeled true 
algorithm model checking existential formulas divided depth rst searches 
rst search looks goal state states lef true performs additional bookkeeping 
simple algorithm described basis rst search 
modied keep track states reached current search potentially belong witness path states truth value unknown right false lef true 
stack cst algorithm store potential witness states 
goal state witness path states formula labeled false states stored stack cst 
rst search algorithm implemented subroutine eu subroutine cst gure 
need second search algorithm goal state 
task second search decide states stack cst belong witness path 
need depth rst search exactly search order rst search potential witness states 
exactly states stack cst states left marked rst search 
search done exactly order know eventually reach goal state 
aim nd exactly potential witness states goal state reached potential witness states 
construct witness path states formula true 
form witness path potential witness states labeled false 
modied version algorithm tarjan 
algorithm nds maximal strongly connected components graph linear time size graph 
original almc algorithm algorithm complex data types operations 
search maximal strongly connected components graph consisting potential witness states goal state reached 
tarjan algorithm property states currently visited state reached stack fst 
nd maximal strongly connected component reaching goal state way reaching goal state states belonging maximal strongly connected component 
construct witness path states formula labeled false 
nally encounter goal state abort execution tarjan algorithm 
moment execution states stored stack fst goal state reached potential witness states 
states stack fst labeled true formula subroutines goal goal fst implement second search algorithm 
note subroutine goal called eu subroutine case goal state 
division searches needs done minimize memory requirements 
causes additional complexity algorithm cuts memory requirements depth rst search numbers length theta jsj theta dlog jsj jsj theta dlog jsj bits memory 
problems caused choice considerable added complexity algorithm especially guaranteeing depth rst searches search reachability graph exactly order far potential witness states concerned 
searches take linear time size reachability graph don increase worst case time complexity algorithm 
almc algorithm local model checking algorithm worst case time complexity length theta jsj jrj best global model checking algorithms 
comparison isn quite fair global model checkers realize worst case running time local model checker perform faster cases 
local model checker book keeping accomplish bigger book keeping overheads 
number bits needed formulas book keeping bitmaps jsj theta length theta bits twice global model checking algorithms 
almc algorithm doesn need predecessor relation saves jrj theta dlog jsj jsj theta dlog jrj bits memory compared emc algorithm 
almc algorithm needs depth rst search numbers require jsj theta dlog jsj bits memory 
cases reachability graphs arrows states arrows states 
drawback amount stack space needed recursive depth rst search routines 
harder account seen bounded length theta jsj order length global model checking routines 
conclude worst case memory requirements local model checking algorithm worse competing global model checking algorithms 
implementation needed considerably 
remains seen local model checking algorithm dioeerence lazy evaluation subformulas practical model checking 
proc eu gamma initialize witness path state cst empty stack store potential witness states cst try cst search witness catch exit uses signal exit abort search aborted signal ioe search aborted goal gamma goal gamma witness empty cst pop cst potential witness state alse false od witness goal label potential witness states subroutine eu 
proc cst search witness containing tmp info tmp alse return false witness elsif tmp rue true witness throw exit abort search elsif tmp unknown check right info right rue true witness throw exit abort search check left info left alse false witness contains alse return search successors mark state visited cst add potential witness states foreach successors xed order marked cst search witness od subroutine cst 
proc goal dfs depth rst search number fst stack fst detection try goal fst label potential witness states goal reached catch exit uses signal exit abort empty fst stack fst contains states fst cleanup dfs number array od subroutine goal 
proc goal fst label states reach goal rue suppose belongs witness goal throw exit goal state abort dfs dfs dfs min dfs initialize minimum reachable dfs number fst store state detection foreach successors visit successors xed order marked exactly order goal fst dfs search goal min state smaller dfs number 
min update minimum dfs number od min root state 
goal repeat top stack fst contains goal reached fst state clean dfs number alse change info false return min subroutine goal fst 
new global model checking algorithm initial goal select ctl model checking algorithm implemented prod reachability analyzer tool set 
analysis previous sections see clear winner existing algorithms algorithms dioeerent strengths 
hand discovered new algorithm having combination features algorithms designed 
section new global model checking algorithm algorithms emc almc sections respectively 
main ideas algorithm section rst 
design goals algorithm match best worst case time complexity achieve minimal worst case memory requirements 
wanted deliver algorithm counterexamples witnesses facility 
facility asking formula true state user get true false result 
facility result universal formula false result existential formula true model checker give user counterexample witness path respectively 
valuable trying nd cause unexpected behaviors system model checking 
example model checker give counterexample path forces universal formula false user easily gure requirement specied formula met 
note counterexamples witnesses facility sense case model checking question user interested local model checking question checking formula true state 
usually way user interacts prod model checker 
evaluating existing model checking algorithms global model checking algorithm emc simple implement small runtime book keeping memory requirements 
emc algorithm requires predecessor relation precomputed stored memory 
creating relation quite straightforward implemented linear running time somewhat wasteful store memory 
major factor deciding implementing emc model checker lack counterexamples witnesses facility 
feature added form algorithm run model checking procedure nished 
approach need denition separate algorithm task somewhat unnecessary 
local model checking algorithm almc quite tricky implement 
correctness almc algorithm relies having depth rst search passes visiting subset reachability graph exactly order 
previous section variant almc algorithm recast simple data types 
dioecult task algorithm representation easily implemented 
main drawback almc algorithm amount runtime book keeping memory overhead required worst case 
example search stack memory requirements worst case order length global model checking algorithm 
remains seen lazy evaluation subformulas larger runtime book keeping overhead local model checker 
almc algorithm easily modied provide counterexamples witnesses facility 
new global model checking algorithm combines features emc almc algorithms 
quite small runtime book keeping memory overheads expected global model checking algorithm 
doesn need predecessor relation respect uses memory emc algorithm 
major feature availability counterexamples witnesses facility 
algorithm somewhat optimized implementation perspective quite straightforward implementation performance characteristics 
basic structure algorithm global model checking algorithms section figures 
dioeerence comparing global model checking algorithms way existential universal formulas model checked 
section rst describe model checking universal formulas followed demanding part model checking existential formulas 
model checking universal formulas model checking universal formulas new algorithm quite similar subroutines emc almc algorithms 
chapter algorithm form memory requirements algorithm explicit 
enables straightforward implementation algorithm performance characteristics 
new algorithm model checking universal formulas 
main dioeerence global model checking algorithms addition counterexamples witnesses facility 
global variable check global set true subroutine calculate truth value formula states system just normal global model checker 
global model checking wanted counterexamples witnesses facility 
case need know state top level formula evaluated 
global variable evaluation state pass information subroutine 
subroutine evaluation state st search counterexample path formula starting state evaluation state 
counterexample path exists left stack st passed subroutine 
counterexample path retrieved stack st procedure st 
important change algorithm way initializes marked labeled bitmaps 
subroutine called 
see directly denition universal formula cases truth value formula state depends truth values formulas lef right state 
enumerated dioeerent cases 
labeled left labeled right marked labeled false false true false false true true true true false false false true true true true search bitmap initialization table 
states marked false need processed 
row 
cases truth value formula determined looking successor states eoecient version initialization routine boolean operations bitmaps initialize marked labeled bitmaps 
searching counterexample logic model checking universal formula state try nd counterexample path universal formula starting state subroutine st accomplishes just 
subroutine dioeerent ways 
subroutine global model checker evaluates truth value formula state counterexample generator counterexamples required 
need reformulation counterexample path terms search bitmaps marked labeled 
table substitute values search bitmaps counterexample denition proc au model check universal formulas initialize marked subformulas length check global global checking wanted 
foreach evaluate formula states marked formula evaluated 
st empty stack st evaluate od counterexample wanted st empty stack evaluation state evaluation state st check locally labeled evaluation state counterexample st output subroutine model checking universal formula 
proc initialize search bitmaps foreach boolean bitmap operations labeled left labeled right labeled right od subroutine initialize marked 
denition counterexample path formula state structure ioe path marked labeled marked labeled marked labeled denition gives direct denition search algorithm counterexample path state just initialize search bitmaps search path satisfying cases denition 
note denition formulated way hold truth value formula evaluated states 
formula evaluated false state marked unlabeled construct counterexample path 
reach unmarked unlabeled states counterexample path path concatenation path counterexample path case formula evaluated true state marked labeled construct counterexample containing state paths containing need considered potential counterexample paths 
subroutine st counterexample search algorithm uses denition 
parameter st passed subroutine 
subroutine non recursive form depth rst search algorithm 
terminates soon counterexample path formula state counterexample path formula 
search consider states formula truth value known states unmarked unlabeled calling subroutine 
need values search bitmaps immediate successor states states 
search starts unmarked state algorithm marks unmarked states rst time encountered 
gives way detecting loops search 
reason encountered states marked fact formula evaluated encountered states search algorithm terminates 
rst enter state check concatenation current search path stored stack st entered state counterexample path 
entered state marked unlabeled state counterexample path 
describe case seen counterexample path denition 
algorithm search path st contains states initially unmarked unlabeled 
counterexample denition dioeerent types counterexample paths 
rst case entered state marked unlabeled search case counterexample rst form 
second case state unmarked unlabeled search started marked labeled search state exists search stack st loop second form 
analyze subtle detail see dioeerent case handled identically algorithm 
need handle cases counterexample path directly 
entered state marked labeled formula true counterexample constructed contains state entered state marked continue search counterexample path depth rst order recursively successor states 
counterexample path successors visited formula true state counterexample path contain state logic counterexample search algorithm similar model checking subroutines emc almc algorithms 
major dioeerence algorithm uses initialization routine evaluate formulas successor state subformula truth values needed 
initialization implemented eoeciently 
way counterexample search algorithm enables faster implementation model checking procedure 
model checking existential formulas model checking existential formulas new algorithm quite similar logic corresponding algorithm almc model checker 
almc algorithm pass depth rst search algorithm model check existential formulas memory requirement reasons 
variant pass search need set depth rst search numbers recursively evaluated subformula require length times memory allocated depth rst search numbers 
algorithm global model checking algorithm recursive subformula evaluations set depth rst search numbers 
enables pass depth rst search algorithm pass combination passes almc algorithm 
proc st search counterexample rue non recursive depth rst search rue visit new states look counterexample marked new state mark 
succ num search successors push hs succ st save search state successor succ num visit successor labeled loop illegal state 
push hs st counterexample return path false break old backtrack exiting loop od rue backtracking search counterexample empty st search complete 
return counterexample true hs succ pop st backtrack parent state succ num succ num try successor succ num push hs succ st save search state successor succ num succ break visit new succ exiting loop succs visited true od od subroutine st 
new algorithm model checking existential formulas 
main dioeerence global model checking algorithms addition counterexamples witnesses facility fashion universal formulas 
global variable check global set true subroutine calculate truth value formula states system just normal global model checker 
global model checking wanted counterexamples witnesses facility 
case need know state top level formula evaluated 
global variable evaluation state pass information subroutine 
subroutine evaluation state st fst search witness path formula starting state evaluation state 
witness path exists left stack st passed subroutine 
witness path retrieved stack st procedure st 
initializations needed quite lot global model checking algorithms 
need initialize search bitmaps marked labeled 
look denition existential formula see cases truth value formula decided consulting successor states truth formula values cases 
construct needed table compare constructed universal formulas see coincidence identical earlier 
subroutine perform initialization 
called 
algorithm needs array depth rst search numbers min state additional bitmap modified 
structures initialized subroutine 
searching witness logic model checking existential formula state try nd witness path existential formula starting state subroutine st fst accomplishes just 
subroutine dioeerent ways 
subroutine global model checker evaluates truth value formula state witness generator witnesses required 
need reformulate denition witness path terms search bitmaps marked labeled 
initialization table substitute values search bitmaps marked labeled witness denition proc eu model check existential formulas fst empty stack initialize father state stack initialize marked subformulas initialize min modied length check global global model checking wanted 
foreach evaluate formula states marked st empty stack st fst evaluate od witness wanted st empty stack evaluation state evaluation state st fst check locally labeled evaluation state witness st output subroutine model checking existential formula 
proc init dfs number handling foreach od subroutine initialize min modified 
denition witness path formula state structure ioe path pw marked labeled marked labeled denition gives direct denition search algorithm witness path starting state denition holds formula evaluated true false states system 
formula evaluated true state marked labeled witness path state reach state unmarked unlabeled states witness formula evaluated false state marked unlabeled couldn construct witness construct witness contains state unfortunately denition doesn give description linear time model checking algorithm existential formulas 
reasons almc algorithm needs passes 
rst pass almc algorithm checks witness path form described exists 
second pass evaluate checked formula visited potential witness states true false depending reach witness path visited potential witness states 
note context new algorithm potential witness states states initially unmarked unlabeled 
new algorithm described section combines search passes stack fst 
new state rst encountered stack fst contains visited potential witness states state reached 
witness states stack fst exactly visited potential witness states witness path constructed 
rst describe part algorithm searches witness path return way stack fst maintained algorithm search 
subroutine st fst witness search algorithm uses witness denition 
uses subroutine st st dfs 
parameters st fst dfs passed subroutines 
subroutines form non recursive depth rst search algorithm 
task subroutine st st dfs search forward depth rst order look witness path 
backtracking search book keeping required handled subroutine st fst 
search terminates soon witness path formula state witness path formula 
search consider states formula truth value known states unmarked unlabeled calling subroutine 
need truth values search bitmaps immediate successor states states 
search starts unmarked state algorithm marks unmarked states rst time encountered 
gives way detecting loops search 
reason encountered states marked fact formula evaluated encountered states search algorithm terminates 
rst enter state check concatenation current search path stored stack st entered state witness path 
part algorithm done subroutine st st dfs 
entered state marked labeled state witness path 
describe case seen witness path denition 
algorithm search path st contains states initially unmarked unlabeled 
state marked labeled search path initially unmarked unlabeled states obviously witness path signal returning subroutine st st dfs return value 
need handle cases witness path directly 
entered state marked unlabeled loop state unlabeled search started 
case don need search successor states witness backtrack parent state exiting subroutine st st dfs 
entered state marked continue search witness path depth rst order recursively successor states 
witness path successors visited conclude witness path contains major dioeerence checking universal formulas reason model checking existential formula complicated 
backtrack state second part algorithm handle labeling state decided 
second part algorithm evaluates truth value formula potential successor states 
recall stack fst decide potential witness states witness path constructed 
new state encountered stack fst contains visited potential witness states state reached 
witness states stack fst exactly visited potential witness states witness path constructed 
maintaining stack fst second part model checking algorithm 
second part algorithm subroutines st fst st fst dfs inspired tarjan algorithm searching maximal strongly connected components graph 
algorithm uses slightly memory designed model checking problem hand 
dioeerence way depth rst search numbers 
tarjan algorithm uses sets depth rst numbers second stored search stack jsj theta log theta bits memory worst case 
algorithm section uses jsj theta log bits memory 
tarjan algorithm minor algorithm component search stack tarjan algorithm contains exactly states stack fst algorithm 
describe handling stack fst handling need additional denitions 
dene dfs total ordering relation encountered states dfs ioe state encountered current depth rst search 
symbol represent edges reachability graph traversed current call subroutine st fst 
represent transitive closure 
denition set states structure set edges traversed current search new state encountered search 
set father states function dfs note algorithm successor edges potential witness states state potential witness state 
new unmarked state encountered want father state stack fst contain exactly states dened 
case witness path rst encounter state states stack fst construct path potential witness states state fst apart states potential witness states 
formula true subroutine st st dfs rows labels correspondingly 
search ended witness path formula false visited potential witness states due initialization procedure needs done 
sketch states stored stack fst exactly visited potential witness states new state reached 
search starts stack fst empty 
time new state encountered stack fst contains visited states state reached 
state belongs set added stack fst visiting successor state array min set depth rst search number state min value marked 
visit successor states time 
return searching successor state witness path returning successor state back parent state array min value successor contains depth rst search number smallest state reachable successor way nding witness contains successor state 
smallest state reachable successor smaller current smallest depth rst number stored variable min true min value case updated value successor depth rst search number state min value marked modied 
successor states state visited min value state hasn modied exist witness path contains state state reachable 
return parent state update stack fst removing states stack fst 
min value modied loop dfs loop requires keep stack fst 
logic get state earlier depth rst search 
get new state depth rst search long state fully processed 
return parent state stack fst updated unmarked state visited 
combination parts model checking algorithm quite straightforward 
algorithm pseudo code figures 
subroutines quite easily combined larger subroutine straightforward non recursive implementation 
proc st fst search witness dfs rue non recursive depth rst search successor min st fst dfs search new successor min gamma return witness st return rue backtracking search witness empty st return witness hs succ pop st backtrack parent state successor min father state reachable successor min successor 
successor min update smallest reachable father state succ num succ num try successor succ num push hs succ st push search state successor succ num succ break visit succ succs visited modied father state reachable 
witness reachable repeat state entered pop fst cleanup reachable popped 
od od subroutine st fst 
proc st st dfs search new states witness rue search forward marked formula evaluated push fst add father states new state mark 
dfs store dfs number dfs dfs dfs passed succ num search succs witness push hs succ st push search state successor succ num visit successor labeled witness push hs st empty fst fst pop fst get father state cleanup label true od return gamma witness stack st return break labeled backtrack parent od return return minimum reachable state witness subroutine st fst dst 
time space requirements algorithm section global model checking algorithm evaluation routines universal existential formulas depth rst searches 
worst case time complexity subroutines jsj jrj model checking algorithm length theta jsj jrj matches worst case time complexity best global local model checking algorithms 
worst case memory requirements length theta jsj jrj assume storing formulas truth values search bitmaps successor relation state depth rst search numbers require constant amount memory item 
analysis assumptions algorithms stated results corresponding sections 
gather results complexity analysis dioeerent sections get table 
save space notation jf way expressing length length formula model checked 
surprises table apart naive algorithm algorithms similar time space complexity gures kind analysis 
main point almc algorithm new algorithm counterexamples witnesses facility easily incorporated algorithm 
algorithm time space counterexamples naive jf theta jsj theta jsj jrj jf theta jsj jrj emc jf theta jsj jrj jf theta jsj jrj almc jf theta jsj jrj jf theta jsj jrj new jf theta jsj jrj jf theta jsj jrj worst case time space requirements 
table algorithms identical time space requirements 
naive algorithm exception rule worse time requirements 
assumptions space requirement analysis realistic ones 
example assumed amount memory needed store item successor relation amount memory needed boolean subformula truth value quite coarse implementation perspective 
detailed analysis account number bits needed encode dioeerent data types algorithms 
environment new model checking algorithm implemented typical model checker check formulas length cardinality states successor relation 
case amount memory needed storing successor relation depth rst search numbers search stacks limiting factor number required subformula truth values 
detailed analysis worst case memory requirements new algorithm shows subformula search bitmaps need jsj theta length bits memory depth rst search numbers need jsj theta dlog jsj bits memory search stacks st fst need jsj theta dlog jsj theta bits memory worst case 
sum actual memory requirements search memory requirement new algorithm jsj theta dlog jsj theta length bits memory worst case additionally simple adjacency list representation successor relation needs jrj theta dlog jsj jsj theta dlog jrj bits memory 
sum search memory requirements algorithms 
search stack usage analyzed carefully algorithms order bits memory required 
expected emc algorithm uses memory search stacks new algorithm simpler depth rst search algorithm needs stack 
almc algorithm dioecult analyze recursive subformula evaluations seen table added length term search stack usage 
algorithm bitmaps dfs numbers search stacks naive jsj theta jf emc jsj theta jf jsj theta dlog jsj almc jsj theta jf theta jsj theta dlog jsj jsj theta dlog jsj theta jf new jsj theta jf jsj theta dlog jsj jsj theta dlog jsj search memory requirements bits 
algorithm successors predecessors naive jrj theta dlog jsj jsj theta dlog jrj emc jrj theta dlog jsj jsj theta dlog jrj theta almc jrj theta dlog jsj jsj theta dlog jrj new jrj theta dlog jsj jsj theta dlog jrj successor predecessor memory requirements bits 
sum amount memory needed store successor predecessor relations simple adjacency list form 
noted emc algorithm needs successor predecessor relations 
cardinality successor relation number states jrj jsj actual memory requirements emc algorithm new algorithm constant factor close 
cases cardinality successor relation larger number states jrj ae jsj algorithm smaller memory requirements emc algorithm 
amount memory needed predecessor relation emc algorithm grows case faster amount memory needed search stacks depth rst search numbers new algorithm 
almc local model checking algorithm larger actual worst case memory requirements algorithms global model checkers 
dioeerence larger length formula increases 
known worst case behavior occur practical model checking 
cases checked formulas generated human usually quite short 
lazy evaluation subformulas combined memory management scheme result model checker average case memory requirements 
easy ctl model checker smaller memory requirements new algorithm example naive implementation global model checker uses memory 
naive algorithm worse time complexity 
interesting know ctl model checking algorithms match worst case time complexity smaller actual memory requirements 
thing noted analysis thesis left amount memory needed store state information state system 
reasons twofold rst amount memory algorithms 
secondly state information removed memory atomic subformulas evaluated states system 
local model checker moment global model checker increase memory usage 
global model checker fact atomic subformulas dependent evaluate atomic subformulas states system pass state information le 
prod implementation reachability analysis formal way analyze concurrent distributed systems 
systems complex errors hard detect tool support designing analyzing systems absolutely essential 
pr net reachability analysis tool set prod developed digital systems laboratory helsinki university technology 
tool set contains dioeerent ways performing analysis verication concurrent systems 
main emphasis prod tool set dioeerent reachability analysis methods 
prod contains dioeerent tools tied command line driven tool prod 
currently tool set consist components 
control program prod execute components tool set 

reachability graph generator generator called program reads net description net description language generates language program compiled run generate reachability graph 

query program probe tool navigating reachability graph 

tool called strong calculating maximal strongly connected components 

interface ara tool won discuss 
see dioeerent parts tool combined 
main tool prod coordinates tools don need explicitly 
description system sys net description language le net 
system description program create language program sys reachability graph generator program compiled compiler gcc generates reachability graph generator program sys 
program run creates reachability graph analyzed system 
reachability graph stored les sys adr sys aws sys gph 
way reachability graph program strong compute maximal strongly connected components reachability graph 
interested model checking branching time temporal logic ctl 
new ctl model checking algorithm implemented new feature probe tool 
program probe interactive ctl formula queries counterexamples witnesses query results gcc probe strong sys adr sys aws sys gph sys sys sys net structure prod tool set 
investigate reachability graph 
probe program interactive reachability graph navigation tool query language automated analysis 
new feature users interactively check ctl formulas want state analyzed system 
algorithm built top existing probe tool existing code possible 
example algorithm uses old probe query language evaluate atomic propositions needed model checking 
experience time ctl model checking spent evaluating atomic subformulas states reachability graph 
current implementation evaluates atomic subformulas states pass markings generated reachability graph generator 
avoid accessing large marking le sys gph times state dioeerent atomic subformulas evaluated 
atomic subformulas evaluated states system state information longer needed removed memory 
users tool ask local ctl model checking questions example want know specied formula true initial state system 
ctl model checking questions users ask local model checking questions counterexamples witnesses facility 
drawback rst evaluating atomic subformulas model checking top level formula local implementation needs evaluate atomic subformulas 
maximal strongly connected components reachability graph optimize order local model checker called evaluate subformula global model checking performed subformula 
topological sorting arrange order formula evaluated dioeerent states starting terminal maximal strongly connected components 
way minimize amount memory needed dioeerent search stacks cost extra preprocessing step 
side note note old probe query language expressive implement ctl model checker 
query language wasn designed task running times model checker grow exponentially length formula model checked 
old probe query language ctl model checking infeasible simple formulas 
extensive measurement results available time writing performance new model checking algorithm quite 
example tried model checking dining philosophers problem net description philosophers 
system reachable states state transitions 
model checking subroutines temporal subformulas take seconds globally model checking temporal subformula required successor relation les preloaded memory 
evaluation time atomic subformula states system take order minute seconds 
reachability graph generation time example approximately minutes 
results obtained mhz pentium pc running linux mb memory 
limited experiments implementation new model checking subroutines quite capable handling larger systems problems reachability graph generation atomic subformula evaluation bottlenecks model checking process 
initial goal select ctl model checking algorithm implemented prod reachability analyzer tool set 
analyzed dioeerent advanced model checking algorithms algorithms dioeerent sets desired features 
algorithm having desired features existed discovered creating algorithm possible 
main contribution thesis new ctl model checking algorithm time complexity matching best existing algorithms length theta jsj jrj memory requirements equal smaller existing algorithms depending structure system model checked 
algorithm counterexamples witnesses facility valuable trying nd cause incorrect behaviors system model checking 
algorithm straightforward implement eoeciently implemented algorithm prod tool set 
main ideas new algorithm rst 
algorithms analyzed thesis means ones model checking ctl 
ctl formulas expressed alternation free subset propositional mu calculus 
means model checking algorithms propositional mu calculus model checking ctl 
linear time model checking algorithms alternation free subset mu calculus cleaveland cleaveland klein andersen bhat cleaveland 
approaches uses mu calculus xed point representation ctl formulas model checkers bdd data structure 
data structure eoeciently compute xed point formulas represent ctl formulas 
representation especially verifying digital circuits 
note bdd doesn guarantee linear running time model checking bdd way heuristically computing xed point formulas 
way doing ctl model checking automata theoretic approach 
vardi wolper developed automata ctl model checking algorithm 
algorithm linear time complexity size structure length formula 
cheng christensen discuss way maximal strongly connected components reachability graph model checking subset ctl 
method independently discovered 
method uses precomputation maximal strongly connected components reachability graph doesn handle full ctl 
methods works combination model checking algorithm 
interesting compare precomputation maximal strongly connected components pays ooe compared new algorithm thesis 
partial order reductions prod reachability graph generation preserve ctl properties 
need generate full reachability graph model checking problem hand 
usually bottleneck verication process ctl model checking process 
partial order reductions preserving temporal logic ctl branching time logic ctl state operator demonstrated 
reduction preserves full branching time temporal logic ctl express formulas linear time temporal logic ltl branching time temporal logic ctl 
currently know implementation combining ctl preserving partial order reductions branching time model checker 
combination truly useful properties interested expressed linear time temporal logic ltl 
ltl model checker combined partial order reductions prod tool set 
quite challenging task design ctl model checking algorithm works combination partial order reductions 
andersen model checking boolean graphs 
theoretical computer science elsevier pp 

vardi wolper automata theoretic approach branching time model checking 
dill 
ed proceedings th international conference computer aided verication lecture notes computer science springer verlag berlin pp 

bhat cleaveland grumberg eoecient fly model checking ctl 
proceedings th annual ieee symposium logic computer science ieee computer society press pp 

bryant graph algorithms boolean function manipulation 
ieee transactions computers pp 

burch clarke mcmillan dill hwang symbolic model checking states 
information computation pp 

cheng christensen mortensen model checking coloured petri nets exploiting strongly connected components 
koz 
eds proceedings international workshop discrete event systems edinburgh pp 

clarke grumberg mcmillan zhao eoecient generation counterexamples witnesses symbolic model checking 
technical report tr cmu cs carnegie mellon university school computer science pittsburg 
clarke emerson sistla automatic verication finite state concurrent systems temporal logic specications 
acm transactions programming languages systems pp 

cleaveland klein faster model checking modal mu calculus 
probst 
eds proceedings fourth international workshop computer aided verication lecture notes computer science verlag berlin pp 

cleaveland linear time model checking algorithm alternation free modal mu calculus 
formal methods system design pp 

emerson temporal modal logic van leeuwen 
ed handbook theoretical computer science volume formal models semantics elsevier pp 

emerson lei eoecient model checking fragments propositional mu calculus 
proceeding symposium logic computer science ieee computer society press pp 

emerson automated temporal reasoning reactive systems 
ller birtwistle 
eds logics concurrency structure versus automata lecture notes computer science springer verlag berlin pp 

predicate transition nets 
jensen rozenberg 
eds high level petri nets springer verlag berlin pp 

gerth kuiper peled penczek partial order approach branching time logic model checking 
proceedings rd israel symposium theory computing systems ieee computer society press pp 

gr pr net reachability analysis tool 
technical report digital systems laboratory helsinki university technology espoo 
implementing ctl model checker 
proceedings workshop concurrency specication programming nr 
humboldt university berlin pp 

holzmann design validation computer protocols 
prentice hall 
tarjan depth rst search linear graph algorithms 
siam journal computing pp 

new model checking algorithm time nets 
nr 
humboldt university berlin 
prod manual 
technical report digital systems laboratory helsinki university technology espoo 
linear local model checking algorithm ctl 
best 
ed proceedings th international conference concurrency theory lecture notes computer science springerverlag berlin pp 

willems wolper partial order methods model checking linear time branching time 
proceedings th annual ieee symposium logic computer science ieee computer society press pp 

ccitt specication description language sdl 
technical report itu 
appendix mutex example prod description define nc define try define cs define place lo nc 
hi cs 
mk nc 
place lo 
hi 
mk 
trans idle nc nc trans try nc turn try turn 
turn turn trans critical try cs trans noncritical cs 
turn nc 
try 
try ii appendix initialization routines proc length od subroutine 
proc sub null lef gamma sub sub lef break od subroutine 
iii proc sub null right gamma sub sub right break od subroutine 
