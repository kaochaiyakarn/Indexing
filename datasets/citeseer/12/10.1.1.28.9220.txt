directions functional programming real time applications walid taha paul hudak wan department computer science yale university new haven ct usa 
hudak cs yale edu 
review basics functional programming give brief emerging techniques approaches relevant building real time software 
doing attempt explain relevance functional programming concepts real time applications domain 
particular address types classify properties real time computations 
thought corrupts language language corrupt thought 
george politics english language important challenge facing functional programming successful application principles domain real time software 
examples real time software include controllers audio systems video cameras video games imaging data acquisition systems telecommunications hardware 
significance challenge fold real time applications constantly growing complexity society growing dependent correctness 
second real time applications possess characteristics traditionally considered outside scope functional programming languages 
example real time systems required responsive reactive live response input 
resource bounded responses happen limited amount time limited hardware 
concurrent components may run parallel manipulate shared data 
networked distributed communication components system may involve time delays loss information 
purpose illustrate fundamental aspects functional programming highly relevant programming funded darpa nsf ccr 
funded nsf itr subcontract johns hopkins university nsf agreement eia 
taha hudak wan understanding real time systems 
long tradition mathematical modeling functions summarize key benefits functional programming 
doing put context going efforts outside area functional programming address issues specific real time domain 
audience organization classic hughes presents excellent motivation general purpose functional programming 
aimed reader interested functional programming real time applications 
assume reader background discrete mathematics years experience programming mainstream language informal familiarity basic programming language concepts 
focus programming writing composing functions section understanding notion types type systems section higher order functions section presence wealth formal semantics treatments various aspects functional languages section 
big deal functions sets functions apart arbitrary relations simple properties sets relation function written satisfies totality exists element uniqueness write denote unique element relation satisfies uniqueness called partial function 
framework allows model programs functions input output natural appeal context real time systems properties desirable totality means program respond input uniqueness means program return result subjected input 
may hard see simple intuition scales complex settings key quality functions compose naturally surprising interactions 
section brief review state art functional programming languages programming languages real time applications 
proceed illustrate language functions expressive tool specifying real time computational models 
functional programming real time applications state art wide variety functional programming languages available today including scheme sml haskell ocaml 
provides full support programming functions sense described reasons 
permit definition partial functions leading potentially non terminating computations 
second haskell languages purely functional allow expression imperative programs violate uniqueness property 
example scheme highly expressive versatile programming language historically main goal list symbolic processing programming functions 
scheme statically typed express impure functions depend implicitly interactions machine state real world 
ml ocaml typed functional languages permit partial imperative computations 
popular languages haskell comes closest purely functional local state interactions real world modeled side effects 
interactions typed explicitly see discussion monads ensuring type reflects interactive properties 
time haskell provides special syntax imperative features 
presents concepts generic mathematical notation fairly straightforward encode equations haskell 
frameworks fully support programming functions 
important examples systems elementary strong functional programming nuprl martin type theory calculus constructions charity lego twelf 
languages mainstream predict grow popularity coming years 
functional programming real time applications languages developed real time domain imperative esterel statecharts number languages expressly functional including lustre synchronous kahn networks frp 
essentially imperative ones deterministic satisfying uniqueness terminating satisfying totality reasonable classify functional 
statement surprising note haskell supports encourages imperative style long sideeffects properly encapsulated 
guarantee termination real time languages disallow general recursion 
synchronous kahn networks developed extension lustre provides recursion higher order programming termination sacrificed expressivity 
implementations lustre macro esterel translates programs circuits state machines circuits analysed ensure determinism 
taha hudak wan facility supports recursion runs risk causing compiler diverge 
frp embedded haskell inherits recursion non termination 
rt frp subset frp guarantees program execution interactive rt frp computation terminates 
special type system rt frp allows forms recursion similar spirit idea tail recursion 
rt frp closed language possible guarantee partiality accidentally introduced 
functions tool analysis modeling computation temporarily away issues performance practically interesting features program behavior specified precisely functions 
means easily simulate prototype interesting computational phenomena functional language 
believe tremendous conceptual benefits long term impact software engineering processes 
follows give brief description computational phenomena review described purely functional manner 
input output uniqueness interaction function implicitly interact outside world course computation 
possible time applied value produce different output 
words computation uniqueness property 
simple approach modeling computations view chain functions determine successive interactions outside world 
types input output recursive type equation written describe computation follows computation input 
output computation equation says computation function takes input returns pair 
pair consists output computation computation carried input 
type computation models strictly infinite sequence interactions outside world long outside world providing input 
model computations suited reactive interactive systems 
number reactive languages lava hawk frp streams implement idea 
streams infinite datastructures easily defined lazy language 
systems developed languages embedded haskell 
rt frp implements model closed language suitable direct real time setting 
functional programming real time applications runtime errors partiality common challenge encounters trying model various features computation functions dealing partiality 
example consider definition defined 
definitions similar allowed programming languages statically typed ones guarantee runtime errors occur 
flaw languages guarantee preclusion specific class runtime errors 
start primitives division generate runtime errors errors generally ignored type systems 
design real time systems raising errors simply acceptable primitives concern 
possible prevent errors replacing faulty set primitives modified set 
example define new division function elegant way dealing partiality introduce distinguished value 
read bottom returned case error 
introduce value type sound manner lifting type constructor defined follows intuitively specification read parameterized bnf definition 
variable left hand side type variable instantiated specific type right hand side denotes term type 
variant definition tells type type second variant tells term type term type type constructor standard concept allows say may may get value result useful modeling partiality 
redefine division function need check result operation continue computations 
infinite loops turing complete language known write programs run forever returning result 
means directly treat arbitrary programs functions 
provide functional models programs 
fact combination implementations typed functional programming languages known option type 
taha hudak wan techniques just introduced 
sum type constructor takes type parameters defined follows alpha beta new constructor allows package values different types common type retain ability recover original values 
term type term alpha type type beta variant lets things way 
define new kind computation computation input initialized computation initialized computation output initialized computation computation takes input returns initialized computation 
initialized computation output case done initialized computation 
second case try 
intuitively model similar observing turing machine performs step program 
program finished generates output 
get back machine advanced step try 
note model computation intuitively special case model interaction 
idea provide form recursion suitable real time applications rt frp 
concurrency randomness non determinism sets possibly biggest conceptual challenge programming functions non determinism 
applications try take advantage concurrency randomness having deal non determinism form 
basic approach modeling non determinism functional setting sets 
naive account sets get way programming functionally 
example order elements set generally considered irrelevant 
language provides mechanism turning arbitrary set ordered data structure list language forcing choices order elements fixed mechanism weaken ability model non determinism accurately mechanism turning sets lists nondeterministic case lose uniqueness property language simple approach soundly modeling set characteristic function set bool example specific set integers represented characteristic function type int bool 
representation easy define basic sums provide kind overloading 
functional programming real time applications set theoretic functions union intersection complement membership 
slightly richer models allow define operations sets size 
large body techniques exist specification functional data structures reasonable performance characteristics 
model concurrent distributed computation consider effect running interactive computations simultaneously 
model explicitly construct set possible interactions computations 
reasoning model easier non deterministic computation function help identify sources complexity 
stateful computation pure functions memory 
matter function applied return result input 
write program reads sequence numbers continually prints sum numbers point 
essential idea explicitly pass relevant state 
fact interactive model earlier suitable realizing idea 
computation type computation int 
int computation function takes input returns current sum output computation continues process indefinitely 
idea exploited rt frp example realize operations integration 
types type systems addition traditional role programming types important role classification models data structures 
section presenting possible application types tool classifying models computation real time applications move discuss newly emerging role tool making assertions performance 
types tool classifying models computation model theory developed partly tool classification various mathematical structures 
types models computation 
general think reactive system map takes input environment returns output accuracy tractability appropriateness particular model depends specifics variables 
particularly important aspect models treatment time clock treated taha hudak wan concretely real number abstractly natural number abstractly partial order 
follows briefly demonstrate types capture key characteristics common models reactive systems 
continuous differential model finest scale model physical world newtonian sense achieved time line reals measuring features world real numbers 
assume respond measurements manner long causal 
mathematically model natural numbers corresponding number inputs outputs system cartesian product repeated times 
restriction domain captures standard constraint causal 
finding solutions equations unconstrained extremely hard 
restrict model tractable transformation reals 
example may restrict ordinary differential equations 
case polynomial integro differential operators inputs model extremely accurate applications ignores digital aspect machinery typically implement computations 
discrete difference model tractable model discrete model 
formal sense model approximation 
described follows case typically polynomial values times synchronous reactive model real time programming languages built notion synchronous computation 
literature word synchrony meanings corresponding important properties synchronous languages implies ability share common time scale logic time advance computations current step completed second elements streams consumed soon produced making possible allocate cell stream 
part definition discrete model 
second performance issue determined primitives allowed combining signals 
key change model view possible conditionals partial functional programming real time applications functions signals 
point view minor variation model 

initial state 
important change memory system restricted fixed size width 
constant developments exact arithmetic methods model realized quite effectively 
finite state machine model reals general require arbitrary amount space represent 
analyzing space requirements non trivial highly tractable model attractive finite state machines 
model described follows bit input bit state main difference model previous set inputs states restricted finite 
yields model computation especially tractable easy analyze reasonably small state sizes 
state machine model model generalization finite state machines state consists term just fixed number bits 
size term finite static limit size 
term input term state discrete event event driven model increasingly popular model discrete event model 
viewed special case finite state machine model updating special set inputs event drives global clock 
model described follows event input output nth event occurs system life 
called models special cases discrete event models events planned occur fixed intervals 
taha hudak wan types performance functional programming languages lambda calculus 
untyped lambda calculus deterministic terminating 
fact absence recursion primitives may introduce partiality programs simply typed lambda calculus terminating see hindley excellent 
true sophisticated typed lambda calculi calculus constructions 
typing essential lambda calculus language programming functions 
type systems guarantee termination require super exponential time 
means traditional typed lambdacalculus suitable real time domain 
advent modern concepts type systems proving useful characterizing resource consumption finer level 
give brief developments section 
functors di functors functor essentially data type list 
type list functor allows form type list list values type adding functors language extend expressivity ways 
data types functors concrete 
list usually concrete data type 
modern programming languages allow users introduce new functors data type declarations class instances 
functors hand allow go defined language provide powerful encapsulation mechanisms 
example consider situation want handle values type computations yield evaluated diverge 
introduce data type functional setting losing uniqueness totality 
interesting problems addressed variety functors monads question raised example turns fundamental 
expanded include computational effects non termination state concurrency exceptions 
particular flavor functors called monads shown suitable precisely 
monad wide variety effectful computations passed combined extended purely functional setting 
linear types kind functor linear logic 
linear logic provides means expressing notion resource lambda calculus 
area shown linear types build expressive programming languages dynamic data structures compiled malloc free 
exactly system build language programs run constant space take polynomial time execute 
programs languages terminating 
functional programming real time applications reactivity frp built functors called behavior event corresponding continuous time behaviors discrete event occurrences 
semantically type constructors rt frp implicit types 
achieved having specialized type system addresses reactive part frp 
staging multi stage languages key ideas multilevel level languages provide mechanisms building programs execute multiple distinct stages 
achieved providing constructs building combining executing code runtime 
presence constructs provides hygienic program generation reflection mechanisms statically typed framework 
multi stage languages provide basis heterogeneous languages combine traditional language framework 
languages provide functor code 
notion code usually possible inspect text 
accurate way describing kind code stage computation 
variant code functor rt frp model annotations variables type marked participate computations base language 
allows certain kind cyclic definitions detected statically ensure totality 
aware results multi stage programming setting 
mckay singh partial evaluation dynamic specialization fpgas 
see important direction research 
arrows noted useful distinguish kinds types functor parameterized input types output types 
gives rise particular brand di functors called arrows 
arrows viewed generalization monads shown model variety interesting kinds computations 
efforts way explore utility notion arrows frp 
type effect systems indexed types approach increasing power type systems enrich types annotations capture additional information value 
early example approach effect system talpin jouvelot introduce side effects functional manner 
system type impure function enriched information variables read written executed 
approach alternative monads 
instances equivalent 
effects develop region memory management 
approach type carries name region allocated addition standard effect information 
reader familiar subtyping distinction alluded related contra variance type constructors 
taha hudak wan enables safe high level form explicit allocation deallocation memory 
explicit memory management execution programs predictable left garbage collector 
effects build type system multi threaded language freedom deadlocks statically tested 
sized types types enriched capture amount space needed store value 
example list length carrying values type type list 
idea build languages reactive systems properties termination resource boundedness verified statically 
especially interesting aspect rules explicitly encodes induction principle allows programmer recursion long type system check founded 
idea explored context execution model reactive systems viewed stream processors rates various streams different key constraint ensure liveness output 
shown sized types region effects combined naturally order system 
ideas dependent typing crary weirich develop type system provides explicit upper bound number steps needed complete computation 
space conservatively bounded bound time 
language recursion provides special iterators guaranteed terminate 
language supports higher order functions 
lustre synchronous kahn networks notion clock calculus essentially type system characterizing clocks underlying expression 
programs typed system pass cyclic dependency test guaranteed behaved 
higher order functions intuitively higher order functions programming patterns 
formally higherorder functions ones take functions arguments return functions results 
seen usefulness returning functions various models computations discussed earlier 
particular provides ability build new functions evolved versions older ones 
passing functions arguments equally useful provides mechanism parameterizing programs functions 
consider example pattern performing point wise operations elements container type list 
way write recursive iterative program time want carry pattern 
higher order functions capture pattern function call map type map list 
list functional programming real time applications presence higher order functions drastically enhance expressivity programming language 
higher order programming generally supported programming languages intended real time domain 
notable exceptions frp synchronous kahn networks 
main reason harder guarantee resource boundedness presence higher order functions 
rt frp example higher order functions supported directly 
mathematical semantics semantics programming language mathematical specification programming language supposed 
semantics necessarily 
colorful spectrum ways define semantics programming language 
number balanced textbook treatments various approaches exist advanced studies 
flavors semantics viewed strong contrast denotational semantics operational semantics 
denotational semantics generally translation syntax mathematical domain called meaning denotation syntax 
concerned traditional program equivalence subtle technical subject 
denotational semantics frequently chosen simplest semantics 
simplicity 
abstractness perfect interested reasoning program equivalence disadvantages practitioner mathematical background understand 
second 
example denotational semantics traditionally describe cost computation crucial concern real time applications 
operational semantics generally set rules building computation provide basis discussing performance 
originally promoted plotkin years approach gained substantial popularity 
combined typing operational techniques provide powerful proof techniques 
essentially languages mentioned kind formal semantics 
large effort develop semantics esterel including denotational semantics point view scott ternary logic operational semantics interpretation scheme expressed term rewriting rules defining microstep sequences circuit semantics translation programs circuits 
semantics shown correspond certain way constrained notion stability 
distinguishing characteristic frp continuous time denotational semantics 
shown stream implemen taha hudak wan tation frp converges semantics limit sampling intervals drop zero modulo uniform continuity conditions 
rt frp deterministic operational semantics 
semantics allows notion cost defined terms derivation size necessary proving rt frp resource bounded 
learn 
jones presents language account complexity computability 
hofmann presents detailed overview results area programming languages capture complexity classes 
implementations purely functional programming languages number introductions programming haskell serve excellent subject 
di cosmo monograph isomorphisms types hindley treatment simply typed lambda calculus excellent introductions types sense 
lee gives overview ongoing efforts fit greater picture transferring software engineering techniques area embedded real time systems 
discussed traditional real time techniques rate monotonic scheduling 
expect approaches fit traditional frameworks concurrency approaches discussed encapsulation concurrency apply 
acknowledgments bellegarde adriana bill harrison gordon pace john peterson reading giving feedback earlier draft 

klaus helmut schwichtenberg 
syntactical analysis non polynomial time computation 
symposium logic computer science lics pages 
ieee june 

stuart allen robert constable richard eaton christoph kreitz lori 
nuprl open logical environment 
mcallester editor international conference automated deduction volume lecture notes artificial intelligence pages 
springer verlag 

john backus 
programming liberated von neumann style 
functional style algebra programs 
communications acm 

henk barendregt 
lambda calculus syntax semantics volume studies logic foundations mathematics 
north holland amsterdam revised edition 
functional programming real time applications 
henk barendregt 
lambda calculi types 
abramsky gabbay maibaum editors handbook logic computer science 
oxford university press oxford 

nick benton philip wadler 
linear logic monads lambda calculus 
symposium logic computer science lics new brunswick 
ieee computer society press 

gerard berry 
real time programming special purpose general purpose languages 
ifip world computer congress san francisco 

gerard berry 
constructive semantics pure esterel draft version 
draft version ecole des mines de paris inria july 

gerard berry esterel team 
esterel system manual 
centre de ecole des mines de paris inria march 
available www inria fr meije esterel 

manfred broy 
fixed point approach applicative multi programming 
lecture notes 
international summer school theoretical foundations programming methodology 

cristiano 
stratified operational semantics safety correctness region calculus 
symposium principles programming languages popl 

cristiano eugenio moggi walid taha 
closed types simple approach safe imperative multi stage programming 
international colloquium automata languages programming icalp volume lecture notes computer science pages geneva 
springer verlag 

luca cardelli 
typeful programming 
neuhold paul editors formal description programming concepts ifip state art reports pages 
springer verlag new york 

luca cardelli 
type systems 
allen jr tucker editor computer science engineering handbook 
crc press 

paul caspi halbwachs halbwachs nicolas pilaud john plaice 
lustre declarative language programming synchronous systems 
symposium principles programming languages popl january 

paul caspi marc 
synchronous kahn networks 
international conference functional programming icfp pages philadelphia pennsylvania may 

church 
calculi lambda conversion 
princeton university press princeton 

koen claessen 
embedded languages describing verifying hardware 
phd thesis chalmers 

robin cockett spencer 
strong categorical datatypes seely editor proceedings international summer category theory meeting montreal quebec june volume canadian mathematical society conf 
proceedings pages 
american mathematical society providence ri 

robin cockett spencer 
strong categorical datatypes ii term logic categorical programming 
theoretical computer science 

thierry coquand gerard huet 
theory constructions 
international symposium semantics data types sophia antipolis 

antony courtney conal elliott 
genuinely functional user interfaces 
proceedings haskell workshop september 
taha hudak wan 
patrik cousot 
constructive design hierarchy semantics transition system interpretation 
mathematical foundations programming semantics 

karl crary stephanie weirich 
resource bound certification 
symposium principles programming languages popl pages january 
acm press 

rowan davies 
temporal logic approach binding time analysis 
symposium logic computer science lics pages new brunswick 
ieee computer society press 

rowan davies frank pfenning 
modal analysis staged computation 
symposium principles programming languages popl pages st petersburg beach 

roberto di cosmo 
isomorphisms types calculus information retrieval language design 
progress theoretical computer science 
birkhauser 

gilles dowek amy felty hugo herbelin gerard huet chet murthy catherine parent christine paulin mohring benjamin werner 
coq proof assistant user guide 
rapport techniques inria rocquencourt france 
version 

abbas edalat peter john potts 
new representation exact real numbers 
notes theoretical computer science pp 
mathematical foundations programming semantics pittsburgh pa 

conal elliott paul hudak 
functional reactive animation 
international conference functional programming pages june 

john peterson haskell non strict purely functional language 
technical report yaleu dcs rr department computer science yale university mar 
world wide web version haskell cs yale edu haskell report 

cormac flanagan martn abadi 
types safe locking 
european symposium programming esop volume lecture notes computer science pages 
springer verlag 

robert gl jesper jrgensen 
fast binding time analysis multi level specialization 
bjrner manfred broy igor editors perspectives system informatics volume lecture notes computer science pages 
springer verlag 

goguen 
typed operational semantics type theory 
phd thesis university edinburgh 

andrew gordon 
functional programming input output 
distinguished dissertations computer science 
cambridge university press september 

carl gunter 
semantics programming languages 
mit press 

david harel 
statecharts visual formalism complex systems 
science computer programming june 

peter henderson 
functional programming formal specification rapid prototyping 
ieee transactions software engineering 

roger hindley 
basic simple type theory volume cambridge tracts theoretical computer science 
cambridge university press cambridge 

hoare 
communicating sequential processes 
comm 
acm 

hoare 
communicating sequential processes 
prentice hall 

hodges 
shorter model theory 
cambridge university press 

martin hofmann 
linear types non size increasing polynomial time computation 
symposium logic computer science lics pages 
ieee july 
functional programming real time applications 
martin hofmann 
programming languages capturing complexity classes 
sigact news acm special interest group automata computability theory 

martin hofmann 
type system bounded space functional place update 
nordic journal computing winter 

paul hudak 
haskell school expression learning functional programming multimedia 
cambridge university press new york 

paul hudak joe fasel 
gentle haskell 
acm sigplan notices may 

hughes 
functional programming matters 
technical report programming methodology group chalmers university technology november 

hughes lars pareto 
recursion dynamic data structures bounded space embedded ml programming 
proceedings fourth acm sigplan international conference functional programming icfp volume acm sigplan notices pages september 
acm press 

hughes lars pareto amr sabry 
proving correctness reactive systems sized types 
guy steele jr editor proceedings acm symposium principles programming languages popl volume st petersburg florida 
acm press 

neil jones 
computability complexity programming perspective 
foundations computing 
mit press cambridge ma usa 

neil jones gomard 
partial evaluator untyped lambda calculus 
diku report university copenhagen copenhagen denmark 
extended version 

neil jones gomard bondorf danvy mogensen 
partial evaluator lambda calculus 
ieee international conference computer languages pages 

richard kieburtz 
taming effects monadic typing 
international conference functional programming icfp volume acm sigplan notices pages 
acm june 

richard kieburtz 
real time reactive programming embedded controllers 
available author home page march 

richard kieburtz 
implementing closed domain specific languages 
pages 

leslie lamport 
time clocks ordering events distributed system 
communications acm 

edward lee 
ahead embedded software 
ieee computer september 

edward lee 
computing embedded systems 
ieee instrumentation measurement technology conference budapest hungary 

xavier leroy 
objective caml 
available caml inria fr ocaml 

zhaohui luo robert pollack 
lego proof development system user manual 
technical report ecs lfcs university edinburgh may 

john matthews byron cook john launchbury 
microprocessor specification hawk 
proceedings international conference computer languages pages 
ieee computer society press 

nicholas mckay singh 
dynamic specialization xc fpgas partial evaluation 
reiner hartenstein andres editors taha hudak wan international workshop field programmable logic applications volume lecture notes computer science pages 
springer verlag 

robin milner 
calculus communicating systems volume lecture notes computer science 
springer verlag 

robin milner 
communication concurrency 
international series computer science 
prentice hall 

robin milner mads tofte robert harper david macqueen 
definition standard ml revised 
mit press 

john mitchell 
foundations programming languages 
mit press cambridge 

eugenio moggi 
notions computation monads 
information computation 

andrew moran david sands 
improvement lazy context operational theory call need 
symposium principles programming languages popl pages san antonio texas january 
acm 

alan mycroft richard sharp 
statically allocated parallel functional language 
automata languages programming pages 

flemming nielson hanne riis nielson 
level semantics code generation 
theoretical computer science 

hanne nielson nielson 
semantics applications formal 
john wiley sons chichester 
available online www daimi au dk bra wiley book wiley html 

bengt nordstr om 
alf proof editor 
proceedings workshop types proofs programs pages nijmegen 

bengt nordstr om kent peterson jan smith 
programming martin lof type theory volume 
oxford university press new york ny 

chris okasaki 
higher order functions parsing want sixth order function 
journal functional programming march 

chris okasaki 
purely functional data structures 
cambridge university press cambridge uk 

oregon graduate institute technical reports 
box portland usa 
available online ftp cse ogi edu pub tech reports readme html 
viewed august 

paul hudak simon peyton jones philip wadler brian boutel john fairbairn joseph fasel maria guzman kevin hammond john hughes thomas johnsson dick kieburtz nikhil partain john peterson 
report programming language haskell 
sigplan notices section 

simon peyton jones philip wadler 
imperative functional programming 
symposium principles programming languages popl 
january 


frank pfenning carsten sch 
system description twelf metalogical framework deductive systems 
ganzinger editor international conference automated deduction cade pages trento italy july 
springer verlag lnai 

andrew pitts 
operationally theories program equivalence 
dybjer andrew pitts editors semantics logics computation 
cambridge university press 
lectures ii summer school semantics logics computation isaac newton institute mathematical sciences cambridge uk september 
functional programming real time applications 
gordon plotkin 
powerdomain construction 
siam journal computing september 

gordon plotkin 
structural approach operational semantics 
technical report computer science department aarhus university 

gordon plotkin 
operational semantics csp 
technical report university edinburgh department computer science 

jean claude jean vuillemin 
operational semantic equivalence recursive programs 
jacm october 

jonathan rees william clinger abelson adams iv brooks dybvig friedman halstead hanson haynes kohlbecker pitman sussman wand 
revised report algorithmic language scheme 
technical report ai memo mit press 

david sands 
nave time analysis theory cost equivalence 
journal logic computation 

michael smyth 
powerdomains 
mathematical foundations computer science symposium volume lecture notes computer science pages 
springer verlag 

joseph stoy 
mathematical aspects functional programming 
john darlington peter henderson david turner editors functional programming applications pages 
cambridge university press 

walid taha 
multi stage programming theory applications 
phd thesis oregon graduate institute science technology 
available 

walid taha editor 
semantics applications implementation program generation volume lecture notes computer science montreal 
springer verlag 

walid taha tim sheard 
multi stage programming explicit annotations 
proceedings symposium partial evaluation semantic program manipulation pepm pages amsterdam 
acm press 

jean pierre talpin pierre jouvelot 
type effect discipline 
scedrov editor proceedings logics computer science conference pages 
ieee 

alastair david turner 
ensuring streams flow 
michael johnson editor algebraic methodology software technology th international conference amast sydney australia december volume lecture notes computer science pages 
amast springer verlag december 

mads tofte jean pierre talpin 
region memory management 
information computation february 

david turner 
functional programs executable specifications 
philosophical transactions royal society london 

philip wadler 
essence functional programming 
symposium principles programming languages popl pages 
acm january 

philip wadler 
marriage effects monads 
international conference functional programming icfp volume acm sigplan notices pages 
acm june 

wan paul hudak 
functional reactive programming principles 
symposium programming language design implementation pldi 
acm 

wan walid taha paul hudak 
real time frp 
international conference functional programming icfp florence italy september 

hongwei xi 
upper bounds application 
journal symbolic logic march 
